import { IndexOf, Dictionary } from './common';
export interface IterableWithLinq<T> extends Iterable<T> {
    linq: IterableWithLinq<T>;
    any(predicate?: (each: T) => boolean): boolean;
    all(predicate: (each: T) => boolean): boolean;
    bifurcate(predicate: (each: T) => boolean): Array<Array<T>>;
    concat(more: Iterable<T>): IterableWithLinq<T>;
    distinct(selector?: (each: T) => any): IterableWithLinq<T>;
    duplicates(selector?: (each: T) => any): IterableWithLinq<T>;
    first(predicate?: (each: T) => boolean): T | undefined;
    selectNonNullable<V>(selector: (each: T) => V): IterableWithLinq<NonNullable<V>>;
    select<V>(selector: (each: T) => V): IterableWithLinq<V>;
    selectMany<V>(selector: (each: T) => Iterable<V>): IterableWithLinq<V>;
    where(predicate: (each: T) => boolean): IterableWithLinq<T>;
    forEach(action: (each: T) => void): void;
    aggregate<A, R>(accumulator: (current: T | A, next: T) => A, seed?: T | A, resultAction?: (result?: T | A) => A | R): T | A | R | undefined;
    toArray(): Array<T>;
    results(): Promise<void>;
    toDictionary<TValue>(keySelector: (each: T) => string, selector: (each: T) => TValue): Dictionary<TValue>;
    toMap<TKey, TValue>(keySelector: (each: T) => TKey, selector: (each: T) => TValue): Map<TKey, TValue>;
    groupBy<TKey, TValue>(keySelector: (each: T) => TKey, selector: (each: T) => TValue): Map<TKey, Array<TValue>>;
    /**
       * Gets or sets the length of the iterable. This is a number one higher than the highest element defined in an array.
       */
    count(): number;
    /**
      * Adds all the elements of an array separated by the specified separator string.
      * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
      */
    join(separator?: string): string;
}
/** returns an IterableWithLinq<> for keys in the collection */
export declare function keys<K, T>(source: Map<K, T> | null | undefined): IterableWithLinq<K>;
export declare function keys<T, TSrc extends Dictionary<T>>(source: Dictionary<T> | null | undefined): IterableWithLinq<string>;
export declare function keys<T, TSrc extends Array<T>>(source: Array<T> | null | undefined): IterableWithLinq<number>;
export declare function keys<K, T, TSrc>(source: any | undefined | null): IterableWithLinq<any>;
/** returns an IterableWithLinq<> for values in the collection
 *
 * @note - null/undefined/empty values are considered 'empty'
*/
export declare function values<K, T, TSrc extends (Array<T> | Dictionary<T> | Map<K, T>)>(...sources: Array<(Iterable<T> | Array<T> | Dictionary<T> | Map<K, T> | Set<T>) | null | undefined>): IterableWithLinq<T>;
/** returns an IterableWithLinq<{key,value}> for the source */
export declare function items<K, T, TSrc extends (Array<T> | Dictionary<T> | Map<K, T> | undefined | null)>(source: TSrc & (Array<T> | Dictionary<T> | Map<K, T>) | null | undefined): IterableWithLinq<{
    key: IndexOf<TSrc>;
    value: T;
}>;
export declare function length<T, K>(source?: string | Iterable<T> | Dictionary<T> | Array<T> | Map<K, T> | Set<T>): number;
//# sourceMappingURL=new-linq.d.ts.map