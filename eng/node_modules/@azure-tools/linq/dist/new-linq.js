"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.length = exports.items = exports.values = exports.keys = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const common_1 = require("./common");
/* eslint-disable */
function linqify(iterable) {
    if (iterable['linq'] === iterable) {
        return iterable;
    }
    const r = {
        [Symbol.iterator]: iterable[Symbol.iterator].bind(iterable),
        all: all.bind(iterable),
        any: any.bind(iterable),
        bifurcate: bifurcate.bind(iterable),
        concat: concat.bind(iterable),
        distinct: distinct.bind(iterable),
        duplicates: duplicates.bind(iterable),
        first: first.bind(iterable),
        select: select.bind(iterable),
        selectMany: selectMany.bind(iterable),
        selectNonNullable: selectNonNullable.bind(iterable),
        toArray: toArray.bind(iterable),
        where: where.bind(iterable),
        forEach: forEach.bind(iterable),
        aggregate: aggregate.bind(iterable),
        join: join.bind(iterable),
        count: len.bind(iterable),
        results: results.bind(iterable),
        toDictionary: toDictionary.bind(iterable),
        toMap: toMap.bind(iterable),
        groupBy: groupBy.bind(iterable),
    };
    r.linq = r;
    return r;
}
function len() {
    return length(this);
}
function keys(source) {
    //export function keys<K, T, TSrc extends (Array<T> | Dictionary<T> | Map<K, T>)>(source: TSrc & (Array<T> | Dictionary<T> | Map<K, T>) | null | undefined): IterableWithLinq<IndexOf<TSrc>> {
    if (source) {
        if (Array.isArray(source)) {
            return linqify(source.keys());
        }
        if (source instanceof Map) {
            return linqify(source.keys());
        }
        if (source instanceof Set) {
            throw new Error('Unable to iterate keys on a Set');
        }
        return linqify((Object.getOwnPropertyNames(source)));
    }
    // undefined/null
    return linqify([]);
}
exports.keys = keys;
function isIterable(source) {
    return !!source && !!source[Symbol.iterator];
}
/** returns an IterableWithLinq<> for values in the collection
 *
 * @note - null/undefined/empty values are considered 'empty'
*/
function values(...sources) {
    return linqify({
        [Symbol.iterator]: function* () {
            for (const each of sources) {
                yield* _values(each);
            }
        }
    });
}
exports.values = values;
/** returns an IterableWithLinq<> for values in the collection */
function _values(source) {
    if (source) {
        // map
        if (source instanceof Map || source instanceof Set) {
            return linqify(source.values());
        }
        // any iterable source
        if (isIterable(source)) {
            return linqify(source);
        }
        // dictionary (object keys)
        return linqify(function* () {
            for (const key of keys(source)) {
                const value = source[key];
                if (typeof value !== 'function') {
                    yield value;
                }
            }
        }());
    }
    // null/undefined
    return linqify([]);
}
/** returns an IterableWithLinq<{key,value}> for the source */
function items(source) {
    if (source) {
        if (Array.isArray(source)) {
            return linqify(function* () { for (let i = 0; i < source.length; i++) {
                yield { key: i, value: source[i] };
            } }());
        }
        if (source instanceof Map) {
            return linqify(function* () { for (const [key, value] of source.entries()) {
                yield { key, value };
            } }());
        }
        if (source instanceof Set) {
            throw new Error('Unable to iterate items on a Set');
        }
        return linqify(function* () {
            for (const key of keys(source)) {
                const value = source[key];
                if (typeof value !== 'function') {
                    yield {
                        key,
                        value: source[key]
                    };
                }
            }
        }());
    }
    // undefined/null
    return linqify([]);
}
exports.items = items;
function length(source) {
    if (source) {
        if (Array.isArray(source) || typeof (source) === 'string') {
            return source.length;
        }
        if (source instanceof Map || source instanceof Set) {
            return source.size;
        }
        if (isIterable(source)) {
            return [...source].length;
        }
        return source ? Object.getOwnPropertyNames(source).length : 0;
    }
    return 0;
}
exports.length = length;
function toDictionary(keySelector, selector) {
    const result = new common_1.Dictionary();
    for (const each of this) {
        result[keySelector(each)] = selector(each);
    }
    return result;
}
function toMap(keySelector, selector) {
    const result = new Map();
    for (const each of this) {
        result.set(keySelector(each), selector(each));
    }
    return result;
}
function groupBy(keySelector, selector) {
    var _a;
    const result = new Map();
    for (const each of this) {
        const key = keySelector(each);
        if (!result.has(key)) {
            result.set(key, new Array());
        }
        (_a = result.get(key)) === null || _a === void 0 ? void 0 : _a.push(selector(each));
    }
    return result;
}
function any(predicate) {
    for (const each of this) {
        if (!predicate || predicate(each)) {
            return true;
        }
    }
    return false;
}
function all(predicate) {
    for (const each of this) {
        if (!predicate(each)) {
            return false;
        }
    }
    return true;
}
function concat(more) {
    return linqify(function* () {
        for (const each of this) {
            yield each;
        }
        for (const each of more) {
            yield each;
        }
    }.bind(this)());
}
function select(selector) {
    return linqify(function* () {
        for (const each of this) {
            yield selector(each);
        }
    }.bind(this)());
}
function selectMany(selector) {
    return linqify(function* () {
        for (const each of this) {
            for (const item of selector(each)) {
                yield item;
            }
        }
    }.bind(this)());
}
function where(predicate) {
    return linqify(function* () {
        for (const each of this) {
            if (predicate(each)) {
                yield each;
            }
        }
    }.bind(this)());
}
function forEach(action) {
    for (const each of this) {
        action(each);
    }
}
function aggregate(accumulator, seed, resultAction) {
    let result = seed;
    for (const each of this) {
        if (result === undefined) {
            result = each;
            continue;
        }
        result = accumulator(result, each);
    }
    return resultAction !== undefined ? resultAction(result) : result;
}
function selectNonNullable(selector) {
    return linqify(function* () {
        for (const each of this) {
            const value = selector(each);
            if (value) {
                yield value;
            }
        }
    }.bind(this)());
}
function nonNullable() {
    return linqify(function* () {
        for (const each of this) {
            if (each) {
                yield each;
            }
        }
    }.bind(this)());
}
function first(predicate) {
    for (const each of this) {
        if (!predicate || predicate(each)) {
            return each;
        }
    }
    return undefined;
}
function toArray() {
    return [...this];
}
async function results() {
    await Promise.all([...this]);
}
function join(separator) {
    return [...this].join(separator);
}
function bifurcate(predicate) {
    const result = [new Array(), new Array()];
    for (const each of this) {
        result[predicate(each) ? 0 : 1].push(each);
    }
    return result;
}
function distinct(selector) {
    const hash = new common_1.Dictionary();
    return linqify(function* () {
        if (!selector) {
            selector = i => i;
        }
        for (const each of this) {
            const k = JSON.stringify(selector(each));
            if (!hash[k]) {
                hash[k] = true;
                yield each;
            }
        }
    }.bind(this)());
}
function duplicates(selector) {
    const hash = new common_1.Dictionary();
    return linqify(function* () {
        if (!selector) {
            selector = i => i;
        }
        for (const each of this) {
            const k = JSON.stringify(selector(each));
            if (hash[k] === undefined) {
                hash[k] = false;
            }
            else {
                if (hash[k] === false) {
                    hash[k] = true;
                    yield each;
                }
            }
        }
    }.bind(this)());
}
//# sourceMappingURL=new-linq.js.map