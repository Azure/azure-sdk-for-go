import { IndexOf, Dictionary } from './common';
export interface Linqed<T> extends Iterable<T> {
    any(predicate?: (each: T) => boolean): boolean;
    all(predicate: (each: T) => boolean): boolean;
    bifurcate(predicate: (each: T) => boolean): Array<Array<T>>;
    concat(more: Iterable<T>): Linqable<T>;
    distinct(selector?: (each: T) => any): Linqable<T>;
    first(predicate?: (each: T) => boolean): T | undefined;
    selectNonNullable<V>(selector: (each: T) => V): Linqable<NonNullable<V>>;
    select<V>(selector: (each: T) => V): Linqable<V>;
    selectMany<V>(selector: (each: T) => Iterable<V>): Linqable<V>;
    where(predicate: (each: T) => boolean): Linqable<T>;
    forEach(action: (each: T) => void): void;
    aggregate<A, R>(accumulator: (current: T | A, next: T) => A, seed?: T | A, resultAction?: (result?: T | A) => A | R): T | A | R | undefined;
    toArray(): Array<T>;
}
export interface Linqable<T> extends Iterable<T> {
    linq: {
        any(predicate?: (each: T) => boolean): boolean;
        all(predicate: (each: T) => boolean): boolean;
        bifurcate(predicate: (each: T) => boolean): Array<Array<T>>;
        concat(more: Iterable<T>): Linqable<T>;
        distinct(selector?: (each: T) => any): Linqable<T>;
        first(predicate?: (each: T) => boolean): T | undefined;
        selectNonNullable<V>(selector: (each: T) => V): Linqable<NonNullable<V>>;
        select<V>(selector: (each: T) => V): Linqable<V>;
        selectMany<V>(selector: (each: T) => Iterable<V>): Linqable<V>;
        where(predicate: (each: T) => boolean): Linqable<T>;
        forEach(action: (each: T) => void): void;
        aggregate<A, R>(accumulator: (current: T | A, next: T) => A, seed?: T | A, resultAction?: (result?: T | A) => A | R): T | A | R | undefined;
        toArray(): Array<T>;
    };
}
/** returns an Linqable<> for keys in the collection */
export declare function keys<K, T, TSrc extends (Array<T> | Dictionary<T> | Map<K, T>)>(source: TSrc & (Array<T> | Dictionary<T> | Map<K, T>) | null | undefined): Linqable<IndexOf<TSrc>>;
/** returns an Linqable<> for values in the collection */
export declare function values<K, T, TSrc extends (Array<T> | Dictionary<T> | Map<K, T>)>(source: (Iterable<T> | Array<T> | Dictionary<T> | Map<K, T>) | null | undefined): Linqable<T>;
/** returns an Linqable<> for values in the collection */
export declare function evalues<K, T, TSrc extends (Array<T> | Dictionary<T> | Map<K, T>)>(source: (Iterable<T> | Array<T> | Dictionary<T> | Map<K, T>) | null | undefined): Linqed<T>;
/** returns an Linqable<{key,value}> for the Collection */
export declare function items<K, T, TSrc extends (Array<T> | Dictionary<T> | Map<K, T>)>(source: TSrc & (Array<T> | Dictionary<T> | Map<K, T>) | null | undefined): Linqable<{
    key: IndexOf<TSrc>;
    value: T;
}>;
export declare function length<T, K>(source?: Dictionary<T> | Array<T> | Map<K, T>): number;
export declare function any<T>(this: Iterable<T>, predicate?: (each: T) => boolean): boolean;
export declare function all<T>(this: Iterable<T>, predicate: (each: T) => boolean): boolean;
export declare function concat<T>(this: Iterable<T>, more: Iterable<T>): Linqable<T>;
export declare function select<T, V>(this: Iterable<T>, selector: (each: T) => V): Linqable<V>;
export declare function selectMany<T, V>(this: Iterable<T>, selector: (each: T) => Iterable<V>): Linqable<V>;
export declare function where<T>(this: Iterable<T>, predicate: (each: T) => boolean): Linqable<T>;
export declare function forEach<T>(this: Iterable<T>, action: (each: T) => void): void;
export declare function aggregate<T, A, R>(this: Iterable<T>, accumulator: (current: T | A, next: T) => A, seed?: T | A, resultAction?: (result?: T | A) => A | R): T | A | R | undefined;
export declare function selectNonNullable<T, V>(this: Iterable<T>, selector: (each: T) => V): Linqable<NonNullable<V>>;
export declare function nonNullable<T>(this: Iterable<T>): Linqable<NonNullable<T>>;
export declare function first<T>(this: Iterable<T>, predicate?: (each: T) => boolean): T | undefined;
export declare function toArray<T>(this: Iterable<T>): Array<T>;
export declare function bifurcate<T>(this: Iterable<T>, predicate: (each: T) => boolean): Array<Array<T>>;
//# sourceMappingURL=old-linq.d.ts.map