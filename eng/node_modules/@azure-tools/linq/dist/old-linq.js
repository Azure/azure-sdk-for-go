"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bifurcate = exports.toArray = exports.first = exports.nonNullable = exports.selectNonNullable = exports.aggregate = exports.forEach = exports.where = exports.selectMany = exports.select = exports.concat = exports.all = exports.any = exports.length = exports.items = exports.evalues = exports.values = exports.keys = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const common_1 = require("./common");
/* eslint-disable */
function enlinq(iterable) {
    return {
        ...iterable,
        all: all.bind(iterable),
        any: any.bind(iterable),
        bifurcate: bifurcate.bind(iterable),
        concat: concat.bind(iterable),
        distinct: distinct.bind(iterable),
        first: first.bind(iterable),
        select: select.bind(iterable),
        selectMany: selectMany.bind(iterable),
        selectNonNullable: selectNonNullable.bind(iterable),
        toArray: toArray.bind(iterable),
        where: where.bind(iterable),
        forEach: forEach.bind(iterable),
        aggregate: aggregate.bind(iterable),
    };
}
function linqify(iterable) {
    if (iterable['linq']) {
        return iterable;
    }
    return Object.defineProperty(iterable, 'linq', {
        get: () => {
            return {
                all: all.bind(iterable),
                any: any.bind(iterable),
                bifurcate: bifurcate.bind(iterable),
                concat: concat.bind(iterable),
                distinct: distinct.bind(iterable),
                first: first.bind(iterable),
                select: select.bind(iterable),
                selectMany: selectMany.bind(iterable),
                selectNonNullable: selectNonNullable.bind(iterable),
                toArray: toArray.bind(iterable),
                where: where.bind(iterable),
                forEach: forEach.bind(iterable),
                aggregate: aggregate.bind(iterable),
            };
        }
    });
}
/** returns an Linqable<> for keys in the collection */
function keys(source) {
    if (source) {
        if (Array.isArray(source)) {
            return linqify(source.keys());
        }
        if (source instanceof Map) {
            return linqify(source.keys());
        }
        return linqify((Object.getOwnPropertyNames(source)));
    }
    // undefined/null
    return linqify([]);
}
exports.keys = keys;
function isIterable(source) {
    return !!source && !!source[Symbol.iterator];
}
/** returns an Linqable<> for values in the collection */
function values(source) {
    if (source) {
        // map
        if (source instanceof Map) {
            return linqify(source.values());
        }
        // any iterable source
        if (isIterable(source)) {
            return linqify(source);
        }
        // dictionary (object keys)
        return linqify(function* () {
            for (const key of keys(source)) {
                const value = source[key];
                if (typeof value !== 'function') {
                    yield value;
                }
            }
        }());
    }
    // null/undefined
    return linqify([]);
}
exports.values = values;
/** returns an Linqable<> for values in the collection */
function evalues(source) {
    if (source) {
        // map
        if (source instanceof Map) {
            return enlinq(source.values());
        }
        // any iterable source
        if (isIterable(source)) {
            return enlinq(source);
        }
        // dictionary (object keys)
        return enlinq(function* () {
            for (const key of keys(source)) {
                const value = source[key];
                if (typeof value !== 'function') {
                    yield value;
                }
            }
        }());
    }
    // null/undefined
    return enlinq([]);
}
exports.evalues = evalues;
/** returns an Linqable<{key,value}> for the Collection */
function items(source) {
    if (source) {
        if (Array.isArray(source)) {
            return linqify(function* () { for (let i = 0; i < source.length; i++) {
                yield { key: i, value: source[i] };
            } }());
        }
        if (source instanceof Map) {
            return linqify(function* () { for (const [key, value] of source.entries()) {
                yield { key, value };
            } }());
        }
        return linqify(function* () {
            for (const key of keys(source)) {
                const value = source[key];
                if (typeof value !== 'function') {
                    yield {
                        key,
                        value: source[key]
                    };
                }
            }
        }());
    }
    // undefined/null
    return linqify([]);
}
exports.items = items;
function length(source) {
    if (source) {
        if (Array.isArray(source)) {
            return source.length;
        }
        if (source instanceof Map) {
            return source.size;
        }
        return source ? Object.getOwnPropertyNames(source).length : 0;
    }
    return 0;
}
exports.length = length;
function any(predicate) {
    for (const each of this) {
        if (!predicate || predicate(each)) {
            return true;
        }
    }
    return false;
}
exports.any = any;
function all(predicate) {
    for (const each of this) {
        if (!predicate(each)) {
            return false;
        }
    }
    return true;
}
exports.all = all;
function concat(more) {
    return linqify(function* () {
        for (const each of this) {
            yield each;
        }
        for (const each of more) {
            yield each;
        }
    }.bind(this)());
}
exports.concat = concat;
function select(selector) {
    return linqify(function* () {
        for (const each of this) {
            yield selector(each);
        }
    }.bind(this)());
}
exports.select = select;
function selectMany(selector) {
    return linqify(function* () {
        for (const each of this) {
            for (const item of selector(each)) {
                yield item;
            }
        }
    }.bind(this)());
}
exports.selectMany = selectMany;
function where(predicate) {
    return linqify(function* () {
        for (const each of this) {
            if (predicate(each)) {
                yield each;
            }
        }
    }.bind(this)());
}
exports.where = where;
function forEach(action) {
    for (const each of this) {
        action(each);
    }
}
exports.forEach = forEach;
function aggregate(accumulator, seed, resultAction) {
    let result = seed;
    for (const each of this) {
        if (result === undefined) {
            result = each;
            continue;
        }
        result = accumulator(result, each);
    }
    return resultAction !== undefined ? resultAction(result) : result;
}
exports.aggregate = aggregate;
function selectNonNullable(selector) {
    return linqify(function* () {
        for (const each of this) {
            const value = selector(each);
            if (value) {
                yield value;
            }
        }
    }.bind(this)());
}
exports.selectNonNullable = selectNonNullable;
function nonNullable() {
    return linqify(function* () {
        for (const each of this) {
            if (each) {
                yield each;
            }
        }
    }.bind(this)());
}
exports.nonNullable = nonNullable;
function first(predicate) {
    for (const each of this) {
        if (!predicate || predicate(each)) {
            return each;
        }
    }
    return undefined;
}
exports.first = first;
function toArray() {
    return [...this];
}
exports.toArray = toArray;
function bifurcate(predicate) {
    const result = [new Array(), new Array()];
    for (const each of this) {
        result[predicate(each) ? 0 : 1].push(each);
    }
    return result;
}
exports.bifurcate = bifurcate;
function distinct(selector) {
    const hash = new common_1.Dictionary();
    return linqify(function* () {
        if (!selector) {
            selector = i => i;
        }
        for (const each of this) {
            const k = JSON.stringify(selector(each));
            if (!hash[k]) {
                hash[k] = true;
                yield each;
            }
        }
    }.bind(this)());
}
//# sourceMappingURL=old-linq.js.map