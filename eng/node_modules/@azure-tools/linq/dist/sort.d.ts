declare function ascendingInvalidLast<T>(input: Array<T>, accessor: (each: T) => number | undefined): Array<T>;
declare function descendingInvalidLast<T>(input: Array<T>, accessor: (each: T) => number | undefined): Array<T>;
declare function ascendingInvalidFirst<T>(input: Array<T>, accessor: (each: T) => number | undefined): Array<T>;
declare function descendingInvalidFirst<T>(input: Array<T>, accessor: (each: T) => number | undefined): Array<T>;
declare function sascendingInvalidLast<T>(input: Array<T>, accessor: (each: T) => string | undefined): Array<T>;
declare function sdescendingInvalidLast<T>(input: Array<T>, accessor: (each: T) => string | undefined): Array<T>;
declare function sascendingInvalidFirst<T>(input: Array<T>, accessor: (each: T) => string | undefined): Array<T>;
declare function sdescendingInvalidFirst<T>(input: Array<T>, accessor: (each: T) => string | undefined): Array<T>;
/** Sort methods that use an accessor function and uses the accessed value in the compare
 *
 * Note: array.sort puts actual undefined values at the end always, regardless of compare code.
*/
export declare const sort: {
    numericly: {
        ascendingInvalidLast: typeof ascendingInvalidLast;
        descendingInvalidLast: typeof descendingInvalidLast;
        ascendingInvalidFirst: typeof ascendingInvalidFirst;
        descendingInvalidFirst: typeof descendingInvalidFirst;
    };
    textually: {
        ascendingInvalidLast: typeof sascendingInvalidLast;
        descendingInvalidLast: typeof sdescendingInvalidLast;
        ascendingInvalidFirst: typeof sascendingInvalidFirst;
        descendingInvalidFirst: typeof sdescendingInvalidFirst;
    };
};
export {};
//# sourceMappingURL=sort.d.ts.map