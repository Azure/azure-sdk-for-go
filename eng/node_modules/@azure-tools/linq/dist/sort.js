"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sort = void 0;
const first = -1;
const second = 1;
const neither = 0;
function ascendingInvalidLast(input, accessor) {
    return input.sort((a, b) => {
        var _a, _b;
        const pA = (_a = accessor(a)) !== null && _a !== void 0 ? _a : Number.MAX_VALUE;
        const pB = (_b = accessor(b)) !== null && _b !== void 0 ? _b : Number.MAX_VALUE;
        return pA === pB ? neither : pA < pB ? first : second;
    });
}
function descendingInvalidLast(input, accessor) {
    return input.sort((a, b) => {
        var _a, _b;
        const pA = (_a = accessor(a)) !== null && _a !== void 0 ? _a : -Number.MAX_VALUE;
        const pB = (_b = accessor(b)) !== null && _b !== void 0 ? _b : -Number.MAX_VALUE;
        return pA === pB ? neither : pA > pB ? first : second;
    });
}
function ascendingInvalidFirst(input, accessor) {
    return input.sort((a, b) => {
        var _a, _b;
        const pA = (_a = accessor(a)) !== null && _a !== void 0 ? _a : -Number.MAX_VALUE;
        const pB = (_b = accessor(b)) !== null && _b !== void 0 ? _b : -Number.MAX_VALUE;
        return pA === pB ? neither : pA < pB ? first : second;
    });
}
function descendingInvalidFirst(input, accessor) {
    return input.sort((a, b) => {
        var _a, _b;
        const pA = (_a = accessor(a)) !== null && _a !== void 0 ? _a : Number.MAX_VALUE;
        const pB = (_b = accessor(b)) !== null && _b !== void 0 ? _b : Number.MAX_VALUE;
        return pA === pB ? neither : pA > pB ? first : second;
    });
}
function sascendingInvalidLast(input, accessor) {
    return input.sort((a, b) => {
        const pA = accessor(a);
        const pB = accessor(b);
        return pA === pB ? 0 : pA !== undefined ? pB !== undefined
            ? pA < pB ? first : second /* both exist */
            : first /* a exists, b undefined */
            : pB !== undefined
                ? second /* b exists, a undefined */
                : neither; /* neither exists */
    });
}
function sdescendingInvalidLast(input, accessor) {
    return input.sort((a, b) => {
        const pA = accessor(a);
        const pB = accessor(b);
        return pA === pB ? 0 : pA !== undefined ? pB !== undefined
            ? pA > pB ? first : second /* both exist */
            : first /* a exists, b undefined */
            : pB !== undefined
                ? second /* b exists, a undefined */
                : neither; /* neither exists */
    });
}
function sascendingInvalidFirst(input, accessor) {
    return input.sort((a, b) => {
        const pA = accessor(a);
        const pB = accessor(b);
        return pA === pB ? 0 : pA !== undefined ? pB !== undefined
            ? pA < pB ? first : second /* both exist */
            : second /* a exists, b undefined */
            : pB !== undefined
                ? first /* b exists, a undefined */
                : neither; /* neither exists */
    });
}
function sdescendingInvalidFirst(input, accessor) {
    return input.sort((a, b) => {
        const pA = accessor(a);
        const pB = accessor(b);
        return pA === pB ? 0 : pA !== undefined ? pB !== undefined
            ? pA > pB ? first : second /* both exist */
            : second /* a exists, b undefined */
            : pB !== undefined
                ? first /* b exists, a undefined */
                : neither; /* neither exists */
    });
}
/** Sort methods that use an accessor function and uses the accessed value in the compare
 *
 * Note: array.sort puts actual undefined values at the end always, regardless of compare code.
*/
exports.sort = {
    numericly: {
        ascendingInvalidLast,
        descendingInvalidLast,
        ascendingInvalidFirst,
        descendingInvalidFirst
    },
    textually: {
        ascendingInvalidLast: sascendingInvalidLast,
        descendingInvalidLast: sdescendingInvalidLast,
        ascendingInvalidFirst: sascendingInvalidFirst,
        descendingInvalidFirst: sdescendingInvalidFirst
    }
};
//# sourceMappingURL=sort.js.map