import { createDiagnosticCollector, emitFile, listServices, resolvePath, } from "@typespec/compiler";
import { getVersions } from "@typespec/versioning";
import { stringify } from "yaml";
import { prepareClientAndOperationCache } from "./cache.js";
import { defaultDecoratorsAllowList } from "./configs.js";
import { handleClientExamples } from "./example.js";
import { getKnownScalars, } from "./interfaces.js";
import { handleVersioningMutationForGlobalNamespace, parseEmitterName, removeVersionsLargerThanExplicitlySpecified, } from "./internal-utils.js";
import { createSdkPackage } from "./package.js";
import { listAllServiceNamespaces } from "./public-utils.js";
export function createTCGCContext(program, emitterName, options) {
    const diagnostics = createDiagnosticCollector();
    return {
        program,
        diagnostics: diagnostics.diagnostics,
        emitterName: diagnostics.pipe(parseEmitterName(program, emitterName ?? program.emitters[0]?.metadata?.name)),
        previewStringRegex: /-preview$/,
        disableUsageAccessPropagationToBase: false,
        generateProtocolMethods: true,
        generateConvenienceMethods: true,
        __referencedTypeCache: new Map(),
        __arrayDictionaryCache: new Map(),
        __modelPropertyCache: new Map(),
        __generatedNames: new Map(),
        __httpOperationCache: new Map(),
        __clientParametersCache: new Map(),
        __tspTypeToApiVersions: new Map(),
        __clientApiVersionDefaultValueCache: new Map(),
        __knownScalars: getKnownScalars(),
        __httpOperationExamples: new Map(),
        __pagedResultSet: new Set(),
        getMutatedGlobalNamespace() {
            if (options?.mutateNamespace === false) {
                // If we are not mutating the global namespace, return the original global namespace type.
                return program.getGlobalNamespaceType();
            }
            let globalNamespace = this.__mutatedGlobalNamespace;
            if (!globalNamespace) {
                globalNamespace = handleVersioningMutationForGlobalNamespace(this);
                this.__mutatedGlobalNamespace = globalNamespace;
            }
            return globalNamespace;
        },
        getApiVersionsForType(type) {
            return this.__tspTypeToApiVersions.get(type) ?? [];
        },
        setApiVersionsForType(type, apiVersions) {
            const existingApiVersions = this.__tspTypeToApiVersions.get(type) ?? [];
            const mergedApiVersions = [...existingApiVersions];
            for (const apiVersion of apiVersions) {
                if (!mergedApiVersions.includes(apiVersion)) {
                    mergedApiVersions.push(apiVersion);
                }
            }
            this.__tspTypeToApiVersions.set(type, mergedApiVersions);
        },
        getPackageVersions() {
            if (this.__packageVersions) {
                return this.__packageVersions;
            }
            const service = listServices(program)[0];
            if (!service) {
                this.__packageVersions = [];
                return this.__packageVersions;
            }
            const versions = getVersions(program, service.type)[1]?.getVersions();
            if (!versions) {
                this.__packageVersions = [];
                return this.__packageVersions;
            }
            removeVersionsLargerThanExplicitlySpecified(this, versions);
            this.__packageVersions = versions.map((version) => version.value);
            return this.__packageVersions;
        },
        getPackageVersionEnum() {
            if (this.__packageVersionEnum) {
                return this.__packageVersionEnum;
            }
            const namespaces = listAllServiceNamespaces(this);
            if (namespaces.length === 0) {
                return undefined;
            }
            return getVersions(this.program, namespaces[0])[1]?.getVersions()?.[0].enumMember.enum;
        },
        getClients() {
            if (!this.__rawClientsOperationGroupsCache) {
                prepareClientAndOperationCache(this);
            }
            return Array.from(this.__rawClientsOperationGroupsCache.values()).filter((item) => item.kind === "SdkClient");
        },
        getClientOrOperationGroup(type) {
            if (!this.__rawClientsOperationGroupsCache) {
                prepareClientAndOperationCache(this);
            }
            return this.__rawClientsOperationGroupsCache.get(type);
        },
        getOperationsForClient(client) {
            if (!this.__clientToOperationsCache) {
                prepareClientAndOperationCache(this);
            }
            return this.__clientToOperationsCache.get(client);
        },
        getClientForOperation(operation) {
            if (!this.__operationToClientCache) {
                prepareClientAndOperationCache(this);
            }
            return this.__operationToClientCache.get(operation);
        },
    };
}
export async function createSdkContext(context, emitterName, options) {
    const diagnostics = createDiagnosticCollector();
    const tcgcContext = createTCGCContext(context.program, emitterName ?? context.options["emitter-name"]);
    const generateProtocolMethods = context.options["generate-protocol-methods"] ?? tcgcContext.generateProtocolMethods;
    const generateConvenienceMethods = context.options["generate-convenience-methods"] ?? tcgcContext.generateConvenienceMethods;
    const sdkContext = {
        ...tcgcContext,
        emitContext: context,
        sdkPackage: undefined,
        generateProtocolMethods: generateProtocolMethods,
        generateConvenienceMethods: generateConvenienceMethods,
        examplesDir: context.options["examples-dir"],
        namespaceFlag: context.options["namespace"],
        apiVersion: context.options["api-version"],
        license: context.options["license"],
        decoratorsAllowList: [...defaultDecoratorsAllowList, ...(options?.additionalDecorators ?? [])],
        previewStringRegex: options?.versioning?.previewStringRegex || tcgcContext.previewStringRegex,
        disableUsageAccessPropagationToBase: options?.disableUsageAccessPropagationToBase ?? false,
        flattenUnionAsEnum: options?.flattenUnionAsEnum ?? true,
    };
    sdkContext.sdkPackage = diagnostics.pipe(createSdkPackage(sdkContext));
    for (const client of sdkContext.sdkPackage.clients) {
        diagnostics.pipe(await handleClientExamples(sdkContext, client));
    }
    sdkContext.diagnostics = sdkContext.diagnostics.concat(diagnostics.diagnostics);
    if (options?.exportTCGCoutput) {
        await exportTCGCOutput(sdkContext);
    }
    return sdkContext;
}
async function exportTCGCOutput(context) {
    await emitFile(context.program, {
        path: resolvePath(context.emitContext.emitterOutputDir, "tcgc-output.yaml"),
        content: stringify(context.sdkPackage, (k, v) => {
            if (typeof k === "string" && k.startsWith("__")) {
                return undefined; // skip keys starting with "__" from the output
            }
            if (k === "scheme") {
                const { model, ...rest } = v;
                return rest; // remove credential schema's model property
            }
            if (k === "rawExample") {
                return undefined; // remove raw example
            }
            return v;
        }, { lineWidth: 0 }),
    });
}
export async function $onEmit(context) {
    if (!context.program.compilerOptions.noEmit) {
        const sdkContext = await createSdkContext(context, undefined, { exportTCGCoutput: true });
        context.program.reportDiagnostics(sdkContext.diagnostics);
    }
}
//# sourceMappingURL=context.js.map