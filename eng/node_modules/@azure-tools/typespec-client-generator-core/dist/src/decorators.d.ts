import { DecoratorContext, DecoratorFunction, Enum, Interface, Model, ModelProperty, Namespace, Operation, Scalar, Type, Union } from "@typespec/compiler";
import { AccessDecorator, AlternateTypeDecorator, ApiVersionDecorator, ClientApiVersionsDecorator, ClientDecorator, ClientDocDecorator, ClientInitializationDecorator, ClientNameDecorator, ClientNamespaceDecorator, ConvenientAPIDecorator, DeserializeEmptyStringAsNullDecorator, FlattenPropertyDecorator, OperationGroupDecorator, ParamAliasDecorator, ProtocolAPIDecorator, ResponseAsBoolDecorator, ScopeDecorator, UsageDecorator } from "../generated-defs/Azure.ClientGenerator.Core.js";
import { AccessFlags, ClientInitializationOptions, LanguageScopes, SdkClient, SdkInitializationType, SdkOperationGroup, TCGCContext, UsageFlags } from "./interfaces.js";
import { AllScopes } from "./internal-utils.js";
export declare const namespace = "Azure.ClientGenerator.Core";
export declare const $client: ClientDecorator;
/**
 * Return the client object for the given namespace or interface, or undefined if the given namespace or interface is not a client.
 *
 * @param context TCGCContext
 * @param type Type to check
 * @returns Client or undefined
 */
export declare function getClient(context: TCGCContext, type: Namespace | Interface): SdkClient | undefined;
/**
 * List all the clients.
 *
 * @param context TCGCContext
 * @returns Array of clients
 */
export declare function listClients(context: TCGCContext): SdkClient[];
export declare const $operationGroup: OperationGroupDecorator;
/**
 * Check a namespace or interface is an operation group.
 * @param context TCGCContext
 * @param type Type to check
 * @returns boolean
 */
export declare function isOperationGroup(context: TCGCContext, type: Namespace | Interface): boolean;
/**
 * Return the operation group object for the given namespace or interface or undefined is not an operation group.
 * @param context TCGCContext
 * @param type Type to check
 * @returns Operation group or undefined.
 */
export declare function getOperationGroup(context: TCGCContext, type: Namespace | Interface): SdkOperationGroup | undefined;
/**
 * List all the operation groups inside a client or an operation group. If ignoreHierarchy is true, the result will include all nested operation groups.
 *
 * @param context TCGCContext
 * @param group Client or operation group to list operation groups
 * @param ignoreHierarchy Whether to get all nested operation groups
 * @returns
 */
export declare function listOperationGroups(context: TCGCContext, group: SdkClient | SdkOperationGroup, ignoreHierarchy?: boolean): SdkOperationGroup[];
/**
 * List operations inside a client or an operation group. If ignoreHierarchy is true, the result will include all nested operations.
 * @param program TCGCContext
 * @param group Client or operation group to list operations
 * @param ignoreHierarchy Whether to get all nested operations
 * @returns
 */
export declare function listOperationsInOperationGroup(context: TCGCContext, group: SdkOperationGroup | SdkClient, ignoreHierarchy?: boolean): Operation[];
export declare const $protocolAPI: ProtocolAPIDecorator;
export declare const $convenientAPI: ConvenientAPIDecorator;
export declare function shouldGenerateProtocol(context: TCGCContext, entity: Operation): boolean;
export declare function shouldGenerateConvenient(context: TCGCContext, entity: Operation): boolean;
export declare const $usage: UsageDecorator;
export declare function getUsageOverride(context: TCGCContext, entity: Model | Enum | Union): number | undefined;
export declare function getUsage(context: TCGCContext, entity: Model | Enum | Union): UsageFlags;
export declare const $access: AccessDecorator;
export declare function getAccessOverride(context: TCGCContext, entity: Model | Enum | Operation | Union | Namespace | ModelProperty): AccessFlags | undefined;
export declare function getAccess(context: TCGCContext, entity: Model | Enum | Operation | Union | ModelProperty): AccessFlags;
/**
 * Whether a model property should be flattened.
 *
 * @param context DecoratorContext
 * @param target ModelProperty to mark as flattened
 * @param scope Names of the projection (e.g. "python", "csharp", "java", "javascript")
 * @deprecated This decorator is not recommended to use.
 */
export declare const $flattenProperty: FlattenPropertyDecorator;
/**
 * Whether a model property should be flattened or not.
 *
 * @param context TCGCContext
 * @param target ModelProperty that we want to check whether it should be flattened or not
 * @returns whether the model property should be flattened or not
 */
export declare function shouldFlattenProperty(context: TCGCContext, target: ModelProperty): boolean;
export declare const $clientName: ClientNameDecorator;
export declare function getClientNameOverride(context: TCGCContext, entity: Type, languageScope?: string | typeof AllScopes): string | undefined;
export declare const $override: (context: DecoratorContext, original: Operation, override: Operation, scope?: LanguageScopes) => void;
/**
 * Gets additional information on how to serialize / deserialize TYPESPEC standard types depending
 * on whether additional serialization information is provided or needed
 *
 * @param context the Sdk Context
 * @param entity the entity whose client format we are going to get
 * @returns the format in which to serialize the typespec type or undefined
 */
export declare function getOverriddenClientMethod(context: TCGCContext, entity: Operation): Operation | undefined;
/**
 * Replace a source type with an alternate type in a specific scope.
 *
 * @param context the decorator context
 * @param source source type to be replaced
 * @param alternate target type to replace the source type
 * @param scope Names of the projection (e.g. "python", "csharp", "java", "javascript")
 */
export declare const $alternateType: AlternateTypeDecorator;
/**
 * Get the alternate type for a source type in a specific scope.
 *
 * @param context the Sdk Context
 * @param source source type to be replaced
 * @returns alternate type to replace the source type, or undefined if no alternate type is found
 */
export declare function getAlternateType(context: TCGCContext, source: ModelProperty | Scalar): Scalar | undefined;
export declare const $useSystemTextJsonConverter: DecoratorFunction;
export declare const $clientInitialization: ClientInitializationDecorator;
/**
 * Get `SdkInitializationType` for namespace or interface. The info is from `@clientInitialization` decorator.
 *
 * @param context
 * @param entity namespace or interface which represents a client
 * @returns
 * @deprecated This function is deprecated. Use `getClientInitializationOptions` instead.
 */
export declare function getClientInitialization(context: TCGCContext, entity: Namespace | Interface): SdkInitializationType | undefined;
/**
 * Get client initialization options for namespace or interface. The info is from `@clientInitialization` decorator.
 *
 * @param context
 * @param entity namespace or interface which represents a client
 * @returns
 */
export declare function getClientInitializationOptions(context: TCGCContext, entity: Namespace | Interface): ClientInitializationOptions | undefined;
export declare const $paramAlias: ParamAliasDecorator;
export declare function getParamAlias(context: TCGCContext, original: ModelProperty): string | undefined;
export declare const $apiVersion: ApiVersionDecorator;
export declare function getIsApiVersion(context: TCGCContext, param: ModelProperty): boolean | undefined;
export declare const $clientNamespace: ClientNamespaceDecorator;
/**
 * Returns the client namespace for a given entity. The order of operations is as follows:
 *
 * 1. If `@clientNamespace` is applied to the entity, this wins out.
 *    a. If the `--namespace` flag is passed in during generation, we will replace the root of the client namespace with the flag.
 * 2. If the `--namespace` flag is passed in, we treat that as the only namespace in the entire spec, and return that namespace.
 * 3. We return the namespace of the entity retrieved from the original spec.
 * @param context
 * @param entity
 * @returns
 */
export declare function getClientNamespace(context: TCGCContext, entity: Namespace | Interface | Model | Enum | Union): string;
export declare const $scope: ScopeDecorator;
/**
 * Add additional api versions that are possible for the client to use.
 *
 * @param context
 * @param target Service namespace that has these additional api versions
 * @param value Enum with the additional api versions
 * @param scope
 */
export declare const $clientApiVersions: ClientApiVersionsDecorator;
/**
 * Get the explicit client api versions that are possible for the client to use denoted by `@clientApiVersions`
 *
 * @param context
 * @param target
 * @returns
 */
export declare function getExplicitClientApiVersions(context: TCGCContext, target: Namespace): Enum | undefined;
export declare const $deserializeEmptyStringAsNull: DeserializeEmptyStringAsNullDecorator;
export declare const $responseAsBool: ResponseAsBoolDecorator;
export declare function getResponseAsBool(context: TCGCContext, target: Operation): boolean;
/**
 * Type representing the client documentation data stored.
 */
interface ClientDocData {
    documentation: string;
    mode: string;
}
export declare const $clientDoc: ClientDocDecorator;
/**
 * Gets the client documentation data for a type.
 *
 * @param context TCGCContext
 * @param target Type to get client documentation for
 * @returns ClientDocData or undefined if no client documentation exists
 */
export declare function getClientDocExplicit(context: TCGCContext, target: Type): ClientDocData | undefined;
export declare const $clientLocation: (context: DecoratorContext, source: Operation, target: Interface | Namespace | string, scope?: LanguageScopes) => void;
/**
 * Gets the `Namespace`, `Interface` or name of client where an operation change the location to.
 *
 * @param context TCGCContext
 * @param operation Operation to be moved
 * @returns `Namespace`, `Interface`, `string` target or undefined if no location change.
 */
export declare function getClientLocation(context: TCGCContext, operation: Operation): Namespace | Interface | string | undefined;
/**
 * Check if an operation is in scope for the current emitter.
 * @param context TCGCContext
 * @param entity Operation to check if it is in scope
 * @returns
 */
export declare function isInScope(context: TCGCContext, entity: Operation): boolean;
export {};
//# sourceMappingURL=decorators.d.ts.map