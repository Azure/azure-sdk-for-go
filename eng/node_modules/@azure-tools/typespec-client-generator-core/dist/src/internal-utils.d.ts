import { BooleanLiteral, Diagnostic, Model, ModelProperty, Namespace, NumericLiteral, Operation, Program, StringLiteral, Type, Union, Value } from "@typespec/compiler";
import { HttpOperation, HttpOperationResponseContent, HttpPayloadBody } from "@typespec/http";
import { DecoratorInfo, SdkBuiltInType, SdkClient, SdkEnumType, SdkHttpResponse, SdkModelPropertyType, SdkOperationGroup, SdkType, TCGCContext } from "./interfaces.js";
export interface TCGCEmitterOptions extends BrandedSdkEmitterOptionsInterface {
    "emitter-name"?: string;
}
export interface UnbrandedSdkEmitterOptionsInterface {
    "generate-protocol-methods"?: boolean;
    "generate-convenience-methods"?: boolean;
    "api-version"?: string;
    license?: {
        name: string;
        company?: string;
        link?: string;
        header?: string;
        description?: string;
    };
}
export interface BrandedSdkEmitterOptionsInterface extends UnbrandedSdkEmitterOptionsInterface {
    "examples-dir"?: string;
    namespace?: string;
}
export declare const AllScopes: unique symbol;
export declare const clientNameKey: symbol;
export declare const clientNamespaceKey: symbol;
export declare const negationScopesKey: symbol;
export declare const scopeKey: symbol;
export declare const clientKey: symbol;
export declare const operationGroupKey: symbol;
export declare const clientLocationKey: symbol;
export declare const omitOperation: symbol;
export declare function hasExplicitClientOrOperationGroup(context: TCGCContext): boolean;
export declare function listScopedDecoratorData(context: TCGCContext, key: symbol, languageScope?: string | typeof AllScopes): Map<Type, any>;
export declare function getScopedDecoratorData(context: TCGCContext, key: symbol, target: Type, languageScope?: string | typeof AllScopes): any;
/**
 *
 * @param emitterName Full emitter name
 * @returns The language of the emitter. I.e. "@azure-tools/typespec-csharp" will return "csharp"
 */
export declare function parseEmitterName(program: Program, emitterName?: string): [string, readonly Diagnostic[]];
/**
 *
 * @param context
 * @param type The type that we are adding api version information onto
 * @returns Whether the type is the api version parameter and the default value for the client
 */
export declare function updateWithApiVersionInformation(context: TCGCContext, type: ModelProperty, client?: SdkClient | SdkOperationGroup): {
    isApiVersionParam: boolean;
    clientDefaultValue?: string;
};
export declare function filterApiVersionsWithDecorators(context: TCGCContext, type: Type, apiVersions: string[]): string[];
/**
 *
 * @param context
 * @param type
 * @param client If it's associated with a client, meaning it's a param etc, we can see if it's available on that client
 * @returns All api versions the type is available on
 */
export declare function getAvailableApiVersions(context: TCGCContext, type: Type, wrapper?: Type): string[];
/**
 *
 * @param type
 * @returns A unique id for each type so we can do set comparisons
 */
export declare function getHashForType(type: SdkType): string;
interface DefaultSdkTypeBase<TKind> {
    __raw: Type;
    deprecation?: string;
    kind: TKind;
    decorators: DecoratorInfo[];
}
/**
 * Helper function to return default values for encode etc
 * @param type
 */
export declare function getSdkTypeBaseHelper<TKind>(context: TCGCContext, type: Type, kind: TKind): [DefaultSdkTypeBase<TKind>, readonly Diagnostic[]];
export declare function getNamespacePrefix(namespace: Namespace): string;
export declare function getTypeDecorators(context: TCGCContext, type: Type): [DecoratorInfo[], readonly Diagnostic[]];
export declare function intOrFloat(value: number): "int32" | "float32";
/**
 * Whether a model or enum or union as enum is in Azure.Core[.Foundations] namespace
 * @param t
 * @returns
 */
export declare function isAzureCoreTspModel(t: Type): boolean;
export declare function isAcceptHeader(param: SdkModelPropertyType): boolean;
export declare function isContentTypeHeader(param: SdkModelPropertyType): boolean;
export declare function isMultipartOperation(context: TCGCContext, operation?: Operation): boolean;
export declare function isHttpOperation(context: TCGCContext, obj: any): obj is HttpOperation;
export type TspLiteralType = StringLiteral | NumericLiteral | BooleanLiteral;
export declare function getNonNullOptions(type: Union): Type[];
export declare function getNullOption(type: Union): Type | undefined;
export declare function getAllResponseBodiesAndNonBodyExists(responses: SdkHttpResponse[]): {
    allResponseBodies: SdkType[];
    nonBodyExists: boolean;
};
export declare function getAllResponseBodies(responses: SdkHttpResponse[]): SdkType[];
/**
 * Use this if you are trying to create a generated name for something without an original TypeSpec type.
 *
 * Otherwise, you should use the `getGeneratedName` function.
 * @param context
 */
export declare function createGeneratedName(context: TCGCContext, type: Namespace | Operation, suffix: string): string;
export declare function isSubscriptionId(context: TCGCContext, parameter: {
    name: string;
}): boolean;
export declare function isNeverOrVoidType(type: Type): boolean;
export declare function getAnyType(context: TCGCContext, type: Type): [SdkBuiltInType, readonly Diagnostic[]];
export declare function getHttpOperationResponseHeaders(response: HttpOperationResponseContent): ModelProperty[];
export declare function removeVersionsLargerThanExplicitlySpecified(context: TCGCContext, versions: {
    value: string | number;
}[]): void;
export declare function filterApiVersionsInEnum(context: TCGCContext, client: SdkClient, sdkVersionsEnum: SdkEnumType): void;
export declare function twoParamsEquivalent(context: TCGCContext, param1?: ModelProperty, param2?: ModelProperty): boolean;
/**
 * If body is from spread, then it does not directly from a model property.
 * @param httpBody
 * @param parameters
 * @returns
 */
export declare function isHttpBodySpread(httpBody: HttpPayloadBody): boolean;
/**
 * If body is from simple spread, then we use the original model as body model.
 * @param type
 * @returns
 */
export declare function getHttpBodySpreadModel(type: Model): Model;
export declare function isOnClient(context: TCGCContext, type: ModelProperty, operation?: Operation, versioning?: boolean): boolean;
export declare function getValueTypeValue(value: Value): string | boolean | null | number | Array<unknown> | object | undefined;
export declare function hasNoneVisibility(context: TCGCContext, type: ModelProperty): boolean;
export declare function listAllUserDefinedNamespaces(context: TCGCContext): Namespace[];
export declare function findRootSourceProperty(property: ModelProperty): ModelProperty;
export declare function getStreamAsBytes(context: TCGCContext, type: Type): [SdkBuiltInType, readonly Diagnostic[]];
export declare function handleVersioningMutationForGlobalNamespace(context: TCGCContext): Namespace;
export declare function resolveDuplicateGenearatedName(context: TCGCContext, type: Union | Model | TspLiteralType, createName: string): string;
export declare function resolveConflictGeneratedName(context: TCGCContext): void;
export declare function getClientDoc(context: TCGCContext, target: Type): string | undefined;
export declare function compareModelProperties(context: TCGCContext | undefined, modelPropA: ModelProperty | undefined, modelPropB: ModelProperty | undefined): boolean;
export declare function filterMapValuesIterator<V>(iterator: MapIterator<V>, predicate: (value: V) => boolean): MapIterator<V>;
export {};
//# sourceMappingURL=internal-utils.d.ts.map