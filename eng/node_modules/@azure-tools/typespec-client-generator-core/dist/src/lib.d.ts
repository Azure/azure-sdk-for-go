import { TCGCEmitterOptions } from "./internal-utils.js";
export declare const UnbrandedSdkEmitterOptions: {
    readonly "generate-protocol-methods": {
        readonly "generate-protocol-methods": {
            readonly type: "boolean";
            readonly nullable: true;
            readonly description: "When set to `true`, the emitter will generate low-level protocol methods for each service operation if `@protocolAPI` is not set for an operation. Default value is `true`.";
        };
    };
    readonly "generate-convenience-methods": {
        readonly "generate-convenience-methods": {
            readonly type: "boolean";
            readonly nullable: true;
            readonly description: "When set to `true`, the emitter will generate convenience methods for each service operation if `@convenientAPI` is not set for an operation. Default value is `true`.";
        };
    };
    readonly "api-version": {
        readonly "api-version": {
            readonly type: "string";
            readonly nullable: true;
            readonly description: "Use this flag if you would like to generate the sdk only for a specific version. Default value is the latest version. Also accepts values `latest` and `all`.";
        };
    };
    readonly license: {
        readonly license: {
            readonly type: "object";
            readonly additionalProperties: false;
            readonly nullable: true;
            readonly required: readonly ["name"];
            readonly properties: {
                readonly name: {
                    readonly type: "string";
                    readonly nullable: false;
                    readonly description: "License name. The config is required. Predefined license are: MIT License, Apache License 2.0, BSD 3-Clause License, MPL 2.0, GPL-3.0, LGPL-3.0. For other license, you need to configure all the other license config manually.";
                };
                readonly company: {
                    readonly type: "string";
                    readonly nullable: true;
                    readonly description: "License company name. It will be used in copyright sentences.";
                };
                readonly link: {
                    readonly type: "string";
                    readonly nullable: true;
                    readonly description: "License link.";
                };
                readonly header: {
                    readonly type: "string";
                    readonly nullable: true;
                    readonly description: "License header. It will be used in the header comment of generated client code.";
                };
                readonly description: {
                    readonly type: "string";
                    readonly nullable: true;
                    readonly description: "License description. The full license text.";
                };
            };
            readonly description: "License information for the generated client code.";
        };
    };
};
export declare const BrandedSdkEmitterOptions: {
    readonly "examples-dir": {
        readonly "examples-dir": {
            readonly type: "string";
            readonly nullable: true;
            readonly format: "absolute-path";
            readonly description: "Specifies the directory where the emitter will look for example files. If the flag isnâ€™t set, the emitter defaults to using an `examples` directory located at the project root.";
        };
    };
    readonly namespace: {
        readonly namespace: {
            readonly type: "string";
            readonly nullable: true;
            readonly description: "Specifies the namespace you want to override for namespaces set in the spec. With this config, all namespace for the spec types will default to it.";
        };
    };
};
export declare const $lib: import("@typespec/compiler").TypeSpecLibrary<{
    "multiple-services": {
        readonly default: "Multiple services found. Only the first service will be used; others will be ignored.";
    };
    "client-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-circular": {
        readonly default: "Cannot have a union containing self.";
    };
    "invalid-access": {
        readonly default: "Access value must be \"public\" or \"internal\".";
    };
    "invalid-usage": {
        readonly default: "Usage value must be one of: 2 (input), 4 (output), 256 (json), or 512 (xml).";
    };
    "conflicting-multipart-model-usage": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "modelName", "modelName"]>;
    };
    "discriminator-not-constant": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator"]>;
    };
    "discriminator-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator", "discriminatorValue"]>;
    };
    "wrong-client-decorator": {
        readonly default: "@client or @operationGroup should decorate namespace or interface in client.tsp";
    };
    "unsupported-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "server-param-not-path": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateArgumentName", "templateArgumentType"]>;
    };
    "unexpected-http-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "expectedType", "actualType"]>;
    };
    "multiple-response-types": {
        readonly default: import("@typespec/compiler").CallableMessage<["operation", "response"]>;
    };
    "no-corresponding-method-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "methodName"]>;
    };
    "unsupported-protocol": {
        readonly default: "Currently we only support HTTP and HTTPS protocols";
    };
    "no-emitter-name": {
        readonly default: "Can not find name for your emitter, please check your emitter name.";
    };
    "unsupported-generic-decorator-arg-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-name": {
        readonly default: "Cannot pass an empty value to the @clientName decorator";
    };
    "override-parameters-mismatch": {
        readonly default: import("@typespec/compiler").CallableMessage<["methodName", "originalParameters", "overrideParameters"]>;
    };
    "duplicate-client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
        readonly nonDecorator: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "example-value-no-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["relativePath", "value"]>;
    };
    "flatten-polymorphism": {
        readonly default: "Cannot flatten property of polymorphic type.";
    };
    "conflict-access-override": {
        readonly default: "@access override conflicts with the access calculated from operation or other @access override.";
    };
    "duplicate-decorator": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-namespace": {
        readonly default: "Cannot pass an empty value to the @clientNamespace decorator";
    };
    "unexpected-pageable-operation-return-type": {
        readonly default: "Operation is pageable but does not return a correct type.";
    };
    "invalid-alternate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["kindName"]>;
    };
    "invalid-initialized-by": {
        readonly default: import("@typespec/compiler").CallableMessage<["message"]>;
    };
    "invalid-deserializeEmptyStringAsNull-target-type": {
        readonly default: "@deserializeEmptyStringAsNull can only be applied to `ModelProperty` of type 'string' or a `Scalar` derived from 'string'.";
    };
    "api-version-not-string": {
        readonly default: "Api version must be a string or a string enum";
    };
    "invalid-encode-for-collection-format": {
        readonly default: "Only encode of `ArrayEncoding.pipeDelimited` and `ArrayEncoding.spaceDelimited` is supported for collection format.";
    };
    "no-discriminated-unions": {
        readonly default: "Discriminated unions are not supported. Please redefine the type using model with hierarchy and `@discriminator` decorator.";
    };
    "non-head-bool-response-decorator": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName"]>;
    };
    "unsupported-http-file-body": {
        readonly default: "File body is not supported for HTTP operations. Please use bytes instead.";
    };
    "require-versioned-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["serviceName", "decoratorName"]>;
    };
    "missing-service-versions": {
        readonly default: import("@typespec/compiler").CallableMessage<["serviceName", "missingVersions"]>;
    };
    "invalid-client-doc-mode": {
        readonly default: import("@typespec/compiler").CallableMessage<["mode"]>;
    };
    "multiple-param-alias": {
        readonly default: import("@typespec/compiler").CallableMessage<["originalName", "firstParamAlias"]>;
    };
    "client-location-conflict": {
        readonly default: "When there is `@client` or `@operationGroup` decorator, `@clientLocation` decorator will be ignored.";
    };
    "client-location-wrong-type": {
        readonly default: "`@clientLocation` could only move operation to the interface or namespace belong to the root namespace with `@service`.";
    };
    "client-location-duplicate": {
        readonly default: "`@clientLocation`'s target should not duplicate with defined namespace or interface under `@service` namespace.";
    };
}, TCGCEmitterOptions, never>;
declare const reportDiagnostic: <C extends "multiple-services" | "client-service" | "union-null" | "union-circular" | "invalid-access" | "invalid-usage" | "conflicting-multipart-model-usage" | "discriminator-not-constant" | "discriminator-not-string" | "wrong-client-decorator" | "unsupported-kind" | "server-param-not-path" | "unexpected-http-param-type" | "multiple-response-types" | "no-corresponding-method-param" | "unsupported-protocol" | "no-emitter-name" | "unsupported-generic-decorator-arg-type" | "empty-client-name" | "override-parameters-mismatch" | "duplicate-client-name" | "example-loading" | "duplicate-example-file" | "example-value-no-mapping" | "flatten-polymorphism" | "conflict-access-override" | "duplicate-decorator" | "empty-client-namespace" | "unexpected-pageable-operation-return-type" | "invalid-alternate-type" | "invalid-initialized-by" | "invalid-deserializeEmptyStringAsNull-target-type" | "api-version-not-string" | "invalid-encode-for-collection-format" | "no-discriminated-unions" | "non-head-bool-response-decorator" | "unsupported-http-file-body" | "require-versioned-service" | "missing-service-versions" | "invalid-client-doc-mode" | "multiple-param-alias" | "client-location-conflict" | "client-location-wrong-type" | "client-location-duplicate", M extends keyof {
    "multiple-services": {
        readonly default: "Multiple services found. Only the first service will be used; others will be ignored.";
    };
    "client-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-circular": {
        readonly default: "Cannot have a union containing self.";
    };
    "invalid-access": {
        readonly default: "Access value must be \"public\" or \"internal\".";
    };
    "invalid-usage": {
        readonly default: "Usage value must be one of: 2 (input), 4 (output), 256 (json), or 512 (xml).";
    };
    "conflicting-multipart-model-usage": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "modelName", "modelName"]>;
    };
    "discriminator-not-constant": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator"]>;
    };
    "discriminator-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator", "discriminatorValue"]>;
    };
    "wrong-client-decorator": {
        readonly default: "@client or @operationGroup should decorate namespace or interface in client.tsp";
    };
    "unsupported-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "server-param-not-path": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateArgumentName", "templateArgumentType"]>;
    };
    "unexpected-http-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "expectedType", "actualType"]>;
    };
    "multiple-response-types": {
        readonly default: import("@typespec/compiler").CallableMessage<["operation", "response"]>;
    };
    "no-corresponding-method-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "methodName"]>;
    };
    "unsupported-protocol": {
        readonly default: "Currently we only support HTTP and HTTPS protocols";
    };
    "no-emitter-name": {
        readonly default: "Can not find name for your emitter, please check your emitter name.";
    };
    "unsupported-generic-decorator-arg-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-name": {
        readonly default: "Cannot pass an empty value to the @clientName decorator";
    };
    "override-parameters-mismatch": {
        readonly default: import("@typespec/compiler").CallableMessage<["methodName", "originalParameters", "overrideParameters"]>;
    };
    "duplicate-client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
        readonly nonDecorator: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "example-value-no-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["relativePath", "value"]>;
    };
    "flatten-polymorphism": {
        readonly default: "Cannot flatten property of polymorphic type.";
    };
    "conflict-access-override": {
        readonly default: "@access override conflicts with the access calculated from operation or other @access override.";
    };
    "duplicate-decorator": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-namespace": {
        readonly default: "Cannot pass an empty value to the @clientNamespace decorator";
    };
    "unexpected-pageable-operation-return-type": {
        readonly default: "Operation is pageable but does not return a correct type.";
    };
    "invalid-alternate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["kindName"]>;
    };
    "invalid-initialized-by": {
        readonly default: import("@typespec/compiler").CallableMessage<["message"]>;
    };
    "invalid-deserializeEmptyStringAsNull-target-type": {
        readonly default: "@deserializeEmptyStringAsNull can only be applied to `ModelProperty` of type 'string' or a `Scalar` derived from 'string'.";
    };
    "api-version-not-string": {
        readonly default: "Api version must be a string or a string enum";
    };
    "invalid-encode-for-collection-format": {
        readonly default: "Only encode of `ArrayEncoding.pipeDelimited` and `ArrayEncoding.spaceDelimited` is supported for collection format.";
    };
    "no-discriminated-unions": {
        readonly default: "Discriminated unions are not supported. Please redefine the type using model with hierarchy and `@discriminator` decorator.";
    };
    "non-head-bool-response-decorator": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName"]>;
    };
    "unsupported-http-file-body": {
        readonly default: "File body is not supported for HTTP operations. Please use bytes instead.";
    };
    "require-versioned-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["serviceName", "decoratorName"]>;
    };
    "missing-service-versions": {
        readonly default: import("@typespec/compiler").CallableMessage<["serviceName", "missingVersions"]>;
    };
    "invalid-client-doc-mode": {
        readonly default: import("@typespec/compiler").CallableMessage<["mode"]>;
    };
    "multiple-param-alias": {
        readonly default: import("@typespec/compiler").CallableMessage<["originalName", "firstParamAlias"]>;
    };
    "client-location-conflict": {
        readonly default: "When there is `@client` or `@operationGroup` decorator, `@clientLocation` decorator will be ignored.";
    };
    "client-location-wrong-type": {
        readonly default: "`@clientLocation` could only move operation to the interface or namespace belong to the root namespace with `@service`.";
    };
    "client-location-duplicate": {
        readonly default: "`@clientLocation`'s target should not duplicate with defined namespace or interface under `@service` namespace.";
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "multiple-services": {
        readonly default: "Multiple services found. Only the first service will be used; others will be ignored.";
    };
    "client-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-circular": {
        readonly default: "Cannot have a union containing self.";
    };
    "invalid-access": {
        readonly default: "Access value must be \"public\" or \"internal\".";
    };
    "invalid-usage": {
        readonly default: "Usage value must be one of: 2 (input), 4 (output), 256 (json), or 512 (xml).";
    };
    "conflicting-multipart-model-usage": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "modelName", "modelName"]>;
    };
    "discriminator-not-constant": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator"]>;
    };
    "discriminator-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator", "discriminatorValue"]>;
    };
    "wrong-client-decorator": {
        readonly default: "@client or @operationGroup should decorate namespace or interface in client.tsp";
    };
    "unsupported-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "server-param-not-path": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateArgumentName", "templateArgumentType"]>;
    };
    "unexpected-http-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "expectedType", "actualType"]>;
    };
    "multiple-response-types": {
        readonly default: import("@typespec/compiler").CallableMessage<["operation", "response"]>;
    };
    "no-corresponding-method-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "methodName"]>;
    };
    "unsupported-protocol": {
        readonly default: "Currently we only support HTTP and HTTPS protocols";
    };
    "no-emitter-name": {
        readonly default: "Can not find name for your emitter, please check your emitter name.";
    };
    "unsupported-generic-decorator-arg-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-name": {
        readonly default: "Cannot pass an empty value to the @clientName decorator";
    };
    "override-parameters-mismatch": {
        readonly default: import("@typespec/compiler").CallableMessage<["methodName", "originalParameters", "overrideParameters"]>;
    };
    "duplicate-client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
        readonly nonDecorator: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "example-value-no-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["relativePath", "value"]>;
    };
    "flatten-polymorphism": {
        readonly default: "Cannot flatten property of polymorphic type.";
    };
    "conflict-access-override": {
        readonly default: "@access override conflicts with the access calculated from operation or other @access override.";
    };
    "duplicate-decorator": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-namespace": {
        readonly default: "Cannot pass an empty value to the @clientNamespace decorator";
    };
    "unexpected-pageable-operation-return-type": {
        readonly default: "Operation is pageable but does not return a correct type.";
    };
    "invalid-alternate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["kindName"]>;
    };
    "invalid-initialized-by": {
        readonly default: import("@typespec/compiler").CallableMessage<["message"]>;
    };
    "invalid-deserializeEmptyStringAsNull-target-type": {
        readonly default: "@deserializeEmptyStringAsNull can only be applied to `ModelProperty` of type 'string' or a `Scalar` derived from 'string'.";
    };
    "api-version-not-string": {
        readonly default: "Api version must be a string or a string enum";
    };
    "invalid-encode-for-collection-format": {
        readonly default: "Only encode of `ArrayEncoding.pipeDelimited` and `ArrayEncoding.spaceDelimited` is supported for collection format.";
    };
    "no-discriminated-unions": {
        readonly default: "Discriminated unions are not supported. Please redefine the type using model with hierarchy and `@discriminator` decorator.";
    };
    "non-head-bool-response-decorator": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName"]>;
    };
    "unsupported-http-file-body": {
        readonly default: "File body is not supported for HTTP operations. Please use bytes instead.";
    };
    "require-versioned-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["serviceName", "decoratorName"]>;
    };
    "missing-service-versions": {
        readonly default: import("@typespec/compiler").CallableMessage<["serviceName", "missingVersions"]>;
    };
    "invalid-client-doc-mode": {
        readonly default: import("@typespec/compiler").CallableMessage<["mode"]>;
    };
    "multiple-param-alias": {
        readonly default: import("@typespec/compiler").CallableMessage<["originalName", "firstParamAlias"]>;
    };
    "client-location-conflict": {
        readonly default: "When there is `@client` or `@operationGroup` decorator, `@clientLocation` decorator will be ignored.";
    };
    "client-location-wrong-type": {
        readonly default: "`@clientLocation` could only move operation to the interface or namespace belong to the root namespace with `@service`.";
    };
    "client-location-duplicate": {
        readonly default: "`@clientLocation`'s target should not duplicate with defined namespace or interface under `@service` namespace.";
    };
}, C, M>) => void, createDiagnostic: <C extends "multiple-services" | "client-service" | "union-null" | "union-circular" | "invalid-access" | "invalid-usage" | "conflicting-multipart-model-usage" | "discriminator-not-constant" | "discriminator-not-string" | "wrong-client-decorator" | "unsupported-kind" | "server-param-not-path" | "unexpected-http-param-type" | "multiple-response-types" | "no-corresponding-method-param" | "unsupported-protocol" | "no-emitter-name" | "unsupported-generic-decorator-arg-type" | "empty-client-name" | "override-parameters-mismatch" | "duplicate-client-name" | "example-loading" | "duplicate-example-file" | "example-value-no-mapping" | "flatten-polymorphism" | "conflict-access-override" | "duplicate-decorator" | "empty-client-namespace" | "unexpected-pageable-operation-return-type" | "invalid-alternate-type" | "invalid-initialized-by" | "invalid-deserializeEmptyStringAsNull-target-type" | "api-version-not-string" | "invalid-encode-for-collection-format" | "no-discriminated-unions" | "non-head-bool-response-decorator" | "unsupported-http-file-body" | "require-versioned-service" | "missing-service-versions" | "invalid-client-doc-mode" | "multiple-param-alias" | "client-location-conflict" | "client-location-wrong-type" | "client-location-duplicate", M extends keyof {
    "multiple-services": {
        readonly default: "Multiple services found. Only the first service will be used; others will be ignored.";
    };
    "client-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-circular": {
        readonly default: "Cannot have a union containing self.";
    };
    "invalid-access": {
        readonly default: "Access value must be \"public\" or \"internal\".";
    };
    "invalid-usage": {
        readonly default: "Usage value must be one of: 2 (input), 4 (output), 256 (json), or 512 (xml).";
    };
    "conflicting-multipart-model-usage": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "modelName", "modelName"]>;
    };
    "discriminator-not-constant": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator"]>;
    };
    "discriminator-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator", "discriminatorValue"]>;
    };
    "wrong-client-decorator": {
        readonly default: "@client or @operationGroup should decorate namespace or interface in client.tsp";
    };
    "unsupported-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "server-param-not-path": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateArgumentName", "templateArgumentType"]>;
    };
    "unexpected-http-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "expectedType", "actualType"]>;
    };
    "multiple-response-types": {
        readonly default: import("@typespec/compiler").CallableMessage<["operation", "response"]>;
    };
    "no-corresponding-method-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "methodName"]>;
    };
    "unsupported-protocol": {
        readonly default: "Currently we only support HTTP and HTTPS protocols";
    };
    "no-emitter-name": {
        readonly default: "Can not find name for your emitter, please check your emitter name.";
    };
    "unsupported-generic-decorator-arg-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-name": {
        readonly default: "Cannot pass an empty value to the @clientName decorator";
    };
    "override-parameters-mismatch": {
        readonly default: import("@typespec/compiler").CallableMessage<["methodName", "originalParameters", "overrideParameters"]>;
    };
    "duplicate-client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
        readonly nonDecorator: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "example-value-no-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["relativePath", "value"]>;
    };
    "flatten-polymorphism": {
        readonly default: "Cannot flatten property of polymorphic type.";
    };
    "conflict-access-override": {
        readonly default: "@access override conflicts with the access calculated from operation or other @access override.";
    };
    "duplicate-decorator": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-namespace": {
        readonly default: "Cannot pass an empty value to the @clientNamespace decorator";
    };
    "unexpected-pageable-operation-return-type": {
        readonly default: "Operation is pageable but does not return a correct type.";
    };
    "invalid-alternate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["kindName"]>;
    };
    "invalid-initialized-by": {
        readonly default: import("@typespec/compiler").CallableMessage<["message"]>;
    };
    "invalid-deserializeEmptyStringAsNull-target-type": {
        readonly default: "@deserializeEmptyStringAsNull can only be applied to `ModelProperty` of type 'string' or a `Scalar` derived from 'string'.";
    };
    "api-version-not-string": {
        readonly default: "Api version must be a string or a string enum";
    };
    "invalid-encode-for-collection-format": {
        readonly default: "Only encode of `ArrayEncoding.pipeDelimited` and `ArrayEncoding.spaceDelimited` is supported for collection format.";
    };
    "no-discriminated-unions": {
        readonly default: "Discriminated unions are not supported. Please redefine the type using model with hierarchy and `@discriminator` decorator.";
    };
    "non-head-bool-response-decorator": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName"]>;
    };
    "unsupported-http-file-body": {
        readonly default: "File body is not supported for HTTP operations. Please use bytes instead.";
    };
    "require-versioned-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["serviceName", "decoratorName"]>;
    };
    "missing-service-versions": {
        readonly default: import("@typespec/compiler").CallableMessage<["serviceName", "missingVersions"]>;
    };
    "invalid-client-doc-mode": {
        readonly default: import("@typespec/compiler").CallableMessage<["mode"]>;
    };
    "multiple-param-alias": {
        readonly default: import("@typespec/compiler").CallableMessage<["originalName", "firstParamAlias"]>;
    };
    "client-location-conflict": {
        readonly default: "When there is `@client` or `@operationGroup` decorator, `@clientLocation` decorator will be ignored.";
    };
    "client-location-wrong-type": {
        readonly default: "`@clientLocation` could only move operation to the interface or namespace belong to the root namespace with `@service`.";
    };
    "client-location-duplicate": {
        readonly default: "`@clientLocation`'s target should not duplicate with defined namespace or interface under `@service` namespace.";
    };
}[C]>(diag: import("@typespec/compiler").DiagnosticReport<{
    "multiple-services": {
        readonly default: "Multiple services found. Only the first service will be used; others will be ignored.";
    };
    "client-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-circular": {
        readonly default: "Cannot have a union containing self.";
    };
    "invalid-access": {
        readonly default: "Access value must be \"public\" or \"internal\".";
    };
    "invalid-usage": {
        readonly default: "Usage value must be one of: 2 (input), 4 (output), 256 (json), or 512 (xml).";
    };
    "conflicting-multipart-model-usage": {
        readonly default: import("@typespec/compiler").CallableMessage<["modelName", "modelName", "modelName"]>;
    };
    "discriminator-not-constant": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator"]>;
    };
    "discriminator-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["discriminator", "discriminatorValue"]>;
    };
    "wrong-client-decorator": {
        readonly default: "@client or @operationGroup should decorate namespace or interface in client.tsp";
    };
    "unsupported-kind": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "server-param-not-path": {
        readonly default: import("@typespec/compiler").CallableMessage<["templateArgumentName", "templateArgumentType"]>;
    };
    "unexpected-http-param-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "expectedType", "actualType"]>;
    };
    "multiple-response-types": {
        readonly default: import("@typespec/compiler").CallableMessage<["operation", "response"]>;
    };
    "no-corresponding-method-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "methodName"]>;
    };
    "unsupported-protocol": {
        readonly default: "Currently we only support HTTP and HTTPS protocols";
    };
    "no-emitter-name": {
        readonly default: "Can not find name for your emitter, please check your emitter name.";
    };
    "unsupported-generic-decorator-arg-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-name": {
        readonly default: "Cannot pass an empty value to the @clientName decorator";
    };
    "override-parameters-mismatch": {
        readonly default: import("@typespec/compiler").CallableMessage<["methodName", "originalParameters", "overrideParameters"]>;
    };
    "duplicate-client-name": {
        readonly default: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
        readonly nonDecorator: import("@typespec/compiler").CallableMessage<["name", "scope"]>;
    };
    "example-loading": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "error"]>;
        readonly noDirectory: import("@typespec/compiler").CallableMessage<["directory"]>;
        readonly noOperationId: import("@typespec/compiler").CallableMessage<["filename"]>;
    };
    "duplicate-example-file": {
        readonly default: import("@typespec/compiler").CallableMessage<["filename", "title", "operationId"]>;
    };
    "example-value-no-mapping": {
        readonly default: import("@typespec/compiler").CallableMessage<["relativePath", "value"]>;
    };
    "flatten-polymorphism": {
        readonly default: "Cannot flatten property of polymorphic type.";
    };
    "conflict-access-override": {
        readonly default: "@access override conflicts with the access calculated from operation or other @access override.";
    };
    "duplicate-decorator": {
        readonly default: import("@typespec/compiler").CallableMessage<["decoratorName"]>;
    };
    "empty-client-namespace": {
        readonly default: "Cannot pass an empty value to the @clientNamespace decorator";
    };
    "unexpected-pageable-operation-return-type": {
        readonly default: "Operation is pageable but does not return a correct type.";
    };
    "invalid-alternate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["kindName"]>;
    };
    "invalid-initialized-by": {
        readonly default: import("@typespec/compiler").CallableMessage<["message"]>;
    };
    "invalid-deserializeEmptyStringAsNull-target-type": {
        readonly default: "@deserializeEmptyStringAsNull can only be applied to `ModelProperty` of type 'string' or a `Scalar` derived from 'string'.";
    };
    "api-version-not-string": {
        readonly default: "Api version must be a string or a string enum";
    };
    "invalid-encode-for-collection-format": {
        readonly default: "Only encode of `ArrayEncoding.pipeDelimited` and `ArrayEncoding.spaceDelimited` is supported for collection format.";
    };
    "no-discriminated-unions": {
        readonly default: "Discriminated unions are not supported. Please redefine the type using model with hierarchy and `@discriminator` decorator.";
    };
    "non-head-bool-response-decorator": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName"]>;
    };
    "unsupported-http-file-body": {
        readonly default: "File body is not supported for HTTP operations. Please use bytes instead.";
    };
    "require-versioned-service": {
        readonly default: import("@typespec/compiler").CallableMessage<["serviceName", "decoratorName"]>;
    };
    "missing-service-versions": {
        readonly default: import("@typespec/compiler").CallableMessage<["serviceName", "missingVersions"]>;
    };
    "invalid-client-doc-mode": {
        readonly default: import("@typespec/compiler").CallableMessage<["mode"]>;
    };
    "multiple-param-alias": {
        readonly default: import("@typespec/compiler").CallableMessage<["originalName", "firstParamAlias"]>;
    };
    "client-location-conflict": {
        readonly default: "When there is `@client` or `@operationGroup` decorator, `@clientLocation` decorator will be ignored.";
    };
    "client-location-wrong-type": {
        readonly default: "`@clientLocation` could only move operation to the interface or namespace belong to the root namespace with `@service`.";
    };
    "client-location-duplicate": {
        readonly default: "`@clientLocation`'s target should not duplicate with defined namespace or interface under `@service` namespace.";
    };
}, C, M>) => import("@typespec/compiler").Diagnostic, createStateSymbol: (name: string) => symbol;
export { createDiagnostic, createStateSymbol, reportDiagnostic };
//# sourceMappingURL=lib.d.ts.map