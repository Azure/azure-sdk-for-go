import { MethodExample } from './examples.js';
import * as pkg from './package.js';
import * as param from './param.js';
import * as result from './result.js';
import * as type from './type.js';
/** an SDK client */
export interface Client {
    /** the name of the client */
    name: string;
    /** any docs for the client */
    docs: type.Docs;
    /** the client options type. for ARM, this will be a QualifiedType (arm.ClientOptions) */
    options: ClientOptions;
    /** constructor params that are persisted as fields on the client, can be empty */
    parameters: Array<param.Parameter>;
    /** all the constructors for this client, can be empty */
    constructors: Array<Constructor>;
    /** contains client methods. can be empty */
    methods: Array<MethodType>;
    /** contains any client accessor methods. can be empty */
    clientAccessors: Array<ClientAccessor>;
    /** client has a statically defined or templated host */
    host?: string;
    /**
     * templatedHost indicates that there's one or more URIParameters
     * required to construct the complete host. the parameters can
     * be solely on the client or span client and method params.
     */
    templatedHost: boolean;
    /** the parent client in a hierarchical client */
    parent?: Client;
}
/** the possible types used for the client options type */
export type ClientOptions = param.ParameterGroup | param.Parameter;
/** a client method that returns a sub-client instance */
export interface ClientAccessor {
    /** the name of the client accessor method */
    name: string;
    /** the client returned by the accessor method */
    subClient: Client;
}
/** a client constructor function */
export interface Constructor {
    /** the name of the constructor function */
    name: string;
    /** the modeled parameters. can be empty */
    parameters: Array<param.Parameter>;
}
/** the possible values defining the "final state via" behavior for LROs */
export type FinalStateVia = 'azure-async-operation' | 'location' | 'operation-location' | 'original-uri';
/** the supported HTTP verbs */
export type HTTPMethod = 'delete' | 'get' | 'head' | 'patch' | 'post' | 'put';
/** the possible method types */
export type MethodType = LROMethod | LROPageableMethod | Method | PageableMethod;
/** a long-running operation method */
export interface LROMethod extends LROMethodBase {
    kind: 'lroMethod';
}
/** a long-running operation method that returns pages of responses */
export interface LROPageableMethod extends LROMethodBase, PageableMethodBase {
    kind: 'lroPageableMethod';
}
/** a synchronous method */
export interface Method extends MethodBase {
    kind: 'method';
}
/** contains the names of the helper methods used to create a complete method implementation */
export interface MethodNaming {
    /** the name of the internal method for consumption by LROs/paging methods */
    internalMethod: string;
    /** the name of the internal method that creates the HTTP request */
    requestMethod: string;
    /** the name of the internal method that handles the HTTP response */
    responseMethod: string;
}
/**
 * the internal method used for fetching the next page for a PageableMethod.
 * It's unique from a regular Method as it's not exported and has no optional params/response envelope.
 * thus, it's not included in the array of methods for a client.
 */
export interface NextPageMethod {
    kind: 'nextPageMethod';
    /** the name of the next page method */
    name: string;
    /** the HTTP path used when creating the request */
    httpPath: string;
    /** the HTTP verb used when creating the request */
    httpMethod: HTTPMethod;
    /** any modeled parameters */
    parameters: Array<param.Parameter>;
    /** the complete list of successful HTTP status codes */
    httpStatusCodes: Array<number>;
    /** the client to which the method belongs */
    client: Client;
    apiVersions: Array<string>;
}
/** a synchronous method that returns pages of responses */
export interface PageableMethod extends PageableMethodBase {
    kind: 'pageableMethod';
}
/** narrows method to a LRO method type within the conditional block */
export declare function isLROMethod(method: MethodType): method is LROMethod | LROPageableMethod;
/** narrows method to a pageable method type within the conditional block */
export declare function isPageableMethod(method: MethodType): method is LROPageableMethod | PageableMethod;
/** creates the ClientOptions type from the specified input */
export declare function newClientOptions(modelType: pkg.CodeModelType, clientName: string): ClientOptions;
interface LROMethodBase extends MethodBase {
    finalStateVia?: FinalStateVia;
    operationLocationResultPath?: string;
}
interface MethodBase {
    /** the name of the method */
    name: string;
    /** any docs for the method */
    docs: type.Docs;
    /** the HTTP path used when creating the request */
    httpPath: string;
    /** the HTTP verb used when creating the request */
    httpMethod: HTTPMethod;
    /** any modeled parameters. the ones we add to the generated code (context.Context etc) aren't included here */
    parameters: Array<param.Parameter>;
    /** the method options type for this methoid */
    optionalParamsGroup: param.ParameterGroup;
    /** the response type for this method */
    responseEnvelope: result.ResponseEnvelope;
    /** the complete list of successful HTTP status codes */
    httpStatusCodes: Array<number>;
    /** the client to which the method belongs */
    client: Client;
    /** naming info for the internal hepler methods for which this method depends */
    naming: MethodNaming;
    apiVersions: Array<string>;
    /** any examples for this method */
    examples: Array<MethodExample>;
}
interface PageableMethodBase extends MethodBase {
    nextLinkName?: string;
    nextPageMethod?: NextPageMethod;
}
declare class MethodBase implements MethodBase {
    constructor(name: string, client: Client, httpPath: string, httpMethod: HTTPMethod, statusCodes: Array<number>, naming: MethodNaming);
}
export declare class Client implements Client {
    constructor(name: string, docs: type.Docs, options: ClientOptions);
}
export declare class ClientAccessor implements ClientAccessor {
    constructor(name: string, subClient: Client);
}
export declare class Constructor implements Constructor {
    constructor(name: string);
}
export declare class LROMethod extends MethodBase implements LROMethod {
    constructor(name: string, client: Client, httpPath: string, httpMethod: HTTPMethod, statusCodes: Array<number>, naming: MethodNaming);
}
export declare class LROPageableMethod extends MethodBase implements LROPageableMethod {
    constructor(name: string, client: Client, httpPath: string, httpMethod: HTTPMethod, statusCodes: Array<number>, naming: MethodNaming);
}
export declare class Method extends MethodBase implements Method {
    constructor(name: string, client: Client, httpPath: string, httpMethod: HTTPMethod, statusCodes: Array<number>, naming: MethodNaming);
}
export declare class MethodNaming implements MethodNaming {
    constructor(internalMethod: string, requestMethod: string, responseMethod: string);
}
export declare class NextPageMethod implements NextPageMethod {
    constructor(name: string, client: Client, httpPath: string, httpMethod: HTTPMethod, statusCodes: Array<number>);
}
export declare class PageableMethod extends MethodBase implements PageableMethod {
    constructor(name: string, client: Client, httpPath: string, httpMethod: HTTPMethod, statusCodes: Array<number>, naming: MethodNaming);
}
export {};
//# sourceMappingURL=client.d.ts.map