/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
import { CodeModelError } from './errors.js';
import * as param from './param.js';
import * as type from './type.js';
/** narrows method to a LRO method type within the conditional block */
export function isLROMethod(method) {
    return method.kind === 'lroMethod' || method.kind === 'lroPageableMethod';
}
/** narrows method to a pageable method type within the conditional block */
export function isPageableMethod(method) {
    return method.kind === 'lroPageableMethod' || method.kind === 'pageableMethod';
}
/** creates the ClientOptions type from the specified input */
export function newClientOptions(modelType, clientName) {
    let options;
    if (modelType === 'azure-arm') {
        options = new param.Parameter('options', new type.QualifiedType('ClientOptions', 'github.com/Azure/azure-sdk-for-go/sdk/azcore/arm'), 'optional', false, 'client');
        options.docs.summary = 'pass nil to accept the default values.';
    }
    else {
        const optionsTypeName = `${clientName}Options`;
        options = new param.ParameterGroup('options', optionsTypeName, false, 'client');
        options.docs.summary = `${optionsTypeName} contains the optional values for creating a [${clientName}]`;
    }
    return options;
}
class MethodBase {
    constructor(name, client, httpPath, httpMethod, statusCodes, naming) {
        if (statusCodes.length === 0) {
            throw new CodeModelError('statusCodes cannot be empty');
        }
        this.apiVersions = new Array();
        this.client = client;
        this.httpMethod = httpMethod;
        this.httpPath = httpPath;
        this.httpStatusCodes = statusCodes;
        this.name = name;
        this.naming = naming;
        this.parameters = new Array();
        this.examples = [];
        this.docs = {};
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
export class Client {
    constructor(name, docs, options) {
        this.name = name;
        this.templatedHost = false;
        this.constructors = new Array();
        this.docs = docs;
        this.methods = new Array();
        this.clientAccessors = new Array();
        this.parameters = new Array();
        this.options = options;
    }
}
export class ClientAccessor {
    constructor(name, subClient) {
        this.name = name;
        this.subClient = subClient;
    }
}
export class Constructor {
    constructor(name) {
        this.name = name;
        this.parameters = new Array();
    }
}
export class LROMethod extends MethodBase {
    constructor(name, client, httpPath, httpMethod, statusCodes, naming) {
        super(name, client, httpPath, httpMethod, statusCodes, naming);
        this.kind = 'lroMethod';
    }
}
export class LROPageableMethod extends MethodBase {
    constructor(name, client, httpPath, httpMethod, statusCodes, naming) {
        super(name, client, httpPath, httpMethod, statusCodes, naming);
        this.kind = 'lroPageableMethod';
    }
}
export class Method extends MethodBase {
    constructor(name, client, httpPath, httpMethod, statusCodes, naming) {
        super(name, client, httpPath, httpMethod, statusCodes, naming);
        this.kind = 'method';
    }
}
export class MethodNaming {
    constructor(internalMethod, requestMethod, responseMethod) {
        this.internalMethod = internalMethod;
        this.requestMethod = requestMethod;
        this.responseMethod = responseMethod;
    }
}
export class NextPageMethod {
    constructor(name, client, httpPath, httpMethod, statusCodes) {
        if (statusCodes.length === 0) {
            throw new CodeModelError('statusCodes cannot be empty');
        }
        this.kind = 'nextPageMethod';
        this.apiVersions = new Array();
        this.client = client;
        this.httpMethod = httpMethod;
        this.httpPath = httpPath;
        this.httpStatusCodes = statusCodes;
        this.name = name;
        this.parameters = new Array();
    }
}
export class PageableMethod extends MethodBase {
    constructor(name, client, httpPath, httpMethod, statusCodes, naming) {
        super(name, client, httpPath, httpMethod, statusCodes, naming);
        this.kind = 'pageableMethod';
    }
}
//# sourceMappingURL=client.js.map