/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
import { CodeModelError } from './errors.js';
import * as type from './type.js';
export function isAnyResult(resultType) {
    return resultType.httpStatusCodeType !== undefined;
}
export function isBinaryResult(resultType) {
    return resultType.binaryFormat !== undefined;
}
export function isHeadAsBooleanResult(resultType) {
    return resultType.headAsBoolean !== undefined;
}
export function isHeaderMapResponse(resp) {
    return resp.collectionPrefix !== undefined;
}
export function isMonomorphicResult(resultType) {
    return resultType.monomorphicType !== undefined;
}
export function isPolymorphicResult(resultType) {
    return resultType.interfaceType !== undefined;
}
export function isModelResult(resultType) {
    return resultType.modelType !== undefined;
}
export function getResultPossibleType(resultType) {
    if (isAnyResult(resultType)) {
        return new type.PrimitiveType('any');
    }
    else if (isBinaryResult(resultType)) {
        return new type.QualifiedType('ReadCloser', 'io');
    }
    else if (isHeadAsBooleanResult(resultType)) {
        return new type.PrimitiveType('bool');
    }
    else if (isMonomorphicResult(resultType)) {
        return resultType.monomorphicType;
    }
    else if (isPolymorphicResult(resultType)) {
        return resultType.interfaceType;
    }
    else if (isModelResult(resultType)) {
        return resultType.modelType;
    }
    else {
        throw new CodeModelError(`unhandled result type ${resultType}`);
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
export class AnyResult {
    constructor(fieldName, format, resultTypes) {
        this.fieldName = fieldName;
        this.format = format;
        this.httpStatusCodeType = resultTypes;
        this.byValue = true;
        this.docs = {};
    }
}
export class BinaryResult {
    constructor(fieldName, format) {
        this.fieldName = fieldName;
        this.binaryFormat = format;
        this.byValue = true;
        this.docs = {};
    }
}
export class HeadAsBooleanResult {
    constructor(fieldName) {
        this.fieldName = fieldName;
        this.headAsBoolean = true;
        this.byValue = true;
        this.docs = {};
    }
}
export class HeaderMapResponse {
    constructor(fieldName, type, collectionPrefix, headerName, byValue) {
        this.fieldName = fieldName;
        this.type = type;
        this.collectionPrefix = collectionPrefix;
        this.byValue = byValue;
        this.headerName = headerName;
        this.docs = {};
    }
}
export class HeaderResponse {
    constructor(fieldName, type, headerName, byValue) {
        this.fieldName = fieldName;
        this.type = type;
        this.byValue = byValue;
        this.headerName = headerName;
        this.docs = {};
    }
}
export class ModelResult {
    constructor(type, format) {
        this.modelType = type;
        this.format = format;
        this.docs = {};
    }
}
export class MonomorphicResult {
    constructor(fieldName, format, type, byValue) {
        this.fieldName = fieldName;
        this.format = format;
        this.monomorphicType = type;
        this.byValue = byValue;
        this.docs = {};
    }
}
export class PolymorphicResult {
    constructor(type) {
        this.interfaceType = type;
        this.format = 'JSON';
        this.docs = {};
    }
}
export class ResponseEnvelope {
    constructor(name, docs, forMethod) {
        this.docs = docs;
        this.headers = new Array();
        this.method = forMethod;
        this.name = name;
    }
}
//# sourceMappingURL=result.js.map