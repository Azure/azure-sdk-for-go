export type PossibleType = BytesType | ConstantType | InterfaceType | LiteralValue | MapType | ModelType | PolymorphicType | PrimitiveType | SliceType | QualifiedType | TimeType;
export interface BytesType {
    encoding: BytesEncoding;
}
export type BytesEncoding = 'Std' | 'URL';
export interface ConstantType {
    name: string;
    docs: Docs;
    type: ConstantTypeTypes;
    values: Array<ConstantValue>;
    valuesFuncName: string;
}
export type ConstantTypeTypes = 'bool' | 'float32' | 'float64' | 'int32' | 'int64' | 'string';
export interface ConstantValue {
    name: string;
    docs: Docs;
    type: ConstantType;
    value: ConstantValueValueTypes;
}
export type ConstantValueValueTypes = boolean | number | string;
export type DateTimeFormat = 'dateType' | 'dateTimeRFC1123' | 'dateTimeRFC3339' | 'timeRFC3339' | 'timeUnix';
export interface Docs {
    summary?: string;
    description?: string;
}
export interface InterfaceType {
    name: string;
    docs: Docs;
    possibleTypes: Array<PolymorphicType>;
    discriminatorField: string;
    parent?: InterfaceType;
    rootType: PolymorphicType;
}
export interface LiteralValue {
    type: LiteralValueType;
    literal: any;
}
export type LiteralValueType = BytesType | ConstantType | PrimitiveType | TimeType;
export interface MapType {
    valueType: MapValueType;
    valueTypeByValue: boolean;
}
export type MapValueType = PossibleType;
export interface ModelField extends StructField {
    serializedName: string;
    annotations: ModelFieldAnnotations;
    defaultValue?: LiteralValue;
    xml?: XMLInfo;
}
export interface ModelAnnotations {
    omitSerDeMethods: boolean;
    multipartFormData: boolean;
}
export interface ModelFieldAnnotations {
    required: boolean;
    readOnly: boolean;
    isAdditionalProperties: boolean;
    isDiscriminator: boolean;
}
export interface ModelType extends StructType {
    fields: Array<ModelField>;
    annotations: ModelAnnotations;
    usage: UsageFlags;
    xml?: XMLInfo;
}
export interface PolymorphicType extends StructType {
    fields: Array<ModelField>;
    annotations: ModelAnnotations;
    usage: UsageFlags;
    interface: InterfaceType;
    discriminatorValue?: LiteralValue;
}
export interface PrimitiveType {
    typeName: PrimitiveTypeName;
    encodeAsString: boolean;
}
export type PrimitiveTypeName = 'any' | 'bool' | 'byte' | 'float32' | 'float64' | 'int8' | 'int16' | 'int32' | 'int64' | 'rune' | 'string' | 'uint8' | 'uint16' | 'uint32' | 'uint64';
export interface QualifiedType {
    exportName: string;
    packageName: string;
}
export interface SliceType {
    elementType: SliceElementType;
    elementTypeByValue: boolean;
    rawJSONAsBytes: boolean;
}
export type SliceElementType = PossibleType;
export interface StructType {
    name: string;
    docs: Docs;
    fields: Array<StructField>;
}
export interface StructField {
    name: string;
    docs: Docs;
    type: PossibleType;
    byValue: boolean;
}
export interface TimeType {
    dateTimeFormat: DateTimeFormat;
    utc: boolean;
}
export declare enum UsageFlags {
    None = 0,
    Input = 1,
    Output = 2
}
export interface XMLInfo {
    name?: string;
    wrapper?: string;
    wraps?: string;
    attribute: boolean;
    text: boolean;
}
export declare function isBytesType(type: PossibleType): type is BytesType;
export declare function isConstantType(type: PossibleType): type is ConstantType;
export declare function isLiteralValueType(type: PossibleType): type is LiteralValueType;
export declare function isPrimitiveType(type: PossibleType): type is PrimitiveType;
export declare function isQualifiedType(type: PossibleType): type is QualifiedType;
export declare function isTimeType(type: PossibleType): type is TimeType;
export declare function isMapType(type: PossibleType): type is MapType;
export declare function isModelType(type: PossibleType): type is ModelType;
export declare function isPolymorphicType(type: PossibleType): type is PolymorphicType;
export declare function isSliceType(type: PossibleType): type is SliceType;
export declare function isInterfaceType(type: PossibleType): type is InterfaceType;
export declare function isLiteralValue(type: PossibleType): type is LiteralValue;
export declare function getLiteralValueTypeName(literal: LiteralValueType): string;
export declare function getTypeDeclaration(type: PossibleType, pkgName?: string): string;
export declare class StructField implements StructField {
    constructor(name: string, type: PossibleType, byValue: boolean);
}
export declare class StructType implements StructType {
    constructor(name: string);
}
export declare class BytesType implements BytesType {
    constructor(encoding: BytesEncoding);
}
export declare class ConstantType implements ConstantType {
    constructor(name: string, type: ConstantTypeTypes, valuesFuncName: string);
}
export declare class ConstantValue implements ConstantValue {
    constructor(name: string, type: ConstantType, value: ConstantValueValueTypes);
}
export declare class InterfaceType implements InterfaceType {
    constructor(name: string, discriminatorField: string);
}
export declare class LiteralValue implements LiteralValue {
    constructor(type: LiteralValueType, literal: any);
}
export declare class MapType implements MapType {
    constructor(valueType: MapValueType, valueTypeByValue: boolean);
}
export declare class ModelAnnotations implements ModelAnnotations {
    constructor(omitSerDe: boolean, multipartForm: boolean);
}
export declare class ModelField extends StructField implements ModelField {
    constructor(name: string, type: PossibleType, byValue: boolean, serializedName: string, annotations: ModelFieldAnnotations);
}
export declare class ModelFieldAnnotations implements ModelFieldAnnotations {
    constructor(required: boolean, readOnly: boolean, isAddlProps: boolean, isDiscriminator: boolean);
}
export declare class ModelType extends StructType implements ModelType {
    constructor(name: string, annotations: ModelAnnotations, usage: UsageFlags);
}
export declare class PolymorphicType extends StructType implements PolymorphicType {
    constructor(name: string, iface: InterfaceType, annotations: ModelAnnotations, usage: UsageFlags);
}
export declare class PrimitiveType implements PrimitiveType {
    constructor(typeName: PrimitiveTypeName, encodeAsString?: boolean);
}
export declare class QualifiedType implements QualifiedType {
    constructor(exportName: string, packageName: string);
}
export declare class SliceType implements SliceType {
    constructor(elementType: SliceElementType, elementTypeByValue: boolean);
}
export declare class TimeType implements TimeType {
    constructor(format: DateTimeFormat, utc: boolean);
}
export declare class XMLInfo implements XMLInfo {
    constructor();
}
//# sourceMappingURL=type.d.ts.map