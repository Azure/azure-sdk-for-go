/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
import { CodeModelError } from "./errors.js";
// UsageFlags are bit flags indicating how a model/polymorphic type is used
export var UsageFlags;
(function (UsageFlags) {
    // the type is unreferenced
    UsageFlags[UsageFlags["None"] = 0] = "None";
    // the type is received over the wire
    UsageFlags[UsageFlags["Input"] = 1] = "Input";
    // the type is sent over the wire
    UsageFlags[UsageFlags["Output"] = 2] = "Output";
})(UsageFlags || (UsageFlags = {}));
export function isBytesType(type) {
    return type.encoding !== undefined;
}
export function isConstantType(type) {
    return type.values !== undefined;
}
export function isLiteralValueType(type) {
    return isConstantType(type) || isPrimitiveType(type);
}
export function isPrimitiveType(type) {
    return type.typeName !== undefined;
}
export function isQualifiedType(type) {
    return type.exportName !== undefined;
}
export function isTimeType(type) {
    return type.dateTimeFormat !== undefined;
}
export function isMapType(type) {
    return type.valueType !== undefined;
}
export function isModelType(type) {
    return type.fields !== undefined;
}
export function isPolymorphicType(type) {
    return type.interface !== undefined;
}
export function isSliceType(type) {
    return type.elementType !== undefined;
}
export function isInterfaceType(type) {
    return type.possibleTypes !== undefined;
}
export function isLiteralValue(type) {
    return type.literal !== undefined;
}
export function getLiteralValueTypeName(literal) {
    if (isBytesType(literal)) {
        return '[]byte';
    }
    else if (isConstantType(literal)) {
        return literal.name;
    }
    else if (isPrimitiveType(literal)) {
        return literal.typeName;
    }
    else if (isTimeType(literal)) {
        return 'time.Time';
    }
    else {
        throw new CodeModelError(`unhandled LiteralValueType ${getTypeDeclaration(literal)}`);
    }
}
export function getTypeDeclaration(type, pkgName) {
    if (isPrimitiveType(type)) {
        return type.typeName;
    }
    else if (isQualifiedType(type)) {
        let pkg = type.packageName;
        const pathChar = pkg.lastIndexOf('/');
        if (pathChar) {
            pkg = pkg.substring(pathChar + 1);
        }
        return pkg + '.' + type.exportName;
    }
    else if (isConstantType(type) || isInterfaceType(type) || isModelType(type) || isPolymorphicType(type)) {
        if (pkgName) {
            return `${pkgName}.${type.name}`;
        }
        return type.name;
    }
    else if (isBytesType(type)) {
        return '[]byte';
    }
    else if (isLiteralValue(type)) {
        return getTypeDeclaration(type.type, pkgName);
    }
    else if (isMapType(type)) {
        let pointer = '*';
        if (type.valueTypeByValue) {
            pointer = '';
        }
        return `map[string]${pointer}` + getTypeDeclaration(type.valueType, pkgName);
    }
    else if (isSliceType(type)) {
        let pointer = '*';
        if (type.elementTypeByValue) {
            pointer = '';
        }
        return `[]${pointer}` + getTypeDeclaration(type.elementType, pkgName);
    }
    else if (isTimeType(type)) {
        return 'time.Time';
    }
    else {
        throw new CodeModelError(`unhandled type ${typeof (type)}`);
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
// Base classes first (StructField and StructType are base classes)
export class StructField {
    constructor(name, type, byValue) {
        this.name = name;
        this.type = type;
        this.byValue = byValue;
        this.docs = {};
    }
}
export class StructType {
    constructor(name) {
        this.fields = new Array();
        this.name = name;
        this.docs = {};
    }
}
// Derived and standalone classes in alphabetical order
export class BytesType {
    constructor(encoding) {
        this.encoding = encoding;
    }
}
export class ConstantType {
    constructor(name, type, valuesFuncName) {
        this.name = name;
        this.type = type;
        this.values = new Array();
        this.valuesFuncName = valuesFuncName;
        this.docs = {};
    }
}
export class ConstantValue {
    constructor(name, type, value) {
        this.name = name;
        this.type = type;
        this.value = value;
        this.docs = {};
    }
}
export class InterfaceType {
    // possibleTypes and rootType are required. however, we have a chicken-and-egg
    // problem as creating a PolymorphicType requires the necessary InterfaceType.
    // so these fields MUST be populated after creating the InterfaceType.
    constructor(name, discriminatorField) {
        this.name = name;
        this.discriminatorField = discriminatorField;
        this.possibleTypes = new Array();
        this.docs = {};
    }
}
export class LiteralValue {
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    constructor(type, literal) {
        this.type = type;
        /* eslint-disable-next-line @typescript-eslint/no-unsafe-assignment */
        this.literal = literal;
    }
}
export class MapType {
    constructor(valueType, valueTypeByValue) {
        this.valueType = valueType;
        this.valueTypeByValue = valueTypeByValue;
    }
}
export class ModelAnnotations {
    constructor(omitSerDe, multipartForm) {
        this.omitSerDeMethods = omitSerDe;
        this.multipartFormData = multipartForm;
    }
}
export class ModelField extends StructField {
    constructor(name, type, byValue, serializedName, annotations) {
        super(name, type, byValue);
        this.serializedName = serializedName;
        this.annotations = annotations;
    }
}
export class ModelFieldAnnotations {
    constructor(required, readOnly, isAddlProps, isDiscriminator) {
        this.required = required;
        this.readOnly = readOnly;
        this.isAdditionalProperties = isAddlProps;
        this.isDiscriminator = isDiscriminator;
    }
}
export class ModelType extends StructType {
    constructor(name, annotations, usage) {
        super(name);
        this.annotations = annotations;
        this.usage = usage;
        this.fields = new Array();
    }
}
export class PolymorphicType extends StructType {
    constructor(name, iface, annotations, usage) {
        super(name);
        this.interface = iface;
        this.annotations = annotations;
        this.usage = usage;
        this.fields = new Array();
    }
}
export class PrimitiveType {
    constructor(typeName, encodeAsString) {
        this.typeName = typeName;
        this.encodeAsString = encodeAsString ?? false;
    }
}
export class QualifiedType {
    constructor(exportName, packageName) {
        this.exportName = exportName;
        this.packageName = packageName;
    }
}
export class SliceType {
    constructor(elementType, elementTypeByValue) {
        this.elementType = elementType;
        this.elementTypeByValue = elementTypeByValue;
    }
}
export class TimeType {
    constructor(format, utc) {
        this.dateTimeFormat = format;
        this.utc = utc;
    }
}
export class XMLInfo {
    constructor() {
        this.attribute = false;
        this.text = false;
    }
}
//# sourceMappingURL=type.js.map