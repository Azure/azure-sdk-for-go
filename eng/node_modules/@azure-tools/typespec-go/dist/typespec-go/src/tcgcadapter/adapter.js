/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { clientAdapter } from './clients.js';
import { AdapterError } from './errors.js';
import { typeAdapter } from './types.js';
import * as go from '../../../codemodel.go/src/index.js';
import { packageNameFromOutputFolder, trimPackagePrefix } from '../../../naming.go/src/naming.js';
import * as tcgc from '@azure-tools/typespec-client-generator-core';
import { NoTarget } from '@typespec/compiler';
import { createRequire } from 'module';
const headerText = `Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the MIT License. See License.txt in the project root for license information.
Code generated by Microsoft (R) Go Code Generator.`;
export async function tcgcToGoCodeModel(context) {
    const info = new go.Info('TODO Title');
    const options = new go.Options(headerText, context.options['generate-fakes'] === true, context.options['inject-spans'] === true, context.options['disallow-unknown-fields'] === true, context.options['generate-examples'] === true || context.options['generate-samples'] === true // generate-examples has been deprecated, for compat we still support it.
    );
    if (context.options['azcore-version']) {
        options.azcoreVersion = context.options['azcore-version'];
    }
    // @encodedName can be used in XML scenarios, it
    // is effectively the same as TypeSpec.Xml.@name.
    // however, it's filtered out by default so we need
    // to add it to the allow list of decorators
    const sdkContext = await tcgc.createSdkContext(context, '@azure-tools/typespec-go', {
        additionalDecorators: ['TypeSpec\\.@encodedName'],
        disableUsageAccessPropagationToBase: true,
    });
    context.program.reportDiagnostics(sdkContext.diagnostics);
    let codeModelType = 'data-plane';
    if (sdkContext.arm === true) {
        codeModelType = 'azure-arm';
    }
    const codeModel = new go.CodeModel(info, codeModelType, packageNameFromOutputFolder(context.emitterOutputDir), options);
    const packageJson = createRequire(import.meta.url)('../../../../package.json');
    codeModel.metadata = {
        ...sdkContext.sdkPackage.metadata,
        emitterVersion: packageJson['version']
    };
    if (context.options.module && context.options['module-version']) {
        codeModel.options.module = new go.Module(context.options.module, context.options['module-version']);
    }
    else if (context.options.module || context.options['module-version']) {
        throw new AdapterError('InvalidArgument', '--module and --module-version must both or neither be set', NoTarget);
    }
    if (context.options['rawjson-as-bytes']) {
        codeModel.options.rawJSONAsBytes = true;
    }
    if (context.options['slice-elements-byval']) {
        codeModel.options.sliceElementsByval = true;
    }
    codeModel.options.factoryGatherAllParams = true;
    if (context.options['factory-gather-all-params'] === false) {
        codeModel.options.factoryGatherAllParams = false;
    }
    fixStutteringTypeNames(sdkContext.sdkPackage, codeModel, context.options);
    const ta = new typeAdapter(codeModel);
    ta.adaptTypes(sdkContext);
    const ca = new clientAdapter(ta, context.options);
    ca.adaptClients(sdkContext.sdkPackage);
    codeModel.sortContent();
    return codeModel;
}
function fixStutteringTypeNames(sdkPackage, codeModel, options) {
    let stutteringPrefix = codeModel.packageName;
    if (options.stutter) {
        stutteringPrefix = options.stutter;
    }
    else {
        // if there's a well-known prefix, remove it
        if (stutteringPrefix.startsWith('arm')) {
            stutteringPrefix = stutteringPrefix.substring(3);
        }
        else if (stutteringPrefix.startsWith('az')) {
            stutteringPrefix = stutteringPrefix.substring(2);
        }
    }
    stutteringPrefix = stutteringPrefix.toUpperCase();
    // ensure that enum, client, and struct type names don't stutter
    const recursiveWalkClients = function (client) {
        client.name = trimPackagePrefix(stutteringPrefix, client.name);
        // fix up the synthesized type names for page responses
        if (client.children && client.children.length > 0) {
            for (const child of client.children) {
                recursiveWalkClients(child);
            }
        }
        for (const sdkMethod of client.methods) {
            if (sdkMethod.kind !== 'paging') {
                continue;
            }
            for (const httpResp of sdkMethod.operation.responses.values()) {
                if (!httpResp.type || httpResp.type.kind !== 'model') {
                    continue;
                }
                httpResp.type.name = trimPackagePrefix(stutteringPrefix, httpResp.type.name);
            }
        }
    };
    for (const sdkClient of sdkPackage.clients) {
        recursiveWalkClients(sdkClient);
    }
    // check if the name collides with an existing name. we only do
    // this for model types as clients and enums get a suffix.
    const nameCollision = function (newName) {
        for (const modelType of sdkPackage.models) {
            if (modelType.name === newName) {
                return true;
            }
        }
        return false;
    };
    // tracks type name collilsions due to renaming
    const collisions = new Array();
    // trims the stuttering prefix from typeName and returns the new name.
    // if there's a collision, an entry is added to the collision list.
    const renameType = function (typeName) {
        const originalName = typeName;
        const newName = trimPackagePrefix(stutteringPrefix, originalName);
        // if the type was renamed to remove stuttering, check if it collides with an existing type name
        if (newName !== originalName && nameCollision(newName)) {
            collisions.push(`type ${originalName} was renamed to ${newName} which collides with an existing type name`);
        }
        return newName;
    };
    // to keep compat with autorest.go, this is off by default
    if (options['fix-const-stuttering'] === true) {
        for (const sdkEnum of sdkPackage.enums) {
            sdkEnum.name = renameType(sdkEnum.name);
        }
    }
    for (const modelType of sdkPackage.models) {
        modelType.name = renameType(modelType.name);
    }
    if (collisions.length > 0) {
        throw new AdapterError('NameCollision', collisions.join('\n'), NoTarget);
    }
}
//# sourceMappingURL=adapter.js.map