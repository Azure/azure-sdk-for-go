/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { values } from '@azure-tools/linq';
import * as tcgc from '@azure-tools/typespec-client-generator-core';
import { NoTarget } from '@typespec/compiler';
import * as go from '../../../codemodel.go/src/index.js';
import { capitalize, createOptionsTypeDescription, createResponseEnvelopeDescription, ensureNameCase, getEscapedReservedName, uncapitalize } from '../../../naming.go/src/naming.js';
import { AdapterError } from './errors.js';
import { getEndpointType, isTypePassedByValue } from './types.js';
// used to convert SDK clients and their methods to Go code model types
export class clientAdapter {
    ta;
    opts;
    // track all of the client and parameter group params across all operations
    // as not every option might contain them, and parameter groups can be shared
    // across multiple operations
    clientParams;
    constructor(ta, opts) {
        this.ta = ta;
        this.opts = opts;
        this.clientParams = new Map();
    }
    // converts all clients and their methods to Go code model types.
    // this includes parameter groups/options types and response envelopes.
    adaptClients(sdkPackage) {
        if (this.opts['single-client'] && sdkPackage.clients.length > 1) {
            throw new AdapterError('InvalidArgument', 'single-client cannot be enabled when there are multiple clients', NoTarget);
        }
        for (const sdkClient of sdkPackage.clients) {
            // start with instantiable clients and recursively work down
            if (sdkClient.clientInitialization.initializedBy & tcgc.InitializedByFlags.Individually) {
                this.recursiveAdaptClient(sdkClient);
            }
        }
    }
    recursiveAdaptClient(sdkClient, parent) {
        if (sdkClient.methods.length === 0 && (sdkClient.children === undefined || sdkClient.children.length === 0)) {
            // skip generating empty clients
            return undefined;
        }
        let clientName = ensureNameCase(sdkClient.name);
        // to keep compat with existing ARM packages, don't use hierarchically named clients
        if (parent && this.ta.codeModel.type !== 'azure-arm') {
            // for hierarchical clients, the child client names are built
            // from the parent client name. this is because tsp allows subclients
            // with the same name. consider the following example.
            //
            // namespace Chat {
            //   interface Completions {
            //     ...
            //   }
            // }
            // interface Completions { ... }
            //
            // we want to generate two clients from this,
            // one name ChatCompletions and the other Completions
            // strip off the Client suffix from the parent client name
            clientName = parent.name.substring(0, parent.name.length - 6) + clientName;
        }
        if (!clientName.match(/Client$/)) {
            clientName += 'Client';
        }
        const docs = {
            summary: sdkClient.summary,
            description: sdkClient.doc,
        };
        if (docs.summary) {
            docs.summary = `${clientName} - ${docs.summary}`;
        }
        else if (docs.description) {
            docs.description = `${clientName} - ${docs.description}`;
        }
        else {
            // strip clientName's "Client" suffix
            const groupName = clientName.substring(0, clientName.length - 6);
            docs.summary = `${clientName} contains the methods for the ${groupName} group.`;
        }
        const goClient = new go.Client(clientName, docs, go.newClientOptions(this.ta.codeModel.type, clientName));
        goClient.parent = parent;
        // anything other than public means non-instantiable client
        if (sdkClient.clientInitialization.initializedBy & tcgc.InitializedByFlags.Individually) {
            for (const param of sdkClient.clientInitialization.parameters) {
                if (param.kind === 'credential') {
                    // skip this for now as we don't generate client constructors
                    continue;
                }
                else if (param.kind === 'endpoint') {
                    const paramType = getEndpointType(param);
                    // this will either be a fixed or templated host
                    // don't set the fixed host for ARM as it isn't used
                    if (this.ta.codeModel.type !== 'azure-arm') {
                        goClient.host = paramType.serverUrl;
                    }
                    if (paramType.templateArguments.length === 0) {
                        // this is the param for the fixed host, don't create a param for it
                        if (!this.ta.codeModel.host) {
                            this.ta.codeModel.host = goClient.host;
                        }
                        else if (this.ta.codeModel.host !== goClient.host) {
                            throw new AdapterError('InternalError', `client ${goClient.name} has a conflicting host ${goClient.host}`, NoTarget);
                        }
                    }
                    else {
                        goClient.templatedHost = true;
                        for (const templateArg of paramType.templateArguments) {
                            goClient.parameters.push(this.adaptURIParam(templateArg));
                        }
                    }
                    continue;
                }
                else if (param.kind === 'method') {
                    // some client params, notably api-version, can be explicitly
                    // defined in the operation signature:
                    // e.g. op withQueryApiVersion(@query("api-version") apiVersion: string)
                    // these get propagated to sdkMethod.operation.parameters thus they
                    // will be adapted in adaptMethodParameters()
                    continue;
                }
                goClient.parameters.push(this.adaptURIParam(param));
            }
        }
        else if (parent) {
            // this is a sub-client. it will share the client/host params of the parent.
            // NOTE: we must propagate parant params before a potential recursive call
            // to create a child client that will need to inherit our client params.
            goClient.templatedHost = parent.templatedHost;
            goClient.host = parent.host;
            // make a copy of the client params. this is to prevent
            // client method params from being shared across clients
            // as not all client method params might be uniform.
            goClient.parameters = new Array(...parent.parameters);
        }
        else {
            throw new AdapterError('InternalError', `uninstantiable client ${sdkClient.name} has no parent`, NoTarget);
        }
        if (sdkClient.children && sdkClient.children.length > 0) {
            for (const child of sdkClient.children) {
                const subClient = this.recursiveAdaptClient(child, goClient);
                if (subClient) {
                    goClient.clientAccessors.push(new go.ClientAccessor(`New${subClient.name}`, subClient));
                }
            }
        }
        for (const sdkMethod of sdkClient.methods) {
            this.adaptMethod(sdkMethod, goClient);
        }
        if (this.ta.codeModel.type === 'azure-arm' && goClient.clientAccessors.length > 0 && goClient.methods.length === 0) {
            // this is the service client. to keep compat with existing
            // ARM SDKs we skip adding it to the code model in favor of
            // the synthesized client factory.
        }
        else {
            this.ta.codeModel.clients.push(goClient);
        }
        return goClient;
    }
    adaptURIParam(sdkParam) {
        const paramType = this.ta.getPossibleType(sdkParam.type, true, false);
        if (!go.isConstantType(paramType) && !go.isPrimitiveType(paramType)) {
            throw new AdapterError('UnsupportedTsp', `unsupported URI parameter type ${go.getTypeDeclaration(paramType)}`, sdkParam.__raw?.node ?? NoTarget);
        }
        // TODO: follow up with tcgc if serializedName should actually be optional
        return new go.URIParameter(sdkParam.name, sdkParam.serializedName ? sdkParam.serializedName : sdkParam.name, paramType, this.adaptParameterStyle(sdkParam), isTypePassedByValue(sdkParam.type) || !sdkParam.optional, 'client');
    }
    adaptMethod(sdkMethod, goClient) {
        let method;
        const naming = new go.MethodNaming(getEscapedReservedName(uncapitalize(ensureNameCase(sdkMethod.name)), 'Operation'), ensureNameCase(`${sdkMethod.name}CreateRequest`, true), ensureNameCase(`${sdkMethod.name}HandleResponse`, true));
        const getStatusCodes = function (httpOp) {
            const statusCodes = new Array();
            for (const response of httpOp.responses) {
                const statusCode = response.statusCodes;
                if (isHttpStatusCodeRange(statusCode)) {
                    for (let code = statusCode.start; code <= statusCode.end; ++code) {
                        statusCodes.push(code);
                    }
                }
                else {
                    statusCodes.push(statusCode);
                }
            }
            return statusCodes;
        };
        let methodName = capitalize(ensureNameCase(sdkMethod.name));
        if (sdkMethod.access === 'internal') {
            // we add internal to the extra list so we don't end up with a method named "internal"
            // which will collide with an unexported field with the same name.
            methodName = getEscapedReservedName(uncapitalize(methodName), 'Method', ['internal']);
        }
        const statusCodes = getStatusCodes(sdkMethod.operation);
        if (sdkMethod.kind === 'basic') {
            method = new go.Method(methodName, goClient, sdkMethod.operation.path, sdkMethod.operation.verb, statusCodes, naming);
        }
        else if (sdkMethod.kind === 'paging') {
            if (sdkMethod.pagingMetadata.nextLinkReInjectedParametersSegments !== undefined && sdkMethod.pagingMetadata.nextLinkReInjectedParametersSegments.length > 0) {
                throw new AdapterError('UnsupportedTsp', `paging with re-injected parameters is not supported`, sdkMethod.__raw?.node ?? NoTarget);
            }
            method = new go.PageableMethod(methodName, goClient, sdkMethod.operation.path, sdkMethod.operation.verb, statusCodes, naming);
            if (sdkMethod.nextLinkPath) {
                // TODO: handle nested next link
                method.nextLinkName = capitalize(ensureNameCase(sdkMethod.nextLinkPath));
            }
        }
        else if (sdkMethod.kind === 'lro') {
            method = new go.LROMethod(methodName, goClient, sdkMethod.operation.path, sdkMethod.operation.verb, statusCodes, naming);
            const lroOptions = this.hasDecorator('Azure.Core.@useFinalStateVia', sdkMethod.decorators);
            if (lroOptions) {
                method.finalStateVia = lroOptions['finalState'];
            }
            if (sdkMethod.lroMetadata.finalResponse?.resultSegments) {
                // 'resultSegments' is designed for furture extensibility, currently only has one segment
                method.operationLocationResultPath = sdkMethod.lroMetadata.finalResponse.resultSegments.map((segment) => {
                    return segment.serializationOptions.json?.name;
                }).join('.');
            }
        }
        else {
            throw new AdapterError('UnsupportedTsp', `unsupported method kind ${sdkMethod.kind}`, sdkMethod.__raw?.node ?? NoTarget);
        }
        method.docs.summary = sdkMethod.summary;
        method.docs.description = sdkMethod.doc;
        goClient.methods.push(method);
        this.populateMethod(sdkMethod, method);
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    hasDecorator(name, decorators) {
        for (const decorator of decorators) {
            if (decorator.name === name) {
                return decorator.arguments;
            }
        }
        return undefined;
    }
    populateMethod(sdkMethod, method) {
        if (method.kind === 'nextPageMethod') {
            throw new AdapterError('UnsupportedTsp', `unsupported method kind ${sdkMethod.kind}`, sdkMethod.__raw?.node ?? NoTarget);
        }
        let prefix = method.client.name;
        if (this.opts['single-client']) {
            prefix = '';
        }
        if (go.isLROMethod(method)) {
            prefix += 'Begin';
        }
        let optionalParamsGroupName = `${prefix}${method.name}Options`;
        if (sdkMethod.access === 'internal') {
            optionalParamsGroupName = uncapitalize(optionalParamsGroupName);
        }
        let optsGroupName = 'options';
        // if there's an existing parameter with the name options then pick something else
        for (const param of sdkMethod.parameters) {
            if (param.name === optsGroupName) {
                optsGroupName = 'opts';
                break;
            }
        }
        method.optionalParamsGroup = new go.ParameterGroup(optsGroupName, optionalParamsGroupName, false, 'method');
        method.optionalParamsGroup.docs.summary = createOptionsTypeDescription(optionalParamsGroupName, this.getMethodNameForDocComment(method));
        method.responseEnvelope = this.adaptResponseEnvelope(sdkMethod, method);
        // find the api version param to use for the doc comment.
        // we can't use sdkMethod.apiVersions as that includes all
        // of the api versions supported by the service.
        for (const opParam of sdkMethod.operation.parameters) {
            if (opParam.isApiVersionParam && opParam.clientDefaultValue) {
                method.apiVersions.push(opParam.clientDefaultValue);
                break;
            }
        }
        const paramMapping = this.adaptMethodParameters(sdkMethod, method);
        // we must do this after adapting method params as it can add optional params
        this.ta.codeModel.paramGroups.push(this.adaptParameterGroup(method.optionalParamsGroup));
        if (this.ta.codeModel.options.generateExamples) {
            this.adaptHttpOperationExamples(sdkMethod, method, paramMapping);
        }
    }
    adaptMethodParameters(sdkMethod, method) {
        const paramMapping = new Map();
        let optionalGroup;
        if (method.kind !== 'nextPageMethod') {
            // NextPageMethods don't have optional params
            optionalGroup = method.optionalParamsGroup;
            if (go.isLROMethod(method)) {
                optionalGroup.params.push(new go.ResumeTokenParameter());
            }
        }
        const allOpParams = new Array();
        allOpParams.push(...sdkMethod.operation.parameters);
        if (sdkMethod.operation.bodyParam) {
            allOpParams.push(sdkMethod.operation.bodyParam);
        }
        // we must enumerate parameters, not operation.parameters, as it
        // contains the params in tsp order as well as any spread params.
        for (const param of sdkMethod.parameters) {
            // we need to translate from the method param to its underlying operation param.
            // most params have a one-to-one mapping. however, for spread params, there will
            // be a many-to-one mapping. i.e. multiple params will map to the same underlying
            // operation param. each param corresponds to a field within the operation param.
            let opParam = values(allOpParams).where((opParam) => {
                return values(opParam.correspondingMethodParams).where((methodParam) => {
                    if (param.type.kind === 'model') {
                        for (const property of param.type.properties) {
                            if (property === methodParam) {
                                return true;
                            }
                        }
                    }
                    return methodParam === param;
                }).any();
            }).first();
            // special handling for constants that used in path, this will not be in operation parameters since it has been resolved in the url
            if (!opParam && param.type.kind === 'constant') {
                continue;
            }
            // special handling for `@bodyRoot`/`@body` on model param's property
            if (!opParam && param.type.kind === 'model') {
                for (const property of param.type.properties) {
                    opParam = values(allOpParams).where((opParam) => {
                        return values(opParam.correspondingMethodParams).where((methodParam) => {
                            return methodParam === property;
                        }).any();
                    }).first();
                    if (opParam) {
                        break;
                    }
                }
            }
            if (!opParam) {
                throw new AdapterError('InternalError', `didn't find operation parameter for method ${sdkMethod.name} parameter ${param.name}`, sdkMethod.__raw?.node ?? NoTarget);
            }
            if (opParam.kind === 'header' && opParam.serializedName.match(/^content-type$/i) && param.type.kind === 'constant') {
                // if the body param is optional, then the content-type param is also optional.
                // for optional constants, this has the side effect of the param being treated like
                // a flag which isn't what we want. so, we mark it as required. we ONLY do this
                // if the content-type is a constant (i.e. literal value).
                // the content-type will be conditionally set based on the requiredness of the body.
                opParam.optional = false;
            }
            let adaptedParam;
            if (opParam.kind === 'body' && opParam.type.kind === 'model' && opParam.type.kind !== param.type.kind) {
                const paramStyle = this.adaptParameterStyle(param);
                const paramName = getEscapedReservedName(ensureNameCase(param.name, paramStyle === 'required'), 'Param');
                const byVal = isTypePassedByValue(param.type);
                const contentType = this.adaptContentType(opParam.defaultContentType);
                const getSerializedNameFromProperty = function (property) {
                    if (contentType === 'JSON') {
                        return property.serializationOptions.json?.name;
                    }
                    if (contentType === 'XML') {
                        return property.serializationOptions.xml?.name;
                    }
                    if (contentType === 'binary') {
                        return property.serializationOptions.multipart?.name;
                    }
                    return undefined;
                };
                switch (contentType) {
                    case 'JSON':
                    case 'XML': {
                        // find the corresponding field within the model param so we can get the serialized name
                        let serializedName;
                        for (const property of opParam.type.properties) {
                            if (property.name === param.name) {
                                serializedName = getSerializedNameFromProperty(property);
                                break;
                            }
                        }
                        if (!serializedName) {
                            throw new AdapterError('InternalError', `didn't find body model property for spread parameter ${param.name}`, param.__raw?.node ?? NoTarget);
                        }
                        adaptedParam = new go.PartialBodyParameter(paramName, serializedName, contentType, this.ta.getPossibleType(param.type, true, true), paramStyle, byVal);
                        break;
                    }
                    case 'binary':
                        if (opParam.defaultContentType.match(/multipart/i)) {
                            adaptedParam = new go.MultipartFormBodyParameter(paramName, this.ta.getReadSeekCloser(false), paramStyle, byVal);
                        }
                        else {
                            adaptedParam = new go.BodyParameter(paramName, contentType, `"${opParam.defaultContentType}"`, this.ta.getReadSeekCloser(false), paramStyle, byVal);
                        }
                        break;
                    default:
                        throw new AdapterError('UnsupportedTsp', `unsupported spread param content type ${contentType}`, opParam.__raw?.node ?? NoTarget);
                }
            }
            else {
                adaptedParam = this.adaptMethodParameter(opParam);
            }
            adaptedParam.docs.summary = param.summary;
            adaptedParam.docs.description = param.doc;
            method.parameters.push(adaptedParam);
            if (!paramMapping.has(opParam)) {
                paramMapping.set(opParam, new Array());
            }
            paramMapping.get(opParam)?.push(adaptedParam);
            if (adaptedParam.style !== 'required' && adaptedParam.style !== 'literal') {
                // add optional method param to the options param group
                if (!optionalGroup) {
                    throw new AdapterError('InternalError', `optional parameter ${param.name} has no optional parameter group`, param.__raw?.node ?? NoTarget);
                }
                adaptedParam.group = optionalGroup;
                optionalGroup.params.push(adaptedParam);
            }
        }
        // client params aren't included in method.parameters so
        // look for them in the operation parameters.
        for (const opParam of allOpParams) {
            if (opParam.onClient) {
                const adaptedParam = this.adaptMethodParameter(opParam);
                adaptedParam.docs.summary = opParam.summary;
                adaptedParam.docs.description = opParam.doc;
                method.parameters.unshift(adaptedParam);
                if (!paramMapping.has(opParam)) {
                    paramMapping.set(opParam, new Array());
                }
                paramMapping.get(opParam)?.push(adaptedParam);
                // if the adapted client param is a literal then don't add it to
                // the array of client params as it's not a formal parameter.
                if (go.isLiteralParameter(adaptedParam)) {
                    continue;
                }
                // we must check via param name and not reference equality. this is because a client param
                // can be used in multiple ways. e.g. a client param "apiVersion" that's used as a path param
                // in one method and a query param in another.
                if (!method.client.parameters.find((v) => {
                    return v.name === adaptedParam.name;
                })) {
                    method.client.parameters.push(adaptedParam);
                }
            }
        }
        return paramMapping;
    }
    adaptContentType(contentTypeStr) {
        // we only recognize/support JSON, text, and XML content types, so assume anything else is binary
        // NOTE: we check XML before text in order to support text/xml
        let contentType = 'binary';
        if (contentTypeStr.match(/json/i)) {
            contentType = 'JSON';
        }
        else if (contentTypeStr.match(/xml/i)) {
            contentType = 'XML';
        }
        else if (contentTypeStr.match(/text/i)) {
            contentType = 'Text';
        }
        return contentType;
    }
    adaptMethodParameter(param) {
        if (param.isApiVersionParam && param.clientDefaultValue) {
            // we emit the api version param inline as a literal, never as a param.
            // the ClientOptions.APIVersion setting is used to change the version.
            const paramType = new go.LiteralValue(new go.PrimitiveType('string'), param.clientDefaultValue);
            switch (param.kind) {
                case 'header':
                    return new go.HeaderParameter(param.name, param.serializedName, paramType, 'literal', true, 'method');
                case 'path':
                    return new go.PathParameter(param.name, param.serializedName, true, paramType, 'literal', true, 'method');
                case 'query':
                    return new go.QueryParameter(param.name, param.serializedName, true, paramType, 'literal', true, 'method');
                default:
                    throw new AdapterError('UnsupportedTsp', `unsupported API version param kind ${param.kind}`, param.__raw?.node ?? NoTarget);
            }
        }
        let location = 'method';
        const getClientParamsKey = function (param) {
            // include the param kind in the key name as a client param can be used
            // in different places across methods (path/query)
            return `${param.name}-${param.kind}`;
        };
        if (param.onClient) {
            // check if we've already adapted this client parameter
            const clientParam = this.clientParams.get(getClientParamsKey(param));
            if (clientParam) {
                return clientParam;
            }
            location = 'client';
        }
        let adaptedParam;
        const paramStyle = this.adaptParameterStyle(param);
        const paramName = getEscapedReservedName(ensureNameCase(param.name, paramStyle === 'required'), 'Param');
        const byVal = isTypePassedByValue(param.type);
        if (param.kind === 'body') {
            // TODO: form data? (non-multipart)
            if (param.defaultContentType.match(/multipart/i)) {
                adaptedParam = new go.MultipartFormBodyParameter(paramName, this.ta.getPossibleType(param.type, false, true), paramStyle, byVal);
            }
            else {
                const contentType = this.adaptContentType(param.defaultContentType);
                let bodyType = this.ta.getPossibleType(param.type, false, true);
                if (contentType === 'binary') {
                    // tcgc models binary params as 'bytes' but we want an io.ReadSeekCloser
                    bodyType = this.ta.getReadSeekCloser(param.type.kind === 'array');
                }
                adaptedParam = new go.BodyParameter(paramName, contentType, `"${param.defaultContentType}"`, bodyType, paramStyle, byVal);
            }
        }
        else if (param.kind === 'header') {
            if (param.collectionFormat) {
                if (param.collectionFormat === 'multi' || param.collectionFormat === 'form') {
                    throw new AdapterError('InternalError', `unexpected collection format ${param.collectionFormat} for HeaderCollectionParameter`, param.__raw?.node ?? NoTarget);
                }
                // TODO: is hard-coded false for element type by value correct?
                const type = this.ta.getPossibleType(param.type, true, false);
                if (!go.isSliceType(type)) {
                    throw new AdapterError('InternalError', `unexpected type ${go.getTypeDeclaration(type)} for HeaderCollectionParameter ${param.name}`, param.__raw?.node ?? NoTarget);
                }
                adaptedParam = new go.HeaderCollectionParameter(paramName, param.serializedName, type, param.collectionFormat === 'simple' ? 'csv' : param.collectionFormat, paramStyle, byVal, location);
            }
            else {
                adaptedParam = new go.HeaderParameter(paramName, param.serializedName, this.adaptHeaderType(param.type, true), paramStyle, byVal, location);
            }
        }
        else if (param.kind === 'path') {
            adaptedParam = new go.PathParameter(paramName, param.serializedName, !param.allowReserved, this.adaptPathParameterType(param.type), paramStyle, byVal, location);
        }
        else if (param.kind === 'cookie') {
            // TODO: currently we don't have Azure service using cookie parameter. need to add support if needed in the future.
            throw new AdapterError('UnsupportedTsp', 'unsupported parameter type cookie', param.__raw?.node ?? NoTarget);
        }
        else {
            if (param.collectionFormat) {
                const type = this.ta.getPossibleType(param.type, true, false);
                if (!go.isSliceType(type)) {
                    throw new AdapterError('InternalError', `unexpected type ${go.getTypeDeclaration(type)} for QueryCollectionParameter ${param.name}`, param.__raw?.node ?? NoTarget);
                }
                // TODO: unencoded query param
                adaptedParam = new go.QueryCollectionParameter(paramName, param.serializedName, true, type, param.collectionFormat === 'simple' ? 'csv' : (param.collectionFormat === 'form' ? 'multi' : param.collectionFormat), paramStyle, byVal, location);
            }
            else {
                // TODO: unencoded query param
                adaptedParam = new go.QueryParameter(paramName, param.serializedName, true, this.adaptQueryParameterType(param.type), paramStyle, byVal, location);
            }
        }
        if (adaptedParam.location === 'client') {
            // track client parameter for later use
            this.clientParams.set(getClientParamsKey(param), adaptedParam);
        }
        return adaptedParam;
    }
    getMethodNameForDocComment(method) {
        let methodName;
        switch (method.kind) {
            case 'lroMethod':
            case 'lroPageableMethod':
                methodName = `Begin${method.name}`;
                break;
            case 'method':
                methodName = method.name;
                break;
            case 'pageableMethod':
                methodName = `New${method.name}Pager`;
                break;
        }
        return `${method.client.name}.${methodName}`;
    }
    adaptResponseEnvelope(sdkMethod, method) {
        // TODO: add Envelope suffix if name collides with existing type
        let prefix = method.client.name;
        if (this.opts['single-client']) {
            prefix = '';
        }
        let respEnvName = `${prefix}${method.name}Response`;
        if (sdkMethod.access === 'internal') {
            respEnvName = uncapitalize(respEnvName);
        }
        const respEnv = new go.ResponseEnvelope(respEnvName, { summary: createResponseEnvelopeDescription(respEnvName, this.getMethodNameForDocComment(method)) }, method);
        this.ta.codeModel.responseEnvelopes.push(respEnv);
        // add any headers
        const addedHeaders = new Set();
        for (const httpResp of sdkMethod.operation.responses) {
            for (const httpHeader of httpResp.headers) {
                if (addedHeaders.has(httpHeader.serializedName)) {
                    continue;
                }
                else if (go.isLROMethod(method) && httpHeader.serializedName.match(/Azure-AsyncOperation|Location|Operation-Location|Retry-After/i)) {
                    // we omit the LRO polling headers as they aren't useful on the response envelope
                    continue;
                }
                // TODO: x-ms-header-collection-prefix
                const headerResp = new go.HeaderResponse(ensureNameCase(httpHeader.serializedName), this.adaptHeaderType(httpHeader.type, false), httpHeader.serializedName, isTypePassedByValue(httpHeader.type));
                headerResp.docs.summary = httpHeader.summary;
                headerResp.docs.description = httpHeader.doc;
                respEnv.headers.push(headerResp);
                addedHeaders.add(httpHeader.serializedName);
            }
        }
        let sdkResponseType = sdkMethod.response.type;
        // since HEAD requests don't return a type, we must check this before checking sdkResponseType
        if (method.httpMethod === 'head' && this.opts['head-as-boolean'] === true) {
            respEnv.result = new go.HeadAsBooleanResult('Success');
            respEnv.result.docs.summary = 'Success indicates if the operation succeeded or failed.';
        }
        if (!sdkResponseType) {
            // method doesn't return a type, so we're done
            return respEnv;
        }
        if (sdkResponseType.kind === 'nullable') {
            // unwrap the nullable type, this will only happen for operations with two responses and one of them does not have a body
            sdkResponseType = sdkResponseType.type;
        }
        // for paged methods, tcgc models the method response type as an Array<T>.
        // however, we want the synthesized paged response envelope as that's what Go returns.
        if (sdkMethod.kind === 'paging') {
            // grab the paged response envelope type from the first response
            sdkResponseType = values(sdkMethod.operation.responses).first().type;
        }
        // we have a response type, determine the content type
        let contentType = 'binary';
        if (sdkMethod.kind === 'lro') {
            // we can't grovel through the operation responses for LROs as some of them
            // return only headers, thus have no content type. while it's highly likely
            // to only ever be JSON, this will be broken for LROs that return text/plain
            // or a binary response. the former seems unlikely, the latter though...??
            // TODO: https://github.com/Azure/typespec-azure/issues/535
            contentType = 'JSON';
        }
        else {
            let foundResp = false;
            for (const httpResp of sdkMethod.operation.responses) {
                if (!httpResp.type || !httpResp.defaultContentType || httpResp.type.kind !== sdkResponseType.kind) {
                    continue;
                }
                contentType = this.adaptContentType(httpResp.defaultContentType);
                foundResp = true;
                break;
            }
            if (!foundResp) {
                throw new AdapterError('InternalError', `didn't find HTTP response for kind ${sdkResponseType.kind} in method ${method.name}`, sdkResponseType.__raw?.node ?? NoTarget);
            }
        }
        if (contentType === 'binary') {
            respEnv.result = new go.BinaryResult('Body', 'binary');
            respEnv.result.docs.summary = 'Body contains the streaming response.';
            return respEnv;
        }
        else if (sdkResponseType.kind === 'model') {
            let modelType;
            const modelName = ensureNameCase(sdkResponseType.name).toUpperCase();
            for (const model of this.ta.codeModel.models) {
                if (model.name.toUpperCase() === modelName) {
                    modelType = model;
                    break;
                }
            }
            if (!modelType) {
                throw new AdapterError('InternalError', `didn't find model type name ${sdkResponseType.name} for response envelope ${respEnv.name}`, sdkResponseType.__raw?.node ?? NoTarget);
            }
            if (go.isPolymorphicType(modelType)) {
                respEnv.result = new go.PolymorphicResult(modelType.interface);
            }
            else {
                if (contentType !== 'JSON' && contentType !== 'XML') {
                    throw new AdapterError('InternalError', `unexpected content type ${contentType} for model ${modelType.name}`, NoTarget);
                }
                respEnv.result = new go.ModelResult(modelType, contentType);
            }
            respEnv.result.docs.summary = sdkResponseType.summary;
            respEnv.result.docs.description = sdkResponseType.doc;
        }
        else {
            const resultType = this.ta.getPossibleType(sdkResponseType, false, false);
            if (go.isInterfaceType(resultType) || go.isLiteralValue(resultType) || go.isModelType(resultType) || go.isPolymorphicType(resultType) || go.isQualifiedType(resultType)) {
                throw new AdapterError('InternalError', `invalid monomorphic result type ${go.getTypeDeclaration(resultType)}`, sdkResponseType.__raw?.node ?? NoTarget);
            }
            respEnv.result = new go.MonomorphicResult(this.recursiveTypeName(sdkResponseType, false), contentType, resultType, isTypePassedByValue(sdkResponseType));
        }
        return respEnv;
    }
    /**
     * creates the monomorphic response field name based on its type.
     *
     * for unknown, use Interface or RawJSON if setting is enabled
     * for basic type, map of basic type, map of UDTs, enum, use Value
     * for array of basic type, array of UDTs, use xxxArray
     *
     * @param type the type for which to create a name
     * @param fromArray indicates if there was recursion from a parent array
     * @returns the name
     */
    recursiveTypeName(type, fromArray) {
        if (!fromArray) {
            switch (type.kind) {
                case 'array':
                    return `${this.recursiveTypeName(type.valueType, true)}Array`;
                case 'nullable':
                    return this.recursiveTypeName(type.type, false);
                case 'unknown':
                    return this.ta.codeModel.options.rawJSONAsBytes ? 'RawJSON' : 'Interface';
                default:
                    return 'Value';
            }
        }
        switch (type.kind) {
            case 'array':
                return `${this.recursiveTypeName(type.valueType, true)}Array`;
            case 'boolean':
                return 'Bool';
            case 'bytes':
                return 'ByteArray';
            case 'enum':
            case 'model':
                return ensureNameCase(type.name);
            case 'utcDateTime':
            case 'offsetDateTime':
                return 'Time';
            case 'decimal':
            case 'decimal128':
                return 'Float64';
            case 'dict':
                return `MapOf${this.recursiveTypeName(type.valueType, fromArray)}`;
            case 'float32':
            case 'float64':
            case 'int16':
            case 'int32':
            case 'int64':
            case 'int8':
                return capitalize(type.kind);
            case 'nullable':
                return this.recursiveTypeName(type.type, fromArray);
            case 'duration':
            case 'string':
            case 'url':
                return 'String';
            case 'unknown':
                return this.ta.codeModel.options.rawJSONAsBytes ? 'RawJSON' : 'Interface';
            default:
                throw new Error(`unhandled monomorphic response type kind ${type.kind}`);
        }
    }
    adaptParameterGroup(paramGroup) {
        const structType = new go.StructType(paramGroup.groupName);
        structType.docs = paramGroup.docs;
        for (const param of paramGroup.params) {
            if (param.style === 'literal') {
                continue;
            }
            let byValue = param.style === 'required' || (param.location === 'client' && go.isClientSideDefault(param.style));
            // if the param isn't required, check if it should be passed by value or not.
            // optional params that are implicitly nil-able shouldn't be pointer-to-type.
            if (!byValue) {
                byValue = param.byValue;
            }
            const field = new go.StructField(param.name, param.type, byValue);
            field.docs = param.docs;
            structType.fields.push(field);
        }
        return structType;
    }
    adaptHeaderType(sdkType, forParam) {
        // for header params, we never pass the element type by pointer
        const type = this.ta.getPossibleType(sdkType, forParam, false);
        if (go.isInterfaceType(type) || go.isMapType(type) || go.isModelType(type) || go.isPolymorphicType(type) || go.isSliceType(type) || go.isQualifiedType(type)) {
            throw new AdapterError('InternalError', `unexpected header parameter type ${sdkType.kind}`, sdkType.__raw?.node ?? NoTarget);
        }
        return type;
    }
    adaptPathParameterType(sdkType) {
        const type = this.ta.getPossibleType(sdkType, false, false);
        if (go.isMapType(type) || go.isInterfaceType(type) || go.isModelType(type) || go.isPolymorphicType(type) || go.isSliceType(type) || go.isQualifiedType(type)) {
            throw new AdapterError('InternalError', `unexpected path parameter type ${sdkType.kind}`, sdkType.__raw?.node ?? NoTarget);
        }
        return type;
    }
    adaptQueryParameterType(sdkType) {
        const type = this.ta.getPossibleType(sdkType, false, false);
        if (go.isMapType(type) || go.isInterfaceType(type) || go.isModelType(type) || go.isPolymorphicType(type) || go.isSliceType(type) || go.isQualifiedType(type)) {
            throw new AdapterError('InternalError', `unexpected query parameter type ${sdkType.kind}`, sdkType.__raw?.node ?? NoTarget);
        }
        return type;
    }
    adaptParameterStyle(param) {
        // NOTE: must check for constant type first as it will also set clientDefaultValue
        if (param.type.kind === 'constant') {
            if (param.optional) {
                return 'flag';
            }
            return 'literal';
        }
        else if (param.clientDefaultValue) {
            const adaptedType = this.ta.getPossibleType(param.type, false, false);
            if (!go.isLiteralValueType(adaptedType)) {
                throw new AdapterError('InternalError', `unexpected client side default type ${go.getTypeDeclaration(adaptedType)} for parameter ${param.name}`, param.__raw?.node ?? NoTarget);
            }
            return new go.ClientSideDefault(new go.LiteralValue(adaptedType, param.clientDefaultValue));
        }
        else if (param.optional) {
            return 'optional';
        }
        else {
            return 'required';
        }
    }
    adaptHttpOperationExamples(sdkMethod, method, paramMapping) {
        if (sdkMethod.operation.examples) {
            for (const example of sdkMethod.operation.examples) {
                const goExample = new go.MethodExample(example.name, { summary: example.doc }, example.filePath);
                for (const param of example.parameters) {
                    if (param.parameter.isApiVersionParam && param.parameter.clientDefaultValue) {
                        // skip the api-version param as it's not a formal parameter
                        continue;
                    }
                    const goParams = paramMapping.get(param.parameter);
                    if (!goParams) {
                        throw new AdapterError('InternalError', `can not find go param for example param ${param.parameter.name}`, NoTarget);
                    }
                    if (goParams.length > 1) {
                        // spread case
                        for (const goParam of goParams) {
                            const propertyValue = param.value.value[goParam.serializedName];
                            const paramExample = new go.ParameterExample(goParam, this.adaptExampleType(propertyValue, goParam?.type));
                            if (goParam.group) {
                                goExample.optionalParamsGroup.push(paramExample);
                            }
                            else {
                                goExample.parameters.push(paramExample);
                            }
                        }
                    }
                    else {
                        const paramExample = new go.ParameterExample(goParams[0], this.adaptExampleType(param.value, goParams[0]?.type));
                        if (goParams[0]?.group) {
                            goExample.optionalParamsGroup.push(paramExample);
                        }
                        else {
                            goExample.parameters.push(paramExample);
                        }
                    }
                }
                // only handle 200 response
                const response = example.responses.find((v) => { return v.statusCode === 200; });
                if (response) {
                    goExample.responseEnvelope = new go.ResponseEnvelopeExample(method.responseEnvelope);
                    for (const header of response.headers) {
                        const goHeader = method.responseEnvelope.headers.find(h => h.headerName === header.header.serializedName);
                        if (!goHeader) {
                            throw new AdapterError('InternalError', `can not find go header for example header ${header.header.serializedName}`, NoTarget);
                        }
                        goExample.responseEnvelope.headers.push(new go.ResponseHeaderExample(goHeader, this.adaptExampleType(header.value, goHeader.type)));
                    }
                    // there are some problems with LROs at present which can cause the result
                    // to be undefined even though the operation returns a response.
                    // TODO: https://github.com/Azure/typespec-azure/issues/1688
                    if (response.bodyValue && method.responseEnvelope.result) {
                        if (go.isAnyResult(method.responseEnvelope.result)) {
                            goExample.responseEnvelope.result = this.adaptExampleType(response.bodyValue, new go.PrimitiveType('any'));
                        }
                        else if (go.isModelResult(method.responseEnvelope.result)) {
                            goExample.responseEnvelope.result = this.adaptExampleType(response.bodyValue, method.responseEnvelope.result.modelType);
                        }
                        else if (go.isBinaryResult(method.responseEnvelope.result)) {
                            goExample.responseEnvelope.result = this.adaptExampleType(response.bodyValue, new go.PrimitiveType('byte'));
                        }
                        else if (go.isMonomorphicResult(method.responseEnvelope.result)) {
                            goExample.responseEnvelope.result = this.adaptExampleType(response.bodyValue, method.responseEnvelope.result.monomorphicType);
                        }
                        else if (go.isPolymorphicResult(method.responseEnvelope.result)) {
                            goExample.responseEnvelope.result = this.adaptExampleType(response.bodyValue, method.responseEnvelope.result.interfaceType);
                        }
                    }
                }
                method.examples.push(goExample);
            }
        }
    }
    adaptExampleType(exampleType, goType) {
        switch (exampleType.kind) {
            case 'string':
                if (go.isConstantType(goType) || go.isBytesType(goType) || go.isLiteralValue(goType) || go.isTimeType(goType) || go.isPrimitiveType(goType)) {
                    return new go.StringExample(exampleType.value, goType);
                }
                if (go.isQualifiedType(goType)) {
                    return new go.QualifiedExample(goType, exampleType.value);
                }
                break;
            case 'number':
                if (go.isConstantType(goType) || go.isLiteralValue(goType) || go.isTimeType(goType) || go.isPrimitiveType(goType)) {
                    return new go.NumberExample(exampleType.value, goType);
                }
                break;
            case 'boolean':
                if (go.isConstantType(goType) || go.isLiteralValue(goType) || go.isPrimitiveType(goType)) {
                    return new go.BooleanExample(exampleType.value, goType);
                }
                break;
            case 'null':
                return new go.NullExample(goType);
            case 'unknown':
                if (go.isPrimitiveType(goType) && goType.typeName === 'any') {
                    return new go.AnyExample(exampleType.value);
                }
                break;
            case 'array':
                if (go.isSliceType(goType)) {
                    const ret = new go.ArrayExample(goType);
                    for (const v of exampleType.value) {
                        ret.value.push(this.adaptExampleType(v, goType.elementType));
                    }
                    return ret;
                }
                break;
            case 'dict':
                if (go.isMapType(goType)) {
                    const ret = new go.DictionaryExample(goType);
                    for (const [k, v] of Object.entries(exampleType.value)) {
                        ret.value[k] = this.adaptExampleType(v, goType.valueType);
                    }
                    return ret;
                }
                break;
            case 'union':
                throw new AdapterError('UnsupportedTsp', 'unsupported example type kind union', NoTarget);
            case 'model':
                if (go.isModelType(goType) || go.isInterfaceType(goType)) {
                    let concreteType;
                    if (go.isInterfaceType(goType)) {
                        /* eslint-disable-next-line @typescript-eslint/no-unsafe-member-access */
                        concreteType = goType.possibleTypes.find(t => t.discriminatorValue?.literal === exampleType.type.discriminatorValue || t.discriminatorValue?.literal.value === exampleType.type.discriminatorValue);
                        if (concreteType === undefined) {
                            // can't find the sub type of a discriminated type, fallback to the base type
                            concreteType = goType.rootType;
                        }
                    }
                    else {
                        concreteType = goType;
                    }
                    if (concreteType === undefined) {
                        throw new AdapterError('InternalError', `can not find concrete type for example type ${exampleType.type.name}`, NoTarget);
                    }
                    const ret = new go.StructExample(concreteType);
                    for (const [k, v] of Object.entries(exampleType.value)) {
                        const field = concreteType.fields.find(f => f.serializedName === k);
                        ret.value[field.name] = this.adaptExampleType(v, field.type);
                    }
                    if (exampleType.additionalPropertiesValue) {
                        ret.additionalProperties = {};
                        for (const [k, v] of Object.entries(exampleType.additionalPropertiesValue)) {
                            const filed = concreteType.fields.find(f => f.annotations.isAdditionalProperties);
                            if (go.isMapType(filed.type)) {
                                ret.additionalProperties[k] = this.adaptExampleType(v, filed.type.valueType);
                            }
                            else {
                                throw new AdapterError('InternalError', `additional properties field type should be map type`, NoTarget);
                            }
                        }
                    }
                    return ret;
                }
                break;
        }
        throw new AdapterError('InternalError', `can not map go type into example type ${exampleType.kind}`, NoTarget);
    }
}
function isHttpStatusCodeRange(statusCode) {
    return statusCode.start !== undefined;
}
//# sourceMappingURL=clients.js.map