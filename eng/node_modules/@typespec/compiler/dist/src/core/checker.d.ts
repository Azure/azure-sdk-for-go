import { NameResolver } from "./name-resolver.js";
import type { Program } from "./program.js";
import { BooleanLiteral, BooleanLiteralNode, IntrinsicScalarName, Model, ModelProperty, Node, NumericLiteral, NumericLiteralNode, Scalar, StdTypeName, StdTypes, StringLiteral, StringLiteralNode, Sym, Type, Value } from "./types.js";
export type CreateTypeProps = Omit<Type, "isFinished" | "entityKind" | keyof TypePrototype>;
export interface Checker {
    /**
     * Using this API involves working with the TypeSpec Ast and may change at any time.
     * See https://typespec.io/docs/handbook/breaking-change-policy/
     */
    getTypeForNode(node: Node): Type;
    cloneType<T extends Type>(type: T, additionalProps?: {
        [P in keyof T]?: T[P];
    }): T;
    createType<T extends Type extends any ? CreateTypeProps : never>(typeDef: T): T & TypePrototype & {
        isFinished: boolean;
        readonly entityKind: "Type";
    };
    createAndFinishType<T extends Type extends any ? CreateTypeProps : never>(typeDef: T): T & TypePrototype;
    finishType<T extends Type>(typeDef: T): T;
    createLiteralType(value: string, node?: StringLiteralNode): StringLiteral;
    createLiteralType(value: number, node?: NumericLiteralNode): NumericLiteral;
    createLiteralType(value: boolean, node?: BooleanLiteralNode): BooleanLiteral;
    createLiteralType(value: string | number | boolean, node?: StringLiteralNode | NumericLiteralNode | BooleanLiteralNode): StringLiteral | NumericLiteral | BooleanLiteral;
    createLiteralType(value: string | number | boolean, node?: StringLiteralNode | NumericLiteralNode | BooleanLiteralNode): StringLiteral | NumericLiteral | BooleanLiteral;
    /**
     * Check if the given type is one of the built-in standard TypeSpec Types.
     * @param type Type to check
     * @param stdType If provided check is that standard type
     */
    isStdType(type: Scalar, stdType?: IntrinsicScalarName): type is Scalar & {
        name: IntrinsicScalarName;
    };
    isStdType(type: Type, stdType?: StdTypeName): type is Type & {
        name: StdTypeName;
    };
    /**
     * Std type
     * @param name Name
     */
    getStdType<T extends keyof StdTypes>(name: T): StdTypes[T];
    /**
     * Return the exact type of a value.
     *
     * ```tsp
     * const a: string = "hello";
     * ```
     * calling `getValueExactType` on the value of a would give the string literal "hello".
     * @param value
     */
    getValueExactType(value: Value): Type | undefined;
}
export interface CheckerStats {
    /** Number of types created */
    createdTypes: number;
    /** Number of types finished */
    finishedTypes: number;
}
interface TypePrototype {
}
export interface TypeSpecCompletionItem {
    sym: Sym;
    /**
     *  Optional label if different from the text to complete.
     */
    label?: string;
    /**
     * Optional text to be appended to the completion if accepted.
     */
    suffix?: string;
}
export declare function createChecker(program: Program, resolver: NameResolver): Checker;
/**
 * If the input is anonymous (or the provided filter removes properties)
 * and there exists a named model with the same set of properties
 * (ignoring filtered properties), then return that named model.
 * Otherwise, return the input unchanged.
 *
 * This can be used by emitters to find a better name for a set of
 * properties after filtering. For example, given `{ @metadata prop:
 * string} & SomeName`, and an emitter that wishes to discard properties
 * marked with `@metadata`, the emitter can use this to recover that the
 * best name for the remaining properties is `SomeName`.
 *
 * @param model The input model
 * @param filter An optional filter to apply to the input model's
 * properties.
 */
export declare function getEffectiveModelType(program: Program, model: Model, filter?: (property: ModelProperty) => boolean): Model;
/**
 * Applies a filter to the properties of a given type. If no properties
 * are filtered out, then return the input unchanged. Otherwise, return
 * a new anonymous model with only the filtered properties.
 *
 * @param model The input model to filter.
 * @param filter The filter to apply. Properties are kept when this returns true.
 */
export declare function filterModelProperties(program: Program, model: Model, filter: (property: ModelProperty) => boolean): Model;
/**
 * Gets the property from the nearest base type that is overridden by the
 * given property, if any.
 */
export declare function getOverriddenProperty(property: ModelProperty): ModelProperty | undefined;
/**
 * Enumerates the properties declared by model or inherited from its base.
 *
 * Properties declared by more derived types are enumerated before properties
 * of less derived types.
 *
 * Properties that are overridden are not enumerated.
 */
export declare function walkPropertiesInherited(model: Model): Generator<ModelProperty, void, unknown>;
export declare function finishTypeForProgram<T extends Type>(program: Program, typeDef: T): T;
export {};
//# sourceMappingURL=checker.d.ts.map