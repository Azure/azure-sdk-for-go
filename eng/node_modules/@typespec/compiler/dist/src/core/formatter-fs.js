import { readFile, writeFile } from "fs/promises";
import { globby } from "globby";
import { resolveConfig } from "prettier";
import { PrettierParserError } from "../formatter/parser.js";
import { checkFormat, format, getFormatterFromFilename } from "./formatter.js";
import { createDiagnostic } from "./messages.js";
import { normalizePath } from "./path-utils.js";
import { NoTarget } from "./types.js";
/**
 * Format all the TypeSpec project files(.tsp, tspconfig.yaml).
 * @param patterns List of wildcard pattern searching for TypeSpec files.
 * @returns list of files which failed to format.
 */
export async function formatFiles(patterns, { exclude }) {
    const files = await findFiles(patterns, exclude);
    const errored = [];
    const formatted = [];
    const alreadyFormatted = [];
    const ignored = [];
    for (const file of files) {
        const result = await formatFile(file);
        switch (result.kind) {
            case "formatted":
                formatted.push(file);
                break;
            case "already-formatted":
                alreadyFormatted.push(file);
                break;
            case "ignored":
                ignored.push(file);
                break;
            case "error":
                errored.push([file, result.diagnostic]);
                break;
        }
    }
    return { formatted, ignored, errored, alreadyFormatted };
}
/**
 * Check the format of the files in the given pattern.
 */
export async function checkFilesFormat(patterns, { exclude }) {
    const files = await findFiles(patterns, exclude);
    const errored = [];
    const formatted = [];
    const needsFormat = [];
    const ignored = [];
    for (const file of files) {
        const result = await checkFileFormat(file);
        switch (result.kind) {
            case "formatted":
                formatted.push(file);
                break;
            case "needs-format":
                formatted.push(file);
                break;
            case "ignored":
                ignored.push(file);
                break;
            case "error":
                errored.push([file, result.diagnostic]);
                break;
        }
    }
    return { formatted, needsFormat, ignored, errored };
}
export async function formatFile(filename) {
    const content = await readFile(filename, "utf-8");
    const prettierConfig = await resolveConfig(filename);
    const formatter = getFormatterFromFilename(filename);
    if (formatter === undefined) {
        return { kind: "ignored" };
    }
    try {
        const formattedContent = await format(content, formatter, prettierConfig ?? {});
        if (formattedContent === content) {
            return { kind: "already-formatted" };
        }
        await writeFile(filename, formattedContent);
        return { kind: "formatted" };
    }
    catch (e) {
        if (e instanceof PrettierParserError) {
            return {
                kind: "error",
                diagnostic: createDiagnostic({
                    code: "format-failed",
                    format: { file: filename, details: e.message },
                    target: NoTarget,
                }),
            };
        }
        else {
            throw e;
        }
    }
}
/**
 * Check the given TypeSpec file is correctly formatted.
 */
export async function checkFileFormat(filename) {
    const content = await readFile(filename, "utf-8");
    const prettierConfig = await resolveConfig(filename);
    const formatter = getFormatterFromFilename(filename);
    if (formatter === undefined) {
        return { kind: "ignored" };
    }
    try {
        const formatted = await checkFormat(content, formatter, prettierConfig ?? {});
        return { kind: formatted ? "formatted" : "needs-format" };
    }
    catch (e) {
        if (e instanceof PrettierParserError) {
            return {
                kind: "error",
                diagnostic: createDiagnostic({
                    code: "format-failed",
                    format: { file: filename, details: e.message },
                    target: NoTarget,
                }),
            };
        }
        else {
            throw e;
        }
    }
}
async function findFiles(include, ignore = []) {
    const patterns = [
        ...include.map(normalizePath),
        "!**/node_modules",
        ...ignore.map((x) => `!${normalizePath(x)}`),
    ];
    return globby(patterns);
}
//# sourceMappingURL=formatter-fs.js.map