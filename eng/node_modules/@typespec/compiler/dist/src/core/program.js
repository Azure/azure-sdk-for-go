import pc from "picocolors";
import { validateEncodedNamesConflicts } from "../lib/encoded-names.js";
import { validatePagingOperations } from "../lib/paging.js";
import { MANIFEST } from "../manifest.js";
import { ResolveModuleError, resolveModule, } from "../module-resolver/module-resolver.js";
import { findProjectRoot } from "../utils/io.js";
import { deepEquals, isDefined, mapEquals, mutate } from "../utils/misc.js";
import { createBinder } from "./binder.js";
import { createChecker } from "./checker.js";
import { createSuppressCodeFix } from "./compiler-code-fixes/suppress.codefix.js";
import { compilerAssert } from "./diagnostics.js";
import { flushEmittedFilesPaths } from "./emitter-utils.js";
import { resolveTypeSpecEntrypoint } from "./entrypoint-resolution.js";
import { ExternalError } from "./external-error.js";
import { getLibraryUrlsLoaded } from "./library.js";
import { builtInLinterLibraryName, createBuiltInLinterLibrary, createLinter, resolveLinterDefinition, } from "./linter.js";
import { createLogger } from "./logger/index.js";
import { createTracer } from "./logger/tracer.js";
import { createDiagnostic } from "./messages.js";
import { createResolver } from "./name-resolver.js";
import { parse, parseStandaloneTypeReference } from "./parser.js";
import { getDirectoryPath, joinPaths, resolvePath } from "./path-utils.js";
import { createSourceLoader, loadJsFile, moduleResolutionErrorToDiagnostic, } from "./source-loader.js";
import { createStateAccessors } from "./state-accessors.js";
import { startTimer, time, timeAsync } from "./stats.js";
import { NoTarget, SyntaxKind, } from "./types.js";
export async function compile(host, mainFile, options = {}, oldProgram) {
    const logger = createLogger({ sink: host.logSink });
    const { program, shouldAbort } = await logger.trackAction("Compiling...", "Compiling", async (task) => {
        const result = await createProgram(host, mainFile, options, oldProgram);
        if (result.program.hasError()) {
            task.fail();
        }
        else if (result.program.diagnostics.length > 0) {
            task.warn();
        }
        return result;
    });
    if (shouldAbort) {
        return program;
    }
    const emitStats = {
        total: 0,
        emitters: {},
    };
    const timer = startTimer();
    // Emitter stage
    for (const emitter of program.emitters) {
        // If in dry mode run and an emitter doesn't support it we have to skip it.
        if (program.compilerOptions.dryRun && !emitter.library.definition?.capabilities?.dryRun) {
            continue;
        }
        const { duration } = await emit(emitter, program);
        emitStats.emitters[emitter.metadata.name ?? "<unnamed>"] = duration;
        if (options.listFiles) {
            logEmittedFilesPath(host.logSink);
        }
    }
    emitStats.total = timer.end();
    program.stats.runtime.emit = emitStats;
    return program;
}
async function createProgram(host, mainFile, options = {}, oldProgram) {
    const runtimeStats = {};
    const validateCbs = [];
    const stateMaps = new Map();
    const stateSets = new Map();
    const diagnostics = [];
    const duplicateSymbols = new Set();
    const emitters = [];
    const requireImports = new Map();
    const complexityStats = {};
    let sourceResolution;
    let error = false;
    let continueToNextStage = true;
    const logger = createLogger({ sink: host.logSink });
    const tracer = createTracer(logger, { filter: options.trace });
    const resolvedMain = await resolveTypeSpecEntrypoint(host, mainFile, reportDiagnostic);
    const program = {
        checker: undefined,
        compilerOptions: resolveOptions(options),
        sourceFiles: new Map(),
        jsSourceFiles: new Map(),
        literalTypes: new Map(),
        host,
        diagnostics,
        emitters,
        loadTypeSpecScript,
        getOption,
        stateMaps,
        stateSets,
        stats: {
            complexity: complexityStats,
            runtime: runtimeStats,
        },
        tracer,
        trace,
        ...createStateAccessors(stateMaps, stateSets),
        reportDiagnostic,
        reportDiagnostics,
        reportDuplicateSymbols,
        hasError() {
            return error;
        },
        onValidate(cb, metadata) {
            validateCbs.push({ callback: cb, metadata });
        },
        getGlobalNamespaceType,
        resolveTypeReference,
        /** @internal */
        resolveTypeOrValueReference,
        getSourceFileLocationContext,
        projectRoot: getDirectoryPath(options.config ?? resolvedMain ?? ""),
    };
    trace("compiler.options", JSON.stringify(options, null, 2));
    function trace(area, message) {
        tracer.trace(area, message);
    }
    const binder = createBinder(program);
    if (resolvedMain === undefined) {
        return { program, shouldAbort: true };
    }
    const basedir = getDirectoryPath(resolvedMain) || "/";
    await checkForCompilerVersionMismatch(basedir);
    runtimeStats.loader = await timeAsync(() => loadSources(resolvedMain));
    const emit = options.noEmit ? [] : (options.emit ?? []);
    const emitterOptions = options.options;
    await loadEmitters(basedir, emit, emitterOptions ?? {});
    if (oldProgram &&
        mapEquals(oldProgram.sourceFiles, program.sourceFiles) &&
        deepEquals(oldProgram.compilerOptions, program.compilerOptions)) {
        return { program: oldProgram, shouldAbort: true };
    }
    // let GC reclaim old program, we do not reuse it beyond this point.
    oldProgram = undefined;
    const resolver = createResolver(program);
    runtimeStats.resolver = time(() => resolver.resolveProgram());
    const linter = createLinter(program, (name) => loadLibrary(basedir, name));
    linter.registerLinterLibrary(builtInLinterLibraryName, createBuiltInLinterLibrary(resolver));
    if (options.linterRuleSet) {
        program.reportDiagnostics(await linter.extendRuleSet(options.linterRuleSet));
    }
    program.checker = createChecker(program, resolver);
    runtimeStats.checker = time(() => program.checker.checkProgram());
    complexityStats.createdTypes = program.checker.stats.createdTypes;
    complexityStats.finishedTypes = program.checker.stats.finishedTypes;
    if (!continueToNextStage) {
        return { program, shouldAbort: true };
    }
    // onValidate stage
    await runValidators();
    validateRequiredImports();
    await validateLoadedLibraries();
    if (!continueToNextStage) {
        return { program, shouldAbort: true };
    }
    // Linter stage
    const lintResult = linter.lint();
    runtimeStats.linter = lintResult.stats.runtime;
    program.reportDiagnostics(lintResult.diagnostics);
    return { program, shouldAbort: false };
    /**
     * Validate the libraries loaded during the compilation process are compatible.
     */
    async function validateLoadedLibraries() {
        const loadedRoots = new Set();
        // Check all the files that were loaded
        for (const fileUrl of getLibraryUrlsLoaded()) {
            if (fileUrl.startsWith("file:")) {
                const root = await findProjectRoot(host.stat, host.fileURLToPath(fileUrl));
                if (root) {
                    loadedRoots.add(root);
                }
            }
        }
        const libraries = new Map([...sourceResolution.loadedLibraries.entries()]);
        const incompatibleLibraries = new Map();
        for (const root of loadedRoots) {
            const packageJsonPath = joinPaths(root, "package.json");
            try {
                const packageJson = JSON.parse((await host.readFile(packageJsonPath)).text);
                if (packageJson.name) {
                    const found = libraries.get(packageJson.name);
                    if (found && found.path !== root && found.manifest.version !== packageJson.version) {
                        let incompatibleIndex = incompatibleLibraries.get(packageJson.name);
                        if (incompatibleIndex === undefined) {
                            incompatibleIndex = [found];
                            incompatibleLibraries.set(packageJson.name, incompatibleIndex);
                        }
                        incompatibleIndex.push({ path: root, manifest: packageJson });
                    }
                }
            }
            catch { }
        }
        for (const [name, incompatibleLibs] of incompatibleLibraries) {
            reportDiagnostic(createDiagnostic({
                code: "incompatible-library",
                format: {
                    name: name,
                    versionMap: incompatibleLibs
                        .map((x) => `  - Version: "${x.manifest.version}" installed at "${x.path}"`)
                        .join("\n"),
                },
                target: NoTarget,
            }));
        }
    }
    async function loadSources(entrypoint) {
        const sourceLoader = await createSourceLoader(host, {
            parseOptions: options.parseOptions,
            tracer,
            getCachedScript: (file) => oldProgram?.sourceFiles.get(file.path) ?? host.parseCache?.get(file),
        });
        // intrinsic.tsp
        await loadIntrinsicTypes(sourceLoader);
        // standard library
        if (!options?.nostdlib) {
            await loadStandardLibrary(sourceLoader);
        }
        // main entrypoint
        await sourceLoader.importFile(entrypoint, NoTarget, { type: "project" }, "entrypoint");
        // additional imports
        for (const additionalImport of options?.additionalImports ?? []) {
            await sourceLoader.importPath(additionalImport, NoTarget, getDirectoryPath(entrypoint), {
                type: "project",
            });
        }
        sourceResolution = sourceLoader.resolution;
        program.sourceFiles = sourceResolution.sourceFiles;
        program.jsSourceFiles = sourceResolution.jsSourceFiles;
        // Bind
        for (const file of sourceResolution.sourceFiles.values()) {
            binder.bindSourceFile(file);
        }
        for (const jsFile of sourceResolution.jsSourceFiles.values()) {
            binder.bindJsSourceFile(jsFile);
        }
        program.reportDiagnostics(sourceResolution.diagnostics);
    }
    async function loadIntrinsicTypes(loader) {
        const locationContext = { type: "compiler" };
        return loader.importFile(resolvePath(host.getExecutionRoot(), "lib/intrinsics.tsp"), NoTarget, locationContext);
    }
    async function loadStandardLibrary(loader) {
        const locationContext = { type: "compiler" };
        for (const dir of host.getLibDirs()) {
            await loader.importFile(resolvePath(dir, "main.tsp"), NoTarget, locationContext);
        }
    }
    async function loadTypeSpecScript(file) {
        // This is not a diagnostic because the compiler should never reuse the same path.
        // It's the caller's responsibility to use unique paths.
        if (program.sourceFiles.has(file.path)) {
            throw new RangeError("Duplicate script path: " + file.path);
        }
        const script = parseOrReuse(file);
        program.reportDiagnostics(script.parseDiagnostics);
        program.sourceFiles.set(file.path, script);
        binder.bindSourceFile(script);
        return script;
    }
    function parseOrReuse(file) {
        const old = oldProgram?.sourceFiles.get(file.path) ?? host?.parseCache?.get(file);
        if (old?.file === file && deepEquals(old.parseOptions, options.parseOptions)) {
            return old;
        }
        const script = parse(file, options.parseOptions);
        host.parseCache?.set(file, script);
        return script;
    }
    function getSourceFileLocationContext(sourcefile) {
        const locationContext = sourceResolution.locationContexts.get(sourcefile);
        compilerAssert(locationContext, "SourceFile should have a declaration locationContext.");
        return locationContext;
    }
    async function loadEmitters(basedir, emitterNameOrPaths, emitterOptions) {
        for (const emitterNameOrPath of emitterNameOrPaths) {
            const emitter = await loadEmitter(basedir, emitterNameOrPath, emitterOptions);
            if (emitter) {
                emitters.push(emitter);
            }
        }
    }
    async function resolveEmitterModuleAndEntrypoint(basedir, specifier) {
        const locationContext = { type: "project" };
        // attempt to resolve a node module with this name
        const [module, diagnostics] = await resolveJSLibrary(specifier, basedir, locationContext);
        if (!module) {
            return [undefined, diagnostics];
        }
        const entrypoint = module.type === "file" ? module.path : module.mainFile;
        const [file, jsDiagnostics] = await loadJsFile(host, entrypoint, NoTarget);
        return [file && { module, entrypoint: file }, jsDiagnostics];
    }
    async function loadLibrary(basedir, libraryNameOrPath) {
        const [resolution, diagnostics] = await resolveEmitterModuleAndEntrypoint(basedir, libraryNameOrPath);
        if (resolution === undefined) {
            program.reportDiagnostics(diagnostics);
            return undefined;
        }
        const { module, entrypoint } = resolution;
        const libDefinition = entrypoint?.esmExports.$lib;
        const metadata = computeLibraryMetadata(module, libDefinition);
        const linterDef = entrypoint?.esmExports.$linter;
        return {
            ...resolution,
            metadata,
            definition: libDefinition,
            linter: linterDef && resolveLinterDefinition(libraryNameOrPath, linterDef),
        };
    }
    async function loadEmitter(basedir, emitterNameOrPath, emittersOptions) {
        const library = await loadLibrary(basedir, emitterNameOrPath);
        if (library === undefined) {
            return undefined;
        }
        const { entrypoint, metadata } = library;
        const emitFunction = entrypoint.esmExports.$onEmit;
        const libDefinition = library.definition;
        let { "emitter-output-dir": emitterOutputDir, ...emitterOptions } = emittersOptions[metadata.name ?? emitterNameOrPath] ?? {};
        if (emitterOutputDir === undefined) {
            emitterOutputDir = [options.outputDir, metadata.name].filter(isDefined).join("/");
        }
        if (libDefinition?.requireImports) {
            for (const lib of libDefinition.requireImports) {
                requireImports.set(lib, libDefinition.name);
            }
        }
        if (emitFunction !== undefined) {
            if (libDefinition?.emitter?.options) {
                const diagnostics = libDefinition?.emitterOptionValidator?.validate(emitterOptions, options.configFile?.file
                    ? {
                        kind: "path-target",
                        path: ["options", emitterNameOrPath],
                        script: options.configFile.file,
                    }
                    : NoTarget);
                if (diagnostics && diagnostics.length > 0) {
                    program.reportDiagnostics(diagnostics);
                    return;
                }
            }
            return {
                main: entrypoint.file.path,
                emitFunction,
                metadata,
                emitterOutputDir,
                options: emitterOptions,
                library,
            };
        }
        else {
            program.trace("emitter.load.invalid-emitter", `Emitter does not have an emit function. Available exported symbols are ${Object.keys(entrypoint.esmExports).join(", ")}`);
            program.reportDiagnostic(createDiagnostic({
                code: "invalid-emitter",
                format: {
                    emitterPackage: emitterNameOrPath,
                },
                target: NoTarget,
            }));
            return undefined;
        }
    }
    function computeLibraryMetadata(module, libDefinition) {
        if (module.type === "file") {
            return {
                type: "file",
                name: libDefinition?.name,
            };
        }
        return computeModuleMetadata(module);
    }
    function computeModuleMetadata(module) {
        const metadata = {
            type: "module",
            name: module.manifest.name,
        };
        if (module.manifest.homepage) {
            metadata.homepage = module.manifest.homepage;
        }
        if (module.manifest.bugs?.url) {
            metadata.bugs = { url: module.manifest.bugs?.url };
        }
        if (module.manifest.version) {
            metadata.version = module.manifest.version;
        }
        return metadata;
    }
    async function runValidators() {
        const start = startTimer();
        runtimeStats.validation = { total: 0, validators: {} };
        runCompilerValidators();
        runtimeStats.validation.validators.compiler = start.end();
        for (const validator of validateCbs) {
            const start = startTimer();
            await runValidator(validator);
            runtimeStats.validation.validators[validator.metadata.name ?? "<unnamed>"] = start.end();
        }
        runtimeStats.validation.total = start.end();
    }
    async function runValidator(validator) {
        try {
            await validator.callback(program);
        }
        catch (error) {
            if (options.designTimeBuild) {
                program.reportDiagnostic(createDiagnostic({
                    code: "on-validate-fail",
                    format: { error: error.stack },
                    target: NoTarget,
                }));
            }
            else {
                throw new ExternalError({ kind: "validator", metadata: validator.metadata, error });
            }
        }
    }
    /** Run the compiler built-in validators */
    function runCompilerValidators() {
        validateEncodedNamesConflicts(program);
        validatePagingOperations(program);
    }
    function validateRequiredImports() {
        for (const [requiredImport, emitterName] of requireImports) {
            if (!sourceResolution.loadedLibraries.has(requiredImport)) {
                program.reportDiagnostic(createDiagnostic({
                    code: "missing-import",
                    format: { requiredImport, emitterName },
                    target: NoTarget,
                }));
            }
        }
    }
    /**
     * resolves a module specifier like "myLib" to an absolute path where we can find the main of
     * that module, e.g. "/typespec/node_modules/myLib/dist/lib.js".
     */
    async function resolveJSLibrary(specifier, baseDir, locationContext) {
        try {
            return [
                await resolveModule(getResolveModuleHost(), specifier, { baseDir, conditions: ["import"] }),
                [],
            ];
        }
        catch (e) {
            if (e instanceof ResolveModuleError) {
                return [undefined, [moduleResolutionErrorToDiagnostic(e, specifier, NoTarget)]];
            }
            else {
                throw e;
            }
        }
    }
    function getResolveModuleHost() {
        return {
            realpath: host.realpath,
            stat: host.stat,
            readFile: async (path) => {
                const file = await host.readFile(path);
                return file.text;
            },
        };
    }
    // It's important that we use the compiler version that resolves locally
    // from the input TypeSpec source location. Otherwise, there will be undefined
    // runtime behavior when decorators and handlers expect a
    // different version of TypeSpec than the current one. Abort the compilation
    // with an error if the TypeSpec entry point resolves to a different local
    // compiler.
    async function checkForCompilerVersionMismatch(baseDir) {
        let actual;
        try {
            const resolved = await resolveModule({
                realpath: host.realpath,
                stat: host.stat,
                readFile: async (path) => {
                    const file = await host.readFile(path);
                    return file.text;
                },
            }, "@typespec/compiler", { baseDir });
            compilerAssert(resolved.type === "module", `Expected to have resolved "@typespec/compiler" to a node module.`);
            actual = resolved;
        }
        catch (err) {
            if (err.code === "MODULE_NOT_FOUND" || err.code === "INVALID_MAIN") {
                return true; // no local typespec, ok to use any compiler
            }
            throw err;
        }
        const expected = host.getExecutionRoot();
        if (actual.path !== expected && MANIFEST.version !== actual.manifest.version) {
            const betterTypeSpecServerPath = actual.path;
            program.reportDiagnostic(createDiagnostic({
                code: "compiler-version-mismatch",
                format: { basedir: baseDir, betterTypeSpecServerPath, actual: actual.path, expected },
                target: NoTarget,
            }));
            return false;
        }
        return true;
    }
    function getOption(key) {
        return (options.miscOptions || {})[key];
    }
    function reportDiagnostic(diagnostic) {
        if (shouldSuppress(diagnostic)) {
            return;
        }
        if (diagnostic.severity === "error") {
            continueToNextStage = false;
        }
        if (diagnostic.severity === "warning" && diagnostic.target !== NoTarget) {
            mutate(diagnostic).codefixes ??= [];
            mutate(diagnostic.codefixes).push(createSuppressCodeFix(diagnostic.target, diagnostic.code));
        }
        if (options.warningAsError && diagnostic.severity === "warning") {
            diagnostic = { ...diagnostic, severity: "error" };
        }
        if (diagnostic.severity === "error") {
            error = true;
        }
        diagnostics.push(diagnostic);
    }
    function reportDiagnostics(newDiagnostics) {
        for (const diagnostic of newDiagnostics) {
            reportDiagnostic(diagnostic);
        }
    }
    function shouldSuppress(diagnostic) {
        const { target } = diagnostic;
        if (diagnostic.code === "error") {
            diagnostics.push(diagnostic);
            return false;
        }
        if (target === NoTarget || target === undefined) {
            return false;
        }
        if ("file" in target) {
            return false; // No global file suppress yet.
        }
        const node = getNode(target);
        if (node === undefined) {
            return false; // Can't find target cannot be suppressed.
        }
        const suppressing = findDirectiveSuppressingOnNode(diagnostic.code, node);
        if (suppressing) {
            if (diagnostic.severity === "error") {
                // Cannot suppress errors.
                diagnostics.push({
                    severity: "error",
                    code: "suppress-error",
                    message: "Errors cannot be suppressed.",
                    target: suppressing.node,
                });
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    }
    function findDirectiveSuppressingOnNode(code, node) {
        let current = node;
        do {
            if (current.directives) {
                const directive = findDirectiveSuppressingCode(code, current.directives);
                if (directive) {
                    return directive;
                }
            }
        } while ((current = current.parent));
        return undefined;
    }
    /**
     * Returns the directive node that is suppressing this code.
     * @param code Code to check for suppression.
     * @param directives List of directives.
     * @returns Directive suppressing this code if found, `undefined` otherwise
     */
    function findDirectiveSuppressingCode(code, directives) {
        for (const directive of directives.map((x) => parseDirective(x))) {
            if (directive.name === "suppress") {
                if (directive.code === code) {
                    return directive;
                }
            }
        }
        return undefined;
    }
    function parseDirective(node) {
        const args = node.arguments.map((x) => {
            return x.kind === SyntaxKind.Identifier ? x.sv : x.value;
        });
        switch (node.target.sv) {
            case "suppress":
                return { name: "suppress", code: args[0], message: args[1], node };
            case "deprecated":
                return { name: "deprecated", message: args[0], node };
            default:
                throw new Error("Unexpected directive name.");
        }
    }
    function getNode(target) {
        if (!("kind" in target) && !("valueKind" in target) && !("entityKind" in target)) {
            // TemplateInstanceTarget
            if (!("declarations" in target)) {
                return target.node;
            }
            // symbol
            if (target.flags & 8192 /* SymbolFlags.Using */) {
                return target.symbolSource.declarations[0];
            }
            return target.declarations[0]; // handle multiple decls
        }
        else if ("kind" in target && typeof target.kind === "number") {
            // node
            return target;
        }
        else {
            // type
            return target.node;
        }
    }
    function reportDuplicateSymbols(symbols) {
        if (!symbols) {
            return;
        }
        for (const set of symbols.duplicates.values()) {
            for (const symbol of set) {
                if (!duplicateSymbols.has(symbol)) {
                    duplicateSymbols.add(symbol);
                    const name = symbol.flags & 8192 /* SymbolFlags.Using */ ? symbol.symbolSource.name : symbol.name;
                    reportDiagnostic(createDiagnostic({
                        code: "duplicate-symbol",
                        format: { name },
                        target: symbol,
                    }));
                }
            }
        }
    }
    function getGlobalNamespaceType() {
        return program.checker.getGlobalNamespaceType();
    }
    function resolveTypeReference(reference) {
        const [node, parseDiagnostics] = parseStandaloneTypeReference(reference);
        if (parseDiagnostics.length > 0) {
            return [undefined, parseDiagnostics];
        }
        const binder = createBinder(program);
        binder.bindNode(node);
        mutate(node).parent = resolver.symbols.global.declarations[0];
        resolver.resolveTypeReference(node);
        return program.checker.resolveTypeReference(node);
    }
    function resolveTypeOrValueReference(reference) {
        const [node, parseDiagnostics] = parseStandaloneTypeReference(reference);
        if (parseDiagnostics.length > 0) {
            return [undefined, parseDiagnostics];
        }
        const binder = createBinder(program);
        binder.bindNode(node);
        mutate(node).parent = resolver.symbols.global.declarations[0];
        resolver.resolveTypeReference(node);
        return program.checker.resolveTypeOrValueReference(node);
    }
}
/**
 * Resolve compiler options from input options.
 */
function resolveOptions(options) {
    return { ...options };
}
async function emit(emitter, program) {
    const emitterName = emitter.metadata.name ?? "";
    const relativePathForEmittedFiles = transformPathForSink(program.host.logSink, emitter.emitterOutputDir) + "/";
    const errorCount = program.diagnostics.filter((x) => x.severity === "error").length;
    const warnCount = program.diagnostics.filter((x) => x.severity === "warning").length;
    const logger = createLogger({ sink: program.host.logSink });
    return await logger.trackAction(`Running ${emitterName}...`, "", async (task) => {
        const start = startTimer();
        await runEmitter(emitter, program);
        const duration = start.end();
        const message = `${emitterName} ${pc.green(`${Math.round(duration)}ms`)} ${pc.dim(relativePathForEmittedFiles)}`;
        const newErrorCount = program.diagnostics.filter((x) => x.severity === "error").length;
        const newWarnCount = program.diagnostics.filter((x) => x.severity === "warning").length;
        if (newErrorCount > errorCount) {
            task.fail(message);
        }
        else if (newWarnCount > warnCount) {
            task.warn(message);
        }
        else {
            task.succeed(message);
        }
        return { duration };
    });
}
/**
 * @param emitter Emitter ref to run
 */
async function runEmitter(emitter, program) {
    const context = {
        program,
        emitterOutputDir: emitter.emitterOutputDir,
        options: emitter.options,
    };
    try {
        await emitter.emitFunction(context);
    }
    catch (error) {
        throw new ExternalError({ kind: "emitter", metadata: emitter.metadata, error });
    }
}
function logEmittedFilesPath(logSink) {
    flushEmittedFilesPaths().forEach((filePath) => {
        // eslint-disable-next-line no-console
        console.log(`    ${pc.dim(transformPathForSink(logSink, filePath))}`);
    });
}
function transformPathForSink(logSink, path) {
    return logSink.getPath ? logSink.getPath(path) : path;
}
//# sourceMappingURL=program.js.map