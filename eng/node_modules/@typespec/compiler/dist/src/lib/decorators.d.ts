import type { DiscriminatedDecorator, DiscriminatorDecorator, DocDecorator, EncodeDecorator, ErrorDecorator, ErrorsDocDecorator, ExampleDecorator, ExampleOptions, FormatDecorator, FriendlyNameDecorator, InspectTypeDecorator, InspectTypeNameDecorator, KeyDecorator, MaxItemsDecorator, MaxLengthDecorator, MaxValueDecorator, MaxValueExclusiveDecorator, MediaTypeHintDecorator, MinItemsDecorator, MinLengthDecorator, MinValueDecorator, MinValueExclusiveDecorator, OpExampleDecorator, OverloadDecorator, PatternDecorator, ReturnsDocDecorator, SecretDecorator, SummaryDecorator, TagDecorator, WithOptionalPropertiesDecorator, WithPickedPropertiesDecorator, WithoutDefaultValuesDecorator, WithoutOmittedPropertiesDecorator } from "../../generated-defs/TypeSpec.js";
import { DocData } from "../core/intrinsic-type-state.js";
import { Program } from "../core/program.js";
import { Enum, Interface, Model, ModelProperty, Namespace, Operation, Scalar, Type, Union, Value } from "../core/types.js";
export { $encodedName, resolveEncodedName } from "./encoded-names.js";
export { serializeValueAsJson } from "./examples.js";
export { getPagingOperation, isList, type PagingOperation, type PagingProperty } from "./paging.js";
export * from "./service.js";
export * from "./visibility.js";
export { ExampleOptions };
export declare const namespace = "TypeSpec";
declare const getSummary: (program: Program, type: Type) => string | undefined;
/**
 * @summary attaches a documentation string. It is typically used to give a short, single-line
 * description, and can be used in combination with or instead of @doc.
 *
 * The first argument to @summary is a string, which may contain template parameters, enclosed in braces,
 * which are replaced with an attribute for the type (commonly "name") passed as the second (optional) argument.
 *
 * @summary can be specified on any language element -- a model, an operation, a namespace, etc.
 */
export declare const $summary: SummaryDecorator;
export { getSummary };
/**
 * `@doc` attaches a documentation string. Works great with multi-line string literals.
 *
 * The first argument to `@doc` is a string, which may contain template parameters, enclosed in braces,
 * which are replaced with an attribute for the type (commonly "name") passed as the second (optional) argument.
 *
 * `@doc` can be specified on any language element -- a model, an operation, a namespace, etc.
 */
export declare const $doc: DocDecorator;
/**
 * Get the documentation string for the given type.
 * @param program Program
 * @param target Type
 * @returns Documentation value
 */
export declare function getDoc(program: Program, target: Type): string | undefined;
export declare const $returnsDoc: ReturnsDocDecorator;
/**
 * Get the documentation information for the return success types of an operation. In most cases you probably just want to use {@link getReturnsDoc}
 * @param program Program
 * @param target Type
 * @returns Doc data with source information.
 */
export declare function getReturnsDocData(program: Program, target: Operation): DocData | undefined;
/**
 * Get the documentation string for the return success types of an operation.
 * @param program Program
 * @param target Type
 * @returns Documentation value
 */
export declare function getReturnsDoc(program: Program, target: Operation): string | undefined;
export declare const $errorsDoc: ErrorsDocDecorator;
/**
 * Get the documentation information for the return errors types of an operation. In most cases you probably just want to use {@link getErrorsDoc}
 * @param program Program
 * @param target Type
 * @returns Doc data with source information.
 */
export declare function getErrorsDocData(program: Program, target: Operation): DocData | undefined;
/**
 * Get the documentation string for the return errors types of an operation.
 * @param program Program
 * @param target Type
 * @returns Documentation value
 */
export declare function getErrorsDoc(program: Program, target: Operation): string | undefined;
export declare const $inspectType: InspectTypeDecorator;
export declare const $inspectTypeName: InspectTypeNameDecorator;
export declare function isStringType(program: Program, target: Type): target is Scalar;
export declare function isNumericType(program: Program, target: Type): target is Scalar;
/**
 * `@error` decorator marks a model as an error type.
 *  Any derived models (using extends) will also be seen as error types.
 */
export declare const $error: ErrorDecorator;
/**
 * Check if the type is an error model or a descendant of an error model.
 */
export declare function isErrorModel(program: Program, target: Type): boolean;
export declare const $mediaTypeHint: MediaTypeHintDecorator;
/**
 * Get the default media type hint for the given target type.
 *
 * This value is a hint _ONLY_. Emitters are not required to use it, but may use it to get the default media type
 * associated with a TypeSpec type.
 *
 * @param program - the Program containing the target
 * @param target - the target to get the MIME type for
 * @returns the default media type hint for the target, if any
 */
export declare function getMediaTypeHint(program: Program, target: Type): string | undefined;
declare const getFormat: (program: Program, type: Type) => string | undefined;
/**
 * `@format` - specify the data format hint for a string type
 *
 * The first argument is a string that identifies the format that the string type expects.  Any string
 * can be entered here, but a TypeSpec emitter must know how to interpret
 *
 * For TypeSpec specs that will be used with an OpenAPI emitter, the OpenAPI specification describes possible
 * valid values for a string type's format:
 *
 * https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#dataTypes
 *
 * `@format` can be specified on a type that extends from `string` or a `string`-typed model property.
 */
export declare const $format: FormatDecorator;
export { getFormat };
declare const getPatternData: (program: Program, type: Type) => PatternData | undefined;
export interface PatternData {
    readonly pattern: string;
    readonly validationMessage?: string;
}
export declare const $pattern: PatternDecorator;
/**
 * Gets the pattern regular expression associated with a given type, if one has been set.
 *
 * @see getPatternData
 *
 * @param program - the Program containing the target Type
 * @param target - the type to get the pattern for
 * @returns the pattern string, if one was set
 */
export declare function getPattern(program: Program, target: Type): string | undefined;
export { 
/**
 * Gets the associated pattern data, including the pattern regular expression and optional validation message, if any
 * has been set.
 *
 * @param program - the Program containing the target Type
 * @param target - the type to get the pattern data for
 * @returns the pattern data, if any was set
 */
getPatternData, };
export declare const $minLength: MinLengthDecorator;
export declare const $maxLength: MaxLengthDecorator;
export declare const $minItems: MinItemsDecorator;
export declare const $maxItems: MaxItemsDecorator;
export declare const $minValue: MinValueDecorator;
export declare const $maxValue: MaxValueDecorator;
export declare const $minValueExclusive: MinValueExclusiveDecorator;
export declare const $maxValueExclusive: MaxValueExclusiveDecorator;
declare const isSecret: (program: Program, type: Type) => boolean;
/**
 * Mark a string as a secret value that should be treated carefully to avoid exposure
 * @param context Decorator context
 * @param target Decorator target, either a string model or a property with type string.
 */
export declare const $secret: SecretDecorator;
export { isSecret };
export type DateTimeKnownEncoding = "rfc3339" | "rfc7231" | "unixTimestamp";
export type DurationKnownEncoding = "ISO8601" | "seconds";
export type BytesKnownEncoding = "base64" | "base64url";
export interface EncodeData {
    /**
     * Known encoding key.
     * Can be undefined when `@encode(string)` is used on a numeric type. In that case it just means using the base10 decimal representation of the number.
     */
    encoding?: DateTimeKnownEncoding | DurationKnownEncoding | BytesKnownEncoding | string;
    type: Scalar;
}
declare const getEncode: (program: Program, type: ModelProperty | Scalar) => EncodeData | undefined;
export declare const $encode: EncodeDecorator;
export { getEncode };
export declare const $withOptionalProperties: WithOptionalPropertiesDecorator;
export declare const $withoutOmittedProperties: WithoutOmittedPropertiesDecorator;
export declare const $withPickedProperties: WithPickedPropertiesDecorator;
export declare const $withoutDefaultValues: WithoutDefaultValuesDecorator;
export declare const $tag: TagDecorator;
export declare function getTags(program: Program, target: Type): string[];
export declare function getAllTags(program: Program, target: Namespace | Interface | Operation): string[] | undefined;
declare const getFriendlyName: (program: Program, type: Type) => string | undefined;
export declare const $friendlyName: FriendlyNameDecorator;
export { getFriendlyName };
/**
 * `@key` - mark a model property as the key to identify instances of that type
 *
 * The optional first argument accepts an alternate key name which may be used by emitters.
 * Otherwise, the name of the target property will be used.
 *
 * `@key` can only be applied to model properties.
 */
export declare const $key: KeyDecorator;
export { getKeyName, isKey } from "./key.js";
/**
 * Return the deprecated message or undefined if not deprecated
 * @param program Program
 * @param type Type
 */
export declare function getDeprecated(program: Program, type: Type): string | undefined;
declare const getOverloads: (program: Program, type: Operation) => Operation[] | undefined;
declare const getOverloadedOperation: (program: Program, type: Operation) => Operation | undefined;
/**
 * `@overload` - Indicate that the target overloads (specializes) the overloads type.
 * @param context DecoratorContext
 * @param target The specializing operation declaration
 * @param overloadBase The operation to be overloaded.
 */
export declare const $overload: OverloadDecorator;
export { 
/**
 * If the given operation overloads another operation, return that operation.
 * @param program Program
 * @param operation The operation to check for an overload target.
 * @returns The operation this operation overloads, if any.
 */
getOverloadedOperation, 
/**
 * Get all operations that are marked as overloads of the given operation
 * @param program Program
 * @param operation Operation
 * @returns An array of operations that overload the given operation.
 */
getOverloads, };
export declare const discriminatedDecorator: DiscriminatedDecorator;
export declare const $discriminator: DiscriminatorDecorator;
export interface Example extends ExampleOptions {
    readonly value: Value;
}
export interface OpExample extends ExampleOptions {
    readonly parameters?: Value;
    readonly returnType?: Value;
}
export declare const $example: ExampleDecorator;
export declare function getExamples(program: Program, target: Model | Scalar | Enum | Union | ModelProperty): readonly Example[];
export declare const $opExample: OpExampleDecorator;
export declare function getOpExamples(program: Program, target: Operation): OpExample[];
//# sourceMappingURL=decorators.d.ts.map