import type { ArrayValue, BooleanValue, Entity, EnumValue, Node, NullValue, NumericValue, ObjectValue, ScalarValue, StringValue, Value } from "../../core/types.js";
import { Diagnosable } from "../create-diagnosable.js";
/**
 * @typekit value
 */
export interface ValueKit {
    /**
     * Create a Value type from a JavaScript value.
     *
     * @param value The JavaScript value to turn into a TypeSpec Value type.
     */
    create(value: string | number | boolean): Value;
    /**
     * Create a string Value type from a JavaScript string value.
     *
     * @param value The string value.
     */
    createString(value: string): StringValue;
    /**
     * Create a numeric Value type from a JavaScript number value.
     *
     * @param value The numeric value.
     */
    createNumeric(value: number): NumericValue;
    /**
     * Create a boolean Value type from a JavaScript boolean value.
     *
     * @param value The boolean value.
     */
    createBoolean(value: boolean): BooleanValue;
    /**
     * Check if `type` is a string Value type.
     *
     * @param type The type to check.
     */
    isString(type: Entity): type is StringValue;
    /**
     * Check if `type` is a numeric Value type.
     *
     * @param type The type to check.
     */
    isNumeric(type: Entity): type is NumericValue;
    /**
     * Check if `type` is a scalar value type
     * @param type The type to check.
     */
    isScalar(type: Entity): type is ScalarValue;
    /**
     * Check if `type` is an object value type
     * @param type The type to check.
     */
    isObject(type: Entity): type is ObjectValue;
    /**
     * Check if `type` is an array value type
     * @param type The type to check.
     */
    isArray(type: Entity): type is ArrayValue;
    /**
     * Check if `type` is an enum value type
     * @param type The type to check.
     */
    isEnum(type: Entity): type is EnumValue;
    /**
     * Check if `type` is a null value Type.
     * @param type The type to check.
     */
    isNull(type: Entity): type is NullValue;
    /**
     * Check if `type` is a boolean Value type.
     *
     * @param type The type to check.
     */
    isBoolean(type: Entity): type is BooleanValue;
    /**
     * Check if `type` is a Value type.
     * @param type The type to check.
     */
    is(type: Entity): type is Value;
    /**
     * Check if the source type can be assigned to the target.
     * @param source Source type
     * @param target Target type
     * @param diagnosticTarget Target for the diagnostic
     */
    isAssignableTo: Diagnosable<(source: Value, target: Entity, diagnosticTarget?: Entity | Node) => boolean>;
    /**
     * Resolve a value reference to a TypeSpec value.
     * By default any diagnostics are ignored.
     *
     * If a `kind` is provided, it will check if the resolved value matches the expected kind
     * and throw an error if it doesn't.
     *
     * Call `value.resolve.withDiagnostics("reference")` to get a tuple containing the resolved value and any diagnostics.
     */
    resolve: Diagnosable<(<K extends Value["valueKind"] | undefined>(reference: string, kind?: K) => K extends Value["valueKind"] ? Extract<Value, {
        valueKind: K;
    }> : undefined)>;
}
interface TypekitExtension {
    value: ValueKit;
}
declare module "../define-kit.js" {
    interface Typekit extends TypekitExtension {
    }
}
export {};
//# sourceMappingURL=value.d.ts.map