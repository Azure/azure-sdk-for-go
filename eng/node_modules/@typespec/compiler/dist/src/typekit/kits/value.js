import { Numeric } from "../../core/numeric.js";
import { isValue } from "../../core/type-utils.js";
import { createDiagnosable } from "../create-diagnosable.js";
import { defineKit } from "../define-kit.js";
defineKit({
    value: {
        is(value) {
            return value.entityKind === "Value";
        },
        create(value) {
            if (typeof value === "string") {
                return this.value.createString(value);
            }
            else if (typeof value === "number") {
                return this.value.createNumeric(value);
            }
            else {
                return this.value.createBoolean(value);
            }
        },
        createString(value) {
            return {
                entityKind: "Value",
                value: value,
                valueKind: "StringValue",
                type: this.literal.createString(value),
                scalar: undefined,
            };
        },
        createNumeric(value) {
            const valueAsString = String(value);
            return {
                entityKind: "Value",
                value: Numeric(valueAsString),
                valueKind: "NumericValue",
                type: this.literal.createNumeric(value),
                scalar: undefined,
            };
        },
        createBoolean(value) {
            return {
                entityKind: "Value",
                value: value,
                valueKind: "BooleanValue",
                type: this.literal.createBoolean(value),
                scalar: undefined,
            };
        },
        isBoolean(type) {
            return this.value.is(type) && type.valueKind === "BooleanValue";
        },
        isString(type) {
            return this.value.is(type) && type.valueKind === "StringValue";
        },
        isNumeric(type) {
            return this.value.is(type) && type.valueKind === "NumericValue";
        },
        isArray(type) {
            return this.value.is(type) && type.valueKind === "ArrayValue";
        },
        isObject(type) {
            return this.value.is(type) && type.valueKind === "ObjectValue";
        },
        isEnum(type) {
            return this.value.is(type) && type.valueKind === "EnumValue";
        },
        isNull(type) {
            return this.value.is(type) && type.valueKind === "NullValue";
        },
        isScalar(type) {
            return this.value.is(type) && type.valueKind === "ScalarValue";
        },
        isAssignableTo: createDiagnosable(function (source, target, diagnosticTarget) {
            return this.program.checker.isTypeAssignableTo(source, target, diagnosticTarget ?? source);
        }),
        resolve: createDiagnosable(function (reference, kind) {
            const [value, diagnostics] = this.program.resolveTypeOrValueReference(reference);
            if (value && !isValue(value)) {
                return [undefined, diagnostics];
            }
            if (value && kind && value.valueKind !== kind) {
                throw new Error(`Value kind mismatch: expected ${kind}, got ${value.valueKind}`);
            }
            return [value, diagnostics];
        }),
    },
});
//# sourceMappingURL=value.js.map