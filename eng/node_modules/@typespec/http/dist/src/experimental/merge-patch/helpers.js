import { isArrayModelType } from "@typespec/compiler";
import { useStateMap } from "@typespec/compiler/utils";
import { HttpStateKeys } from "../../lib.js";
export const [getMergePatchSource, setMergePatchSource] = useStateMap(HttpStateKeys.mergePatchModel);
export const [getMergePatchPropertySource, setMergePatchPropertySource] = useStateMap(HttpStateKeys.mergePatchProperty);
export const [getMergePatchPropertyOverrides, setMergePatchPropertyOverrides] = useStateMap(HttpStateKeys.mergePatchPropertyOptions);
/**
 * Determines if the given model is part of a mergePatch transform
 * @param program The compiled TypeSpec program
 * @param model The model to check
 * @returns true if the model was generated using a mergePatch template, otherwise false
 */
export function isMergePatch(program, model) {
    return getMergePatchSource(program, model) !== undefined;
}
/**
 * Returns the MergePatch characteristics of the property, if the property is used in a MergePatch request
 * @param program The compiled TypeSpec program
 * @param property The model property to check
 * @returns The characteristics of the property in a MergePatch request (or undefined if the property is not part of a mErgePatch request)
 */
export function getMergePatchProperties(program, property) {
    function getUpdateBehavior(type) {
        switch (type.kind) {
            case "Model":
                if (isArrayModelType(program, type))
                    return "merge";
                return "replace";
            default:
                return "replace";
        }
    }
    if (!property.model || !isMergePatch(program, property.model))
        return undefined;
    const sourceProperty = getMergePatchPropertySource(program, property);
    return {
        erasable: sourceProperty.optional || sourceProperty.defaultValue !== undefined,
        updateBehavior: getUpdateBehavior(sourceProperty.type),
        sourceProperty: sourceProperty,
        erasedValue: sourceProperty.defaultValue,
    };
}
//# sourceMappingURL=helpers.js.map