import { createDiagnosable, defineKit, } from "@typespec/compiler/typekit";
import { getHttpOperation } from "../../../operations.js";
defineKit({
    httpOperation: {
        get: createDiagnosable(function (op) {
            return getHttpOperation(this.program, op);
        }),
        getReturnType(httpOperation, options) {
            let responses = this.httpOperation.flattenResponses(httpOperation);
            if (!options?.includeErrors) {
                responses = responses.filter((r) => !this.httpResponse.isErrorResponse(r));
            }
            const voidType = { kind: "Intrinsic", name: "void" };
            let httpReturnType = voidType;
            if (!responses.length) {
                return voidType;
            }
            if (responses.length > 1) {
                const res = [...new Set(responses.map((r) => r.responseContent.body?.type))];
                httpReturnType = this.union.create({
                    variants: res.map((t) => {
                        return this.unionVariant.create({
                            type: getEffectiveType(this, t),
                        });
                    }),
                });
            }
            else {
                httpReturnType = getEffectiveType(this, responses[0].responseContent.body?.type);
            }
            return httpReturnType;
        },
        flattenResponses(httpOperation) {
            const responsesMap = [];
            for (const response of httpOperation.responses) {
                for (const responseContent of response.responses) {
                    const contentTypeProperty = responseContent.properties.find((property) => property.kind === "contentType");
                    let contentType;
                    if (contentTypeProperty) {
                        contentType = contentTypeProperty.property.type.value;
                    }
                    else if (responseContent.body) {
                        contentType = "application/json";
                    }
                    responsesMap.push({
                        statusCode: response.statusCodes,
                        contentType,
                        responseContent,
                        type: response.type,
                    });
                }
            }
            return responsesMap;
        },
    },
});
function getEffectiveType(typekit, type) {
    if (type === undefined) {
        return { kind: "Intrinsic", name: "void" };
    }
    if (typekit.model.is(type)) {
        return typekit.model.getEffectiveModel(type);
    }
    return type;
}
//# sourceMappingURL=http-operation.js.map