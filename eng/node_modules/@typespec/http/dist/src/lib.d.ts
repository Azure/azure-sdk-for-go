export declare const $lib: import("@typespec/compiler").TypeSpecLibrary<{
    "http-verb-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["entityName"]>;
    };
    "missing-uri-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "incompatible-uri-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param", "uriKind", "annotationKind"]>;
    };
    "use-uri-template": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "double-slash": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName"]>;
        readonly optionalUnset: import("@typespec/compiler").CallableMessage<["paramName"]>;
        readonly optionalSet: import("@typespec/compiler").CallableMessage<["paramName"]>;
    };
    "missing-server-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "duplicate-body": {
        readonly default: "Operation has multiple @body parameters declared";
        readonly duplicateUnannotated: "Operation has multiple unannotated parameters. There can only be one representing the body";
        readonly bodyAndUnannotated: "Operation has a @body and an unannotated parameter. There can only be one representing the body";
    };
    "duplicate-route-decorator": {
        readonly namespace: "@route was defined twice on this namespace and has different values.";
    };
    "operation-param-duplicate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "types"]>;
    };
    "duplicate-operation": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName", "verb", "path"]>;
    };
    "multiple-status-codes": {
        readonly default: "Multiple `@statusCode` decorators defined for this operation response.";
    };
    "status-code-invalid": {
        readonly default: "statusCode value must be a numeric or string literal or union of numeric or string literals";
        readonly value: "statusCode value must be a three digit code between 100 and 599";
    };
    "content-type-string": {
        readonly default: "contentType parameter must be a string literal or union of string literals";
    };
    "content-type-ignored": {
        readonly default: "`Content-Type` header ignored because there is no body.";
    };
    "metadata-ignored": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "response-cookie-not-supported": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "no-service-found": {
        readonly default: import("@typespec/compiler").CallableMessage<["namespace"]>;
    };
    "invalid-type-for-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "shared-inconsistency": {
        readonly default: import("@typespec/compiler").CallableMessage<["verb", "path"]>;
    };
    "multipart-invalid-content-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType", "supportedContentTypes"]>;
    };
    "multipart-model": {
        readonly default: "Multipart request body must be a model or a tuple of http parts.";
    };
    "no-implicit-multipart": {
        readonly default: "Using multipart payloads requires the use of @multipartBody and HttpPart<T> models.";
    };
    "multipart-part": {
        readonly default: "Expect item to be an HttpPart model.";
    };
    "multipart-nested": {
        readonly default: "Cannot use @multipartBody inside of an HttpPart";
    };
    "http-file-extra-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "http-file-disallowed-metadata": {
        readonly default: import("@typespec/compiler").CallableMessage<["metadataType", "propName"]>;
    };
    "formdata-no-part-name": {
        readonly default: "Part used in multipart/form-data must have a name.";
    };
    "http-file-structured": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentTypes"]>;
        readonly union: "An HTTP File in a union is serialized as a structured model instead of being treated as the contents of a file. Declare a separate operation using `@sharedRoute` that has only the File model as the body type to treat it as a file, or suppress this warning if you intend to serialize the File as a model.";
    };
    "http-file-content-type-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "http-file-contents-not-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "patch-implicit-optional": {
        readonly default: "Patch operation stopped applying an implicit optional transform to the body in 1.0.0. Use @patch(#{implicitOptionality: true}) to restore the old behavior.";
    };
    "merge-patch-contains-null": {
        readonly default: "Cannot convert model to a merge-patch compatible shape because it contains the 'null' intrinsic type.";
    };
    "merge-patch-content-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType"]>;
    };
    "merge-patch-contains-metadata": {
        readonly default: import("@typespec/compiler").CallableMessage<["metadataType", "propertyName"]>;
    };
}, Record<string, any>, "path" | "authentication" | "header" | "cookie" | "query" | "body" | "bodyRoot" | "bodyIgnore" | "multipartBody" | "statusCode" | "verbs" | "patchOptions" | "servers" | "includeInapplicableMetadataInPayload" | "externalInterfaces" | "routeProducer" | "routes" | "sharedRoutes" | "routeOptions" | "file" | "httpPart" | "mergePatchModel" | "mergePatchProperty" | "mergePatchPropertyOptions">;
export declare const reportDiagnostic: <C extends "http-verb-duplicate" | "missing-uri-param" | "incompatible-uri-param" | "use-uri-template" | "double-slash" | "missing-server-param" | "duplicate-body" | "duplicate-route-decorator" | "operation-param-duplicate-type" | "duplicate-operation" | "multiple-status-codes" | "status-code-invalid" | "content-type-string" | "content-type-ignored" | "metadata-ignored" | "response-cookie-not-supported" | "no-service-found" | "invalid-type-for-auth" | "shared-inconsistency" | "multipart-invalid-content-type" | "multipart-model" | "no-implicit-multipart" | "multipart-part" | "multipart-nested" | "http-file-extra-property" | "http-file-disallowed-metadata" | "formdata-no-part-name" | "http-file-structured" | "http-file-content-type-not-string" | "http-file-contents-not-scalar" | "patch-implicit-optional" | "merge-patch-contains-null" | "merge-patch-content-type" | "merge-patch-contains-metadata", M extends keyof {
    "http-verb-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["entityName"]>;
    };
    "missing-uri-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "incompatible-uri-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param", "uriKind", "annotationKind"]>;
    };
    "use-uri-template": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "double-slash": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName"]>;
        readonly optionalUnset: import("@typespec/compiler").CallableMessage<["paramName"]>;
        readonly optionalSet: import("@typespec/compiler").CallableMessage<["paramName"]>;
    };
    "missing-server-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "duplicate-body": {
        readonly default: "Operation has multiple @body parameters declared";
        readonly duplicateUnannotated: "Operation has multiple unannotated parameters. There can only be one representing the body";
        readonly bodyAndUnannotated: "Operation has a @body and an unannotated parameter. There can only be one representing the body";
    };
    "duplicate-route-decorator": {
        readonly namespace: "@route was defined twice on this namespace and has different values.";
    };
    "operation-param-duplicate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "types"]>;
    };
    "duplicate-operation": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName", "verb", "path"]>;
    };
    "multiple-status-codes": {
        readonly default: "Multiple `@statusCode` decorators defined for this operation response.";
    };
    "status-code-invalid": {
        readonly default: "statusCode value must be a numeric or string literal or union of numeric or string literals";
        readonly value: "statusCode value must be a three digit code between 100 and 599";
    };
    "content-type-string": {
        readonly default: "contentType parameter must be a string literal or union of string literals";
    };
    "content-type-ignored": {
        readonly default: "`Content-Type` header ignored because there is no body.";
    };
    "metadata-ignored": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "response-cookie-not-supported": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "no-service-found": {
        readonly default: import("@typespec/compiler").CallableMessage<["namespace"]>;
    };
    "invalid-type-for-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "shared-inconsistency": {
        readonly default: import("@typespec/compiler").CallableMessage<["verb", "path"]>;
    };
    "multipart-invalid-content-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType", "supportedContentTypes"]>;
    };
    "multipart-model": {
        readonly default: "Multipart request body must be a model or a tuple of http parts.";
    };
    "no-implicit-multipart": {
        readonly default: "Using multipart payloads requires the use of @multipartBody and HttpPart<T> models.";
    };
    "multipart-part": {
        readonly default: "Expect item to be an HttpPart model.";
    };
    "multipart-nested": {
        readonly default: "Cannot use @multipartBody inside of an HttpPart";
    };
    "http-file-extra-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "http-file-disallowed-metadata": {
        readonly default: import("@typespec/compiler").CallableMessage<["metadataType", "propName"]>;
    };
    "formdata-no-part-name": {
        readonly default: "Part used in multipart/form-data must have a name.";
    };
    "http-file-structured": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentTypes"]>;
        readonly union: "An HTTP File in a union is serialized as a structured model instead of being treated as the contents of a file. Declare a separate operation using `@sharedRoute` that has only the File model as the body type to treat it as a file, or suppress this warning if you intend to serialize the File as a model.";
    };
    "http-file-content-type-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "http-file-contents-not-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "patch-implicit-optional": {
        readonly default: "Patch operation stopped applying an implicit optional transform to the body in 1.0.0. Use @patch(#{implicitOptionality: true}) to restore the old behavior.";
    };
    "merge-patch-contains-null": {
        readonly default: "Cannot convert model to a merge-patch compatible shape because it contains the 'null' intrinsic type.";
    };
    "merge-patch-content-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType"]>;
    };
    "merge-patch-contains-metadata": {
        readonly default: import("@typespec/compiler").CallableMessage<["metadataType", "propertyName"]>;
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "http-verb-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["entityName"]>;
    };
    "missing-uri-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "incompatible-uri-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param", "uriKind", "annotationKind"]>;
    };
    "use-uri-template": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "double-slash": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName"]>;
        readonly optionalUnset: import("@typespec/compiler").CallableMessage<["paramName"]>;
        readonly optionalSet: import("@typespec/compiler").CallableMessage<["paramName"]>;
    };
    "missing-server-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "duplicate-body": {
        readonly default: "Operation has multiple @body parameters declared";
        readonly duplicateUnannotated: "Operation has multiple unannotated parameters. There can only be one representing the body";
        readonly bodyAndUnannotated: "Operation has a @body and an unannotated parameter. There can only be one representing the body";
    };
    "duplicate-route-decorator": {
        readonly namespace: "@route was defined twice on this namespace and has different values.";
    };
    "operation-param-duplicate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "types"]>;
    };
    "duplicate-operation": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName", "verb", "path"]>;
    };
    "multiple-status-codes": {
        readonly default: "Multiple `@statusCode` decorators defined for this operation response.";
    };
    "status-code-invalid": {
        readonly default: "statusCode value must be a numeric or string literal or union of numeric or string literals";
        readonly value: "statusCode value must be a three digit code between 100 and 599";
    };
    "content-type-string": {
        readonly default: "contentType parameter must be a string literal or union of string literals";
    };
    "content-type-ignored": {
        readonly default: "`Content-Type` header ignored because there is no body.";
    };
    "metadata-ignored": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "response-cookie-not-supported": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "no-service-found": {
        readonly default: import("@typespec/compiler").CallableMessage<["namespace"]>;
    };
    "invalid-type-for-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "shared-inconsistency": {
        readonly default: import("@typespec/compiler").CallableMessage<["verb", "path"]>;
    };
    "multipart-invalid-content-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType", "supportedContentTypes"]>;
    };
    "multipart-model": {
        readonly default: "Multipart request body must be a model or a tuple of http parts.";
    };
    "no-implicit-multipart": {
        readonly default: "Using multipart payloads requires the use of @multipartBody and HttpPart<T> models.";
    };
    "multipart-part": {
        readonly default: "Expect item to be an HttpPart model.";
    };
    "multipart-nested": {
        readonly default: "Cannot use @multipartBody inside of an HttpPart";
    };
    "http-file-extra-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "http-file-disallowed-metadata": {
        readonly default: import("@typespec/compiler").CallableMessage<["metadataType", "propName"]>;
    };
    "formdata-no-part-name": {
        readonly default: "Part used in multipart/form-data must have a name.";
    };
    "http-file-structured": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentTypes"]>;
        readonly union: "An HTTP File in a union is serialized as a structured model instead of being treated as the contents of a file. Declare a separate operation using `@sharedRoute` that has only the File model as the body type to treat it as a file, or suppress this warning if you intend to serialize the File as a model.";
    };
    "http-file-content-type-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "http-file-contents-not-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "patch-implicit-optional": {
        readonly default: "Patch operation stopped applying an implicit optional transform to the body in 1.0.0. Use @patch(#{implicitOptionality: true}) to restore the old behavior.";
    };
    "merge-patch-contains-null": {
        readonly default: "Cannot convert model to a merge-patch compatible shape because it contains the 'null' intrinsic type.";
    };
    "merge-patch-content-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType"]>;
    };
    "merge-patch-contains-metadata": {
        readonly default: import("@typespec/compiler").CallableMessage<["metadataType", "propertyName"]>;
    };
}, C, M>) => void, createDiagnostic: <C extends "http-verb-duplicate" | "missing-uri-param" | "incompatible-uri-param" | "use-uri-template" | "double-slash" | "missing-server-param" | "duplicate-body" | "duplicate-route-decorator" | "operation-param-duplicate-type" | "duplicate-operation" | "multiple-status-codes" | "status-code-invalid" | "content-type-string" | "content-type-ignored" | "metadata-ignored" | "response-cookie-not-supported" | "no-service-found" | "invalid-type-for-auth" | "shared-inconsistency" | "multipart-invalid-content-type" | "multipart-model" | "no-implicit-multipart" | "multipart-part" | "multipart-nested" | "http-file-extra-property" | "http-file-disallowed-metadata" | "formdata-no-part-name" | "http-file-structured" | "http-file-content-type-not-string" | "http-file-contents-not-scalar" | "patch-implicit-optional" | "merge-patch-contains-null" | "merge-patch-content-type" | "merge-patch-contains-metadata", M extends keyof {
    "http-verb-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["entityName"]>;
    };
    "missing-uri-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "incompatible-uri-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param", "uriKind", "annotationKind"]>;
    };
    "use-uri-template": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "double-slash": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName"]>;
        readonly optionalUnset: import("@typespec/compiler").CallableMessage<["paramName"]>;
        readonly optionalSet: import("@typespec/compiler").CallableMessage<["paramName"]>;
    };
    "missing-server-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "duplicate-body": {
        readonly default: "Operation has multiple @body parameters declared";
        readonly duplicateUnannotated: "Operation has multiple unannotated parameters. There can only be one representing the body";
        readonly bodyAndUnannotated: "Operation has a @body and an unannotated parameter. There can only be one representing the body";
    };
    "duplicate-route-decorator": {
        readonly namespace: "@route was defined twice on this namespace and has different values.";
    };
    "operation-param-duplicate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "types"]>;
    };
    "duplicate-operation": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName", "verb", "path"]>;
    };
    "multiple-status-codes": {
        readonly default: "Multiple `@statusCode` decorators defined for this operation response.";
    };
    "status-code-invalid": {
        readonly default: "statusCode value must be a numeric or string literal or union of numeric or string literals";
        readonly value: "statusCode value must be a three digit code between 100 and 599";
    };
    "content-type-string": {
        readonly default: "contentType parameter must be a string literal or union of string literals";
    };
    "content-type-ignored": {
        readonly default: "`Content-Type` header ignored because there is no body.";
    };
    "metadata-ignored": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "response-cookie-not-supported": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "no-service-found": {
        readonly default: import("@typespec/compiler").CallableMessage<["namespace"]>;
    };
    "invalid-type-for-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "shared-inconsistency": {
        readonly default: import("@typespec/compiler").CallableMessage<["verb", "path"]>;
    };
    "multipart-invalid-content-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType", "supportedContentTypes"]>;
    };
    "multipart-model": {
        readonly default: "Multipart request body must be a model or a tuple of http parts.";
    };
    "no-implicit-multipart": {
        readonly default: "Using multipart payloads requires the use of @multipartBody and HttpPart<T> models.";
    };
    "multipart-part": {
        readonly default: "Expect item to be an HttpPart model.";
    };
    "multipart-nested": {
        readonly default: "Cannot use @multipartBody inside of an HttpPart";
    };
    "http-file-extra-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "http-file-disallowed-metadata": {
        readonly default: import("@typespec/compiler").CallableMessage<["metadataType", "propName"]>;
    };
    "formdata-no-part-name": {
        readonly default: "Part used in multipart/form-data must have a name.";
    };
    "http-file-structured": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentTypes"]>;
        readonly union: "An HTTP File in a union is serialized as a structured model instead of being treated as the contents of a file. Declare a separate operation using `@sharedRoute` that has only the File model as the body type to treat it as a file, or suppress this warning if you intend to serialize the File as a model.";
    };
    "http-file-content-type-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "http-file-contents-not-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "patch-implicit-optional": {
        readonly default: "Patch operation stopped applying an implicit optional transform to the body in 1.0.0. Use @patch(#{implicitOptionality: true}) to restore the old behavior.";
    };
    "merge-patch-contains-null": {
        readonly default: "Cannot convert model to a merge-patch compatible shape because it contains the 'null' intrinsic type.";
    };
    "merge-patch-content-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType"]>;
    };
    "merge-patch-contains-metadata": {
        readonly default: import("@typespec/compiler").CallableMessage<["metadataType", "propertyName"]>;
    };
}[C]>(diag: import("@typespec/compiler").DiagnosticReport<{
    "http-verb-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["entityName"]>;
    };
    "missing-uri-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "incompatible-uri-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param", "uriKind", "annotationKind"]>;
    };
    "use-uri-template": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "double-slash": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName"]>;
        readonly optionalUnset: import("@typespec/compiler").CallableMessage<["paramName"]>;
        readonly optionalSet: import("@typespec/compiler").CallableMessage<["paramName"]>;
    };
    "missing-server-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "duplicate-body": {
        readonly default: "Operation has multiple @body parameters declared";
        readonly duplicateUnannotated: "Operation has multiple unannotated parameters. There can only be one representing the body";
        readonly bodyAndUnannotated: "Operation has a @body and an unannotated parameter. There can only be one representing the body";
    };
    "duplicate-route-decorator": {
        readonly namespace: "@route was defined twice on this namespace and has different values.";
    };
    "operation-param-duplicate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "types"]>;
    };
    "duplicate-operation": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName", "verb", "path"]>;
    };
    "multiple-status-codes": {
        readonly default: "Multiple `@statusCode` decorators defined for this operation response.";
    };
    "status-code-invalid": {
        readonly default: "statusCode value must be a numeric or string literal or union of numeric or string literals";
        readonly value: "statusCode value must be a three digit code between 100 and 599";
    };
    "content-type-string": {
        readonly default: "contentType parameter must be a string literal or union of string literals";
    };
    "content-type-ignored": {
        readonly default: "`Content-Type` header ignored because there is no body.";
    };
    "metadata-ignored": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "response-cookie-not-supported": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "no-service-found": {
        readonly default: import("@typespec/compiler").CallableMessage<["namespace"]>;
    };
    "invalid-type-for-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "shared-inconsistency": {
        readonly default: import("@typespec/compiler").CallableMessage<["verb", "path"]>;
    };
    "multipart-invalid-content-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType", "supportedContentTypes"]>;
    };
    "multipart-model": {
        readonly default: "Multipart request body must be a model or a tuple of http parts.";
    };
    "no-implicit-multipart": {
        readonly default: "Using multipart payloads requires the use of @multipartBody and HttpPart<T> models.";
    };
    "multipart-part": {
        readonly default: "Expect item to be an HttpPart model.";
    };
    "multipart-nested": {
        readonly default: "Cannot use @multipartBody inside of an HttpPart";
    };
    "http-file-extra-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "http-file-disallowed-metadata": {
        readonly default: import("@typespec/compiler").CallableMessage<["metadataType", "propName"]>;
    };
    "formdata-no-part-name": {
        readonly default: "Part used in multipart/form-data must have a name.";
    };
    "http-file-structured": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentTypes"]>;
        readonly union: "An HTTP File in a union is serialized as a structured model instead of being treated as the contents of a file. Declare a separate operation using `@sharedRoute` that has only the File model as the body type to treat it as a file, or suppress this warning if you intend to serialize the File as a model.";
    };
    "http-file-content-type-not-string": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "http-file-contents-not-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "patch-implicit-optional": {
        readonly default: "Patch operation stopped applying an implicit optional transform to the body in 1.0.0. Use @patch(#{implicitOptionality: true}) to restore the old behavior.";
    };
    "merge-patch-contains-null": {
        readonly default: "Cannot convert model to a merge-patch compatible shape because it contains the 'null' intrinsic type.";
    };
    "merge-patch-content-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType"]>;
    };
    "merge-patch-contains-metadata": {
        readonly default: import("@typespec/compiler").CallableMessage<["metadataType", "propertyName"]>;
    };
}, C, M>) => import("@typespec/compiler").Diagnostic, HttpStateKeys: Record<"path" | "authentication" | "header" | "cookie" | "query" | "body" | "bodyRoot" | "bodyIgnore" | "multipartBody" | "statusCode" | "verbs" | "patchOptions" | "servers" | "includeInapplicableMetadataInPayload" | "externalInterfaces" | "routeProducer" | "routes" | "sharedRoutes" | "routeOptions" | "file" | "httpPart" | "mergePatchModel" | "mergePatchProperty" | "mergePatchPropertyOptions", symbol>;
//# sourceMappingURL=lib.d.ts.map