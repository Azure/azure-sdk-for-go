import { ModelProperty, Operation, Program, Type, VisibilityProvider } from "@typespec/compiler";
import { HttpVerb, OperationParameterOptions } from "./types.js";
/**
 * Flags enum representation of well-known visibilities that are used in
 * REST API.
 */
export declare enum Visibility {
    Read = 1,
    Create = 2,
    Update = 4,
    Delete = 8,
    Query = 16,
    None = 0,
    All = 31,
    /**
     * Additional flag to indicate when something is nested in a collection
     * and therefore no metadata is applicable.
     */
    Item = 1048576,
    /**
     * Additional flag to indicate when the verb is PATCH and will have fields made
     * optional if the request visibility includes update.
     *
     * Whether or not this flag is set automatically is determined by the options
     * passed to the `@patch` decorator. By default, it is set in requests for any
     * operation that uses the PATCH verb.
     *
     * @see {@link PatchOptions}
     */
    Patch = 2097152
}
/**
 * Provides a naming suffix to create a unique name for a type with this
 * visibility.
 *
 * The canonical visibility (default Visibility.Read) gets empty suffix,
 * otherwise visibilities are joined in pascal-case with `Or`. And `Item` is
 * if `Visibility.Item` is produced.
 *
 * Examples (with canonicalVisibility = Visibility.Read):
 *  - Visibility.Read => ""
 *  - Visibility.Update => "Update"
 *  - Visibility.Create | Visibility.Update => "CreateOrUpdate"
 *  - Visibility.Create | Visibility.Item => "CreateItem"
 *  - Visibility.Create | Visibility.Update | Visibility.Item => "CreateOrUpdateItem"
 *  */
export declare function getVisibilitySuffix(visibility: Visibility, canonicalVisibility?: Visibility): string;
/**
 * A visibility provider for HTTP operations. Pass this value as a provider to the `getParameterVisibilityFilter` and
 * `getReturnTypeVisibilityFilter` functions in the TypeSpec core to get the applicable parameter and return type
 * visibility filters for an HTTP operation.
 *
 * When created with a verb, this provider will use the default visibility for that verb.
 *
 * @param verb - the HTTP verb for the operation
 *
 * @see {@link VisibilityProvider}
 * @see {@link getParameterVisibilityFilter}
 * @see {@link getReturnTypeVisibilityFilter}
 */
export declare function HttpVisibilityProvider(verb: HttpVerb): VisibilityProvider;
/**
 * A visibility provider for HTTP operations. Pass this value as a provider to the `getParameterVisibilityFilter` and
 * `getReturnTypeVisibilityFilter` functions in the TypeSpec core to get the applicable parameter and return type
 * visibility filters for an HTTP operation.
 *
 * When created with an options object, this provider will use the `verbSelector` function to determine the verb for the
 * operation and use the default visibility for that verb, or the configured HTTP verb for the operation, and finally
 * the GET verb if the verbSelector function is not defined and no HTTP verb is configured.
 *
 * @param options - an options object with a `verbSelector` function that returns the HTTP verb for the operation
 *
 * @see {@link VisibilityProvider}
 * @see {@link getParameterVisibilityFilter}
 * @see {@link getReturnTypeVisibilityFilter}
 */
export declare function HttpVisibilityProvider(options: OperationParameterOptions): VisibilityProvider;
/**
 * A visibility provider for HTTP operations. Pass this value as a provider to the `getParameterVisibilityFilter` and
 * `getReturnTypeVisibilityFilter` functions in the TypeSpec core to get the applicable parameter and return type
 * visibility filters for an HTTP operation.
 *
 * When created without any arguments, this provider will use the configured verb for the operation or the GET verb if
 * no HTTP verb is configured and use the default visibility for that selected verb.
 *
 * @see {@link VisibilityProvider}
 * @see {@link getParameterVisibilityFilter}
 * @see {@link getReturnTypeVisibilityFilter}
 */
export declare function HttpVisibilityProvider(): VisibilityProvider;
/**
 * Returns the applicable parameter visibility or visibilities for the request if `@requestVisibility` was used.
 * Otherwise, returns the default visibility based on the HTTP verb for the operation.
 * @param operation The TypeSpec Operation for the request.
 * @param verb The HTTP verb for the operation.
 * @returns The applicable parameter visibility or visibilities for the request.
 */
export declare function resolveRequestVisibility(program: Program, operation: Operation, verb: HttpVerb): Visibility;
/**
 * Determines if a property is metadata. A property is defined to be
 * metadata if it is marked `@header`, `@cookie`, `@query`, `@path`, or `@statusCode`.
 */
export declare function isMetadata(program: Program, property: ModelProperty): boolean;
/**
 * Determines if the given property is visible with the given visibility.
 */
export declare function isVisible(program: Program, property: ModelProperty, visibility: Visibility): boolean;
/**
 * Determines if the given property is metadata that is applicable with the
 * given visibility.
 *
 * - No metadata is applicable with Visibility.Item present.
 * - If only Visibility.Read is present, then only `@header` and `@status`
 *   properties are applicable.
 * - If Visibility.Read is not present, all metadata properties other than
 *   `@statusCode` are applicable.
 */
export declare function isApplicableMetadata(program: Program, property: ModelProperty, visibility: Visibility, isMetadataCallback?: typeof isMetadata): boolean;
/**
 * Determines if the given property is metadata or marked `@body` and
 * applicable with the given visibility.
 */
export declare function isApplicableMetadataOrBody(program: Program, property: ModelProperty, visibility: Visibility, isMetadataCallback?: typeof isMetadata): boolean;
/**
 * Provides information about changes that happen to a data type's payload
 * when inapplicable metadata is added or invisible properties are removed.
 *
 * Results are computed on demand and expensive computations are memoized.
 */
export interface MetadataInfo {
    /**
     * Determines if the given type is transformed by applying the given
     * visibility and removing invisible properties or adding inapplicable
     * metadata properties.
     */
    isTransformed(type: Type | undefined, visibility: Visibility): boolean;
    /**
     * Determines if the given property is part of the request or response
     * payload and not applicable metadata {@link isApplicableMetadata} or
     * filtered out by the given visibility.
     */
    isPayloadProperty(property: ModelProperty, visibility: Visibility, inExplicitBody?: boolean): boolean;
    /**
     * Determines if the given property is optional in the request or
     * response payload for the given visibility.
     */
    isOptional(property: ModelProperty, visibility: Visibility): boolean;
    /**
     * If type is an anonymous model, tries to find a named model that has the
     * same set of properties when non-payload properties are excluded.
     */
    getEffectivePayloadType(type: Type, visibility: Visibility): Type;
}
export interface MetadataInfoOptions {
    /**
     * The visibility to be used as the baseline against which
     * {@link MetadataInfo.isEmptied} and {@link MetadataInfo.isTransformed}
     * are computed. If not specified, {@link Visibility.All} is used, which
     * will consider that any model that has fields that are only visible to
     * some visibilities as transformed.
     */
    canonicalVisibility?: Visibility;
    /**
     * Optional callback to indicate that a property can be shared with the
     * canonical representation even for visibilities where it is not visible.
     *
     * This is used, for example, in OpenAPI emit where a property can be
     * marked `readOnly: true` to represent @visibility("read") without
     * creating a separate schema schema for {@link Visibility.Read}.
     */
    canShareProperty?(property: ModelProperty): boolean;
}
export declare function createMetadataInfo(program: Program, options?: MetadataInfoOptions): MetadataInfo;
//# sourceMappingURL=metadata.d.ts.map