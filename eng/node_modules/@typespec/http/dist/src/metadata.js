import { compilerAssert, getEffectiveModelType, getLifecycleVisibilityEnum, getParameterVisibilityFilter, isVisible as isVisibleCore, } from "@typespec/compiler";
import { TwoLevelMap } from "@typespec/compiler/utils";
import { getOperationVerb, getPatchOptions, isBody, isBodyIgnore, isBodyRoot, isCookieParam, isHeader, isMultipartBodyProperty, isPathParam, isQueryParam, isStatusCode, } from "./decorators.js";
import { getHttpOperation } from "./operations.js";
import { includeInapplicableMetadataInPayload } from "./private.decorators.js";
/**
 * Flags enum representation of well-known visibilities that are used in
 * REST API.
 */
export var Visibility;
(function (Visibility) {
    Visibility[Visibility["Read"] = 1] = "Read";
    Visibility[Visibility["Create"] = 2] = "Create";
    Visibility[Visibility["Update"] = 4] = "Update";
    Visibility[Visibility["Delete"] = 8] = "Delete";
    Visibility[Visibility["Query"] = 16] = "Query";
    Visibility[Visibility["None"] = 0] = "None";
    Visibility[Visibility["All"] = 31] = "All";
    /**
     * Additional flag to indicate when something is nested in a collection
     * and therefore no metadata is applicable.
     */
    Visibility[Visibility["Item"] = 1048576] = "Item";
    /**
     * Additional flag to indicate when the verb is PATCH and will have fields made
     * optional if the request visibility includes update.
     *
     * Whether or not this flag is set automatically is determined by the options
     * passed to the `@patch` decorator. By default, it is set in requests for any
     * operation that uses the PATCH verb.
     *
     * @see {@link PatchOptions}
     */
    Visibility[Visibility["Patch"] = 2097152] = "Patch";
    /**
     * Additional flags to indicate the treatment of properties in specific contexts.
     *
     * Never use these flags. They are used internally by the HTTP core.
     *
     * @internal
     */
    Visibility[Visibility["Synthetic"] = 3145728] = "Synthetic";
})(Visibility || (Visibility = {}));
const visibilityToArrayMap = new Map();
function visibilityToArray(visibility) {
    // Synthetic flags are not real visibilities.
    visibility &= ~Visibility.Synthetic;
    let result = visibilityToArrayMap.get(visibility);
    if (!result) {
        result = [];
        if (visibility & Visibility.Read) {
            result.push("read");
        }
        if (visibility & Visibility.Create) {
            result.push("create");
        }
        if (visibility & Visibility.Update) {
            result.push("update");
        }
        if (visibility & Visibility.Delete) {
            result.push("delete");
        }
        if (visibility & Visibility.Query) {
            result.push("query");
        }
        compilerAssert(result.length > 0 || visibility === Visibility.None, "invalid visibility");
        visibilityToArrayMap.set(visibility, result);
    }
    return result;
}
function filterToVisibility(program, filter) {
    const Lifecycle = getLifecycleVisibilityEnum(program);
    compilerAssert(!filter.all, "Unexpected: `all` constraint in visibility filter passed to filterToVisibility");
    compilerAssert(!filter.none, "Unexpected: `none` constraint in visibility filter passed to filterToVisibility");
    if (!filter.any) {
        return Visibility.All;
    }
    else {
        let visibility = Visibility.None;
        for (const modifierConstraint of filter.any ?? []) {
            if (modifierConstraint.enum !== Lifecycle)
                continue;
            switch (modifierConstraint.name) {
                case "Read":
                    visibility |= Visibility.Read;
                    break;
                case "Create":
                    visibility |= Visibility.Create;
                    break;
                case "Update":
                    visibility |= Visibility.Update;
                    break;
                case "Delete":
                    visibility |= Visibility.Delete;
                    break;
                case "Query":
                    visibility |= Visibility.Query;
                    break;
                default:
                    compilerAssert(false, `Unreachable: unrecognized Lifecycle visibility member: '${modifierConstraint.name}'`);
            }
        }
        return visibility;
    }
}
const VISIBILITY_FILTER_CACHE_MAP = new WeakMap();
function getVisibilityFilterCache(program) {
    let cache = VISIBILITY_FILTER_CACHE_MAP.get(program);
    if (!cache) {
        cache = new Map();
        VISIBILITY_FILTER_CACHE_MAP.set(program, cache);
    }
    return cache;
}
/**
 * Convert an HTTP visibility to a visibility filter that can be used to test core visibility and applied to a model.
 *
 * The Item and Patch visibility flags are ignored.
 *
 * @param program - the Program we're working in
 * @param visibility - the visibility to convert to a filter
 * @returns a VisibilityFilter object that selects properties having any of the given visibility flags
 */
function visibilityToFilter(program, visibility) {
    // Synthetic flags are not real visibilities.
    visibility &= ~Visibility.Synthetic;
    if (visibility === Visibility.All)
        return {};
    const cache = getVisibilityFilterCache(program);
    let filter = cache.get(visibility);
    if (!filter) {
        const LifecycleEnum = getLifecycleVisibilityEnum(program);
        const Lifecycle = {
            Create: LifecycleEnum.members.get("Create"),
            Read: LifecycleEnum.members.get("Read"),
            Update: LifecycleEnum.members.get("Update"),
            Delete: LifecycleEnum.members.get("Delete"),
            Query: LifecycleEnum.members.get("Query"),
        };
        const any = new Set();
        if (visibility & Visibility.Read) {
            any.add(Lifecycle.Read);
        }
        if (visibility & Visibility.Create) {
            any.add(Lifecycle.Create);
        }
        if (visibility & Visibility.Update) {
            any.add(Lifecycle.Update);
        }
        if (visibility & Visibility.Delete) {
            any.add(Lifecycle.Delete);
        }
        if (visibility & Visibility.Query) {
            any.add(Lifecycle.Query);
        }
        compilerAssert(any.size > 0 || visibility === Visibility.None, "invalid visibility");
        filter = { any };
        cache.set(visibility, filter);
    }
    return filter;
}
/**
 * Provides a naming suffix to create a unique name for a type with this
 * visibility.
 *
 * The canonical visibility (default Visibility.Read) gets empty suffix,
 * otherwise visibilities are joined in pascal-case with `Or`. And `Item` is
 * if `Visibility.Item` is produced.
 *
 * Examples (with canonicalVisibility = Visibility.Read):
 *  - Visibility.Read => ""
 *  - Visibility.Update => "Update"
 *  - Visibility.Create | Visibility.Update => "CreateOrUpdate"
 *  - Visibility.Create | Visibility.Item => "CreateItem"
 *  - Visibility.Create | Visibility.Update | Visibility.Item => "CreateOrUpdateItem"
 *  */
export function getVisibilitySuffix(visibility, canonicalVisibility = Visibility.All) {
    let suffix = "";
    if ((visibility & ~Visibility.Synthetic) !== canonicalVisibility) {
        const visibilities = visibilityToArray(visibility);
        suffix += visibilities.map((v) => v[0].toUpperCase() + v.slice(1)).join("Or");
    }
    if (visibility & Visibility.Item) {
        suffix += "Item";
    }
    return suffix;
}
/**
 * Determines the visibility to use for a request with the given verb.
 *
 * - GET | HEAD => Visibility.Query
 * - POST => Visibility.Update
 * - PUT => Visibility.Create | Update
 * - DELETE => Visibility.Delete
 */
function getDefaultVisibilityForVerb(verb) {
    switch (verb) {
        case "get":
        case "head":
            return Visibility.Query;
        case "post":
            return Visibility.Create;
        case "put":
            return Visibility.Create | Visibility.Update;
        case "patch":
            return Visibility.Update;
        case "delete":
            return Visibility.Delete;
        default:
            compilerAssert(false, `Unreachable: unrecognized HTTP verb: '${verb}'`);
    }
}
export function HttpVisibilityProvider(verbOrParameterOptions) {
    const hasVerb = typeof verbOrParameterOptions === "string";
    return {
        parameters: (program, operation) => {
            let verb = hasVerb
                ? verbOrParameterOptions
                : (verbOrParameterOptions?.verbSelector?.(program, operation) ??
                    getOperationVerb(program, operation));
            if (!verb) {
                const [httpOperation] = getHttpOperation(program, operation);
                verb = httpOperation.verb;
            }
            return visibilityToFilter(program, getDefaultVisibilityForVerb(verb));
        },
        returnType: (program, _) => {
            const Read = getLifecycleVisibilityEnum(program).members.get("Read");
            // For return types, we always use Read visibility in HTTP.
            return { any: new Set([Read]) };
        },
    };
}
/**
 * Returns the applicable parameter visibility or visibilities for the request if `@requestVisibility` was used.
 * Otherwise, returns the default visibility based on the HTTP verb for the operation.
 * @param operation The TypeSpec Operation for the request.
 * @param verb The HTTP verb for the operation.
 * @returns The applicable parameter visibility or visibilities for the request.
 */
export function resolveRequestVisibility(program, operation, verb) {
    // WARNING: This is the only place where we call HttpVisibilityProvider _WITHIN_ the HTTP implementation itself. We
    // _must_ provide the verb directly to the function as the first argument. If the verb is not provided directly, the
    // provider calls getHttpOperation to resolve the verb. Since the current function is called from getHttpOperation, it
    // will cause a stack overflow if the version of HttpVisibilityProvider we use here has to resolve the verb itself.
    const parameterVisibilityFilter = getParameterVisibilityFilter(program, operation, HttpVisibilityProvider(verb));
    let visibility = filterToVisibility(program, parameterVisibilityFilter);
    // If the verb is PATCH, then we need to add the patch flag to the visibility in order for
    // later processes to properly apply it.
    if (verb === "patch") {
        const implicitOptionality = getPatchOptions(program, operation)?.implicitOptionality;
        if (implicitOptionality) {
            visibility |= Visibility.Patch;
        }
    }
    return visibility;
}
/**
 * Determines if a property is metadata. A property is defined to be
 * metadata if it is marked `@header`, `@cookie`, `@query`, `@path`, or `@statusCode`.
 */
export function isMetadata(program, property) {
    return (isHeader(program, property) ||
        isCookieParam(program, property) ||
        isQueryParam(program, property) ||
        isPathParam(program, property) ||
        isStatusCode(program, property));
}
/**
 * Determines if the given property is visible with the given visibility.
 */
export function isVisible(program, property, visibility) {
    return isVisibleCore(program, property, visibilityToFilter(program, visibility));
}
/**
 * Determines if the given property is metadata that is applicable with the
 * given visibility.
 *
 * - No metadata is applicable with Visibility.Item present.
 * - If only Visibility.Read is present, then only `@header` and `@status`
 *   properties are applicable.
 * - If Visibility.Read is not present, all metadata properties other than
 *   `@statusCode` are applicable.
 */
export function isApplicableMetadata(program, property, visibility, isMetadataCallback = isMetadata) {
    return isApplicableMetadataCore(program, property, visibility, false, isMetadataCallback);
}
/**
 * Determines if the given property is metadata or marked `@body` and
 * applicable with the given visibility.
 */
export function isApplicableMetadataOrBody(program, property, visibility, isMetadataCallback = isMetadata) {
    return isApplicableMetadataCore(program, property, visibility, true, isMetadataCallback);
}
function isApplicableMetadataCore(program, property, visibility, treatBodyAsMetadata, isMetadataCallback) {
    if (visibility & Visibility.Item) {
        return false; // no metadata is applicable to collection items
    }
    if (treatBodyAsMetadata &&
        (isBody(program, property) ||
            isBodyRoot(program, property) ||
            isMultipartBodyProperty(program, property))) {
        return true;
    }
    if (!isMetadataCallback(program, property)) {
        return false;
    }
    if (visibility & Visibility.Read) {
        return isHeader(program, property) || isStatusCode(program, property);
    }
    if (!(visibility & Visibility.Read)) {
        return !isStatusCode(program, property);
    }
    return true;
}
export function createMetadataInfo(program, options) {
    const canonicalVisibility = options?.canonicalVisibility ?? Visibility.All;
    const stateMap = new TwoLevelMap();
    return {
        isTransformed,
        isPayloadProperty,
        isOptional,
        getEffectivePayloadType,
    };
    function isEmptied(type, visibility) {
        if (!type) {
            return false;
        }
        const state = getState(type, visibility);
        return state === 2 /* State.Emptied */;
    }
    function isTransformed(type, visibility) {
        if (!type) {
            return false;
        }
        const state = getState(type, visibility);
        switch (state) {
            case 1 /* State.Transformed */:
                return true;
            case 2 /* State.Emptied */:
                return visibility === canonicalVisibility || !isEmptied(type, canonicalVisibility);
            default:
                return false;
        }
    }
    function getState(type, visibility) {
        return stateMap.getOrAdd(type, visibility, () => computeState(type, visibility), 3 /* State.ComputationInProgress */);
    }
    function computeState(type, visibility) {
        switch (type.kind) {
            case "Model":
                return computeStateForModel(type, visibility);
            case "Union":
                return computeStateForUnion(type, visibility);
            default:
                return 0 /* State.NotTransformed */;
        }
    }
    function computeStateForModel(model, visibility) {
        if (computeIsEmptied(model, visibility)) {
            return 2 /* State.Emptied */;
        }
        if (isTransformed(model.indexer?.value, visibility | Visibility.Item) ||
            isTransformed(model.baseModel, visibility)) {
            return 1 /* State.Transformed */;
        }
        for (const property of model.properties.values()) {
            if (isAddedRemovedOrMadeOptional(property, visibility) ||
                isTransformed(property.type, visibility)) {
                return 1 /* State.Transformed */;
            }
        }
        return 0 /* State.NotTransformed */;
    }
    function computeStateForUnion(union, visibility) {
        for (const variant of union.variants.values()) {
            if (isTransformed(variant.type, visibility)) {
                return 1 /* State.Transformed */;
            }
        }
        return 0 /* State.NotTransformed */;
    }
    function isAddedRemovedOrMadeOptional(property, visibility) {
        if (visibility === canonicalVisibility) {
            return false;
        }
        if (isOptional(property, canonicalVisibility) !== isOptional(property, visibility)) {
            return true;
        }
        return (isPayloadProperty(property, visibility, undefined, /* keep shared */ true) !==
            isPayloadProperty(property, canonicalVisibility, undefined, /*keep shared*/ true));
    }
    function computeIsEmptied(model, visibility) {
        if (model.baseModel || model.indexer || model.properties.size === 0) {
            return false;
        }
        for (const property of model.properties.values()) {
            if (isPayloadProperty(property, visibility, undefined, /* keep shared */ true)) {
                return false;
            }
        }
        return true;
    }
    function isOptional(property, visibility) {
        // Properties are made optional for patch requests if the visibility includes
        // update, but not for array elements with the item flag since you must provide
        // all array elements with required properties, even in a patch.
        const hasUpdate = (visibility & Visibility.Update) !== 0;
        const isPatch = (visibility & Visibility.Patch) !== 0;
        const isItem = (visibility & Visibility.Item) !== 0;
        return property.optional || (hasUpdate && isPatch && !isItem);
    }
    function isPayloadProperty(property, visibility, inExplicitBody, keepShareableProperties) {
        if (!inExplicitBody &&
            (isBodyIgnore(program, property) ||
                isApplicableMetadata(program, property, visibility) ||
                (isMetadata(program, property) && !includeInapplicableMetadataInPayload(program, property)))) {
            return false;
        }
        if (!isVisible(program, property, visibility)) {
            // NOTE: When we check if a model is transformed for a given
            // visibility, we retain shared properties. It is not considered
            // transformed if the only removed properties are shareable. However,
            // if we do create a unique schema for a visibility, then we still
            // drop invisible shareable properties from other uses of
            // isPayloadProperty.
            //
            // For OpenAPI emit, for example, this means that we won't put a
            // readOnly: true property into a specialized schema for a non-read
            // visibility.
            keepShareableProperties ??= visibility === canonicalVisibility;
            return !!(keepShareableProperties && options?.canShareProperty?.(property));
        }
        return true;
    }
    /**
     * If the type is an anonymous model, tries to find a named model that has the same
     * set of properties when non-payload properties are excluded.we
     */
    function getEffectivePayloadType(type, visibility) {
        if (type.kind === "Model" && !type.name) {
            const effective = getEffectiveModelType(program, type, (p) => isPayloadProperty(p, visibility, undefined, /* keep shared */ false));
            if (effective.name) {
                return effective;
            }
        }
        return type;
    }
}
//# sourceMappingURL=metadata.js.map