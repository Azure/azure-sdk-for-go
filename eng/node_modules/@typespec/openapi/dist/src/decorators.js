import { compilerAssert, getDoc, getService, getSummary, isType, serializeValueAsJson, } from "@typespec/compiler";
import { useStateMap } from "@typespec/compiler/utils";
import * as http from "@typespec/http";
import { validateAdditionalInfoModel, validateIsUri } from "./helpers.js";
import { createStateSymbol, OpenAPIKeys, reportDiagnostic } from "./lib.js";
const operationIdsKey = createStateSymbol("operationIds");
/**
 * Set a specific operation ID.
 * @param context Decorator Context
 * @param entity Decorator target
 * @param opId Operation ID.
 */
export const $operationId = (context, entity, opId) => {
    context.program.stateMap(operationIdsKey).set(entity, opId);
};
/**
 * Returns operationId set via the `@operationId` decorator or `undefined`
 */
export function getOperationId(program, entity) {
    return program.stateMap(operationIdsKey).get(entity);
}
const openApiExtensionKey = createStateSymbol("openApiExtension");
/** {@inheritdoc ExtensionDecorator} */
export const $extension = (context, entity, extensionName, value) => {
    compilerAssert(!value || !isType(value), "OpenAPI extension value must be a value but was a type", context.getArgumentTarget(1));
    const processed = convertRemainingValuesToExtensions(context.program, value);
    setExtension(context.program, entity, extensionName, processed);
};
// Workaround until we have a way to disable arg marshalling and just call serializeValueAsJson
// https://github.com/microsoft/typespec/issues/3570
function convertRemainingValuesToExtensions(program, value) {
    switch (typeof value) {
        case "string":
        case "number":
        case "boolean":
            return value;
        case "object":
            if (value === null) {
                return null;
            }
            if (Array.isArray(value)) {
                return value.map((x) => convertRemainingValuesToExtensions(program, x));
            }
            if (isTypeSpecValue(value)) {
                return serializeValueAsJson(program, value, value.type);
            }
            else {
                const result = {};
                for (const [key, val] of Object.entries(value)) {
                    if (val === undefined) {
                        continue;
                    }
                    result[key] = convertRemainingValuesToExtensions(program, val);
                }
                return result;
            }
        default:
            return value;
    }
}
function isTypeSpecValue(value) {
    return "entityKind" in value && value.entityKind === "Value";
}
/**
 * Set the OpenAPI info node on for the given service namespace.
 * @param program Program
 * @param entity Service namespace
 * @param data OpenAPI Info object
 */
export function setInfo(program, entity, data) {
    program.stateMap(infoKey).set(entity, data);
}
/**
 *  Set OpenAPI extension on the given type. Equivalent of using `@extension` decorator
 * @param program Program
 * @param entity Type to annotate
 * @param extensionName Extension key
 * @param data Extension value
 */
export function setExtension(program, entity, extensionName, data) {
    const openApiExtensions = program.stateMap(openApiExtensionKey);
    const typeExtensions = openApiExtensions.get(entity) ?? new Map();
    typeExtensions.set(extensionName, data);
    openApiExtensions.set(entity, typeExtensions);
}
/**
 * Get extensions set for the given type.
 * @param program Program
 * @param entity Type
 */
export function getExtensions(program, entity) {
    return program.stateMap(openApiExtensionKey).get(entity) ?? new Map();
}
/**
 * The @defaultResponse decorator can be applied to a model. When that model is used
 * as the return type of an operation, this return type will be the default response.
 *
 */
const defaultResponseKey = createStateSymbol("defaultResponse");
/** {@inheritdoc DefaultResponseDecorator} */
export const $defaultResponse = (context, entity) => {
    http.setStatusCode(context.program, entity, ["*"]);
    context.program.stateSet(defaultResponseKey).add(entity);
};
/**
 * Check if the given model has been mark as a default response.
 * @param program TypeSpec Program
 * @param entity Model to check.
 * @returns boolean.
 */
export function isDefaultResponse(program, entity) {
    return program.stateSet(defaultResponseKey).has(entity);
}
const externalDocsKey = createStateSymbol("externalDocs");
/**
 * Allows referencing an external resource for extended documentation.
 * @param url The URL for the target documentation. Value MUST be in the format of a URL.
 * @param description A short description of the target documentation.
 */
export const $externalDocs = (context, target, url, description) => {
    const doc = { url };
    if (description) {
        doc.description = description;
    }
    context.program.stateMap(externalDocsKey).set(target, doc);
};
/**
 * Return external doc info set via the `@externalDocs` decorator.
 * @param program Program
 * @param entity Type
 */
export function getExternalDocs(program, entity) {
    return program.stateMap(externalDocsKey).get(entity);
}
const infoKey = createStateSymbol("info");
/** {@inheritdoc InfoDecorator} */
export const $info = (context, entity, data) => {
    if (data === undefined) {
        return;
    }
    // Validate the AdditionalInfo model
    if (!validateAdditionalInfoModel(context.program, context.getArgumentTarget(0), data, "TypeSpec.OpenAPI.AdditionalInfo")) {
        return;
    }
    // Validate termsOfService
    if (data.termsOfService) {
        if (!validateIsUri(context.program, context.getArgumentTarget(0), data.termsOfService, "TermsOfService")) {
            return;
        }
    }
    setInfo(context.program, entity, data);
};
/**
 * Get the info entry for the given service namespace.
 * @param program Program
 * @param entity Service namespace
 */
export function getInfo(program, entity) {
    return program.stateMap(infoKey).get(entity);
}
/** Resolve the info entry by merging data specified with `@service`, `@summary` and `@info`. */
export function resolveInfo(program, entity) {
    const info = getInfo(program, entity);
    const service = getService(program, entity);
    return omitUndefined({
        ...info,
        title: info?.title ?? service?.title,
        version: info?.version,
        summary: info?.summary ?? getSummary(program, entity),
        description: info?.description ?? getDoc(program, entity),
    });
}
function omitUndefined(data) {
    return Object.fromEntries(Object.entries(data).filter(([k, v]) => v !== undefined));
}
/** Get TagsMetadata set with `@tagMetadata` decorator */
const [getTagsMetadata, setTagsMetadata] = useStateMap(OpenAPIKeys.tagsMetadata);
/**
 * Decorator to add metadata to a tag associated with a namespace.
 * @param context - The decorator context.
 * @param entity - The namespace entity to associate the tag with.
 * @param name - The name of the tag.
 * @param tagMetadata - Optional metadata for the tag.
 */
export const tagMetadataDecorator = (context, entity, name, tagMetadata) => {
    // Check if the namespace is a service namespace
    if (!entity.decorators.some((decorator) => decorator.definition?.name === "@service" &&
        decorator.definition?.namespace.name === "TypeSpec")) {
        reportDiagnostic(context.program, {
            code: "tag-metadata-target-service",
            format: {
                namespace: entity.name,
            },
            target: context.getArgumentTarget(0),
        });
        return;
    }
    // Retrieve existing tags metadata or initialize an empty object
    const tags = getTagsMetadata(context.program, entity) ?? {};
    // Check for duplicate tag names
    if (tags[name]) {
        reportDiagnostic(context.program, {
            code: "duplicate-tag",
            format: { tagName: name },
            target: context.getArgumentTarget(0),
        });
        return;
    }
    // Validate the additionalInfo model
    if (!validateAdditionalInfoModel(context.program, context.getArgumentTarget(0), tagMetadata, "TypeSpec.OpenAPI.TagMetadata")) {
        return;
    }
    // Validate the externalDocs.url property
    if (tagMetadata.externalDocs?.url) {
        if (!validateIsUri(context.program, context.getArgumentTarget(0), tagMetadata.externalDocs.url, "externalDocs.url")) {
            return;
        }
    }
    // Update the tags metadata with the new tag
    tags[name] = tagMetadata;
    setTagsMetadata(context.program, entity, tags);
};
export { getTagsMetadata };
//# sourceMappingURL=decorators.js.map