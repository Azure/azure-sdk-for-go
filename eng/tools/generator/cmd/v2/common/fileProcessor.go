// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

package common

import (
	"fmt"
	"io"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/eng/tools/generator/changelog"
	"github.com/Azure/azure-sdk-for-go/eng/tools/generator/utils"
	"github.com/Azure/azure-sdk-for-go/eng/tools/internal/exports"
)

const (
	generated_file_scan_string        = "Code generated by Microsoft"
	autorest_md_file_suffix           = "readme.md"
	autorest_md_module_version_prefix = "module-version: "
	swagger_md_module_name_prefix     = "module-name: "
)

var (
	v2BeginRegex                    = regexp.MustCompile("^```\\s*yaml\\s*\\$\\(go\\)\\s*&&\\s*\\$\\((track2|v2)\\)")
	v2EndRegex                      = regexp.MustCompile("^\\s*```\\s*$")
	newClientMethodNameRegex        = regexp.MustCompile("^New.*Client$")
	versionLineRegex                = regexp.MustCompile(`moduleVersion\s*=\s*\".*v.+"`)
	changelogPosWithPreviewRegex    = regexp.MustCompile(`##\s*(?P<version>.+)\s*\((\d{4}-\d{2}-\d{2}|Unreleased)\)`)
	changelogPosWithoutPreviewRegex = regexp.MustCompile(`##\s*(?P<version>\d+\.\d+\.\d+)\s*\((\d{4}-\d{2}-\d{2}|Unreleased)\)`)
	packageConfigRegex              = regexp.MustCompile(`\$\((package-.+)\)`)
)

// paramsToString converts a parameter list to a comma-delimited string with names and types
func paramsToString(params []exports.Param) string {
	if len(params) == 0 {
		return ""
	}

	var parts []string
	for _, p := range params {
		if p.Name != "" {
			parts = append(parts, p.Name+" "+p.Type)
		} else {
			parts = append(parts, p.Type)
		}
	}
	return strings.Join(parts, ", ")
}

// hasExpectedClientParams checks if params match the expected ARM client constructor signature
func hasExpectedClientParams(params []exports.Param) bool {
	expectedTypes := []string{"string", "azcore.TokenCredential", "*arm.ClientOptions"}
	if len(params) != len(expectedTypes) {
		return false
	}
	for i, p := range params {
		if p.Type != expectedTypes[i] {
			return false
		}
	}
	return true
}

type PackageInfo struct {
	Name        string
	Config      string
	SpecName    string
	RequestLink string
	Tag         string
	ReleaseDate *time.Time
}

// ReadV2ModuleNameToGetNamespace reads from readme.go.md, parses the `track2` section to get module and package name
func ReadV2ModuleNameToGetNamespace(path string) (map[string][]PackageInfo, error) {
	result := make(map[string][]PackageInfo)
	log.Printf("Reading from readme.go.md '%s'...", path)
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}

	log.Printf("Parsing module and package name from readme.go.md ...")
	b, err := io.ReadAll(file)
	if err != nil {
		return nil, err
	}

	lines := strings.Split(string(b), "\n")

	var start []int
	var end []int
	for i, line := range lines {
		if v2BeginRegex.MatchString(line) {
			start = append(start, i)
		}
		if len(start) != len(end) && v2EndRegex.MatchString(line) {
			end = append(end, i)
		}
	}

	if len(start) == 0 {
		return nil, fmt.Errorf("cannot find any `track2` section")
	}
	if len(start) != len(end) {
		return nil, fmt.Errorf("last `track2` section does not properly end")
	}

	_, after, _ := strings.Cut(strings.ReplaceAll(path, "\\", "/"), "specification")
	before, _, _ := strings.Cut(after, "resource-manager")
	specName := strings.Trim(before, "/")

	for i := range start {
		hasModuleName := false
		// get the content of the `track2` section
		section := lines[start[i]+1 : end[i]]
		// iterate over the rest lines, get module name
		for _, line := range section {
			if strings.HasPrefix(line, swagger_md_module_name_prefix) {
				modules := strings.Split(strings.TrimSpace(line[len(swagger_md_module_name_prefix):]), "/")
				if len(modules) != 4 && len(modules) != 5 {
					return nil, fmt.Errorf("cannot parse module name from `track2` section")
				}
				namespaceName := strings.TrimSuffix(strings.TrimSuffix(modules[3], "\n"), "\r")
				log.Printf("RP: %s Package: %s", modules[2], namespaceName)
				packageConfig := ""
				matchResults := packageConfigRegex.FindAllStringSubmatch(lines[start[i]], -1)
				for _, matchResult := range matchResults {
					packageConfig = matchResult[1] + ": true"
				}
				result[modules[2]] = append(result[modules[2]], PackageInfo{Name: namespaceName, Config: packageConfig, SpecName: specName})
				hasModuleName = true
			}
		}

		if !hasModuleName {
			return nil, fmt.Errorf("%s line:%d-%d is not configured correctly, please refer to sample: `https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/samplefiles/readme.go.md`", path, start[i]+2, end[i])
		}
	}

	return result, nil
}

// CleanSDKGeneratedFiles removes all sdk generated files in given path
func CleanSDKGeneratedFiles(path string) error {
	if _, err := os.Stat(path); os.IsNotExist(err) {
		return nil
	}
	log.Printf("Removing all sdk generated files in '%s'...", path)
	return filepath.WalkDir(path, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			return nil
		}

		if filepath.Ext(d.Name()) == ".go" {
			b, err := os.ReadFile(path)
			if err != nil {
				return err
			}

			if strings.Contains(string(b), generated_file_scan_string) {
				if err = os.Remove(path); err != nil {
					return err
				}
			}
		}

		return nil
	})
}

// ChangeConfigWithLocalPath replaces repo commit with local path in autorest.md file
func ChangeConfigWithLocalPath(path, readmeFile, readmeGoFile string) error {
	log.Printf("Replacing repo commit with local path in autorest.md ...")
	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	lines := strings.Split(string(b), "\n")
	for i, line := range lines {
		if strings.Contains(line, autorest_md_file_suffix) {
			lines[i] = fmt.Sprintf("- %s", readmeFile)
			lines[i+1] = fmt.Sprintf("- %s", readmeGoFile)
			break
		}
	}

	return os.WriteFile(path, []byte(strings.Join(lines, "\n")), 0644)
}

// ChangeConfigWithCommitID replaces repo URL and commit id in autorest.md file
func ChangeConfigWithCommitID(path, repoURL, commitID, specRPName string) error {
	log.Printf("Replacing repo URL and commit id in autorest.md ...")
	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	lines := strings.Split(string(b), "\n")
	for i, line := range lines {
		if strings.Contains(line, autorest_md_file_suffix) {
			indexResourceManager := strings.Index(line, "resource-manager")
			indexReadme := strings.Index(line, autorest_md_file_suffix)
			resourceManagerPath := []byte(line)
			resourceManagerPath = resourceManagerPath[indexResourceManager : indexReadme-1]

			lines[i] = fmt.Sprintf("- %s/blob/%s/specification/%s/%s/readme.md", repoURL, commitID, specRPName, resourceManagerPath)
			lines[i+1] = fmt.Sprintf("- %s/blob/%s/specification/%s/%s/readme.go.md", repoURL, commitID, specRPName, resourceManagerPath)
			break
		}
	}

	return os.WriteFile(path, []byte(strings.Join(lines, "\n")), 0644)
}

// RemoveTagSet deletes tag set in config file
func RemoveTagSet(path string) error {
	log.Printf("Removing tag set in autorest.md ...")
	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	lines := strings.Split(string(b), "\n")
	for i, line := range lines {
		if strings.Contains(line, "tag:") {
			lines = append(lines[:i], lines[i+1:]...)
			break
		}
	}

	return os.WriteFile(path, []byte(strings.Join(lines, "\n")), 0644)
}

// GetSpecRpName gets swagger rp folder name from autorest.md file
func GetSpecRpName(packageRootPath string) (string, error) {
	b, err := os.ReadFile(filepath.Join(packageRootPath, "autorest.md"))
	if err != nil {
		return "", err
	}

	lines := strings.Split(string(b), "\n")
	for _, line := range lines {
		if strings.Contains(line, autorest_md_file_suffix) {
			allParts := strings.Split(line, "/")
			for i, part := range allParts {
				if part == "specification" {
					return allParts[i+1], nil
				}
			}
		}
	}
	return "", fmt.Errorf("cannot get sepc rp name from config")
}

// ReplaceNewClientNamePlaceholder replaces `{{NewClientName}}` placeholder in README.md by first func name according to `^New.+Method$` pattern
func ReplaceNewClientNamePlaceholder(packageRootPath string, exports exports.Content) error {
	var clientName string
	for _, k := range changelog.SortFuncItem(exports.Funcs) {
		v := exports.Funcs[k]
		if newClientMethodNameRegex.MatchString(k) && hasExpectedClientParams(v.Params) {
			clientName = k
			break
		}
	}

	path := filepath.Join(packageRootPath, "README.md")

	if _, err := os.Stat(path); os.IsNotExist(err) {
		return nil
	}

	b, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("cannot read from file '%s': %+v", path, err)
	}

	var content = strings.ReplaceAll(string(b), "{{NewClientName}}", clientName)
	return os.WriteFile(path, []byte(content), 0644)
}

// GetAlwaysSetBodyParamRequiredFlag gets the flag for always setting body param required
func GetAlwaysSetBodyParamRequiredFlag(path string) (string, error) {
	buildGo, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	if strings.Contains(string(buildGo), "-alwaysSetBodyParamRequired") {
		return "-alwaysSetBodyParamRequired", nil
	}
	return "", nil
}

// GetFactoryGatherAllParamsFlag gets the flag for factory gather all params
func GetFactoryGatherAllParamsFlag(path string) (string, error) {
	buildGo, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	if strings.Contains(string(buildGo), "-factoryGatherCommonParams") {
		return "-factoryGatherCommonParams", nil
	}
	return "", nil
}

// AddTagSet adds tag in file
func AddTagSet(path, tag string) error {
	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	lines := strings.Split(string(b), "\n")
	for i, line := range lines {
		if strings.Contains(line, "tag:") {
			lines[i] = tag
			break
		}

		// end index
		if i == len(lines)-1 {
			for j := len(lines) - 1; j > 0; j-- {
				if strings.Contains(lines[j], "```") {
					if lines[j-1] == "" {
						lines[j-1] = tag
						break
					} else {
						newLines := make([]string, len(lines))
						copy(newLines, lines)

						newLines = append(newLines[:j], tag)
						tailLines := lines[j:]
						lines = append(newLines, tailLines...)
						break
					}
				}
			}
		}
	}

	return os.WriteFile(path, []byte(strings.Join(lines, "\n")), 0644)
}

// GetTag gets tag from file
func GetTag(path string) (string, error) {
	b, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}

	lines := strings.Split(string(b), "\n")
	for _, line := range lines {
		if strings.Contains(line, "tag:") {
			return strings.TrimSpace(string([]byte(line)[len("tag:"):])), nil
		}
	}

	return "", nil
}

// ReplaceReadmeNewClientName replaces old client name in README.md by first func name according to `^New.+Method$` pattern
func ReplaceReadmeNewClientName(packageRootPath string, exports exports.Content) error {
	path := filepath.Join(packageRootPath, "README.md")
	var clientName string
	for _, k := range changelog.SortFuncItem(exports.Funcs) {
		v := exports.Funcs[k]
		if newClientMethodNameRegex.MatchString(k) && hasExpectedClientParams(v.Params) {
			clientName = k
			break
		}
	}

	b, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("cannot read from file '%s': %+v", path, err)
	}

	oldClientName := ""
	for _, v := range strings.Split(string(b), "\n") {
		oldClientName = regexp.MustCompile(`New.*Client\(\)`).FindString(v)
		if oldClientName != "" {
			break
		}
	}

	if clientName == "" || oldClientName == "" || oldClientName == fmt.Sprintf("%s()", clientName) {
		return nil
	}

	var content = strings.ReplaceAll(string(b), oldClientName, fmt.Sprintf("%s()", clientName))
	return os.WriteFile(path, []byte(content), 0644)
}

// FindModuleDirByGoMod finds the sdk directory to find module based on a go.mod file
func FindModuleDirByGoMod(root string) (string, error) {
	path := root
	curLevel := 0
	maxLevel := 5
	for !strings.HasSuffix(path, utils.SdkRootPath) && curLevel < maxLevel {
		if _, err := os.Stat(path); os.IsNotExist(err) {
			path = filepath.Dir(path)
			curLevel++
			continue
		}
		goModFilePath := filepath.Join(path, utils.GoModFileName)
		if _, err := os.Stat(goModFilePath); err == nil {
			return path, nil
		}
		path = filepath.Dir(path)
		curLevel++
	}
	return "", fmt.Errorf("module not found, package path:%s", root)
}

// UpdateReadmeClientFactory updates the NewClientFactory calls in README.md according to client_factory.go
func UpdateReadmeClientFactory(path string) error {
	readmePath := filepath.Join(path, utils.ReadmeFileName)
	readmeFile, err := os.ReadFile(readmePath)
	if err != nil {
		return err
	}
	noOptionalFactoryReg := regexp.MustCompile(`NewClientFactory\((.*?)(?:,\s*)?cred,\s*nil\)`)
	withOptionalFactoryReg := regexp.MustCompile(`NewClientFactory\((.*?)(?:,\s*)?cred,\s*&options\)`)
	oldnoOptionalFactory := noOptionalFactoryReg.FindString(string(readmeFile))
	oldwithOptionalFactory := withOptionalFactoryReg.FindString(string(readmeFile))
	if oldnoOptionalFactory == "" && oldwithOptionalFactory == "" {
		return nil
	}
	clientFactoryFile, err := os.ReadFile(filepath.Join(path, utils.ClientFactoryFileName))
	if err != nil {
		return err
	}
	re := regexp.MustCompile(`func\s+NewClientFactory\(([^)]+)\)`)
	matches := re.FindStringSubmatch(string(clientFactoryFile))
	if len(matches) <= 1 {
		return nil
	}
	var factoryParams []string
	params := strings.Split(matches[1], ",")
	for param := range params {
		params[param] = strings.TrimSpace(params[param])
		paramDefinition := strings.Split(params[param], " ")
		if len(paramDefinition) != 2 {
			continue
		}
		paramName := paramDefinition[0]
		if paramName == "credential" || paramName == "options" {
			// fixed params, no need to process
			continue
		}
		if paramName == "subscriptionID" {
			// compatible with old version
			factoryParams = append(factoryParams, "<subscription ID>")
			continue
		}
		factoryParams = append(factoryParams, fmt.Sprintf("<%s>", paramName))
	}
	noOptionsParams := append(factoryParams, []string{"cred", "nil"}...)
	withOptionsParams := append(factoryParams, []string{"cred", "&options"}...)
	newNoOptionalFactory := fmt.Sprintf("NewClientFactory(%s)", strings.Join(noOptionsParams, ", "))
	newWithOptionalFactory := fmt.Sprintf("NewClientFactory(%s)", strings.Join(withOptionsParams, ", "))
	if oldnoOptionalFactory == newNoOptionalFactory && oldwithOptionalFactory == newWithOptionalFactory {
		return nil
	}
	content := strings.ReplaceAll(string(readmeFile), oldnoOptionalFactory, newNoOptionalFactory)
	content = strings.ReplaceAll(content, oldwithOptionalFactory, newWithOptionalFactory)
	return os.WriteFile(readmePath, []byte(content), 0644)
}
