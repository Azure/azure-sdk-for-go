// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

package common

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/Azure/azure-sdk-for-go/eng/tools/generator/changelog"
	"github.com/Azure/azure-sdk-for-go/eng/tools/generator/cmd/template"
	"github.com/Azure/azure-sdk-for-go/eng/tools/generator/repo"
	"github.com/Azure/azure-sdk-for-go/eng/tools/generator/typespec"
	"github.com/Azure/azure-sdk-for-go/eng/tools/internal/exports"
	"github.com/Masterminds/semver"
)

type GenerateContext struct {
	SDKPath           string
	SDKRepo           *repo.SDKRepository
	SpecPath          string
	SpecCommitHash    string
	SpecReadmeFile    string
	SpecReadmeGoFile  string
	SpecRepoURL       string
	UpdateSpecVersion bool

	// typespec
	TypeSpecConfig *typespec.TypeSpecConfig
}

type GenerateResult struct {
	Version             string
	RPName              string
	PackageName         string
	PackageAbsPath      string
	Changelog           changelog.Changelog
	ChangelogMD         string
	PullRequestLabels   string
	PackageRelativePath string
	ModuleRelativePath  string
	GenerationType      string
}

type GenerateParam struct {
	RPName               string
	NamespaceName        string
	NamespaceConfig      string
	SpecificPackageTitle string
	SpecRPName           string
	ReleaseDate          string
	SkipGenerateExample  bool
	RemoveTagSet         bool
	ForceStableVersion   bool
	TypeSpecEmitOption   string
	TspClientOptions     []string
	ReleasedTags         []string
	ApiVersion           string
	SdkReleaseType       string
	SkipUpdateDep        bool
}

type Generator interface {
	PreGenerate(generateParam *GenerateParam) error
	Generate(generateParam *GenerateParam) error
	PreChangeLog(generateParam *GenerateParam) (*exports.Content, error)
	GenChangeLog(oriExports *exports.Content, newExports *exports.Content) (*changelog.Changelog, error)
	AfterGenerate(generateParam *GenerateParam, changelog *changelog.Changelog, newExports exports.Content) (*GenerateResult, error)
}

// Common steps for onboard and normal service
type SwaggerCommonGenerator struct {
	Version     *semver.Version
	PackagePath string
	*GenerateContext
}

type SwaggerOnBoardGenerator struct {
	*SwaggerCommonGenerator
}

type SwaggerUpdateGenerator struct {
	*SwaggerCommonGenerator
	PreviousVersion  string
	IsCurrentPreview bool
}

type TypeSpecCommonGenerator struct {
	PackageRelativePath string
	ModuleRelativePath  string
	PackagePath         string
	ModulePath          string
	Version             *semver.Version
	IsSubPackage        bool
	*GenerateContext
}

type TypeSpecOnBoardGenerator struct {
	*TypeSpecCommonGenerator
}

type TypeSpecUpdateGenerator struct {
	*TypeSpecCommonGenerator
	PreviousVersion  string
	IsCurrentPreview bool
}

func (ctx *GenerateContext) GenerateFromTypeSpec(tspconfigPath string, commonGenerateParam *GenerateParam) (*GenerateResult, error) {
	// typespec
	// Generated by tsp only when tspconfig.yaml exists and has typespec-go option
	tsc, err := typespec.ParseTypeSpecConfig(tspconfigPath)
	if err != nil {
		return nil, fmt.Errorf("failed to parse %s: %+v\nInvalid tspconfig.yaml provided and refer to the sample file to fix the content. management-plane: https://aka.ms/azsdk/tspconfig-sample-mpg, data-plane: https://aka.ms/azsdk/tspconfig-sample-dpg", tspconfigPath, err)
	}

	if ok, _ := tsc.ExistEmitOption(); !ok {
		log.Printf("`@azure-tools/typespec-go` option not found in %s, it is required, please refer to the sample file to configure it. management-plane: https://aka.ms/azsdk/tspconfig-sample-mpg, data-plane: https://aka.ms/azsdk/tspconfig-sample-dpg", tspconfigPath)
		return nil, nil
	}
	ctx.TypeSpecConfig = tsc
	// reuse the same param for all typespec projects
	generateParam := commonGenerateParam
	namespaceResult, err := ctx.GenerateForSingleTypeSpec(generateParam)
	if err != nil {
		return nil, err
	}
	return namespaceResult, nil
}

func (ctx *GenerateContext) GenerateFromSwagger(rpMap map[string][]PackageInfo, commonGenerateParam *GenerateParam) ([]*GenerateResult, []error) {
	// autorest
	errors := make([]error, 0)
	results := make([]*GenerateResult, 0)
	for rpName, packageInfos := range rpMap {
		for _, packageInfo := range packageInfos {
			log.Printf("Start to process rp: %s, namespace: %s", rpName, packageInfo.Name)
			singleResult, err := ctx.GenerateForSingleRPNamespace(&GenerateParam{
				RPName:               rpName,
				NamespaceName:        packageInfo.Name,
				SpecRPName:           packageInfo.SpecName,
				NamespaceConfig:      packageInfo.Config,
				ReleaseDate:          commonGenerateParam.ReleaseDate,
				RemoveTagSet:         commonGenerateParam.RemoveTagSet,
				SkipGenerateExample:  commonGenerateParam.SkipGenerateExample,
				SpecificPackageTitle: commonGenerateParam.SpecificPackageTitle,
			})
			if err != nil {
				errors = append(errors, fmt.Errorf("failed to generate for rp: %s, namespace: %s: %+v", rpName, packageInfo.Name, err))
				continue
			}
			results = append(results, singleResult)
			log.Printf("Finish processing rp: %s, namespace: %s", rpName, packageInfo.Name)
		}
	}
	return results, errors
}

func (ctx *GenerateContext) GenerateForSingleRPNamespace(generateParam *GenerateParam) (*GenerateResult, error) {
	packagePath := filepath.Join(ctx.SDKPath, "sdk", "resourcemanager", generateParam.RPName, generateParam.NamespaceName)
	changelogPath := filepath.Join(packagePath, ChangelogFileName)

	version, err := semver.NewVersion("0.1.0")
	if err != nil {
		return nil, err
	}

	// check if the package is onboard or update, to init different generator
	var generator Generator
	commonGenerator := &SwaggerCommonGenerator{GenerateContext: ctx, PackagePath: packagePath, Version: version}
	if _, err := os.Stat(changelogPath); os.IsNotExist(err) {
		generator = &SwaggerOnBoardGenerator{SwaggerCommonGenerator: commonGenerator}
	} else {
		tags, err := changelog.GetAllVersionTags(fmt.Sprintf("sdk/resourcemanager/%s/%s", generateParam.RPName, generateParam.NamespaceName), *ctx.SDKRepo)
		if err != nil {
			return nil, err
		}
		if len(tags) == 0 {
			generator = &SwaggerOnBoardGenerator{SwaggerCommonGenerator: commonGenerator}
		} else {
			generateParam.ReleasedTags = tags
			generator = &SwaggerUpdateGenerator{SwaggerCommonGenerator: commonGenerator}
		}
	}

	err = generator.PreGenerate(generateParam)
	if err != nil {
		return nil, err
	}

	err = generator.Generate(generateParam)
	if err != nil {
		return nil, err
	}

	oriExports, err := generator.PreChangeLog(generateParam)
	if err != nil {
		return nil, err
	}

	log.Printf("Start to generate changelog for package...")
	newExports, err := exports.Get(packagePath)
	if err != nil {
		return nil, err
	}

	changelog, err := generator.GenChangeLog(oriExports, &newExports)
	if err != nil {
		return nil, err
	}

	return generator.AfterGenerate(generateParam, changelog, newExports)
}

func (t *SwaggerCommonGenerator) PreGenerate(generateParam *GenerateParam) error {
	packagePath := t.PackagePath
	// same step for onboard and update
	if t.SpecCommitHash == "" {
		log.Printf("Change swagger config in `autorest.md` according to local path...")
		autorestMdPath := filepath.Join(packagePath, "autorest.md")
		if err := ChangeConfigWithLocalPath(autorestMdPath, t.SpecReadmeFile, t.SpecReadmeGoFile); err != nil {
			return err
		}
	} else {
		log.Printf("Change swagger config in `autorest.md` according to repo URL and commit ID...")
		autorestMdPath := filepath.Join(packagePath, "autorest.md")
		if err := ChangeConfigWithCommitID(autorestMdPath, t.SpecRepoURL, t.SpecCommitHash, generateParam.SpecRPName); err != nil {
			return err
		}
	}

	// add tag set
	if !generateParam.RemoveTagSet && generateParam.NamespaceConfig != "" {
		log.Printf("Add tag in `autorest.md`...")
		autorestMdPath := filepath.Join(packagePath, "autorest.md")
		if err := AddTagSet(autorestMdPath, generateParam.NamespaceConfig); err != nil {
			return err
		}
	}

	// remove tag set
	if generateParam.RemoveTagSet {
		log.Printf("Remove tag set for swagger config in `autorest.md`...")
		autorestMdPath := filepath.Join(packagePath, "autorest.md")
		if err := RemoveTagSet(autorestMdPath); err != nil {
			return err
		}
	}

	return nil
}

func (t *SwaggerCommonGenerator) Generate(generateParam *GenerateParam) error {
	packagePath := t.PackagePath
	log.Printf("Start to run `go generate` to regenerate the code...")
	if err := ExecuteGoGenerate(packagePath); err != nil {
		return err
	}
	return nil
}

func (t *SwaggerCommonGenerator) PreChangeLog(generateParam *GenerateParam) (*exports.Content, error) {
	return nil, nil
}

func (t *SwaggerCommonGenerator) GenChangeLog(oriExports *exports.Content, newExports *exports.Content) (*changelog.Changelog, error) {
	changelogs, err := changelog.GetChangelogForPackage(oriExports, newExports)
	if err != nil {
		return nil, err
	}

	log.Printf("filter changelog...")
	changelog.FilterChangelog(changelogs, changelog.NonExportedFilter, changelog.MarshalUnmarshalFilter, changelog.EnumFilter, changelog.FuncFilter, changelog.LROFilter, changelog.PageableFilter, changelog.InterfaceToAnyFilter, changelog.TypeToAnyFilter)
	return changelogs, nil
}

func (t *SwaggerCommonGenerator) AfterGenerate(generateParam *GenerateParam, changelog *changelog.Changelog, newExports exports.Content) (*GenerateResult, error) {
	packagePath := t.PackagePath

	// Example generation should be the last step because the package import relay on the new calculated version
	if !generateParam.SkipGenerateExample {
		log.Printf("Start to generate examples...")
		var flags []string
		alwaysSetBodyParamRequiredFlag, err := GetAlwaysSetBodyParamRequiredFlag(filepath.Join(packagePath, "build.go"))
		if err != nil {
			return nil, err
		}
		if len(alwaysSetBodyParamRequiredFlag) > 0 {
			flags = append(flags, alwaysSetBodyParamRequiredFlag)
		}
		clientFactoryParamsFlag, err := GetFactoryGatherAllParamsFlag(filepath.Join(packagePath, "build.go"))
		if err != nil {
			return nil, err
		}
		if len(clientFactoryParamsFlag) > 0 {
			flags = append(flags, clientFactoryParamsFlag)
		}
		log.Println(flags)
		if err := ExecuteExampleGenerate(packagePath, filepath.Join("resourcemanager", generateParam.RPName, generateParam.NamespaceName), flags); err != nil {
			return nil, err
		}
	}
	log.Printf("Update README.md ClientFactory...")
	err := UpdateReadmeClientFactory(t.PackagePath)
	if err != nil {
		// only log error, avoid breaking the process
		log.Printf("Update README.md ClientFactory failed! err: %v", err)
	}
	return nil, nil
}

func (t *SwaggerOnBoardGenerator) PreGenerate(generateParam *GenerateParam) error {
	var err error
	version := t.Version
	packagePath := t.PackagePath
	log.Printf("Package '%s' changelog not exist, do onboard process", packagePath)

	if generateParam.SpecificPackageTitle == "" {
		generateParam.SpecificPackageTitle = strings.Title(generateParam.RPName)
	}

	log.Printf("Start to use template to generate new rp folder and basic package files...")
	if err = template.GeneratePackageByTemplate(generateParam.RPName, generateParam.NamespaceName, template.Flags{
		SDKRoot:        t.SDKPath,
		TemplatePath:   "eng/tools/generator/template/rpName/packageName",
		PackageTitle:   generateParam.SpecificPackageTitle,
		Commit:         t.SpecCommitHash,
		PackageConfig:  generateParam.NamespaceConfig,
		PackageVersion: version.String(),
		ReleaseDate:    generateParam.ReleaseDate,
	}); err != nil {
		return err
	}
	if err = t.SwaggerCommonGenerator.PreGenerate(generateParam); err != nil {
		return err
	}
	return nil
}

func (t *SwaggerOnBoardGenerator) AfterGenerate(generateParam *GenerateParam, changelog *changelog.Changelog, newExports exports.Content) (*GenerateResult, error) {
	var err error
	var prl PullRequestLabel
	version := t.Version
	packagePath := t.PackagePath
	log.Printf("Replace {{NewClientName}} placeholder in the README.md ")
	if err = ReplaceNewClientNamePlaceholder(packagePath, newExports); err != nil {
		return nil, err
	}

	if _, err := t.SwaggerCommonGenerator.AfterGenerate(generateParam, changelog, newExports); err != nil {
		return nil, err
	}

	// issue: https://github.com/Azure/azure-sdk-for-go/issues/23877
	prl = FirstBetaLabel
	packageRelativePath := fmt.Sprintf("sdk/resourcemanager/%s/%s", generateParam.RPName, generateParam.NamespaceName)
	return &GenerateResult{
		Version:             version.String(),
		RPName:              generateParam.RPName,
		PackageName:         generateParam.NamespaceName,
		PackageAbsPath:      packagePath,
		Changelog:           *changelog,
		ChangelogMD:         changelog.ToCompactMarkdown() + "\n" + changelog.GetChangeSummary(),
		PullRequestLabels:   string(prl),
		PackageRelativePath: packageRelativePath,
		GenerationType:      "SwaggerOnBoard",
	}, nil
}

func (t *SwaggerUpdateGenerator) PreGenerate(generateParam *GenerateParam) error {
	packagePath := t.PackagePath
	var err error
	log.Printf("Package '%s' existed, do update process", packagePath)

	log.Printf("Remove all the generated files ...")
	if err = CleanSDKGeneratedFiles(packagePath); err != nil {
		return err
	}

	if err = t.SwaggerCommonGenerator.PreGenerate(generateParam); err != nil {
		return err
	}
	return nil
}

func (t *SwaggerUpdateGenerator) PreChangeLog(generateParam *GenerateParam) (*exports.Content, error) {
	var err error
	previousVersion := ""
	isCurrentPreview := false
	var oriExports *exports.Content
	isCurrentPreview, err = changelog.ContainsPreviewAPIVersion(t.PackagePath)
	if err != nil {
		return nil, err
	}

	if generateParam.ForceStableVersion {
		isCurrentPreview = false
	}

	log.Printf("Get ori exports for changelog generation...")

	tags := generateParam.ReleasedTags

	previousVersionTag := changelog.GetPreviousVersionTag(isCurrentPreview, tags)

	relativePackagePath, err := filepath.Rel(t.SDKPath, t.PackagePath)
	if err != nil {
		return nil, err
	}
	oriExports, err = changelog.GetExportsFromTag(relativePackagePath, previousVersionTag)
	if err != nil && !strings.Contains(err.Error(), "doesn't contain any exports") {
		return nil, err
	}

	tagSplit := strings.Split(previousVersionTag, "/")
	previousVersion = strings.TrimLeft(tagSplit[len(tagSplit)-1], "v")
	t.PreviousVersion = previousVersion
	t.IsCurrentPreview = isCurrentPreview
	return oriExports, nil
}

func (t *SwaggerUpdateGenerator) AfterGenerate(generateParam *GenerateParam, changelog *changelog.Changelog, newExports exports.Content) (*GenerateResult, error) {
	var prl PullRequestLabel
	var err error
	version := t.Version
	isCurrentPreview := t.IsCurrentPreview
	previousVersion := t.PreviousVersion
	packagePath := t.PackagePath

	log.Printf("Calculate new version...")
	version, prl, err = CalculateNewVersion(changelog, previousVersion, isCurrentPreview)
	if err != nil {
		return nil, err
	}

	log.Printf("Add changelog to file...")
	changelogMd, err := AddChangelogToFile(changelog, version, packagePath, generateParam.ReleaseDate)
	if err != nil {
		return nil, err
	}

	log.Printf("Update module definition if v2+...")
	err = UpdateModuleDefinition(packagePath, fmt.Sprintf("sdk/resourcemanager/%s/%s", generateParam.RPName, generateParam.NamespaceName), version)
	if err != nil {
		return nil, err
	}

	log.Printf("Replace version in autorest.md and version.go...")
	if err = ReplaceVersion(packagePath, version.String()); err != nil {
		return nil, err
	}

	// Replace import for module v2+
	baseModule := fmt.Sprintf("github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/%s/%s", generateParam.RPName, generateParam.NamespaceName)
	if version.Major() > 1 {
		log.Printf("Replace import for module v2+...")
		if err = ReplaceModule(version, packagePath, baseModule, ".go"); err != nil {
			return nil, err
		}
	}

	log.Printf("Replace README.md module...")
	if err = replaceReadmeModule(packagePath, fmt.Sprintf("sdk/resourcemanager/%s/%s", generateParam.RPName, generateParam.NamespaceName), version.String()); err != nil {
		return nil, err
	}

	log.Printf("Replace README.md NewClient name...")
	if err = ReplaceReadmeNewClientName(packagePath, newExports); err != nil {
		return nil, err
	}

	if _, err := t.SwaggerCommonGenerator.AfterGenerate(generateParam, changelog, newExports); err != nil {
		return nil, err
	}

	packageRelativePath := fmt.Sprintf("sdk/resourcemanager/%s/%s", generateParam.RPName, generateParam.NamespaceName)
	return &GenerateResult{
		Version:             version.String(),
		RPName:              generateParam.RPName,
		PackageName:         generateParam.NamespaceName,
		PackageAbsPath:      packagePath,
		Changelog:           *changelog,
		ChangelogMD:         changelogMd + "\n" + changelog.GetChangeSummary(),
		PullRequestLabels:   string(prl),
		PackageRelativePath: packageRelativePath,
		GenerationType:      "SwaggerUpdate",
	}, nil
}

func (ctx *GenerateContext) GenerateForSingleTypeSpec(generateParam *GenerateParam) (*GenerateResult, error) {
	isSubPackage := false

	packageRelativePath := ctx.TypeSpecConfig.GetPackageRelativePath()
	if packageRelativePath == "" {
		return nil, fmt.Errorf("package module relative path not found in %s", ctx.TypeSpecConfig.Path)
	}

	moduleRelativePath := ctx.TypeSpecConfig.GetModuleRelativePath()
	// if module relative path is not provided, find it from the sdk path by go.mod
	if moduleRelativePath == "" {
		isSubPackage = true
		val, err := FindModuleDirByGoMod(filepath.Join(ctx.SDKPath, packageRelativePath))
		if err != nil {
			return nil, err
		}
		moduleRelativePath, err = filepath.Rel(ctx.SDKPath, val)
		if err != nil {
			return nil, err
		}
		moduleRelativePath = filepath.ToSlash(moduleRelativePath)
	}

	if !strings.HasPrefix(packageRelativePath, moduleRelativePath) {
		return nil, fmt.Errorf("module relative path '%s' is not a prefix of package relative path '%s', please check your tspconfig.yaml file", moduleRelativePath, packageRelativePath)
	}

	if packageRelativePath != moduleRelativePath {
		isSubPackage = true
	}

	// if rp name and namespace name are not provided, extract them from the module path
	if len(generateParam.RPName) == 0 && len(generateParam.NamespaceName) == 0 {
		rpAndNamespaceName, err := ctx.TypeSpecConfig.GetRpAndPackageNameByModule(moduleRelativePath)
		if err != nil {
			return nil, err
		}
		generateParam.RPName = rpAndNamespaceName[0]
		generateParam.NamespaceName = rpAndNamespaceName[1]
	}

	packagePath := filepath.Join(ctx.SDKPath, packageRelativePath)
	modulePath := filepath.Join(ctx.SDKPath, moduleRelativePath)
	changelogPath := filepath.Join(modulePath, ChangelogFileName)

	version, err := semver.NewVersion("0.1.0")
	if err != nil {
		return nil, err
	}

	// check if the package is onboard or update, to init different generator
	var generator Generator
	commonGenerator := &TypeSpecCommonGenerator{
		GenerateContext:     ctx,
		PackagePath:         packagePath,
		ModulePath:          modulePath,
		PackageRelativePath: packageRelativePath,
		ModuleRelativePath:  moduleRelativePath,
		Version:             version,
		IsSubPackage:        isSubPackage,
	}
	if _, err := os.Stat(changelogPath); os.IsNotExist(err) {
		generator = &TypeSpecOnBoardGenerator{TypeSpecCommonGenerator: commonGenerator}
	} else {
		tags, err := changelog.GetAllVersionTags(moduleRelativePath, *ctx.SDKRepo)
		if err != nil {
			return nil, err
		}
		if len(tags) == 0 {
			generator = &TypeSpecOnBoardGenerator{TypeSpecCommonGenerator: commonGenerator}
		} else {
			generateParam.ReleasedTags = tags
			generator = &TypeSpecUpdateGenerator{TypeSpecCommonGenerator: commonGenerator}
		}
	}

	err = generator.PreGenerate(generateParam)
	if err != nil {
		return nil, err
	}

	err = generator.Generate(generateParam)
	if err != nil {
		return nil, err
	}

	oriExports, err := generator.PreChangeLog(generateParam)
	if err != nil {
		return nil, err
	}

	log.Printf("Start to generate changelog for package...")
	newExports, err := exports.Get(packagePath)
	if err != nil {
		return nil, err
	}
	changelog, err := generator.GenChangeLog(oriExports, &newExports)
	if err != nil {
		return nil, err
	}

	return generator.AfterGenerate(generateParam, changelog, newExports)
}

func (t *TypeSpecCommonGenerator) PreGenerate(generateParam *GenerateParam) error {
	return nil
}

func (t *TypeSpecCommonGenerator) Generate(generateParam *GenerateParam) error {
	version := t.Version
	ctx := t.GenerateContext
	log.Printf("Start to run `tsp-client init` to generate the code...")
	defaultModuleVersion := version.String()
	emitOption := ""
	if !t.IsSubPackage {
		emitOption = fmt.Sprintf("module-version=%s", defaultModuleVersion)
	}
	if generateParam.TypeSpecEmitOption != "" {
		emitOption = fmt.Sprintf("%s;%s", emitOption, generateParam.TypeSpecEmitOption)
	}
	if generateParam.ApiVersion != "" {
		emitOption = fmt.Sprintf("%s;api-version=%s", emitOption, generateParam.ApiVersion)
	}
	err := ExecuteTypeSpecGenerate(ctx, emitOption, generateParam.TspClientOptions)
	if err != nil {
		return err
	}
	return nil
}

func (t *TypeSpecCommonGenerator) PreChangeLog(generateParam *GenerateParam) (*exports.Content, error) {
	return nil, nil
}

func (t *TypeSpecCommonGenerator) GenChangeLog(oriExports *exports.Content, newExports *exports.Content) (*changelog.Changelog, error) {
	changelogs, err := changelog.GetChangelogForPackage(oriExports, newExports)
	if err != nil && !strings.Contains(err.Error(), "doesn't contain any exports") {
		return nil, err
	}

	log.Printf("filter changelog...")
	changelog.FilterChangelog(changelogs, changelog.NonExportedFilter, changelog.MarshalUnmarshalFilter, changelog.EnumFilter, changelog.FuncFilter, changelog.LROFilter, changelog.PageableFilter, changelog.InterfaceToAnyFilter, changelog.TypeToAnyFilter)
	return changelogs, nil
}

func (t *TypeSpecCommonGenerator) AfterGenerate(generateParam *GenerateParam, changelog *changelog.Changelog, newExports exports.Content) (*GenerateResult, error) {
	packagePath := t.PackagePath
	modulePath := t.ModulePath
	if t.IsSubPackage {
		// remove go.mod for sub package
		goModPath := filepath.Join(packagePath, GoModFileName)
		if _, err := os.Stat(goModPath); !os.IsNotExist(err) {
			if err = os.Remove(goModPath); err != nil {
				return nil, err
			}
		}
	}

	log.Printf("##[command]Executing gofmt -s -w . in %s\n", modulePath)
	if err := ExecuteGoFmt(modulePath, "-s", "-w", "."); err != nil {
		return nil, err
	}

	if !generateParam.SkipUpdateDep {
		log.Printf("##[command]Executing go get -u github.com/Azure/azure-sdk-for-go/sdk/azcore toolchain@none go@1.23.0 in %s\n", modulePath)
		if err := ExecuteGo(modulePath, "get", "-u", "github.com/Azure/azure-sdk-for-go/sdk/azcore", "toolchain@none", "go@1.23.0"); err != nil {
			return nil, err
		}
		log.Printf("##[command]Executing go get -u github.com/Azure/azure-sdk-for-go/sdk/azidentity toolchain@none go@1.23.0 in %s\n", modulePath)
		if err := ExecuteGo(modulePath, "get", "-u", "github.com/Azure/azure-sdk-for-go/sdk/azidentity", "toolchain@none", "go@1.23.0"); err != nil {
			return nil, err
		}
	}

	log.Printf("##[command]Executing go mod tidy in %s\n", modulePath)
	if err := ExecuteGo(modulePath, "mod", "tidy"); err != nil {
		return nil, err
	}

	log.Printf("Update README.md ClientFactory...")
	err := UpdateReadmeClientFactory(t.PackagePath)
	if err != nil {
		// only log error, avoid breaking the process
		log.Printf("Update README.md ClientFactory failed! err: %v", err)
	}
	return nil, nil
}

func (t *TypeSpecOnBoardGenerator) PreGenerate(generateParam *GenerateParam) error {
	version := t.Version
	modulePath := t.ModulePath
	moduleRelativePath := t.ModuleRelativePath
	log.Printf("Module '%s' changelog not exist, do onboard process", modulePath)
	if generateParam.SpecificPackageTitle == "" {
		generateParam.SpecificPackageTitle = strings.Title(generateParam.RPName)
	}
	log.Printf("Start to use template to generate new rp folder and basic package files...")
	sdkBasicInfo := map[string]any{
		"rpName":             generateParam.RPName,
		"packageName":        generateParam.NamespaceName,
		"moduleRelativePath": moduleRelativePath,
		"serviceDir":         strings.Replace(moduleRelativePath, "sdk/", "", 1),
		"packageTitle":       generateParam.SpecificPackageTitle,
		"packageVersion":     version.String(),
		"releaseDate":        generateParam.ReleaseDate,
	}
	return typespec.ParseTypeSpecTemplates(filepath.Join(t.SDKPath, "eng/tools/generator/template/typespec"), modulePath, sdkBasicInfo, nil)
}

func (t *TypeSpecOnBoardGenerator) PreChangeLog(generateParam *GenerateParam) (*exports.Content, error) {
	return nil, nil
}

func (t *TypeSpecOnBoardGenerator) AfterGenerate(generateParam *GenerateParam, changelog *changelog.Changelog, newExports exports.Content) (*GenerateResult, error) {
	var err error
	version := t.Version
	modulePath := t.ModulePath
	packagePath := t.PackagePath
	packageRelativePath := t.PackageRelativePath

	var prl PullRequestLabel
	log.Printf("Replace {{NewClientName}} placeholder in the README.md ")
	if err = ReplaceNewClientNamePlaceholder(modulePath, newExports); err != nil {
		return nil, err
	}

	if !generateParam.SkipGenerateExample {
		log.Printf("Generate examples...")
	}

	// issue: https://github.com/Azure/azure-sdk-for-go/issues/23877
	prl = FirstBetaLabel

	if _, err := t.TypeSpecCommonGenerator.AfterGenerate(generateParam, changelog, newExports); err != nil {
		return nil, err
	}

	return &GenerateResult{
		Version:             version.String(),
		RPName:              generateParam.RPName,
		PackageName:         generateParam.NamespaceName,
		PackageAbsPath:      packagePath,
		Changelog:           *changelog,
		ChangelogMD:         changelog.ToCompactMarkdown() + "\n" + changelog.GetChangeSummary(),
		PullRequestLabels:   string(prl),
		PackageRelativePath: packageRelativePath,
		ModuleRelativePath:  t.ModuleRelativePath,
		GenerationType:      "TypeSpecOnBoard",
	}, nil
}

func (t *TypeSpecUpdateGenerator) PreGenerate(generateParam *GenerateParam) error {
	log.Printf("Package '%s' existed, do update process", t.PackagePath)
	log.Printf("Remove all the generated files ...")
	if err := CleanSDKGeneratedFiles(t.PackagePath); err != nil {
		return err
	}
	return nil
}

func (t *TypeSpecUpdateGenerator) PreChangeLog(generateParam *GenerateParam) (*exports.Content, error) {
	var err error
	packagePath := t.PackagePath

	previousVersion := ""
	isCurrentPreview := false
	var oriExports *exports.Content
	if generateParam.SdkReleaseType == SDKReleaseTypePreview {
		isCurrentPreview = true
	} else if generateParam.SdkReleaseType == SDKReleaseTypeStable {
		isCurrentPreview = false
	} else {
		isCurrentPreview, err = changelog.ContainsPreviewAPIVersion(packagePath)
		if err != nil {
			return nil, err
		}
	}

	log.Printf("Get ori exports for changelog generation...")

	tags := generateParam.ReleasedTags

	previousVersionTag := changelog.GetPreviousVersionTag(isCurrentPreview, tags)

	relativePackagePath, err := filepath.Rel(t.SDKPath, t.PackagePath)
	if err != nil {
		return nil, err
	}
	oriExports, err = changelog.GetExportsFromTag(relativePackagePath, previousVersionTag)
	if err != nil && !strings.Contains(err.Error(), "doesn't contain any exports") {
		return nil, err
	}

	tagSplit := strings.Split(previousVersionTag, "/")
	previousVersion = strings.TrimLeft(tagSplit[len(tagSplit)-1], "v")

	t.PreviousVersion = previousVersion
	t.IsCurrentPreview = isCurrentPreview
	return oriExports, nil
}

func (t *TypeSpecUpdateGenerator) AfterGenerate(generateParam *GenerateParam, changelog *changelog.Changelog, newExports exports.Content) (*GenerateResult, error) {
	var prl PullRequestLabel
	var err error
	var version *semver.Version
	packagePath := t.PackagePath
	modulePath := t.ModulePath
	packageRelativePath := t.PackageRelativePath
	moduleRelativePath := t.ModuleRelativePath
	previousVersion := t.PreviousVersion
	isCurrentPreview := t.IsCurrentPreview

	log.Printf("Calculate new version...")
	version, prl, err = CalculateNewVersion(changelog, previousVersion, isCurrentPreview)
	if err != nil {
		return nil, err
	}

	log.Printf("Add changelog to file...")
	changelogMd, err := AddChangelogToFile(changelog, version, modulePath, generateParam.ReleaseDate)
	if err != nil {
		return nil, err
	}

	log.Printf("Update module definition if v2+...")
	err = UpdateModuleDefinition(modulePath, moduleRelativePath, version)
	if err != nil {
		return nil, err
	}

	log.Printf("Replace version in version.go...")
	if err = ReplaceConstModuleVersion(packagePath, version.String()); err != nil {
		return nil, err
	}

	// Replace import for module v2+
	baseModule := fmt.Sprintf("%s/%s", "github.com/Azure/azure-sdk-for-go", moduleRelativePath)
	if version.Major() > 1 {
		log.Printf("Replace import for module v2+...")
		if err = ReplaceModule(version, packagePath, baseModule, ".go"); err != nil {
			return nil, err
		}
	}

	log.Printf("Replace README.md module...")
	if err = replaceReadmeModule(modulePath, moduleRelativePath, version.String()); err != nil {
		return nil, err
	}

	log.Printf("Replace README.md NewClient name...")
	if err = ReplaceReadmeNewClientName(modulePath, newExports); err != nil {
		return nil, err
	}

	// Example generation should be the last step because the package import relay on the new calculated version
	if !generateParam.SkipGenerateExample {
		log.Printf("Generate examples...")
	}

	generationType := "TypeSpecUpdate"

	// remove autorest.md and build.go
	autorestMdPath := filepath.Join(packagePath, "autorest.md")
	if _, err := os.Stat(autorestMdPath); !os.IsNotExist(err) {
		log.Println("Remove autorest.md...")
		if err = os.Remove(autorestMdPath); err != nil {
			return nil, err
		}
		generationType = "MigrateToTypeSpec"
	}
	buildGoPath := filepath.Join(packagePath, "build.go")
	if _, err := os.Stat(buildGoPath); !os.IsNotExist(err) {
		log.Println("Remove build.go...")
		if err = os.Remove(buildGoPath); err != nil {
			return nil, err
		}
	}

	if _, err := t.TypeSpecCommonGenerator.AfterGenerate(generateParam, changelog, newExports); err != nil {
		return nil, err
	}

	return &GenerateResult{
		Version:             version.String(),
		RPName:              generateParam.RPName,
		PackageName:         generateParam.NamespaceName,
		PackageAbsPath:      packagePath,
		Changelog:           *changelog,
		ChangelogMD:         changelogMd + "\n" + changelog.GetChangeSummary(),
		PullRequestLabels:   string(prl),
		PackageRelativePath: packageRelativePath,
		ModuleRelativePath:  moduleRelativePath,
		GenerationType:      generationType,
	}, nil
}
