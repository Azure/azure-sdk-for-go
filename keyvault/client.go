// Package keyvault implements the Azure ARM Keyvault service API version
// 2015-06-01.
//
// Performs cryptographic key operations and vault operations against the Key
// Vault service.
package keyvault

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator 0.17.0.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

import (
	"net/http"

	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
)

const (
	// APIVersion is the version of the Keyvault
	APIVersion = "2015-06-01"

	// DefaultBaseURI is the default URI used for the service Keyvault
	DefaultBaseURI = "http://localhost"
)

// KeyVaultClient is the base client for Keyvault.
type KeyVaultClient struct {
	autorest.Client
	BaseURI    string
	APIVersion string
}

// New creates an instance of the KeyVaultClient client.
func New() KeyVaultClient {
	return NewWithBaseURI(DefaultBaseURI)
}

// NewWithBaseURI creates an instance of the KeyVaultClient client.
func NewWithBaseURI(baseURI string) KeyVaultClient {
	return KeyVaultClient{
		Client:     autorest.NewClientWithUserAgent(UserAgent()),
		BaseURI:    baseURI,
		APIVersion: APIVersion,
	}
}

// BackupKey requests that a backup of the specified key be downloaded to the
// client.
//
// keyName is the name of the key
func (client KeyVaultClient) BackupKey(keyName string) (result BackupKeyResult, err error) {
	req, err := client.BackupKeyPreparer(keyName)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "BackupKey", nil, "Failure preparing request")
	}

	resp, err := client.BackupKeySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "BackupKey", resp, "Failure sending request")
	}

	result, err = client.BackupKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "BackupKey", resp, "Failure responding to request")
	}

	return
}

// BackupKeyPreparer prepares the BackupKey request.
func (client KeyVaultClient) BackupKeyPreparer(keyName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name": autorest.Encode("path", keyName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}/backup", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// BackupKeySender sends the BackupKey request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) BackupKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// BackupKeyResponder handles the response to the BackupKey request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) BackupKeyResponder(resp *http.Response) (result BackupKeyResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateCertificate creates a new certificate version. If this is the first
// version, the certificate resource is created.
//
// certificateName is the name of the certificate parameters is the parameters
// to create certificate.
func (client KeyVaultClient) CreateCertificate(certificateName string, parameters CertificateCreateParameters) (result CertificateOperation, err error) {
	if err := validation.Validate([]validation.Validation{
		{certificateName,
			[]validation.Constraint{{"certificateName", validation.Pattern, `^[0-9a-zA-Z-]+$`, nil}}},
		{parameters,
			[]validation.Constraint{{"parameters.Policy", validation.Null, false,
				[]validation.Constraint{{"parameters.Policy.X509Props", validation.Null, false,
					[]validation.Constraint{{"parameters.Policy.X509Props.ValidityMonths", validation.Null, false,
						[]validation.Constraint{{"parameters.Policy.X509Props.ValidityMonths", validation.InclusiveMinimum, 0, nil}}},
					}},
					{"ID", validation.ReadOnly, true, nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "CreateCertificate")
	}

	req, err := client.CreateCertificatePreparer(certificateName, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "CreateCertificate", nil, "Failure preparing request")
	}

	resp, err := client.CreateCertificateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "CreateCertificate", resp, "Failure sending request")
	}

	result, err = client.CreateCertificateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "CreateCertificate", resp, "Failure responding to request")
	}

	return
}

// CreateCertificatePreparer prepares the CreateCertificate request.
func (client KeyVaultClient) CreateCertificatePreparer(certificateName string, parameters CertificateCreateParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"certificate-name": autorest.Encode("path", certificateName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/{certificate-name}/create", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// CreateCertificateSender sends the CreateCertificate request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) CreateCertificateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// CreateCertificateResponder handles the response to the CreateCertificate request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) CreateCertificateResponder(resp *http.Response) (result CertificateOperation, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateKey creates a new, named, key in the specified vault.
//
// keyName is the name of the key parameters is the parameters to create key.
func (client KeyVaultClient) CreateKey(keyName string, parameters KeyCreateParameters) (result KeyBundle, err error) {
	if err := validation.Validate([]validation.Validation{
		{keyName,
			[]validation.Constraint{{"keyName", validation.Pattern, `^[0-9a-zA-Z-]+$`, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "CreateKey")
	}

	req, err := client.CreateKeyPreparer(keyName, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "CreateKey", nil, "Failure preparing request")
	}

	resp, err := client.CreateKeySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "CreateKey", resp, "Failure sending request")
	}

	result, err = client.CreateKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "CreateKey", resp, "Failure responding to request")
	}

	return
}

// CreateKeyPreparer prepares the CreateKey request.
func (client KeyVaultClient) CreateKeyPreparer(keyName string, parameters KeyCreateParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name": autorest.Encode("path", keyName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}/create", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// CreateKeySender sends the CreateKey request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) CreateKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// CreateKeyResponder handles the response to the CreateKey request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) CreateKeyResponder(resp *http.Response) (result KeyBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Decrypt decrypts a single block of encrypted data
//
// keyName is the name of the key keyVersion is the version of the key
// parameters is the parameters for key operations.
func (client KeyVaultClient) Decrypt(keyName string, keyVersion string, parameters KeyOperationsParameters) (result KeyOperationResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{parameters,
			[]validation.Constraint{{"parameters.Value", validation.Null, true, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "Decrypt")
	}

	req, err := client.DecryptPreparer(keyName, keyVersion, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "Decrypt", nil, "Failure preparing request")
	}

	resp, err := client.DecryptSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "Decrypt", resp, "Failure sending request")
	}

	result, err = client.DecryptResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "Decrypt", resp, "Failure responding to request")
	}

	return
}

// DecryptPreparer prepares the Decrypt request.
func (client KeyVaultClient) DecryptPreparer(keyName string, keyVersion string, parameters KeyOperationsParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name":    autorest.Encode("path", keyName),
		"key-version": autorest.Encode("path", keyVersion),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}/{key-version}/decrypt", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DecryptSender sends the Decrypt request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) DecryptSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DecryptResponder handles the response to the Decrypt request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) DecryptResponder(resp *http.Response) (result KeyOperationResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteCertificate deletes a certificate from the specified vault.
//
// certificateName is the name of the certificate in the given vault
func (client KeyVaultClient) DeleteCertificate(certificateName string) (result CertificateBundle, err error) {
	req, err := client.DeleteCertificatePreparer(certificateName)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteCertificate", nil, "Failure preparing request")
	}

	resp, err := client.DeleteCertificateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteCertificate", resp, "Failure sending request")
	}

	result, err = client.DeleteCertificateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteCertificate", resp, "Failure responding to request")
	}

	return
}

// DeleteCertificatePreparer prepares the DeleteCertificate request.
func (client KeyVaultClient) DeleteCertificatePreparer(certificateName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"certificate-name": autorest.Encode("path", certificateName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/{certificate-name}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DeleteCertificateSender sends the DeleteCertificate request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) DeleteCertificateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DeleteCertificateResponder handles the response to the DeleteCertificate request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) DeleteCertificateResponder(resp *http.Response) (result CertificateBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteCertificateContacts deletes the certificate contacts for the
// specified vault.
func (client KeyVaultClient) DeleteCertificateContacts() (result Contacts, err error) {
	req, err := client.DeleteCertificateContactsPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteCertificateContacts", nil, "Failure preparing request")
	}

	resp, err := client.DeleteCertificateContactsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteCertificateContacts", resp, "Failure sending request")
	}

	result, err = client.DeleteCertificateContactsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteCertificateContacts", resp, "Failure responding to request")
	}

	return
}

// DeleteCertificateContactsPreparer prepares the DeleteCertificateContacts request.
func (client KeyVaultClient) DeleteCertificateContactsPreparer() (*http.Request, error) {
	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/certificates/contacts"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DeleteCertificateContactsSender sends the DeleteCertificateContacts request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) DeleteCertificateContactsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DeleteCertificateContactsResponder handles the response to the DeleteCertificateContacts request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) DeleteCertificateContactsResponder(resp *http.Response) (result Contacts, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteCertificateIssuer deletes the specified certificate issuer.
//
// issuerName is the name of the issuer.
func (client KeyVaultClient) DeleteCertificateIssuer(issuerName string) (result IssuerBundle, err error) {
	req, err := client.DeleteCertificateIssuerPreparer(issuerName)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteCertificateIssuer", nil, "Failure preparing request")
	}

	resp, err := client.DeleteCertificateIssuerSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteCertificateIssuer", resp, "Failure sending request")
	}

	result, err = client.DeleteCertificateIssuerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteCertificateIssuer", resp, "Failure responding to request")
	}

	return
}

// DeleteCertificateIssuerPreparer prepares the DeleteCertificateIssuer request.
func (client KeyVaultClient) DeleteCertificateIssuerPreparer(issuerName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"issuer-name": autorest.Encode("path", issuerName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/issuers/{issuer-name}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DeleteCertificateIssuerSender sends the DeleteCertificateIssuer request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) DeleteCertificateIssuerSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DeleteCertificateIssuerResponder handles the response to the DeleteCertificateIssuer request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) DeleteCertificateIssuerResponder(resp *http.Response) (result IssuerBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteCertificateOperation deletes the certificate operation.
//
// certificateName is the name of the certificate
func (client KeyVaultClient) DeleteCertificateOperation(certificateName string) (result CertificateOperation, err error) {
	req, err := client.DeleteCertificateOperationPreparer(certificateName)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteCertificateOperation", nil, "Failure preparing request")
	}

	resp, err := client.DeleteCertificateOperationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteCertificateOperation", resp, "Failure sending request")
	}

	result, err = client.DeleteCertificateOperationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteCertificateOperation", resp, "Failure responding to request")
	}

	return
}

// DeleteCertificateOperationPreparer prepares the DeleteCertificateOperation request.
func (client KeyVaultClient) DeleteCertificateOperationPreparer(certificateName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"certificate-name": autorest.Encode("path", certificateName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/{certificate-name}/pending", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DeleteCertificateOperationSender sends the DeleteCertificateOperation request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) DeleteCertificateOperationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DeleteCertificateOperationResponder handles the response to the DeleteCertificateOperation request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) DeleteCertificateOperationResponder(resp *http.Response) (result CertificateOperation, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteKey deletes the specified key
//
// keyName is the name of the key
func (client KeyVaultClient) DeleteKey(keyName string) (result KeyBundle, err error) {
	req, err := client.DeleteKeyPreparer(keyName)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteKey", nil, "Failure preparing request")
	}

	resp, err := client.DeleteKeySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteKey", resp, "Failure sending request")
	}

	result, err = client.DeleteKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteKey", resp, "Failure responding to request")
	}

	return
}

// DeleteKeyPreparer prepares the DeleteKey request.
func (client KeyVaultClient) DeleteKeyPreparer(keyName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name": autorest.Encode("path", keyName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DeleteKeySender sends the DeleteKey request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) DeleteKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DeleteKeyResponder handles the response to the DeleteKey request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) DeleteKeyResponder(resp *http.Response) (result KeyBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteSecret deletes a secret from the specified vault.
//
// secretName is the name of the secret in the given vault
func (client KeyVaultClient) DeleteSecret(secretName string) (result SecretBundle, err error) {
	req, err := client.DeleteSecretPreparer(secretName)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteSecret", nil, "Failure preparing request")
	}

	resp, err := client.DeleteSecretSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteSecret", resp, "Failure sending request")
	}

	result, err = client.DeleteSecretResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "DeleteSecret", resp, "Failure responding to request")
	}

	return
}

// DeleteSecretPreparer prepares the DeleteSecret request.
func (client KeyVaultClient) DeleteSecretPreparer(secretName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"secret-name": autorest.Encode("path", secretName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/secrets/{secret-name}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DeleteSecretSender sends the DeleteSecret request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) DeleteSecretSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DeleteSecretResponder handles the response to the DeleteSecret request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) DeleteSecretResponder(resp *http.Response) (result SecretBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Encrypt encrypts an arbitrary sequence of bytes using an encryption key
// that is stored in Azure Key Vault.
//
// keyName is the name of the key keyVersion is the version of the key
// parameters is the parameters for key operations.
func (client KeyVaultClient) Encrypt(keyName string, keyVersion string, parameters KeyOperationsParameters) (result KeyOperationResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{parameters,
			[]validation.Constraint{{"parameters.Value", validation.Null, true, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "Encrypt")
	}

	req, err := client.EncryptPreparer(keyName, keyVersion, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "Encrypt", nil, "Failure preparing request")
	}

	resp, err := client.EncryptSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "Encrypt", resp, "Failure sending request")
	}

	result, err = client.EncryptResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "Encrypt", resp, "Failure responding to request")
	}

	return
}

// EncryptPreparer prepares the Encrypt request.
func (client KeyVaultClient) EncryptPreparer(keyName string, keyVersion string, parameters KeyOperationsParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name":    autorest.Encode("path", keyName),
		"key-version": autorest.Encode("path", keyVersion),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}/{key-version}/encrypt", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// EncryptSender sends the Encrypt request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) EncryptSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// EncryptResponder handles the response to the Encrypt request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) EncryptResponder(resp *http.Response) (result KeyOperationResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetCertificate gets a Certificate.
//
// certificateName is the name of the certificate in the given vault
// certificateVersion is the version of the certificate
func (client KeyVaultClient) GetCertificate(certificateName string, certificateVersion string) (result CertificateBundle, err error) {
	req, err := client.GetCertificatePreparer(certificateName, certificateVersion)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificate", nil, "Failure preparing request")
	}

	resp, err := client.GetCertificateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificate", resp, "Failure sending request")
	}

	result, err = client.GetCertificateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificate", resp, "Failure responding to request")
	}

	return
}

// GetCertificatePreparer prepares the GetCertificate request.
func (client KeyVaultClient) GetCertificatePreparer(certificateName string, certificateVersion string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"certificate-name":    autorest.Encode("path", certificateName),
		"certificate-version": autorest.Encode("path", certificateVersion),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/{certificate-name}/{certificate-version}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetCertificateSender sends the GetCertificate request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetCertificateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetCertificateResponder handles the response to the GetCertificate request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetCertificateResponder(resp *http.Response) (result CertificateBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetCertificateContacts gets the certificate contacts for the specified
// vault.
func (client KeyVaultClient) GetCertificateContacts() (result Contacts, err error) {
	req, err := client.GetCertificateContactsPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateContacts", nil, "Failure preparing request")
	}

	resp, err := client.GetCertificateContactsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateContacts", resp, "Failure sending request")
	}

	result, err = client.GetCertificateContactsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateContacts", resp, "Failure responding to request")
	}

	return
}

// GetCertificateContactsPreparer prepares the GetCertificateContacts request.
func (client KeyVaultClient) GetCertificateContactsPreparer() (*http.Request, error) {
	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/certificates/contacts"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetCertificateContactsSender sends the GetCertificateContacts request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetCertificateContactsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetCertificateContactsResponder handles the response to the GetCertificateContacts request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetCertificateContactsResponder(resp *http.Response) (result Contacts, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetCertificateIssuer gets the specified certificate issuer.
//
// issuerName is the name of the issuer.
func (client KeyVaultClient) GetCertificateIssuer(issuerName string) (result IssuerBundle, err error) {
	req, err := client.GetCertificateIssuerPreparer(issuerName)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateIssuer", nil, "Failure preparing request")
	}

	resp, err := client.GetCertificateIssuerSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateIssuer", resp, "Failure sending request")
	}

	result, err = client.GetCertificateIssuerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateIssuer", resp, "Failure responding to request")
	}

	return
}

// GetCertificateIssuerPreparer prepares the GetCertificateIssuer request.
func (client KeyVaultClient) GetCertificateIssuerPreparer(issuerName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"issuer-name": autorest.Encode("path", issuerName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/issuers/{issuer-name}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetCertificateIssuerSender sends the GetCertificateIssuer request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetCertificateIssuerSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetCertificateIssuerResponder handles the response to the GetCertificateIssuer request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetCertificateIssuerResponder(resp *http.Response) (result IssuerBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetCertificateIssuers list certificate issuers for the specified vault.
//
// maxresults is maximum number of results to return in a page. If not
// specified the service will return up to 25 results.
func (client KeyVaultClient) GetCertificateIssuers(maxresults *int32) (result CertificateIssuerListResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{maxresults,
			[]validation.Constraint{{"maxresults", validation.Null, false,
				[]validation.Constraint{{"maxresults", validation.InclusiveMaximum, 25, nil},
					{"maxresults", validation.InclusiveMinimum, 1, nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "GetCertificateIssuers")
	}

	req, err := client.GetCertificateIssuersPreparer(maxresults)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateIssuers", nil, "Failure preparing request")
	}

	resp, err := client.GetCertificateIssuersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateIssuers", resp, "Failure sending request")
	}

	result, err = client.GetCertificateIssuersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateIssuers", resp, "Failure responding to request")
	}

	return
}

// GetCertificateIssuersPreparer prepares the GetCertificateIssuers request.
func (client KeyVaultClient) GetCertificateIssuersPreparer(maxresults *int32) (*http.Request, error) {
	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}
	if maxresults != nil {
		queryParameters["maxresults"] = autorest.Encode("query", *maxresults)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/certificates/issuers"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetCertificateIssuersSender sends the GetCertificateIssuers request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetCertificateIssuersSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetCertificateIssuersResponder handles the response to the GetCertificateIssuers request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetCertificateIssuersResponder(resp *http.Response) (result CertificateIssuerListResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetCertificateIssuersNextResults retrieves the next set of results, if any.
func (client KeyVaultClient) GetCertificateIssuersNextResults(lastResults CertificateIssuerListResult) (result CertificateIssuerListResult, err error) {
	req, err := lastResults.CertificateIssuerListResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateIssuers", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.GetCertificateIssuersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateIssuers", resp, "Failure sending next results request")
	}

	result, err = client.GetCertificateIssuersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateIssuers", resp, "Failure responding to next results request")
	}

	return
}

// GetCertificateOperation gets the certificate operation response.
//
// certificateName is the name of the certificate
func (client KeyVaultClient) GetCertificateOperation(certificateName string) (result CertificateOperation, err error) {
	req, err := client.GetCertificateOperationPreparer(certificateName)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateOperation", nil, "Failure preparing request")
	}

	resp, err := client.GetCertificateOperationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateOperation", resp, "Failure sending request")
	}

	result, err = client.GetCertificateOperationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateOperation", resp, "Failure responding to request")
	}

	return
}

// GetCertificateOperationPreparer prepares the GetCertificateOperation request.
func (client KeyVaultClient) GetCertificateOperationPreparer(certificateName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"certificate-name": autorest.Encode("path", certificateName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/{certificate-name}/pending", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetCertificateOperationSender sends the GetCertificateOperation request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetCertificateOperationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetCertificateOperationResponder handles the response to the GetCertificateOperation request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetCertificateOperationResponder(resp *http.Response) (result CertificateOperation, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetCertificatePolicy gets the policy for a certificate.
//
// certificateName is the name of the certificate in the given vault.
func (client KeyVaultClient) GetCertificatePolicy(certificateName string) (result CertificatePolicy, err error) {
	req, err := client.GetCertificatePolicyPreparer(certificateName)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificatePolicy", nil, "Failure preparing request")
	}

	resp, err := client.GetCertificatePolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificatePolicy", resp, "Failure sending request")
	}

	result, err = client.GetCertificatePolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificatePolicy", resp, "Failure responding to request")
	}

	return
}

// GetCertificatePolicyPreparer prepares the GetCertificatePolicy request.
func (client KeyVaultClient) GetCertificatePolicyPreparer(certificateName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"certificate-name": autorest.Encode("path", certificateName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/{certificate-name}/policy", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetCertificatePolicySender sends the GetCertificatePolicy request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetCertificatePolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetCertificatePolicyResponder handles the response to the GetCertificatePolicy request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetCertificatePolicyResponder(resp *http.Response) (result CertificatePolicy, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetCertificates list certificates in the specified vault
//
// maxresults is maximum number of results to return in a page. If not
// specified the service will return up to 25 results.
func (client KeyVaultClient) GetCertificates(maxresults *int32) (result CertificateListResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{maxresults,
			[]validation.Constraint{{"maxresults", validation.Null, false,
				[]validation.Constraint{{"maxresults", validation.InclusiveMaximum, 25, nil},
					{"maxresults", validation.InclusiveMinimum, 1, nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "GetCertificates")
	}

	req, err := client.GetCertificatesPreparer(maxresults)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificates", nil, "Failure preparing request")
	}

	resp, err := client.GetCertificatesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificates", resp, "Failure sending request")
	}

	result, err = client.GetCertificatesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificates", resp, "Failure responding to request")
	}

	return
}

// GetCertificatesPreparer prepares the GetCertificates request.
func (client KeyVaultClient) GetCertificatesPreparer(maxresults *int32) (*http.Request, error) {
	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}
	if maxresults != nil {
		queryParameters["maxresults"] = autorest.Encode("query", *maxresults)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/certificates"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetCertificatesSender sends the GetCertificates request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetCertificatesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetCertificatesResponder handles the response to the GetCertificates request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetCertificatesResponder(resp *http.Response) (result CertificateListResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetCertificatesNextResults retrieves the next set of results, if any.
func (client KeyVaultClient) GetCertificatesNextResults(lastResults CertificateListResult) (result CertificateListResult, err error) {
	req, err := lastResults.CertificateListResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificates", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.GetCertificatesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificates", resp, "Failure sending next results request")
	}

	result, err = client.GetCertificatesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificates", resp, "Failure responding to next results request")
	}

	return
}

// GetCertificateVersions list the versions of a certificate.
//
// certificateName is the name of the certificate maxresults is maximum number
// of results to return in a page. If not specified the service will return
// up to 25 results.
func (client KeyVaultClient) GetCertificateVersions(certificateName string, maxresults *int32) (result CertificateListResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{maxresults,
			[]validation.Constraint{{"maxresults", validation.Null, false,
				[]validation.Constraint{{"maxresults", validation.InclusiveMaximum, 25, nil},
					{"maxresults", validation.InclusiveMinimum, 1, nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "GetCertificateVersions")
	}

	req, err := client.GetCertificateVersionsPreparer(certificateName, maxresults)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateVersions", nil, "Failure preparing request")
	}

	resp, err := client.GetCertificateVersionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateVersions", resp, "Failure sending request")
	}

	result, err = client.GetCertificateVersionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateVersions", resp, "Failure responding to request")
	}

	return
}

// GetCertificateVersionsPreparer prepares the GetCertificateVersions request.
func (client KeyVaultClient) GetCertificateVersionsPreparer(certificateName string, maxresults *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"certificate-name": autorest.Encode("path", certificateName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}
	if maxresults != nil {
		queryParameters["maxresults"] = autorest.Encode("query", *maxresults)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/{certificate-name}/versions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetCertificateVersionsSender sends the GetCertificateVersions request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetCertificateVersionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetCertificateVersionsResponder handles the response to the GetCertificateVersions request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetCertificateVersionsResponder(resp *http.Response) (result CertificateListResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetCertificateVersionsNextResults retrieves the next set of results, if any.
func (client KeyVaultClient) GetCertificateVersionsNextResults(lastResults CertificateListResult) (result CertificateListResult, err error) {
	req, err := lastResults.CertificateListResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateVersions", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.GetCertificateVersionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateVersions", resp, "Failure sending next results request")
	}

	result, err = client.GetCertificateVersionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetCertificateVersions", resp, "Failure responding to next results request")
	}

	return
}

// GetKey retrieves the public portion of a key plus its attributes
//
// keyName is the name of the key keyVersion is the version of the key
func (client KeyVaultClient) GetKey(keyName string, keyVersion string) (result KeyBundle, err error) {
	req, err := client.GetKeyPreparer(keyName, keyVersion)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKey", nil, "Failure preparing request")
	}

	resp, err := client.GetKeySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKey", resp, "Failure sending request")
	}

	result, err = client.GetKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKey", resp, "Failure responding to request")
	}

	return
}

// GetKeyPreparer prepares the GetKey request.
func (client KeyVaultClient) GetKeyPreparer(keyName string, keyVersion string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name":    autorest.Encode("path", keyName),
		"key-version": autorest.Encode("path", keyVersion),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}/{key-version}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetKeySender sends the GetKey request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetKeyResponder handles the response to the GetKey request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetKeyResponder(resp *http.Response) (result KeyBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetKeys list keys in the specified vault
//
// maxresults is maximum number of results to return in a page. If not
// specified the service will return up to 25 results.
func (client KeyVaultClient) GetKeys(maxresults *int32) (result KeyListResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{maxresults,
			[]validation.Constraint{{"maxresults", validation.Null, false,
				[]validation.Constraint{{"maxresults", validation.InclusiveMaximum, 25, nil},
					{"maxresults", validation.InclusiveMinimum, 1, nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "GetKeys")
	}

	req, err := client.GetKeysPreparer(maxresults)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKeys", nil, "Failure preparing request")
	}

	resp, err := client.GetKeysSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKeys", resp, "Failure sending request")
	}

	result, err = client.GetKeysResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKeys", resp, "Failure responding to request")
	}

	return
}

// GetKeysPreparer prepares the GetKeys request.
func (client KeyVaultClient) GetKeysPreparer(maxresults *int32) (*http.Request, error) {
	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}
	if maxresults != nil {
		queryParameters["maxresults"] = autorest.Encode("query", *maxresults)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/keys"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetKeysSender sends the GetKeys request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetKeysSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetKeysResponder handles the response to the GetKeys request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetKeysResponder(resp *http.Response) (result KeyListResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetKeysNextResults retrieves the next set of results, if any.
func (client KeyVaultClient) GetKeysNextResults(lastResults KeyListResult) (result KeyListResult, err error) {
	req, err := lastResults.KeyListResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKeys", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.GetKeysSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKeys", resp, "Failure sending next results request")
	}

	result, err = client.GetKeysResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKeys", resp, "Failure responding to next results request")
	}

	return
}

// GetKeyVersions list the versions of the specified key
//
// keyName is the name of the key maxresults is maximum number of results to
// return in a page. If not specified the service will return up to 25
// results.
func (client KeyVaultClient) GetKeyVersions(keyName string, maxresults *int32) (result KeyListResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{maxresults,
			[]validation.Constraint{{"maxresults", validation.Null, false,
				[]validation.Constraint{{"maxresults", validation.InclusiveMaximum, 25, nil},
					{"maxresults", validation.InclusiveMinimum, 1, nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "GetKeyVersions")
	}

	req, err := client.GetKeyVersionsPreparer(keyName, maxresults)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKeyVersions", nil, "Failure preparing request")
	}

	resp, err := client.GetKeyVersionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKeyVersions", resp, "Failure sending request")
	}

	result, err = client.GetKeyVersionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKeyVersions", resp, "Failure responding to request")
	}

	return
}

// GetKeyVersionsPreparer prepares the GetKeyVersions request.
func (client KeyVaultClient) GetKeyVersionsPreparer(keyName string, maxresults *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name": autorest.Encode("path", keyName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}
	if maxresults != nil {
		queryParameters["maxresults"] = autorest.Encode("query", *maxresults)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}/versions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetKeyVersionsSender sends the GetKeyVersions request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetKeyVersionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetKeyVersionsResponder handles the response to the GetKeyVersions request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetKeyVersionsResponder(resp *http.Response) (result KeyListResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetKeyVersionsNextResults retrieves the next set of results, if any.
func (client KeyVaultClient) GetKeyVersionsNextResults(lastResults KeyListResult) (result KeyListResult, err error) {
	req, err := lastResults.KeyListResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKeyVersions", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.GetKeyVersionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKeyVersions", resp, "Failure sending next results request")
	}

	result, err = client.GetKeyVersionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetKeyVersions", resp, "Failure responding to next results request")
	}

	return
}

// GetSecret gets a secret.
//
// secretName is the name of the secret in the given vault secretVersion is
// the version of the secret
func (client KeyVaultClient) GetSecret(secretName string, secretVersion string) (result SecretBundle, err error) {
	req, err := client.GetSecretPreparer(secretName, secretVersion)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecret", nil, "Failure preparing request")
	}

	resp, err := client.GetSecretSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecret", resp, "Failure sending request")
	}

	result, err = client.GetSecretResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecret", resp, "Failure responding to request")
	}

	return
}

// GetSecretPreparer prepares the GetSecret request.
func (client KeyVaultClient) GetSecretPreparer(secretName string, secretVersion string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"secret-name":    autorest.Encode("path", secretName),
		"secret-version": autorest.Encode("path", secretVersion),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/secrets/{secret-name}/{secret-version}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetSecretSender sends the GetSecret request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetSecretSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetSecretResponder handles the response to the GetSecret request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetSecretResponder(resp *http.Response) (result SecretBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSecrets list secrets in the specified vault
//
// maxresults is maximum number of results to return in a page. If not
// specified the service will return up to 25 results.
func (client KeyVaultClient) GetSecrets(maxresults *int32) (result SecretListResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{maxresults,
			[]validation.Constraint{{"maxresults", validation.Null, false,
				[]validation.Constraint{{"maxresults", validation.InclusiveMaximum, 25, nil},
					{"maxresults", validation.InclusiveMinimum, 1, nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "GetSecrets")
	}

	req, err := client.GetSecretsPreparer(maxresults)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecrets", nil, "Failure preparing request")
	}

	resp, err := client.GetSecretsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecrets", resp, "Failure sending request")
	}

	result, err = client.GetSecretsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecrets", resp, "Failure responding to request")
	}

	return
}

// GetSecretsPreparer prepares the GetSecrets request.
func (client KeyVaultClient) GetSecretsPreparer(maxresults *int32) (*http.Request, error) {
	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}
	if maxresults != nil {
		queryParameters["maxresults"] = autorest.Encode("query", *maxresults)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/secrets"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetSecretsSender sends the GetSecrets request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetSecretsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetSecretsResponder handles the response to the GetSecrets request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetSecretsResponder(resp *http.Response) (result SecretListResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSecretsNextResults retrieves the next set of results, if any.
func (client KeyVaultClient) GetSecretsNextResults(lastResults SecretListResult) (result SecretListResult, err error) {
	req, err := lastResults.SecretListResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecrets", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.GetSecretsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecrets", resp, "Failure sending next results request")
	}

	result, err = client.GetSecretsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecrets", resp, "Failure responding to next results request")
	}

	return
}

// GetSecretVersions list the versions of the specified secret
//
// secretName is the name of the secret in the given vault maxresults is
// maximum number of results to return in a page. If not specified the
// service will return up to 25 results.
func (client KeyVaultClient) GetSecretVersions(secretName string, maxresults *int32) (result SecretListResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{maxresults,
			[]validation.Constraint{{"maxresults", validation.Null, false,
				[]validation.Constraint{{"maxresults", validation.InclusiveMaximum, 25, nil},
					{"maxresults", validation.InclusiveMinimum, 1, nil},
				}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "GetSecretVersions")
	}

	req, err := client.GetSecretVersionsPreparer(secretName, maxresults)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecretVersions", nil, "Failure preparing request")
	}

	resp, err := client.GetSecretVersionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecretVersions", resp, "Failure sending request")
	}

	result, err = client.GetSecretVersionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecretVersions", resp, "Failure responding to request")
	}

	return
}

// GetSecretVersionsPreparer prepares the GetSecretVersions request.
func (client KeyVaultClient) GetSecretVersionsPreparer(secretName string, maxresults *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"secret-name": autorest.Encode("path", secretName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}
	if maxresults != nil {
		queryParameters["maxresults"] = autorest.Encode("query", *maxresults)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/secrets/{secret-name}/versions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetSecretVersionsSender sends the GetSecretVersions request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) GetSecretVersionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetSecretVersionsResponder handles the response to the GetSecretVersions request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) GetSecretVersionsResponder(resp *http.Response) (result SecretListResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSecretVersionsNextResults retrieves the next set of results, if any.
func (client KeyVaultClient) GetSecretVersionsNextResults(lastResults SecretListResult) (result SecretListResult, err error) {
	req, err := lastResults.SecretListResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecretVersions", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.GetSecretVersionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecretVersions", resp, "Failure sending next results request")
	}

	result, err = client.GetSecretVersionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "GetSecretVersions", resp, "Failure responding to next results request")
	}

	return
}

// ImportCertificate imports a certificate into the specified vault
//
// certificateName is the name of the certificate parameters is the parameters
// to import certificate.
func (client KeyVaultClient) ImportCertificate(certificateName string, parameters CertificateImportParameters) (result CertificateBundle, err error) {
	if err := validation.Validate([]validation.Validation{
		{certificateName,
			[]validation.Constraint{{"certificateName", validation.Pattern, `^[0-9a-zA-Z-]+$`, nil}}},
		{parameters,
			[]validation.Constraint{{"parameters.Value", validation.Null, true, nil},
				{"parameters.Policy", validation.Null, false,
					[]validation.Constraint{{"parameters.Policy.X509Props", validation.Null, false,
						[]validation.Constraint{{"parameters.Policy.X509Props.ValidityMonths", validation.Null, false,
							[]validation.Constraint{{"parameters.Policy.X509Props.ValidityMonths", validation.InclusiveMinimum, 0, nil}}},
						}},
						{"ID", validation.ReadOnly, true, nil},
					}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "ImportCertificate")
	}

	req, err := client.ImportCertificatePreparer(certificateName, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "ImportCertificate", nil, "Failure preparing request")
	}

	resp, err := client.ImportCertificateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "ImportCertificate", resp, "Failure sending request")
	}

	result, err = client.ImportCertificateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "ImportCertificate", resp, "Failure responding to request")
	}

	return
}

// ImportCertificatePreparer prepares the ImportCertificate request.
func (client KeyVaultClient) ImportCertificatePreparer(certificateName string, parameters CertificateImportParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"certificate-name": autorest.Encode("path", certificateName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/{certificate-name}/import", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ImportCertificateSender sends the ImportCertificate request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) ImportCertificateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ImportCertificateResponder handles the response to the ImportCertificate request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) ImportCertificateResponder(resp *http.Response) (result CertificateBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ImportKey imports a key into the specified vault
//
// keyName is the name of the key parameters is the parameters to import key.
func (client KeyVaultClient) ImportKey(keyName string, parameters KeyImportParameters) (result KeyBundle, err error) {
	if err := validation.Validate([]validation.Validation{
		{keyName,
			[]validation.Constraint{{"keyName", validation.Pattern, `^[0-9a-zA-Z-]+$`, nil}}},
		{parameters,
			[]validation.Constraint{{"parameters.Key", validation.Null, true, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "ImportKey")
	}

	req, err := client.ImportKeyPreparer(keyName, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "ImportKey", nil, "Failure preparing request")
	}

	resp, err := client.ImportKeySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "ImportKey", resp, "Failure sending request")
	}

	result, err = client.ImportKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "ImportKey", resp, "Failure responding to request")
	}

	return
}

// ImportKeyPreparer prepares the ImportKey request.
func (client KeyVaultClient) ImportKeyPreparer(keyName string, parameters KeyImportParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name": autorest.Encode("path", keyName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ImportKeySender sends the ImportKey request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) ImportKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ImportKeyResponder handles the response to the ImportKey request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) ImportKeyResponder(resp *http.Response) (result KeyBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// MergeCertificate merges a certificate or a certificate chain with a key
// pair existing on the server.
//
// certificateName is the name of the certificate parameters is the parameters
// to merge certificate.
func (client KeyVaultClient) MergeCertificate(certificateName string, parameters CertificateMergeParameters) (result CertificateBundle, err error) {
	if err := validation.Validate([]validation.Validation{
		{parameters,
			[]validation.Constraint{{"parameters.X5c", validation.Null, true, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "MergeCertificate")
	}

	req, err := client.MergeCertificatePreparer(certificateName, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "MergeCertificate", nil, "Failure preparing request")
	}

	resp, err := client.MergeCertificateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "MergeCertificate", resp, "Failure sending request")
	}

	result, err = client.MergeCertificateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "MergeCertificate", resp, "Failure responding to request")
	}

	return
}

// MergeCertificatePreparer prepares the MergeCertificate request.
func (client KeyVaultClient) MergeCertificatePreparer(certificateName string, parameters CertificateMergeParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"certificate-name": autorest.Encode("path", certificateName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/{certificate-name}/pending/merge", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// MergeCertificateSender sends the MergeCertificate request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) MergeCertificateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// MergeCertificateResponder handles the response to the MergeCertificate request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) MergeCertificateResponder(resp *http.Response) (result CertificateBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// RestoreKey restores the backup key in to a vault
//
// parameters is the parameters to restore key
func (client KeyVaultClient) RestoreKey(parameters KeyRestoreParameters) (result KeyBundle, err error) {
	if err := validation.Validate([]validation.Validation{
		{parameters,
			[]validation.Constraint{{"parameters.Value", validation.Null, true, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "RestoreKey")
	}

	req, err := client.RestoreKeyPreparer(parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "RestoreKey", nil, "Failure preparing request")
	}

	resp, err := client.RestoreKeySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "RestoreKey", resp, "Failure sending request")
	}

	result, err = client.RestoreKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "RestoreKey", resp, "Failure responding to request")
	}

	return
}

// RestoreKeyPreparer prepares the RestoreKey request.
func (client KeyVaultClient) RestoreKeyPreparer(parameters KeyRestoreParameters) (*http.Request, error) {
	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/keys/restore"),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// RestoreKeySender sends the RestoreKey request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) RestoreKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// RestoreKeyResponder handles the response to the RestoreKey request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) RestoreKeyResponder(resp *http.Response) (result KeyBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// SetCertificateContacts sets the certificate contacts for the specified
// vault.
//
// contacts is the contacts for the vault certificates.
func (client KeyVaultClient) SetCertificateContacts(contacts Contacts) (result Contacts, err error) {
	if err := validation.Validate([]validation.Validation{
		{contacts,
			[]validation.Constraint{{"ID", validation.ReadOnly, true, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "SetCertificateContacts")
	}

	req, err := client.SetCertificateContactsPreparer(contacts)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "SetCertificateContacts", nil, "Failure preparing request")
	}

	resp, err := client.SetCertificateContactsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "SetCertificateContacts", resp, "Failure sending request")
	}

	result, err = client.SetCertificateContactsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "SetCertificateContacts", resp, "Failure responding to request")
	}

	return
}

// SetCertificateContactsPreparer prepares the SetCertificateContacts request.
func (client KeyVaultClient) SetCertificateContactsPreparer(contacts Contacts) (*http.Request, error) {
	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/certificates/contacts"),
		autorest.WithJSON(contacts),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// SetCertificateContactsSender sends the SetCertificateContacts request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) SetCertificateContactsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// SetCertificateContactsResponder handles the response to the SetCertificateContacts request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) SetCertificateContactsResponder(resp *http.Response) (result Contacts, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// SetCertificateIssuer sets the specified certificate issuer.
//
// issuerName is the name of the issuer. parameter is certificate issuer set
// parameter.
func (client KeyVaultClient) SetCertificateIssuer(issuerName string, parameter CertificateIssuerSetParameters) (result IssuerBundle, err error) {
	if err := validation.Validate([]validation.Validation{
		{parameter,
			[]validation.Constraint{{"parameter.Provider", validation.Null, true, nil},
				{"parameter.Attributes", validation.Null, false,
					[]validation.Constraint{{"Created", validation.ReadOnly, true, nil},
						{"Updated", validation.ReadOnly, true, nil},
					}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "SetCertificateIssuer")
	}

	req, err := client.SetCertificateIssuerPreparer(issuerName, parameter)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "SetCertificateIssuer", nil, "Failure preparing request")
	}

	resp, err := client.SetCertificateIssuerSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "SetCertificateIssuer", resp, "Failure sending request")
	}

	result, err = client.SetCertificateIssuerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "SetCertificateIssuer", resp, "Failure responding to request")
	}

	return
}

// SetCertificateIssuerPreparer prepares the SetCertificateIssuer request.
func (client KeyVaultClient) SetCertificateIssuerPreparer(issuerName string, parameter CertificateIssuerSetParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"issuer-name": autorest.Encode("path", issuerName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/issuers/{issuer-name}", pathParameters),
		autorest.WithJSON(parameter),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// SetCertificateIssuerSender sends the SetCertificateIssuer request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) SetCertificateIssuerSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// SetCertificateIssuerResponder handles the response to the SetCertificateIssuer request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) SetCertificateIssuerResponder(resp *http.Response) (result IssuerBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// SetSecret sets a secret in the specified vault.
//
// secretName is the name of the secret in the given vault parameters is the
// parameters for secret set
func (client KeyVaultClient) SetSecret(secretName string, parameters SecretSetParameters) (result SecretBundle, err error) {
	if err := validation.Validate([]validation.Validation{
		{secretName,
			[]validation.Constraint{{"secretName", validation.Pattern, `^[0-9a-zA-Z-]+$`, nil}}},
		{parameters,
			[]validation.Constraint{{"parameters.Value", validation.Null, true, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "SetSecret")
	}

	req, err := client.SetSecretPreparer(secretName, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "SetSecret", nil, "Failure preparing request")
	}

	resp, err := client.SetSecretSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "SetSecret", resp, "Failure sending request")
	}

	result, err = client.SetSecretResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "SetSecret", resp, "Failure responding to request")
	}

	return
}

// SetSecretPreparer prepares the SetSecret request.
func (client KeyVaultClient) SetSecretPreparer(secretName string, parameters SecretSetParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"secret-name": autorest.Encode("path", secretName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/secrets/{secret-name}", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// SetSecretSender sends the SetSecret request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) SetSecretSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// SetSecretResponder handles the response to the SetSecret request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) SetSecretResponder(resp *http.Response) (result SecretBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Sign creates a signature from a digest using the specified key in the vault
//
// keyName is the name of the key keyVersion is the version of the key
// parameters is the parameters for key operations.
func (client KeyVaultClient) Sign(keyName string, keyVersion string, parameters KeySignParameters) (result KeyOperationResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{parameters,
			[]validation.Constraint{{"parameters.Value", validation.Null, true, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "Sign")
	}

	req, err := client.SignPreparer(keyName, keyVersion, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "Sign", nil, "Failure preparing request")
	}

	resp, err := client.SignSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "Sign", resp, "Failure sending request")
	}

	result, err = client.SignResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "Sign", resp, "Failure responding to request")
	}

	return
}

// SignPreparer prepares the Sign request.
func (client KeyVaultClient) SignPreparer(keyName string, keyVersion string, parameters KeySignParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name":    autorest.Encode("path", keyName),
		"key-version": autorest.Encode("path", keyVersion),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}/{key-version}/sign", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// SignSender sends the Sign request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) SignSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// SignResponder handles the response to the Sign request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) SignResponder(resp *http.Response) (result KeyOperationResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UnwrapKey unwraps a symmetric key using the specified key in the vault that
// has initially been used for wrapping the key.
//
// keyName is the name of the key keyVersion is the version of the key
// parameters is the parameters for key operations.
func (client KeyVaultClient) UnwrapKey(keyName string, keyVersion string, parameters KeyOperationsParameters) (result KeyOperationResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{parameters,
			[]validation.Constraint{{"parameters.Value", validation.Null, true, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "UnwrapKey")
	}

	req, err := client.UnwrapKeyPreparer(keyName, keyVersion, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UnwrapKey", nil, "Failure preparing request")
	}

	resp, err := client.UnwrapKeySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UnwrapKey", resp, "Failure sending request")
	}

	result, err = client.UnwrapKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UnwrapKey", resp, "Failure responding to request")
	}

	return
}

// UnwrapKeyPreparer prepares the UnwrapKey request.
func (client KeyVaultClient) UnwrapKeyPreparer(keyName string, keyVersion string, parameters KeyOperationsParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name":    autorest.Encode("path", keyName),
		"key-version": autorest.Encode("path", keyVersion),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}/{key-version}/unwrapkey", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// UnwrapKeySender sends the UnwrapKey request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) UnwrapKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// UnwrapKeyResponder handles the response to the UnwrapKey request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) UnwrapKeyResponder(resp *http.Response) (result KeyOperationResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateCertificate updates the attributes associated with the specified
// certificate
//
// certificateName is the name of the certificate in the given vault
// certificateVersion is the version of the certificate
func (client KeyVaultClient) UpdateCertificate(certificateName string, certificateVersion string, parameters CertificateUpdateParameters) (result CertificateBundle, err error) {
	req, err := client.UpdateCertificatePreparer(certificateName, certificateVersion, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateCertificate", nil, "Failure preparing request")
	}

	resp, err := client.UpdateCertificateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateCertificate", resp, "Failure sending request")
	}

	result, err = client.UpdateCertificateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateCertificate", resp, "Failure responding to request")
	}

	return
}

// UpdateCertificatePreparer prepares the UpdateCertificate request.
func (client KeyVaultClient) UpdateCertificatePreparer(certificateName string, certificateVersion string, parameters CertificateUpdateParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"certificate-name":    autorest.Encode("path", certificateName),
		"certificate-version": autorest.Encode("path", certificateVersion),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/{certificate-name}/{certificate-version}", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// UpdateCertificateSender sends the UpdateCertificate request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) UpdateCertificateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// UpdateCertificateResponder handles the response to the UpdateCertificate request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) UpdateCertificateResponder(resp *http.Response) (result CertificateBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateCertificateIssuer updates the specified certificate issuer.
//
// issuerName is the name of the issuer. parameter is certificate issuer
// update parameter.
func (client KeyVaultClient) UpdateCertificateIssuer(issuerName string, parameter CertificateIssuerUpdateParameters) (result IssuerBundle, err error) {
	req, err := client.UpdateCertificateIssuerPreparer(issuerName, parameter)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateCertificateIssuer", nil, "Failure preparing request")
	}

	resp, err := client.UpdateCertificateIssuerSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateCertificateIssuer", resp, "Failure sending request")
	}

	result, err = client.UpdateCertificateIssuerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateCertificateIssuer", resp, "Failure responding to request")
	}

	return
}

// UpdateCertificateIssuerPreparer prepares the UpdateCertificateIssuer request.
func (client KeyVaultClient) UpdateCertificateIssuerPreparer(issuerName string, parameter CertificateIssuerUpdateParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"issuer-name": autorest.Encode("path", issuerName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/issuers/{issuer-name}", pathParameters),
		autorest.WithJSON(parameter),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// UpdateCertificateIssuerSender sends the UpdateCertificateIssuer request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) UpdateCertificateIssuerSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// UpdateCertificateIssuerResponder handles the response to the UpdateCertificateIssuer request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) UpdateCertificateIssuerResponder(resp *http.Response) (result IssuerBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateCertificateOperation updates a certificate operation.
//
// certificateName is the name of the certificate certificateOperation is the
// certificate operation response.
func (client KeyVaultClient) UpdateCertificateOperation(certificateName string, certificateOperation CertificateOperationUpdateParameter) (result CertificateOperation, err error) {
	req, err := client.UpdateCertificateOperationPreparer(certificateName, certificateOperation)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateCertificateOperation", nil, "Failure preparing request")
	}

	resp, err := client.UpdateCertificateOperationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateCertificateOperation", resp, "Failure sending request")
	}

	result, err = client.UpdateCertificateOperationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateCertificateOperation", resp, "Failure responding to request")
	}

	return
}

// UpdateCertificateOperationPreparer prepares the UpdateCertificateOperation request.
func (client KeyVaultClient) UpdateCertificateOperationPreparer(certificateName string, certificateOperation CertificateOperationUpdateParameter) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"certificate-name": autorest.Encode("path", certificateName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/{certificate-name}/pending", pathParameters),
		autorest.WithJSON(certificateOperation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// UpdateCertificateOperationSender sends the UpdateCertificateOperation request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) UpdateCertificateOperationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// UpdateCertificateOperationResponder handles the response to the UpdateCertificateOperation request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) UpdateCertificateOperationResponder(resp *http.Response) (result CertificateOperation, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateCertificatePolicy updates the policy for a certificate. Set
// appropriate members in the certificatePolicy that must be updated. Leave
// others as null.
//
// certificateName is the name of the certificate in the given vault.
// certificatePolicy is the policy for the certificate.
func (client KeyVaultClient) UpdateCertificatePolicy(certificateName string, certificatePolicy CertificatePolicy) (result CertificatePolicy, err error) {
	if err := validation.Validate([]validation.Validation{
		{certificatePolicy,
			[]validation.Constraint{{"ID", validation.ReadOnly, true, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "UpdateCertificatePolicy")
	}

	req, err := client.UpdateCertificatePolicyPreparer(certificateName, certificatePolicy)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateCertificatePolicy", nil, "Failure preparing request")
	}

	resp, err := client.UpdateCertificatePolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateCertificatePolicy", resp, "Failure sending request")
	}

	result, err = client.UpdateCertificatePolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateCertificatePolicy", resp, "Failure responding to request")
	}

	return
}

// UpdateCertificatePolicyPreparer prepares the UpdateCertificatePolicy request.
func (client KeyVaultClient) UpdateCertificatePolicyPreparer(certificateName string, certificatePolicy CertificatePolicy) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"certificate-name": autorest.Encode("path", certificateName),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/certificates/{certificate-name}/policy", pathParameters),
		autorest.WithJSON(certificatePolicy),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// UpdateCertificatePolicySender sends the UpdateCertificatePolicy request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) UpdateCertificatePolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// UpdateCertificatePolicyResponder handles the response to the UpdateCertificatePolicy request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) UpdateCertificatePolicyResponder(resp *http.Response) (result CertificatePolicy, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateKey updates the Key Attributes associated with the specified key
//
// keyName is the name of the key keyVersion is the version of the key
// parameters is the parameters to update key.
func (client KeyVaultClient) UpdateKey(keyName string, keyVersion string, parameters KeyUpdateParameters) (result KeyBundle, err error) {
	req, err := client.UpdateKeyPreparer(keyName, keyVersion, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateKey", nil, "Failure preparing request")
	}

	resp, err := client.UpdateKeySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateKey", resp, "Failure sending request")
	}

	result, err = client.UpdateKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateKey", resp, "Failure responding to request")
	}

	return
}

// UpdateKeyPreparer prepares the UpdateKey request.
func (client KeyVaultClient) UpdateKeyPreparer(keyName string, keyVersion string, parameters KeyUpdateParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name":    autorest.Encode("path", keyName),
		"key-version": autorest.Encode("path", keyVersion),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}/{key-version}", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// UpdateKeySender sends the UpdateKey request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) UpdateKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// UpdateKeyResponder handles the response to the UpdateKey request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) UpdateKeyResponder(resp *http.Response) (result KeyBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateSecret updates the attributes associated with the specified secret
//
// secretName is the name of the secret in the given vault secretVersion is
// the version of the secret
func (client KeyVaultClient) UpdateSecret(secretName string, secretVersion string, parameters SecretUpdateParameters) (result SecretBundle, err error) {
	req, err := client.UpdateSecretPreparer(secretName, secretVersion, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateSecret", nil, "Failure preparing request")
	}

	resp, err := client.UpdateSecretSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateSecret", resp, "Failure sending request")
	}

	result, err = client.UpdateSecretResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "UpdateSecret", resp, "Failure responding to request")
	}

	return
}

// UpdateSecretPreparer prepares the UpdateSecret request.
func (client KeyVaultClient) UpdateSecretPreparer(secretName string, secretVersion string, parameters SecretUpdateParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"secret-name":    autorest.Encode("path", secretName),
		"secret-version": autorest.Encode("path", secretVersion),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/secrets/{secret-name}/{secret-version}", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// UpdateSecretSender sends the UpdateSecret request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) UpdateSecretSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// UpdateSecretResponder handles the response to the UpdateSecret request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) UpdateSecretResponder(resp *http.Response) (result SecretBundle, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Verify verifies a signature using the specified key
//
// keyName is the name of the key keyVersion is the version of the key
// parameters is the parameters for key operations.
func (client KeyVaultClient) Verify(keyName string, keyVersion string, parameters KeyVerifyParameters) (result KeyVerifyResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{parameters,
			[]validation.Constraint{{"parameters.Digest", validation.Null, true, nil},
				{"parameters.Value", validation.Null, true, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "Verify")
	}

	req, err := client.VerifyPreparer(keyName, keyVersion, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "Verify", nil, "Failure preparing request")
	}

	resp, err := client.VerifySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "Verify", resp, "Failure sending request")
	}

	result, err = client.VerifyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "Verify", resp, "Failure responding to request")
	}

	return
}

// VerifyPreparer prepares the Verify request.
func (client KeyVaultClient) VerifyPreparer(keyName string, keyVersion string, parameters KeyVerifyParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name":    autorest.Encode("path", keyName),
		"key-version": autorest.Encode("path", keyVersion),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}/{key-version}/verify", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// VerifySender sends the Verify request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) VerifySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// VerifyResponder handles the response to the Verify request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) VerifyResponder(resp *http.Response) (result KeyVerifyResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// WrapKey wraps a symmetric key using the specified key
//
// keyName is the name of the key keyVersion is the version of the key
// parameters is the parameters for key operations.
func (client KeyVaultClient) WrapKey(keyName string, keyVersion string, parameters KeyOperationsParameters) (result KeyOperationResult, err error) {
	if err := validation.Validate([]validation.Validation{
		{parameters,
			[]validation.Constraint{{"parameters.Value", validation.Null, true, nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "keyvault.KeyVaultClient", "WrapKey")
	}

	req, err := client.WrapKeyPreparer(keyName, keyVersion, parameters)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "WrapKey", nil, "Failure preparing request")
	}

	resp, err := client.WrapKeySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "WrapKey", resp, "Failure sending request")
	}

	result, err = client.WrapKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "keyvault.KeyVaultClient", "WrapKey", resp, "Failure responding to request")
	}

	return
}

// WrapKeyPreparer prepares the WrapKey request.
func (client KeyVaultClient) WrapKeyPreparer(keyName string, keyVersion string, parameters KeyOperationsParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"key-name":    autorest.Encode("path", keyName),
		"key-version": autorest.Encode("path", keyVersion),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/keys/{key-name}/{key-version}/wrapkey", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// WrapKeySender sends the WrapKey request. The method will close the
// http.Response Body if it receives an error.
func (client KeyVaultClient) WrapKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// WrapKeyResponder handles the response to the WrapKey request. The method always
// closes the http.Response Body.
func (client KeyVaultClient) WrapKeyResponder(resp *http.Response) (result KeyOperationResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
