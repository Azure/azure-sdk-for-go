//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package azacr

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AccessToken.
func (a AccessToken) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "access_token", a.AccessToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessToken.
func (a *AccessToken) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "access_token":
			err = unpopulate(val, "AccessToken", &a.AccessToken)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Annotations.
func (a Annotations) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "org.opencontainers.image.authors", a.Authors)
	populateTimeRFC3339(objectMap, "org.opencontainers.image.created", a.Created)
	populate(objectMap, "org.opencontainers.image.description", a.Description)
	populate(objectMap, "org.opencontainers.image.documentation", a.Documentation)
	populate(objectMap, "org.opencontainers.image.licenses", a.Licenses)
	populate(objectMap, "org.opencontainers.image.ref.name", a.Name)
	populate(objectMap, "org.opencontainers.image.revision", a.Revision)
	populate(objectMap, "org.opencontainers.image.source", a.Source)
	populate(objectMap, "org.opencontainers.image.title", a.Title)
	populate(objectMap, "org.opencontainers.image.url", a.URL)
	populate(objectMap, "org.opencontainers.image.vendor", a.Vendor)
	populate(objectMap, "org.opencontainers.image.version", a.Version)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Annotations.
func (a *Annotations) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "org.opencontainers.image.authors":
			err = unpopulate(val, "Authors", &a.Authors)
			delete(rawMsg, key)
		case "org.opencontainers.image.created":
			err = unpopulateTimeRFC3339(val, "Created", &a.Created)
			delete(rawMsg, key)
		case "org.opencontainers.image.description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "org.opencontainers.image.documentation":
			err = unpopulate(val, "Documentation", &a.Documentation)
			delete(rawMsg, key)
		case "org.opencontainers.image.licenses":
			err = unpopulate(val, "Licenses", &a.Licenses)
			delete(rawMsg, key)
		case "org.opencontainers.image.ref.name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "org.opencontainers.image.revision":
			err = unpopulate(val, "Revision", &a.Revision)
			delete(rawMsg, key)
		case "org.opencontainers.image.source":
			err = unpopulate(val, "Source", &a.Source)
			delete(rawMsg, key)
		case "org.opencontainers.image.title":
			err = unpopulate(val, "Title", &a.Title)
			delete(rawMsg, key)
		case "org.opencontainers.image.url":
			err = unpopulate(val, "URL", &a.URL)
			delete(rawMsg, key)
		case "org.opencontainers.image.vendor":
			err = unpopulate(val, "Vendor", &a.Vendor)
			delete(rawMsg, key)
		case "org.opencontainers.image.version":
			err = unpopulate(val, "Version", &a.Version)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArtifactManifestPlatform.
func (a ArtifactManifestPlatform) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "architecture", a.Architecture)
	populate(objectMap, "digest", a.Digest)
	populate(objectMap, "os", a.OperatingSystem)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArtifactManifestPlatform.
func (a *ArtifactManifestPlatform) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "architecture":
			err = unpopulate(val, "Architecture", &a.Architecture)
			delete(rawMsg, key)
		case "digest":
			err = unpopulate(val, "Digest", &a.Digest)
			delete(rawMsg, key)
		case "os":
			err = unpopulate(val, "OperatingSystem", &a.OperatingSystem)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArtifactManifestProperties.
func (a ArtifactManifestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "manifest", a.Manifest)
	populate(objectMap, "registry", a.RegistryLoginServer)
	populate(objectMap, "imageName", a.RepositoryName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArtifactManifestProperties.
func (a *ArtifactManifestProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "manifest":
			err = unpopulate(val, "Manifest", &a.Manifest)
			delete(rawMsg, key)
		case "registry":
			err = unpopulate(val, "RegistryLoginServer", &a.RegistryLoginServer)
			delete(rawMsg, key)
		case "imageName":
			err = unpopulate(val, "RepositoryName", &a.RepositoryName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArtifactTagProperties.
func (a ArtifactTagProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "registry", a.RegistryLoginServer)
	populate(objectMap, "imageName", a.RepositoryName)
	populate(objectMap, "tag", a.Tag)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArtifactTagProperties.
func (a *ArtifactTagProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "registry":
			err = unpopulate(val, "RegistryLoginServer", &a.RegistryLoginServer)
			delete(rawMsg, key)
		case "imageName":
			err = unpopulate(val, "RepositoryName", &a.RepositoryName)
			delete(rawMsg, key)
		case "tag":
			err = unpopulate(val, "Tag", &a.Tag)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerRepositoryProperties.
func (c ContainerRepositoryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "changeableAttributes", c.ChangeableAttributes)
	populateTimeRFC3339(objectMap, "createdTime", c.CreatedOn)
	populateTimeRFC3339(objectMap, "lastUpdateTime", c.LastUpdatedOn)
	populate(objectMap, "manifestCount", c.ManifestCount)
	populate(objectMap, "imageName", c.Name)
	populate(objectMap, "registry", c.RegistryLoginServer)
	populate(objectMap, "tagCount", c.TagCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerRepositoryProperties.
func (c *ContainerRepositoryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "changeableAttributes":
			err = unpopulate(val, "ChangeableAttributes", &c.ChangeableAttributes)
			delete(rawMsg, key)
		case "createdTime":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &c.CreatedOn)
			delete(rawMsg, key)
		case "lastUpdateTime":
			err = unpopulateTimeRFC3339(val, "LastUpdatedOn", &c.LastUpdatedOn)
			delete(rawMsg, key)
		case "manifestCount":
			err = unpopulate(val, "ManifestCount", &c.ManifestCount)
			delete(rawMsg, key)
		case "imageName":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "registry":
			err = unpopulate(val, "RegistryLoginServer", &c.RegistryLoginServer)
			delete(rawMsg, key)
		case "tagCount":
			err = unpopulate(val, "TagCount", &c.TagCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeleteRepositoryResult.
func (d DeleteRepositoryResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "manifestsDeleted", d.DeletedManifests)
	populate(objectMap, "tagsDeleted", d.DeletedTags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeleteRepositoryResult.
func (d *DeleteRepositoryResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "manifestsDeleted":
			err = unpopulate(val, "DeletedManifests", &d.DeletedManifests)
			delete(rawMsg, key)
		case "tagsDeleted":
			err = unpopulate(val, "DeletedTags", &d.DeletedTags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Descriptor.
func (d Descriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", d.Annotations)
	populate(objectMap, "digest", d.Digest)
	populate(objectMap, "mediaType", d.MediaType)
	populate(objectMap, "size", d.Size)
	populate(objectMap, "urls", d.Urls)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Descriptor.
func (d *Descriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &d.Annotations)
			delete(rawMsg, key)
		case "digest":
			err = unpopulate(val, "Digest", &d.Digest)
			delete(rawMsg, key)
		case "mediaType":
			err = unpopulate(val, "MediaType", &d.MediaType)
			delete(rawMsg, key)
		case "size":
			err = unpopulate(val, "Size", &d.Size)
			delete(rawMsg, key)
		case "urls":
			err = unpopulate(val, "Urls", &d.Urls)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorInfo.
func (e ErrorInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "detail", &e.Detail)
	populate(objectMap, "message", e.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorInfo.
func (e *ErrorInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "detail":
			err = unpopulate(val, "Detail", &e.Detail)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Errors.
func (e Errors) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errors", e.Errors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Errors.
func (e *Errors) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
			err = unpopulate(val, "Errors", &e.Errors)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FsLayer.
func (f FsLayer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blobSum", f.BlobSum)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FsLayer.
func (f *FsLayer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobSum":
			err = unpopulate(val, "BlobSum", &f.BlobSum)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type History.
func (h History) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "v1Compatibility", h.V1Compatibility)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type History.
func (h *History) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "v1Compatibility":
			err = unpopulate(val, "V1Compatibility", &h.V1Compatibility)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageSignature.
func (i ImageSignature) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "header", i.Header)
	populate(objectMap, "protected", i.Protected)
	populate(objectMap, "signature", i.Signature)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageSignature.
func (i *ImageSignature) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "header":
			err = unpopulate(val, "Header", &i.Header)
			delete(rawMsg, key)
		case "protected":
			err = unpopulate(val, "Protected", &i.Protected)
			delete(rawMsg, key)
		case "signature":
			err = unpopulate(val, "Signature", &i.Signature)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JWK.
func (j JWK) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alg", j.Alg)
	populate(objectMap, "jwk", j.Jwk)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JWK.
func (j *JWK) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alg":
			err = unpopulate(val, "Alg", &j.Alg)
			delete(rawMsg, key)
		case "jwk":
			err = unpopulate(val, "Jwk", &j.Jwk)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JWKHeader.
func (j JWKHeader) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "crv", j.Crv)
	populate(objectMap, "kid", j.Kid)
	populate(objectMap, "kty", j.Kty)
	populate(objectMap, "x", j.X)
	populate(objectMap, "y", j.Y)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JWKHeader.
func (j *JWKHeader) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "crv":
			err = unpopulate(val, "Crv", &j.Crv)
			delete(rawMsg, key)
		case "kid":
			err = unpopulate(val, "Kid", &j.Kid)
			delete(rawMsg, key)
		case "kty":
			err = unpopulate(val, "Kty", &j.Kty)
			delete(rawMsg, key)
		case "x":
			err = unpopulate(val, "X", &j.X)
			delete(rawMsg, key)
		case "y":
			err = unpopulate(val, "Y", &j.Y)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Manifest.
func (m Manifest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "schemaVersion", m.SchemaVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Manifest.
func (m *Manifest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schemaVersion":
			err = unpopulate(val, "SchemaVersion", &m.SchemaVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManifestAttributesBase.
func (m ManifestAttributesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "architecture", m.Architecture)
	populate(objectMap, "changeableAttributes", m.ChangeableAttributes)
	populateTimeRFC3339(objectMap, "createdTime", m.CreatedOn)
	populate(objectMap, "digest", m.Digest)
	populateTimeRFC3339(objectMap, "lastUpdateTime", m.LastUpdatedOn)
	populate(objectMap, "os", m.OperatingSystem)
	populate(objectMap, "references", m.RelatedArtifacts)
	populate(objectMap, "imageSize", m.Size)
	populate(objectMap, "tags", m.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManifestAttributesBase.
func (m *ManifestAttributesBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "architecture":
			err = unpopulate(val, "Architecture", &m.Architecture)
			delete(rawMsg, key)
		case "changeableAttributes":
			err = unpopulate(val, "ChangeableAttributes", &m.ChangeableAttributes)
			delete(rawMsg, key)
		case "createdTime":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &m.CreatedOn)
			delete(rawMsg, key)
		case "digest":
			err = unpopulate(val, "Digest", &m.Digest)
			delete(rawMsg, key)
		case "lastUpdateTime":
			err = unpopulateTimeRFC3339(val, "LastUpdatedOn", &m.LastUpdatedOn)
			delete(rawMsg, key)
		case "os":
			err = unpopulate(val, "OperatingSystem", &m.OperatingSystem)
			delete(rawMsg, key)
		case "references":
			err = unpopulate(val, "RelatedArtifacts", &m.RelatedArtifacts)
			delete(rawMsg, key)
		case "imageSize":
			err = unpopulate(val, "Size", &m.Size)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &m.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManifestAttributesManifest.
func (m ManifestAttributesManifest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "references", m.References)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManifestAttributesManifest.
func (m *ManifestAttributesManifest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "references":
			err = unpopulate(val, "References", &m.References)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManifestList.
func (m ManifestList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "manifests", m.Manifests)
	populate(objectMap, "mediaType", m.MediaType)
	populate(objectMap, "schemaVersion", m.SchemaVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManifestList.
func (m *ManifestList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "manifests":
			err = unpopulate(val, "Manifests", &m.Manifests)
			delete(rawMsg, key)
		case "mediaType":
			err = unpopulate(val, "MediaType", &m.MediaType)
			delete(rawMsg, key)
		case "schemaVersion":
			err = unpopulate(val, "SchemaVersion", &m.SchemaVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManifestListAttributes.
func (m ManifestListAttributes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "digest", m.Digest)
	populate(objectMap, "mediaType", m.MediaType)
	populate(objectMap, "platform", m.Platform)
	populate(objectMap, "size", m.Size)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManifestListAttributes.
func (m *ManifestListAttributes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "digest":
			err = unpopulate(val, "Digest", &m.Digest)
			delete(rawMsg, key)
		case "mediaType":
			err = unpopulate(val, "MediaType", &m.MediaType)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, "Platform", &m.Platform)
			delete(rawMsg, key)
		case "size":
			err = unpopulate(val, "Size", &m.Size)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManifestWrapper.
func (m ManifestWrapper) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", m.Annotations)
	populate(objectMap, "architecture", m.Architecture)
	populate(objectMap, "config", m.Config)
	populate(objectMap, "fsLayers", m.FsLayers)
	populate(objectMap, "history", m.History)
	populate(objectMap, "layers", m.Layers)
	populate(objectMap, "manifests", m.Manifests)
	populate(objectMap, "mediaType", m.MediaType)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "schemaVersion", m.SchemaVersion)
	populate(objectMap, "signatures", m.Signatures)
	populate(objectMap, "tag", m.Tag)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManifestWrapper.
func (m *ManifestWrapper) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &m.Annotations)
			delete(rawMsg, key)
		case "architecture":
			err = unpopulate(val, "Architecture", &m.Architecture)
			delete(rawMsg, key)
		case "config":
			err = unpopulate(val, "Config", &m.Config)
			delete(rawMsg, key)
		case "fsLayers":
			err = unpopulate(val, "FsLayers", &m.FsLayers)
			delete(rawMsg, key)
		case "history":
			err = unpopulate(val, "History", &m.History)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, "Layers", &m.Layers)
			delete(rawMsg, key)
		case "manifests":
			err = unpopulate(val, "Manifests", &m.Manifests)
			delete(rawMsg, key)
		case "mediaType":
			err = unpopulate(val, "MediaType", &m.MediaType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "schemaVersion":
			err = unpopulate(val, "SchemaVersion", &m.SchemaVersion)
			delete(rawMsg, key)
		case "signatures":
			err = unpopulate(val, "Signatures", &m.Signatures)
			delete(rawMsg, key)
		case "tag":
			err = unpopulate(val, "Tag", &m.Tag)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManifestWriteableProperties.
func (m ManifestWriteableProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deleteEnabled", m.CanDelete)
	populate(objectMap, "listEnabled", m.CanList)
	populate(objectMap, "readEnabled", m.CanRead)
	populate(objectMap, "writeEnabled", m.CanWrite)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManifestWriteableProperties.
func (m *ManifestWriteableProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteEnabled":
			err = unpopulate(val, "CanDelete", &m.CanDelete)
			delete(rawMsg, key)
		case "listEnabled":
			err = unpopulate(val, "CanList", &m.CanList)
			delete(rawMsg, key)
		case "readEnabled":
			err = unpopulate(val, "CanRead", &m.CanRead)
			delete(rawMsg, key)
		case "writeEnabled":
			err = unpopulate(val, "CanWrite", &m.CanWrite)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Manifests.
func (m Manifests) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "link", m.Link)
	populate(objectMap, "manifests", m.Manifests)
	populate(objectMap, "registry", m.RegistryLoginServer)
	populate(objectMap, "imageName", m.Repository)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Manifests.
func (m *Manifests) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "link":
			err = unpopulate(val, "Link", &m.Link)
			delete(rawMsg, key)
		case "manifests":
			err = unpopulate(val, "Manifests", &m.Manifests)
			delete(rawMsg, key)
		case "registry":
			err = unpopulate(val, "RegistryLoginServer", &m.RegistryLoginServer)
			delete(rawMsg, key)
		case "imageName":
			err = unpopulate(val, "Repository", &m.Repository)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OCIIndex.
func (o OCIIndex) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "manifests", o.Manifests)
	populate(objectMap, "schemaVersion", o.SchemaVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OCIIndex.
func (o *OCIIndex) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "manifests":
			err = unpopulate(val, "Manifests", &o.Manifests)
			delete(rawMsg, key)
		case "schemaVersion":
			err = unpopulate(val, "SchemaVersion", &o.SchemaVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OCIManifest.
func (o OCIManifest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", o.Annotations)
	populate(objectMap, "config", o.Config)
	populate(objectMap, "layers", o.Layers)
	populate(objectMap, "schemaVersion", o.SchemaVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OCIManifest.
func (o *OCIManifest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "config":
			err = unpopulate(val, "Config", &o.Config)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, "Layers", &o.Layers)
			delete(rawMsg, key)
		case "schemaVersion":
			err = unpopulate(val, "SchemaVersion", &o.SchemaVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema.
func (p Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "access_token", p.AADAccessToken)
	populate(objectMap, "grant_type", p.GrantType)
	populate(objectMap, "refresh_token", p.RefreshToken)
	populate(objectMap, "service", p.Service)
	populate(objectMap, "tenant", p.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema.
func (p *Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "access_token":
			err = unpopulate(val, "AADAccessToken", &p.AADAccessToken)
			delete(rawMsg, key)
		case "grant_type":
			err = unpopulate(val, "GrantType", &p.GrantType)
			delete(rawMsg, key)
		case "refresh_token":
			err = unpopulate(val, "RefreshToken", &p.RefreshToken)
			delete(rawMsg, key)
		case "service":
			err = unpopulate(val, "Service", &p.Service)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, "Tenant", &p.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema.
func (p PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "refresh_token", p.AcrRefreshToken)
	if p.GrantType == nil {
		p.GrantType = to.Ptr(TokenGrantTypeRefreshToken)
	}
	populate(objectMap, "grant_type", p.GrantType)
	populate(objectMap, "scope", p.Scope)
	populate(objectMap, "service", p.Service)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema.
func (p *PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "refresh_token":
			err = unpopulate(val, "AcrRefreshToken", &p.AcrRefreshToken)
			delete(rawMsg, key)
		case "grant_type":
			err = unpopulate(val, "GrantType", &p.GrantType)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, "Scope", &p.Scope)
			delete(rawMsg, key)
		case "service":
			err = unpopulate(val, "Service", &p.Service)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Platform.
func (p Platform) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "architecture", p.Architecture)
	populate(objectMap, "features", p.Features)
	populate(objectMap, "os", p.OS)
	populate(objectMap, "os.features", p.OSFeatures)
	populate(objectMap, "os.version", p.OSVersion)
	populate(objectMap, "variant", p.Variant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Platform.
func (p *Platform) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "architecture":
			err = unpopulate(val, "Architecture", &p.Architecture)
			delete(rawMsg, key)
		case "features":
			err = unpopulate(val, "Features", &p.Features)
			delete(rawMsg, key)
		case "os":
			err = unpopulate(val, "OS", &p.OS)
			delete(rawMsg, key)
		case "os.features":
			err = unpopulate(val, "OSFeatures", &p.OSFeatures)
			delete(rawMsg, key)
		case "os.version":
			err = unpopulate(val, "OSVersion", &p.OSVersion)
			delete(rawMsg, key)
		case "variant":
			err = unpopulate(val, "Variant", &p.Variant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RefreshToken.
func (r RefreshToken) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "refresh_token", r.RefreshToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RefreshToken.
func (r *RefreshToken) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "refresh_token":
			err = unpopulate(val, "RefreshToken", &r.RefreshToken)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Repositories.
func (r Repositories) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "link", r.Link)
	populate(objectMap, "repositories", r.Repositories)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Repositories.
func (r *Repositories) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "link":
			err = unpopulate(val, "Link", &r.Link)
			delete(rawMsg, key)
		case "repositories":
			err = unpopulate(val, "Repositories", &r.Repositories)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RepositoryTags.
func (r RepositoryTags) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RepositoryTags.
func (r *RepositoryTags) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &r.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RepositoryWriteableProperties.
func (r RepositoryWriteableProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deleteEnabled", r.CanDelete)
	populate(objectMap, "listEnabled", r.CanList)
	populate(objectMap, "readEnabled", r.CanRead)
	populate(objectMap, "writeEnabled", r.CanWrite)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RepositoryWriteableProperties.
func (r *RepositoryWriteableProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteEnabled":
			err = unpopulate(val, "CanDelete", &r.CanDelete)
			delete(rawMsg, key)
		case "listEnabled":
			err = unpopulate(val, "CanList", &r.CanList)
			delete(rawMsg, key)
		case "readEnabled":
			err = unpopulate(val, "CanRead", &r.CanRead)
			delete(rawMsg, key)
		case "writeEnabled":
			err = unpopulate(val, "CanWrite", &r.CanWrite)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TagAttributesBase.
func (t TagAttributesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "changeableAttributes", t.ChangeableAttributes)
	populateTimeRFC3339(objectMap, "createdTime", t.CreatedOn)
	populate(objectMap, "digest", t.Digest)
	populateTimeRFC3339(objectMap, "lastUpdateTime", t.LastUpdatedOn)
	populate(objectMap, "name", t.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TagAttributesBase.
func (t *TagAttributesBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "changeableAttributes":
			err = unpopulate(val, "ChangeableAttributes", &t.ChangeableAttributes)
			delete(rawMsg, key)
		case "createdTime":
			err = unpopulateTimeRFC3339(val, "CreatedOn", &t.CreatedOn)
			delete(rawMsg, key)
		case "digest":
			err = unpopulate(val, "Digest", &t.Digest)
			delete(rawMsg, key)
		case "lastUpdateTime":
			err = unpopulateTimeRFC3339(val, "LastUpdatedOn", &t.LastUpdatedOn)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TagAttributesTag.
func (t TagAttributesTag) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "signatureRecord", t.SignatureRecord)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TagAttributesTag.
func (t *TagAttributesTag) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "signatureRecord":
			err = unpopulate(val, "SignatureRecord", &t.SignatureRecord)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TagList.
func (t TagList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "link", t.Link)
	populate(objectMap, "registry", t.RegistryLoginServer)
	populate(objectMap, "imageName", t.Repository)
	populate(objectMap, "tags", t.TagAttributeBases)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TagList.
func (t *TagList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "link":
			err = unpopulate(val, "Link", &t.Link)
			delete(rawMsg, key)
		case "registry":
			err = unpopulate(val, "RegistryLoginServer", &t.RegistryLoginServer)
			delete(rawMsg, key)
		case "imageName":
			err = unpopulate(val, "Repository", &t.Repository)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "TagAttributeBases", &t.TagAttributeBases)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TagWriteableProperties.
func (t TagWriteableProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deleteEnabled", t.CanDelete)
	populate(objectMap, "listEnabled", t.CanList)
	populate(objectMap, "readEnabled", t.CanRead)
	populate(objectMap, "writeEnabled", t.CanWrite)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TagWriteableProperties.
func (t *TagWriteableProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteEnabled":
			err = unpopulate(val, "CanDelete", &t.CanDelete)
			delete(rawMsg, key)
		case "listEnabled":
			err = unpopulate(val, "CanList", &t.CanList)
			delete(rawMsg, key)
		case "readEnabled":
			err = unpopulate(val, "CanRead", &t.CanRead)
			delete(rawMsg, key)
		case "writeEnabled":
			err = unpopulate(val, "CanWrite", &t.CanWrite)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type V1Manifest.
func (v V1Manifest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "architecture", v.Architecture)
	populate(objectMap, "fsLayers", v.FsLayers)
	populate(objectMap, "history", v.History)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "schemaVersion", v.SchemaVersion)
	populate(objectMap, "signatures", v.Signatures)
	populate(objectMap, "tag", v.Tag)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type V1Manifest.
func (v *V1Manifest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "architecture":
			err = unpopulate(val, "Architecture", &v.Architecture)
			delete(rawMsg, key)
		case "fsLayers":
			err = unpopulate(val, "FsLayers", &v.FsLayers)
			delete(rawMsg, key)
		case "history":
			err = unpopulate(val, "History", &v.History)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "schemaVersion":
			err = unpopulate(val, "SchemaVersion", &v.SchemaVersion)
			delete(rawMsg, key)
		case "signatures":
			err = unpopulate(val, "Signatures", &v.Signatures)
			delete(rawMsg, key)
		case "tag":
			err = unpopulate(val, "Tag", &v.Tag)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type V2Manifest.
func (v V2Manifest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "config", v.Config)
	populate(objectMap, "layers", v.Layers)
	populate(objectMap, "mediaType", v.MediaType)
	populate(objectMap, "schemaVersion", v.SchemaVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type V2Manifest.
func (v *V2Manifest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "config":
			err = unpopulate(val, "Config", &v.Config)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, "Layers", &v.Layers)
			delete(rawMsg, key)
		case "mediaType":
			err = unpopulate(val, "MediaType", &v.MediaType)
			delete(rawMsg, key)
		case "schemaVersion":
			err = unpopulate(val, "SchemaVersion", &v.SchemaVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
