//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azopenai

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// MarshalJSON implements the json.Marshaller interface for type AudioTranscription.
func (a AudioTranscription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "duration", a.Duration)
	populate(objectMap, "language", a.Language)
	populate(objectMap, "segments", a.Segments)
	populate(objectMap, "task", a.Task)
	populate(objectMap, "text", a.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioTranscription.
func (a *AudioTranscription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
			err = unpopulate(val, "Duration", &a.Duration)
			delete(rawMsg, key)
		case "language":
			err = unpopulate(val, "Language", &a.Language)
			delete(rawMsg, key)
		case "segments":
			err = unpopulate(val, "Segments", &a.Segments)
			delete(rawMsg, key)
		case "task":
			err = unpopulate(val, "Task", &a.Task)
			delete(rawMsg, key)
		case "text":
			err = unpopulate(val, "Text", &a.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AudioTranscriptionOptions.
func (a AudioTranscriptionOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateByteArray(objectMap, "file", a.File, runtime.Base64StdFormat)
	populate(objectMap, "language", a.Language)
	populate(objectMap, "model", &a.Deployment)
	populate(objectMap, "prompt", a.Prompt)
	populate(objectMap, "response_format", a.ResponseFormat)
	populate(objectMap, "temperature", a.Temperature)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioTranscriptionOptions.
func (a *AudioTranscriptionOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "file":
			err = runtime.DecodeByteArray(string(val), &a.File, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "language":
			err = unpopulate(val, "Language", &a.Language)
			delete(rawMsg, key)
		case "model":
			err = unpopulate(val, "Model", &a.Deployment)
			delete(rawMsg, key)
		case "prompt":
			err = unpopulate(val, "Prompt", &a.Prompt)
			delete(rawMsg, key)
		case "response_format":
			err = unpopulate(val, "ResponseFormat", &a.ResponseFormat)
			delete(rawMsg, key)
		case "temperature":
			err = unpopulate(val, "Temperature", &a.Temperature)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AudioTranscriptionSegment.
func (a AudioTranscriptionSegment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "avg_logprob", a.AvgLogProb)
	populate(objectMap, "compression_ratio", a.CompressionRatio)
	populate(objectMap, "end", a.End)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "no_speech_prob", a.NoSpeechProb)
	populate(objectMap, "seek", a.Seek)
	populate(objectMap, "start", a.Start)
	populate(objectMap, "temperature", a.Temperature)
	populate(objectMap, "text", a.Text)
	populate(objectMap, "tokens", a.Tokens)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioTranscriptionSegment.
func (a *AudioTranscriptionSegment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avg_logprob":
			err = unpopulate(val, "AvgLogprob", &a.AvgLogProb)
			delete(rawMsg, key)
		case "compression_ratio":
			err = unpopulate(val, "CompressionRatio", &a.CompressionRatio)
			delete(rawMsg, key)
		case "end":
			err = unpopulate(val, "End", &a.End)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "no_speech_prob":
			err = unpopulate(val, "NoSpeechProb", &a.NoSpeechProb)
			delete(rawMsg, key)
		case "seek":
			err = unpopulate(val, "Seek", &a.Seek)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, "Start", &a.Start)
			delete(rawMsg, key)
		case "temperature":
			err = unpopulate(val, "Temperature", &a.Temperature)
			delete(rawMsg, key)
		case "text":
			err = unpopulate(val, "Text", &a.Text)
			delete(rawMsg, key)
		case "tokens":
			err = unpopulate(val, "Tokens", &a.Tokens)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AudioTranslation.
func (a AudioTranslation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "duration", a.Duration)
	populate(objectMap, "language", a.Language)
	populate(objectMap, "segments", a.Segments)
	populate(objectMap, "task", a.Task)
	populate(objectMap, "text", a.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioTranslation.
func (a *AudioTranslation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
			err = unpopulate(val, "Duration", &a.Duration)
			delete(rawMsg, key)
		case "language":
			err = unpopulate(val, "Language", &a.Language)
			delete(rawMsg, key)
		case "segments":
			err = unpopulate(val, "Segments", &a.Segments)
			delete(rawMsg, key)
		case "task":
			err = unpopulate(val, "Task", &a.Task)
			delete(rawMsg, key)
		case "text":
			err = unpopulate(val, "Text", &a.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AudioTranslationOptions.
func (a AudioTranslationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateByteArray(objectMap, "file", a.File, runtime.Base64StdFormat)
	populate(objectMap, "model", &a.Deployment)
	populate(objectMap, "prompt", a.Prompt)
	populate(objectMap, "response_format", a.ResponseFormat)
	populate(objectMap, "temperature", a.Temperature)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioTranslationOptions.
func (a *AudioTranslationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "file":
			err = runtime.DecodeByteArray(string(val), &a.File, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "model":
			err = unpopulate(val, "Model", &a.Deployment)
			delete(rawMsg, key)
		case "prompt":
			err = unpopulate(val, "Prompt", &a.Prompt)
			delete(rawMsg, key)
		case "response_format":
			err = unpopulate(val, "ResponseFormat", &a.ResponseFormat)
			delete(rawMsg, key)
		case "temperature":
			err = unpopulate(val, "Temperature", &a.Temperature)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AudioTranslationSegment.
func (a AudioTranslationSegment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "avg_logprob", a.AvgLogProb)
	populate(objectMap, "compression_ratio", a.CompressionRatio)
	populate(objectMap, "end", a.End)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "no_speech_prob", a.NoSpeechProb)
	populate(objectMap, "seek", a.Seek)
	populate(objectMap, "start", a.Start)
	populate(objectMap, "temperature", a.Temperature)
	populate(objectMap, "text", a.Text)
	populate(objectMap, "tokens", a.Tokens)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioTranslationSegment.
func (a *AudioTranslationSegment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avg_logprob":
			err = unpopulate(val, "AvgLogprob", &a.AvgLogProb)
			delete(rawMsg, key)
		case "compression_ratio":
			err = unpopulate(val, "CompressionRatio", &a.CompressionRatio)
			delete(rawMsg, key)
		case "end":
			err = unpopulate(val, "End", &a.End)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "no_speech_prob":
			err = unpopulate(val, "NoSpeechProb", &a.NoSpeechProb)
			delete(rawMsg, key)
		case "seek":
			err = unpopulate(val, "Seek", &a.Seek)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, "Start", &a.Start)
			delete(rawMsg, key)
		case "temperature":
			err = unpopulate(val, "Temperature", &a.Temperature)
			delete(rawMsg, key)
		case "text":
			err = unpopulate(val, "Text", &a.Text)
			delete(rawMsg, key)
		case "tokens":
			err = unpopulate(val, "Tokens", &a.Tokens)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureChatExtensionConfiguration.
func (a AzureChatExtensionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "parameters", a.Parameters)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureChatExtensionConfiguration.
func (a *AzureChatExtensionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureChatExtensionsMessageContext.
func (a AzureChatExtensionsMessageContext) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "messages", a.Messages)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureChatExtensionsMessageContext.
func (a *AzureChatExtensionsMessageContext) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "messages":
			err = unpopulate(val, "Messages", &a.Messages)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureCognitiveSearchChatExtensionConfiguration.
func (a AzureCognitiveSearchChatExtensionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "embeddingEndpoint", a.EmbeddingEndpoint)
	populate(objectMap, "embeddingKey", a.EmbeddingKey)
	populate(objectMap, "endpoint", a.Endpoint)
	populate(objectMap, "fieldsMapping", a.FieldsMapping)
	populate(objectMap, "inScope", a.InScope)
	populate(objectMap, "indexName", a.IndexName)
	populate(objectMap, "key", a.Key)
	populate(objectMap, "queryType", a.QueryType)
	populate(objectMap, "semanticConfiguration", a.SemanticConfiguration)
	populate(objectMap, "topNDocuments", a.TopNDocuments)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureCognitiveSearchChatExtensionConfiguration.
func (a *AzureCognitiveSearchChatExtensionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "embeddingEndpoint":
			err = unpopulate(val, "EmbeddingEndpoint", &a.EmbeddingEndpoint)
			delete(rawMsg, key)
		case "embeddingKey":
			err = unpopulate(val, "EmbeddingKey", &a.EmbeddingKey)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &a.Endpoint)
			delete(rawMsg, key)
		case "fieldsMapping":
			err = unpopulate(val, "FieldsMapping", &a.FieldsMapping)
			delete(rawMsg, key)
		case "inScope":
			err = unpopulate(val, "InScope", &a.InScope)
			delete(rawMsg, key)
		case "indexName":
			err = unpopulate(val, "IndexName", &a.IndexName)
			delete(rawMsg, key)
		case "key":
			err = unpopulate(val, "Key", &a.Key)
			delete(rawMsg, key)
		case "queryType":
			err = unpopulate(val, "QueryType", &a.QueryType)
			delete(rawMsg, key)
		case "semanticConfiguration":
			err = unpopulate(val, "SemanticConfiguration", &a.SemanticConfiguration)
			delete(rawMsg, key)
		case "topNDocuments":
			err = unpopulate(val, "TopNDocuments", &a.TopNDocuments)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureCognitiveSearchChatExtensionConfigurationFieldsMapping.
func (a AzureCognitiveSearchChatExtensionConfigurationFieldsMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contentFieldNames", a.ContentFieldNames)
	populate(objectMap, "contentFieldSeparator", a.ContentFieldSeparator)
	populate(objectMap, "filepathField", a.FilepathField)
	populate(objectMap, "titleField", a.TitleField)
	populate(objectMap, "urlField", a.URLField)
	populate(objectMap, "vectorFields", a.VectorFields)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureCognitiveSearchChatExtensionConfigurationFieldsMapping.
func (a *AzureCognitiveSearchChatExtensionConfigurationFieldsMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentFieldNames":
			err = unpopulate(val, "ContentFieldNames", &a.ContentFieldNames)
			delete(rawMsg, key)
		case "contentFieldSeparator":
			err = unpopulate(val, "ContentFieldSeparator", &a.ContentFieldSeparator)
			delete(rawMsg, key)
		case "filepathField":
			err = unpopulate(val, "FilepathField", &a.FilepathField)
			delete(rawMsg, key)
		case "titleField":
			err = unpopulate(val, "TitleField", &a.TitleField)
			delete(rawMsg, key)
		case "urlField":
			err = unpopulate(val, "URLField", &a.URLField)
			delete(rawMsg, key)
		case "vectorFields":
			err = unpopulate(val, "VectorFields", &a.VectorFields)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureCognitiveSearchIndexFieldMappingOptions.
func (a AzureCognitiveSearchIndexFieldMappingOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contentFieldNames", a.ContentFieldNames)
	populate(objectMap, "contentFieldSeparator", a.ContentFieldSeparator)
	populate(objectMap, "filepathField", a.FilepathField)
	populate(objectMap, "titleField", a.TitleField)
	populate(objectMap, "urlField", a.URLField)
	populate(objectMap, "vectorFields", a.VectorFields)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureCognitiveSearchIndexFieldMappingOptions.
func (a *AzureCognitiveSearchIndexFieldMappingOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentFieldNames":
			err = unpopulate(val, "ContentFieldNames", &a.ContentFieldNames)
			delete(rawMsg, key)
		case "contentFieldSeparator":
			err = unpopulate(val, "ContentFieldSeparator", &a.ContentFieldSeparator)
			delete(rawMsg, key)
		case "filepathField":
			err = unpopulate(val, "FilepathField", &a.FilepathField)
			delete(rawMsg, key)
		case "titleField":
			err = unpopulate(val, "TitleField", &a.TitleField)
			delete(rawMsg, key)
		case "urlField":
			err = unpopulate(val, "URLField", &a.URLField)
			delete(rawMsg, key)
		case "vectorFields":
			err = unpopulate(val, "VectorFields", &a.VectorFields)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Error.
func (a Error) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", a.Code)
	populate(objectMap, "details", a.Details)
	populate(objectMap, "innererror", a.InnerError)
	populate(objectMap, "message", a.Message)
	populate(objectMap, "target", a.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Error.
func (a *Error) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &a.Code)
			delete(rawMsg, key)
		case "details":
			err = unpopulate(val, "Details", &a.Details)
			delete(rawMsg, key)
		case "innererror":
			err = unpopulate(val, "Innererror", &a.InnerError)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &a.Message)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &a.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InnerError.
func (a InnerError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", a.Code)
	populate(objectMap, "innererror", a.InnerError)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InnerError.
func (a *InnerError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &a.Code)
			delete(rawMsg, key)
		case "innererror":
			err = unpopulate(val, "Innererror", &a.InnerError)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type batchImageGenerationOperationResponse.
func (b batchImageGenerationOperationResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeUnix(objectMap, "created", b.Created)
	populate(objectMap, "error", b.Error)
	populate(objectMap, "expires", b.Expires)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "result", b.Result)
	populate(objectMap, "status", b.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type batchImageGenerationOperationResponse.
func (b *batchImageGenerationOperationResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeUnix(val, "Created", &b.Created)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &b.Error)
			delete(rawMsg, key)
		case "expires":
			err = unpopulate(val, "Expires", &b.Expires)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "result":
			err = unpopulate(val, "Result", &b.Result)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &b.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatChoice.
func (c ChatChoice) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content_filter_results", c.ContentFilterResults)
	populate(objectMap, "delta", c.Delta)
	populate(objectMap, "finish_reason", c.FinishReason)
	populate(objectMap, "index", c.Index)
	populate(objectMap, "message", c.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatChoice.
func (c *ChatChoice) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content_filter_results":
			err = unpopulate(val, "ContentFilterResults", &c.ContentFilterResults)
			delete(rawMsg, key)
		case "delta":
			err = unpopulate(val, "Delta", &c.Delta)
			delete(rawMsg, key)
		case "finish_reason":
			err = unpopulate(val, "FinishReason", &c.FinishReason)
			delete(rawMsg, key)
		case "index":
			err = unpopulate(val, "Index", &c.Index)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &c.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatChoiceContentFilterResults.
func (c ChatChoiceContentFilterResults) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", c.Error)
	populate(objectMap, "hate", c.Hate)
	populate(objectMap, "self_harm", c.SelfHarm)
	populate(objectMap, "sexual", c.Sexual)
	populate(objectMap, "violence", c.Violence)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatChoiceContentFilterResults.
func (c *ChatChoiceContentFilterResults) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, "Error", &c.Error)
			delete(rawMsg, key)
		case "hate":
			err = unpopulate(val, "Hate", &c.Hate)
			delete(rawMsg, key)
		case "self_harm":
			err = unpopulate(val, "SelfHarm", &c.SelfHarm)
			delete(rawMsg, key)
		case "sexual":
			err = unpopulate(val, "Sexual", &c.Sexual)
			delete(rawMsg, key)
		case "violence":
			err = unpopulate(val, "Violence", &c.Violence)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatChoiceDelta.
func (c ChatChoiceDelta) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content", c.Content)
	populate(objectMap, "context", c.Context)
	populate(objectMap, "function_call", c.FunctionCall)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "role", c.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatChoiceDelta.
func (c *ChatChoiceDelta) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
			err = unpopulate(val, "Content", &c.Content)
			delete(rawMsg, key)
		case "context":
			err = unpopulate(val, "Context", &c.Context)
			delete(rawMsg, key)
		case "function_call":
			err = unpopulate(val, "FunctionCall", &c.FunctionCall)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &c.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatChoiceMessage.
func (c ChatChoiceMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content", c.Content)
	populate(objectMap, "context", c.Context)
	populate(objectMap, "function_call", c.FunctionCall)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "role", c.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatChoiceMessage.
func (c *ChatChoiceMessage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
			err = unpopulate(val, "Content", &c.Content)
			delete(rawMsg, key)
		case "context":
			err = unpopulate(val, "Context", &c.Context)
			delete(rawMsg, key)
		case "function_call":
			err = unpopulate(val, "FunctionCall", &c.FunctionCall)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &c.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatCompletions.
func (c ChatCompletions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "choices", c.Choices)
	populateTimeUnix(objectMap, "created", c.Created)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "prompt_filter_results", c.PromptFilterResults)
	populate(objectMap, "usage", c.Usage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatCompletions.
func (c *ChatCompletions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "choices":
			err = unpopulate(val, "Choices", &c.Choices)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeUnix(val, "Created", &c.Created)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "prompt_annotations":
			fallthrough
		case "prompt_filter_results":
			err = unpopulate(val, "PromptFilterResults", &c.PromptFilterResults)
			delete(rawMsg, key)
		case "usage":
			err = unpopulate(val, "Usage", &c.Usage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatCompletionsOptions.
func (c ChatCompletionsOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	if c.AzureExtensionsOptions != nil {
		populate(objectMap, "dataSources", c.AzureExtensionsOptions.Extensions)
	}
	populate(objectMap, "frequency_penalty", c.FrequencyPenalty)
	populate(objectMap, "function_call", c.FunctionCall)
	populate(objectMap, "functions", c.Functions)
	populate(objectMap, "logit_bias", c.LogitBias)
	populate(objectMap, "max_tokens", c.MaxTokens)
	populate(objectMap, "messages", c.Messages)
	populate(objectMap, "model", &c.Deployment)
	populate(objectMap, "n", c.N)
	populate(objectMap, "presence_penalty", c.PresencePenalty)
	populate(objectMap, "stop", c.Stop)
	populate(objectMap, "temperature", c.Temperature)
	populate(objectMap, "top_p", c.TopP)
	populate(objectMap, "user", c.User)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatCompletionsOptions.
func (c *ChatCompletionsOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataSources":
			c.AzureExtensionsOptions = &AzureChatExtensionOptions{}
			err = unpopulate(val, "DataSources", &c.AzureExtensionsOptions.Extensions)
			delete(rawMsg, key)
		case "frequency_penalty":
			err = unpopulate(val, "FrequencyPenalty", &c.FrequencyPenalty)
			delete(rawMsg, key)
		case "function_call":
			err = unpopulate(val, "FunctionCall", &c.FunctionCall)
			delete(rawMsg, key)
		case "functions":
			err = unpopulate(val, "Functions", &c.Functions)
			delete(rawMsg, key)
		case "logit_bias":
			err = unpopulate(val, "LogitBias", &c.LogitBias)
			delete(rawMsg, key)
		case "max_tokens":
			err = unpopulate(val, "MaxTokens", &c.MaxTokens)
			delete(rawMsg, key)
		case "messages":
			err = unpopulate(val, "Messages", &c.Messages)
			delete(rawMsg, key)
		case "model":
			err = unpopulate(val, "Model", &c.Deployment)
			delete(rawMsg, key)
		case "n":
			err = unpopulate(val, "N", &c.N)
			delete(rawMsg, key)
		case "presence_penalty":
			err = unpopulate(val, "PresencePenalty", &c.PresencePenalty)
			delete(rawMsg, key)
		case "stop":
			err = unpopulate(val, "Stop", &c.Stop)
			delete(rawMsg, key)
		case "temperature":
			err = unpopulate(val, "Temperature", &c.Temperature)
			delete(rawMsg, key)
		case "top_p":
			err = unpopulate(val, "TopP", &c.TopP)
			delete(rawMsg, key)
		case "user":
			err = unpopulate(val, "User", &c.User)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatMessage.
func (c ChatMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content", c.Content)
	populate(objectMap, "context", c.Context)
	populate(objectMap, "function_call", c.FunctionCall)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "role", c.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatMessage.
func (c *ChatMessage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
			err = unpopulate(val, "Content", &c.Content)
			delete(rawMsg, key)
		case "context":
			err = unpopulate(val, "Context", &c.Context)
			delete(rawMsg, key)
		case "function_call":
			err = unpopulate(val, "FunctionCall", &c.FunctionCall)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &c.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatMessageContext.
func (c ChatMessageContext) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "messages", c.Messages)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatMessageContext.
func (c *ChatMessageContext) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "messages":
			err = unpopulate(val, "Messages", &c.Messages)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatMessageFunctionCall.
func (c ChatMessageFunctionCall) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arguments", c.Arguments)
	populate(objectMap, "name", c.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatMessageFunctionCall.
func (c *ChatMessageFunctionCall) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, "Arguments", &c.Arguments)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Choice.
func (c Choice) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content_filter_results", c.ContentFilterResults)
	populate(objectMap, "finish_reason", c.FinishReason)
	populate(objectMap, "index", c.Index)
	populate(objectMap, "logprobs", c.LogProbs)
	populate(objectMap, "text", c.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Choice.
func (c *Choice) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content_filter_results":
			err = unpopulate(val, "ContentFilterResults", &c.ContentFilterResults)
			delete(rawMsg, key)
		case "finish_reason":
			err = unpopulate(val, "FinishReason", &c.FinishReason)
			delete(rawMsg, key)
		case "index":
			err = unpopulate(val, "Index", &c.Index)
			delete(rawMsg, key)
		case "logprobs":
			err = unpopulate(val, "LogProbs", &c.LogProbs)
			delete(rawMsg, key)
		case "text":
			err = unpopulate(val, "Text", &c.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChoiceContentFilterResults.
func (c ChoiceContentFilterResults) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", c.Error)
	populate(objectMap, "hate", c.Hate)
	populate(objectMap, "self_harm", c.SelfHarm)
	populate(objectMap, "sexual", c.Sexual)
	populate(objectMap, "violence", c.Violence)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChoiceContentFilterResults.
func (c *ChoiceContentFilterResults) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, "Error", &c.Error)
			delete(rawMsg, key)
		case "hate":
			err = unpopulate(val, "Hate", &c.Hate)
			delete(rawMsg, key)
		case "self_harm":
			err = unpopulate(val, "SelfHarm", &c.SelfHarm)
			delete(rawMsg, key)
		case "sexual":
			err = unpopulate(val, "Sexual", &c.Sexual)
			delete(rawMsg, key)
		case "violence":
			err = unpopulate(val, "Violence", &c.Violence)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChoiceLogProbs.
func (c ChoiceLogProbs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "text_offset", c.TextOffset)
	populate(objectMap, "token_logprobs", c.TokenLogProbs)
	populate(objectMap, "tokens", c.Tokens)
	populate(objectMap, "top_logprobs", c.TopLogProbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChoiceLogProbs.
func (c *ChoiceLogProbs) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "text_offset":
			err = unpopulate(val, "TextOffset", &c.TextOffset)
			delete(rawMsg, key)
		case "token_logprobs":
			err = unpopulate(val, "TokenLogProbs", &c.TokenLogProbs)
			delete(rawMsg, key)
		case "tokens":
			err = unpopulate(val, "Tokens", &c.Tokens)
			delete(rawMsg, key)
		case "top_logprobs":
			err = unpopulate(val, "TopLogProbs", &c.TopLogProbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Completions.
func (c Completions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "choices", c.Choices)
	populateTimeUnix(objectMap, "created", c.Created)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "prompt_filter_results", c.PromptFilterResults)
	populate(objectMap, "usage", c.Usage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Completions.
func (c *Completions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "choices":
			err = unpopulate(val, "Choices", &c.Choices)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeUnix(val, "Created", &c.Created)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "prompt_annotations":
			fallthrough
		case "prompt_filter_results":
			err = unpopulate(val, "PromptFilterResults", &c.PromptFilterResults)
			delete(rawMsg, key)
		case "usage":
			err = unpopulate(val, "Usage", &c.Usage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CompletionsLogProbabilityModel.
func (c CompletionsLogProbabilityModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "text_offset", c.TextOffset)
	populate(objectMap, "token_logprobs", c.TokenLogProbs)
	populate(objectMap, "tokens", c.Tokens)
	populate(objectMap, "top_logprobs", c.TopLogProbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CompletionsLogProbabilityModel.
func (c *CompletionsLogProbabilityModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "text_offset":
			err = unpopulate(val, "TextOffset", &c.TextOffset)
			delete(rawMsg, key)
		case "token_logprobs":
			err = unpopulate(val, "TokenLogProbs", &c.TokenLogProbs)
			delete(rawMsg, key)
		case "tokens":
			err = unpopulate(val, "Tokens", &c.Tokens)
			delete(rawMsg, key)
		case "top_logprobs":
			err = unpopulate(val, "TopLogProbs", &c.TopLogProbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CompletionsOptions.
func (c CompletionsOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "best_of", c.BestOf)
	populate(objectMap, "echo", c.Echo)
	populate(objectMap, "frequency_penalty", c.FrequencyPenalty)
	populate(objectMap, "logit_bias", c.LogitBias)
	populate(objectMap, "logprobs", c.LogProbs)
	populate(objectMap, "max_tokens", c.MaxTokens)
	populate(objectMap, "model", &c.Deployment)
	populate(objectMap, "n", c.N)
	populate(objectMap, "presence_penalty", c.PresencePenalty)
	populate(objectMap, "prompt", c.Prompt)
	populate(objectMap, "stop", c.Stop)
	populate(objectMap, "temperature", c.Temperature)
	populate(objectMap, "top_p", c.TopP)
	populate(objectMap, "user", c.User)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CompletionsOptions.
func (c *CompletionsOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "best_of":
			err = unpopulate(val, "BestOf", &c.BestOf)
			delete(rawMsg, key)
		case "echo":
			err = unpopulate(val, "Echo", &c.Echo)
			delete(rawMsg, key)
		case "frequency_penalty":
			err = unpopulate(val, "FrequencyPenalty", &c.FrequencyPenalty)
			delete(rawMsg, key)
		case "logit_bias":
			err = unpopulate(val, "LogitBias", &c.LogitBias)
			delete(rawMsg, key)
		case "logprobs":
			err = unpopulate(val, "LogProbs", &c.LogProbs)
			delete(rawMsg, key)
		case "max_tokens":
			err = unpopulate(val, "MaxTokens", &c.MaxTokens)
			delete(rawMsg, key)
		case "model":
			err = unpopulate(val, "Model", &c.Deployment)
			delete(rawMsg, key)
		case "n":
			err = unpopulate(val, "N", &c.N)
			delete(rawMsg, key)
		case "presence_penalty":
			err = unpopulate(val, "PresencePenalty", &c.PresencePenalty)
			delete(rawMsg, key)
		case "prompt":
			err = unpopulate(val, "Prompt", &c.Prompt)
			delete(rawMsg, key)
		case "stop":
			err = unpopulate(val, "Stop", &c.Stop)
			delete(rawMsg, key)
		case "temperature":
			err = unpopulate(val, "Temperature", &c.Temperature)
			delete(rawMsg, key)
		case "top_p":
			err = unpopulate(val, "TopP", &c.TopP)
			delete(rawMsg, key)
		case "user":
			err = unpopulate(val, "User", &c.User)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CompletionsUsage.
func (c CompletionsUsage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "completion_tokens", c.CompletionTokens)
	populate(objectMap, "prompt_tokens", c.PromptTokens)
	populate(objectMap, "total_tokens", c.TotalTokens)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CompletionsUsage.
func (c *CompletionsUsage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "completion_tokens":
			err = unpopulate(val, "CompletionTokens", &c.CompletionTokens)
			delete(rawMsg, key)
		case "prompt_tokens":
			err = unpopulate(val, "PromptTokens", &c.PromptTokens)
			delete(rawMsg, key)
		case "total_tokens":
			err = unpopulate(val, "TotalTokens", &c.TotalTokens)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentFilterResult.
func (c ContentFilterResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "filtered", c.Filtered)
	populate(objectMap, "severity", c.Severity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentFilterResult.
func (c *ContentFilterResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filtered":
			err = unpopulate(val, "Filtered", &c.Filtered)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &c.Severity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentFilterResults.
func (c ContentFilterResults) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", c.Error)
	populate(objectMap, "hate", c.Hate)
	populate(objectMap, "self_harm", c.SelfHarm)
	populate(objectMap, "sexual", c.Sexual)
	populate(objectMap, "violence", c.Violence)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentFilterResults.
func (c *ContentFilterResults) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, "Error", &c.Error)
			delete(rawMsg, key)
		case "hate":
			err = unpopulate(val, "Hate", &c.Hate)
			delete(rawMsg, key)
		case "self_harm":
			err = unpopulate(val, "SelfHarm", &c.SelfHarm)
			delete(rawMsg, key)
		case "sexual":
			err = unpopulate(val, "Sexual", &c.Sexual)
			delete(rawMsg, key)
		case "violence":
			err = unpopulate(val, "Violence", &c.Violence)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentFilterResultsError.
func (c ContentFilterResultsError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", c.Code)
	populate(objectMap, "details", c.Details)
	populate(objectMap, "innererror", c.InnerError)
	populate(objectMap, "message", c.Message)
	populate(objectMap, "target", c.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentFilterResultsError.
func (c *ContentFilterResultsError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &c.Code)
			delete(rawMsg, key)
		case "details":
			err = unpopulate(val, "Details", &c.Details)
			delete(rawMsg, key)
		case "innererror":
			err = unpopulate(val, "Innererror", &c.InnerError)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &c.Message)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &c.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Deployment.
func (d Deployment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentId", d.DeploymentID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Deployment.
func (d *Deployment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentId":
			err = unpopulate(val, "DeploymentID", &d.DeploymentID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EmbeddingItem.
func (e EmbeddingItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "embedding", e.Embedding)
	populate(objectMap, "index", e.Index)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EmbeddingItem.
func (e *EmbeddingItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "embedding":
			err = unpopulate(val, "Embedding", &e.Embedding)
			delete(rawMsg, key)
		case "index":
			err = unpopulate(val, "Index", &e.Index)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Embeddings.
func (e Embeddings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "data", e.Data)
	populate(objectMap, "usage", e.Usage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Embeddings.
func (e *Embeddings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "data":
			err = unpopulate(val, "Data", &e.Data)
			delete(rawMsg, key)
		case "usage":
			err = unpopulate(val, "Usage", &e.Usage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EmbeddingsOptions.
func (e EmbeddingsOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "input", e.Input)
	populate(objectMap, "model", &e.Deployment)
	populate(objectMap, "user", e.User)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EmbeddingsOptions.
func (e *EmbeddingsOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, "Input", &e.Input)
			delete(rawMsg, key)
		case "model":
			err = unpopulate(val, "Model", &e.Deployment)
			delete(rawMsg, key)
		case "user":
			err = unpopulate(val, "User", &e.User)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EmbeddingsUsage.
func (e EmbeddingsUsage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "prompt_tokens", e.PromptTokens)
	populate(objectMap, "total_tokens", e.TotalTokens)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EmbeddingsUsage.
func (e *EmbeddingsUsage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "prompt_tokens":
			err = unpopulate(val, "PromptTokens", &e.PromptTokens)
			delete(rawMsg, key)
		case "total_tokens":
			err = unpopulate(val, "TotalTokens", &e.TotalTokens)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EmbeddingsUsageAutoGenerated.
func (e EmbeddingsUsageAutoGenerated) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "prompt_tokens", e.PromptTokens)
	populate(objectMap, "total_tokens", e.TotalTokens)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EmbeddingsUsageAutoGenerated.
func (e *EmbeddingsUsageAutoGenerated) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "prompt_tokens":
			err = unpopulate(val, "PromptTokens", &e.PromptTokens)
			delete(rawMsg, key)
		case "total_tokens":
			err = unpopulate(val, "TotalTokens", &e.TotalTokens)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FunctionCall.
func (f FunctionCall) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arguments", f.Arguments)
	populate(objectMap, "name", f.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FunctionCall.
func (f *FunctionCall) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arguments":
			err = unpopulate(val, "Arguments", &f.Arguments)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FunctionDefinition.
func (f FunctionDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "name", f.Name)
	populateAny(objectMap, "parameters", f.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FunctionDefinition.
func (f *FunctionDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &f.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &f.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FunctionName.
func (f FunctionName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", f.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FunctionName.
func (f *FunctionName) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageGenerationOptions.
func (i ImageGenerationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "n", i.N)
	populate(objectMap, "prompt", i.Prompt)
	populate(objectMap, "response_format", i.ResponseFormat)
	populate(objectMap, "size", i.Size)
	populate(objectMap, "user", i.User)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageGenerationOptions.
func (i *ImageGenerationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "n":
			err = unpopulate(val, "N", &i.N)
			delete(rawMsg, key)
		case "prompt":
			err = unpopulate(val, "Prompt", &i.Prompt)
			delete(rawMsg, key)
		case "response_format":
			err = unpopulate(val, "ResponseFormat", &i.ResponseFormat)
			delete(rawMsg, key)
		case "size":
			err = unpopulate(val, "Size", &i.Size)
			delete(rawMsg, key)
		case "user":
			err = unpopulate(val, "User", &i.User)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageGenerations.
func (i ImageGenerations) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeUnix(objectMap, "created", i.Created)
	populateAny(objectMap, "data", i.Data)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageGenerations.
func (i *ImageGenerations) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeUnix(val, "Created", &i.Created)
			delete(rawMsg, key)
		case "data":
			err = unpopulate(val, "Data", &i.Data)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PromptFilterResult.
func (p PromptFilterResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content_filter_results", p.ContentFilterResults)
	populate(objectMap, "prompt_index", p.PromptIndex)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PromptFilterResult.
func (p *PromptFilterResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content_filter_results":
			err = unpopulate(val, "ContentFilterResults", &p.ContentFilterResults)
			delete(rawMsg, key)
		case "prompt_index":
			err = unpopulate(val, "PromptIndex", &p.PromptIndex)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PromptFilterResultContentFilterResults.
func (p PromptFilterResultContentFilterResults) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", p.Error)
	populate(objectMap, "hate", p.Hate)
	populate(objectMap, "self_harm", p.SelfHarm)
	populate(objectMap, "sexual", p.Sexual)
	populate(objectMap, "violence", p.Violence)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PromptFilterResultContentFilterResults.
func (p *PromptFilterResultContentFilterResults) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, "Error", &p.Error)
			delete(rawMsg, key)
		case "hate":
			err = unpopulate(val, "Hate", &p.Hate)
			delete(rawMsg, key)
		case "self_harm":
			err = unpopulate(val, "SelfHarm", &p.SelfHarm)
			delete(rawMsg, key)
		case "sexual":
			err = unpopulate(val, "Sexual", &p.Sexual)
			delete(rawMsg, key)
		case "violence":
			err = unpopulate(val, "Violence", &p.Violence)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func populateByteArray(m map[string]any, k string, b []byte, f runtime.Base64Encoding) {
	if azcore.IsNullValue(b) {
		m[k] = nil
	} else if len(b) == 0 {
		return
	} else {
		m[k] = runtime.EncodeByteArray(b, f)
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
