//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azopenaiassistants

import (
	"context"
	"errors"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// Client contains the methods for the OpenAIAssistants group.
// Don't use this type directly, use a constructor function instead.
type Client struct {
	cd       clientData
	internal *azcore.Client
	endpoint string
}

// CancelRun - Cancels a run of an in progress thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread being run.
//   - runID - The ID of the run to cancel.
//   - options - CancelRunOptions contains the optional parameters for the Client.CancelRun method.
func (client *Client) CancelRun(ctx context.Context, threadID string, runID string, options *CancelRunOptions) (CancelRunResponse, error) {
	var err error
	req, err := client.cancelRunCreateRequest(ctx, threadID, runID, options)
	if err != nil {
		return CancelRunResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CancelRunResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return CancelRunResponse{}, err
	}
	resp, err := client.cancelRunHandleResponse(httpResp)
	return resp, err
}

// cancelRunCreateRequest creates the CancelRun request.
func (client *Client) cancelRunCreateRequest(ctx context.Context, threadID string, runID string, options *CancelRunOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}/runs/{runId}/cancel")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	if runID == "" {
		return nil, errors.New("parameter runID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{runId}", url.PathEscape(runID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// cancelRunHandleResponse handles the CancelRun response.
func (client *Client) cancelRunHandleResponse(resp *http.Response) (CancelRunResponse, error) {
	result := CancelRunResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadRun); err != nil {
		return CancelRunResponse{}, err
	}
	return result, nil
}

// CancelVectorStoreFileBatch - Cancel a vector store file batch. This attempts to cancel the processing of files in this
// batch as soon as possible.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - vectorStoreID - The ID of the vector store that the file batch belongs to.
//   - batchID - The ID of the file batch to cancel.
//   - options - CancelVectorStoreFileBatchOptions contains the optional parameters for the Client.CancelVectorStoreFileBatch
//     method.
func (client *Client) CancelVectorStoreFileBatch(ctx context.Context, vectorStoreID string, batchID string, options *CancelVectorStoreFileBatchOptions) (CancelVectorStoreFileBatchResponse, error) {
	var err error
	req, err := client.cancelVectorStoreFileBatchCreateRequest(ctx, vectorStoreID, batchID, options)
	if err != nil {
		return CancelVectorStoreFileBatchResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CancelVectorStoreFileBatchResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return CancelVectorStoreFileBatchResponse{}, err
	}
	resp, err := client.cancelVectorStoreFileBatchHandleResponse(httpResp)
	return resp, err
}

// cancelVectorStoreFileBatchCreateRequest creates the CancelVectorStoreFileBatch request.
func (client *Client) cancelVectorStoreFileBatchCreateRequest(ctx context.Context, vectorStoreID string, batchID string, options *CancelVectorStoreFileBatchOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores/{vectorStoreId}/file_batches/{batchId}/cancel")
	if vectorStoreID == "" {
		return nil, errors.New("parameter vectorStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vectorStoreId}", url.PathEscape(vectorStoreID))
	if batchID == "" {
		return nil, errors.New("parameter batchID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{batchId}", url.PathEscape(batchID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// cancelVectorStoreFileBatchHandleResponse handles the CancelVectorStoreFileBatch response.
func (client *Client) cancelVectorStoreFileBatchHandleResponse(resp *http.Response) (CancelVectorStoreFileBatchResponse, error) {
	result := CancelVectorStoreFileBatchResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStoreFileBatch); err != nil {
		return CancelVectorStoreFileBatchResponse{}, err
	}
	return result, nil
}

// CreateAssistant - Creates a new assistant.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - options - CreateAssistantOptions contains the optional parameters for the Client.CreateAssistant method.
func (client *Client) CreateAssistant(ctx context.Context, body CreateAssistantBody, options *CreateAssistantOptions) (CreateAssistantResponse, error) {
	var err error
	req, err := client.createAssistantCreateRequest(ctx, body, options)
	if err != nil {
		return CreateAssistantResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateAssistantResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return CreateAssistantResponse{}, err
	}
	resp, err := client.createAssistantHandleResponse(httpResp)
	return resp, err
}

// createAssistantCreateRequest creates the CreateAssistant request.
func (client *Client) createAssistantCreateRequest(ctx context.Context, body CreateAssistantBody, options *CreateAssistantOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/assistants")
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createAssistantHandleResponse handles the CreateAssistant response.
func (client *Client) createAssistantHandleResponse(resp *http.Response) (CreateAssistantResponse, error) {
	result := CreateAssistantResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Assistant); err != nil {
		return CreateAssistantResponse{}, err
	}
	return result, nil
}

// CreateMessage - Creates a new message on a specified thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread to create the new message on.
//   - threadMessageOptions - A single message within an assistant thread, as provided during that thread's creation for its initial
//     state.
//   - options - CreateMessageOptions contains the optional parameters for the Client.CreateMessage method.
func (client *Client) CreateMessage(ctx context.Context, threadID string, threadMessageOptions CreateMessageBody, options *CreateMessageOptions) (CreateMessageResponse, error) {
	var err error
	req, err := client.createMessageCreateRequest(ctx, threadID, threadMessageOptions, options)
	if err != nil {
		return CreateMessageResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateMessageResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return CreateMessageResponse{}, err
	}
	resp, err := client.createMessageHandleResponse(httpResp)
	return resp, err
}

// createMessageCreateRequest creates the CreateMessage request.
func (client *Client) createMessageCreateRequest(ctx context.Context, threadID string, threadMessageOptions CreateMessageBody, options *CreateMessageOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}/messages")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, threadMessageOptions); err != nil {
		return nil, err
	}
	return req, nil
}

// createMessageHandleResponse handles the CreateMessage response.
func (client *Client) createMessageHandleResponse(resp *http.Response) (CreateMessageResponse, error) {
	result := CreateMessageResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadMessage); err != nil {
		return CreateMessageResponse{}, err
	}
	return result, nil
}

// CreateRun - Creates a new run for an assistant thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread to run.
//   - createRunBody - The details for the run to create.
//   - options - CreateRunOptions contains the optional parameters for the Client.CreateRun method.
func (client *Client) CreateRun(ctx context.Context, threadID string, createRunBody CreateRunBody, options *CreateRunOptions) (CreateRunResponse, error) {
	var err error
	req, err := client.createRunCreateRequest(ctx, threadID, createRunBody, options)
	if err != nil {
		return CreateRunResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateRunResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return CreateRunResponse{}, err
	}
	resp, err := client.createRunHandleResponse(httpResp)
	return resp, err
}

// createRunCreateRequest creates the CreateRun request.
func (client *Client) createRunCreateRequest(ctx context.Context, threadID string, createRunBody CreateRunBody, options *CreateRunOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}/runs")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, createRunBody); err != nil {
		return nil, err
	}
	return req, nil
}

// createRunHandleResponse handles the CreateRun response.
func (client *Client) createRunHandleResponse(resp *http.Response) (CreateRunResponse, error) {
	result := CreateRunResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadRun); err != nil {
		return CreateRunResponse{}, err
	}
	return result, nil
}

// CreateThread - Creates a new thread. Threads contain messages and can be run by assistants.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - options - CreateThreadOptions contains the optional parameters for the Client.CreateThread method.
func (client *Client) CreateThread(ctx context.Context, body CreateThreadBody, options *CreateThreadOptions) (CreateThreadResponse, error) {
	var err error
	req, err := client.createThreadCreateRequest(ctx, body, options)
	if err != nil {
		return CreateThreadResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateThreadResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return CreateThreadResponse{}, err
	}
	resp, err := client.createThreadHandleResponse(httpResp)
	return resp, err
}

// createThreadCreateRequest creates the CreateThread request.
func (client *Client) createThreadCreateRequest(ctx context.Context, body CreateThreadBody, options *CreateThreadOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads")
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createThreadHandleResponse handles the CreateThread response.
func (client *Client) createThreadHandleResponse(resp *http.Response) (CreateThreadResponse, error) {
	result := CreateThreadResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AssistantThread); err != nil {
		return CreateThreadResponse{}, err
	}
	return result, nil
}

// CreateThreadAndRun - Creates a new assistant thread and immediately starts a run using that new thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - options - CreateThreadAndRunOptions contains the optional parameters for the Client.CreateThreadAndRun method.
func (client *Client) CreateThreadAndRun(ctx context.Context, body CreateAndRunThreadBody, options *CreateThreadAndRunOptions) (CreateThreadAndRunResponse, error) {
	var err error
	req, err := client.createThreadAndRunCreateRequest(ctx, body, options)
	if err != nil {
		return CreateThreadAndRunResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateThreadAndRunResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return CreateThreadAndRunResponse{}, err
	}
	resp, err := client.createThreadAndRunHandleResponse(httpResp)
	return resp, err
}

// createThreadAndRunCreateRequest creates the CreateThreadAndRun request.
func (client *Client) createThreadAndRunCreateRequest(ctx context.Context, body CreateAndRunThreadBody, options *CreateThreadAndRunOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/runs")
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createThreadAndRunHandleResponse handles the CreateThreadAndRun response.
func (client *Client) createThreadAndRunHandleResponse(resp *http.Response) (CreateThreadAndRunResponse, error) {
	result := CreateThreadAndRunResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadRun); err != nil {
		return CreateThreadAndRunResponse{}, err
	}
	return result, nil
}

// CreateVectorStore - Creates a vector store.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - options - CreateVectorStoreOptions contains the optional parameters for the Client.CreateVectorStore method.
func (client *Client) CreateVectorStore(ctx context.Context, body VectorStoreBody, options *CreateVectorStoreOptions) (CreateVectorStoreResponse, error) {
	var err error
	req, err := client.createVectorStoreCreateRequest(ctx, body, options)
	if err != nil {
		return CreateVectorStoreResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateVectorStoreResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return CreateVectorStoreResponse{}, err
	}
	resp, err := client.createVectorStoreHandleResponse(httpResp)
	return resp, err
}

// createVectorStoreCreateRequest creates the CreateVectorStore request.
func (client *Client) createVectorStoreCreateRequest(ctx context.Context, body VectorStoreBody, options *CreateVectorStoreOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores")
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createVectorStoreHandleResponse handles the CreateVectorStore response.
func (client *Client) createVectorStoreHandleResponse(resp *http.Response) (CreateVectorStoreResponse, error) {
	result := CreateVectorStoreResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStore); err != nil {
		return CreateVectorStoreResponse{}, err
	}
	return result, nil
}

// CreateVectorStoreFile - Create a vector store file by attaching a file to a vector store.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - vectorStoreID - The ID of the vector store for which to create a File.
//   - fileID - A File ID that the vector store should use. Useful for tools like file_search that can access files.
//   - options - CreateVectorStoreFileOptions contains the optional parameters for the Client.CreateVectorStoreFile method.
func (client *Client) CreateVectorStoreFile(ctx context.Context, vectorStoreID string, fileID string, options *CreateVectorStoreFileOptions) (CreateVectorStoreFileResponse, error) {
	var err error
	req, err := client.createVectorStoreFileCreateRequest(ctx, vectorStoreID, fileID, options)
	if err != nil {
		return CreateVectorStoreFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateVectorStoreFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return CreateVectorStoreFileResponse{}, err
	}
	resp, err := client.createVectorStoreFileHandleResponse(httpResp)
	return resp, err
}

// createVectorStoreFileCreateRequest creates the CreateVectorStoreFile request.
func (client *Client) createVectorStoreFileCreateRequest(ctx context.Context, vectorStoreID string, fileID string, options *CreateVectorStoreFileOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores/{vectorStoreId}/files")
	if vectorStoreID == "" {
		return nil, errors.New("parameter vectorStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vectorStoreId}", url.PathEscape(vectorStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, fileIDStruct{fileID}); err != nil {
		return nil, err
	}
	return req, nil
}

// createVectorStoreFileHandleResponse handles the CreateVectorStoreFile response.
func (client *Client) createVectorStoreFileHandleResponse(resp *http.Response) (CreateVectorStoreFileResponse, error) {
	result := CreateVectorStoreFileResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStoreFile); err != nil {
		return CreateVectorStoreFileResponse{}, err
	}
	return result, nil
}

// CreateVectorStoreFileBatch - Create a vector store file batch.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - vectorStoreID - The ID of the vector store for which to create a File Batch.
//   - options - CreateVectorStoreFileBatchOptions contains the optional parameters for the Client.CreateVectorStoreFileBatch
//     method.
func (client *Client) CreateVectorStoreFileBatch(ctx context.Context, vectorStoreID string, body CreateVectorStoreFileBatchBody, options *CreateVectorStoreFileBatchOptions) (CreateVectorStoreFileBatchResponse, error) {
	var err error
	req, err := client.createVectorStoreFileBatchCreateRequest(ctx, vectorStoreID, body, options)
	if err != nil {
		return CreateVectorStoreFileBatchResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateVectorStoreFileBatchResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return CreateVectorStoreFileBatchResponse{}, err
	}
	resp, err := client.createVectorStoreFileBatchHandleResponse(httpResp)
	return resp, err
}

// createVectorStoreFileBatchCreateRequest creates the CreateVectorStoreFileBatch request.
func (client *Client) createVectorStoreFileBatchCreateRequest(ctx context.Context, vectorStoreID string, body CreateVectorStoreFileBatchBody, options *CreateVectorStoreFileBatchOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores/{vectorStoreId}/file_batches")
	if vectorStoreID == "" {
		return nil, errors.New("parameter vectorStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vectorStoreId}", url.PathEscape(vectorStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createVectorStoreFileBatchHandleResponse handles the CreateVectorStoreFileBatch response.
func (client *Client) createVectorStoreFileBatchHandleResponse(resp *http.Response) (CreateVectorStoreFileBatchResponse, error) {
	result := CreateVectorStoreFileBatchResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStoreFileBatch); err != nil {
		return CreateVectorStoreFileBatchResponse{}, err
	}
	return result, nil
}

// DeleteAssistant - Deletes an assistant.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - assistantID - The ID of the assistant to delete.
//   - options - DeleteAssistantOptions contains the optional parameters for the Client.DeleteAssistant method.
func (client *Client) DeleteAssistant(ctx context.Context, assistantID string, options *DeleteAssistantOptions) (DeleteAssistantResponse, error) {
	var err error
	req, err := client.deleteAssistantCreateRequest(ctx, assistantID, options)
	if err != nil {
		return DeleteAssistantResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteAssistantResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeleteAssistantResponse{}, err
	}
	resp, err := client.deleteAssistantHandleResponse(httpResp)
	return resp, err
}

// deleteAssistantCreateRequest creates the DeleteAssistant request.
func (client *Client) deleteAssistantCreateRequest(ctx context.Context, assistantID string, options *DeleteAssistantOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/assistants/{assistantId}")
	if assistantID == "" {
		return nil, errors.New("parameter assistantID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{assistantId}", url.PathEscape(assistantID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteAssistantHandleResponse handles the DeleteAssistant response.
func (client *Client) deleteAssistantHandleResponse(resp *http.Response) (DeleteAssistantResponse, error) {
	result := DeleteAssistantResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AssistantDeletionStatus); err != nil {
		return DeleteAssistantResponse{}, err
	}
	return result, nil
}

// DeleteFile - Delete a previously uploaded file.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - fileID - The ID of the file to delete.
//   - options - DeleteFileOptions contains the optional parameters for the Client.DeleteFile method.
func (client *Client) DeleteFile(ctx context.Context, fileID string, options *DeleteFileOptions) (DeleteFileResponse, error) {
	var err error
	req, err := client.deleteFileCreateRequest(ctx, fileID, options)
	if err != nil {
		return DeleteFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeleteFileResponse{}, err
	}
	resp, err := client.deleteFileHandleResponse(httpResp)
	return resp, err
}

// deleteFileCreateRequest creates the DeleteFile request.
func (client *Client) deleteFileCreateRequest(ctx context.Context, fileID string, options *DeleteFileOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/files/{fileId}")
	if fileID == "" {
		return nil, errors.New("parameter fileID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{fileId}", url.PathEscape(fileID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteFileHandleResponse handles the DeleteFile response.
func (client *Client) deleteFileHandleResponse(resp *http.Response) (DeleteFileResponse, error) {
	result := DeleteFileResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FileDeletionStatus); err != nil {
		return DeleteFileResponse{}, err
	}
	return result, nil
}

// DeleteThread - Deletes an existing thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread to delete.
//   - options - DeleteThreadOptions contains the optional parameters for the Client.DeleteThread method.
func (client *Client) DeleteThread(ctx context.Context, threadID string, options *DeleteThreadOptions) (DeleteThreadResponse, error) {
	var err error
	req, err := client.deleteThreadCreateRequest(ctx, threadID, options)
	if err != nil {
		return DeleteThreadResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteThreadResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeleteThreadResponse{}, err
	}
	resp, err := client.deleteThreadHandleResponse(httpResp)
	return resp, err
}

// deleteThreadCreateRequest creates the DeleteThread request.
func (client *Client) deleteThreadCreateRequest(ctx context.Context, threadID string, options *DeleteThreadOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteThreadHandleResponse handles the DeleteThread response.
func (client *Client) deleteThreadHandleResponse(resp *http.Response) (DeleteThreadResponse, error) {
	result := DeleteThreadResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadDeletionStatus); err != nil {
		return DeleteThreadResponse{}, err
	}
	return result, nil
}

// DeleteVectorStore - Deletes the vector store object matching the specified ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - vectorStoreID - The ID of the vector store to delete.
//   - options - DeleteVectorStoreOptions contains the optional parameters for the Client.DeleteVectorStore method.
func (client *Client) DeleteVectorStore(ctx context.Context, vectorStoreID string, options *DeleteVectorStoreOptions) (DeleteVectorStoreResponse, error) {
	var err error
	req, err := client.deleteVectorStoreCreateRequest(ctx, vectorStoreID, options)
	if err != nil {
		return DeleteVectorStoreResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteVectorStoreResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeleteVectorStoreResponse{}, err
	}
	resp, err := client.deleteVectorStoreHandleResponse(httpResp)
	return resp, err
}

// deleteVectorStoreCreateRequest creates the DeleteVectorStore request.
func (client *Client) deleteVectorStoreCreateRequest(ctx context.Context, vectorStoreID string, options *DeleteVectorStoreOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores/{vectorStoreId}")
	if vectorStoreID == "" {
		return nil, errors.New("parameter vectorStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vectorStoreId}", url.PathEscape(vectorStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteVectorStoreHandleResponse handles the DeleteVectorStore response.
func (client *Client) deleteVectorStoreHandleResponse(resp *http.Response) (DeleteVectorStoreResponse, error) {
	result := DeleteVectorStoreResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStoreDeletionStatus); err != nil {
		return DeleteVectorStoreResponse{}, err
	}
	return result, nil
}

// DeleteVectorStoreFile - Delete a vector store file. This will remove the file from the vector store but the file itself
// will not be deleted. To delete the file, use the delete file endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - vectorStoreID - The ID of the vector store that the file belongs to.
//   - fileID - The ID of the file to delete its relationship to the vector store.
//   - options - DeleteVectorStoreFileOptions contains the optional parameters for the Client.DeleteVectorStoreFile method.
func (client *Client) DeleteVectorStoreFile(ctx context.Context, vectorStoreID string, fileID string, options *DeleteVectorStoreFileOptions) (DeleteVectorStoreFileResponse, error) {
	var err error
	req, err := client.deleteVectorStoreFileCreateRequest(ctx, vectorStoreID, fileID, options)
	if err != nil {
		return DeleteVectorStoreFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteVectorStoreFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeleteVectorStoreFileResponse{}, err
	}
	resp, err := client.deleteVectorStoreFileHandleResponse(httpResp)
	return resp, err
}

// deleteVectorStoreFileCreateRequest creates the DeleteVectorStoreFile request.
func (client *Client) deleteVectorStoreFileCreateRequest(ctx context.Context, vectorStoreID string, fileID string, options *DeleteVectorStoreFileOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores/{vectorStoreId}/files/{fileId}")
	if vectorStoreID == "" {
		return nil, errors.New("parameter vectorStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vectorStoreId}", url.PathEscape(vectorStoreID))
	if fileID == "" {
		return nil, errors.New("parameter fileID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{fileId}", url.PathEscape(fileID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteVectorStoreFileHandleResponse handles the DeleteVectorStoreFile response.
func (client *Client) deleteVectorStoreFileHandleResponse(resp *http.Response) (DeleteVectorStoreFileResponse, error) {
	result := DeleteVectorStoreFileResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStoreFileDeletionStatus); err != nil {
		return DeleteVectorStoreFileResponse{}, err
	}
	return result, nil
}

// GetAssistant - Retrieves an existing assistant.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - assistantID - The ID of the assistant to retrieve.
//   - options - GetAssistantOptions contains the optional parameters for the Client.GetAssistant method.
func (client *Client) GetAssistant(ctx context.Context, assistantID string, options *GetAssistantOptions) (GetAssistantResponse, error) {
	var err error
	req, err := client.getAssistantCreateRequest(ctx, assistantID, options)
	if err != nil {
		return GetAssistantResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetAssistantResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetAssistantResponse{}, err
	}
	resp, err := client.getAssistantHandleResponse(httpResp)
	return resp, err
}

// getAssistantCreateRequest creates the GetAssistant request.
func (client *Client) getAssistantCreateRequest(ctx context.Context, assistantID string, options *GetAssistantOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/assistants/{assistantId}")
	if assistantID == "" {
		return nil, errors.New("parameter assistantID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{assistantId}", url.PathEscape(assistantID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAssistantHandleResponse handles the GetAssistant response.
func (client *Client) getAssistantHandleResponse(resp *http.Response) (GetAssistantResponse, error) {
	result := GetAssistantResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Assistant); err != nil {
		return GetAssistantResponse{}, err
	}
	return result, nil
}

// GetFile - Returns information about a specific file. Does not retrieve file content.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - fileID - The ID of the file to retrieve.
//   - options - GetFileOptions contains the optional parameters for the Client.GetFile method.
func (client *Client) GetFile(ctx context.Context, fileID string, options *GetFileOptions) (GetFileResponse, error) {
	var err error
	req, err := client.getFileCreateRequest(ctx, fileID, options)
	if err != nil {
		return GetFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetFileResponse{}, err
	}
	resp, err := client.getFileHandleResponse(httpResp)
	return resp, err
}

// getFileCreateRequest creates the GetFile request.
func (client *Client) getFileCreateRequest(ctx context.Context, fileID string, options *GetFileOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/files/{fileId}")
	if fileID == "" {
		return nil, errors.New("parameter fileID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{fileId}", url.PathEscape(fileID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFileHandleResponse handles the GetFile response.
func (client *Client) getFileHandleResponse(resp *http.Response) (GetFileResponse, error) {
	result := GetFileResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.OpenAIFile); err != nil {
		return GetFileResponse{}, err
	}
	return result, nil
}

// GetMessage - Gets an existing message from an existing thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread to retrieve the specified message from.
//   - messageID - The ID of the message to retrieve from the specified thread.
//   - options - GetMessageOptions contains the optional parameters for the Client.GetMessage method.
func (client *Client) GetMessage(ctx context.Context, threadID string, messageID string, options *GetMessageOptions) (GetMessageResponse, error) {
	var err error
	req, err := client.getMessageCreateRequest(ctx, threadID, messageID, options)
	if err != nil {
		return GetMessageResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetMessageResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetMessageResponse{}, err
	}
	resp, err := client.getMessageHandleResponse(httpResp)
	return resp, err
}

// getMessageCreateRequest creates the GetMessage request.
func (client *Client) getMessageCreateRequest(ctx context.Context, threadID string, messageID string, options *GetMessageOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}/messages/{messageId}")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	if messageID == "" {
		return nil, errors.New("parameter messageID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{messageId}", url.PathEscape(messageID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMessageHandleResponse handles the GetMessage response.
func (client *Client) getMessageHandleResponse(resp *http.Response) (GetMessageResponse, error) {
	result := GetMessageResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadMessage); err != nil {
		return GetMessageResponse{}, err
	}
	return result, nil
}

// GetRun - Gets an existing run from an existing thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread to retrieve run information from.
//   - runID - The ID of the thread to retrieve information about.
//   - options - GetRunOptions contains the optional parameters for the Client.GetRun method.
func (client *Client) GetRun(ctx context.Context, threadID string, runID string, options *GetRunOptions) (GetRunResponse, error) {
	var err error
	req, err := client.getRunCreateRequest(ctx, threadID, runID, options)
	if err != nil {
		return GetRunResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetRunResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetRunResponse{}, err
	}
	resp, err := client.getRunHandleResponse(httpResp)
	return resp, err
}

// getRunCreateRequest creates the GetRun request.
func (client *Client) getRunCreateRequest(ctx context.Context, threadID string, runID string, options *GetRunOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}/runs/{runId}")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	if runID == "" {
		return nil, errors.New("parameter runID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{runId}", url.PathEscape(runID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getRunHandleResponse handles the GetRun response.
func (client *Client) getRunHandleResponse(resp *http.Response) (GetRunResponse, error) {
	result := GetRunResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadRun); err != nil {
		return GetRunResponse{}, err
	}
	return result, nil
}

// GetRunStep - Gets a single run step from a thread run.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread that was run.
//   - runID - The ID of the specific run to retrieve the step from.
//   - stepID - The ID of the step to retrieve information about.
//   - options - GetRunStepOptions contains the optional parameters for the Client.GetRunStep method.
func (client *Client) GetRunStep(ctx context.Context, threadID string, runID string, stepID string, options *GetRunStepOptions) (GetRunStepResponse, error) {
	var err error
	req, err := client.getRunStepCreateRequest(ctx, threadID, runID, stepID, options)
	if err != nil {
		return GetRunStepResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetRunStepResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetRunStepResponse{}, err
	}
	resp, err := client.getRunStepHandleResponse(httpResp)
	return resp, err
}

// getRunStepCreateRequest creates the GetRunStep request.
func (client *Client) getRunStepCreateRequest(ctx context.Context, threadID string, runID string, stepID string, options *GetRunStepOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}/runs/{runId}/steps/{stepId}")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	if runID == "" {
		return nil, errors.New("parameter runID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{runId}", url.PathEscape(runID))
	if stepID == "" {
		return nil, errors.New("parameter stepID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{stepId}", url.PathEscape(stepID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getRunStepHandleResponse handles the GetRunStep response.
func (client *Client) getRunStepHandleResponse(resp *http.Response) (GetRunStepResponse, error) {
	result := GetRunStepResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RunStep); err != nil {
		return GetRunStepResponse{}, err
	}
	return result, nil
}

// GetThread - Gets information about an existing thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread to retrieve information about.
//   - options - GetThreadOptions contains the optional parameters for the Client.GetThread method.
func (client *Client) GetThread(ctx context.Context, threadID string, options *GetThreadOptions) (GetThreadResponse, error) {
	var err error
	req, err := client.getThreadCreateRequest(ctx, threadID, options)
	if err != nil {
		return GetThreadResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetThreadResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetThreadResponse{}, err
	}
	resp, err := client.getThreadHandleResponse(httpResp)
	return resp, err
}

// getThreadCreateRequest creates the GetThread request.
func (client *Client) getThreadCreateRequest(ctx context.Context, threadID string, options *GetThreadOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getThreadHandleResponse handles the GetThread response.
func (client *Client) getThreadHandleResponse(resp *http.Response) (GetThreadResponse, error) {
	result := GetThreadResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AssistantThread); err != nil {
		return GetThreadResponse{}, err
	}
	return result, nil
}

// GetVectorStore - Returns the vector store object matching the specified ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - vectorStoreID - The ID of the vector store to retrieve.
//   - options - GetVectorStoreOptions contains the optional parameters for the Client.GetVectorStore method.
func (client *Client) GetVectorStore(ctx context.Context, vectorStoreID string, options *GetVectorStoreOptions) (GetVectorStoreResponse, error) {
	var err error
	req, err := client.getVectorStoreCreateRequest(ctx, vectorStoreID, options)
	if err != nil {
		return GetVectorStoreResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetVectorStoreResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetVectorStoreResponse{}, err
	}
	resp, err := client.getVectorStoreHandleResponse(httpResp)
	return resp, err
}

// getVectorStoreCreateRequest creates the GetVectorStore request.
func (client *Client) getVectorStoreCreateRequest(ctx context.Context, vectorStoreID string, options *GetVectorStoreOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores/{vectorStoreId}")
	if vectorStoreID == "" {
		return nil, errors.New("parameter vectorStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vectorStoreId}", url.PathEscape(vectorStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVectorStoreHandleResponse handles the GetVectorStore response.
func (client *Client) getVectorStoreHandleResponse(resp *http.Response) (GetVectorStoreResponse, error) {
	result := GetVectorStoreResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStore); err != nil {
		return GetVectorStoreResponse{}, err
	}
	return result, nil
}

// GetVectorStoreFile - Retrieves a vector store file.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - vectorStoreID - The ID of the vector store that the file belongs to.
//   - fileID - The ID of the file being retrieved.
//   - options - GetVectorStoreFileOptions contains the optional parameters for the Client.GetVectorStoreFile method.
func (client *Client) GetVectorStoreFile(ctx context.Context, vectorStoreID string, fileID string, options *GetVectorStoreFileOptions) (GetVectorStoreFileResponse, error) {
	var err error
	req, err := client.getVectorStoreFileCreateRequest(ctx, vectorStoreID, fileID, options)
	if err != nil {
		return GetVectorStoreFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetVectorStoreFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetVectorStoreFileResponse{}, err
	}
	resp, err := client.getVectorStoreFileHandleResponse(httpResp)
	return resp, err
}

// getVectorStoreFileCreateRequest creates the GetVectorStoreFile request.
func (client *Client) getVectorStoreFileCreateRequest(ctx context.Context, vectorStoreID string, fileID string, options *GetVectorStoreFileOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores/{vectorStoreId}/files/{fileId}")
	if vectorStoreID == "" {
		return nil, errors.New("parameter vectorStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vectorStoreId}", url.PathEscape(vectorStoreID))
	if fileID == "" {
		return nil, errors.New("parameter fileID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{fileId}", url.PathEscape(fileID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVectorStoreFileHandleResponse handles the GetVectorStoreFile response.
func (client *Client) getVectorStoreFileHandleResponse(resp *http.Response) (GetVectorStoreFileResponse, error) {
	result := GetVectorStoreFileResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStoreFile); err != nil {
		return GetVectorStoreFileResponse{}, err
	}
	return result, nil
}

// GetVectorStoreFileBatch - Retrieve a vector store file batch.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - vectorStoreID - The ID of the vector store that the file batch belongs to.
//   - batchID - The ID of the file batch being retrieved.
//   - options - GetVectorStoreFileBatchOptions contains the optional parameters for the Client.GetVectorStoreFileBatch
//     method.
func (client *Client) GetVectorStoreFileBatch(ctx context.Context, vectorStoreID string, batchID string, options *GetVectorStoreFileBatchOptions) (GetVectorStoreFileBatchResponse, error) {
	var err error
	req, err := client.getVectorStoreFileBatchCreateRequest(ctx, vectorStoreID, batchID, options)
	if err != nil {
		return GetVectorStoreFileBatchResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetVectorStoreFileBatchResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetVectorStoreFileBatchResponse{}, err
	}
	resp, err := client.getVectorStoreFileBatchHandleResponse(httpResp)
	return resp, err
}

// getVectorStoreFileBatchCreateRequest creates the GetVectorStoreFileBatch request.
func (client *Client) getVectorStoreFileBatchCreateRequest(ctx context.Context, vectorStoreID string, batchID string, options *GetVectorStoreFileBatchOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores/{vectorStoreId}/file_batches/{batchId}")
	if vectorStoreID == "" {
		return nil, errors.New("parameter vectorStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vectorStoreId}", url.PathEscape(vectorStoreID))
	if batchID == "" {
		return nil, errors.New("parameter batchID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{batchId}", url.PathEscape(batchID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVectorStoreFileBatchHandleResponse handles the GetVectorStoreFileBatch response.
func (client *Client) getVectorStoreFileBatchHandleResponse(resp *http.Response) (GetVectorStoreFileBatchResponse, error) {
	result := GetVectorStoreFileBatchResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStoreFileBatch); err != nil {
		return GetVectorStoreFileBatchResponse{}, err
	}
	return result, nil
}

// ListAssistants - Gets a list of assistants that were previously created.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - options - ListAssistantsOptions contains the optional parameters for the Client.ListAssistants method.
func (client *Client) internalListAssistants(ctx context.Context, options *ListAssistantsOptions) (ListAssistantsResponse, error) {
	var err error
	req, err := client.listAssistantsCreateRequest(ctx, options)
	if err != nil {
		return ListAssistantsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ListAssistantsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ListAssistantsResponse{}, err
	}
	resp, err := client.listAssistantsHandleResponse(httpResp)
	return resp, err
}

// listAssistantsCreateRequest creates the ListAssistants request.
func (client *Client) listAssistantsCreateRequest(ctx context.Context, options *ListAssistantsOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/assistants")
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.After != nil {
		reqQP.Set("after", *options.After)
	}
	if options != nil && options.Before != nil {
		reqQP.Set("before", *options.Before)
	}
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Order != nil {
		reqQP.Set("order", string(*options.Order))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAssistantsHandleResponse handles the ListAssistants response.
func (client *Client) listAssistantsHandleResponse(resp *http.Response) (ListAssistantsResponse, error) {
	result := ListAssistantsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AssistantsPage); err != nil {
		return ListAssistantsResponse{}, err
	}
	return result, nil
}

// ListFiles - Gets a list of previously uploaded files.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - options - ListFilesOptions contains the optional parameters for the Client.ListFiles method.
func (client *Client) ListFiles(ctx context.Context, options *ListFilesOptions) (ListFilesResponse, error) {
	var err error
	req, err := client.listFilesCreateRequest(ctx, options)
	if err != nil {
		return ListFilesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ListFilesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ListFilesResponse{}, err
	}
	resp, err := client.listFilesHandleResponse(httpResp)
	return resp, err
}

// listFilesCreateRequest creates the ListFiles request.
func (client *Client) listFilesCreateRequest(ctx context.Context, options *ListFilesOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/files")
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Purpose != nil {
		reqQP.Set("purpose", string(*options.Purpose))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFilesHandleResponse handles the ListFiles response.
func (client *Client) listFilesHandleResponse(resp *http.Response) (ListFilesResponse, error) {
	result := ListFilesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FileListResponse); err != nil {
		return ListFilesResponse{}, err
	}
	return result, nil
}

// ListMessages - Gets a list of messages that exist on a thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread to list messages from.
//   - options - ListMessagesOptions contains the optional parameters for the Client.ListMessages method.
func (client *Client) internalListMessages(ctx context.Context, threadID string, options *ListMessagesOptions) (ListMessagesResponse, error) {
	var err error
	req, err := client.listMessagesCreateRequest(ctx, threadID, options)
	if err != nil {
		return ListMessagesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ListMessagesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ListMessagesResponse{}, err
	}
	resp, err := client.listMessagesHandleResponse(httpResp)
	return resp, err
}

// listMessagesCreateRequest creates the ListMessages request.
func (client *Client) listMessagesCreateRequest(ctx context.Context, threadID string, options *ListMessagesOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}/messages")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.After != nil {
		reqQP.Set("after", *options.After)
	}
	if options != nil && options.Before != nil {
		reqQP.Set("before", *options.Before)
	}
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Order != nil {
		reqQP.Set("order", string(*options.Order))
	}
	if options != nil && options.RunID != nil {
		reqQP.Set("runId", *options.RunID)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listMessagesHandleResponse handles the ListMessages response.
func (client *Client) listMessagesHandleResponse(resp *http.Response) (ListMessagesResponse, error) {
	result := ListMessagesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadMessagesPage); err != nil {
		return ListMessagesResponse{}, err
	}
	return result, nil
}

// ListRunSteps - Gets a list of run steps from a thread run.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread that was run.
//   - runID - The ID of the run to list steps from.
//   - options - ListRunStepsOptions contains the optional parameters for the Client.ListRunSteps method.
func (client *Client) internalListRunSteps(ctx context.Context, threadID string, runID string, options *ListRunStepsOptions) (ListRunStepsResponse, error) {
	var err error
	req, err := client.listRunStepsCreateRequest(ctx, threadID, runID, options)
	if err != nil {
		return ListRunStepsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ListRunStepsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ListRunStepsResponse{}, err
	}
	resp, err := client.listRunStepsHandleResponse(httpResp)
	return resp, err
}

// listRunStepsCreateRequest creates the ListRunSteps request.
func (client *Client) listRunStepsCreateRequest(ctx context.Context, threadID string, runID string, options *ListRunStepsOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}/runs/{runId}/steps")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	if runID == "" {
		return nil, errors.New("parameter runID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{runId}", url.PathEscape(runID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.After != nil {
		reqQP.Set("after", *options.After)
	}
	if options != nil && options.Before != nil {
		reqQP.Set("before", *options.Before)
	}
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Order != nil {
		reqQP.Set("order", string(*options.Order))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listRunStepsHandleResponse handles the ListRunSteps response.
func (client *Client) listRunStepsHandleResponse(resp *http.Response) (ListRunStepsResponse, error) {
	result := ListRunStepsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadRunStepsPage); err != nil {
		return ListRunStepsResponse{}, err
	}
	return result, nil
}

// ListRuns - Gets a list of runs for a specified thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread to list runs from.
//   - options - ListRunsOptions contains the optional parameters for the Client.ListRuns method.
func (client *Client) internalListRuns(ctx context.Context, threadID string, options *ListRunsOptions) (ListRunsResponse, error) {
	var err error
	req, err := client.listRunsCreateRequest(ctx, threadID, options)
	if err != nil {
		return ListRunsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ListRunsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ListRunsResponse{}, err
	}
	resp, err := client.listRunsHandleResponse(httpResp)
	return resp, err
}

// listRunsCreateRequest creates the ListRuns request.
func (client *Client) listRunsCreateRequest(ctx context.Context, threadID string, options *ListRunsOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}/runs")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.After != nil {
		reqQP.Set("after", *options.After)
	}
	if options != nil && options.Before != nil {
		reqQP.Set("before", *options.Before)
	}
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Order != nil {
		reqQP.Set("order", string(*options.Order))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listRunsHandleResponse handles the ListRuns response.
func (client *Client) listRunsHandleResponse(resp *http.Response) (ListRunsResponse, error) {
	result := ListRunsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadRunsPage); err != nil {
		return ListRunsResponse{}, err
	}
	return result, nil
}

// ListVectorStoreFileBatchFiles - Returns a list of vector store files in a batch.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - vectorStoreID - The ID of the vector store that the file batch belongs to.
//   - batchID - The ID of the file batch that the files belong to.
//   - options - ListVectorStoreFileBatchFilesOptions contains the optional parameters for the Client.ListVectorStoreFileBatchFiles
//     method.
func (client *Client) internalListVectorStoreFileBatchFiles(ctx context.Context, vectorStoreID string, batchID string, options *ListVectorStoreFileBatchFilesOptions) (ListVectorStoreFileBatchFilesResponse, error) {
	var err error
	req, err := client.listVectorStoreFileBatchFilesCreateRequest(ctx, vectorStoreID, batchID, options)
	if err != nil {
		return ListVectorStoreFileBatchFilesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ListVectorStoreFileBatchFilesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ListVectorStoreFileBatchFilesResponse{}, err
	}
	resp, err := client.listVectorStoreFileBatchFilesHandleResponse(httpResp)
	return resp, err
}

// listVectorStoreFileBatchFilesCreateRequest creates the ListVectorStoreFileBatchFiles request.
func (client *Client) listVectorStoreFileBatchFilesCreateRequest(ctx context.Context, vectorStoreID string, batchID string, options *ListVectorStoreFileBatchFilesOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores/{vectorStoreId}/file_batches/{batchId}/files")
	if vectorStoreID == "" {
		return nil, errors.New("parameter vectorStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vectorStoreId}", url.PathEscape(vectorStoreID))
	if batchID == "" {
		return nil, errors.New("parameter batchID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{batchId}", url.PathEscape(batchID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.After != nil {
		reqQP.Set("after", *options.After)
	}
	if options != nil && options.Before != nil {
		reqQP.Set("before", *options.Before)
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", string(*options.Filter))
	}
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Order != nil {
		reqQP.Set("order", string(*options.Order))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listVectorStoreFileBatchFilesHandleResponse handles the ListVectorStoreFileBatchFiles response.
func (client *Client) listVectorStoreFileBatchFilesHandleResponse(resp *http.Response) (ListVectorStoreFileBatchFilesResponse, error) {
	result := ListVectorStoreFileBatchFilesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStoreFileBatchesPage); err != nil {
		return ListVectorStoreFileBatchFilesResponse{}, err
	}
	return result, nil
}

// ListVectorStoreFiles - Returns a list of vector store files.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - vectorStoreID - The ID of the vector store that the files belong to.
//   - options - ListVectorStoreFilesOptions contains the optional parameters for the Client.ListVectorStoreFiles method.
func (client *Client) internalListVectorStoreFiles(ctx context.Context, vectorStoreID string, options *ListVectorStoreFilesOptions) (ListVectorStoreFilesResponse, error) {
	var err error
	req, err := client.listVectorStoreFilesCreateRequest(ctx, vectorStoreID, options)
	if err != nil {
		return ListVectorStoreFilesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ListVectorStoreFilesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ListVectorStoreFilesResponse{}, err
	}
	resp, err := client.listVectorStoreFilesHandleResponse(httpResp)
	return resp, err
}

// listVectorStoreFilesCreateRequest creates the ListVectorStoreFiles request.
func (client *Client) listVectorStoreFilesCreateRequest(ctx context.Context, vectorStoreID string, options *ListVectorStoreFilesOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores/{vectorStoreId}/files")
	if vectorStoreID == "" {
		return nil, errors.New("parameter vectorStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vectorStoreId}", url.PathEscape(vectorStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.After != nil {
		reqQP.Set("after", *options.After)
	}
	if options != nil && options.Before != nil {
		reqQP.Set("before", *options.Before)
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", string(*options.Filter))
	}
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Order != nil {
		reqQP.Set("order", string(*options.Order))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listVectorStoreFilesHandleResponse handles the ListVectorStoreFiles response.
func (client *Client) listVectorStoreFilesHandleResponse(resp *http.Response) (ListVectorStoreFilesResponse, error) {
	result := ListVectorStoreFilesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStoreFilesPage); err != nil {
		return ListVectorStoreFilesResponse{}, err
	}
	return result, nil
}

// ListVectorStores - Returns a list of vector stores.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - options - ListVectorStoresOptions contains the optional parameters for the Client.ListVectorStores method.
func (client *Client) internalListVectorStores(ctx context.Context, options *ListVectorStoresOptions) (ListVectorStoresResponse, error) {
	var err error
	req, err := client.listVectorStoresCreateRequest(ctx, options)
	if err != nil {
		return ListVectorStoresResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ListVectorStoresResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ListVectorStoresResponse{}, err
	}
	resp, err := client.listVectorStoresHandleResponse(httpResp)
	return resp, err
}

// listVectorStoresCreateRequest creates the ListVectorStores request.
func (client *Client) listVectorStoresCreateRequest(ctx context.Context, options *ListVectorStoresOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores")
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.After != nil {
		reqQP.Set("after", *options.After)
	}
	if options != nil && options.Before != nil {
		reqQP.Set("before", *options.Before)
	}
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Order != nil {
		reqQP.Set("order", string(*options.Order))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listVectorStoresHandleResponse handles the ListVectorStores response.
func (client *Client) listVectorStoresHandleResponse(resp *http.Response) (ListVectorStoresResponse, error) {
	result := ListVectorStoresResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStoresPage); err != nil {
		return ListVectorStoresResponse{}, err
	}
	return result, nil
}

// ModifyVectorStore - The ID of the vector store to modify.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - vectorStoreID - The ID of the vector store to modify.
//   - options - ModifyVectorStoreOptions contains the optional parameters for the Client.ModifyVectorStore method.
func (client *Client) ModifyVectorStore(ctx context.Context, vectorStoreID string, body VectorStoreUpdateBody, options *ModifyVectorStoreOptions) (ModifyVectorStoreResponse, error) {
	var err error
	req, err := client.modifyVectorStoreCreateRequest(ctx, vectorStoreID, body, options)
	if err != nil {
		return ModifyVectorStoreResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModifyVectorStoreResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ModifyVectorStoreResponse{}, err
	}
	resp, err := client.modifyVectorStoreHandleResponse(httpResp)
	return resp, err
}

// modifyVectorStoreCreateRequest creates the ModifyVectorStore request.
func (client *Client) modifyVectorStoreCreateRequest(ctx context.Context, vectorStoreID string, body VectorStoreUpdateBody, options *ModifyVectorStoreOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/vector_stores/{vectorStoreId}")
	if vectorStoreID == "" {
		return nil, errors.New("parameter vectorStoreID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vectorStoreId}", url.PathEscape(vectorStoreID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// modifyVectorStoreHandleResponse handles the ModifyVectorStore response.
func (client *Client) modifyVectorStoreHandleResponse(resp *http.Response) (ModifyVectorStoreResponse, error) {
	result := ModifyVectorStoreResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VectorStore); err != nil {
		return ModifyVectorStoreResponse{}, err
	}
	return result, nil
}

// SubmitToolOutputsToRun - Submits outputs from tools as requested by tool calls in a run. Runs that need submitted tool
// outputs will have a status of 'requiresaction' with a requiredaction.type of 'submittooloutputs'.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread that was run.
//   - runID - The ID of the run that requires tool outputs.
//   - options - SubmitToolOutputsToRunOptions contains the optional parameters for the Client.SubmitToolOutputsToRun method.
func (client *Client) SubmitToolOutputsToRun(ctx context.Context, threadID string, runID string, body SubmitToolOutputsToRunBody, options *SubmitToolOutputsToRunOptions) (SubmitToolOutputsToRunResponse, error) {
	var err error
	req, err := client.submitToolOutputsToRunCreateRequest(ctx, threadID, runID, body, options)
	if err != nil {
		return SubmitToolOutputsToRunResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SubmitToolOutputsToRunResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return SubmitToolOutputsToRunResponse{}, err
	}
	resp, err := client.submitToolOutputsToRunHandleResponse(httpResp)
	return resp, err
}

// submitToolOutputsToRunCreateRequest creates the SubmitToolOutputsToRun request.
func (client *Client) submitToolOutputsToRunCreateRequest(ctx context.Context, threadID string, runID string, body SubmitToolOutputsToRunBody, options *SubmitToolOutputsToRunOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}/runs/{runId}/submit_tool_outputs")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	if runID == "" {
		return nil, errors.New("parameter runID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{runId}", url.PathEscape(runID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// submitToolOutputsToRunHandleResponse handles the SubmitToolOutputsToRun response.
func (client *Client) submitToolOutputsToRunHandleResponse(resp *http.Response) (SubmitToolOutputsToRunResponse, error) {
	result := SubmitToolOutputsToRunResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadRun); err != nil {
		return SubmitToolOutputsToRunResponse{}, err
	}
	return result, nil
}

// UpdateAssistant - Modifies an existing assistant.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - assistantID - The ID of the assistant to modify.
//   - options - UpdateAssistantOptions contains the optional parameters for the Client.UpdateAssistant method.
func (client *Client) UpdateAssistant(ctx context.Context, assistantID string, body UpdateAssistantBody, options *UpdateAssistantOptions) (UpdateAssistantResponse, error) {
	var err error
	req, err := client.updateAssistantCreateRequest(ctx, assistantID, body, options)
	if err != nil {
		return UpdateAssistantResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return UpdateAssistantResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return UpdateAssistantResponse{}, err
	}
	resp, err := client.updateAssistantHandleResponse(httpResp)
	return resp, err
}

// updateAssistantCreateRequest creates the UpdateAssistant request.
func (client *Client) updateAssistantCreateRequest(ctx context.Context, assistantID string, body UpdateAssistantBody, options *UpdateAssistantOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/assistants/{assistantId}")
	if assistantID == "" {
		return nil, errors.New("parameter assistantID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{assistantId}", url.PathEscape(assistantID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// updateAssistantHandleResponse handles the UpdateAssistant response.
func (client *Client) updateAssistantHandleResponse(resp *http.Response) (UpdateAssistantResponse, error) {
	result := UpdateAssistantResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Assistant); err != nil {
		return UpdateAssistantResponse{}, err
	}
	return result, nil
}

// UpdateMessage - Modifies an existing message on an existing thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread containing the specified message to modify.
//   - messageID - The ID of the message to modify on the specified thread.
//   - options - UpdateMessageOptions contains the optional parameters for the Client.UpdateMessage method.
func (client *Client) UpdateMessage(ctx context.Context, threadID string, messageID string, body UpdateMessageBody, options *UpdateMessageOptions) (UpdateMessageResponse, error) {
	var err error
	req, err := client.updateMessageCreateRequest(ctx, threadID, messageID, body, options)
	if err != nil {
		return UpdateMessageResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return UpdateMessageResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return UpdateMessageResponse{}, err
	}
	resp, err := client.updateMessageHandleResponse(httpResp)
	return resp, err
}

// updateMessageCreateRequest creates the UpdateMessage request.
func (client *Client) updateMessageCreateRequest(ctx context.Context, threadID string, messageID string, body UpdateMessageBody, options *UpdateMessageOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}/messages/{messageId}")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	if messageID == "" {
		return nil, errors.New("parameter messageID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{messageId}", url.PathEscape(messageID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// updateMessageHandleResponse handles the UpdateMessage response.
func (client *Client) updateMessageHandleResponse(resp *http.Response) (UpdateMessageResponse, error) {
	result := UpdateMessageResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadMessage); err != nil {
		return UpdateMessageResponse{}, err
	}
	return result, nil
}

// UpdateRun - Modifies an existing thread run.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread associated with the specified run.
//   - runID - The ID of the run to modify.
//   - options - UpdateRunOptions contains the optional parameters for the Client.UpdateRun method.
func (client *Client) UpdateRun(ctx context.Context, threadID string, runID string, body UpdateRunBody, options *UpdateRunOptions) (UpdateRunResponse, error) {
	var err error
	req, err := client.updateRunCreateRequest(ctx, threadID, runID, body, options)
	if err != nil {
		return UpdateRunResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return UpdateRunResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return UpdateRunResponse{}, err
	}
	resp, err := client.updateRunHandleResponse(httpResp)
	return resp, err
}

// updateRunCreateRequest creates the UpdateRun request.
func (client *Client) updateRunCreateRequest(ctx context.Context, threadID string, runID string, body UpdateRunBody, options *UpdateRunOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}/runs/{runId}")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	if runID == "" {
		return nil, errors.New("parameter runID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{runId}", url.PathEscape(runID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// updateRunHandleResponse handles the UpdateRun response.
func (client *Client) updateRunHandleResponse(resp *http.Response) (UpdateRunResponse, error) {
	result := UpdateRunResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadRun); err != nil {
		return UpdateRunResponse{}, err
	}
	return result, nil
}

// UpdateThread - Modifies an existing thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - threadID - The ID of the thread to modify.
//   - options - UpdateThreadOptions contains the optional parameters for the Client.UpdateThread method.
func (client *Client) UpdateThread(ctx context.Context, threadID string, body UpdateThreadBody, options *UpdateThreadOptions) (UpdateThreadResponse, error) {
	var err error
	req, err := client.updateThreadCreateRequest(ctx, threadID, body, options)
	if err != nil {
		return UpdateThreadResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return UpdateThreadResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return UpdateThreadResponse{}, err
	}
	resp, err := client.updateThreadHandleResponse(httpResp)
	return resp, err
}

// updateThreadCreateRequest creates the UpdateThread request.
func (client *Client) updateThreadCreateRequest(ctx context.Context, threadID string, body UpdateThreadBody, options *UpdateThreadOptions) (*policy.Request, error) {
	urlPath := client.formatURL("/threads/{threadId}")
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// updateThreadHandleResponse handles the UpdateThread response.
func (client *Client) updateThreadHandleResponse(resp *http.Response) (UpdateThreadResponse, error) {
	result := UpdateThreadResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AssistantThread); err != nil {
		return UpdateThreadResponse{}, err
	}
	return result, nil
}

// UploadFile - Uploads a file for use by other operations.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-05-01-preview
//   - file - The file data (not filename) to upload.
//   - purpose - The intended purpose of the file.
//   - options - UploadFileOptions contains the optional parameters for the Client.UploadFile method.
func (client *Client) UploadFile(ctx context.Context, file io.ReadSeeker, purpose FilePurpose, options *UploadFileOptions) (UploadFileResponse, error) {
	var err error
	req, err := client.uploadFileCreateRequest(ctx, file, purpose, options)
	if err != nil {
		return UploadFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return UploadFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return UploadFileResponse{}, err
	}
	resp, err := client.uploadFileHandleResponse(httpResp)
	return resp, err
}

// uploadFileHandleResponse handles the UploadFile response.
func (client *Client) uploadFileHandleResponse(resp *http.Response) (UploadFileResponse, error) {
	result := UploadFileResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.OpenAIFile); err != nil {
		return UploadFileResponse{}, err
	}
	return result, nil
}
