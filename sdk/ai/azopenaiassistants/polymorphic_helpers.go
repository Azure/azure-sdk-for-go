//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azopenaiassistants

import "encoding/json"

func unmarshalMessageContentClassification(rawMsg json.RawMessage) (MessageContentClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b MessageContentClassification
	switch m["type"] {
	case "image_file":
		b = &MessageImageFileContent{}
	case "text":
		b = &MessageTextContent{}
	default:
		b = &MessageContent{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalMessageContentClassificationArray(rawMsg json.RawMessage) ([]MessageContentClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]MessageContentClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalMessageContentClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalMessageDeltaContentClassification(rawMsg json.RawMessage) (MessageDeltaContentClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b MessageDeltaContentClassification
	switch m["type"] {
	case "image_file":
		b = &MessageDeltaImageFileContent{}
	case "text":
		b = &MessageDeltaTextContentObject{}
	default:
		b = &MessageDeltaContent{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalMessageDeltaContentClassificationArray(rawMsg json.RawMessage) ([]MessageDeltaContentClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]MessageDeltaContentClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalMessageDeltaContentClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalMessageDeltaTextAnnotationClassification(rawMsg json.RawMessage) (MessageDeltaTextAnnotationClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b MessageDeltaTextAnnotationClassification
	switch m["type"] {
	case "file_citation":
		b = &MessageDeltaTextFileCitationAnnotationObject{}
	case "file_path":
		b = &MessageDeltaTextFilePathAnnotationObject{}
	default:
		b = &MessageDeltaTextAnnotation{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalMessageDeltaTextAnnotationClassificationArray(rawMsg json.RawMessage) ([]MessageDeltaTextAnnotationClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]MessageDeltaTextAnnotationClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalMessageDeltaTextAnnotationClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalMessageTextAnnotationClassification(rawMsg json.RawMessage) (MessageTextAnnotationClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b MessageTextAnnotationClassification
	switch m["type"] {
	case "file_citation":
		b = &MessageTextFileCitationAnnotation{}
	case "file_path":
		b = &MessageTextFilePathAnnotation{}
	default:
		b = &MessageTextAnnotation{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalMessageTextAnnotationClassificationArray(rawMsg json.RawMessage) ([]MessageTextAnnotationClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]MessageTextAnnotationClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalMessageTextAnnotationClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalRequiredActionClassification(rawMsg json.RawMessage) (RequiredActionClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b RequiredActionClassification
	switch m["type"] {
	case "submit_tool_outputs":
		b = &SubmitToolOutputsAction{}
	default:
		b = &RequiredAction{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalRequiredToolCallClassification(rawMsg json.RawMessage) (RequiredToolCallClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b RequiredToolCallClassification
	switch m["type"] {
	case "function":
		b = &RequiredFunctionToolCall{}
	default:
		b = &RequiredToolCall{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalRequiredToolCallClassificationArray(rawMsg json.RawMessage) ([]RequiredToolCallClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]RequiredToolCallClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalRequiredToolCallClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalRunStepCodeInterpreterToolCallOutputClassification(rawMsg json.RawMessage) (RunStepCodeInterpreterToolCallOutputClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b RunStepCodeInterpreterToolCallOutputClassification
	switch m["type"] {
	case "image":
		b = &RunStepCodeInterpreterImageOutput{}
	case "logs":
		b = &RunStepCodeInterpreterLogOutput{}
	default:
		b = &RunStepCodeInterpreterToolCallOutput{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalRunStepCodeInterpreterToolCallOutputClassificationArray(rawMsg json.RawMessage) ([]RunStepCodeInterpreterToolCallOutputClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]RunStepCodeInterpreterToolCallOutputClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalRunStepCodeInterpreterToolCallOutputClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalRunStepDeltaCodeInterpreterOutputClassification(rawMsg json.RawMessage) (RunStepDeltaCodeInterpreterOutputClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b RunStepDeltaCodeInterpreterOutputClassification
	switch m["type"] {
	case "image":
		b = &RunStepDeltaCodeInterpreterImageOutput{}
	case "logs":
		b = &RunStepDeltaCodeInterpreterLogOutput{}
	default:
		b = &RunStepDeltaCodeInterpreterOutput{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalRunStepDeltaCodeInterpreterOutputClassificationArray(rawMsg json.RawMessage) ([]RunStepDeltaCodeInterpreterOutputClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]RunStepDeltaCodeInterpreterOutputClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalRunStepDeltaCodeInterpreterOutputClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalRunStepDeltaDetailClassification(rawMsg json.RawMessage) (RunStepDeltaDetailClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b RunStepDeltaDetailClassification
	switch m["type"] {
	case "message_creation":
		b = &RunStepDeltaMessageCreation{}
	case "tool_calls":
		b = &RunStepDeltaToolCallObject{}
	default:
		b = &RunStepDeltaDetail{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalRunStepDeltaToolCallClassification(rawMsg json.RawMessage) (RunStepDeltaToolCallClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b RunStepDeltaToolCallClassification
	switch m["type"] {
	case "code_interpreter":
		b = &RunStepDeltaCodeInterpreterToolCall{}
	case "file_search":
		b = &RunStepDeltaFileSearchToolCall{}
	case "function":
		b = &RunStepDeltaFunctionToolCall{}
	default:
		b = &RunStepDeltaToolCall{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalRunStepDeltaToolCallClassificationArray(rawMsg json.RawMessage) ([]RunStepDeltaToolCallClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]RunStepDeltaToolCallClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalRunStepDeltaToolCallClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalRunStepDetailsClassification(rawMsg json.RawMessage) (RunStepDetailsClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b RunStepDetailsClassification
	switch m["type"] {
	case string(RunStepTypeMessageCreation):
		b = &RunStepMessageCreationDetails{}
	case string(RunStepTypeToolCalls):
		b = &RunStepToolCallDetails{}
	default:
		b = &RunStepDetails{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalRunStepToolCallClassification(rawMsg json.RawMessage) (RunStepToolCallClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b RunStepToolCallClassification
	switch m["type"] {
	case "code_interpreter":
		b = &RunStepCodeInterpreterToolCall{}
	case "file_search":
		b = &RunStepFileSearchToolCall{}
	case "function":
		b = &RunStepFunctionToolCall{}
	default:
		b = &RunStepToolCall{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalRunStepToolCallClassificationArray(rawMsg json.RawMessage) ([]RunStepToolCallClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]RunStepToolCallClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalRunStepToolCallClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalToolDefinitionClassification(rawMsg json.RawMessage) (ToolDefinitionClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b ToolDefinitionClassification
	switch m["type"] {
	case "code_interpreter":
		b = &CodeInterpreterToolDefinition{}
	case "file_search":
		b = &FileSearchToolDefinition{}
	case "function":
		b = &FunctionToolDefinition{}
	default:
		b = &ToolDefinition{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalToolDefinitionClassificationArray(rawMsg json.RawMessage) ([]ToolDefinitionClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ToolDefinitionClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalToolDefinitionClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}
