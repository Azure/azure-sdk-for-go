//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azopenaiextensions

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// MarshalJSON implements the json.Marshaller interface for type AzureChatEnhancementConfiguration.
func (a AzureChatEnhancementConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "grounding", a.Grounding)
	populate(objectMap, "ocr", a.Ocr)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureChatEnhancementConfiguration.
func (a *AzureChatEnhancementConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "grounding":
			err = unpopulate(val, "Grounding", &a.Grounding)
			delete(rawMsg, key)
		case "ocr":
			err = unpopulate(val, "Ocr", &a.Ocr)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureChatEnhancements.
func (a AzureChatEnhancements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "grounding", a.Grounding)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureChatEnhancements.
func (a *AzureChatEnhancements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "grounding":
			err = unpopulate(val, "Grounding", &a.Grounding)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureChatExtensionConfiguration.
func (a AzureChatExtensionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = a.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureChatExtensionConfiguration.
func (a *AzureChatExtensionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureChatExtensionDataSourceResponseCitation.
func (a AzureChatExtensionDataSourceResponseCitation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "chunk_id", a.ChunkID)
	populate(objectMap, "content", a.Content)
	populate(objectMap, "filepath", a.Filepath)
	populate(objectMap, "title", a.Title)
	populate(objectMap, "url", a.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureChatExtensionDataSourceResponseCitation.
func (a *AzureChatExtensionDataSourceResponseCitation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "chunk_id":
			err = unpopulate(val, "ChunkID", &a.ChunkID)
			delete(rawMsg, key)
		case "content":
			err = unpopulate(val, "Content", &a.Content)
			delete(rawMsg, key)
		case "filepath":
			err = unpopulate(val, "Filepath", &a.Filepath)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, "Title", &a.Title)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &a.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureChatExtensionRetrievedDocument.
func (a AzureChatExtensionRetrievedDocument) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "chunk_id", a.ChunkID)
	populate(objectMap, "content", a.Content)
	populate(objectMap, "data_source_index", a.DataSourceIndex)
	populate(objectMap, "filepath", a.Filepath)
	populate(objectMap, "filter_reason", a.FilterReason)
	populate(objectMap, "original_search_score", a.OriginalSearchScore)
	populate(objectMap, "rerank_score", a.RerankScore)
	populate(objectMap, "search_queries", a.SearchQueries)
	populate(objectMap, "title", a.Title)
	populate(objectMap, "url", a.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureChatExtensionRetrievedDocument.
func (a *AzureChatExtensionRetrievedDocument) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "chunk_id":
			err = unpopulate(val, "ChunkID", &a.ChunkID)
			delete(rawMsg, key)
		case "content":
			err = unpopulate(val, "Content", &a.Content)
			delete(rawMsg, key)
		case "data_source_index":
			err = unpopulate(val, "DataSourceIndex", &a.DataSourceIndex)
			delete(rawMsg, key)
		case "filepath":
			err = unpopulate(val, "Filepath", &a.Filepath)
			delete(rawMsg, key)
		case "filter_reason":
			err = unpopulate(val, "FilterReason", &a.FilterReason)
			delete(rawMsg, key)
		case "original_search_score":
			err = unpopulate(val, "OriginalSearchScore", &a.OriginalSearchScore)
			delete(rawMsg, key)
		case "rerank_score":
			err = unpopulate(val, "RerankScore", &a.RerankScore)
			delete(rawMsg, key)
		case "search_queries":
			err = unpopulate(val, "SearchQueries", &a.SearchQueries)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, "Title", &a.Title)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &a.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureChatExtensionsMessageContext.
func (a AzureChatExtensionsMessageContext) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "all_retrieved_documents", a.AllRetrievedDocuments)
	populate(objectMap, "citations", a.Citations)
	populate(objectMap, "intent", a.Intent)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureChatExtensionsMessageContext.
func (a *AzureChatExtensionsMessageContext) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "all_retrieved_documents":
			err = unpopulate(val, "AllRetrievedDocuments", &a.AllRetrievedDocuments)
			delete(rawMsg, key)
		case "citations":
			err = unpopulate(val, "Citations", &a.Citations)
			delete(rawMsg, key)
		case "intent":
			err = unpopulate(val, "Intent", &a.Intent)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureChatGroundingEnhancementConfiguration.
func (a AzureChatGroundingEnhancementConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enabled", a.Enabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureChatGroundingEnhancementConfiguration.
func (a *AzureChatGroundingEnhancementConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enabled":
			err = unpopulate(val, "Enabled", &a.Enabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureChatOCREnhancementConfiguration.
func (a AzureChatOCREnhancementConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enabled", a.Enabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureChatOCREnhancementConfiguration.
func (a *AzureChatOCREnhancementConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enabled":
			err = unpopulate(val, "Enabled", &a.Enabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureCosmosDBChatExtensionConfiguration.
func (a AzureCosmosDBChatExtensionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = AzureChatExtensionTypeAzureCosmosDB
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureCosmosDBChatExtensionConfiguration.
func (a *AzureCosmosDBChatExtensionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureCosmosDBChatExtensionParameters.
func (a AzureCosmosDBChatExtensionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allow_partial_result", a.AllowPartialResult)
	populate(objectMap, "authentication", a.Authentication)
	populate(objectMap, "container_name", a.ContainerName)
	populate(objectMap, "database_name", a.DatabaseName)
	populate(objectMap, "embedding_dependency", a.EmbeddingDependency)
	populate(objectMap, "fields_mapping", a.FieldsMapping)
	populate(objectMap, "in_scope", a.InScope)
	populate(objectMap, "include_contexts", a.IncludeContexts)
	populate(objectMap, "index_name", a.IndexName)
	populate(objectMap, "max_search_queries", a.MaxSearchQueries)
	populate(objectMap, "role_information", a.RoleInformation)
	populate(objectMap, "strictness", a.Strictness)
	populate(objectMap, "top_n_documents", a.TopNDocuments)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureCosmosDBChatExtensionParameters.
func (a *AzureCosmosDBChatExtensionParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allow_partial_result":
			err = unpopulate(val, "AllowPartialResult", &a.AllowPartialResult)
			delete(rawMsg, key)
		case "authentication":
			a.Authentication, err = unmarshalOnYourDataAuthenticationOptionsClassification(val)
			delete(rawMsg, key)
		case "container_name":
			err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "database_name":
			err = unpopulate(val, "DatabaseName", &a.DatabaseName)
			delete(rawMsg, key)
		case "embedding_dependency":
			a.EmbeddingDependency, err = unmarshalOnYourDataVectorizationSourceClassification(val)
			delete(rawMsg, key)
		case "fields_mapping":
			err = unpopulate(val, "FieldsMapping", &a.FieldsMapping)
			delete(rawMsg, key)
		case "in_scope":
			err = unpopulate(val, "InScope", &a.InScope)
			delete(rawMsg, key)
		case "include_contexts":
			err = unpopulate(val, "IncludeContexts", &a.IncludeContexts)
			delete(rawMsg, key)
		case "index_name":
			err = unpopulate(val, "IndexName", &a.IndexName)
			delete(rawMsg, key)
		case "max_search_queries":
			err = unpopulate(val, "MaxSearchQueries", &a.MaxSearchQueries)
			delete(rawMsg, key)
		case "role_information":
			err = unpopulate(val, "RoleInformation", &a.RoleInformation)
			delete(rawMsg, key)
		case "strictness":
			err = unpopulate(val, "Strictness", &a.Strictness)
			delete(rawMsg, key)
		case "top_n_documents":
			err = unpopulate(val, "TopNDocuments", &a.TopNDocuments)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureCosmosDBFieldMappingOptions.
func (a AzureCosmosDBFieldMappingOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content_fields", a.ContentFields)
	populate(objectMap, "content_fields_separator", a.ContentFieldsSeparator)
	populate(objectMap, "filepath_field", a.FilepathField)
	populate(objectMap, "title_field", a.TitleField)
	populate(objectMap, "url_field", a.URLField)
	populate(objectMap, "vector_fields", a.VectorFields)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureCosmosDBFieldMappingOptions.
func (a *AzureCosmosDBFieldMappingOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content_fields":
			err = unpopulate(val, "ContentFields", &a.ContentFields)
			delete(rawMsg, key)
		case "content_fields_separator":
			err = unpopulate(val, "ContentFieldsSeparator", &a.ContentFieldsSeparator)
			delete(rawMsg, key)
		case "filepath_field":
			err = unpopulate(val, "FilepathField", &a.FilepathField)
			delete(rawMsg, key)
		case "title_field":
			err = unpopulate(val, "TitleField", &a.TitleField)
			delete(rawMsg, key)
		case "url_field":
			err = unpopulate(val, "URLField", &a.URLField)
			delete(rawMsg, key)
		case "vector_fields":
			err = unpopulate(val, "VectorFields", &a.VectorFields)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureGroundingEnhancement.
func (a AzureGroundingEnhancement) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "lines", a.Lines)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureGroundingEnhancement.
func (a *AzureGroundingEnhancement) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lines":
			err = unpopulate(val, "Lines", &a.Lines)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureGroundingEnhancementCoordinatePoint.
func (a AzureGroundingEnhancementCoordinatePoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "x", a.X)
	populate(objectMap, "y", a.Y)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureGroundingEnhancementCoordinatePoint.
func (a *AzureGroundingEnhancementCoordinatePoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "x":
			err = unpopulate(val, "X", &a.X)
			delete(rawMsg, key)
		case "y":
			err = unpopulate(val, "Y", &a.Y)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureGroundingEnhancementLine.
func (a AzureGroundingEnhancementLine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "spans", a.Spans)
	populate(objectMap, "text", a.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureGroundingEnhancementLine.
func (a *AzureGroundingEnhancementLine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "spans":
			err = unpopulate(val, "Spans", &a.Spans)
			delete(rawMsg, key)
		case "text":
			err = unpopulate(val, "Text", &a.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureGroundingEnhancementLineSpan.
func (a AzureGroundingEnhancementLineSpan) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "length", a.Length)
	populate(objectMap, "offset", a.Offset)
	populate(objectMap, "polygon", a.Polygon)
	populate(objectMap, "text", a.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureGroundingEnhancementLineSpan.
func (a *AzureGroundingEnhancementLineSpan) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "length":
			err = unpopulate(val, "Length", &a.Length)
			delete(rawMsg, key)
		case "offset":
			err = unpopulate(val, "Offset", &a.Offset)
			delete(rawMsg, key)
		case "polygon":
			err = unpopulate(val, "Polygon", &a.Polygon)
			delete(rawMsg, key)
		case "text":
			err = unpopulate(val, "Text", &a.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMachineLearningIndexChatExtensionConfiguration.
func (a AzureMachineLearningIndexChatExtensionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = AzureChatExtensionTypeAzureMachineLearningIndex
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMachineLearningIndexChatExtensionConfiguration.
func (a *AzureMachineLearningIndexChatExtensionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMachineLearningIndexChatExtensionParameters.
func (a AzureMachineLearningIndexChatExtensionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allow_partial_result", a.AllowPartialResult)
	populate(objectMap, "authentication", a.Authentication)
	populate(objectMap, "filter", a.Filter)
	populate(objectMap, "in_scope", a.InScope)
	populate(objectMap, "include_contexts", a.IncludeContexts)
	populate(objectMap, "max_search_queries", a.MaxSearchQueries)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "project_resource_id", a.ProjectResourceID)
	populate(objectMap, "role_information", a.RoleInformation)
	populate(objectMap, "strictness", a.Strictness)
	populate(objectMap, "top_n_documents", a.TopNDocuments)
	populate(objectMap, "version", a.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMachineLearningIndexChatExtensionParameters.
func (a *AzureMachineLearningIndexChatExtensionParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allow_partial_result":
			err = unpopulate(val, "AllowPartialResult", &a.AllowPartialResult)
			delete(rawMsg, key)
		case "authentication":
			a.Authentication, err = unmarshalOnYourDataAuthenticationOptionsClassification(val)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, "Filter", &a.Filter)
			delete(rawMsg, key)
		case "in_scope":
			err = unpopulate(val, "InScope", &a.InScope)
			delete(rawMsg, key)
		case "include_contexts":
			err = unpopulate(val, "IncludeContexts", &a.IncludeContexts)
			delete(rawMsg, key)
		case "max_search_queries":
			err = unpopulate(val, "MaxSearchQueries", &a.MaxSearchQueries)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "project_resource_id":
			err = unpopulate(val, "ProjectResourceID", &a.ProjectResourceID)
			delete(rawMsg, key)
		case "role_information":
			err = unpopulate(val, "RoleInformation", &a.RoleInformation)
			delete(rawMsg, key)
		case "strictness":
			err = unpopulate(val, "Strictness", &a.Strictness)
			delete(rawMsg, key)
		case "top_n_documents":
			err = unpopulate(val, "TopNDocuments", &a.TopNDocuments)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &a.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchChatExtensionConfiguration.
func (a AzureSearchChatExtensionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", a.Parameters)
	objectMap["type"] = AzureChatExtensionTypeAzureSearch
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchChatExtensionConfiguration.
func (a *AzureSearchChatExtensionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchChatExtensionParameters.
func (a AzureSearchChatExtensionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allow_partial_result", a.AllowPartialResult)
	populate(objectMap, "authentication", a.Authentication)
	populate(objectMap, "embedding_dependency", a.EmbeddingDependency)
	populate(objectMap, "endpoint", a.Endpoint)
	populate(objectMap, "fields_mapping", a.FieldsMapping)
	populate(objectMap, "filter", a.Filter)
	populate(objectMap, "in_scope", a.InScope)
	populate(objectMap, "include_contexts", a.IncludeContexts)
	populate(objectMap, "index_name", a.IndexName)
	populate(objectMap, "max_search_queries", a.MaxSearchQueries)
	populate(objectMap, "query_type", a.QueryType)
	populate(objectMap, "role_information", a.RoleInformation)
	populate(objectMap, "semantic_configuration", a.SemanticConfiguration)
	populate(objectMap, "strictness", a.Strictness)
	populate(objectMap, "top_n_documents", a.TopNDocuments)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchChatExtensionParameters.
func (a *AzureSearchChatExtensionParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allow_partial_result":
			err = unpopulate(val, "AllowPartialResult", &a.AllowPartialResult)
			delete(rawMsg, key)
		case "authentication":
			a.Authentication, err = unmarshalOnYourDataAuthenticationOptionsClassification(val)
			delete(rawMsg, key)
		case "embedding_dependency":
			a.EmbeddingDependency, err = unmarshalOnYourDataVectorizationSourceClassification(val)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &a.Endpoint)
			delete(rawMsg, key)
		case "fields_mapping":
			err = unpopulate(val, "FieldsMapping", &a.FieldsMapping)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, "Filter", &a.Filter)
			delete(rawMsg, key)
		case "in_scope":
			err = unpopulate(val, "InScope", &a.InScope)
			delete(rawMsg, key)
		case "include_contexts":
			err = unpopulate(val, "IncludeContexts", &a.IncludeContexts)
			delete(rawMsg, key)
		case "index_name":
			err = unpopulate(val, "IndexName", &a.IndexName)
			delete(rawMsg, key)
		case "max_search_queries":
			err = unpopulate(val, "MaxSearchQueries", &a.MaxSearchQueries)
			delete(rawMsg, key)
		case "query_type":
			err = unpopulate(val, "QueryType", &a.QueryType)
			delete(rawMsg, key)
		case "role_information":
			err = unpopulate(val, "RoleInformation", &a.RoleInformation)
			delete(rawMsg, key)
		case "semantic_configuration":
			err = unpopulate(val, "SemanticConfiguration", &a.SemanticConfiguration)
			delete(rawMsg, key)
		case "strictness":
			err = unpopulate(val, "Strictness", &a.Strictness)
			delete(rawMsg, key)
		case "top_n_documents":
			err = unpopulate(val, "TopNDocuments", &a.TopNDocuments)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchIndexFieldMappingOptions.
func (a AzureSearchIndexFieldMappingOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content_fields", a.ContentFields)
	populate(objectMap, "content_fields_separator", a.ContentFieldsSeparator)
	populate(objectMap, "filepath_field", a.FilepathField)
	populate(objectMap, "image_vector_fields", a.ImageVectorFields)
	populate(objectMap, "title_field", a.TitleField)
	populate(objectMap, "url_field", a.URLField)
	populate(objectMap, "vector_fields", a.VectorFields)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchIndexFieldMappingOptions.
func (a *AzureSearchIndexFieldMappingOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content_fields":
			err = unpopulate(val, "ContentFields", &a.ContentFields)
			delete(rawMsg, key)
		case "content_fields_separator":
			err = unpopulate(val, "ContentFieldsSeparator", &a.ContentFieldsSeparator)
			delete(rawMsg, key)
		case "filepath_field":
			err = unpopulate(val, "FilepathField", &a.FilepathField)
			delete(rawMsg, key)
		case "image_vector_fields":
			err = unpopulate(val, "ImageVectorFields", &a.ImageVectorFields)
			delete(rawMsg, key)
		case "title_field":
			err = unpopulate(val, "TitleField", &a.TitleField)
			delete(rawMsg, key)
		case "url_field":
			err = unpopulate(val, "URLField", &a.URLField)
			delete(rawMsg, key)
		case "vector_fields":
			err = unpopulate(val, "VectorFields", &a.VectorFields)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentFilterBlocklistIDResult.
func (c ContentFilterBlocklistIDResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "filtered", c.Filtered)
	populate(objectMap, "id", c.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentFilterBlocklistIDResult.
func (c *ContentFilterBlocklistIDResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filtered":
			err = unpopulate(val, "Filtered", &c.Filtered)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentFilterCitedDetectionResult.
func (c ContentFilterCitedDetectionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "detected", c.Detected)
	populate(objectMap, "filtered", c.Filtered)
	populate(objectMap, "license", c.License)
	populate(objectMap, "URL", c.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentFilterCitedDetectionResult.
func (c *ContentFilterCitedDetectionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "detected":
			err = unpopulate(val, "Detected", &c.Detected)
			delete(rawMsg, key)
		case "filtered":
			err = unpopulate(val, "Filtered", &c.Filtered)
			delete(rawMsg, key)
		case "license":
			err = unpopulate(val, "License", &c.License)
			delete(rawMsg, key)
		case "URL":
			err = unpopulate(val, "URL", &c.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentFilterDetailedResults.
func (c ContentFilterDetailedResults) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "details", c.Details)
	populate(objectMap, "filtered", c.Filtered)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentFilterDetailedResults.
func (c *ContentFilterDetailedResults) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "details":
			err = unpopulate(val, "Details", &c.Details)
			delete(rawMsg, key)
		case "filtered":
			err = unpopulate(val, "Filtered", &c.Filtered)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentFilterDetectionResult.
func (c ContentFilterDetectionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "detected", c.Detected)
	populate(objectMap, "filtered", c.Filtered)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentFilterDetectionResult.
func (c *ContentFilterDetectionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "detected":
			err = unpopulate(val, "Detected", &c.Detected)
			delete(rawMsg, key)
		case "filtered":
			err = unpopulate(val, "Filtered", &c.Filtered)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentFilterResult.
func (c ContentFilterResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "filtered", c.Filtered)
	populate(objectMap, "severity", c.Severity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentFilterResult.
func (c *ContentFilterResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filtered":
			err = unpopulate(val, "Filtered", &c.Filtered)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &c.Severity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentFilterResultDetailsForPrompt.
func (c ContentFilterResultDetailsForPrompt) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "custom_blocklists", c.CustomBlocklists)
	populate(objectMap, "error", c.Error)
	populate(objectMap, "hate", c.Hate)
	populate(objectMap, "indirect_attack", c.IndirectAttack)
	populate(objectMap, "jailbreak", c.Jailbreak)
	populate(objectMap, "profanity", c.Profanity)
	populate(objectMap, "self_harm", c.SelfHarm)
	populate(objectMap, "sexual", c.Sexual)
	populate(objectMap, "violence", c.Violence)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentFilterResultDetailsForPrompt.
func (c *ContentFilterResultDetailsForPrompt) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "custom_blocklists":
			err = unpopulate(val, "CustomBlocklists", &c.CustomBlocklists)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &c.Error)
			delete(rawMsg, key)
		case "hate":
			err = unpopulate(val, "Hate", &c.Hate)
			delete(rawMsg, key)
		case "indirect_attack":
			err = unpopulate(val, "IndirectAttack", &c.IndirectAttack)
			delete(rawMsg, key)
		case "jailbreak":
			err = unpopulate(val, "Jailbreak", &c.Jailbreak)
			delete(rawMsg, key)
		case "profanity":
			err = unpopulate(val, "Profanity", &c.Profanity)
			delete(rawMsg, key)
		case "self_harm":
			err = unpopulate(val, "SelfHarm", &c.SelfHarm)
			delete(rawMsg, key)
		case "sexual":
			err = unpopulate(val, "Sexual", &c.Sexual)
			delete(rawMsg, key)
		case "violence":
			err = unpopulate(val, "Violence", &c.Violence)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentFilterResultsForChoice.
func (c ContentFilterResultsForChoice) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "custom_blocklists", c.CustomBlocklists)
	populate(objectMap, "error", c.Error)
	populate(objectMap, "hate", c.Hate)
	populate(objectMap, "profanity", c.Profanity)
	populate(objectMap, "protected_material_code", c.ProtectedMaterialCode)
	populate(objectMap, "protected_material_text", c.ProtectedMaterialText)
	populate(objectMap, "self_harm", c.SelfHarm)
	populate(objectMap, "sexual", c.Sexual)
	populate(objectMap, "violence", c.Violence)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentFilterResultsForChoice.
func (c *ContentFilterResultsForChoice) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "custom_blocklists":
			err = unpopulate(val, "CustomBlocklists", &c.CustomBlocklists)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &c.Error)
			delete(rawMsg, key)
		case "hate":
			err = unpopulate(val, "Hate", &c.Hate)
			delete(rawMsg, key)
		case "profanity":
			err = unpopulate(val, "Profanity", &c.Profanity)
			delete(rawMsg, key)
		case "protected_material_code":
			err = unpopulate(val, "ProtectedMaterialCode", &c.ProtectedMaterialCode)
			delete(rawMsg, key)
		case "protected_material_text":
			err = unpopulate(val, "ProtectedMaterialText", &c.ProtectedMaterialText)
			delete(rawMsg, key)
		case "self_harm":
			err = unpopulate(val, "SelfHarm", &c.SelfHarm)
			delete(rawMsg, key)
		case "sexual":
			err = unpopulate(val, "Sexual", &c.Sexual)
			delete(rawMsg, key)
		case "violence":
			err = unpopulate(val, "Violence", &c.Violence)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentFilterResultsForPrompt.
func (c ContentFilterResultsForPrompt) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content_filter_results", c.ContentFilterResults)
	populate(objectMap, "prompt_index", c.PromptIndex)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentFilterResultsForPrompt.
func (c *ContentFilterResultsForPrompt) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content_filter_results":
			err = unpopulate(val, "ContentFilterResults", &c.ContentFilterResults)
			delete(rawMsg, key)
		case "prompt_index":
			err = unpopulate(val, "PromptIndex", &c.PromptIndex)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Error.
func (e Error) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "message", e.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Error.
func (e *Error) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataAPIKeyAuthenticationOptions.
func (o OnYourDataAPIKeyAuthenticationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", o.Key)
	objectMap["type"] = OnYourDataAuthenticationTypeAPIKey
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataAPIKeyAuthenticationOptions.
func (o *OnYourDataAPIKeyAuthenticationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, "Key", &o.Key)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataAccessTokenAuthenticationOptions.
func (o OnYourDataAccessTokenAuthenticationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "access_token", o.AccessToken)
	objectMap["type"] = OnYourDataAuthenticationTypeAccessToken
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataAccessTokenAuthenticationOptions.
func (o *OnYourDataAccessTokenAuthenticationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "access_token":
			err = unpopulate(val, "AccessToken", &o.AccessToken)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataAuthenticationOptions.
func (o OnYourDataAuthenticationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = o.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataAuthenticationOptions.
func (o *OnYourDataAuthenticationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataConnectionStringAuthenticationOptions.
func (o OnYourDataConnectionStringAuthenticationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connection_string", o.ConnectionString)
	objectMap["type"] = OnYourDataAuthenticationTypeConnectionString
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataConnectionStringAuthenticationOptions.
func (o *OnYourDataConnectionStringAuthenticationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connection_string":
			err = unpopulate(val, "ConnectionString", &o.ConnectionString)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataDeploymentNameVectorizationSource.
func (o OnYourDataDeploymentNameVectorizationSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deployment_name", o.DeploymentName)
	populate(objectMap, "dimensions", o.Dimensions)
	objectMap["type"] = OnYourDataVectorizationSourceTypeDeploymentName
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataDeploymentNameVectorizationSource.
func (o *OnYourDataDeploymentNameVectorizationSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deployment_name":
			err = unpopulate(val, "DeploymentName", &o.DeploymentName)
			delete(rawMsg, key)
		case "dimensions":
			err = unpopulate(val, "Dimensions", &o.Dimensions)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataEncodedAPIKeyAuthenticationOptions.
func (o OnYourDataEncodedAPIKeyAuthenticationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encoded_api_key", o.EncodedAPIKey)
	objectMap["type"] = OnYourDataAuthenticationTypeEncodedAPIKey
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataEncodedAPIKeyAuthenticationOptions.
func (o *OnYourDataEncodedAPIKeyAuthenticationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encoded_api_key":
			err = unpopulate(val, "EncodedAPIKey", &o.EncodedAPIKey)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataEndpointVectorizationSource.
func (o OnYourDataEndpointVectorizationSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authentication", o.Authentication)
	populate(objectMap, "endpoint", o.Endpoint)
	objectMap["type"] = OnYourDataVectorizationSourceTypeEndpoint
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataEndpointVectorizationSource.
func (o *OnYourDataEndpointVectorizationSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			o.Authentication, err = unmarshalOnYourDataVectorSearchAuthenticationOptionsClassification(val)
			delete(rawMsg, key)
		case "endpoint":
			err = unpopulate(val, "Endpoint", &o.Endpoint)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataKeyAndKeyIDAuthenticationOptions.
func (o OnYourDataKeyAndKeyIDAuthenticationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", o.Key)
	populate(objectMap, "key_id", o.KeyID)
	objectMap["type"] = OnYourDataAuthenticationTypeKeyAndKeyID
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataKeyAndKeyIDAuthenticationOptions.
func (o *OnYourDataKeyAndKeyIDAuthenticationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, "Key", &o.Key)
			delete(rawMsg, key)
		case "key_id":
			err = unpopulate(val, "KeyID", &o.KeyID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataModelIDVectorizationSource.
func (o OnYourDataModelIDVectorizationSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "model_id", o.ModelID)
	objectMap["type"] = OnYourDataVectorizationSourceTypeModelID
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataModelIDVectorizationSource.
func (o *OnYourDataModelIDVectorizationSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "model_id":
			err = unpopulate(val, "ModelID", &o.ModelID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataSystemAssignedManagedIdentityAuthenticationOptions.
func (o OnYourDataSystemAssignedManagedIdentityAuthenticationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = OnYourDataAuthenticationTypeSystemAssignedManagedIdentity
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataSystemAssignedManagedIdentityAuthenticationOptions.
func (o *OnYourDataSystemAssignedManagedIdentityAuthenticationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataUserAssignedManagedIdentityAuthenticationOptions.
func (o OnYourDataUserAssignedManagedIdentityAuthenticationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "managed_identity_resource_id", o.ManagedIdentityResourceID)
	objectMap["type"] = OnYourDataAuthenticationTypeUserAssignedManagedIdentity
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataUserAssignedManagedIdentityAuthenticationOptions.
func (o *OnYourDataUserAssignedManagedIdentityAuthenticationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "managed_identity_resource_id":
			err = unpopulate(val, "ManagedIdentityResourceID", &o.ManagedIdentityResourceID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataVectorSearchAPIKeyAuthenticationOptions.
func (o OnYourDataVectorSearchAPIKeyAuthenticationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", o.Key)
	objectMap["type"] = OnYourDataVectorSearchAuthenticationTypeAPIKey
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataVectorSearchAPIKeyAuthenticationOptions.
func (o *OnYourDataVectorSearchAPIKeyAuthenticationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, "Key", &o.Key)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataVectorSearchAccessTokenAuthenticationOptions.
func (o OnYourDataVectorSearchAccessTokenAuthenticationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "access_token", o.AccessToken)
	objectMap["type"] = OnYourDataVectorSearchAuthenticationTypeAccessToken
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataVectorSearchAccessTokenAuthenticationOptions.
func (o *OnYourDataVectorSearchAccessTokenAuthenticationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "access_token":
			err = unpopulate(val, "AccessToken", &o.AccessToken)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataVectorSearchAuthenticationOptions.
func (o OnYourDataVectorSearchAuthenticationOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = o.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataVectorSearchAuthenticationOptions.
func (o *OnYourDataVectorSearchAuthenticationOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnYourDataVectorizationSource.
func (o OnYourDataVectorizationSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = o.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnYourDataVectorizationSource.
func (o *OnYourDataVectorizationSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PineconeChatExtensionConfiguration.
func (p PineconeChatExtensionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", p.Parameters)
	objectMap["type"] = AzureChatExtensionTypePinecone
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PineconeChatExtensionConfiguration.
func (p *PineconeChatExtensionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, "Parameters", &p.Parameters)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PineconeChatExtensionParameters.
func (p PineconeChatExtensionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allow_partial_result", p.AllowPartialResult)
	populate(objectMap, "authentication", p.Authentication)
	populate(objectMap, "embedding_dependency", p.EmbeddingDependency)
	populate(objectMap, "environment", p.Environment)
	populate(objectMap, "fields_mapping", p.FieldsMapping)
	populate(objectMap, "in_scope", p.InScope)
	populate(objectMap, "include_contexts", p.IncludeContexts)
	populate(objectMap, "index_name", p.IndexName)
	populate(objectMap, "max_search_queries", p.MaxSearchQueries)
	populate(objectMap, "role_information", p.RoleInformation)
	populate(objectMap, "strictness", p.Strictness)
	populate(objectMap, "top_n_documents", p.TopNDocuments)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PineconeChatExtensionParameters.
func (p *PineconeChatExtensionParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allow_partial_result":
			err = unpopulate(val, "AllowPartialResult", &p.AllowPartialResult)
			delete(rawMsg, key)
		case "authentication":
			p.Authentication, err = unmarshalOnYourDataAuthenticationOptionsClassification(val)
			delete(rawMsg, key)
		case "embedding_dependency":
			p.EmbeddingDependency, err = unmarshalOnYourDataVectorizationSourceClassification(val)
			delete(rawMsg, key)
		case "environment":
			err = unpopulate(val, "Environment", &p.Environment)
			delete(rawMsg, key)
		case "fields_mapping":
			err = unpopulate(val, "FieldsMapping", &p.FieldsMapping)
			delete(rawMsg, key)
		case "in_scope":
			err = unpopulate(val, "InScope", &p.InScope)
			delete(rawMsg, key)
		case "include_contexts":
			err = unpopulate(val, "IncludeContexts", &p.IncludeContexts)
			delete(rawMsg, key)
		case "index_name":
			err = unpopulate(val, "IndexName", &p.IndexName)
			delete(rawMsg, key)
		case "max_search_queries":
			err = unpopulate(val, "MaxSearchQueries", &p.MaxSearchQueries)
			delete(rawMsg, key)
		case "role_information":
			err = unpopulate(val, "RoleInformation", &p.RoleInformation)
			delete(rawMsg, key)
		case "strictness":
			err = unpopulate(val, "Strictness", &p.Strictness)
			delete(rawMsg, key)
		case "top_n_documents":
			err = unpopulate(val, "TopNDocuments", &p.TopNDocuments)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PineconeFieldMappingOptions.
func (p PineconeFieldMappingOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content_fields", p.ContentFields)
	populate(objectMap, "content_fields_separator", p.ContentFieldsSeparator)
	populate(objectMap, "filepath_field", p.FilepathField)
	populate(objectMap, "title_field", p.TitleField)
	populate(objectMap, "url_field", p.URLField)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PineconeFieldMappingOptions.
func (p *PineconeFieldMappingOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content_fields":
			err = unpopulate(val, "ContentFields", &p.ContentFields)
			delete(rawMsg, key)
		case "content_fields_separator":
			err = unpopulate(val, "ContentFieldsSeparator", &p.ContentFieldsSeparator)
			delete(rawMsg, key)
		case "filepath_field":
			err = unpopulate(val, "FilepathField", &p.FilepathField)
			delete(rawMsg, key)
		case "title_field":
			err = unpopulate(val, "TitleField", &p.TitleField)
			delete(rawMsg, key)
		case "url_field":
			err = unpopulate(val, "URLField", &p.URLField)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
