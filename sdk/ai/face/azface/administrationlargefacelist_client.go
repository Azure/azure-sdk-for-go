// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package azface

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// AdministrationLargeFaceListClient contains the methods for the AdministrationLargeFaceList group.
// Don't use this type directly, use [AdministrationClient.NewAdministrationLargeFaceListClient] instead.
type AdministrationLargeFaceListClient struct {
	internal   *azcore.Client
	endpoint   string
	apiVersion Versions
}

// AddFace - Add a face to a specified Large Face List, up to 1,000,000 faces.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/add-large-face-list-face for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largeFaceListID - Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
//   - imageContent - The image to be analyzed
//   - options - AdministrationLargeFaceListClientAddFaceOptions contains the optional parameters for the AdministrationLargeFaceListClient.AddFace
//     method.
func (client *AdministrationLargeFaceListClient) AddFace(ctx context.Context, largeFaceListID string, imageContent io.ReadSeekCloser, options *AdministrationLargeFaceListClientAddFaceOptions) (AdministrationLargeFaceListClientAddFaceResponse, error) {
	var err error
	req, err := client.addFaceCreateRequest(ctx, largeFaceListID, imageContent, options)
	if err != nil {
		return AdministrationLargeFaceListClientAddFaceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargeFaceListClientAddFaceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargeFaceListClientAddFaceResponse{}, err
	}
	resp, err := client.addFaceHandleResponse(httpResp)
	return resp, err
}

// addFaceCreateRequest creates the AddFace request.
func (client *AdministrationLargeFaceListClient) addFaceCreateRequest(ctx context.Context, largeFaceListID string, imageContent io.ReadSeekCloser, options *AdministrationLargeFaceListClientAddFaceOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists/{largeFaceListId}/persistedfaces"
	if largeFaceListID == "" {
		return nil, errors.New("parameter largeFaceListID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largeFaceListId}", url.PathEscape(largeFaceListID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DetectionModel != nil {
		reqQP.Set("detectionModel", string(*options.DetectionModel))
	}
	if options != nil && options.TargetFace != nil {
		reqQP.Set("targetFace", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.TargetFace), "[]")), ","))
	}
	if options != nil && options.UserData != nil {
		reqQP.Set("userData", *options.UserData)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/octet-stream"}
	if err := req.SetBody(imageContent, "application/octet-stream"); err != nil {
		return nil, err
	}
	return req, nil
}

// addFaceHandleResponse handles the AddFace response.
func (client *AdministrationLargeFaceListClient) addFaceHandleResponse(resp *http.Response) (AdministrationLargeFaceListClientAddFaceResponse, error) {
	result := AdministrationLargeFaceListClientAddFaceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AddFaceResult); err != nil {
		return AdministrationLargeFaceListClientAddFaceResponse{}, err
	}
	return result, nil
}

// AddFaceFromURL - Add a face to a specified Large Face List, up to 1,000,000 faces.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/add-large-face-list-face-from-url for more
// details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largeFaceListID - Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
//   - urlParam - URL of input image.
//   - options - AdministrationLargeFaceListClientAddFaceFromURLOptions contains the optional parameters for the AdministrationLargeFaceListClient.AddFaceFromURL
//     method.
func (client *AdministrationLargeFaceListClient) AddFaceFromURL(ctx context.Context, largeFaceListID string, urlParam string, options *AdministrationLargeFaceListClientAddFaceFromURLOptions) (AdministrationLargeFaceListClientAddFaceFromURLResponse, error) {
	var err error
	req, err := client.addFaceFromURLCreateRequest(ctx, largeFaceListID, urlParam, options)
	if err != nil {
		return AdministrationLargeFaceListClientAddFaceFromURLResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargeFaceListClientAddFaceFromURLResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargeFaceListClientAddFaceFromURLResponse{}, err
	}
	resp, err := client.addFaceFromURLHandleResponse(httpResp)
	return resp, err
}

// addFaceFromURLCreateRequest creates the AddFaceFromURL request.
func (client *AdministrationLargeFaceListClient) addFaceFromURLCreateRequest(ctx context.Context, largeFaceListID string, urlParam string, options *AdministrationLargeFaceListClientAddFaceFromURLOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists/{largeFaceListId}/persistedfaces"
	if largeFaceListID == "" {
		return nil, errors.New("parameter largeFaceListID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largeFaceListId}", url.PathEscape(largeFaceListID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DetectionModel != nil {
		reqQP.Set("detectionModel", string(*options.DetectionModel))
	}
	if options != nil && options.TargetFace != nil {
		reqQP.Set("targetFace", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.TargetFace), "[]")), ","))
	}
	if options != nil && options.UserData != nil {
		reqQP.Set("userData", *options.UserData)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		Url string `json:"url"`
	}{
		Url: urlParam,
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// addFaceFromURLHandleResponse handles the AddFaceFromURL response.
func (client *AdministrationLargeFaceListClient) addFaceFromURLHandleResponse(resp *http.Response) (AdministrationLargeFaceListClientAddFaceFromURLResponse, error) {
	result := AdministrationLargeFaceListClientAddFaceFromURLResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AddFaceResult); err != nil {
		return AdministrationLargeFaceListClientAddFaceFromURLResponse{}, err
	}
	return result, nil
}

// Create - Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData and recognitionModel.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/create-large-face-list for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largeFaceListID - Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
//   - name - User defined name, maximum length is 128.
//   - options - AdministrationLargeFaceListClientCreateOptions contains the optional parameters for the AdministrationLargeFaceListClient.Create
//     method.
func (client *AdministrationLargeFaceListClient) Create(ctx context.Context, largeFaceListID string, name string, options *AdministrationLargeFaceListClientCreateOptions) (AdministrationLargeFaceListClientCreateResponse, error) {
	var err error
	req, err := client.createCreateRequest(ctx, largeFaceListID, name, options)
	if err != nil {
		return AdministrationLargeFaceListClientCreateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargeFaceListClientCreateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargeFaceListClientCreateResponse{}, err
	}
	return AdministrationLargeFaceListClientCreateResponse{}, nil
}

// createCreateRequest creates the Create request.
func (client *AdministrationLargeFaceListClient) createCreateRequest(ctx context.Context, largeFaceListID string, name string, options *AdministrationLargeFaceListClientCreateOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists/{largeFaceListId}"
	if largeFaceListID == "" {
		return nil, errors.New("parameter largeFaceListID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largeFaceListId}", url.PathEscape(largeFaceListID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		Name             string                `json:"name"`
		UserData         *string               `json:"userData"`
		RecognitionModel *FaceRecognitionModel `json:"recognitionModel"`
	}{
		Name: name,
	}
	if options != nil && options.UserData != nil {
		body.UserData = options.UserData
	}
	if options != nil && options.RecognitionModel != nil {
		body.RecognitionModel = options.RecognitionModel
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// Delete - Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/delete-large-face-list for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largeFaceListID - Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
//   - options - AdministrationLargeFaceListClientDeleteOptions contains the optional parameters for the AdministrationLargeFaceListClient.Delete
//     method.
func (client *AdministrationLargeFaceListClient) Delete(ctx context.Context, largeFaceListID string, options *AdministrationLargeFaceListClientDeleteOptions) (AdministrationLargeFaceListClientDeleteResponse, error) {
	var err error
	req, err := client.deleteCreateRequest(ctx, largeFaceListID, options)
	if err != nil {
		return AdministrationLargeFaceListClientDeleteResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargeFaceListClientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargeFaceListClientDeleteResponse{}, err
	}
	return AdministrationLargeFaceListClientDeleteResponse{}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *AdministrationLargeFaceListClient) deleteCreateRequest(ctx context.Context, largeFaceListID string, _ *AdministrationLargeFaceListClientDeleteOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists/{largeFaceListId}"
	if largeFaceListID == "" {
		return nil, errors.New("parameter largeFaceListID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largeFaceListId}", url.PathEscape(largeFaceListID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteFace - Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/delete-large-face-list-face
// for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largeFaceListID - Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
//   - persistedFaceID - Face ID of the face.
//   - options - AdministrationLargeFaceListClientDeleteFaceOptions contains the optional parameters for the AdministrationLargeFaceListClient.DeleteFace
//     method.
func (client *AdministrationLargeFaceListClient) DeleteFace(ctx context.Context, largeFaceListID string, persistedFaceID string, options *AdministrationLargeFaceListClientDeleteFaceOptions) (AdministrationLargeFaceListClientDeleteFaceResponse, error) {
	var err error
	req, err := client.deleteFaceCreateRequest(ctx, largeFaceListID, persistedFaceID, options)
	if err != nil {
		return AdministrationLargeFaceListClientDeleteFaceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargeFaceListClientDeleteFaceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargeFaceListClientDeleteFaceResponse{}, err
	}
	return AdministrationLargeFaceListClientDeleteFaceResponse{}, nil
}

// deleteFaceCreateRequest creates the DeleteFace request.
func (client *AdministrationLargeFaceListClient) deleteFaceCreateRequest(ctx context.Context, largeFaceListID string, persistedFaceID string, _ *AdministrationLargeFaceListClientDeleteFaceOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}"
	if largeFaceListID == "" {
		return nil, errors.New("parameter largeFaceListID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largeFaceListId}", url.PathEscape(largeFaceListID))
	if persistedFaceID == "" {
		return nil, errors.New("parameter persistedFaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{persistedFaceId}", url.PathEscape(persistedFaceID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// Get - Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/get-large-face-list for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largeFaceListID - Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
//   - options - AdministrationLargeFaceListClientGetOptions contains the optional parameters for the AdministrationLargeFaceListClient.Get
//     method.
func (client *AdministrationLargeFaceListClient) Get(ctx context.Context, largeFaceListID string, options *AdministrationLargeFaceListClientGetOptions) (AdministrationLargeFaceListClientGetResponse, error) {
	var err error
	req, err := client.getCreateRequest(ctx, largeFaceListID, options)
	if err != nil {
		return AdministrationLargeFaceListClientGetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargeFaceListClientGetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargeFaceListClientGetResponse{}, err
	}
	resp, err := client.getHandleResponse(httpResp)
	return resp, err
}

// getCreateRequest creates the Get request.
func (client *AdministrationLargeFaceListClient) getCreateRequest(ctx context.Context, largeFaceListID string, options *AdministrationLargeFaceListClientGetOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists/{largeFaceListId}"
	if largeFaceListID == "" {
		return nil, errors.New("parameter largeFaceListID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largeFaceListId}", url.PathEscape(largeFaceListID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ReturnRecognitionModel != nil {
		reqQP.Set("returnRecognitionModel", strconv.FormatBool(*options.ReturnRecognitionModel))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *AdministrationLargeFaceListClient) getHandleResponse(resp *http.Response) (AdministrationLargeFaceListClientGetResponse, error) {
	result := AdministrationLargeFaceListClientGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.LargeFaceList); err != nil {
		return AdministrationLargeFaceListClientGetResponse{}, err
	}
	return result, nil
}

// GetFace - Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/get-large-face-list-face for more
// details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largeFaceListID - Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
//   - persistedFaceID - Face ID of the face.
//   - options - AdministrationLargeFaceListClientGetFaceOptions contains the optional parameters for the AdministrationLargeFaceListClient.GetFace
//     method.
func (client *AdministrationLargeFaceListClient) GetFace(ctx context.Context, largeFaceListID string, persistedFaceID string, options *AdministrationLargeFaceListClientGetFaceOptions) (AdministrationLargeFaceListClientGetFaceResponse, error) {
	var err error
	req, err := client.getFaceCreateRequest(ctx, largeFaceListID, persistedFaceID, options)
	if err != nil {
		return AdministrationLargeFaceListClientGetFaceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargeFaceListClientGetFaceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargeFaceListClientGetFaceResponse{}, err
	}
	resp, err := client.getFaceHandleResponse(httpResp)
	return resp, err
}

// getFaceCreateRequest creates the GetFace request.
func (client *AdministrationLargeFaceListClient) getFaceCreateRequest(ctx context.Context, largeFaceListID string, persistedFaceID string, _ *AdministrationLargeFaceListClientGetFaceOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}"
	if largeFaceListID == "" {
		return nil, errors.New("parameter largeFaceListID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largeFaceListId}", url.PathEscape(largeFaceListID))
	if persistedFaceID == "" {
		return nil, errors.New("parameter persistedFaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{persistedFaceId}", url.PathEscape(persistedFaceID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFaceHandleResponse handles the GetFace response.
func (client *AdministrationLargeFaceListClient) getFaceHandleResponse(resp *http.Response) (AdministrationLargeFaceListClientGetFaceResponse, error) {
	result := AdministrationLargeFaceListClientGetFaceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.LargeFaceListFace); err != nil {
		return AdministrationLargeFaceListClientGetFaceResponse{}, err
	}
	return result, nil
}

// GetFaces - List faces' persistedFaceId and userData in a specified Large Face List.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/get-large-face-list-faces for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largeFaceListID - Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
//   - options - AdministrationLargeFaceListClientGetFacesOptions contains the optional parameters for the AdministrationLargeFaceListClient.GetFaces
//     method.
func (client *AdministrationLargeFaceListClient) GetFaces(ctx context.Context, largeFaceListID string, options *AdministrationLargeFaceListClientGetFacesOptions) (AdministrationLargeFaceListClientGetFacesResponse, error) {
	var err error
	req, err := client.getFacesCreateRequest(ctx, largeFaceListID, options)
	if err != nil {
		return AdministrationLargeFaceListClientGetFacesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargeFaceListClientGetFacesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargeFaceListClientGetFacesResponse{}, err
	}
	resp, err := client.getFacesHandleResponse(httpResp)
	return resp, err
}

// getFacesCreateRequest creates the GetFaces request.
func (client *AdministrationLargeFaceListClient) getFacesCreateRequest(ctx context.Context, largeFaceListID string, options *AdministrationLargeFaceListClientGetFacesOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists/{largeFaceListId}/persistedfaces"
	if largeFaceListID == "" {
		return nil, errors.New("parameter largeFaceListID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largeFaceListId}", url.PathEscape(largeFaceListID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Start != nil {
		reqQP.Set("start", *options.Start)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFacesHandleResponse handles the GetFaces response.
func (client *AdministrationLargeFaceListClient) getFacesHandleResponse(resp *http.Response) (AdministrationLargeFaceListClientGetFacesResponse, error) {
	result := AdministrationLargeFaceListClientGetFacesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.LargeFaceListFaceArray); err != nil {
		return AdministrationLargeFaceListClientGetFacesResponse{}, err
	}
	return result, nil
}

// GetLargeFaceLists - List Large Face Lists' information of largeFaceListId, name, userData and recognitionModel.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/get-large-face-lists for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - AdministrationLargeFaceListClientGetLargeFaceListsOptions contains the optional parameters for the AdministrationLargeFaceListClient.GetLargeFaceLists
//     method.
func (client *AdministrationLargeFaceListClient) GetLargeFaceLists(ctx context.Context, options *AdministrationLargeFaceListClientGetLargeFaceListsOptions) (AdministrationLargeFaceListClientGetLargeFaceListsResponse, error) {
	var err error
	req, err := client.getLargeFaceListsCreateRequest(ctx, options)
	if err != nil {
		return AdministrationLargeFaceListClientGetLargeFaceListsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargeFaceListClientGetLargeFaceListsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargeFaceListClientGetLargeFaceListsResponse{}, err
	}
	resp, err := client.getLargeFaceListsHandleResponse(httpResp)
	return resp, err
}

// getLargeFaceListsCreateRequest creates the GetLargeFaceLists request.
func (client *AdministrationLargeFaceListClient) getLargeFaceListsCreateRequest(ctx context.Context, options *AdministrationLargeFaceListClientGetLargeFaceListsOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ReturnRecognitionModel != nil {
		reqQP.Set("returnRecognitionModel", strconv.FormatBool(*options.ReturnRecognitionModel))
	}
	if options != nil && options.Start != nil {
		reqQP.Set("start", *options.Start)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLargeFaceListsHandleResponse handles the GetLargeFaceLists response.
func (client *AdministrationLargeFaceListClient) getLargeFaceListsHandleResponse(resp *http.Response) (AdministrationLargeFaceListClientGetLargeFaceListsResponse, error) {
	result := AdministrationLargeFaceListClientGetLargeFaceListsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.LargeFaceListArray); err != nil {
		return AdministrationLargeFaceListClientGetLargeFaceListsResponse{}, err
	}
	return result, nil
}

// GetTrainingStatus - Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/get-large-face-list-training-status
// for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largeFaceListID - Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
//   - options - AdministrationLargeFaceListClientGetTrainingStatusOptions contains the optional parameters for the AdministrationLargeFaceListClient.GetTrainingStatus
//     method.
func (client *AdministrationLargeFaceListClient) GetTrainingStatus(ctx context.Context, largeFaceListID string, options *AdministrationLargeFaceListClientGetTrainingStatusOptions) (AdministrationLargeFaceListClientGetTrainingStatusResponse, error) {
	var err error
	req, err := client.getTrainingStatusCreateRequest(ctx, largeFaceListID, options)
	if err != nil {
		return AdministrationLargeFaceListClientGetTrainingStatusResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargeFaceListClientGetTrainingStatusResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargeFaceListClientGetTrainingStatusResponse{}, err
	}
	resp, err := client.getTrainingStatusHandleResponse(httpResp)
	return resp, err
}

// getTrainingStatusCreateRequest creates the GetTrainingStatus request.
func (client *AdministrationLargeFaceListClient) getTrainingStatusCreateRequest(ctx context.Context, largeFaceListID string, _ *AdministrationLargeFaceListClientGetTrainingStatusOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists/{largeFaceListId}/training"
	if largeFaceListID == "" {
		return nil, errors.New("parameter largeFaceListID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largeFaceListId}", url.PathEscape(largeFaceListID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTrainingStatusHandleResponse handles the GetTrainingStatus response.
func (client *AdministrationLargeFaceListClient) getTrainingStatusHandleResponse(resp *http.Response) (AdministrationLargeFaceListClientGetTrainingStatusResponse, error) {
	result := AdministrationLargeFaceListClientGetTrainingStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TrainingResult); err != nil {
		return AdministrationLargeFaceListClientGetTrainingStatusResponse{}, err
	}
	return result, nil
}

// BeginTrain - Submit a Large Face List training task.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/train-large-face-list for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largeFaceListID - Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
//   - options - AdministrationLargeFaceListClientBeginTrainOptions contains the optional parameters for the AdministrationLargeFaceListClient.BeginTrain
//     method.
func (client *AdministrationLargeFaceListClient) BeginTrain(ctx context.Context, largeFaceListID string, options *AdministrationLargeFaceListClientBeginTrainOptions) (*runtime.Poller[AdministrationLargeFaceListClientTrainResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.train(ctx, largeFaceListID, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller[AdministrationLargeFaceListClientTrainResponse](resp, client.internal.Pipeline(), nil)
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken[AdministrationLargeFaceListClientTrainResponse](options.ResumeToken, client.internal.Pipeline(), nil)
	}
}

// Train - Submit a Large Face List training task.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/train-large-face-list for more details.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *AdministrationLargeFaceListClient) train(ctx context.Context, largeFaceListID string, options *AdministrationLargeFaceListClientBeginTrainOptions) (*http.Response, error) {
	var err error
	req, err := client.trainCreateRequest(ctx, largeFaceListID, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// trainCreateRequest creates the Train request.
func (client *AdministrationLargeFaceListClient) trainCreateRequest(ctx context.Context, largeFaceListID string, _ *AdministrationLargeFaceListClientBeginTrainOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists/{largeFaceListId}/train"
	if largeFaceListID == "" {
		return nil, errors.New("parameter largeFaceListID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largeFaceListId}", url.PathEscape(largeFaceListID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// Update - Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/update-large-face-list for more
// details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largeFaceListID - Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
//   - options - AdministrationLargeFaceListClientUpdateOptions contains the optional parameters for the AdministrationLargeFaceListClient.Update
//     method.
func (client *AdministrationLargeFaceListClient) Update(ctx context.Context, largeFaceListID string, options *AdministrationLargeFaceListClientUpdateOptions) (AdministrationLargeFaceListClientUpdateResponse, error) {
	var err error
	req, err := client.updateCreateRequest(ctx, largeFaceListID, options)
	if err != nil {
		return AdministrationLargeFaceListClientUpdateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargeFaceListClientUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargeFaceListClientUpdateResponse{}, err
	}
	return AdministrationLargeFaceListClientUpdateResponse{}, nil
}

// updateCreateRequest creates the Update request.
func (client *AdministrationLargeFaceListClient) updateCreateRequest(ctx context.Context, largeFaceListID string, options *AdministrationLargeFaceListClientUpdateOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists/{largeFaceListId}"
	if largeFaceListID == "" {
		return nil, errors.New("parameter largeFaceListID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largeFaceListId}", url.PathEscape(largeFaceListID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		Name     *string `json:"name"`
		UserData *string `json:"userData"`
	}{}
	if options != nil && options.Name != nil {
		body.Name = options.Name
	}
	if options != nil && options.UserData != nil {
		body.UserData = options.UserData
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// UpdateFace - Please refer to https://learn.microsoft.com/rest/api/face/face-list-operations/update-large-face-list-face
// for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largeFaceListID - Valid character is letter in lower case or digit or '-' or '_', maximum length is 64.
//   - persistedFaceID - Face ID of the face.
//   - options - AdministrationLargeFaceListClientUpdateFaceOptions contains the optional parameters for the AdministrationLargeFaceListClient.UpdateFace
//     method.
func (client *AdministrationLargeFaceListClient) UpdateFace(ctx context.Context, largeFaceListID string, persistedFaceID string, options *AdministrationLargeFaceListClientUpdateFaceOptions) (AdministrationLargeFaceListClientUpdateFaceResponse, error) {
	var err error
	req, err := client.updateFaceCreateRequest(ctx, largeFaceListID, persistedFaceID, options)
	if err != nil {
		return AdministrationLargeFaceListClientUpdateFaceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargeFaceListClientUpdateFaceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargeFaceListClientUpdateFaceResponse{}, err
	}
	return AdministrationLargeFaceListClientUpdateFaceResponse{}, nil
}

// updateFaceCreateRequest creates the UpdateFace request.
func (client *AdministrationLargeFaceListClient) updateFaceCreateRequest(ctx context.Context, largeFaceListID string, persistedFaceID string, options *AdministrationLargeFaceListClientUpdateFaceOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}"
	if largeFaceListID == "" {
		return nil, errors.New("parameter largeFaceListID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largeFaceListId}", url.PathEscape(largeFaceListID))
	if persistedFaceID == "" {
		return nil, errors.New("parameter persistedFaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{persistedFaceId}", url.PathEscape(persistedFaceID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		UserData *string `json:"userData"`
	}{}
	if options != nil && options.UserData != nil {
		body.UserData = options.UserData
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}
