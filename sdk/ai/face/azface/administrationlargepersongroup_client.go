// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package azface

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// AdministrationLargePersonGroupClient contains the methods for the AdministrationLargePersonGroup group.
// Don't use this type directly, use [AdministrationClient.NewAdministrationLargePersonGroupClient] instead.
type AdministrationLargePersonGroupClient struct {
	internal   *azcore.Client
	endpoint   string
	apiVersion Versions
}

// AddFace - Add a face to a person into a Large Person Group for face identification or verification.
//
// Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/add-large-person-group-person-face for
// more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - personID - ID of the person.
//   - imageContent - The image to be analyzed
//   - options - AdministrationLargePersonGroupClientAddFaceOptions contains the optional parameters for the AdministrationLargePersonGroupClient.AddFace
//     method.
func (client *AdministrationLargePersonGroupClient) AddFace(ctx context.Context, largePersonGroupID string, personID string, imageContent io.ReadSeekCloser, options *AdministrationLargePersonGroupClientAddFaceOptions) (AdministrationLargePersonGroupClientAddFaceResponse, error) {
	var err error
	req, err := client.addFaceCreateRequest(ctx, largePersonGroupID, personID, imageContent, options)
	if err != nil {
		return AdministrationLargePersonGroupClientAddFaceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientAddFaceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientAddFaceResponse{}, err
	}
	resp, err := client.addFaceHandleResponse(httpResp)
	return resp, err
}

// addFaceCreateRequest creates the AddFace request.
func (client *AdministrationLargePersonGroupClient) addFaceCreateRequest(ctx context.Context, largePersonGroupID string, personID string, imageContent io.ReadSeekCloser, options *AdministrationLargePersonGroupClientAddFaceOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	if personID == "" {
		return nil, errors.New("parameter personID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{personId}", url.PathEscape(personID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DetectionModel != nil {
		reqQP.Set("detectionModel", string(*options.DetectionModel))
	}
	if options != nil && options.TargetFace != nil {
		reqQP.Set("targetFace", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.TargetFace), "[]")), ","))
	}
	if options != nil && options.UserData != nil {
		reqQP.Set("userData", *options.UserData)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/octet-stream"}
	if err := req.SetBody(imageContent, "application/octet-stream"); err != nil {
		return nil, err
	}
	return req, nil
}

// addFaceHandleResponse handles the AddFace response.
func (client *AdministrationLargePersonGroupClient) addFaceHandleResponse(resp *http.Response) (AdministrationLargePersonGroupClientAddFaceResponse, error) {
	result := AdministrationLargePersonGroupClientAddFaceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AddFaceResult); err != nil {
		return AdministrationLargePersonGroupClientAddFaceResponse{}, err
	}
	return result, nil
}

// AddFaceFromURL - Add a face to a person into a Large Person Group for face identification or verification.
//
// Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/add-large-person-group-person-face-from-url
// for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - personID - ID of the person.
//   - urlParam - URL of input image.
//   - options - AdministrationLargePersonGroupClientAddFaceFromURLOptions contains the optional parameters for the AdministrationLargePersonGroupClient.AddFaceFromURL
//     method.
func (client *AdministrationLargePersonGroupClient) AddFaceFromURL(ctx context.Context, largePersonGroupID string, personID string, urlParam string, options *AdministrationLargePersonGroupClientAddFaceFromURLOptions) (AdministrationLargePersonGroupClientAddFaceFromURLResponse, error) {
	var err error
	req, err := client.addFaceFromURLCreateRequest(ctx, largePersonGroupID, personID, urlParam, options)
	if err != nil {
		return AdministrationLargePersonGroupClientAddFaceFromURLResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientAddFaceFromURLResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientAddFaceFromURLResponse{}, err
	}
	resp, err := client.addFaceFromURLHandleResponse(httpResp)
	return resp, err
}

// addFaceFromURLCreateRequest creates the AddFaceFromURL request.
func (client *AdministrationLargePersonGroupClient) addFaceFromURLCreateRequest(ctx context.Context, largePersonGroupID string, personID string, urlParam string, options *AdministrationLargePersonGroupClientAddFaceFromURLOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	if personID == "" {
		return nil, errors.New("parameter personID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{personId}", url.PathEscape(personID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DetectionModel != nil {
		reqQP.Set("detectionModel", string(*options.DetectionModel))
	}
	if options != nil && options.TargetFace != nil {
		reqQP.Set("targetFace", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.TargetFace), "[]")), ","))
	}
	if options != nil && options.UserData != nil {
		reqQP.Set("userData", *options.UserData)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		Url string `json:"url"`
	}{
		Url: urlParam,
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// addFaceFromURLHandleResponse handles the AddFaceFromURL response.
func (client *AdministrationLargePersonGroupClient) addFaceFromURLHandleResponse(resp *http.Response) (AdministrationLargePersonGroupClientAddFaceFromURLResponse, error) {
	result := AdministrationLargePersonGroupClientAddFaceFromURLResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AddFaceResult); err != nil {
		return AdministrationLargePersonGroupClientAddFaceFromURLResponse{}, err
	}
	return result, nil
}

// Create - Create a new Large Person Group with user-specified largePersonGroupId, name, an optional userData and recognitionModel.
//
// Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/create-large-person-group for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - name - User defined name, maximum length is 128.
//   - options - AdministrationLargePersonGroupClientCreateOptions contains the optional parameters for the AdministrationLargePersonGroupClient.Create
//     method.
func (client *AdministrationLargePersonGroupClient) Create(ctx context.Context, largePersonGroupID string, name string, options *AdministrationLargePersonGroupClientCreateOptions) (AdministrationLargePersonGroupClientCreateResponse, error) {
	var err error
	req, err := client.createCreateRequest(ctx, largePersonGroupID, name, options)
	if err != nil {
		return AdministrationLargePersonGroupClientCreateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientCreateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientCreateResponse{}, err
	}
	return AdministrationLargePersonGroupClientCreateResponse{}, nil
}

// createCreateRequest creates the Create request.
func (client *AdministrationLargePersonGroupClient) createCreateRequest(ctx context.Context, largePersonGroupID string, name string, options *AdministrationLargePersonGroupClientCreateOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		Name             string                `json:"name"`
		UserData         *string               `json:"userData"`
		RecognitionModel *FaceRecognitionModel `json:"recognitionModel"`
	}{
		Name: name,
	}
	if options != nil && options.UserData != nil {
		body.UserData = options.UserData
	}
	if options != nil && options.RecognitionModel != nil {
		body.RecognitionModel = options.RecognitionModel
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// CreatePerson - Create a new person in a specified Large Person Group. To add face to this person, please call "Add Large
// Person Group Person Face".
//
// Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/create-large-person-group-person for
// more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - name - User defined name, maximum length is 128.
//   - options - AdministrationLargePersonGroupClientCreatePersonOptions contains the optional parameters for the AdministrationLargePersonGroupClient.CreatePerson
//     method.
func (client *AdministrationLargePersonGroupClient) CreatePerson(ctx context.Context, largePersonGroupID string, name string, options *AdministrationLargePersonGroupClientCreatePersonOptions) (AdministrationLargePersonGroupClientCreatePersonResponse, error) {
	var err error
	req, err := client.createPersonCreateRequest(ctx, largePersonGroupID, name, options)
	if err != nil {
		return AdministrationLargePersonGroupClientCreatePersonResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientCreatePersonResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientCreatePersonResponse{}, err
	}
	resp, err := client.createPersonHandleResponse(httpResp)
	return resp, err
}

// createPersonCreateRequest creates the CreatePerson request.
func (client *AdministrationLargePersonGroupClient) createPersonCreateRequest(ctx context.Context, largePersonGroupID string, name string, options *AdministrationLargePersonGroupClientCreatePersonOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}/persons"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		Name     string  `json:"name"`
		UserData *string `json:"userData"`
	}{
		Name: name,
	}
	if options != nil && options.UserData != nil {
		body.UserData = options.UserData
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createPersonHandleResponse handles the CreatePerson response.
func (client *AdministrationLargePersonGroupClient) createPersonHandleResponse(resp *http.Response) (AdministrationLargePersonGroupClientCreatePersonResponse, error) {
	result := AdministrationLargePersonGroupClientCreatePersonResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CreatePersonResult); err != nil {
		return AdministrationLargePersonGroupClientCreatePersonResponse{}, err
	}
	return result, nil
}

// Delete - Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/delete-large-person-group for
// more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - options - AdministrationLargePersonGroupClientDeleteOptions contains the optional parameters for the AdministrationLargePersonGroupClient.Delete
//     method.
func (client *AdministrationLargePersonGroupClient) Delete(ctx context.Context, largePersonGroupID string, options *AdministrationLargePersonGroupClientDeleteOptions) (AdministrationLargePersonGroupClientDeleteResponse, error) {
	var err error
	req, err := client.deleteCreateRequest(ctx, largePersonGroupID, options)
	if err != nil {
		return AdministrationLargePersonGroupClientDeleteResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientDeleteResponse{}, err
	}
	return AdministrationLargePersonGroupClientDeleteResponse{}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *AdministrationLargePersonGroupClient) deleteCreateRequest(ctx context.Context, largePersonGroupID string, _ *AdministrationLargePersonGroupClientDeleteOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteFace - Delete a face from a person in a Large Person Group by specified largePersonGroupId, personId and persistedFaceId.
//
// Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/delete-large-person-group-person-face
// for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - personID - ID of the person.
//   - persistedFaceID - Face ID of the face.
//   - options - AdministrationLargePersonGroupClientDeleteFaceOptions contains the optional parameters for the AdministrationLargePersonGroupClient.DeleteFace
//     method.
func (client *AdministrationLargePersonGroupClient) DeleteFace(ctx context.Context, largePersonGroupID string, personID string, persistedFaceID string, options *AdministrationLargePersonGroupClientDeleteFaceOptions) (AdministrationLargePersonGroupClientDeleteFaceResponse, error) {
	var err error
	req, err := client.deleteFaceCreateRequest(ctx, largePersonGroupID, personID, persistedFaceID, options)
	if err != nil {
		return AdministrationLargePersonGroupClientDeleteFaceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientDeleteFaceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientDeleteFaceResponse{}, err
	}
	return AdministrationLargePersonGroupClientDeleteFaceResponse{}, nil
}

// deleteFaceCreateRequest creates the DeleteFace request.
func (client *AdministrationLargePersonGroupClient) deleteFaceCreateRequest(ctx context.Context, largePersonGroupID string, personID string, persistedFaceID string, _ *AdministrationLargePersonGroupClientDeleteFaceOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	if personID == "" {
		return nil, errors.New("parameter personID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{personId}", url.PathEscape(personID))
	if persistedFaceID == "" {
		return nil, errors.New("parameter persistedFaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{persistedFaceId}", url.PathEscape(persistedFaceID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeletePerson - Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/delete-large-person-group-person
// for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - personID - ID of the person.
//   - options - AdministrationLargePersonGroupClientDeletePersonOptions contains the optional parameters for the AdministrationLargePersonGroupClient.DeletePerson
//     method.
func (client *AdministrationLargePersonGroupClient) DeletePerson(ctx context.Context, largePersonGroupID string, personID string, options *AdministrationLargePersonGroupClientDeletePersonOptions) (AdministrationLargePersonGroupClientDeletePersonResponse, error) {
	var err error
	req, err := client.deletePersonCreateRequest(ctx, largePersonGroupID, personID, options)
	if err != nil {
		return AdministrationLargePersonGroupClientDeletePersonResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientDeletePersonResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientDeletePersonResponse{}, err
	}
	return AdministrationLargePersonGroupClientDeletePersonResponse{}, nil
}

// deletePersonCreateRequest creates the DeletePerson request.
func (client *AdministrationLargePersonGroupClient) deletePersonCreateRequest(ctx context.Context, largePersonGroupID string, personID string, _ *AdministrationLargePersonGroupClientDeletePersonOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}/persons/{personId}"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	if personID == "" {
		return nil, errors.New("parameter personID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{personId}", url.PathEscape(personID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// Get - Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/get-large-person-group for more
// details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - options - AdministrationLargePersonGroupClientGetOptions contains the optional parameters for the AdministrationLargePersonGroupClient.Get
//     method.
func (client *AdministrationLargePersonGroupClient) Get(ctx context.Context, largePersonGroupID string, options *AdministrationLargePersonGroupClientGetOptions) (AdministrationLargePersonGroupClientGetResponse, error) {
	var err error
	req, err := client.getCreateRequest(ctx, largePersonGroupID, options)
	if err != nil {
		return AdministrationLargePersonGroupClientGetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientGetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientGetResponse{}, err
	}
	resp, err := client.getHandleResponse(httpResp)
	return resp, err
}

// getCreateRequest creates the Get request.
func (client *AdministrationLargePersonGroupClient) getCreateRequest(ctx context.Context, largePersonGroupID string, options *AdministrationLargePersonGroupClientGetOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ReturnRecognitionModel != nil {
		reqQP.Set("returnRecognitionModel", strconv.FormatBool(*options.ReturnRecognitionModel))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *AdministrationLargePersonGroupClient) getHandleResponse(resp *http.Response) (AdministrationLargePersonGroupClientGetResponse, error) {
	result := AdministrationLargePersonGroupClientGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.LargePersonGroup); err != nil {
		return AdministrationLargePersonGroupClientGetResponse{}, err
	}
	return result, nil
}

// GetFace - Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/get-large-person-group-person-face
// for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - personID - ID of the person.
//   - persistedFaceID - Face ID of the face.
//   - options - AdministrationLargePersonGroupClientGetFaceOptions contains the optional parameters for the AdministrationLargePersonGroupClient.GetFace
//     method.
func (client *AdministrationLargePersonGroupClient) GetFace(ctx context.Context, largePersonGroupID string, personID string, persistedFaceID string, options *AdministrationLargePersonGroupClientGetFaceOptions) (AdministrationLargePersonGroupClientGetFaceResponse, error) {
	var err error
	req, err := client.getFaceCreateRequest(ctx, largePersonGroupID, personID, persistedFaceID, options)
	if err != nil {
		return AdministrationLargePersonGroupClientGetFaceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientGetFaceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientGetFaceResponse{}, err
	}
	resp, err := client.getFaceHandleResponse(httpResp)
	return resp, err
}

// getFaceCreateRequest creates the GetFace request.
func (client *AdministrationLargePersonGroupClient) getFaceCreateRequest(ctx context.Context, largePersonGroupID string, personID string, persistedFaceID string, _ *AdministrationLargePersonGroupClientGetFaceOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	if personID == "" {
		return nil, errors.New("parameter personID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{personId}", url.PathEscape(personID))
	if persistedFaceID == "" {
		return nil, errors.New("parameter persistedFaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{persistedFaceId}", url.PathEscape(persistedFaceID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFaceHandleResponse handles the GetFace response.
func (client *AdministrationLargePersonGroupClient) getFaceHandleResponse(resp *http.Response) (AdministrationLargePersonGroupClientGetFaceResponse, error) {
	result := AdministrationLargePersonGroupClientGetFaceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.LargePersonGroupPersonFace); err != nil {
		return AdministrationLargePersonGroupClientGetFaceResponse{}, err
	}
	return result, nil
}

// GetLargePersonGroups - List all existing Large Person Groups' largePersonGroupId, name, userData and recognitionModel.
//
// Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/get-large-person-groups for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - AdministrationLargePersonGroupClientGetLargePersonGroupsOptions contains the optional parameters for the AdministrationLargePersonGroupClient.GetLargePersonGroups
//     method.
func (client *AdministrationLargePersonGroupClient) GetLargePersonGroups(ctx context.Context, options *AdministrationLargePersonGroupClientGetLargePersonGroupsOptions) (AdministrationLargePersonGroupClientGetLargePersonGroupsResponse, error) {
	var err error
	req, err := client.getLargePersonGroupsCreateRequest(ctx, options)
	if err != nil {
		return AdministrationLargePersonGroupClientGetLargePersonGroupsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientGetLargePersonGroupsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientGetLargePersonGroupsResponse{}, err
	}
	resp, err := client.getLargePersonGroupsHandleResponse(httpResp)
	return resp, err
}

// getLargePersonGroupsCreateRequest creates the GetLargePersonGroups request.
func (client *AdministrationLargePersonGroupClient) getLargePersonGroupsCreateRequest(ctx context.Context, options *AdministrationLargePersonGroupClientGetLargePersonGroupsOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ReturnRecognitionModel != nil {
		reqQP.Set("returnRecognitionModel", strconv.FormatBool(*options.ReturnRecognitionModel))
	}
	if options != nil && options.Start != nil {
		reqQP.Set("start", *options.Start)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLargePersonGroupsHandleResponse handles the GetLargePersonGroups response.
func (client *AdministrationLargePersonGroupClient) getLargePersonGroupsHandleResponse(resp *http.Response) (AdministrationLargePersonGroupClientGetLargePersonGroupsResponse, error) {
	result := AdministrationLargePersonGroupClientGetLargePersonGroupsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.LargePersonGroupArray); err != nil {
		return AdministrationLargePersonGroupClientGetLargePersonGroupsResponse{}, err
	}
	return result, nil
}

// GetPerson - Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/get-large-person-group-person
// for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - personID - ID of the person.
//   - options - AdministrationLargePersonGroupClientGetPersonOptions contains the optional parameters for the AdministrationLargePersonGroupClient.GetPerson
//     method.
func (client *AdministrationLargePersonGroupClient) GetPerson(ctx context.Context, largePersonGroupID string, personID string, options *AdministrationLargePersonGroupClientGetPersonOptions) (AdministrationLargePersonGroupClientGetPersonResponse, error) {
	var err error
	req, err := client.getPersonCreateRequest(ctx, largePersonGroupID, personID, options)
	if err != nil {
		return AdministrationLargePersonGroupClientGetPersonResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientGetPersonResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientGetPersonResponse{}, err
	}
	resp, err := client.getPersonHandleResponse(httpResp)
	return resp, err
}

// getPersonCreateRequest creates the GetPerson request.
func (client *AdministrationLargePersonGroupClient) getPersonCreateRequest(ctx context.Context, largePersonGroupID string, personID string, _ *AdministrationLargePersonGroupClientGetPersonOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}/persons/{personId}"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	if personID == "" {
		return nil, errors.New("parameter personID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{personId}", url.PathEscape(personID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPersonHandleResponse handles the GetPerson response.
func (client *AdministrationLargePersonGroupClient) getPersonHandleResponse(resp *http.Response) (AdministrationLargePersonGroupClientGetPersonResponse, error) {
	result := AdministrationLargePersonGroupClientGetPersonResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.LargePersonGroupPerson); err != nil {
		return AdministrationLargePersonGroupClientGetPersonResponse{}, err
	}
	return result, nil
}

// GetPersons - List all persons' information in the specified Large Person Group, including personId, name, userData and
// persistedFaceIds of registered person faces.
//
// Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/get-large-person-group-persons for more
// details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - options - AdministrationLargePersonGroupClientGetPersonsOptions contains the optional parameters for the AdministrationLargePersonGroupClient.GetPersons
//     method.
func (client *AdministrationLargePersonGroupClient) GetPersons(ctx context.Context, largePersonGroupID string, options *AdministrationLargePersonGroupClientGetPersonsOptions) (AdministrationLargePersonGroupClientGetPersonsResponse, error) {
	var err error
	req, err := client.getPersonsCreateRequest(ctx, largePersonGroupID, options)
	if err != nil {
		return AdministrationLargePersonGroupClientGetPersonsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientGetPersonsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientGetPersonsResponse{}, err
	}
	resp, err := client.getPersonsHandleResponse(httpResp)
	return resp, err
}

// getPersonsCreateRequest creates the GetPersons request.
func (client *AdministrationLargePersonGroupClient) getPersonsCreateRequest(ctx context.Context, largePersonGroupID string, options *AdministrationLargePersonGroupClientGetPersonsOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}/persons"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Start != nil {
		reqQP.Set("start", *options.Start)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPersonsHandleResponse handles the GetPersons response.
func (client *AdministrationLargePersonGroupClient) getPersonsHandleResponse(resp *http.Response) (AdministrationLargePersonGroupClientGetPersonsResponse, error) {
	result := AdministrationLargePersonGroupClientGetPersonsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.LargePersonGroupPersonArray); err != nil {
		return AdministrationLargePersonGroupClientGetPersonsResponse{}, err
	}
	return result, nil
}

// GetTrainingStatus - To check Large Person Group training status completed or still ongoing. Large Person Group training
// is an asynchronous operation triggered by "Train Large Person Group" API.
//
// Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/get-large-person-group-training-status
// for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - options - AdministrationLargePersonGroupClientGetTrainingStatusOptions contains the optional parameters for the AdministrationLargePersonGroupClient.GetTrainingStatus
//     method.
func (client *AdministrationLargePersonGroupClient) GetTrainingStatus(ctx context.Context, largePersonGroupID string, options *AdministrationLargePersonGroupClientGetTrainingStatusOptions) (AdministrationLargePersonGroupClientGetTrainingStatusResponse, error) {
	var err error
	req, err := client.getTrainingStatusCreateRequest(ctx, largePersonGroupID, options)
	if err != nil {
		return AdministrationLargePersonGroupClientGetTrainingStatusResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientGetTrainingStatusResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientGetTrainingStatusResponse{}, err
	}
	resp, err := client.getTrainingStatusHandleResponse(httpResp)
	return resp, err
}

// getTrainingStatusCreateRequest creates the GetTrainingStatus request.
func (client *AdministrationLargePersonGroupClient) getTrainingStatusCreateRequest(ctx context.Context, largePersonGroupID string, _ *AdministrationLargePersonGroupClientGetTrainingStatusOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}/training"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTrainingStatusHandleResponse handles the GetTrainingStatus response.
func (client *AdministrationLargePersonGroupClient) getTrainingStatusHandleResponse(resp *http.Response) (AdministrationLargePersonGroupClientGetTrainingStatusResponse, error) {
	result := AdministrationLargePersonGroupClientGetTrainingStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TrainingResult); err != nil {
		return AdministrationLargePersonGroupClientGetTrainingStatusResponse{}, err
	}
	return result, nil
}

// BeginTrain - Submit a Large Person Group training task. Training is a crucial step that only a trained Large Person Group
// can be used by "Identify From Large Person Group".
//
// Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/train-large-person-group for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - options - AdministrationLargePersonGroupClientBeginTrainOptions contains the optional parameters for the AdministrationLargePersonGroupClient.BeginTrain
//     method.
func (client *AdministrationLargePersonGroupClient) BeginTrain(ctx context.Context, largePersonGroupID string, options *AdministrationLargePersonGroupClientBeginTrainOptions) (*runtime.Poller[AdministrationLargePersonGroupClientTrainResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.train(ctx, largePersonGroupID, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller[AdministrationLargePersonGroupClientTrainResponse](resp, client.internal.Pipeline(), nil)
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken[AdministrationLargePersonGroupClientTrainResponse](options.ResumeToken, client.internal.Pipeline(), nil)
	}
}

// Train - Submit a Large Person Group training task. Training is a crucial step that only a trained Large Person Group can
// be used by "Identify From Large Person Group".
//
// Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/train-large-person-group for more details.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *AdministrationLargePersonGroupClient) train(ctx context.Context, largePersonGroupID string, options *AdministrationLargePersonGroupClientBeginTrainOptions) (*http.Response, error) {
	var err error
	req, err := client.trainCreateRequest(ctx, largePersonGroupID, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// trainCreateRequest creates the Train request.
func (client *AdministrationLargePersonGroupClient) trainCreateRequest(ctx context.Context, largePersonGroupID string, _ *AdministrationLargePersonGroupClientBeginTrainOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}/train"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// Update - Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/update-large-person-group for
// more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - options - AdministrationLargePersonGroupClientUpdateOptions contains the optional parameters for the AdministrationLargePersonGroupClient.Update
//     method.
func (client *AdministrationLargePersonGroupClient) Update(ctx context.Context, largePersonGroupID string, options *AdministrationLargePersonGroupClientUpdateOptions) (AdministrationLargePersonGroupClientUpdateResponse, error) {
	var err error
	req, err := client.updateCreateRequest(ctx, largePersonGroupID, options)
	if err != nil {
		return AdministrationLargePersonGroupClientUpdateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientUpdateResponse{}, err
	}
	return AdministrationLargePersonGroupClientUpdateResponse{}, nil
}

// updateCreateRequest creates the Update request.
func (client *AdministrationLargePersonGroupClient) updateCreateRequest(ctx context.Context, largePersonGroupID string, options *AdministrationLargePersonGroupClientUpdateOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		Name     *string `json:"name"`
		UserData *string `json:"userData"`
	}{}
	if options != nil && options.Name != nil {
		body.Name = options.Name
	}
	if options != nil && options.UserData != nil {
		body.UserData = options.UserData
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// UpdateFace - Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/update-large-person-group-person-face
// for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - personID - ID of the person.
//   - persistedFaceID - Face ID of the face.
//   - options - AdministrationLargePersonGroupClientUpdateFaceOptions contains the optional parameters for the AdministrationLargePersonGroupClient.UpdateFace
//     method.
func (client *AdministrationLargePersonGroupClient) UpdateFace(ctx context.Context, largePersonGroupID string, personID string, persistedFaceID string, options *AdministrationLargePersonGroupClientUpdateFaceOptions) (AdministrationLargePersonGroupClientUpdateFaceResponse, error) {
	var err error
	req, err := client.updateFaceCreateRequest(ctx, largePersonGroupID, personID, persistedFaceID, options)
	if err != nil {
		return AdministrationLargePersonGroupClientUpdateFaceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientUpdateFaceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientUpdateFaceResponse{}, err
	}
	return AdministrationLargePersonGroupClientUpdateFaceResponse{}, nil
}

// updateFaceCreateRequest creates the UpdateFace request.
func (client *AdministrationLargePersonGroupClient) updateFaceCreateRequest(ctx context.Context, largePersonGroupID string, personID string, persistedFaceID string, options *AdministrationLargePersonGroupClientUpdateFaceOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	if personID == "" {
		return nil, errors.New("parameter personID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{personId}", url.PathEscape(personID))
	if persistedFaceID == "" {
		return nil, errors.New("parameter persistedFaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{persistedFaceId}", url.PathEscape(persistedFaceID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		UserData *string `json:"userData"`
	}{}
	if options != nil && options.UserData != nil {
		body.UserData = options.UserData
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// UpdatePerson - Please refer to https://learn.microsoft.com/rest/api/face/person-group-operations/update-large-person-group-person
// for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - largePersonGroupID - ID of the container.
//   - personID - ID of the person.
//   - options - AdministrationLargePersonGroupClientUpdatePersonOptions contains the optional parameters for the AdministrationLargePersonGroupClient.UpdatePerson
//     method.
func (client *AdministrationLargePersonGroupClient) UpdatePerson(ctx context.Context, largePersonGroupID string, personID string, options *AdministrationLargePersonGroupClientUpdatePersonOptions) (AdministrationLargePersonGroupClientUpdatePersonResponse, error) {
	var err error
	req, err := client.updatePersonCreateRequest(ctx, largePersonGroupID, personID, options)
	if err != nil {
		return AdministrationLargePersonGroupClientUpdatePersonResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AdministrationLargePersonGroupClientUpdatePersonResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return AdministrationLargePersonGroupClientUpdatePersonResponse{}, err
	}
	return AdministrationLargePersonGroupClientUpdatePersonResponse{}, nil
}

// updatePersonCreateRequest creates the UpdatePerson request.
func (client *AdministrationLargePersonGroupClient) updatePersonCreateRequest(ctx context.Context, largePersonGroupID string, personID string, options *AdministrationLargePersonGroupClientUpdatePersonOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/largepersongroups/{largePersonGroupId}/persons/{personId}"
	if largePersonGroupID == "" {
		return nil, errors.New("parameter largePersonGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{largePersonGroupId}", url.PathEscape(largePersonGroupID))
	if personID == "" {
		return nil, errors.New("parameter personID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{personId}", url.PathEscape(personID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		Name     *string `json:"name"`
		UserData *string `json:"userData"`
	}{}
	if options != nil && options.Name != nil {
		body.Name = options.Name
	}
	if options != nil && options.UserData != nil {
		body.UserData = options.UserData
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}
