// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package azface

import (
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"io"
	"net/http"
	"strconv"
	"strings"
)

// Client contains the methods for the group.
// Don't use this type directly, use a constructor function instead.
type Client struct {
	internal   *azcore.Client
	endpoint   string
	apiVersion Versions
}

// FindSimilar - Given query face's faceId, to search the similar-looking faces from a faceId array. A faceId array contains
// the faces created by Detect.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-recognition-operations/find-similar for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - faceID - faceId of the query face. User needs to call "Detect" first to get a valid faceId. Note that this faceId is not
//     persisted and will expire 24 hours after the detection call.
//   - faceIDs - An array of candidate faceIds. All of them are created by "Detect" and the faceIds will expire 24 hours after
//     the detection call. The number of faceIds is limited to 1000.
//   - options - ClientFindSimilarOptions contains the optional parameters for the Client.FindSimilar method.
func (client *Client) FindSimilar(ctx context.Context, faceID string, faceIDs []string, options *ClientFindSimilarOptions) (ClientFindSimilarResponse, error) {
	var err error
	req, err := client.findSimilarCreateRequest(ctx, faceID, faceIDs, options)
	if err != nil {
		return ClientFindSimilarResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientFindSimilarResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientFindSimilarResponse{}, err
	}
	resp, err := client.findSimilarHandleResponse(httpResp)
	return resp, err
}

// findSimilarCreateRequest creates the FindSimilar request.
func (client *Client) findSimilarCreateRequest(ctx context.Context, faceID string, faceIDs []string, options *ClientFindSimilarOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/findsimilars"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		FaceId                     string                `json:"faceId"`
		MaxNumOfCandidatesReturned *int32                `json:"maxNumOfCandidatesReturned"`
		Mode                       *FindSimilarMatchMode `json:"mode"`
		FaceIds                    []string              `json:"faceIds"`
	}{
		FaceId:  faceID,
		FaceIds: faceIDs,
	}
	if options != nil && options.MaxNumOfCandidatesReturned != nil {
		body.MaxNumOfCandidatesReturned = options.MaxNumOfCandidatesReturned
	}
	if options != nil && options.Mode != nil {
		body.Mode = options.Mode
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// findSimilarHandleResponse handles the FindSimilar response.
func (client *Client) findSimilarHandleResponse(resp *http.Response) (ClientFindSimilarResponse, error) {
	result := ClientFindSimilarResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FindSimilarResultArray); err != nil {
		return ClientFindSimilarResponse{}, err
	}
	return result, nil
}

// FindSimilarFromLargeFaceList - Given query face's faceId, to search the similar-looking faces from a Large Face List. A
// 'largeFaceListId' is created by Create Large Face List.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-recognition-operations/find-similar-from-large-face-list
// for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - faceID - faceId of the query face. User needs to call "Detect" first to get a valid faceId. Note that this faceId is not
//     persisted and will expire 24 hours after the detection call.
//   - largeFaceListID - An existing user-specified unique candidate Large Face List, created in "Create Large Face List". Large
//     Face List contains a set of persistedFaceIds which are persisted and will never expire.
//   - options - ClientFindSimilarFromLargeFaceListOptions contains the optional parameters for the Client.FindSimilarFromLargeFaceList
//     method.
func (client *Client) FindSimilarFromLargeFaceList(ctx context.Context, faceID string, largeFaceListID string, options *ClientFindSimilarFromLargeFaceListOptions) (ClientFindSimilarFromLargeFaceListResponse, error) {
	var err error
	req, err := client.findSimilarFromLargeFaceListCreateRequest(ctx, faceID, largeFaceListID, options)
	if err != nil {
		return ClientFindSimilarFromLargeFaceListResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientFindSimilarFromLargeFaceListResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientFindSimilarFromLargeFaceListResponse{}, err
	}
	resp, err := client.findSimilarFromLargeFaceListHandleResponse(httpResp)
	return resp, err
}

// findSimilarFromLargeFaceListCreateRequest creates the FindSimilarFromLargeFaceList request.
func (client *Client) findSimilarFromLargeFaceListCreateRequest(ctx context.Context, faceID string, largeFaceListID string, options *ClientFindSimilarFromLargeFaceListOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/findsimilars"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		FaceId                     string                `json:"faceId"`
		MaxNumOfCandidatesReturned *int32                `json:"maxNumOfCandidatesReturned"`
		Mode                       *FindSimilarMatchMode `json:"mode"`
		LargeFaceListId            string                `json:"largeFaceListId"`
	}{
		FaceId:          faceID,
		LargeFaceListId: largeFaceListID,
	}
	if options != nil && options.MaxNumOfCandidatesReturned != nil {
		body.MaxNumOfCandidatesReturned = options.MaxNumOfCandidatesReturned
	}
	if options != nil && options.Mode != nil {
		body.Mode = options.Mode
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// findSimilarFromLargeFaceListHandleResponse handles the FindSimilarFromLargeFaceList response.
func (client *Client) findSimilarFromLargeFaceListHandleResponse(resp *http.Response) (ClientFindSimilarFromLargeFaceListResponse, error) {
	result := ClientFindSimilarFromLargeFaceListResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FindSimilarResultArray); err != nil {
		return ClientFindSimilarFromLargeFaceListResponse{}, err
	}
	return result, nil
}

// Group - Divide candidate faces into groups based on face similarity.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-recognition-operations/group for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - faceIDs - Array of candidate faceIds created by "Detect". The maximum is 1000 faces.
//   - options - ClientGroupOptions contains the optional parameters for the Client.Group method.
func (client *Client) Group(ctx context.Context, faceIDs []string, options *ClientGroupOptions) (ClientGroupResponse, error) {
	var err error
	req, err := client.groupCreateRequest(ctx, faceIDs, options)
	if err != nil {
		return ClientGroupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientGroupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientGroupResponse{}, err
	}
	resp, err := client.groupHandleResponse(httpResp)
	return resp, err
}

// groupCreateRequest creates the Group request.
func (client *Client) groupCreateRequest(ctx context.Context, faceIDs []string, _ *ClientGroupOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/group"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		FaceIds []string `json:"faceIds"`
	}{
		FaceIds: faceIDs,
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// groupHandleResponse handles the Group response.
func (client *Client) groupHandleResponse(resp *http.Response) (ClientGroupResponse, error) {
	result := ClientGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.GroupingResult); err != nil {
		return ClientGroupResponse{}, err
	}
	return result, nil
}

// IdentifyFromLargePersonGroup - 1-to-many identification to find the closest matches of the specific query person face from
// a Large Person Group.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-recognition-operations/identify-from-person-group for more
// details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - faceIDs - Array of query faces faceIds, created by the "Detect". Each of the faces are identified independently. The valid
//     number of faceIds is between [1, 10].
//   - largePersonGroupID - largePersonGroupId of the target Large Person Group, created by "Create Large Person Group". Parameter
//     personGroupId and largePersonGroupId should not be provided at the same time.
//   - options - ClientIdentifyFromLargePersonGroupOptions contains the optional parameters for the Client.IdentifyFromLargePersonGroup
//     method.
func (client *Client) IdentifyFromLargePersonGroup(ctx context.Context, faceIDs []string, largePersonGroupID string, options *ClientIdentifyFromLargePersonGroupOptions) (ClientIdentifyFromLargePersonGroupResponse, error) {
	var err error
	req, err := client.identifyFromLargePersonGroupCreateRequest(ctx, faceIDs, largePersonGroupID, options)
	if err != nil {
		return ClientIdentifyFromLargePersonGroupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientIdentifyFromLargePersonGroupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientIdentifyFromLargePersonGroupResponse{}, err
	}
	resp, err := client.identifyFromLargePersonGroupHandleResponse(httpResp)
	return resp, err
}

// identifyFromLargePersonGroupCreateRequest creates the IdentifyFromLargePersonGroup request.
func (client *Client) identifyFromLargePersonGroupCreateRequest(ctx context.Context, faceIDs []string, largePersonGroupID string, options *ClientIdentifyFromLargePersonGroupOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/identify"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		FaceIds                    []string `json:"faceIds"`
		LargePersonGroupId         string   `json:"largePersonGroupId"`
		MaxNumOfCandidatesReturned *int32   `json:"maxNumOfCandidatesReturned"`
		ConfidenceThreshold        *float32 `json:"confidenceThreshold"`
	}{
		FaceIds:            faceIDs,
		LargePersonGroupId: largePersonGroupID,
	}
	if options != nil && options.MaxNumOfCandidatesReturned != nil {
		body.MaxNumOfCandidatesReturned = options.MaxNumOfCandidatesReturned
	}
	if options != nil && options.ConfidenceThreshold != nil {
		body.ConfidenceThreshold = options.ConfidenceThreshold
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// identifyFromLargePersonGroupHandleResponse handles the IdentifyFromLargePersonGroup response.
func (client *Client) identifyFromLargePersonGroupHandleResponse(resp *http.Response) (ClientIdentifyFromLargePersonGroupResponse, error) {
	result := ClientIdentifyFromLargePersonGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IdentificationResultArray); err != nil {
		return ClientIdentifyFromLargePersonGroupResponse{}, err
	}
	return result, nil
}

// VerifyFaceToFace - Verify whether two faces belong to a same person.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-recognition-operations/verify-face-to-face for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - faceId1 - The faceId of one face, come from "Detect".
//   - faceId2 - The faceId of another face, come from "Detect".
//   - options - ClientVerifyFaceToFaceOptions contains the optional parameters for the Client.VerifyFaceToFace method.
func (client *Client) VerifyFaceToFace(ctx context.Context, faceId1 string, faceId2 string, options *ClientVerifyFaceToFaceOptions) (ClientVerifyFaceToFaceResponse, error) {
	var err error
	req, err := client.verifyFaceToFaceCreateRequest(ctx, faceId1, faceId2, options)
	if err != nil {
		return ClientVerifyFaceToFaceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientVerifyFaceToFaceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientVerifyFaceToFaceResponse{}, err
	}
	resp, err := client.verifyFaceToFaceHandleResponse(httpResp)
	return resp, err
}

// verifyFaceToFaceCreateRequest creates the VerifyFaceToFace request.
func (client *Client) verifyFaceToFaceCreateRequest(ctx context.Context, faceId1 string, faceId2 string, _ *ClientVerifyFaceToFaceOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/verify"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		FaceId1 string `json:"faceId1"`
		FaceId2 string `json:"faceId2"`
	}{
		FaceId1: faceId1,
		FaceId2: faceId2,
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// verifyFaceToFaceHandleResponse handles the VerifyFaceToFace response.
func (client *Client) verifyFaceToFaceHandleResponse(resp *http.Response) (ClientVerifyFaceToFaceResponse, error) {
	result := ClientVerifyFaceToFaceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VerificationResult); err != nil {
		return ClientVerifyFaceToFaceResponse{}, err
	}
	return result, nil
}

// VerifyFromLargePersonGroup - Verify whether a face belongs to a person in a Large Person Group.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-recognition-operations/verify-from-large-person-group for
// more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - faceID - The faceId of the face, come from "Detect".
//   - largePersonGroupID - Using existing largePersonGroupId and personId for fast loading a specified person. largePersonGroupId
//     is created in "Create Large Person Group".
//   - personID - Specify a certain person in Large Person Group.
//   - options - ClientVerifyFromLargePersonGroupOptions contains the optional parameters for the Client.VerifyFromLargePersonGroup
//     method.
func (client *Client) VerifyFromLargePersonGroup(ctx context.Context, faceID string, largePersonGroupID string, personID string, options *ClientVerifyFromLargePersonGroupOptions) (ClientVerifyFromLargePersonGroupResponse, error) {
	var err error
	req, err := client.verifyFromLargePersonGroupCreateRequest(ctx, faceID, largePersonGroupID, personID, options)
	if err != nil {
		return ClientVerifyFromLargePersonGroupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientVerifyFromLargePersonGroupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientVerifyFromLargePersonGroupResponse{}, err
	}
	resp, err := client.verifyFromLargePersonGroupHandleResponse(httpResp)
	return resp, err
}

// verifyFromLargePersonGroupCreateRequest creates the VerifyFromLargePersonGroup request.
func (client *Client) verifyFromLargePersonGroupCreateRequest(ctx context.Context, faceID string, largePersonGroupID string, personID string, _ *ClientVerifyFromLargePersonGroupOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/verify"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		FaceId             string `json:"faceId"`
		LargePersonGroupId string `json:"largePersonGroupId"`
		PersonId           string `json:"personId"`
	}{
		FaceId:             faceID,
		LargePersonGroupId: largePersonGroupID,
		PersonId:           personID,
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// verifyFromLargePersonGroupHandleResponse handles the VerifyFromLargePersonGroup response.
func (client *Client) verifyFromLargePersonGroupHandleResponse(resp *http.Response) (ClientVerifyFromLargePersonGroupResponse, error) {
	result := ClientVerifyFromLargePersonGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VerificationResult); err != nil {
		return ClientVerifyFromLargePersonGroupResponse{}, err
	}
	return result, nil
}

// detect - Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks, and attributes.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-detection-operations/detect for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - imageContent - The input image binary.
//   - options - clientdetectOptions contains the optional parameters for the Client.detect method.
func (client *Client) detect(ctx context.Context, imageContent io.ReadSeekCloser, options *clientdetectOptions) (clientdetectResponse, error) {
	var err error
	req, err := client.detectCreateRequest(ctx, imageContent, options)
	if err != nil {
		return clientdetectResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return clientdetectResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return clientdetectResponse{}, err
	}
	resp, err := client.detectHandleResponse(httpResp)
	return resp, err
}

// detectCreateRequest creates the detect request.
func (client *Client) detectCreateRequest(ctx context.Context, imageContent io.ReadSeekCloser, options *clientdetectOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/detect"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DetectionModel != nil {
		reqQP.Set("detectionModel", string(*options.DetectionModel))
	}
	if options != nil && options.FaceIDTimeToLive != nil {
		reqQP.Set("faceIdTimeToLive", strconv.FormatInt(int64(*options.FaceIDTimeToLive), 10))
	}
	if options != nil && options.RecognitionModel != nil {
		reqQP.Set("recognitionModel", string(*options.RecognitionModel))
	}
	if options != nil && options.ReturnFaceAttributes != nil {
		reqQP.Set("returnFaceAttributes", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.ReturnFaceAttributes), "[]")), ","))
	}
	if options != nil && options.ReturnFaceID != nil {
		reqQP.Set("returnFaceId", strconv.FormatBool(*options.ReturnFaceID))
	}
	if options != nil && options.ReturnFaceLandmarks != nil {
		reqQP.Set("returnFaceLandmarks", strconv.FormatBool(*options.ReturnFaceLandmarks))
	}
	if options != nil && options.ReturnRecognitionModel != nil {
		reqQP.Set("returnRecognitionModel", strconv.FormatBool(*options.ReturnRecognitionModel))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/octet-stream"}
	if err := req.SetBody(imageContent, "application/octet-stream"); err != nil {
		return nil, err
	}
	return req, nil
}

// detectHandleResponse handles the detect response.
func (client *Client) detectHandleResponse(resp *http.Response) (clientdetectResponse, error) {
	result := clientdetectResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DetectionResultArray); err != nil {
		return clientdetectResponse{}, err
	}
	return result, nil
}

// detectFromURL - Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks, and attributes.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-detection-operations/detect-from-url for more details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - urlParam - URL of input image.
//   - options - clientdetectFromURLOptions contains the optional parameters for the Client.detectFromURL method.
func (client *Client) detectFromURL(ctx context.Context, urlParam string, options *clientdetectFromURLOptions) (clientdetectFromURLResponse, error) {
	var err error
	req, err := client.detectFromURLCreateRequest(ctx, urlParam, options)
	if err != nil {
		return clientdetectFromURLResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return clientdetectFromURLResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return clientdetectFromURLResponse{}, err
	}
	resp, err := client.detectFromURLHandleResponse(httpResp)
	return resp, err
}

// detectFromURLCreateRequest creates the detectFromURL request.
func (client *Client) detectFromURLCreateRequest(ctx context.Context, urlParam string, options *clientdetectFromURLOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/detect"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DetectionModel != nil {
		reqQP.Set("detectionModel", string(*options.DetectionModel))
	}
	if options != nil && options.FaceIDTimeToLive != nil {
		reqQP.Set("faceIdTimeToLive", strconv.FormatInt(int64(*options.FaceIDTimeToLive), 10))
	}
	if options != nil && options.RecognitionModel != nil {
		reqQP.Set("recognitionModel", string(*options.RecognitionModel))
	}
	if options != nil && options.ReturnFaceAttributes != nil {
		reqQP.Set("returnFaceAttributes", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.ReturnFaceAttributes), "[]")), ","))
	}
	if options != nil && options.ReturnFaceID != nil {
		reqQP.Set("returnFaceId", strconv.FormatBool(*options.ReturnFaceID))
	}
	if options != nil && options.ReturnFaceLandmarks != nil {
		reqQP.Set("returnFaceLandmarks", strconv.FormatBool(*options.ReturnFaceLandmarks))
	}
	if options != nil && options.ReturnRecognitionModel != nil {
		reqQP.Set("returnRecognitionModel", strconv.FormatBool(*options.ReturnRecognitionModel))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		Url string `json:"url"`
	}{
		Url: urlParam,
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// detectFromURLHandleResponse handles the detectFromURL response.
func (client *Client) detectFromURLHandleResponse(resp *http.Response) (clientdetectFromURLResponse, error) {
	result := clientdetectFromURLResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DetectionResultArray); err != nil {
		return clientdetectFromURLResponse{}, err
	}
	return result, nil
}
