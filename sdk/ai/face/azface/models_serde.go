// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package azface

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AccessoryItem.
func (a AccessoryItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "confidence", a.Confidence)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessoryItem.
func (a *AccessoryItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "confidence":
			err = unpopulate(val, "Confidence", &a.Confidence)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddFaceResult.
func (a AddFaceResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "persistedFaceId", a.PersistedFaceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddFaceResult.
func (a *AddFaceResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "persistedFaceId":
			err = unpopulate(val, "PersistedFaceID", &a.PersistedFaceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Attributes.
func (a Attributes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessories", a.Accessories)
	populate(objectMap, "age", a.Age)
	populate(objectMap, "blur", a.Blur)
	populate(objectMap, "exposure", a.Exposure)
	populate(objectMap, "facialHair", a.FacialHair)
	populate(objectMap, "glasses", a.Glasses)
	populate(objectMap, "hair", a.Hair)
	populate(objectMap, "headPose", a.HeadPose)
	populate(objectMap, "mask", a.Mask)
	populate(objectMap, "noise", a.Noise)
	populate(objectMap, "occlusion", a.Occlusion)
	populate(objectMap, "qualityForRecognition", a.QualityForRecognition)
	populate(objectMap, "smile", a.Smile)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Attributes.
func (a *Attributes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessories":
			err = unpopulate(val, "Accessories", &a.Accessories)
			delete(rawMsg, key)
		case "age":
			err = unpopulate(val, "Age", &a.Age)
			delete(rawMsg, key)
		case "blur":
			err = unpopulate(val, "Blur", &a.Blur)
			delete(rawMsg, key)
		case "exposure":
			err = unpopulate(val, "Exposure", &a.Exposure)
			delete(rawMsg, key)
		case "facialHair":
			err = unpopulate(val, "FacialHair", &a.FacialHair)
			delete(rawMsg, key)
		case "glasses":
			err = unpopulate(val, "Glasses", &a.Glasses)
			delete(rawMsg, key)
		case "hair":
			err = unpopulate(val, "Hair", &a.Hair)
			delete(rawMsg, key)
		case "headPose":
			err = unpopulate(val, "HeadPose", &a.HeadPose)
			delete(rawMsg, key)
		case "mask":
			err = unpopulate(val, "Mask", &a.Mask)
			delete(rawMsg, key)
		case "noise":
			err = unpopulate(val, "Noise", &a.Noise)
			delete(rawMsg, key)
		case "occlusion":
			err = unpopulate(val, "Occlusion", &a.Occlusion)
			delete(rawMsg, key)
		case "qualityForRecognition":
			err = unpopulate(val, "QualityForRecognition", &a.QualityForRecognition)
			delete(rawMsg, key)
		case "smile":
			err = unpopulate(val, "Smile", &a.Smile)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BlurProperties.
func (b BlurProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blurLevel", b.BlurLevel)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlurProperties.
func (b *BlurProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blurLevel":
			err = unpopulate(val, "BlurLevel", &b.BlurLevel)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreatePersonResult.
func (c CreatePersonResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "personId", c.PersonID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreatePersonResult.
func (c *CreatePersonResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "personId":
			err = unpopulate(val, "PersonID", &c.PersonID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DetectionResult.
func (d DetectionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "faceAttributes", d.FaceAttributes)
	populate(objectMap, "faceId", d.FaceID)
	populate(objectMap, "faceLandmarks", d.FaceLandmarks)
	populate(objectMap, "faceRectangle", d.FaceRectangle)
	populate(objectMap, "recognitionModel", d.RecognitionModel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DetectionResult.
func (d *DetectionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "faceAttributes":
			err = unpopulate(val, "FaceAttributes", &d.FaceAttributes)
			delete(rawMsg, key)
		case "faceId":
			err = unpopulate(val, "FaceID", &d.FaceID)
			delete(rawMsg, key)
		case "faceLandmarks":
			err = unpopulate(val, "FaceLandmarks", &d.FaceLandmarks)
			delete(rawMsg, key)
		case "faceRectangle":
			err = unpopulate(val, "FaceRectangle", &d.FaceRectangle)
			delete(rawMsg, key)
		case "recognitionModel":
			err = unpopulate(val, "RecognitionModel", &d.RecognitionModel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExposureProperties.
func (e ExposureProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "exposureLevel", e.ExposureLevel)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExposureProperties.
func (e *ExposureProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exposureLevel":
			err = unpopulate(val, "ExposureLevel", &e.ExposureLevel)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FacialHair.
func (f FacialHair) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "beard", f.Beard)
	populate(objectMap, "moustache", f.Moustache)
	populate(objectMap, "sideburns", f.Sideburns)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FacialHair.
func (f *FacialHair) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "beard":
			err = unpopulate(val, "Beard", &f.Beard)
			delete(rawMsg, key)
		case "moustache":
			err = unpopulate(val, "Moustache", &f.Moustache)
			delete(rawMsg, key)
		case "sideburns":
			err = unpopulate(val, "Sideburns", &f.Sideburns)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FindSimilarResult.
func (f FindSimilarResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "confidence", f.Confidence)
	populate(objectMap, "faceId", f.FaceID)
	populate(objectMap, "persistedFaceId", f.PersistedFaceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FindSimilarResult.
func (f *FindSimilarResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "confidence":
			err = unpopulate(val, "Confidence", &f.Confidence)
			delete(rawMsg, key)
		case "faceId":
			err = unpopulate(val, "FaceID", &f.FaceID)
			delete(rawMsg, key)
		case "persistedFaceId":
			err = unpopulate(val, "PersistedFaceID", &f.PersistedFaceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GroupingResult.
func (g GroupingResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groups", g.Groups)
	populate(objectMap, "messyGroup", g.MessyGroup)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GroupingResult.
func (g *GroupingResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groups":
			err = unpopulate(val, "Groups", &g.Groups)
			delete(rawMsg, key)
		case "messyGroup":
			err = unpopulate(val, "MessyGroup", &g.MessyGroup)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HairColor.
func (h HairColor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "color", h.Color)
	populate(objectMap, "confidence", h.Confidence)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HairColor.
func (h *HairColor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "color":
			err = unpopulate(val, "Color", &h.Color)
			delete(rawMsg, key)
		case "confidence":
			err = unpopulate(val, "Confidence", &h.Confidence)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HairProperties.
func (h HairProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bald", h.Bald)
	populate(objectMap, "hairColor", h.HairColor)
	populate(objectMap, "invisible", h.Invisible)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HairProperties.
func (h *HairProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bald":
			err = unpopulate(val, "Bald", &h.Bald)
			delete(rawMsg, key)
		case "hairColor":
			err = unpopulate(val, "HairColor", &h.HairColor)
			delete(rawMsg, key)
		case "invisible":
			err = unpopulate(val, "Invisible", &h.Invisible)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HeadPose.
func (h HeadPose) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "pitch", h.Pitch)
	populate(objectMap, "roll", h.Roll)
	populate(objectMap, "yaw", h.Yaw)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HeadPose.
func (h *HeadPose) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "pitch":
			err = unpopulate(val, "Pitch", &h.Pitch)
			delete(rawMsg, key)
		case "roll":
			err = unpopulate(val, "Roll", &h.Roll)
			delete(rawMsg, key)
		case "yaw":
			err = unpopulate(val, "Yaw", &h.Yaw)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentificationCandidate.
func (i IdentificationCandidate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "confidence", i.Confidence)
	populate(objectMap, "personId", i.PersonID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentificationCandidate.
func (i *IdentificationCandidate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "confidence":
			err = unpopulate(val, "Confidence", &i.Confidence)
			delete(rawMsg, key)
		case "personId":
			err = unpopulate(val, "PersonID", &i.PersonID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentificationResult.
func (i IdentificationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "candidates", i.Candidates)
	populate(objectMap, "faceId", i.FaceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentificationResult.
func (i *IdentificationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "candidates":
			err = unpopulate(val, "Candidates", &i.Candidates)
			delete(rawMsg, key)
		case "faceId":
			err = unpopulate(val, "FaceID", &i.FaceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LandmarkCoordinate.
func (l LandmarkCoordinate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "x", l.X)
	populate(objectMap, "y", l.Y)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LandmarkCoordinate.
func (l *LandmarkCoordinate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "x":
			err = unpopulate(val, "X", &l.X)
			delete(rawMsg, key)
		case "y":
			err = unpopulate(val, "Y", &l.Y)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Landmarks.
func (l Landmarks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eyeLeftBottom", l.EyeLeftBottom)
	populate(objectMap, "eyeLeftInner", l.EyeLeftInner)
	populate(objectMap, "eyeLeftOuter", l.EyeLeftOuter)
	populate(objectMap, "eyeLeftTop", l.EyeLeftTop)
	populate(objectMap, "eyeRightBottom", l.EyeRightBottom)
	populate(objectMap, "eyeRightInner", l.EyeRightInner)
	populate(objectMap, "eyeRightOuter", l.EyeRightOuter)
	populate(objectMap, "eyeRightTop", l.EyeRightTop)
	populate(objectMap, "eyebrowLeftInner", l.EyebrowLeftInner)
	populate(objectMap, "eyebrowLeftOuter", l.EyebrowLeftOuter)
	populate(objectMap, "eyebrowRightInner", l.EyebrowRightInner)
	populate(objectMap, "eyebrowRightOuter", l.EyebrowRightOuter)
	populate(objectMap, "mouthLeft", l.MouthLeft)
	populate(objectMap, "mouthRight", l.MouthRight)
	populate(objectMap, "noseLeftAlarOutTip", l.NoseLeftAlarOutTip)
	populate(objectMap, "noseLeftAlarTop", l.NoseLeftAlarTop)
	populate(objectMap, "noseRightAlarOutTip", l.NoseRightAlarOutTip)
	populate(objectMap, "noseRightAlarTop", l.NoseRightAlarTop)
	populate(objectMap, "noseRootLeft", l.NoseRootLeft)
	populate(objectMap, "noseRootRight", l.NoseRootRight)
	populate(objectMap, "noseTip", l.NoseTip)
	populate(objectMap, "pupilLeft", l.PupilLeft)
	populate(objectMap, "pupilRight", l.PupilRight)
	populate(objectMap, "underLipBottom", l.UnderLipBottom)
	populate(objectMap, "underLipTop", l.UnderLipTop)
	populate(objectMap, "upperLipBottom", l.UpperLipBottom)
	populate(objectMap, "upperLipTop", l.UpperLipTop)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Landmarks.
func (l *Landmarks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eyeLeftBottom":
			err = unpopulate(val, "EyeLeftBottom", &l.EyeLeftBottom)
			delete(rawMsg, key)
		case "eyeLeftInner":
			err = unpopulate(val, "EyeLeftInner", &l.EyeLeftInner)
			delete(rawMsg, key)
		case "eyeLeftOuter":
			err = unpopulate(val, "EyeLeftOuter", &l.EyeLeftOuter)
			delete(rawMsg, key)
		case "eyeLeftTop":
			err = unpopulate(val, "EyeLeftTop", &l.EyeLeftTop)
			delete(rawMsg, key)
		case "eyeRightBottom":
			err = unpopulate(val, "EyeRightBottom", &l.EyeRightBottom)
			delete(rawMsg, key)
		case "eyeRightInner":
			err = unpopulate(val, "EyeRightInner", &l.EyeRightInner)
			delete(rawMsg, key)
		case "eyeRightOuter":
			err = unpopulate(val, "EyeRightOuter", &l.EyeRightOuter)
			delete(rawMsg, key)
		case "eyeRightTop":
			err = unpopulate(val, "EyeRightTop", &l.EyeRightTop)
			delete(rawMsg, key)
		case "eyebrowLeftInner":
			err = unpopulate(val, "EyebrowLeftInner", &l.EyebrowLeftInner)
			delete(rawMsg, key)
		case "eyebrowLeftOuter":
			err = unpopulate(val, "EyebrowLeftOuter", &l.EyebrowLeftOuter)
			delete(rawMsg, key)
		case "eyebrowRightInner":
			err = unpopulate(val, "EyebrowRightInner", &l.EyebrowRightInner)
			delete(rawMsg, key)
		case "eyebrowRightOuter":
			err = unpopulate(val, "EyebrowRightOuter", &l.EyebrowRightOuter)
			delete(rawMsg, key)
		case "mouthLeft":
			err = unpopulate(val, "MouthLeft", &l.MouthLeft)
			delete(rawMsg, key)
		case "mouthRight":
			err = unpopulate(val, "MouthRight", &l.MouthRight)
			delete(rawMsg, key)
		case "noseLeftAlarOutTip":
			err = unpopulate(val, "NoseLeftAlarOutTip", &l.NoseLeftAlarOutTip)
			delete(rawMsg, key)
		case "noseLeftAlarTop":
			err = unpopulate(val, "NoseLeftAlarTop", &l.NoseLeftAlarTop)
			delete(rawMsg, key)
		case "noseRightAlarOutTip":
			err = unpopulate(val, "NoseRightAlarOutTip", &l.NoseRightAlarOutTip)
			delete(rawMsg, key)
		case "noseRightAlarTop":
			err = unpopulate(val, "NoseRightAlarTop", &l.NoseRightAlarTop)
			delete(rawMsg, key)
		case "noseRootLeft":
			err = unpopulate(val, "NoseRootLeft", &l.NoseRootLeft)
			delete(rawMsg, key)
		case "noseRootRight":
			err = unpopulate(val, "NoseRootRight", &l.NoseRootRight)
			delete(rawMsg, key)
		case "noseTip":
			err = unpopulate(val, "NoseTip", &l.NoseTip)
			delete(rawMsg, key)
		case "pupilLeft":
			err = unpopulate(val, "PupilLeft", &l.PupilLeft)
			delete(rawMsg, key)
		case "pupilRight":
			err = unpopulate(val, "PupilRight", &l.PupilRight)
			delete(rawMsg, key)
		case "underLipBottom":
			err = unpopulate(val, "UnderLipBottom", &l.UnderLipBottom)
			delete(rawMsg, key)
		case "underLipTop":
			err = unpopulate(val, "UnderLipTop", &l.UnderLipTop)
			delete(rawMsg, key)
		case "upperLipBottom":
			err = unpopulate(val, "UpperLipBottom", &l.UpperLipBottom)
			delete(rawMsg, key)
		case "upperLipTop":
			err = unpopulate(val, "UpperLipTop", &l.UpperLipTop)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LargeFaceList.
func (l LargeFaceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "largeFaceListId", l.LargeFaceListID)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "recognitionModel", l.RecognitionModel)
	populate(objectMap, "userData", l.UserData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LargeFaceList.
func (l *LargeFaceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "largeFaceListId":
			err = unpopulate(val, "LargeFaceListID", &l.LargeFaceListID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "recognitionModel":
			err = unpopulate(val, "RecognitionModel", &l.RecognitionModel)
			delete(rawMsg, key)
		case "userData":
			err = unpopulate(val, "UserData", &l.UserData)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LargeFaceListFace.
func (l LargeFaceListFace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "persistedFaceId", l.PersistedFaceID)
	populate(objectMap, "userData", l.UserData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LargeFaceListFace.
func (l *LargeFaceListFace) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "persistedFaceId":
			err = unpopulate(val, "PersistedFaceID", &l.PersistedFaceID)
			delete(rawMsg, key)
		case "userData":
			err = unpopulate(val, "UserData", &l.UserData)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LargePersonGroup.
func (l LargePersonGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "largePersonGroupId", l.LargePersonGroupID)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "recognitionModel", l.RecognitionModel)
	populate(objectMap, "userData", l.UserData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LargePersonGroup.
func (l *LargePersonGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "largePersonGroupId":
			err = unpopulate(val, "LargePersonGroupID", &l.LargePersonGroupID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "recognitionModel":
			err = unpopulate(val, "RecognitionModel", &l.RecognitionModel)
			delete(rawMsg, key)
		case "userData":
			err = unpopulate(val, "UserData", &l.UserData)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LargePersonGroupPerson.
func (l LargePersonGroupPerson) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "persistedFaceIds", l.PersistedFaceIDs)
	populate(objectMap, "personId", l.PersonID)
	populate(objectMap, "userData", l.UserData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LargePersonGroupPerson.
func (l *LargePersonGroupPerson) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "persistedFaceIds":
			err = unpopulate(val, "PersistedFaceIDs", &l.PersistedFaceIDs)
			delete(rawMsg, key)
		case "personId":
			err = unpopulate(val, "PersonID", &l.PersonID)
			delete(rawMsg, key)
		case "userData":
			err = unpopulate(val, "UserData", &l.UserData)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LargePersonGroupPersonFace.
func (l LargePersonGroupPersonFace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "persistedFaceId", l.PersistedFaceID)
	populate(objectMap, "userData", l.UserData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LargePersonGroupPersonFace.
func (l *LargePersonGroupPersonFace) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "persistedFaceId":
			err = unpopulate(val, "PersistedFaceID", &l.PersistedFaceID)
			delete(rawMsg, key)
		case "userData":
			err = unpopulate(val, "UserData", &l.UserData)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MaskProperties.
func (m MaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "noseAndMouthCovered", m.NoseAndMouthCovered)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MaskProperties.
func (m *MaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "noseAndMouthCovered":
			err = unpopulate(val, "NoseAndMouthCovered", &m.NoseAndMouthCovered)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NoiseProperties.
func (n NoiseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "noiseLevel", n.NoiseLevel)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NoiseProperties.
func (n *NoiseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "noiseLevel":
			err = unpopulate(val, "NoiseLevel", &n.NoiseLevel)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OcclusionProperties.
func (o OcclusionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eyeOccluded", o.EyeOccluded)
	populate(objectMap, "foreheadOccluded", o.ForeheadOccluded)
	populate(objectMap, "mouthOccluded", o.MouthOccluded)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OcclusionProperties.
func (o *OcclusionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eyeOccluded":
			err = unpopulate(val, "EyeOccluded", &o.EyeOccluded)
			delete(rawMsg, key)
		case "foreheadOccluded":
			err = unpopulate(val, "ForeheadOccluded", &o.ForeheadOccluded)
			delete(rawMsg, key)
		case "mouthOccluded":
			err = unpopulate(val, "MouthOccluded", &o.MouthOccluded)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Rectangle.
func (r Rectangle) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "height", r.Height)
	populate(objectMap, "left", r.Left)
	populate(objectMap, "top", r.Top)
	populate(objectMap, "width", r.Width)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Rectangle.
func (r *Rectangle) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "height":
			err = unpopulate(val, "Height", &r.Height)
			delete(rawMsg, key)
		case "left":
			err = unpopulate(val, "Left", &r.Left)
			delete(rawMsg, key)
		case "top":
			err = unpopulate(val, "Top", &r.Top)
			delete(rawMsg, key)
		case "width":
			err = unpopulate(val, "Width", &r.Width)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TrainingResult.
func (t TrainingResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdDateTime", t.CreatedDateTime)
	populateDateTimeRFC3339(objectMap, "lastActionDateTime", t.LastActionDateTime)
	populateDateTimeRFC3339(objectMap, "lastSuccessfulTrainingDateTime", t.LastSuccessfulTrainingDateTime)
	populate(objectMap, "message", t.Message)
	populate(objectMap, "status", t.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TrainingResult.
func (t *TrainingResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDateTime":
			err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &t.CreatedDateTime)
			delete(rawMsg, key)
		case "lastActionDateTime":
			err = unpopulateDateTimeRFC3339(val, "LastActionDateTime", &t.LastActionDateTime)
			delete(rawMsg, key)
		case "lastSuccessfulTrainingDateTime":
			err = unpopulateDateTimeRFC3339(val, "LastSuccessfulTrainingDateTime", &t.LastSuccessfulTrainingDateTime)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &t.Message)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &t.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VerificationResult.
func (v VerificationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "confidence", v.Confidence)
	populate(objectMap, "isIdentical", v.IsIdentical)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerificationResult.
func (v *VerificationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "confidence":
			err = unpopulate(val, "Confidence", &v.Confidence)
			delete(rawMsg, key)
		case "isIdentical":
			err = unpopulate(val, "IsIdentical", &v.IsIdentical)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
