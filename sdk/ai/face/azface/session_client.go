// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package azface

import (
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"strings"
)

// SessionClient contains the methods for the Session group.
// Don't use this type directly, use a constructor function instead.
type SessionClient struct {
	internal   *azcore.Client
	endpoint   string
	apiVersion Versions
}

// DetectFromSessionImage - Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks,
// and attributes.
//
// Please refer to https://learn.microsoft.com/rest/api/face/face-detection-operations/detect-from-session-image-id for more
// details.
// If the operation fails it returns an *azcore.ResponseError type.
//   - sessionImageID - Id of session image.
//   - options - SessionClientDetectFromSessionImageOptions contains the optional parameters for the SessionClient.DetectFromSessionImage
//     method.
func (client *SessionClient) DetectFromSessionImage(ctx context.Context, sessionImageID string, options *SessionClientDetectFromSessionImageOptions) (SessionClientDetectFromSessionImageResponse, error) {
	var err error
	req, err := client.detectFromSessionImageCreateRequest(ctx, sessionImageID, options)
	if err != nil {
		return SessionClientDetectFromSessionImageResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SessionClientDetectFromSessionImageResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return SessionClientDetectFromSessionImageResponse{}, err
	}
	resp, err := client.detectFromSessionImageHandleResponse(httpResp)
	return resp, err
}

// detectFromSessionImageCreateRequest creates the DetectFromSessionImage request.
func (client *SessionClient) detectFromSessionImageCreateRequest(ctx context.Context, sessionImageID string, options *SessionClientDetectFromSessionImageOptions) (*policy.Request, error) {
	host := "{endpoint}/face/{apiVersion}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{apiVersion}", string(client.apiVersion))
	urlPath := "/detect"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DetectionModel != nil {
		reqQP.Set("detectionModel", string(*options.DetectionModel))
	}
	if options != nil && options.FaceIDTimeToLive != nil {
		reqQP.Set("faceIdTimeToLive", strconv.FormatInt(int64(*options.FaceIDTimeToLive), 10))
	}
	if options != nil && options.RecognitionModel != nil {
		reqQP.Set("recognitionModel", string(*options.RecognitionModel))
	}
	if options != nil && options.ReturnFaceAttributes != nil {
		reqQP.Set("returnFaceAttributes", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.ReturnFaceAttributes), "[]")), ","))
	}
	if options != nil && options.ReturnFaceID != nil {
		reqQP.Set("returnFaceId", strconv.FormatBool(*options.ReturnFaceID))
	}
	if options != nil && options.ReturnFaceLandmarks != nil {
		reqQP.Set("returnFaceLandmarks", strconv.FormatBool(*options.ReturnFaceLandmarks))
	}
	if options != nil && options.ReturnRecognitionModel != nil {
		reqQP.Set("returnRecognitionModel", strconv.FormatBool(*options.ReturnRecognitionModel))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	body := struct {
		SessionImageId string `json:"sessionImageId"`
	}{
		SessionImageId: sessionImageID,
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// detectFromSessionImageHandleResponse handles the DetectFromSessionImage response.
func (client *SessionClient) detectFromSessionImageHandleResponse(resp *http.Response) (SessionClientDetectFromSessionImageResponse, error) {
	result := SessionClientDetectFromSessionImageResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DetectionResultArray); err != nil {
		return SessionClientDetectFromSessionImageResponse{}, err
	}
	return result, nil
}
