// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armappconfiguration

import (
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// ConfigurationStoresOperations contains the methods for the ConfigurationStores group.
type ConfigurationStoresOperations interface {
	// BeginCreate - Creates a configuration store with the specified parameters.
	BeginCreate(ctx context.Context, resourceGroupName string, configStoreName string, configStoreCreationParameters ConfigurationStore) (*ConfigurationStorePollerResponse, error)
	// ResumeCreate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreate(token string) (ConfigurationStorePoller, error)
	// BeginDelete - Deletes a configuration store.
	BeginDelete(ctx context.Context, resourceGroupName string, configStoreName string) (*HTTPPollerResponse, error)
	// ResumeDelete - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDelete(token string) (HTTPPoller, error)
	// Get - Gets the properties of the specified configuration store.
	Get(ctx context.Context, resourceGroupName string, configStoreName string) (*ConfigurationStoreResponse, error)
	// List - Lists the configuration stores for a given subscription.
	List(configurationStoresListOptions *ConfigurationStoresListOptions) (ConfigurationStoreListResultPager, error)
	// ListByResourceGroup - Lists the configuration stores for a given resource group.
	ListByResourceGroup(resourceGroupName string, configurationStoresListByResourceGroupOptions *ConfigurationStoresListByResourceGroupOptions) (ConfigurationStoreListResultPager, error)
	// ListKeyValue - Lists a configuration store key-value.
	ListKeyValue(ctx context.Context, resourceGroupName string, configStoreName string, listKeyValueParameters ListKeyValueParameters) (*KeyValueResponse, error)
	// ListKeys - Lists the access key for the specified configuration store.
	ListKeys(resourceGroupName string, configStoreName string, configurationStoresListKeysOptions *ConfigurationStoresListKeysOptions) (APIKeyListResultPager, error)
	// RegenerateKey - Regenerates an access key for the specified configuration store.
	RegenerateKey(ctx context.Context, resourceGroupName string, configStoreName string, regenerateKeyParameters RegenerateKeyParameters) (*APIKeyResponse, error)
	// BeginUpdate - Updates a configuration store with the specified parameters.
	BeginUpdate(ctx context.Context, resourceGroupName string, configStoreName string, configStoreUpdateParameters ConfigurationStoreUpdateParameters) (*ConfigurationStorePollerResponse, error)
	// ResumeUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeUpdate(token string) (ConfigurationStorePoller, error)
}

// configurationStoresOperations implements the ConfigurationStoresOperations interface.
type configurationStoresOperations struct {
	*Client
	subscriptionID string
}

// Create - Creates a configuration store with the specified parameters.
func (client *configurationStoresOperations) BeginCreate(ctx context.Context, resourceGroupName string, configStoreName string, configStoreCreationParameters ConfigurationStore) (*ConfigurationStorePollerResponse, error) {
	req, err := client.createCreateRequest(resourceGroupName, configStoreName, configStoreCreationParameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("configurationStoresOperations.Create", "", resp, client.createHandleError)
	if err != nil {
		return nil, err
	}
	poller := &configurationStorePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ConfigurationStoreResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *configurationStoresOperations) ResumeCreate(token string) (ConfigurationStorePoller, error) {
	pt, err := resumePollingTracker("configurationStoresOperations.Create", token, client.createHandleError)
	if err != nil {
		return nil, err
	}
	return &configurationStorePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// createCreateRequest creates the Create request.
func (client *configurationStoresOperations) createCreateRequest(resourceGroupName string, configStoreName string, configStoreCreationParameters ConfigurationStore) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AppConfiguration/configurationStores/{configStoreName}"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{configStoreName}", url.PathEscape(configStoreName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-10-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(configStoreCreationParameters)
}

// createHandleResponse handles the Create response.
func (client *configurationStoresOperations) createHandleResponse(resp *azcore.Response) (*ConfigurationStorePollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusNoContent) {
		return nil, client.createHandleError(resp)
	}
	return &ConfigurationStorePollerResponse{RawResponse: resp.Response}, nil
}

// createHandleError handles the Create error response.
func (client *configurationStoresOperations) createHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Delete - Deletes a configuration store.
func (client *configurationStoresOperations) BeginDelete(ctx context.Context, resourceGroupName string, configStoreName string) (*HTTPPollerResponse, error) {
	req, err := client.deleteCreateRequest(resourceGroupName, configStoreName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("configurationStoresOperations.Delete", "", resp, client.deleteHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *configurationStoresOperations) ResumeDelete(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("configurationStoresOperations.Delete", token, client.deleteHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *configurationStoresOperations) deleteCreateRequest(resourceGroupName string, configStoreName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AppConfiguration/configurationStores/{configStoreName}"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{configStoreName}", url.PathEscape(configStoreName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-10-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *configurationStoresOperations) deleteHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// deleteHandleError handles the Delete error response.
func (client *configurationStoresOperations) deleteHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Get - Gets the properties of the specified configuration store.
func (client *configurationStoresOperations) Get(ctx context.Context, resourceGroupName string, configStoreName string) (*ConfigurationStoreResponse, error) {
	req, err := client.getCreateRequest(resourceGroupName, configStoreName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getCreateRequest creates the Get request.
func (client *configurationStoresOperations) getCreateRequest(resourceGroupName string, configStoreName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AppConfiguration/configurationStores/{configStoreName}"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{configStoreName}", url.PathEscape(configStoreName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-10-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *configurationStoresOperations) getHandleResponse(resp *azcore.Response) (*ConfigurationStoreResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getHandleError(resp)
	}
	result := ConfigurationStoreResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ConfigurationStore)
}

// getHandleError handles the Get error response.
func (client *configurationStoresOperations) getHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// List - Lists the configuration stores for a given subscription.
func (client *configurationStoresOperations) List(configurationStoresListOptions *ConfigurationStoresListOptions) (ConfigurationStoreListResultPager, error) {
	req, err := client.listCreateRequest(configurationStoresListOptions)
	if err != nil {
		return nil, err
	}
	return &configurationStoreListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listHandleResponse,
		advancer: func(resp *ConfigurationStoreListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ConfigurationStoreListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ConfigurationStoreListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listCreateRequest creates the List request.
func (client *configurationStoresOperations) listCreateRequest(configurationStoresListOptions *ConfigurationStoresListOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.AppConfiguration/configurationStores"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-10-01")
	if configurationStoresListOptions != nil && configurationStoresListOptions.SkipToken != nil {
		query.Set("$skipToken", *configurationStoresListOptions.SkipToken)
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listHandleResponse handles the List response.
func (client *configurationStoresOperations) listHandleResponse(resp *azcore.Response) (*ConfigurationStoreListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listHandleError(resp)
	}
	result := ConfigurationStoreListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ConfigurationStoreListResult)
}

// listHandleError handles the List error response.
func (client *configurationStoresOperations) listHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ListByResourceGroup - Lists the configuration stores for a given resource group.
func (client *configurationStoresOperations) ListByResourceGroup(resourceGroupName string, configurationStoresListByResourceGroupOptions *ConfigurationStoresListByResourceGroupOptions) (ConfigurationStoreListResultPager, error) {
	req, err := client.listByResourceGroupCreateRequest(resourceGroupName, configurationStoresListByResourceGroupOptions)
	if err != nil {
		return nil, err
	}
	return &configurationStoreListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listByResourceGroupHandleResponse,
		advancer: func(resp *ConfigurationStoreListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ConfigurationStoreListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ConfigurationStoreListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *configurationStoresOperations) listByResourceGroupCreateRequest(resourceGroupName string, configurationStoresListByResourceGroupOptions *ConfigurationStoresListByResourceGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AppConfiguration/configurationStores"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-10-01")
	if configurationStoresListByResourceGroupOptions != nil && configurationStoresListByResourceGroupOptions.SkipToken != nil {
		query.Set("$skipToken", *configurationStoresListByResourceGroupOptions.SkipToken)
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *configurationStoresOperations) listByResourceGroupHandleResponse(resp *azcore.Response) (*ConfigurationStoreListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listByResourceGroupHandleError(resp)
	}
	result := ConfigurationStoreListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ConfigurationStoreListResult)
}

// listByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *configurationStoresOperations) listByResourceGroupHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ListKeyValue - Lists a configuration store key-value.
func (client *configurationStoresOperations) ListKeyValue(ctx context.Context, resourceGroupName string, configStoreName string, listKeyValueParameters ListKeyValueParameters) (*KeyValueResponse, error) {
	req, err := client.listKeyValueCreateRequest(resourceGroupName, configStoreName, listKeyValueParameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.listKeyValueHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// listKeyValueCreateRequest creates the ListKeyValue request.
func (client *configurationStoresOperations) listKeyValueCreateRequest(resourceGroupName string, configStoreName string, listKeyValueParameters ListKeyValueParameters) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AppConfiguration/configurationStores/{configStoreName}/listKeyValue"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{configStoreName}", url.PathEscape(configStoreName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-10-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(listKeyValueParameters)
}

// listKeyValueHandleResponse handles the ListKeyValue response.
func (client *configurationStoresOperations) listKeyValueHandleResponse(resp *azcore.Response) (*KeyValueResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listKeyValueHandleError(resp)
	}
	result := KeyValueResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.KeyValue)
}

// listKeyValueHandleError handles the ListKeyValue error response.
func (client *configurationStoresOperations) listKeyValueHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ListKeys - Lists the access key for the specified configuration store.
func (client *configurationStoresOperations) ListKeys(resourceGroupName string, configStoreName string, configurationStoresListKeysOptions *ConfigurationStoresListKeysOptions) (APIKeyListResultPager, error) {
	req, err := client.listKeysCreateRequest(resourceGroupName, configStoreName, configurationStoresListKeysOptions)
	if err != nil {
		return nil, err
	}
	return &apiKeyListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listKeysHandleResponse,
		advancer: func(resp *APIKeyListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.APIKeyListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.APIKeyListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listKeysCreateRequest creates the ListKeys request.
func (client *configurationStoresOperations) listKeysCreateRequest(resourceGroupName string, configStoreName string, configurationStoresListKeysOptions *ConfigurationStoresListKeysOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AppConfiguration/configurationStores/{configStoreName}/ListKeys"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{configStoreName}", url.PathEscape(configStoreName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-10-01")
	if configurationStoresListKeysOptions != nil && configurationStoresListKeysOptions.SkipToken != nil {
		query.Set("$skipToken", *configurationStoresListKeysOptions.SkipToken)
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// listKeysHandleResponse handles the ListKeys response.
func (client *configurationStoresOperations) listKeysHandleResponse(resp *azcore.Response) (*APIKeyListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listKeysHandleError(resp)
	}
	result := APIKeyListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.APIKeyListResult)
}

// listKeysHandleError handles the ListKeys error response.
func (client *configurationStoresOperations) listKeysHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// RegenerateKey - Regenerates an access key for the specified configuration store.
func (client *configurationStoresOperations) RegenerateKey(ctx context.Context, resourceGroupName string, configStoreName string, regenerateKeyParameters RegenerateKeyParameters) (*APIKeyResponse, error) {
	req, err := client.regenerateKeyCreateRequest(resourceGroupName, configStoreName, regenerateKeyParameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.regenerateKeyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// regenerateKeyCreateRequest creates the RegenerateKey request.
func (client *configurationStoresOperations) regenerateKeyCreateRequest(resourceGroupName string, configStoreName string, regenerateKeyParameters RegenerateKeyParameters) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AppConfiguration/configurationStores/{configStoreName}/RegenerateKey"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{configStoreName}", url.PathEscape(configStoreName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-10-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(regenerateKeyParameters)
}

// regenerateKeyHandleResponse handles the RegenerateKey response.
func (client *configurationStoresOperations) regenerateKeyHandleResponse(resp *azcore.Response) (*APIKeyResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.regenerateKeyHandleError(resp)
	}
	result := APIKeyResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.APIKey)
}

// regenerateKeyHandleError handles the RegenerateKey error response.
func (client *configurationStoresOperations) regenerateKeyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Update - Updates a configuration store with the specified parameters.
func (client *configurationStoresOperations) BeginUpdate(ctx context.Context, resourceGroupName string, configStoreName string, configStoreUpdateParameters ConfigurationStoreUpdateParameters) (*ConfigurationStorePollerResponse, error) {
	req, err := client.updateCreateRequest(resourceGroupName, configStoreName, configStoreUpdateParameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.updateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("configurationStoresOperations.Update", "", resp, client.updateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &configurationStorePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*ConfigurationStoreResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *configurationStoresOperations) ResumeUpdate(token string) (ConfigurationStorePoller, error) {
	pt, err := resumePollingTracker("configurationStoresOperations.Update", token, client.updateHandleError)
	if err != nil {
		return nil, err
	}
	return &configurationStorePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// updateCreateRequest creates the Update request.
func (client *configurationStoresOperations) updateCreateRequest(resourceGroupName string, configStoreName string, configStoreUpdateParameters ConfigurationStoreUpdateParameters) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AppConfiguration/configurationStores/{configStoreName}"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{configStoreName}", url.PathEscape(configStoreName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-10-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPatch, *u)
	return req, req.MarshalAsJSON(configStoreUpdateParameters)
}

// updateHandleResponse handles the Update response.
func (client *configurationStoresOperations) updateHandleResponse(resp *azcore.Response) (*ConfigurationStorePollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusNoContent) {
		return nil, client.updateHandleError(resp)
	}
	return &ConfigurationStorePollerResponse{RawResponse: resp.Response}, nil
}

// updateHandleError handles the Update error response.
func (client *configurationStoresOperations) updateHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}
