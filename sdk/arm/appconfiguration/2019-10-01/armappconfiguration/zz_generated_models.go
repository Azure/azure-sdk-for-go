// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armappconfiguration

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

// An API key used for authenticating with a configuration store endpoint.
type APIKey struct {
	// A connection string that can be used by supporting clients for authentication.
	ConnectionString *string `json:"connectionString,omitempty" azure:"ro"`

	// The key ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// The last time any of the key's properties were modified.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// A name for the key describing its usage.
	Name *string `json:"name,omitempty" azure:"ro"`

	// Whether this key can only be used for read operations.
	ReadOnly *bool `json:"readOnly,omitempty" azure:"ro"`

	// The value of the key that is used for authentication purposes.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type APIKey.
func (a APIKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.ConnectionString != nil {
		objectMap["connectionString"] = a.ConnectionString
	}
	if a.ID != nil {
		objectMap["id"] = a.ID
	}
	if a.LastModified != nil {
		objectMap["lastModified"] = (*timeRFC3339)(a.LastModified)
	}
	if a.Name != nil {
		objectMap["name"] = a.Name
	}
	if a.ReadOnly != nil {
		objectMap["readOnly"] = a.ReadOnly
	}
	if a.Value != nil {
		objectMap["value"] = a.Value
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type APIKey.
func (a *APIKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &a.ConnectionString)
			}
			delete(rawMsg, key)
		case "id":
			if val != nil {
				err = json.Unmarshal(*val, &a.ID)
			}
			delete(rawMsg, key)
		case "lastModified":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				a.LastModified = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &a.Name)
			}
			delete(rawMsg, key)
		case "readOnly":
			if val != nil {
				err = json.Unmarshal(*val, &a.ReadOnly)
			}
			delete(rawMsg, key)
		case "value":
			if val != nil {
				err = json.Unmarshal(*val, &a.Value)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The result of a request to list API keys.
type APIKeyListResult struct {
	// The URI that can be used to request the next set of paged results.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection value.
	Value *[]APIKey `json:"value,omitempty"`
}

// APIKeyListResultResponse is the response envelope for operations that return a APIKeyListResult type.
type APIKeyListResultResponse struct {
	// The result of a request to list API keys.
	APIKeyListResult *APIKeyListResult

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// APIKeyResponse is the response envelope for operations that return a APIKey type.
type APIKeyResponse struct {
	// An API key used for authenticating with a configuration store endpoint.
	APIKey *APIKey

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Parameters used for checking whether a resource name is available.
type CheckNameAvailabilityParameters struct {
	// The name to check for availability.
	Name *string `json:"name,omitempty"`

	// The resource type to check for name availability.
	Type *ConfigurationResourceType `json:"type,omitempty"`
}

// The configuration store along with all resource properties. The Configuration Store will have all information to begin
// utilizing it.
type ConfigurationStore struct {
	Resource
	// The managed identity information, if configured.
	IDentity *ResourceIDentity `json:"identity,omitempty"`

	// The properties of a configuration store.
	Properties *ConfigurationStoreProperties `json:"properties,omitempty"`

	// The sku of the configuration store.
	SKU *SKU `json:"sku,omitempty"`
}

// The result of a request to list configuration stores.
type ConfigurationStoreListResult struct {
	// The URI that can be used to request the next set of paged results.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection value.
	Value *[]ConfigurationStore `json:"value,omitempty"`
}

// ConfigurationStoreListResultResponse is the response envelope for operations that return a ConfigurationStoreListResult
// type.
type ConfigurationStoreListResultResponse struct {
	// The result of a request to list configuration stores.
	ConfigurationStoreListResult *ConfigurationStoreListResult

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationStorePollerResponse is the response envelope for operations that asynchronously return a ConfigurationStore
// type.
type ConfigurationStorePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*ConfigurationStoreResponse, error)

	// Poller contains an initialized poller.
	Poller ConfigurationStorePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The properties of a configuration store.
type ConfigurationStoreProperties struct {
	// The creation date of configuration store.
	CreationDate *time.Time `json:"creationDate,omitempty" azure:"ro"`

	// The DNS endpoint where the configuration store API will be available.
	Endpoint *string `json:"endpoint,omitempty" azure:"ro"`

	// The provisioning state of the configuration store.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConfigurationStoreProperties.
func (c ConfigurationStoreProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if c.CreationDate != nil {
		objectMap["creationDate"] = (*timeRFC3339)(c.CreationDate)
	}
	if c.Endpoint != nil {
		objectMap["endpoint"] = c.Endpoint
	}
	if c.ProvisioningState != nil {
		objectMap["provisioningState"] = c.ProvisioningState
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConfigurationStoreProperties.
func (c *ConfigurationStoreProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationDate":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				c.CreationDate = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &c.Endpoint)
			}
			delete(rawMsg, key)
		case "provisioningState":
			if val != nil {
				err = json.Unmarshal(*val, &c.ProvisioningState)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConfigurationStoreResponse is the response envelope for operations that return a ConfigurationStore type.
type ConfigurationStoreResponse struct {
	// The configuration store along with all resource properties. The Configuration Store will have all information to begin
	// utilizing it.
	ConfigurationStore *ConfigurationStore

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The parameters for updating a configuration store.
type ConfigurationStoreUpdateParameters struct {
	// The managed identity information for the configuration store.
	IDentity *ResourceIDentity `json:"identity,omitempty"`

	// The properties for updating a configuration store.
	Properties *interface{} `json:"properties,omitempty"`

	// The SKU of the configuration store.
	SKU *SKU `json:"sku,omitempty"`

	// The ARM resource tags.
	Tags *map[string]string `json:"tags,omitempty"`
}

// ConfigurationStoresCreateOptions contains the optional parameters for the ConfigurationStores.Create method.
type ConfigurationStoresCreateOptions struct {
	// placeholder for future optional parameters
}

// ConfigurationStoresDeleteOptions contains the optional parameters for the ConfigurationStores.Delete method.
type ConfigurationStoresDeleteOptions struct {
	// placeholder for future optional parameters
}

// ConfigurationStoresGetOptions contains the optional parameters for the ConfigurationStores.Get method.
type ConfigurationStoresGetOptions struct {
	// placeholder for future optional parameters
}

// ConfigurationStoresListByResourceGroupOptions contains the optional parameters for the ConfigurationStores.ListByResourceGroup
// method.
type ConfigurationStoresListByResourceGroupOptions struct {
	// A skip token is used to continue retrieving items after an operation returns a partial result. If a previous response contains
	// a nextLink element, the value of the nextLink element will include a skipToken parameter that specifies a starting point
	// to use for subsequent calls.
	SkipToken *string
}

// ConfigurationStoresListKeyValueOptions contains the optional parameters for the ConfigurationStores.ListKeyValue method.
type ConfigurationStoresListKeyValueOptions struct {
	// placeholder for future optional parameters
}

// ConfigurationStoresListKeysOptions contains the optional parameters for the ConfigurationStores.ListKeys method.
type ConfigurationStoresListKeysOptions struct {
	// A skip token is used to continue retrieving items after an operation returns a partial result. If a previous response contains
	// a nextLink element, the value of the nextLink element will include a skipToken parameter that specifies a starting point
	// to use for subsequent calls.
	SkipToken *string
}

// ConfigurationStoresListOptions contains the optional parameters for the ConfigurationStores.List method.
type ConfigurationStoresListOptions struct {
	// A skip token is used to continue retrieving items after an operation returns a partial result. If a previous response contains
	// a nextLink element, the value of the nextLink element will include a skipToken parameter that specifies a starting point
	// to use for subsequent calls.
	SkipToken *string
}

// ConfigurationStoresRegenerateKeyOptions contains the optional parameters for the ConfigurationStores.RegenerateKey method.
type ConfigurationStoresRegenerateKeyOptions struct {
	// placeholder for future optional parameters
}

// ConfigurationStoresUpdateOptions contains the optional parameters for the ConfigurationStores.Update method.
type ConfigurationStoresUpdateOptions struct {
	// placeholder for future optional parameters
}

// AppConfiguration error object.
type Error struct {
	// Error code.
	Code *string `json:"code,omitempty"`

	// Error message.
	Message *string `json:"message,omitempty"`
}

// Error implements the error interface for type Error.
func (e Error) Error() string {
	msg := ""
	if e.Code != nil {
		msg += fmt.Sprintf("Code: %v\n", *e.Code)
	}
	if e.Message != nil {
		msg += fmt.Sprintf("Message: %v\n", *e.Message)
	}
	if msg == "" {
		msg = "missing error info"
	}
	return msg
}

// HTTPPollerResponse contains the asynchronous HTTP response from the call to the service endpoint.
type HTTPPollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*http.Response, error)

	// Poller contains an initialized poller.
	Poller HTTPPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The result of a request to retrieve a key-value from the specified configuration store.
type KeyValue struct {
	// The content type of the key-value's value.
	// Providing a proper content-type can enable transformations of values when they are retrieved by applications.
	ContentType *string `json:"contentType,omitempty" azure:"ro"`

	// An ETag indicating the state of a key-value within a configuration store.
	ETag *string `json:"eTag,omitempty" azure:"ro"`

	// The primary identifier of a key-value.
	// The key is used in unison with the label to uniquely identify a key-value.
	Key *string `json:"key,omitempty" azure:"ro"`

	// A value used to group key-values.
	// The label is used in unison with the key to uniquely identify a key-value.
	Label *string `json:"label,omitempty" azure:"ro"`

	// The last time a modifying operation was performed on the given key-value.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// A value indicating whether the key-value is locked.
	// A locked key-value may not be modified until it is unlocked.
	Locked *bool `json:"locked,omitempty" azure:"ro"`

	// A dictionary of tags that can help identify what a key-value may be applicable for.
	Tags *map[string]string `json:"tags,omitempty" azure:"ro"`

	// The value of the key-value.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyValue.
func (k KeyValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if k.ContentType != nil {
		objectMap["contentType"] = k.ContentType
	}
	if k.ETag != nil {
		objectMap["eTag"] = k.ETag
	}
	if k.Key != nil {
		objectMap["key"] = k.Key
	}
	if k.Label != nil {
		objectMap["label"] = k.Label
	}
	if k.LastModified != nil {
		objectMap["lastModified"] = (*timeRFC3339)(k.LastModified)
	}
	if k.Locked != nil {
		objectMap["locked"] = k.Locked
	}
	if k.Tags != nil {
		objectMap["tags"] = k.Tags
	}
	if k.Value != nil {
		objectMap["value"] = k.Value
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyValue.
func (k *KeyValue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentType":
			if val != nil {
				err = json.Unmarshal(*val, &k.ContentType)
			}
			delete(rawMsg, key)
		case "eTag":
			if val != nil {
				err = json.Unmarshal(*val, &k.ETag)
			}
			delete(rawMsg, key)
		case "key":
			if val != nil {
				err = json.Unmarshal(*val, &k.Key)
			}
			delete(rawMsg, key)
		case "label":
			if val != nil {
				err = json.Unmarshal(*val, &k.Label)
			}
			delete(rawMsg, key)
		case "lastModified":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				k.LastModified = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "locked":
			if val != nil {
				err = json.Unmarshal(*val, &k.Locked)
			}
			delete(rawMsg, key)
		case "tags":
			if val != nil {
				err = json.Unmarshal(*val, &k.Tags)
			}
			delete(rawMsg, key)
		case "value":
			if val != nil {
				err = json.Unmarshal(*val, &k.Value)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// KeyValueResponse is the response envelope for operations that return a KeyValue type.
type KeyValueResponse struct {
	// The result of a request to retrieve a key-value from the specified configuration store.
	KeyValue *KeyValue

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The parameters used to list a configuration store key-value
type ListKeyValueParameters struct {
	// The key to retrieve.
	Key *string `json:"key,omitempty"`

	// The label of the key.
	Label *string `json:"label,omitempty"`
}

// The result of a request to check the availability of a resource name.
type NameAvailabilityStatus struct {
	// If any, the error message that provides more detail for the reason that the name is not available.
	Message *string `json:"message,omitempty" azure:"ro"`

	// The value indicating whether the resource name is available.
	NameAvailable *bool `json:"nameAvailable,omitempty" azure:"ro"`

	// If any, the reason that the name is not available.
	Reason *string `json:"reason,omitempty" azure:"ro"`
}

// NameAvailabilityStatusResponse is the response envelope for operations that return a NameAvailabilityStatus type.
type NameAvailabilityStatusResponse struct {
	// The result of a request to check the availability of a resource name.
	NameAvailabilityStatus *NameAvailabilityStatus

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The definition of a configuration store operation.
type OperationDefinition struct {
	// The display information for the configuration store operation.
	Display *OperationDefinitionDisplay `json:"display,omitempty"`

	// Operation name: {provider}/{resource}/{operation}.
	Name *string `json:"name,omitempty"`
}

// The display information for a configuration store operation.
type OperationDefinitionDisplay struct {
	// The description for the operation.
	Description *string `json:"description,omitempty"`

	// The operation that users can perform.
	Operation *string `json:"operation,omitempty"`

	// The resource provider name: Microsoft App Configuration."
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// The resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
}

// The result of a request to list configuration store operations.
type OperationDefinitionListResult struct {
	// The URI that can be used to request the next set of paged results.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection value.
	Value *[]OperationDefinition `json:"value,omitempty"`
}

// OperationDefinitionListResultResponse is the response envelope for operations that return a OperationDefinitionListResult
// type.
type OperationDefinitionListResultResponse struct {
	// The result of a request to list configuration store operations.
	OperationDefinitionListResult *OperationDefinitionListResult

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsCheckNameAvailabilityOptions contains the optional parameters for the Operations.CheckNameAvailability method.
type OperationsCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// A skip token is used to continue retrieving items after an operation returns a partial result. If a previous response contains
	// a nextLink element, the value of the nextLink element will include a skipToken parameter that specifies a starting point
	// to use for subsequent calls.
	SkipToken *string
}

// The parameters used to regenerate an API key.
type RegenerateKeyParameters struct {
	// The id of the key to regenerate.
	ID *string `json:"id,omitempty"`
}

// An Azure resource.
type Resource struct {
	// The resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// The location of the resource. This cannot be changed after the resource is created.
	Location *string `json:"location,omitempty"`

	// The name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// The tags of the resource.
	Tags *map[string]string `json:"tags,omitempty"`

	// The type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

type ResourceIDentity struct {
	// The principal id of the identity. This property will only be provided for a system-assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// The tenant id associated with the resource's identity. This property will only be provided for a system-assigned identity.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`

	// The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity
	// and a set of user-assigned identities. The type 'None' will remove any identities.
	Type *IDentityType `json:"type,omitempty"`

	// The list of user-assigned identities associated with the resource. The user-assigned identity dictionary keys will be ARM
	// resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIDentities *map[string]UserIDentity `json:"userAssignedIdentities,omitempty"`
}

// Describes a configuration store SKU.
type SKU struct {
	// The SKU name of the configuration store.
	Name *string `json:"name,omitempty"`
}

type UserIDentity struct {
	// The client ID of the user-assigned identity.
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// The principal ID of the user-assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`
}
