// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// DedicatedHostsOperations contains the methods for the DedicatedHosts group.
type DedicatedHostsOperations interface {
	// BeginCreateOrUpdate - Create or update a dedicated host .
	BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, hostGroupName string, hostName string, parameters DedicatedHost) (*DedicatedHostResponse, error)
	// ResumeCreateOrUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdate(token string) (DedicatedHostPoller, error)
	// BeginDelete - Delete a dedicated host.
	BeginDelete(ctx context.Context, resourceGroupName string, hostGroupName string, hostName string) (*HTTPResponse, error)
	// ResumeDelete - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDelete(token string) (HTTPPoller, error)
	// Get - Retrieves information about a dedicated host.
	Get(ctx context.Context, resourceGroupName string, hostGroupName string, hostName string) (*DedicatedHostResponse, error)
	// ListByHostGroup - Lists all of the dedicated hosts in the specified dedicated host group. Use the nextLink property in the response to get the next page of dedicated hosts.
	ListByHostGroup(resourceGroupName string, hostGroupName string) (DedicatedHostListResultPager, error)
	// BeginUpdate - Update an dedicated host .
	BeginUpdate(ctx context.Context, resourceGroupName string, hostGroupName string, hostName string, parameters DedicatedHostUpdate) (*DedicatedHostResponse, error)
	// ResumeUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeUpdate(token string) (DedicatedHostPoller, error)
}

// dedicatedHostsOperations implements the DedicatedHostsOperations interface.
type dedicatedHostsOperations struct {
	*Client
	subscriptionID string
}

// CreateOrUpdate - Create or update a dedicated host .
func (client *dedicatedHostsOperations) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, hostGroupName string, hostName string, parameters DedicatedHost) (*DedicatedHostResponse, error) {
	req, err := client.createOrUpdateCreateRequest(resourceGroupName, hostGroupName, hostName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createOrUpdateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("dedicatedHostsOperations.CreateOrUpdate", "", resp, client.createOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &dedicatedHostPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DedicatedHostResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *dedicatedHostsOperations) ResumeCreateOrUpdate(token string) (DedicatedHostPoller, error) {
	pt, err := resumePollingTracker("dedicatedHostsOperations.CreateOrUpdate", token, client.createOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	return &dedicatedHostPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *dedicatedHostsOperations) createOrUpdateCreateRequest(resourceGroupName string, hostGroupName string, hostName string, parameters DedicatedHost) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{hostGroupName}", url.PathEscape(hostGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateHandleResponse handles the CreateOrUpdate response.
func (client *dedicatedHostsOperations) createOrUpdateHandleResponse(resp *azcore.Response) (*DedicatedHostResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusNoContent) {
		return nil, client.createOrUpdateHandleError(resp)
	}
	result := DedicatedHostResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DedicatedHost)
}

// createOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *dedicatedHostsOperations) createOrUpdateHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Delete - Delete a dedicated host.
func (client *dedicatedHostsOperations) BeginDelete(ctx context.Context, resourceGroupName string, hostGroupName string, hostName string) (*HTTPResponse, error) {
	req, err := client.deleteCreateRequest(resourceGroupName, hostGroupName, hostName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("dedicatedHostsOperations.Delete", "", resp, client.deleteHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *dedicatedHostsOperations) ResumeDelete(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("dedicatedHostsOperations.Delete", token, client.deleteHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *dedicatedHostsOperations) deleteCreateRequest(resourceGroupName string, hostGroupName string, hostName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{hostGroupName}", url.PathEscape(hostGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *dedicatedHostsOperations) deleteHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	result := HTTPResponse{RawResponse: resp.Response}
	return &result, nil
}

// deleteHandleError handles the Delete error response.
func (client *dedicatedHostsOperations) deleteHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Get - Retrieves information about a dedicated host.
func (client *dedicatedHostsOperations) Get(ctx context.Context, resourceGroupName string, hostGroupName string, hostName string) (*DedicatedHostResponse, error) {
	req, err := client.getCreateRequest(resourceGroupName, hostGroupName, hostName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getCreateRequest creates the Get request.
func (client *dedicatedHostsOperations) getCreateRequest(resourceGroupName string, hostGroupName string, hostName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{hostGroupName}", url.PathEscape(hostGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *dedicatedHostsOperations) getHandleResponse(resp *azcore.Response) (*DedicatedHostResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getHandleError(resp)
	}
	result := DedicatedHostResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DedicatedHost)
}

// getHandleError handles the Get error response.
func (client *dedicatedHostsOperations) getHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// ListByHostGroup - Lists all of the dedicated hosts in the specified dedicated host group. Use the nextLink property in the response to get the next page of dedicated hosts.
func (client *dedicatedHostsOperations) ListByHostGroup(resourceGroupName string, hostGroupName string) (DedicatedHostListResultPager, error) {
	req, err := client.listByHostGroupCreateRequest(resourceGroupName, hostGroupName)
	if err != nil {
		return nil, err
	}
	return &dedicatedHostListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listByHostGroupHandleResponse,
		advancer: func(resp *DedicatedHostListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.DedicatedHostListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.DedicatedHostListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listByHostGroupCreateRequest creates the ListByHostGroup request.
func (client *dedicatedHostsOperations) listByHostGroupCreateRequest(resourceGroupName string, hostGroupName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{hostGroupName}", url.PathEscape(hostGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listByHostGroupHandleResponse handles the ListByHostGroup response.
func (client *dedicatedHostsOperations) listByHostGroupHandleResponse(resp *azcore.Response) (*DedicatedHostListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listByHostGroupHandleError(resp)
	}
	result := DedicatedHostListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DedicatedHostListResult)
}

// listByHostGroupHandleError handles the ListByHostGroup error response.
func (client *dedicatedHostsOperations) listByHostGroupHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Update - Update an dedicated host .
func (client *dedicatedHostsOperations) BeginUpdate(ctx context.Context, resourceGroupName string, hostGroupName string, hostName string, parameters DedicatedHostUpdate) (*DedicatedHostResponse, error) {
	req, err := client.updateCreateRequest(resourceGroupName, hostGroupName, hostName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.updateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("dedicatedHostsOperations.Update", "", resp, client.updateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &dedicatedHostPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DedicatedHostResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *dedicatedHostsOperations) ResumeUpdate(token string) (DedicatedHostPoller, error) {
	pt, err := resumePollingTracker("dedicatedHostsOperations.Update", token, client.updateHandleError)
	if err != nil {
		return nil, err
	}
	return &dedicatedHostPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// updateCreateRequest creates the Update request.
func (client *dedicatedHostsOperations) updateCreateRequest(resourceGroupName string, hostGroupName string, hostName string, parameters DedicatedHostUpdate) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{hostGroupName}", url.PathEscape(hostGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPatch, *u)
	return req, req.MarshalAsJSON(parameters)
}

// updateHandleResponse handles the Update response.
func (client *dedicatedHostsOperations) updateHandleResponse(resp *azcore.Response) (*DedicatedHostResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.updateHandleError(resp)
	}
	result := DedicatedHostResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DedicatedHost)
}

// updateHandleError handles the Update error response.
func (client *dedicatedHostsOperations) updateHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}
