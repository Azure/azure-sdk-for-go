// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// AvailabilitySetListResultPager provides iteration over AvailabilitySetListResult pages.
type AvailabilitySetListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AvailabilitySetListResultResponse.
	PageResponse() *AvailabilitySetListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type availabilitySetListResultHandleResponse func(*azcore.Response) (*AvailabilitySetListResultResponse, error)

type availabilitySetListResultAdvancePage func(*AvailabilitySetListResultResponse) (*azcore.Request, error)

type availabilitySetListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder availabilitySetListResultHandleResponse
	// callback for advancing to the next page
	advancer availabilitySetListResultAdvancePage
	// contains the current response
	current *AvailabilitySetListResultResponse
	// any error encountered
	err error
}

func (p *availabilitySetListResultPager) Err() error {
	return p.err
}

func (p *availabilitySetListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.AvailabilitySetListResult.NextLink == nil || len(*p.current.AvailabilitySetListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *availabilitySetListResultPager) PageResponse() *AvailabilitySetListResultResponse {
	return p.current
}

// ContainerServiceListResultPager provides iteration over ContainerServiceListResult pages.
type ContainerServiceListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ContainerServiceListResultResponse.
	PageResponse() *ContainerServiceListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type containerServiceListResultHandleResponse func(*azcore.Response) (*ContainerServiceListResultResponse, error)

type containerServiceListResultAdvancePage func(*ContainerServiceListResultResponse) (*azcore.Request, error)

type containerServiceListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder containerServiceListResultHandleResponse
	// callback for advancing to the next page
	advancer containerServiceListResultAdvancePage
	// contains the current response
	current *ContainerServiceListResultResponse
	// any error encountered
	err error
}

func (p *containerServiceListResultPager) Err() error {
	return p.err
}

func (p *containerServiceListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ContainerServiceListResult.NextLink == nil || len(*p.current.ContainerServiceListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *containerServiceListResultPager) PageResponse() *ContainerServiceListResultResponse {
	return p.current
}

// DedicatedHostGroupListResultPager provides iteration over DedicatedHostGroupListResult pages.
type DedicatedHostGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current DedicatedHostGroupListResultResponse.
	PageResponse() *DedicatedHostGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type dedicatedHostGroupListResultHandleResponse func(*azcore.Response) (*DedicatedHostGroupListResultResponse, error)

type dedicatedHostGroupListResultAdvancePage func(*DedicatedHostGroupListResultResponse) (*azcore.Request, error)

type dedicatedHostGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder dedicatedHostGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer dedicatedHostGroupListResultAdvancePage
	// contains the current response
	current *DedicatedHostGroupListResultResponse
	// any error encountered
	err error
}

func (p *dedicatedHostGroupListResultPager) Err() error {
	return p.err
}

func (p *dedicatedHostGroupListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.DedicatedHostGroupListResult.NextLink == nil || len(*p.current.DedicatedHostGroupListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *dedicatedHostGroupListResultPager) PageResponse() *DedicatedHostGroupListResultResponse {
	return p.current
}

// DedicatedHostListResultPager provides iteration over DedicatedHostListResult pages.
type DedicatedHostListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current DedicatedHostListResultResponse.
	PageResponse() *DedicatedHostListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type dedicatedHostListResultHandleResponse func(*azcore.Response) (*DedicatedHostListResultResponse, error)

type dedicatedHostListResultAdvancePage func(*DedicatedHostListResultResponse) (*azcore.Request, error)

type dedicatedHostListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder dedicatedHostListResultHandleResponse
	// callback for advancing to the next page
	advancer dedicatedHostListResultAdvancePage
	// contains the current response
	current *DedicatedHostListResultResponse
	// any error encountered
	err error
}

func (p *dedicatedHostListResultPager) Err() error {
	return p.err
}

func (p *dedicatedHostListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.DedicatedHostListResult.NextLink == nil || len(*p.current.DedicatedHostListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *dedicatedHostListResultPager) PageResponse() *DedicatedHostListResultResponse {
	return p.current
}

// DiskEncryptionSetListPager provides iteration over DiskEncryptionSetList pages.
type DiskEncryptionSetListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current DiskEncryptionSetListResponse.
	PageResponse() *DiskEncryptionSetListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type diskEncryptionSetListHandleResponse func(*azcore.Response) (*DiskEncryptionSetListResponse, error)

type diskEncryptionSetListAdvancePage func(*DiskEncryptionSetListResponse) (*azcore.Request, error)

type diskEncryptionSetListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder diskEncryptionSetListHandleResponse
	// callback for advancing to the next page
	advancer diskEncryptionSetListAdvancePage
	// contains the current response
	current *DiskEncryptionSetListResponse
	// any error encountered
	err error
}

func (p *diskEncryptionSetListPager) Err() error {
	return p.err
}

func (p *diskEncryptionSetListPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.DiskEncryptionSetList.NextLink == nil || len(*p.current.DiskEncryptionSetList.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *diskEncryptionSetListPager) PageResponse() *DiskEncryptionSetListResponse {
	return p.current
}

// DiskListPager provides iteration over DiskList pages.
type DiskListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current DiskListResponse.
	PageResponse() *DiskListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type diskListHandleResponse func(*azcore.Response) (*DiskListResponse, error)

type diskListAdvancePage func(*DiskListResponse) (*azcore.Request, error)

type diskListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder diskListHandleResponse
	// callback for advancing to the next page
	advancer diskListAdvancePage
	// contains the current response
	current *DiskListResponse
	// any error encountered
	err error
}

func (p *diskListPager) Err() error {
	return p.err
}

func (p *diskListPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.DiskList.NextLink == nil || len(*p.current.DiskList.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *diskListPager) PageResponse() *DiskListResponse {
	return p.current
}

// GalleryApplicationListPager provides iteration over GalleryApplicationList pages.
type GalleryApplicationListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current GalleryApplicationListResponse.
	PageResponse() *GalleryApplicationListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type galleryApplicationListHandleResponse func(*azcore.Response) (*GalleryApplicationListResponse, error)

type galleryApplicationListAdvancePage func(*GalleryApplicationListResponse) (*azcore.Request, error)

type galleryApplicationListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder galleryApplicationListHandleResponse
	// callback for advancing to the next page
	advancer galleryApplicationListAdvancePage
	// contains the current response
	current *GalleryApplicationListResponse
	// any error encountered
	err error
}

func (p *galleryApplicationListPager) Err() error {
	return p.err
}

func (p *galleryApplicationListPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.GalleryApplicationList.NextLink == nil || len(*p.current.GalleryApplicationList.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *galleryApplicationListPager) PageResponse() *GalleryApplicationListResponse {
	return p.current
}

// GalleryApplicationVersionListPager provides iteration over GalleryApplicationVersionList pages.
type GalleryApplicationVersionListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current GalleryApplicationVersionListResponse.
	PageResponse() *GalleryApplicationVersionListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type galleryApplicationVersionListHandleResponse func(*azcore.Response) (*GalleryApplicationVersionListResponse, error)

type galleryApplicationVersionListAdvancePage func(*GalleryApplicationVersionListResponse) (*azcore.Request, error)

type galleryApplicationVersionListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder galleryApplicationVersionListHandleResponse
	// callback for advancing to the next page
	advancer galleryApplicationVersionListAdvancePage
	// contains the current response
	current *GalleryApplicationVersionListResponse
	// any error encountered
	err error
}

func (p *galleryApplicationVersionListPager) Err() error {
	return p.err
}

func (p *galleryApplicationVersionListPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.GalleryApplicationVersionList.NextLink == nil || len(*p.current.GalleryApplicationVersionList.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *galleryApplicationVersionListPager) PageResponse() *GalleryApplicationVersionListResponse {
	return p.current
}

// GalleryImageListPager provides iteration over GalleryImageList pages.
type GalleryImageListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current GalleryImageListResponse.
	PageResponse() *GalleryImageListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type galleryImageListHandleResponse func(*azcore.Response) (*GalleryImageListResponse, error)

type galleryImageListAdvancePage func(*GalleryImageListResponse) (*azcore.Request, error)

type galleryImageListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder galleryImageListHandleResponse
	// callback for advancing to the next page
	advancer galleryImageListAdvancePage
	// contains the current response
	current *GalleryImageListResponse
	// any error encountered
	err error
}

func (p *galleryImageListPager) Err() error {
	return p.err
}

func (p *galleryImageListPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.GalleryImageList.NextLink == nil || len(*p.current.GalleryImageList.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *galleryImageListPager) PageResponse() *GalleryImageListResponse {
	return p.current
}

// GalleryImageVersionListPager provides iteration over GalleryImageVersionList pages.
type GalleryImageVersionListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current GalleryImageVersionListResponse.
	PageResponse() *GalleryImageVersionListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type galleryImageVersionListHandleResponse func(*azcore.Response) (*GalleryImageVersionListResponse, error)

type galleryImageVersionListAdvancePage func(*GalleryImageVersionListResponse) (*azcore.Request, error)

type galleryImageVersionListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder galleryImageVersionListHandleResponse
	// callback for advancing to the next page
	advancer galleryImageVersionListAdvancePage
	// contains the current response
	current *GalleryImageVersionListResponse
	// any error encountered
	err error
}

func (p *galleryImageVersionListPager) Err() error {
	return p.err
}

func (p *galleryImageVersionListPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.GalleryImageVersionList.NextLink == nil || len(*p.current.GalleryImageVersionList.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *galleryImageVersionListPager) PageResponse() *GalleryImageVersionListResponse {
	return p.current
}

// GalleryListPager provides iteration over GalleryList pages.
type GalleryListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current GalleryListResponse.
	PageResponse() *GalleryListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type galleryListHandleResponse func(*azcore.Response) (*GalleryListResponse, error)

type galleryListAdvancePage func(*GalleryListResponse) (*azcore.Request, error)

type galleryListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder galleryListHandleResponse
	// callback for advancing to the next page
	advancer galleryListAdvancePage
	// contains the current response
	current *GalleryListResponse
	// any error encountered
	err error
}

func (p *galleryListPager) Err() error {
	return p.err
}

func (p *galleryListPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.GalleryList.NextLink == nil || len(*p.current.GalleryList.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *galleryListPager) PageResponse() *GalleryListResponse {
	return p.current
}

// ImageListResultPager provides iteration over ImageListResult pages.
type ImageListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ImageListResultResponse.
	PageResponse() *ImageListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type imageListResultHandleResponse func(*azcore.Response) (*ImageListResultResponse, error)

type imageListResultAdvancePage func(*ImageListResultResponse) (*azcore.Request, error)

type imageListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder imageListResultHandleResponse
	// callback for advancing to the next page
	advancer imageListResultAdvancePage
	// contains the current response
	current *ImageListResultResponse
	// any error encountered
	err error
}

func (p *imageListResultPager) Err() error {
	return p.err
}

func (p *imageListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ImageListResult.NextLink == nil || len(*p.current.ImageListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *imageListResultPager) PageResponse() *ImageListResultResponse {
	return p.current
}

// ListUsagesResultPager provides iteration over ListUsagesResult pages.
type ListUsagesResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListUsagesResultResponse.
	PageResponse() *ListUsagesResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listUsagesResultHandleResponse func(*azcore.Response) (*ListUsagesResultResponse, error)

type listUsagesResultAdvancePage func(*ListUsagesResultResponse) (*azcore.Request, error)

type listUsagesResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder listUsagesResultHandleResponse
	// callback for advancing to the next page
	advancer listUsagesResultAdvancePage
	// contains the current response
	current *ListUsagesResultResponse
	// any error encountered
	err error
}

func (p *listUsagesResultPager) Err() error {
	return p.err
}

func (p *listUsagesResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ListUsagesResult.NextLink == nil || len(*p.current.ListUsagesResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listUsagesResultPager) PageResponse() *ListUsagesResultResponse {
	return p.current
}

// ProximityPlacementGroupListResultPager provides iteration over ProximityPlacementGroupListResult pages.
type ProximityPlacementGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ProximityPlacementGroupListResultResponse.
	PageResponse() *ProximityPlacementGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type proximityPlacementGroupListResultHandleResponse func(*azcore.Response) (*ProximityPlacementGroupListResultResponse, error)

type proximityPlacementGroupListResultAdvancePage func(*ProximityPlacementGroupListResultResponse) (*azcore.Request, error)

type proximityPlacementGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder proximityPlacementGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer proximityPlacementGroupListResultAdvancePage
	// contains the current response
	current *ProximityPlacementGroupListResultResponse
	// any error encountered
	err error
}

func (p *proximityPlacementGroupListResultPager) Err() error {
	return p.err
}

func (p *proximityPlacementGroupListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ProximityPlacementGroupListResult.NextLink == nil || len(*p.current.ProximityPlacementGroupListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *proximityPlacementGroupListResultPager) PageResponse() *ProximityPlacementGroupListResultResponse {
	return p.current
}

// ResourceSkusResultPager provides iteration over ResourceSkusResult pages.
type ResourceSkusResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ResourceSkusResultResponse.
	PageResponse() *ResourceSkusResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type resourceSkusResultHandleResponse func(*azcore.Response) (*ResourceSkusResultResponse, error)

type resourceSkusResultAdvancePage func(*ResourceSkusResultResponse) (*azcore.Request, error)

type resourceSkusResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder resourceSkusResultHandleResponse
	// callback for advancing to the next page
	advancer resourceSkusResultAdvancePage
	// contains the current response
	current *ResourceSkusResultResponse
	// any error encountered
	err error
}

func (p *resourceSkusResultPager) Err() error {
	return p.err
}

func (p *resourceSkusResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ResourceSkusResult.NextLink == nil || len(*p.current.ResourceSkusResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *resourceSkusResultPager) PageResponse() *ResourceSkusResultResponse {
	return p.current
}

// RunCommandListResultPager provides iteration over RunCommandListResult pages.
type RunCommandListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current RunCommandListResultResponse.
	PageResponse() *RunCommandListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type runCommandListResultHandleResponse func(*azcore.Response) (*RunCommandListResultResponse, error)

type runCommandListResultAdvancePage func(*RunCommandListResultResponse) (*azcore.Request, error)

type runCommandListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder runCommandListResultHandleResponse
	// callback for advancing to the next page
	advancer runCommandListResultAdvancePage
	// contains the current response
	current *RunCommandListResultResponse
	// any error encountered
	err error
}

func (p *runCommandListResultPager) Err() error {
	return p.err
}

func (p *runCommandListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.RunCommandListResult.NextLink == nil || len(*p.current.RunCommandListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *runCommandListResultPager) PageResponse() *RunCommandListResultResponse {
	return p.current
}

// SSHPublicKeysGroupListResultPager provides iteration over SSHPublicKeysGroupListResult pages.
type SSHPublicKeysGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current SSHPublicKeysGroupListResultResponse.
	PageResponse() *SSHPublicKeysGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type sshPublicKeysGroupListResultHandleResponse func(*azcore.Response) (*SSHPublicKeysGroupListResultResponse, error)

type sshPublicKeysGroupListResultAdvancePage func(*SSHPublicKeysGroupListResultResponse) (*azcore.Request, error)

type sshPublicKeysGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder sshPublicKeysGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer sshPublicKeysGroupListResultAdvancePage
	// contains the current response
	current *SSHPublicKeysGroupListResultResponse
	// any error encountered
	err error
}

func (p *sshPublicKeysGroupListResultPager) Err() error {
	return p.err
}

func (p *sshPublicKeysGroupListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.SSHPublicKeysGroupListResult.NextLink == nil || len(*p.current.SSHPublicKeysGroupListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *sshPublicKeysGroupListResultPager) PageResponse() *SSHPublicKeysGroupListResultResponse {
	return p.current
}

// SnapshotListPager provides iteration over SnapshotList pages.
type SnapshotListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current SnapshotListResponse.
	PageResponse() *SnapshotListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type snapshotListHandleResponse func(*azcore.Response) (*SnapshotListResponse, error)

type snapshotListAdvancePage func(*SnapshotListResponse) (*azcore.Request, error)

type snapshotListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder snapshotListHandleResponse
	// callback for advancing to the next page
	advancer snapshotListAdvancePage
	// contains the current response
	current *SnapshotListResponse
	// any error encountered
	err error
}

func (p *snapshotListPager) Err() error {
	return p.err
}

func (p *snapshotListPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.SnapshotList.NextLink == nil || len(*p.current.SnapshotList.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *snapshotListPager) PageResponse() *SnapshotListResponse {
	return p.current
}

// VirtualMachineListResultPager provides iteration over VirtualMachineListResult pages.
type VirtualMachineListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineListResultResponse.
	PageResponse() *VirtualMachineListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineListResultHandleResponse func(*azcore.Response) (*VirtualMachineListResultResponse, error)

type virtualMachineListResultAdvancePage func(*VirtualMachineListResultResponse) (*azcore.Request, error)

type virtualMachineListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualMachineListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineListResultAdvancePage
	// contains the current response
	current *VirtualMachineListResultResponse
	// any error encountered
	err error
}

func (p *virtualMachineListResultPager) Err() error {
	return p.err
}

func (p *virtualMachineListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineListResultPager) PageResponse() *VirtualMachineListResultResponse {
	return p.current
}

// VirtualMachineScaleSetExtensionListResultPager provides iteration over VirtualMachineScaleSetExtensionListResult pages.
type VirtualMachineScaleSetExtensionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineScaleSetExtensionListResultResponse.
	PageResponse() *VirtualMachineScaleSetExtensionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineScaleSetExtensionListResultHandleResponse func(*azcore.Response) (*VirtualMachineScaleSetExtensionListResultResponse, error)

type virtualMachineScaleSetExtensionListResultAdvancePage func(*VirtualMachineScaleSetExtensionListResultResponse) (*azcore.Request, error)

type virtualMachineScaleSetExtensionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualMachineScaleSetExtensionListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineScaleSetExtensionListResultAdvancePage
	// contains the current response
	current *VirtualMachineScaleSetExtensionListResultResponse
	// any error encountered
	err error
}

func (p *virtualMachineScaleSetExtensionListResultPager) Err() error {
	return p.err
}

func (p *virtualMachineScaleSetExtensionListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualMachineScaleSetExtensionListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetExtensionListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineScaleSetExtensionListResultPager) PageResponse() *VirtualMachineScaleSetExtensionListResultResponse {
	return p.current
}

// VirtualMachineScaleSetListOSUpgradeHistoryPager provides iteration over VirtualMachineScaleSetListOSUpgradeHistory pages.
type VirtualMachineScaleSetListOSUpgradeHistoryPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineScaleSetListOSUpgradeHistoryResponse.
	PageResponse() *VirtualMachineScaleSetListOSUpgradeHistoryResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineScaleSetListOSUpgradeHistoryHandleResponse func(*azcore.Response) (*VirtualMachineScaleSetListOSUpgradeHistoryResponse, error)

type virtualMachineScaleSetListOSUpgradeHistoryAdvancePage func(*VirtualMachineScaleSetListOSUpgradeHistoryResponse) (*azcore.Request, error)

type virtualMachineScaleSetListOSUpgradeHistoryPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualMachineScaleSetListOSUpgradeHistoryHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineScaleSetListOSUpgradeHistoryAdvancePage
	// contains the current response
	current *VirtualMachineScaleSetListOSUpgradeHistoryResponse
	// any error encountered
	err error
}

func (p *virtualMachineScaleSetListOSUpgradeHistoryPager) Err() error {
	return p.err
}

func (p *virtualMachineScaleSetListOSUpgradeHistoryPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualMachineScaleSetListOSUpgradeHistory.NextLink == nil || len(*p.current.VirtualMachineScaleSetListOSUpgradeHistory.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineScaleSetListOSUpgradeHistoryPager) PageResponse() *VirtualMachineScaleSetListOSUpgradeHistoryResponse {
	return p.current
}

// VirtualMachineScaleSetListResultPager provides iteration over VirtualMachineScaleSetListResult pages.
type VirtualMachineScaleSetListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineScaleSetListResultResponse.
	PageResponse() *VirtualMachineScaleSetListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineScaleSetListResultHandleResponse func(*azcore.Response) (*VirtualMachineScaleSetListResultResponse, error)

type virtualMachineScaleSetListResultAdvancePage func(*VirtualMachineScaleSetListResultResponse) (*azcore.Request, error)

type virtualMachineScaleSetListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualMachineScaleSetListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineScaleSetListResultAdvancePage
	// contains the current response
	current *VirtualMachineScaleSetListResultResponse
	// any error encountered
	err error
}

func (p *virtualMachineScaleSetListResultPager) Err() error {
	return p.err
}

func (p *virtualMachineScaleSetListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualMachineScaleSetListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineScaleSetListResultPager) PageResponse() *VirtualMachineScaleSetListResultResponse {
	return p.current
}

// VirtualMachineScaleSetListSkusResultPager provides iteration over VirtualMachineScaleSetListSkusResult pages.
type VirtualMachineScaleSetListSkusResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineScaleSetListSkusResultResponse.
	PageResponse() *VirtualMachineScaleSetListSkusResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineScaleSetListSkusResultHandleResponse func(*azcore.Response) (*VirtualMachineScaleSetListSkusResultResponse, error)

type virtualMachineScaleSetListSkusResultAdvancePage func(*VirtualMachineScaleSetListSkusResultResponse) (*azcore.Request, error)

type virtualMachineScaleSetListSkusResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualMachineScaleSetListSkusResultHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineScaleSetListSkusResultAdvancePage
	// contains the current response
	current *VirtualMachineScaleSetListSkusResultResponse
	// any error encountered
	err error
}

func (p *virtualMachineScaleSetListSkusResultPager) Err() error {
	return p.err
}

func (p *virtualMachineScaleSetListSkusResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualMachineScaleSetListSkusResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListSkusResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineScaleSetListSkusResultPager) PageResponse() *VirtualMachineScaleSetListSkusResultResponse {
	return p.current
}

// VirtualMachineScaleSetListWithLinkResultPager provides iteration over VirtualMachineScaleSetListWithLinkResult pages.
type VirtualMachineScaleSetListWithLinkResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineScaleSetListWithLinkResultResponse.
	PageResponse() *VirtualMachineScaleSetListWithLinkResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineScaleSetListWithLinkResultHandleResponse func(*azcore.Response) (*VirtualMachineScaleSetListWithLinkResultResponse, error)

type virtualMachineScaleSetListWithLinkResultAdvancePage func(*VirtualMachineScaleSetListWithLinkResultResponse) (*azcore.Request, error)

type virtualMachineScaleSetListWithLinkResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualMachineScaleSetListWithLinkResultHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineScaleSetListWithLinkResultAdvancePage
	// contains the current response
	current *VirtualMachineScaleSetListWithLinkResultResponse
	// any error encountered
	err error
}

func (p *virtualMachineScaleSetListWithLinkResultPager) Err() error {
	return p.err
}

func (p *virtualMachineScaleSetListWithLinkResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualMachineScaleSetListWithLinkResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListWithLinkResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineScaleSetListWithLinkResultPager) PageResponse() *VirtualMachineScaleSetListWithLinkResultResponse {
	return p.current
}

// VirtualMachineScaleSetVMListResultPager provides iteration over VirtualMachineScaleSetVMListResult pages.
type VirtualMachineScaleSetVMListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineScaleSetVMListResultResponse.
	PageResponse() *VirtualMachineScaleSetVMListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineScaleSetVMListResultHandleResponse func(*azcore.Response) (*VirtualMachineScaleSetVMListResultResponse, error)

type virtualMachineScaleSetVMListResultAdvancePage func(*VirtualMachineScaleSetVMListResultResponse) (*azcore.Request, error)

type virtualMachineScaleSetVMListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualMachineScaleSetVMListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineScaleSetVMListResultAdvancePage
	// contains the current response
	current *VirtualMachineScaleSetVMListResultResponse
	// any error encountered
	err error
}

func (p *virtualMachineScaleSetVMListResultPager) Err() error {
	return p.err
}

func (p *virtualMachineScaleSetVMListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualMachineScaleSetVMListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetVMListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineScaleSetVMListResultPager) PageResponse() *VirtualMachineScaleSetVMListResultResponse {
	return p.current
}
