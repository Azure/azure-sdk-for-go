// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azcompute

import (
	"context"
	"encoding/json"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"time"
)

// AccessURIPoller provides polling facilities until the operation completes
type AccessURIPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*AccessURIResponse, error)
	ResumeToken() (string, error)
}

type accessUriPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *accessUriPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *accessUriPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *accessUriPoller) FinalResponse(ctx context.Context) (*AccessURIResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.AccessURI != AccessURI{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeAccessURIPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *accessUriPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *accessUriPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*AccessURIResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *accessUriPoller) handleResponse(resp *azcore.Response) (*AccessURIResponse, error) {
	result := AccessURIResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.AccessURI)
}

// ContainerServicePoller provides polling facilities until the operation completes
type ContainerServicePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ContainerServiceResponse, error)
	ResumeToken() (string, error)
}

type containerServicePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *containerServicePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *containerServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *containerServicePoller) FinalResponse(ctx context.Context) (*ContainerServiceResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ContainerService != ContainerService{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeContainerServicePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *containerServicePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *containerServicePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ContainerServiceResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *containerServicePoller) handleResponse(resp *azcore.Response) (*ContainerServiceResponse, error) {
	result := ContainerServiceResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ContainerService)
}

// DedicatedHostPoller provides polling facilities until the operation completes
type DedicatedHostPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*DedicatedHostResponse, error)
	ResumeToken() (string, error)
}

type dedicatedHostPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *dedicatedHostPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *dedicatedHostPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *dedicatedHostPoller) FinalResponse(ctx context.Context) (*DedicatedHostResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.DedicatedHost != DedicatedHost{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeDedicatedHostPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *dedicatedHostPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *dedicatedHostPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*DedicatedHostResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *dedicatedHostPoller) handleResponse(resp *azcore.Response) (*DedicatedHostResponse, error) {
	result := DedicatedHostResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.DedicatedHost)
}

// DiskEncryptionSetPoller provides polling facilities until the operation completes
type DiskEncryptionSetPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*DiskEncryptionSetResponse, error)
	ResumeToken() (string, error)
}

type diskEncryptionSetPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *diskEncryptionSetPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *diskEncryptionSetPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *diskEncryptionSetPoller) FinalResponse(ctx context.Context) (*DiskEncryptionSetResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.DiskEncryptionSet != DiskEncryptionSet{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeDiskEncryptionSetPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *diskEncryptionSetPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *diskEncryptionSetPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*DiskEncryptionSetResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *diskEncryptionSetPoller) handleResponse(resp *azcore.Response) (*DiskEncryptionSetResponse, error) {
	result := DiskEncryptionSetResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.DiskEncryptionSet)
}

// DiskPoller provides polling facilities until the operation completes
type DiskPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*DiskResponse, error)
	ResumeToken() (string, error)
}

type diskPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *diskPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *diskPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *diskPoller) FinalResponse(ctx context.Context) (*DiskResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.Disk != Disk{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeDiskPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *diskPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *diskPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*DiskResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *diskPoller) handleResponse(resp *azcore.Response) (*DiskResponse, error) {
	result := DiskResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.Disk)
}

// GalleryApplicationPoller provides polling facilities until the operation completes
type GalleryApplicationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*GalleryApplicationResponse, error)
	ResumeToken() (string, error)
}

type galleryApplicationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *galleryApplicationPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *galleryApplicationPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *galleryApplicationPoller) FinalResponse(ctx context.Context) (*GalleryApplicationResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.GalleryApplication != GalleryApplication{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeGalleryApplicationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *galleryApplicationPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *galleryApplicationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*GalleryApplicationResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *galleryApplicationPoller) handleResponse(resp *azcore.Response) (*GalleryApplicationResponse, error) {
	result := GalleryApplicationResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.GalleryApplication)
}

// GalleryApplicationVersionPoller provides polling facilities until the operation completes
type GalleryApplicationVersionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*GalleryApplicationVersionResponse, error)
	ResumeToken() (string, error)
}

type galleryApplicationVersionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *galleryApplicationVersionPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *galleryApplicationVersionPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *galleryApplicationVersionPoller) FinalResponse(ctx context.Context) (*GalleryApplicationVersionResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.GalleryApplicationVersion != GalleryApplicationVersion{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeGalleryApplicationVersionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *galleryApplicationVersionPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *galleryApplicationVersionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*GalleryApplicationVersionResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *galleryApplicationVersionPoller) handleResponse(resp *azcore.Response) (*GalleryApplicationVersionResponse, error) {
	result := GalleryApplicationVersionResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.GalleryApplicationVersion)
}

// GalleryImagePoller provides polling facilities until the operation completes
type GalleryImagePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*GalleryImageResponse, error)
	ResumeToken() (string, error)
}

type galleryImagePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *galleryImagePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *galleryImagePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *galleryImagePoller) FinalResponse(ctx context.Context) (*GalleryImageResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.GalleryImage != GalleryImage{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeGalleryImagePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *galleryImagePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *galleryImagePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*GalleryImageResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *galleryImagePoller) handleResponse(resp *azcore.Response) (*GalleryImageResponse, error) {
	result := GalleryImageResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.GalleryImage)
}

// GalleryImageVersionPoller provides polling facilities until the operation completes
type GalleryImageVersionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*GalleryImageVersionResponse, error)
	ResumeToken() (string, error)
}

type galleryImageVersionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *galleryImageVersionPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *galleryImageVersionPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *galleryImageVersionPoller) FinalResponse(ctx context.Context) (*GalleryImageVersionResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.GalleryImageVersion != GalleryImageVersion{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeGalleryImageVersionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *galleryImageVersionPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *galleryImageVersionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*GalleryImageVersionResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *galleryImageVersionPoller) handleResponse(resp *azcore.Response) (*GalleryImageVersionResponse, error) {
	result := GalleryImageVersionResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.GalleryImageVersion)
}

// GalleryPoller provides polling facilities until the operation completes
type GalleryPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*GalleryResponse, error)
	ResumeToken() (string, error)
}

type galleryPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *galleryPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *galleryPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *galleryPoller) FinalResponse(ctx context.Context) (*GalleryResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.Gallery != Gallery{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeGalleryPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *galleryPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *galleryPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*GalleryResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *galleryPoller) handleResponse(resp *azcore.Response) (*GalleryResponse, error) {
	result := GalleryResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.Gallery)
}

// HTTPPoller provides polling facilities until the operation completes
type HTTPPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse() *http.Response
	ResumeToken() (string, error)
}

type httpPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *httpPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *httpPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *httpPoller) FinalResponse() *http.Response {
	return p.pt.latestResponse().Response
}

// ResumeToken generates the string token that can be used with the ResumeHTTPPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *httpPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *httpPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*http.Response, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(), nil
}

// ImagePoller provides polling facilities until the operation completes
type ImagePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ImageResponse, error)
	ResumeToken() (string, error)
}

type imagePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *imagePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *imagePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *imagePoller) FinalResponse(ctx context.Context) (*ImageResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.Image != Image{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeImagePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *imagePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *imagePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ImageResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *imagePoller) handleResponse(resp *azcore.Response) (*ImageResponse, error) {
	result := ImageResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.Image)
}

// LogAnalyticsOperationResultPoller provides polling facilities until the operation completes
type LogAnalyticsOperationResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*LogAnalyticsOperationResultResponse, error)
	ResumeToken() (string, error)
}

type logAnalyticsOperationResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *logAnalyticsOperationResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *logAnalyticsOperationResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *logAnalyticsOperationResultPoller) FinalResponse(ctx context.Context) (*LogAnalyticsOperationResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.LogAnalyticsOperationResult != LogAnalyticsOperationResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeLogAnalyticsOperationResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *logAnalyticsOperationResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *logAnalyticsOperationResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*LogAnalyticsOperationResultResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *logAnalyticsOperationResultPoller) handleResponse(resp *azcore.Response) (*LogAnalyticsOperationResultResponse, error) {
	result := LogAnalyticsOperationResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.LogAnalyticsOperationResult)
}

// RunCommandResultPoller provides polling facilities until the operation completes
type RunCommandResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*RunCommandResultResponse, error)
	ResumeToken() (string, error)
}

type runCommandResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *runCommandResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *runCommandResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *runCommandResultPoller) FinalResponse(ctx context.Context) (*RunCommandResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.RunCommandResult != RunCommandResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeRunCommandResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *runCommandResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *runCommandResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*RunCommandResultResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *runCommandResultPoller) handleResponse(resp *azcore.Response) (*RunCommandResultResponse, error) {
	result := RunCommandResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.RunCommandResult)
}

// SnapshotPoller provides polling facilities until the operation completes
type SnapshotPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*SnapshotResponse, error)
	ResumeToken() (string, error)
}

type snapshotPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *snapshotPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *snapshotPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *snapshotPoller) FinalResponse(ctx context.Context) (*SnapshotResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.Snapshot != Snapshot{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeSnapshotPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *snapshotPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *snapshotPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*SnapshotResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *snapshotPoller) handleResponse(resp *azcore.Response) (*SnapshotResponse, error) {
	result := SnapshotResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.Snapshot)
}

// VirtualMachineCaptureResultPoller provides polling facilities until the operation completes
type VirtualMachineCaptureResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualMachineCaptureResultResponse, error)
	ResumeToken() (string, error)
}

type virtualMachineCaptureResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualMachineCaptureResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualMachineCaptureResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualMachineCaptureResultPoller) FinalResponse(ctx context.Context) (*VirtualMachineCaptureResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualMachineCaptureResult != VirtualMachineCaptureResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualMachineCaptureResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualMachineCaptureResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualMachineCaptureResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualMachineCaptureResultResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualMachineCaptureResultPoller) handleResponse(resp *azcore.Response) (*VirtualMachineCaptureResultResponse, error) {
	result := VirtualMachineCaptureResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineCaptureResult)
}

// VirtualMachineExtensionPoller provides polling facilities until the operation completes
type VirtualMachineExtensionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualMachineExtensionResponse, error)
	ResumeToken() (string, error)
}

type virtualMachineExtensionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualMachineExtensionPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualMachineExtensionPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualMachineExtensionPoller) FinalResponse(ctx context.Context) (*VirtualMachineExtensionResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualMachineExtension != VirtualMachineExtension{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualMachineExtensionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualMachineExtensionPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualMachineExtensionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualMachineExtensionResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualMachineExtensionPoller) handleResponse(resp *azcore.Response) (*VirtualMachineExtensionResponse, error) {
	result := VirtualMachineExtensionResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineExtension)
}

// VirtualMachinePoller provides polling facilities until the operation completes
type VirtualMachinePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualMachineResponse, error)
	ResumeToken() (string, error)
}

type virtualMachinePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualMachinePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualMachinePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualMachinePoller) FinalResponse(ctx context.Context) (*VirtualMachineResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualMachine != VirtualMachine{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualMachinePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualMachinePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualMachinePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualMachineResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualMachinePoller) handleResponse(resp *azcore.Response) (*VirtualMachineResponse, error) {
	result := VirtualMachineResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachine)
}

// VirtualMachineScaleSetExtensionPoller provides polling facilities until the operation completes
type VirtualMachineScaleSetExtensionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualMachineScaleSetExtensionResponse, error)
	ResumeToken() (string, error)
}

type virtualMachineScaleSetExtensionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualMachineScaleSetExtensionPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualMachineScaleSetExtensionPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualMachineScaleSetExtensionPoller) FinalResponse(ctx context.Context) (*VirtualMachineScaleSetExtensionResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualMachineScaleSetExtension != VirtualMachineScaleSetExtension{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualMachineScaleSetExtensionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualMachineScaleSetExtensionPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualMachineScaleSetExtensionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualMachineScaleSetExtensionResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualMachineScaleSetExtensionPoller) handleResponse(resp *azcore.Response) (*VirtualMachineScaleSetExtensionResponse, error) {
	result := VirtualMachineScaleSetExtensionResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineScaleSetExtension)
}

// VirtualMachineScaleSetPoller provides polling facilities until the operation completes
type VirtualMachineScaleSetPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualMachineScaleSetResponse, error)
	ResumeToken() (string, error)
}

type virtualMachineScaleSetPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualMachineScaleSetPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualMachineScaleSetPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualMachineScaleSetPoller) FinalResponse(ctx context.Context) (*VirtualMachineScaleSetResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualMachineScaleSet != VirtualMachineScaleSet{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualMachineScaleSetPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualMachineScaleSetPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualMachineScaleSetPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualMachineScaleSetResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualMachineScaleSetPoller) handleResponse(resp *azcore.Response) (*VirtualMachineScaleSetResponse, error) {
	result := VirtualMachineScaleSetResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineScaleSet)
}

// VirtualMachineScaleSetVMPoller provides polling facilities until the operation completes
type VirtualMachineScaleSetVMPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualMachineScaleSetVMResponse, error)
	ResumeToken() (string, error)
}

type virtualMachineScaleSetVMPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualMachineScaleSetVMPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualMachineScaleSetVMPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualMachineScaleSetVMPoller) FinalResponse(ctx context.Context) (*VirtualMachineScaleSetVMResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualMachineScaleSetVM != VirtualMachineScaleSetVM{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualMachineScaleSetVMPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualMachineScaleSetVMPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualMachineScaleSetVMPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualMachineScaleSetVMResponse, error) {
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		if delay := azcore.RetryAfter(resp); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(frequency)
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualMachineScaleSetVMPoller) handleResponse(resp *azcore.Response) (*VirtualMachineScaleSetVMResponse, error) {
	result := VirtualMachineScaleSetVMResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineScaleSetVM)
}
