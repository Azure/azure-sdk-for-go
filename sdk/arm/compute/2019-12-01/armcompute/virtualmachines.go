// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// VirtualMachinesOperations contains the methods for the VirtualMachines group.
type VirtualMachinesOperations interface {
	// BeginCapture - Captures the VM by copying virtual hard disks of the VM and outputs a template that can be used to create similar VMs.
	BeginCapture(ctx context.Context, resourceGroupName string, vmName string, parameters VirtualMachineCaptureParameters) (*VirtualMachineCaptureResultPollerResponse, error)
	// ResumeCapture - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCapture(token string) (VirtualMachineCaptureResultPoller, error)
	// BeginConvertToManagedDisks - Converts virtual machine disks from blob-based to managed disks. Virtual machine must be stop-deallocated before invoking this operation.
	BeginConvertToManagedDisks(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error)
	// ResumeConvertToManagedDisks - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeConvertToManagedDisks(token string) (HTTPPoller, error)
	// BeginCreateOrUpdate - The operation to create or update a virtual machine. Please note some properties can be set only during virtual machine creation.
	BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, vmName string, parameters VirtualMachine) (*VirtualMachinePollerResponse, error)
	// ResumeCreateOrUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdate(token string) (VirtualMachinePoller, error)
	// BeginDeallocate - Shuts down the virtual machine and releases the compute resources. You are not billed for the compute resources that this virtual machine uses.
	BeginDeallocate(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error)
	// ResumeDeallocate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeallocate(token string) (HTTPPoller, error)
	// BeginDelete - The operation to delete a virtual machine.
	BeginDelete(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error)
	// ResumeDelete - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDelete(token string) (HTTPPoller, error)
	// Generalize - Sets the OS state of the virtual machine to generalized. It is recommended to sysprep the virtual machine before performing this operation. <br>For Windows, please refer to [Create a managed image of a generalized VM in Azure](https://docs.microsoft.com/en-us/azure/virtual-machines/windows/capture-image-resource).<br>For Linux, please refer to [How to create an image of a virtual machine or VHD](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/capture-image).
	Generalize(ctx context.Context, resourceGroupName string, vmName string) (*http.Response, error)
	// Get - Retrieves information about the model view or the instance view of a virtual machine.
	Get(ctx context.Context, resourceGroupName string, vmName string) (*VirtualMachineResponse, error)
	// InstanceView - Retrieves information about the run-time state of a virtual machine.
	InstanceView(ctx context.Context, resourceGroupName string, vmName string) (*VirtualMachineInstanceViewResponse, error)
	// List - Lists all of the virtual machines in the specified resource group. Use the nextLink property in the response to get the next page of virtual machines.
	List(resourceGroupName string) (VirtualMachineListResultPager, error)
	// ListAll - Lists all of the virtual machines in the specified subscription. Use the nextLink property in the response to get the next page of virtual machines.
	ListAll(virtualMachinesListAllOptions *VirtualMachinesListAllOptions) (VirtualMachineListResultPager, error)
	// ListAvailableSizes - Lists all available virtual machine sizes to which the specified virtual machine can be resized.
	ListAvailableSizes(ctx context.Context, resourceGroupName string, vmName string) (*VirtualMachineSizeListResultResponse, error)
	// ListByLocation - Gets all the virtual machines under the specified subscription for the specified location.
	ListByLocation(location string) (VirtualMachineListResultPager, error)
	// BeginPerformMaintenance - The operation to perform maintenance on a virtual machine.
	BeginPerformMaintenance(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error)
	// ResumePerformMaintenance - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePerformMaintenance(token string) (HTTPPoller, error)
	// BeginPowerOff - The operation to power off (stop) a virtual machine. The virtual machine can be restarted with the same provisioned resources. You are still charged for this virtual machine.
	BeginPowerOff(ctx context.Context, resourceGroupName string, vmName string, virtualMachinesPowerOffOptions *VirtualMachinesPowerOffOptions) (*HTTPPollerResponse, error)
	// ResumePowerOff - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePowerOff(token string) (HTTPPoller, error)
	// BeginReapply - The operation to reapply a virtual machine's state.
	BeginReapply(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error)
	// ResumeReapply - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeReapply(token string) (HTTPPoller, error)
	// BeginRedeploy - Shuts down the virtual machine, moves it to a new node, and powers it back on.
	BeginRedeploy(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error)
	// ResumeRedeploy - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeRedeploy(token string) (HTTPPoller, error)
	// BeginReimage - Reimages the virtual machine which has an ephemeral OS disk back to its initial state.
	BeginReimage(ctx context.Context, resourceGroupName string, vmName string, virtualMachinesReimageOptions *VirtualMachinesReimageOptions) (*HTTPPollerResponse, error)
	// ResumeReimage - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeReimage(token string) (HTTPPoller, error)
	// BeginRestart - The operation to restart a virtual machine.
	BeginRestart(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error)
	// ResumeRestart - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeRestart(token string) (HTTPPoller, error)
	// BeginRunCommand - Run command on the VM.
	BeginRunCommand(ctx context.Context, resourceGroupName string, vmName string, parameters RunCommandInput) (*RunCommandResultPollerResponse, error)
	// ResumeRunCommand - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeRunCommand(token string) (RunCommandResultPoller, error)
	// SimulateEviction - The operation to simulate the eviction of spot virtual machine. The eviction will occur within 30 minutes of calling the API
	SimulateEviction(ctx context.Context, resourceGroupName string, vmName string) (*http.Response, error)
	// BeginStart - The operation to start a virtual machine.
	BeginStart(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error)
	// ResumeStart - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeStart(token string) (HTTPPoller, error)
	// BeginUpdate - The operation to update a virtual machine.
	BeginUpdate(ctx context.Context, resourceGroupName string, vmName string, parameters VirtualMachineUpdate) (*VirtualMachinePollerResponse, error)
	// ResumeUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeUpdate(token string) (VirtualMachinePoller, error)
}

// virtualMachinesOperations implements the VirtualMachinesOperations interface.
type virtualMachinesOperations struct {
	*Client
	subscriptionID string
}

// Capture - Captures the VM by copying virtual hard disks of the VM and outputs a template that can be used to create similar VMs.
func (client *virtualMachinesOperations) BeginCapture(ctx context.Context, resourceGroupName string, vmName string, parameters VirtualMachineCaptureParameters) (*VirtualMachineCaptureResultPollerResponse, error) {
	req, err := client.captureCreateRequest(resourceGroupName, vmName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.captureHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.Capture", "location", resp, client.captureHandleError)
	if err != nil {
		return nil, err
	}
	poller := &virtualMachineCaptureResultPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*VirtualMachineCaptureResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumeCapture(token string) (VirtualMachineCaptureResultPoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.Capture", token, client.captureHandleError)
	if err != nil {
		return nil, err
	}
	return &virtualMachineCaptureResultPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// captureCreateRequest creates the Capture request.
func (client *virtualMachinesOperations) captureCreateRequest(resourceGroupName string, vmName string, parameters VirtualMachineCaptureParameters) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/capture"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(parameters)
}

// captureHandleResponse handles the Capture response.
func (client *virtualMachinesOperations) captureHandleResponse(resp *azcore.Response) (*VirtualMachineCaptureResultPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.captureHandleError(resp)
	}
	return &VirtualMachineCaptureResultPollerResponse{RawResponse: resp.Response}, nil
}

// captureHandleError handles the Capture error response.
func (client *virtualMachinesOperations) captureHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ConvertToManagedDisks - Converts virtual machine disks from blob-based to managed disks. Virtual machine must be stop-deallocated before invoking this operation.
func (client *virtualMachinesOperations) BeginConvertToManagedDisks(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error) {
	req, err := client.convertToManagedDisksCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.convertToManagedDisksHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.ConvertToManagedDisks", "", resp, client.convertToManagedDisksHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumeConvertToManagedDisks(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.ConvertToManagedDisks", token, client.convertToManagedDisksHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// convertToManagedDisksCreateRequest creates the ConvertToManagedDisks request.
func (client *virtualMachinesOperations) convertToManagedDisksCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/convertToManagedDisks"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// convertToManagedDisksHandleResponse handles the ConvertToManagedDisks response.
func (client *virtualMachinesOperations) convertToManagedDisksHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.convertToManagedDisksHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// convertToManagedDisksHandleError handles the ConvertToManagedDisks error response.
func (client *virtualMachinesOperations) convertToManagedDisksHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// CreateOrUpdate - The operation to create or update a virtual machine. Please note some properties can be set only during virtual machine creation.
func (client *virtualMachinesOperations) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, vmName string, parameters VirtualMachine) (*VirtualMachinePollerResponse, error) {
	req, err := client.createOrUpdateCreateRequest(resourceGroupName, vmName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createOrUpdateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.CreateOrUpdate", "", resp, client.createOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &virtualMachinePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*VirtualMachineResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumeCreateOrUpdate(token string) (VirtualMachinePoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.CreateOrUpdate", token, client.createOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	return &virtualMachinePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *virtualMachinesOperations) createOrUpdateCreateRequest(resourceGroupName string, vmName string, parameters VirtualMachine) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateHandleResponse handles the CreateOrUpdate response.
func (client *virtualMachinesOperations) createOrUpdateHandleResponse(resp *azcore.Response) (*VirtualMachinePollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusNoContent) {
		return nil, client.createOrUpdateHandleError(resp)
	}
	return &VirtualMachinePollerResponse{RawResponse: resp.Response}, nil
}

// createOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *virtualMachinesOperations) createOrUpdateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Deallocate - Shuts down the virtual machine and releases the compute resources. You are not billed for the compute resources that this virtual machine uses.
func (client *virtualMachinesOperations) BeginDeallocate(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error) {
	req, err := client.deallocateCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deallocateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.Deallocate", "", resp, client.deallocateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumeDeallocate(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.Deallocate", token, client.deallocateHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deallocateCreateRequest creates the Deallocate request.
func (client *virtualMachinesOperations) deallocateCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/deallocate"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// deallocateHandleResponse handles the Deallocate response.
func (client *virtualMachinesOperations) deallocateHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deallocateHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// deallocateHandleError handles the Deallocate error response.
func (client *virtualMachinesOperations) deallocateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Delete - The operation to delete a virtual machine.
func (client *virtualMachinesOperations) BeginDelete(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error) {
	req, err := client.deleteCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.Delete", "", resp, client.deleteHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumeDelete(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.Delete", token, client.deleteHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *virtualMachinesOperations) deleteCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *virtualMachinesOperations) deleteHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// deleteHandleError handles the Delete error response.
func (client *virtualMachinesOperations) deleteHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Generalize - Sets the OS state of the virtual machine to generalized. It is recommended to sysprep the virtual machine before performing this operation. <br>For Windows, please refer to [Create a managed image of a generalized VM in Azure](https://docs.microsoft.com/en-us/azure/virtual-machines/windows/capture-image-resource).<br>For Linux, please refer to [How to create an image of a virtual machine or VHD](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/capture-image).
func (client *virtualMachinesOperations) Generalize(ctx context.Context, resourceGroupName string, vmName string) (*http.Response, error) {
	req, err := client.generalizeCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.generalizeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// generalizeCreateRequest creates the Generalize request.
func (client *virtualMachinesOperations) generalizeCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/generalize"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// generalizeHandleResponse handles the Generalize response.
func (client *virtualMachinesOperations) generalizeHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.generalizeHandleError(resp)
	}
	return resp.Response, nil
}

// generalizeHandleError handles the Generalize error response.
func (client *virtualMachinesOperations) generalizeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Get - Retrieves information about the model view or the instance view of a virtual machine.
func (client *virtualMachinesOperations) Get(ctx context.Context, resourceGroupName string, vmName string) (*VirtualMachineResponse, error) {
	req, err := client.getCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getCreateRequest creates the Get request.
func (client *virtualMachinesOperations) getCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *virtualMachinesOperations) getHandleResponse(resp *azcore.Response) (*VirtualMachineResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getHandleError(resp)
	}
	result := VirtualMachineResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachine)
}

// getHandleError handles the Get error response.
func (client *virtualMachinesOperations) getHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// InstanceView - Retrieves information about the run-time state of a virtual machine.
func (client *virtualMachinesOperations) InstanceView(ctx context.Context, resourceGroupName string, vmName string) (*VirtualMachineInstanceViewResponse, error) {
	req, err := client.instanceViewCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.instanceViewHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// instanceViewCreateRequest creates the InstanceView request.
func (client *virtualMachinesOperations) instanceViewCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/instanceView"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// instanceViewHandleResponse handles the InstanceView response.
func (client *virtualMachinesOperations) instanceViewHandleResponse(resp *azcore.Response) (*VirtualMachineInstanceViewResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.instanceViewHandleError(resp)
	}
	result := VirtualMachineInstanceViewResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineInstanceView)
}

// instanceViewHandleError handles the InstanceView error response.
func (client *virtualMachinesOperations) instanceViewHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// List - Lists all of the virtual machines in the specified resource group. Use the nextLink property in the response to get the next page of virtual machines.
func (client *virtualMachinesOperations) List(resourceGroupName string) (VirtualMachineListResultPager, error) {
	req, err := client.listCreateRequest(resourceGroupName)
	if err != nil {
		return nil, err
	}
	return &virtualMachineListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listHandleResponse,
		advancer: func(resp *VirtualMachineListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.VirtualMachineListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.VirtualMachineListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listCreateRequest creates the List request.
func (client *virtualMachinesOperations) listCreateRequest(resourceGroupName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listHandleResponse handles the List response.
func (client *virtualMachinesOperations) listHandleResponse(resp *azcore.Response) (*VirtualMachineListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listHandleError(resp)
	}
	result := VirtualMachineListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineListResult)
}

// listHandleError handles the List error response.
func (client *virtualMachinesOperations) listHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ListAll - Lists all of the virtual machines in the specified subscription. Use the nextLink property in the response to get the next page of virtual machines.
func (client *virtualMachinesOperations) ListAll(virtualMachinesListAllOptions *VirtualMachinesListAllOptions) (VirtualMachineListResultPager, error) {
	req, err := client.listAllCreateRequest(virtualMachinesListAllOptions)
	if err != nil {
		return nil, err
	}
	return &virtualMachineListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listAllHandleResponse,
		advancer: func(resp *VirtualMachineListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.VirtualMachineListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.VirtualMachineListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listAllCreateRequest creates the ListAll request.
func (client *virtualMachinesOperations) listAllCreateRequest(virtualMachinesListAllOptions *VirtualMachinesListAllOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/virtualMachines"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	if virtualMachinesListAllOptions != nil && virtualMachinesListAllOptions.StatusOnly != nil {
		query.Set("statusOnly", *virtualMachinesListAllOptions.StatusOnly)
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listAllHandleResponse handles the ListAll response.
func (client *virtualMachinesOperations) listAllHandleResponse(resp *azcore.Response) (*VirtualMachineListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listAllHandleError(resp)
	}
	result := VirtualMachineListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineListResult)
}

// listAllHandleError handles the ListAll error response.
func (client *virtualMachinesOperations) listAllHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ListAvailableSizes - Lists all available virtual machine sizes to which the specified virtual machine can be resized.
func (client *virtualMachinesOperations) ListAvailableSizes(ctx context.Context, resourceGroupName string, vmName string) (*VirtualMachineSizeListResultResponse, error) {
	req, err := client.listAvailableSizesCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.listAvailableSizesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// listAvailableSizesCreateRequest creates the ListAvailableSizes request.
func (client *virtualMachinesOperations) listAvailableSizesCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/vmSizes"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listAvailableSizesHandleResponse handles the ListAvailableSizes response.
func (client *virtualMachinesOperations) listAvailableSizesHandleResponse(resp *azcore.Response) (*VirtualMachineSizeListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listAvailableSizesHandleError(resp)
	}
	result := VirtualMachineSizeListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineSizeListResult)
}

// listAvailableSizesHandleError handles the ListAvailableSizes error response.
func (client *virtualMachinesOperations) listAvailableSizesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ListByLocation - Gets all the virtual machines under the specified subscription for the specified location.
func (client *virtualMachinesOperations) ListByLocation(location string) (VirtualMachineListResultPager, error) {
	req, err := client.listByLocationCreateRequest(location)
	if err != nil {
		return nil, err
	}
	return &virtualMachineListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listByLocationHandleResponse,
		advancer: func(resp *VirtualMachineListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.VirtualMachineListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.VirtualMachineListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listByLocationCreateRequest creates the ListByLocation request.
func (client *virtualMachinesOperations) listByLocationCreateRequest(location string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/virtualMachines"
	urlPath = strings.ReplaceAll(urlPath, "{location}", url.PathEscape(location))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listByLocationHandleResponse handles the ListByLocation response.
func (client *virtualMachinesOperations) listByLocationHandleResponse(resp *azcore.Response) (*VirtualMachineListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listByLocationHandleError(resp)
	}
	result := VirtualMachineListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineListResult)
}

// listByLocationHandleError handles the ListByLocation error response.
func (client *virtualMachinesOperations) listByLocationHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PerformMaintenance - The operation to perform maintenance on a virtual machine.
func (client *virtualMachinesOperations) BeginPerformMaintenance(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error) {
	req, err := client.performMaintenanceCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.performMaintenanceHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.PerformMaintenance", "", resp, client.performMaintenanceHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumePerformMaintenance(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.PerformMaintenance", token, client.performMaintenanceHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// performMaintenanceCreateRequest creates the PerformMaintenance request.
func (client *virtualMachinesOperations) performMaintenanceCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/performMaintenance"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// performMaintenanceHandleResponse handles the PerformMaintenance response.
func (client *virtualMachinesOperations) performMaintenanceHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.performMaintenanceHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// performMaintenanceHandleError handles the PerformMaintenance error response.
func (client *virtualMachinesOperations) performMaintenanceHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PowerOff - The operation to power off (stop) a virtual machine. The virtual machine can be restarted with the same provisioned resources. You are still charged for this virtual machine.
func (client *virtualMachinesOperations) BeginPowerOff(ctx context.Context, resourceGroupName string, vmName string, virtualMachinesPowerOffOptions *VirtualMachinesPowerOffOptions) (*HTTPPollerResponse, error) {
	req, err := client.powerOffCreateRequest(resourceGroupName, vmName, virtualMachinesPowerOffOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.powerOffHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.PowerOff", "", resp, client.powerOffHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumePowerOff(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.PowerOff", token, client.powerOffHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// powerOffCreateRequest creates the PowerOff request.
func (client *virtualMachinesOperations) powerOffCreateRequest(resourceGroupName string, vmName string, virtualMachinesPowerOffOptions *VirtualMachinesPowerOffOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/powerOff"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	if virtualMachinesPowerOffOptions != nil && virtualMachinesPowerOffOptions.SkipShutdown != nil {
		query.Set("skipShutdown", strconv.FormatBool(*virtualMachinesPowerOffOptions.SkipShutdown))
	}
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// powerOffHandleResponse handles the PowerOff response.
func (client *virtualMachinesOperations) powerOffHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.powerOffHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// powerOffHandleError handles the PowerOff error response.
func (client *virtualMachinesOperations) powerOffHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Reapply - The operation to reapply a virtual machine's state.
func (client *virtualMachinesOperations) BeginReapply(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error) {
	req, err := client.reapplyCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.reapplyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.Reapply", "", resp, client.reapplyHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumeReapply(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.Reapply", token, client.reapplyHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// reapplyCreateRequest creates the Reapply request.
func (client *virtualMachinesOperations) reapplyCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/reapply"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// reapplyHandleResponse handles the Reapply response.
func (client *virtualMachinesOperations) reapplyHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.reapplyHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// reapplyHandleError handles the Reapply error response.
func (client *virtualMachinesOperations) reapplyHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Redeploy - Shuts down the virtual machine, moves it to a new node, and powers it back on.
func (client *virtualMachinesOperations) BeginRedeploy(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error) {
	req, err := client.redeployCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.redeployHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.Redeploy", "", resp, client.redeployHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumeRedeploy(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.Redeploy", token, client.redeployHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// redeployCreateRequest creates the Redeploy request.
func (client *virtualMachinesOperations) redeployCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/redeploy"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// redeployHandleResponse handles the Redeploy response.
func (client *virtualMachinesOperations) redeployHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.redeployHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// redeployHandleError handles the Redeploy error response.
func (client *virtualMachinesOperations) redeployHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Reimage - Reimages the virtual machine which has an ephemeral OS disk back to its initial state.
func (client *virtualMachinesOperations) BeginReimage(ctx context.Context, resourceGroupName string, vmName string, virtualMachinesReimageOptions *VirtualMachinesReimageOptions) (*HTTPPollerResponse, error) {
	req, err := client.reimageCreateRequest(resourceGroupName, vmName, virtualMachinesReimageOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.reimageHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.Reimage", "", resp, client.reimageHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumeReimage(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.Reimage", token, client.reimageHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// reimageCreateRequest creates the Reimage request.
func (client *virtualMachinesOperations) reimageCreateRequest(resourceGroupName string, vmName string, virtualMachinesReimageOptions *VirtualMachinesReimageOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/reimage"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	if virtualMachinesReimageOptions != nil {
		return req, req.MarshalAsJSON(virtualMachinesReimageOptions.Parameters)
	}
	return req, nil
}

// reimageHandleResponse handles the Reimage response.
func (client *virtualMachinesOperations) reimageHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.reimageHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// reimageHandleError handles the Reimage error response.
func (client *virtualMachinesOperations) reimageHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Restart - The operation to restart a virtual machine.
func (client *virtualMachinesOperations) BeginRestart(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error) {
	req, err := client.restartCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.restartHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.Restart", "", resp, client.restartHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumeRestart(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.Restart", token, client.restartHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// restartCreateRequest creates the Restart request.
func (client *virtualMachinesOperations) restartCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/restart"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// restartHandleResponse handles the Restart response.
func (client *virtualMachinesOperations) restartHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.restartHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// restartHandleError handles the Restart error response.
func (client *virtualMachinesOperations) restartHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// RunCommand - Run command on the VM.
func (client *virtualMachinesOperations) BeginRunCommand(ctx context.Context, resourceGroupName string, vmName string, parameters RunCommandInput) (*RunCommandResultPollerResponse, error) {
	req, err := client.runCommandCreateRequest(resourceGroupName, vmName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.runCommandHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.RunCommand", "location", resp, client.runCommandHandleError)
	if err != nil {
		return nil, err
	}
	poller := &runCommandResultPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*RunCommandResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumeRunCommand(token string) (RunCommandResultPoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.RunCommand", token, client.runCommandHandleError)
	if err != nil {
		return nil, err
	}
	return &runCommandResultPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// runCommandCreateRequest creates the RunCommand request.
func (client *virtualMachinesOperations) runCommandCreateRequest(resourceGroupName string, vmName string, parameters RunCommandInput) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/runCommand"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(parameters)
}

// runCommandHandleResponse handles the RunCommand response.
func (client *virtualMachinesOperations) runCommandHandleResponse(resp *azcore.Response) (*RunCommandResultPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.runCommandHandleError(resp)
	}
	return &RunCommandResultPollerResponse{RawResponse: resp.Response}, nil
}

// runCommandHandleError handles the RunCommand error response.
func (client *virtualMachinesOperations) runCommandHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// SimulateEviction - The operation to simulate the eviction of spot virtual machine. The eviction will occur within 30 minutes of calling the API
func (client *virtualMachinesOperations) SimulateEviction(ctx context.Context, resourceGroupName string, vmName string) (*http.Response, error) {
	req, err := client.simulateEvictionCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.simulateEvictionHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// simulateEvictionCreateRequest creates the SimulateEviction request.
func (client *virtualMachinesOperations) simulateEvictionCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/simulateEviction"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// simulateEvictionHandleResponse handles the SimulateEviction response.
func (client *virtualMachinesOperations) simulateEvictionHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.simulateEvictionHandleError(resp)
	}
	return resp.Response, nil
}

// simulateEvictionHandleError handles the SimulateEviction error response.
func (client *virtualMachinesOperations) simulateEvictionHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Start - The operation to start a virtual machine.
func (client *virtualMachinesOperations) BeginStart(ctx context.Context, resourceGroupName string, vmName string) (*HTTPPollerResponse, error) {
	req, err := client.startCreateRequest(resourceGroupName, vmName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.startHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.Start", "", resp, client.startHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumeStart(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.Start", token, client.startHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// startCreateRequest creates the Start request.
func (client *virtualMachinesOperations) startCreateRequest(resourceGroupName string, vmName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/start"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// startHandleResponse handles the Start response.
func (client *virtualMachinesOperations) startHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.startHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// startHandleError handles the Start error response.
func (client *virtualMachinesOperations) startHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Update - The operation to update a virtual machine.
func (client *virtualMachinesOperations) BeginUpdate(ctx context.Context, resourceGroupName string, vmName string, parameters VirtualMachineUpdate) (*VirtualMachinePollerResponse, error) {
	req, err := client.updateCreateRequest(resourceGroupName, vmName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.updateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachinesOperations.Update", "", resp, client.updateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &virtualMachinePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*VirtualMachineResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachinesOperations) ResumeUpdate(token string) (VirtualMachinePoller, error) {
	pt, err := resumePollingTracker("virtualMachinesOperations.Update", token, client.updateHandleError)
	if err != nil {
		return nil, err
	}
	return &virtualMachinePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// updateCreateRequest creates the Update request.
func (client *virtualMachinesOperations) updateCreateRequest(resourceGroupName string, vmName string, parameters VirtualMachineUpdate) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmName}", url.PathEscape(vmName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPatch, *u)
	return req, req.MarshalAsJSON(parameters)
}

// updateHandleResponse handles the Update response.
func (client *virtualMachinesOperations) updateHandleResponse(resp *azcore.Response) (*VirtualMachinePollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusNoContent) {
		return nil, client.updateHandleError(resp)
	}
	return &VirtualMachinePollerResponse{RawResponse: resp.Response}, nil
}

// updateHandleError handles the Update error response.
func (client *virtualMachinesOperations) updateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}
