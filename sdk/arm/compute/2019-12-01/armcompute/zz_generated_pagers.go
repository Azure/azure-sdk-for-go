// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// AvailabilitySetListResultPager provides iteration over AvailabilitySetListResult pages.
type AvailabilitySetListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AvailabilitySetListResultResponse.
	PageResponse() *AvailabilitySetListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type availabilitySetListResultCreateRequest func(context.Context) (*azcore.Request, error)

type availabilitySetListResultHandleError func(*azcore.Response) error

type availabilitySetListResultHandleResponse func(*azcore.Response) (*AvailabilitySetListResultResponse, error)

type availabilitySetListResultAdvancePage func(context.Context, *AvailabilitySetListResultResponse) (*azcore.Request, error)

type availabilitySetListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester availabilitySetListResultCreateRequest
	// callback for handling response errors
	errorer availabilitySetListResultHandleError
	// callback for handling the HTTP response
	responder availabilitySetListResultHandleResponse
	// callback for advancing to the next page
	advancer availabilitySetListResultAdvancePage
	// contains the current response
	current *AvailabilitySetListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *availabilitySetListResultPager) Err() error {
	return p.err
}

func (p *availabilitySetListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.AvailabilitySetListResult.NextLink == nil || len(*p.current.AvailabilitySetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *availabilitySetListResultPager) PageResponse() *AvailabilitySetListResultResponse {
	return p.current
}

// ContainerServiceListResultPager provides iteration over ContainerServiceListResult pages.
type ContainerServiceListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ContainerServiceListResultResponse.
	PageResponse() *ContainerServiceListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type containerServiceListResultCreateRequest func(context.Context) (*azcore.Request, error)

type containerServiceListResultHandleError func(*azcore.Response) error

type containerServiceListResultHandleResponse func(*azcore.Response) (*ContainerServiceListResultResponse, error)

type containerServiceListResultAdvancePage func(context.Context, *ContainerServiceListResultResponse) (*azcore.Request, error)

type containerServiceListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester containerServiceListResultCreateRequest
	// callback for handling response errors
	errorer containerServiceListResultHandleError
	// callback for handling the HTTP response
	responder containerServiceListResultHandleResponse
	// callback for advancing to the next page
	advancer containerServiceListResultAdvancePage
	// contains the current response
	current *ContainerServiceListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *containerServiceListResultPager) Err() error {
	return p.err
}

func (p *containerServiceListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ContainerServiceListResult.NextLink == nil || len(*p.current.ContainerServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *containerServiceListResultPager) PageResponse() *ContainerServiceListResultResponse {
	return p.current
}

// DedicatedHostGroupListResultPager provides iteration over DedicatedHostGroupListResult pages.
type DedicatedHostGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current DedicatedHostGroupListResultResponse.
	PageResponse() *DedicatedHostGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type dedicatedHostGroupListResultCreateRequest func(context.Context) (*azcore.Request, error)

type dedicatedHostGroupListResultHandleError func(*azcore.Response) error

type dedicatedHostGroupListResultHandleResponse func(*azcore.Response) (*DedicatedHostGroupListResultResponse, error)

type dedicatedHostGroupListResultAdvancePage func(context.Context, *DedicatedHostGroupListResultResponse) (*azcore.Request, error)

type dedicatedHostGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester dedicatedHostGroupListResultCreateRequest
	// callback for handling response errors
	errorer dedicatedHostGroupListResultHandleError
	// callback for handling the HTTP response
	responder dedicatedHostGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer dedicatedHostGroupListResultAdvancePage
	// contains the current response
	current *DedicatedHostGroupListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *dedicatedHostGroupListResultPager) Err() error {
	return p.err
}

func (p *dedicatedHostGroupListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.DedicatedHostGroupListResult.NextLink == nil || len(*p.current.DedicatedHostGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *dedicatedHostGroupListResultPager) PageResponse() *DedicatedHostGroupListResultResponse {
	return p.current
}

// DedicatedHostListResultPager provides iteration over DedicatedHostListResult pages.
type DedicatedHostListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current DedicatedHostListResultResponse.
	PageResponse() *DedicatedHostListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type dedicatedHostListResultCreateRequest func(context.Context) (*azcore.Request, error)

type dedicatedHostListResultHandleError func(*azcore.Response) error

type dedicatedHostListResultHandleResponse func(*azcore.Response) (*DedicatedHostListResultResponse, error)

type dedicatedHostListResultAdvancePage func(context.Context, *DedicatedHostListResultResponse) (*azcore.Request, error)

type dedicatedHostListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester dedicatedHostListResultCreateRequest
	// callback for handling response errors
	errorer dedicatedHostListResultHandleError
	// callback for handling the HTTP response
	responder dedicatedHostListResultHandleResponse
	// callback for advancing to the next page
	advancer dedicatedHostListResultAdvancePage
	// contains the current response
	current *DedicatedHostListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *dedicatedHostListResultPager) Err() error {
	return p.err
}

func (p *dedicatedHostListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.DedicatedHostListResult.NextLink == nil || len(*p.current.DedicatedHostListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *dedicatedHostListResultPager) PageResponse() *DedicatedHostListResultResponse {
	return p.current
}

// DiskEncryptionSetListPager provides iteration over DiskEncryptionSetList pages.
type DiskEncryptionSetListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current DiskEncryptionSetListResponse.
	PageResponse() *DiskEncryptionSetListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type diskEncryptionSetListCreateRequest func(context.Context) (*azcore.Request, error)

type diskEncryptionSetListHandleError func(*azcore.Response) error

type diskEncryptionSetListHandleResponse func(*azcore.Response) (*DiskEncryptionSetListResponse, error)

type diskEncryptionSetListAdvancePage func(context.Context, *DiskEncryptionSetListResponse) (*azcore.Request, error)

type diskEncryptionSetListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester diskEncryptionSetListCreateRequest
	// callback for handling response errors
	errorer diskEncryptionSetListHandleError
	// callback for handling the HTTP response
	responder diskEncryptionSetListHandleResponse
	// callback for advancing to the next page
	advancer diskEncryptionSetListAdvancePage
	// contains the current response
	current *DiskEncryptionSetListResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *diskEncryptionSetListPager) Err() error {
	return p.err
}

func (p *diskEncryptionSetListPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.DiskEncryptionSetList.NextLink == nil || len(*p.current.DiskEncryptionSetList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *diskEncryptionSetListPager) PageResponse() *DiskEncryptionSetListResponse {
	return p.current
}

// DiskListPager provides iteration over DiskList pages.
type DiskListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current DiskListResponse.
	PageResponse() *DiskListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type diskListCreateRequest func(context.Context) (*azcore.Request, error)

type diskListHandleError func(*azcore.Response) error

type diskListHandleResponse func(*azcore.Response) (*DiskListResponse, error)

type diskListAdvancePage func(context.Context, *DiskListResponse) (*azcore.Request, error)

type diskListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester diskListCreateRequest
	// callback for handling response errors
	errorer diskListHandleError
	// callback for handling the HTTP response
	responder diskListHandleResponse
	// callback for advancing to the next page
	advancer diskListAdvancePage
	// contains the current response
	current *DiskListResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *diskListPager) Err() error {
	return p.err
}

func (p *diskListPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.DiskList.NextLink == nil || len(*p.current.DiskList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *diskListPager) PageResponse() *DiskListResponse {
	return p.current
}

// GalleryApplicationListPager provides iteration over GalleryApplicationList pages.
type GalleryApplicationListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current GalleryApplicationListResponse.
	PageResponse() *GalleryApplicationListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type galleryApplicationListCreateRequest func(context.Context) (*azcore.Request, error)

type galleryApplicationListHandleError func(*azcore.Response) error

type galleryApplicationListHandleResponse func(*azcore.Response) (*GalleryApplicationListResponse, error)

type galleryApplicationListAdvancePage func(context.Context, *GalleryApplicationListResponse) (*azcore.Request, error)

type galleryApplicationListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester galleryApplicationListCreateRequest
	// callback for handling response errors
	errorer galleryApplicationListHandleError
	// callback for handling the HTTP response
	responder galleryApplicationListHandleResponse
	// callback for advancing to the next page
	advancer galleryApplicationListAdvancePage
	// contains the current response
	current *GalleryApplicationListResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *galleryApplicationListPager) Err() error {
	return p.err
}

func (p *galleryApplicationListPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.GalleryApplicationList.NextLink == nil || len(*p.current.GalleryApplicationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *galleryApplicationListPager) PageResponse() *GalleryApplicationListResponse {
	return p.current
}

// GalleryApplicationVersionListPager provides iteration over GalleryApplicationVersionList pages.
type GalleryApplicationVersionListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current GalleryApplicationVersionListResponse.
	PageResponse() *GalleryApplicationVersionListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type galleryApplicationVersionListCreateRequest func(context.Context) (*azcore.Request, error)

type galleryApplicationVersionListHandleError func(*azcore.Response) error

type galleryApplicationVersionListHandleResponse func(*azcore.Response) (*GalleryApplicationVersionListResponse, error)

type galleryApplicationVersionListAdvancePage func(context.Context, *GalleryApplicationVersionListResponse) (*azcore.Request, error)

type galleryApplicationVersionListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester galleryApplicationVersionListCreateRequest
	// callback for handling response errors
	errorer galleryApplicationVersionListHandleError
	// callback for handling the HTTP response
	responder galleryApplicationVersionListHandleResponse
	// callback for advancing to the next page
	advancer galleryApplicationVersionListAdvancePage
	// contains the current response
	current *GalleryApplicationVersionListResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *galleryApplicationVersionListPager) Err() error {
	return p.err
}

func (p *galleryApplicationVersionListPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.GalleryApplicationVersionList.NextLink == nil || len(*p.current.GalleryApplicationVersionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *galleryApplicationVersionListPager) PageResponse() *GalleryApplicationVersionListResponse {
	return p.current
}

// GalleryImageListPager provides iteration over GalleryImageList pages.
type GalleryImageListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current GalleryImageListResponse.
	PageResponse() *GalleryImageListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type galleryImageListCreateRequest func(context.Context) (*azcore.Request, error)

type galleryImageListHandleError func(*azcore.Response) error

type galleryImageListHandleResponse func(*azcore.Response) (*GalleryImageListResponse, error)

type galleryImageListAdvancePage func(context.Context, *GalleryImageListResponse) (*azcore.Request, error)

type galleryImageListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester galleryImageListCreateRequest
	// callback for handling response errors
	errorer galleryImageListHandleError
	// callback for handling the HTTP response
	responder galleryImageListHandleResponse
	// callback for advancing to the next page
	advancer galleryImageListAdvancePage
	// contains the current response
	current *GalleryImageListResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *galleryImageListPager) Err() error {
	return p.err
}

func (p *galleryImageListPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.GalleryImageList.NextLink == nil || len(*p.current.GalleryImageList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *galleryImageListPager) PageResponse() *GalleryImageListResponse {
	return p.current
}

// GalleryImageVersionListPager provides iteration over GalleryImageVersionList pages.
type GalleryImageVersionListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current GalleryImageVersionListResponse.
	PageResponse() *GalleryImageVersionListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type galleryImageVersionListCreateRequest func(context.Context) (*azcore.Request, error)

type galleryImageVersionListHandleError func(*azcore.Response) error

type galleryImageVersionListHandleResponse func(*azcore.Response) (*GalleryImageVersionListResponse, error)

type galleryImageVersionListAdvancePage func(context.Context, *GalleryImageVersionListResponse) (*azcore.Request, error)

type galleryImageVersionListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester galleryImageVersionListCreateRequest
	// callback for handling response errors
	errorer galleryImageVersionListHandleError
	// callback for handling the HTTP response
	responder galleryImageVersionListHandleResponse
	// callback for advancing to the next page
	advancer galleryImageVersionListAdvancePage
	// contains the current response
	current *GalleryImageVersionListResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *galleryImageVersionListPager) Err() error {
	return p.err
}

func (p *galleryImageVersionListPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.GalleryImageVersionList.NextLink == nil || len(*p.current.GalleryImageVersionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *galleryImageVersionListPager) PageResponse() *GalleryImageVersionListResponse {
	return p.current
}

// GalleryListPager provides iteration over GalleryList pages.
type GalleryListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current GalleryListResponse.
	PageResponse() *GalleryListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type galleryListCreateRequest func(context.Context) (*azcore.Request, error)

type galleryListHandleError func(*azcore.Response) error

type galleryListHandleResponse func(*azcore.Response) (*GalleryListResponse, error)

type galleryListAdvancePage func(context.Context, *GalleryListResponse) (*azcore.Request, error)

type galleryListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester galleryListCreateRequest
	// callback for handling response errors
	errorer galleryListHandleError
	// callback for handling the HTTP response
	responder galleryListHandleResponse
	// callback for advancing to the next page
	advancer galleryListAdvancePage
	// contains the current response
	current *GalleryListResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *galleryListPager) Err() error {
	return p.err
}

func (p *galleryListPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.GalleryList.NextLink == nil || len(*p.current.GalleryList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *galleryListPager) PageResponse() *GalleryListResponse {
	return p.current
}

// ImageListResultPager provides iteration over ImageListResult pages.
type ImageListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ImageListResultResponse.
	PageResponse() *ImageListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type imageListResultCreateRequest func(context.Context) (*azcore.Request, error)

type imageListResultHandleError func(*azcore.Response) error

type imageListResultHandleResponse func(*azcore.Response) (*ImageListResultResponse, error)

type imageListResultAdvancePage func(context.Context, *ImageListResultResponse) (*azcore.Request, error)

type imageListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester imageListResultCreateRequest
	// callback for handling response errors
	errorer imageListResultHandleError
	// callback for handling the HTTP response
	responder imageListResultHandleResponse
	// callback for advancing to the next page
	advancer imageListResultAdvancePage
	// contains the current response
	current *ImageListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *imageListResultPager) Err() error {
	return p.err
}

func (p *imageListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ImageListResult.NextLink == nil || len(*p.current.ImageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *imageListResultPager) PageResponse() *ImageListResultResponse {
	return p.current
}

// ListUsagesResultPager provides iteration over ListUsagesResult pages.
type ListUsagesResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListUsagesResultResponse.
	PageResponse() *ListUsagesResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listUsagesResultCreateRequest func(context.Context) (*azcore.Request, error)

type listUsagesResultHandleError func(*azcore.Response) error

type listUsagesResultHandleResponse func(*azcore.Response) (*ListUsagesResultResponse, error)

type listUsagesResultAdvancePage func(context.Context, *ListUsagesResultResponse) (*azcore.Request, error)

type listUsagesResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester listUsagesResultCreateRequest
	// callback for handling response errors
	errorer listUsagesResultHandleError
	// callback for handling the HTTP response
	responder listUsagesResultHandleResponse
	// callback for advancing to the next page
	advancer listUsagesResultAdvancePage
	// contains the current response
	current *ListUsagesResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *listUsagesResultPager) Err() error {
	return p.err
}

func (p *listUsagesResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ListUsagesResult.NextLink == nil || len(*p.current.ListUsagesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listUsagesResultPager) PageResponse() *ListUsagesResultResponse {
	return p.current
}

// ProximityPlacementGroupListResultPager provides iteration over ProximityPlacementGroupListResult pages.
type ProximityPlacementGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ProximityPlacementGroupListResultResponse.
	PageResponse() *ProximityPlacementGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type proximityPlacementGroupListResultCreateRequest func(context.Context) (*azcore.Request, error)

type proximityPlacementGroupListResultHandleError func(*azcore.Response) error

type proximityPlacementGroupListResultHandleResponse func(*azcore.Response) (*ProximityPlacementGroupListResultResponse, error)

type proximityPlacementGroupListResultAdvancePage func(context.Context, *ProximityPlacementGroupListResultResponse) (*azcore.Request, error)

type proximityPlacementGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester proximityPlacementGroupListResultCreateRequest
	// callback for handling response errors
	errorer proximityPlacementGroupListResultHandleError
	// callback for handling the HTTP response
	responder proximityPlacementGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer proximityPlacementGroupListResultAdvancePage
	// contains the current response
	current *ProximityPlacementGroupListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *proximityPlacementGroupListResultPager) Err() error {
	return p.err
}

func (p *proximityPlacementGroupListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ProximityPlacementGroupListResult.NextLink == nil || len(*p.current.ProximityPlacementGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *proximityPlacementGroupListResultPager) PageResponse() *ProximityPlacementGroupListResultResponse {
	return p.current
}

// ResourceSKUsResultPager provides iteration over ResourceSKUsResult pages.
type ResourceSKUsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ResourceSKUsResultResponse.
	PageResponse() *ResourceSKUsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type resourceSkUsResultCreateRequest func(context.Context) (*azcore.Request, error)

type resourceSkUsResultHandleError func(*azcore.Response) error

type resourceSkUsResultHandleResponse func(*azcore.Response) (*ResourceSKUsResultResponse, error)

type resourceSkUsResultAdvancePage func(context.Context, *ResourceSKUsResultResponse) (*azcore.Request, error)

type resourceSkUsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester resourceSkUsResultCreateRequest
	// callback for handling response errors
	errorer resourceSkUsResultHandleError
	// callback for handling the HTTP response
	responder resourceSkUsResultHandleResponse
	// callback for advancing to the next page
	advancer resourceSkUsResultAdvancePage
	// contains the current response
	current *ResourceSKUsResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *resourceSkUsResultPager) Err() error {
	return p.err
}

func (p *resourceSkUsResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ResourceSKUsResult.NextLink == nil || len(*p.current.ResourceSKUsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *resourceSkUsResultPager) PageResponse() *ResourceSKUsResultResponse {
	return p.current
}

// RunCommandListResultPager provides iteration over RunCommandListResult pages.
type RunCommandListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current RunCommandListResultResponse.
	PageResponse() *RunCommandListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type runCommandListResultCreateRequest func(context.Context) (*azcore.Request, error)

type runCommandListResultHandleError func(*azcore.Response) error

type runCommandListResultHandleResponse func(*azcore.Response) (*RunCommandListResultResponse, error)

type runCommandListResultAdvancePage func(context.Context, *RunCommandListResultResponse) (*azcore.Request, error)

type runCommandListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester runCommandListResultCreateRequest
	// callback for handling response errors
	errorer runCommandListResultHandleError
	// callback for handling the HTTP response
	responder runCommandListResultHandleResponse
	// callback for advancing to the next page
	advancer runCommandListResultAdvancePage
	// contains the current response
	current *RunCommandListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *runCommandListResultPager) Err() error {
	return p.err
}

func (p *runCommandListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.RunCommandListResult.NextLink == nil || len(*p.current.RunCommandListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *runCommandListResultPager) PageResponse() *RunCommandListResultResponse {
	return p.current
}

// SSHPublicKeysGroupListResultPager provides iteration over SSHPublicKeysGroupListResult pages.
type SSHPublicKeysGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current SSHPublicKeysGroupListResultResponse.
	PageResponse() *SSHPublicKeysGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type sshPublicKeysGroupListResultCreateRequest func(context.Context) (*azcore.Request, error)

type sshPublicKeysGroupListResultHandleError func(*azcore.Response) error

type sshPublicKeysGroupListResultHandleResponse func(*azcore.Response) (*SSHPublicKeysGroupListResultResponse, error)

type sshPublicKeysGroupListResultAdvancePage func(context.Context, *SSHPublicKeysGroupListResultResponse) (*azcore.Request, error)

type sshPublicKeysGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester sshPublicKeysGroupListResultCreateRequest
	// callback for handling response errors
	errorer sshPublicKeysGroupListResultHandleError
	// callback for handling the HTTP response
	responder sshPublicKeysGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer sshPublicKeysGroupListResultAdvancePage
	// contains the current response
	current *SSHPublicKeysGroupListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *sshPublicKeysGroupListResultPager) Err() error {
	return p.err
}

func (p *sshPublicKeysGroupListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.SSHPublicKeysGroupListResult.NextLink == nil || len(*p.current.SSHPublicKeysGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *sshPublicKeysGroupListResultPager) PageResponse() *SSHPublicKeysGroupListResultResponse {
	return p.current
}

// SnapshotListPager provides iteration over SnapshotList pages.
type SnapshotListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current SnapshotListResponse.
	PageResponse() *SnapshotListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type snapshotListCreateRequest func(context.Context) (*azcore.Request, error)

type snapshotListHandleError func(*azcore.Response) error

type snapshotListHandleResponse func(*azcore.Response) (*SnapshotListResponse, error)

type snapshotListAdvancePage func(context.Context, *SnapshotListResponse) (*azcore.Request, error)

type snapshotListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester snapshotListCreateRequest
	// callback for handling response errors
	errorer snapshotListHandleError
	// callback for handling the HTTP response
	responder snapshotListHandleResponse
	// callback for advancing to the next page
	advancer snapshotListAdvancePage
	// contains the current response
	current *SnapshotListResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *snapshotListPager) Err() error {
	return p.err
}

func (p *snapshotListPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.SnapshotList.NextLink == nil || len(*p.current.SnapshotList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *snapshotListPager) PageResponse() *SnapshotListResponse {
	return p.current
}

// VirtualMachineListResultPager provides iteration over VirtualMachineListResult pages.
type VirtualMachineListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineListResultResponse.
	PageResponse() *VirtualMachineListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineListResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualMachineListResultHandleError func(*azcore.Response) error

type virtualMachineListResultHandleResponse func(*azcore.Response) (*VirtualMachineListResultResponse, error)

type virtualMachineListResultAdvancePage func(context.Context, *VirtualMachineListResultResponse) (*azcore.Request, error)

type virtualMachineListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualMachineListResultCreateRequest
	// callback for handling response errors
	errorer virtualMachineListResultHandleError
	// callback for handling the HTTP response
	responder virtualMachineListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineListResultAdvancePage
	// contains the current response
	current *VirtualMachineListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualMachineListResultPager) Err() error {
	return p.err
}

func (p *virtualMachineListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineListResultPager) PageResponse() *VirtualMachineListResultResponse {
	return p.current
}

// VirtualMachineScaleSetExtensionListResultPager provides iteration over VirtualMachineScaleSetExtensionListResult pages.
type VirtualMachineScaleSetExtensionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineScaleSetExtensionListResultResponse.
	PageResponse() *VirtualMachineScaleSetExtensionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineScaleSetExtensionListResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualMachineScaleSetExtensionListResultHandleError func(*azcore.Response) error

type virtualMachineScaleSetExtensionListResultHandleResponse func(*azcore.Response) (*VirtualMachineScaleSetExtensionListResultResponse, error)

type virtualMachineScaleSetExtensionListResultAdvancePage func(context.Context, *VirtualMachineScaleSetExtensionListResultResponse) (*azcore.Request, error)

type virtualMachineScaleSetExtensionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualMachineScaleSetExtensionListResultCreateRequest
	// callback for handling response errors
	errorer virtualMachineScaleSetExtensionListResultHandleError
	// callback for handling the HTTP response
	responder virtualMachineScaleSetExtensionListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineScaleSetExtensionListResultAdvancePage
	// contains the current response
	current *VirtualMachineScaleSetExtensionListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualMachineScaleSetExtensionListResultPager) Err() error {
	return p.err
}

func (p *virtualMachineScaleSetExtensionListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualMachineScaleSetExtensionListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetExtensionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineScaleSetExtensionListResultPager) PageResponse() *VirtualMachineScaleSetExtensionListResultResponse {
	return p.current
}

// VirtualMachineScaleSetListOSUpgradeHistoryPager provides iteration over VirtualMachineScaleSetListOSUpgradeHistory pages.
type VirtualMachineScaleSetListOSUpgradeHistoryPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineScaleSetListOSUpgradeHistoryResponse.
	PageResponse() *VirtualMachineScaleSetListOSUpgradeHistoryResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineScaleSetListOSUpgradeHistoryCreateRequest func(context.Context) (*azcore.Request, error)

type virtualMachineScaleSetListOSUpgradeHistoryHandleError func(*azcore.Response) error

type virtualMachineScaleSetListOSUpgradeHistoryHandleResponse func(*azcore.Response) (*VirtualMachineScaleSetListOSUpgradeHistoryResponse, error)

type virtualMachineScaleSetListOSUpgradeHistoryAdvancePage func(context.Context, *VirtualMachineScaleSetListOSUpgradeHistoryResponse) (*azcore.Request, error)

type virtualMachineScaleSetListOSUpgradeHistoryPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualMachineScaleSetListOSUpgradeHistoryCreateRequest
	// callback for handling response errors
	errorer virtualMachineScaleSetListOSUpgradeHistoryHandleError
	// callback for handling the HTTP response
	responder virtualMachineScaleSetListOSUpgradeHistoryHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineScaleSetListOSUpgradeHistoryAdvancePage
	// contains the current response
	current *VirtualMachineScaleSetListOSUpgradeHistoryResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualMachineScaleSetListOSUpgradeHistoryPager) Err() error {
	return p.err
}

func (p *virtualMachineScaleSetListOSUpgradeHistoryPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualMachineScaleSetListOSUpgradeHistory.NextLink == nil || len(*p.current.VirtualMachineScaleSetListOSUpgradeHistory.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineScaleSetListOSUpgradeHistoryPager) PageResponse() *VirtualMachineScaleSetListOSUpgradeHistoryResponse {
	return p.current
}

// VirtualMachineScaleSetListResultPager provides iteration over VirtualMachineScaleSetListResult pages.
type VirtualMachineScaleSetListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineScaleSetListResultResponse.
	PageResponse() *VirtualMachineScaleSetListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineScaleSetListResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualMachineScaleSetListResultHandleError func(*azcore.Response) error

type virtualMachineScaleSetListResultHandleResponse func(*azcore.Response) (*VirtualMachineScaleSetListResultResponse, error)

type virtualMachineScaleSetListResultAdvancePage func(context.Context, *VirtualMachineScaleSetListResultResponse) (*azcore.Request, error)

type virtualMachineScaleSetListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualMachineScaleSetListResultCreateRequest
	// callback for handling response errors
	errorer virtualMachineScaleSetListResultHandleError
	// callback for handling the HTTP response
	responder virtualMachineScaleSetListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineScaleSetListResultAdvancePage
	// contains the current response
	current *VirtualMachineScaleSetListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualMachineScaleSetListResultPager) Err() error {
	return p.err
}

func (p *virtualMachineScaleSetListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualMachineScaleSetListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineScaleSetListResultPager) PageResponse() *VirtualMachineScaleSetListResultResponse {
	return p.current
}

// VirtualMachineScaleSetListSKUsResultPager provides iteration over VirtualMachineScaleSetListSKUsResult pages.
type VirtualMachineScaleSetListSKUsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineScaleSetListSKUsResultResponse.
	PageResponse() *VirtualMachineScaleSetListSKUsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineScaleSetListSkUsResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualMachineScaleSetListSkUsResultHandleError func(*azcore.Response) error

type virtualMachineScaleSetListSkUsResultHandleResponse func(*azcore.Response) (*VirtualMachineScaleSetListSKUsResultResponse, error)

type virtualMachineScaleSetListSkUsResultAdvancePage func(context.Context, *VirtualMachineScaleSetListSKUsResultResponse) (*azcore.Request, error)

type virtualMachineScaleSetListSkUsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualMachineScaleSetListSkUsResultCreateRequest
	// callback for handling response errors
	errorer virtualMachineScaleSetListSkUsResultHandleError
	// callback for handling the HTTP response
	responder virtualMachineScaleSetListSkUsResultHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineScaleSetListSkUsResultAdvancePage
	// contains the current response
	current *VirtualMachineScaleSetListSKUsResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualMachineScaleSetListSkUsResultPager) Err() error {
	return p.err
}

func (p *virtualMachineScaleSetListSkUsResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualMachineScaleSetListSKUsResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListSKUsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineScaleSetListSkUsResultPager) PageResponse() *VirtualMachineScaleSetListSKUsResultResponse {
	return p.current
}

// VirtualMachineScaleSetListWithLinkResultPager provides iteration over VirtualMachineScaleSetListWithLinkResult pages.
type VirtualMachineScaleSetListWithLinkResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineScaleSetListWithLinkResultResponse.
	PageResponse() *VirtualMachineScaleSetListWithLinkResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineScaleSetListWithLinkResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualMachineScaleSetListWithLinkResultHandleError func(*azcore.Response) error

type virtualMachineScaleSetListWithLinkResultHandleResponse func(*azcore.Response) (*VirtualMachineScaleSetListWithLinkResultResponse, error)

type virtualMachineScaleSetListWithLinkResultAdvancePage func(context.Context, *VirtualMachineScaleSetListWithLinkResultResponse) (*azcore.Request, error)

type virtualMachineScaleSetListWithLinkResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualMachineScaleSetListWithLinkResultCreateRequest
	// callback for handling response errors
	errorer virtualMachineScaleSetListWithLinkResultHandleError
	// callback for handling the HTTP response
	responder virtualMachineScaleSetListWithLinkResultHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineScaleSetListWithLinkResultAdvancePage
	// contains the current response
	current *VirtualMachineScaleSetListWithLinkResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualMachineScaleSetListWithLinkResultPager) Err() error {
	return p.err
}

func (p *virtualMachineScaleSetListWithLinkResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualMachineScaleSetListWithLinkResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListWithLinkResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineScaleSetListWithLinkResultPager) PageResponse() *VirtualMachineScaleSetListWithLinkResultResponse {
	return p.current
}

// VirtualMachineScaleSetVMListResultPager provides iteration over VirtualMachineScaleSetVMListResult pages.
type VirtualMachineScaleSetVMListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualMachineScaleSetVMListResultResponse.
	PageResponse() *VirtualMachineScaleSetVMListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualMachineScaleSetVMListResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualMachineScaleSetVMListResultHandleError func(*azcore.Response) error

type virtualMachineScaleSetVMListResultHandleResponse func(*azcore.Response) (*VirtualMachineScaleSetVMListResultResponse, error)

type virtualMachineScaleSetVMListResultAdvancePage func(context.Context, *VirtualMachineScaleSetVMListResultResponse) (*azcore.Request, error)

type virtualMachineScaleSetVMListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualMachineScaleSetVMListResultCreateRequest
	// callback for handling response errors
	errorer virtualMachineScaleSetVMListResultHandleError
	// callback for handling the HTTP response
	responder virtualMachineScaleSetVMListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualMachineScaleSetVMListResultAdvancePage
	// contains the current response
	current *VirtualMachineScaleSetVMListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualMachineScaleSetVMListResultPager) Err() error {
	return p.err
}

func (p *virtualMachineScaleSetVMListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualMachineScaleSetVMListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetVMListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualMachineScaleSetVMListResultPager) PageResponse() *VirtualMachineScaleSetVMListResultResponse {
	return p.current
}
