// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azmonitor

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

// ActionClassification provides polymorphic access to related types.
type ActionClassification interface {
	GetAction() *Action
}

// Action descriptor.
type Action struct {
	// Specifies the action. Supported values - AlertingAction, LogToMetricAction
	OdataType *string `json:"odata.type,omitempty"`
}

func (a *Action) GetAction() *Action { return a }

func (a *Action) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "odata.type":
			if v != nil {
				err = json.Unmarshal(*v, &a.OdataType)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (a Action) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	a.OdataType = &discValue
	objectMap["odata.type"] = a.OdataType
	return objectMap
}

// An Azure action group.
type ActionGroup struct {
	// The list of ARM role receivers that are part of this action group. Roles are Azure RBAC roles and only built-in roles are
	// supported.
	ArmRoleReceivers *[]ArmRoleReceiver `json:"armRoleReceivers,omitempty"`

	// The list of AutomationRunbook receivers that are part of this action group.
	AutomationRunbookReceivers *[]AutomationRunbookReceiver `json:"automationRunbookReceivers,omitempty"`

	// The list of AzureAppPush receivers that are part of this action group.
	AzureAppPushReceivers *[]AzureAppPushReceiver `json:"azureAppPushReceivers,omitempty"`

	// The list of azure function receivers that are part of this action group.
	AzureFunctionReceivers *[]AzureFunctionReceiver `json:"azureFunctionReceivers,omitempty"`

	// The list of email receivers that are part of this action group.
	EmailReceivers *[]EmailReceiver `json:"emailReceivers,omitempty"`

	// Indicates whether this action group is enabled. If an action group is not enabled, then none of its receivers will receive
	// communications.
	Enabled *bool `json:"enabled,omitempty"`

	// The short name of the action group. This will be used in SMS messages.
	GroupShortName *string `json:"groupShortName,omitempty"`

	// The list of ITSM receivers that are part of this action group.
	ItsmReceivers *[]ItsmReceiver `json:"itsmReceivers,omitempty"`

	// The list of logic app receivers that are part of this action group.
	LogicAppReceivers *[]LogicAppReceiver `json:"logicAppReceivers,omitempty"`

	// The list of SMS receivers that are part of this action group.
	SmsReceivers *[]SmsReceiver `json:"smsReceivers,omitempty"`

	// The list of voice receivers that are part of this action group.
	VoiceReceivers *[]VoiceReceiver `json:"voiceReceivers,omitempty"`

	// The list of webhook receivers that are part of this action group.
	WebhookReceivers *[]WebhookReceiver `json:"webhookReceivers,omitempty"`
}

// A list of action groups.
type ActionGroupList struct {
	// Provides the link to retrieve the next set of elements.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of action groups.
	Value *[]ActionGroupResource `json:"value,omitempty"`
}

// ActionGroupListResponse is the response envelope for operations that return a ActionGroupList type.
type ActionGroupListResponse struct {
	// A list of action groups.
	ActionGroupList *ActionGroupList

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// An Azure action group for patch operations.
type ActionGroupPatch struct {
	// Indicates whether this action group is enabled. If an action group is not enabled, then none of its actions will be activated.
	Enabled *bool `json:"enabled,omitempty"`
}

// An action group object for the body of patch operations.
type ActionGroupPatchBody struct {
	// The action group settings for an update operation.
	Properties *ActionGroupPatch `json:"properties,omitempty"`

	// Resource tags
	Tags *map[string]string `json:"tags,omitempty"`
}

// An action group resource.
type ActionGroupResource struct {
	Resource
	// The action groups properties of the resource.
	Properties *ActionGroup `json:"properties,omitempty"`
}

// ActionGroupResourceResponse is the response envelope for operations that return a ActionGroupResource type.
type ActionGroupResourceResponse struct {
	// An action group resource.
	ActionGroupResource *ActionGroupResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// An Azure activity log alert.
type ActivityLogAlert struct {
	// The actions that will activate when the condition is met.
	Actions *ActivityLogAlertActionList `json:"actions,omitempty"`

	// The condition that will cause this alert to activate.
	Condition *ActivityLogAlertAllOfCondition `json:"condition,omitempty"`

	// A description of this activity log alert.
	Description *string `json:"description,omitempty"`

	// Indicates whether this activity log alert is enabled. If an activity log alert is not enabled, then none of its actions
	// will be activated.
	Enabled *bool `json:"enabled,omitempty"`

	// A list of resourceIds that will be used as prefixes. The alert will only apply to activityLogs with resourceIds that fall
	// under one of these prefixes. This list must include at least one item.
	Scopes *[]string `json:"scopes,omitempty"`
}

// A pointer to an Azure Action Group.
type ActivityLogAlertActionGroup struct {
	// The resourceId of the action group. This cannot be null or empty.
	ActionGroupID *string `json:"actionGroupId,omitempty"`

	// the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload.
	WebhookProperties *map[string]string `json:"webhookProperties,omitempty"`
}

// A list of activity log alert actions.
type ActivityLogAlertActionList struct {
	// The list of activity log alerts.
	ActionGroups *[]ActivityLogAlertActionGroup `json:"actionGroups,omitempty"`
}

// An Activity Log alert condition that is met when all its member conditions are met.
type ActivityLogAlertAllOfCondition struct {
	// The list of activity log alert conditions.
	AllOf *[]ActivityLogAlertLeafCondition `json:"allOf,omitempty"`
}

// An Activity Log alert condition that is met by comparing an activity log field and value.
type ActivityLogAlertLeafCondition struct {
	// The field value will be compared to this value (case-insensitive) to determine if the condition is met.
	Equals *string `json:"equals,omitempty"`

	// The name of the field that this condition will examine. The possible values for this field are (case-insensitive): 'resourceId',
	// 'category', 'caller', 'level', 'operationName', 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType',
	// or anything beginning with 'properties.'.
	Field *string `json:"field,omitempty"`
}

// A list of activity log alerts.
type ActivityLogAlertList struct {
	// Provides the link to retrieve the next set of elements.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of activity log alerts.
	Value *[]ActivityLogAlertResource `json:"value,omitempty"`
}

// ActivityLogAlertListResponse is the response envelope for operations that return a ActivityLogAlertList type.
type ActivityLogAlertListResponse struct {
	// A list of activity log alerts.
	ActivityLogAlertList *ActivityLogAlertList

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// An Azure activity log alert for patch operations.
type ActivityLogAlertPatch struct {
	// Indicates whether this activity log alert is enabled. If an activity log alert is not enabled, then none of its actions
	// will be activated.
	Enabled *bool `json:"enabled,omitempty"`
}

// An activity log alert object for the body of patch operations.
type ActivityLogAlertPatchBody struct {
	// The activity log alert settings for an update operation.
	Properties *ActivityLogAlertPatch `json:"properties,omitempty"`

	// Resource tags
	Tags *map[string]string `json:"tags,omitempty"`
}

// An activity log alert resource.
type ActivityLogAlertResource struct {
	Resource
	// The activity log alert properties of the resource.
	Properties *ActivityLogAlert `json:"properties,omitempty"`
}

// ActivityLogAlertResourceResponse is the response envelope for operations that return a ActivityLogAlertResource type.
type ActivityLogAlertResourceResponse struct {
	// An activity log alert resource.
	ActivityLogAlertResource *ActivityLogAlertResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ActivityLogsListOptions contains the optional parameters for the ActivityLogs.List method.
type ActivityLogsListOptions struct {
	// Used to fetch events with only the given properties.<br>The **$select** argument is a comma separated list of property
	// names to be returned. Possible values are: *authorization*, *claims*, *correlationId*, *description*, *eventDataId*, *eventName*,
	// *eventTimestamp*, *httpRequest*, *level*, *operationId*, *operationName*, *properties*, *resourceGroupName*, *resourceProviderName*,
	// *resourceId*, *status*, *submissionTimestamp*, *subStatus*, *subscriptionId*
	SelectParameter *string
}

// An alert rule.
type AlertRule struct {
	// the array of actions that are performed when the alert rule becomes active, and when an alert condition is resolved.
	Actions *[]RuleActionClassification `json:"actions,omitempty"`

	// the condition that results in the alert rule being activated.
	Condition RuleConditionClassification `json:"condition,omitempty"`

	// the description of the alert rule that will be included in the alert email.
	Description *string `json:"description,omitempty"`

	// the flag that indicates whether the alert rule is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Last time the rule was updated in ISO8601 format.
	LastUpdatedTime *time.Time `json:"lastUpdatedTime,omitempty"`

	// the name of the alert rule.
	Name *string `json:"name,omitempty"`
}

func (a *AlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "actions":
			if v != nil {
				a.Actions, err = unmarshalRuleActionClassificationArray(*v)
			}
		case "condition":
			if v != nil {
				a.Condition, err = unmarshalRuleConditionClassification(*v)
			}
		case "description":
			if v != nil {
				err = json.Unmarshal(*v, &a.Description)
			}
		case "isEnabled":
			if v != nil {
				err = json.Unmarshal(*v, &a.IsEnabled)
			}
		case "lastUpdatedTime":
			if v != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*v, &aux)
				a.LastUpdatedTime = (*time.Time)(&aux)
			}
		case "name":
			if v != nil {
				err = json.Unmarshal(*v, &a.Name)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The alert rule resource.
type AlertRuleResource struct {
	Resource
	// The alert rule properties of the resource.
	Properties *AlertRule `json:"properties,omitempty"`
}

// Represents a collection of alert rule resources.
type AlertRuleResourceCollection struct {
	// the values for the alert rule resources.
	Value *[]AlertRuleResource `json:"value,omitempty"`
}

// AlertRuleResourceCollectionResponse is the response envelope for operations that return a AlertRuleResourceCollection type.
type AlertRuleResourceCollectionResponse struct {
	// Represents a collection of alert rule resources.
	AlertRuleResourceCollection *AlertRuleResourceCollection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The alert rule object for patch operations.
type AlertRuleResourcePatch struct {
	// The properties of an alert rule.
	Properties *AlertRule `json:"properties,omitempty"`

	// Resource tags
	Tags *map[string]string `json:"tags,omitempty"`
}

// AlertRuleResourceResponse is the response envelope for operations that return a AlertRuleResource type.
type AlertRuleResourceResponse struct {
	// The alert rule resource.
	AlertRuleResource *AlertRuleResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Specify action need to be taken when rule type is Alert
type AlertingAction struct {
	Action
	// Azure action group reference.
	AznsAction *AzNsActionGroup `json:"aznsAction,omitempty"`

	// Severity of the alert
	Severity *AlertSeverity `json:"severity,omitempty"`

	// time (in minutes) for which Alerts should be throttled or suppressed.
	ThrottlingInMin *int32 `json:"throttlingInMin,omitempty"`

	// The trigger condition that results in the alert rule being.
	Trigger *TriggerCondition `json:"trigger,omitempty"`
}

func (a AlertingAction) MarshalJSON() ([]byte, error) {
	objectMap := a.Action.marshalInternal("Microsoft.WindowsAzure.Management.Monitoring.Alerts.Models.Microsoft.AppInsights.Nexus.DataContracts.Resources.ScheduledQueryRules.AlertingAction")
	if a.AznsAction != nil {
		objectMap["aznsAction"] = a.AznsAction
	}
	if a.Severity != nil {
		objectMap["severity"] = a.Severity
	}
	if a.ThrottlingInMin != nil {
		objectMap["throttlingInMin"] = a.ThrottlingInMin
	}
	if a.Trigger != nil {
		objectMap["trigger"] = a.Trigger
	}
	return json.Marshal(objectMap)
}

func (a *AlertingAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "aznsAction":
			if v != nil {
				err = json.Unmarshal(*v, &a.AznsAction)
			}
		case "severity":
			if v != nil {
				err = json.Unmarshal(*v, &a.Severity)
			}
		case "throttlingInMin":
			if v != nil {
				err = json.Unmarshal(*v, &a.ThrottlingInMin)
			}
		case "trigger":
			if v != nil {
				err = json.Unmarshal(*v, &a.Trigger)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Action)
}

// An arm role receiver.
type ArmRoleReceiver struct {
	// The name of the arm role receiver. Names must be unique across all receivers within an action group.
	Name *string `json:"name,omitempty"`

	// The arm role id.
	RoleID *string `json:"roleId,omitempty"`

	// Indicates whether to use common alert schema.
	UseCommonAlertSchema *bool `json:"useCommonAlertSchema,omitempty"`
}

// The Azure Automation Runbook notification receiver.
type AutomationRunbookReceiver struct {
	// The Azure automation account Id which holds this runbook and authenticate to Azure resource.
	AutomationAccountID *string `json:"automationAccountId,omitempty"`

	// Indicates whether this instance is global runbook.
	IsGlobalRunbook *bool `json:"isGlobalRunbook,omitempty"`

	// Indicates name of the webhook.
	Name *string `json:"name,omitempty"`

	// The name for this runbook.
	RunbookName *string `json:"runbookName,omitempty"`

	// The URI where webhooks should be sent.
	ServiceURI *string `json:"serviceUri,omitempty"`

	// Indicates whether to use common alert schema.
	UseCommonAlertSchema *bool `json:"useCommonAlertSchema,omitempty"`

	// The resource id for webhook linked to this runbook.
	WebhookResourceID *string `json:"webhookResourceId,omitempty"`
}

// Autoscale notification.
type AutoscaleNotification struct {
	// the email notification.
	Email *EmailNotification `json:"email,omitempty"`

	// the operation associated with the notification and its value must be "scale"
	Operation *string `json:"operation,omitempty"`

	// the collection of webhook notifications.
	Webhooks *[]WebhookNotification `json:"webhooks,omitempty"`
}

// Autoscale profile.
type AutoscaleProfile struct {
	// the number of instances that can be used during this profile.
	Capacity *ScaleCapacity `json:"capacity,omitempty"`

	// the specific date-time for the profile. This element is not used if the Recurrence element is used.
	FixedDate *TimeWindow `json:"fixedDate,omitempty"`

	// the name of the profile.
	Name *string `json:"name,omitempty"`

	// the repeating times at which this profile begins. This element is not used if the FixedDate element is used.
	Recurrence *Recurrence `json:"recurrence,omitempty"`

	// the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules can be specified.
	Rules *[]ScaleRule `json:"rules,omitempty"`
}

// A setting that contains all of the configuration for the automatic scaling of a resource.
type AutoscaleSetting struct {
	// the enabled flag. Specifies whether automatic scaling is enabled for the resource. The default value is 'true'.
	Enabled *bool `json:"enabled,omitempty"`

	// the name of the autoscale setting.
	Name *string `json:"name,omitempty"`

	// the collection of notifications.
	Notifications *[]AutoscaleNotification `json:"notifications,omitempty"`

	// the collection of automatic scaling profiles that specify different scaling parameters for different time periods. A maximum
	// of 20 profiles can be specified.
	Profiles *[]AutoscaleProfile `json:"profiles,omitempty"`

	// the resource identifier of the resource that the autoscale setting should be added to.
	TargetResourceURI *string `json:"targetResourceUri,omitempty"`
}

// The autoscale setting resource.
type AutoscaleSettingResource struct {
	Resource
	// The autoscale setting of the resource.
	Properties *AutoscaleSetting `json:"properties,omitempty"`
}

// Represents a collection of autoscale setting resources.
type AutoscaleSettingResourceCollection struct {
	// URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// the values for the autoscale setting resources.
	Value *[]AutoscaleSettingResource `json:"value,omitempty"`
}

// AutoscaleSettingResourceCollectionResponse is the response envelope for operations that return a AutoscaleSettingResourceCollection
// type.
type AutoscaleSettingResourceCollectionResponse struct {
	// Represents a collection of autoscale setting resources.
	AutoscaleSettingResourceCollection *AutoscaleSettingResourceCollection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The autoscale setting object for patch operations.
type AutoscaleSettingResourcePatch struct {
	// The autoscale setting properties of the update operation.
	Properties *AutoscaleSetting `json:"properties,omitempty"`

	// Resource tags
	Tags *map[string]string `json:"tags,omitempty"`
}

// AutoscaleSettingResourceResponse is the response envelope for operations that return a AutoscaleSettingResource type.
type AutoscaleSettingResourceResponse struct {
	// The autoscale setting resource.
	AutoscaleSettingResource *AutoscaleSettingResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Azure action group
type AzNsActionGroup struct {
	// Azure Action Group reference.
	ActionGroup *[]string `json:"actionGroup,omitempty"`

	// Custom payload to be sent for all webhook URI in Azure action group
	CustomWebhookPayload *string `json:"customWebhookPayload,omitempty"`

	// Custom subject override for all email ids in Azure action group
	EmailSubject *string `json:"emailSubject,omitempty"`
}

// The Azure mobile App push notification receiver.
type AzureAppPushReceiver struct {
	// The email address registered for the Azure mobile app.
	EmailAddress *string `json:"emailAddress,omitempty"`

	// The name of the Azure mobile app push receiver. Names must be unique across all receivers within an action group.
	Name *string `json:"name,omitempty"`
}

// An azure function receiver.
type AzureFunctionReceiver struct {
	// The azure resource id of the function app.
	FunctionAppResourceID *string `json:"functionAppResourceId,omitempty"`

	// The function name in the function app.
	FunctionName *string `json:"functionName,omitempty"`

	// The http trigger url where http request sent to.
	HTTPTriggerURL *string `json:"httpTriggerUrl,omitempty"`

	// The name of the azure function receiver. Names must be unique across all receivers within an action group.
	Name *string `json:"name,omitempty"`

	// Indicates whether to use common alert schema.
	UseCommonAlertSchema *bool `json:"useCommonAlertSchema,omitempty"`
}

// The baseline values for a single sensitivity value.
type Baseline struct {
	// The high thresholds of the baseline.
	HighThresholds *[]float64 `json:"highThresholds,omitempty"`

	// The low thresholds of the baseline.
	LowThresholds *[]float64 `json:"lowThresholds,omitempty"`

	// the sensitivity of the baseline.
	Sensitivity *Sensitivity `json:"sensitivity,omitempty"`
}

// Represents a baseline metadata value.
type BaselineMetadata struct {
	// Name of the baseline metadata.
	Name *string `json:"name,omitempty"`

	// Value of the baseline metadata.
	Value *string `json:"value,omitempty"`
}

// Represents a baseline metadata value.
type BaselineMetadataValue struct {
	// the name of the metadata.
	Name *LocalizableString `json:"name,omitempty"`

	// the value of the metadata.
	Value *string `json:"value,omitempty"`
}

// The baseline properties class.
type BaselineProperties struct {
	// The aggregation type of the metric.
	Aggregation *string `json:"aggregation,omitempty"`

	// the baseline values for each sensitivity.
	Baseline *[]Baseline `json:"baseline,omitempty"`

	// The interval (window size) for which the metric data was returned in. This may be adjusted in the future and returned back
	// from what was originally requested. This is not present if a metadata request was made.
	Interval *time.Duration `json:"interval,omitempty"`

	// the baseline metadata values.
	Metadata *[]BaselineMetadataValue `json:"metadata,omitempty"`

	// The timespan for which the data was retrieved. Its value consists of two datetimes concatenated, separated by '/'. This
	// may be adjusted in the future and returned back from what was originally requested.
	Timespan *string `json:"timespan,omitempty"`

	// the array of timestamps of the baselines.
	Timestamps *[]time.Time `json:"timestamps,omitempty"`
}

// The response to a baseline query.
type BaselineResponse struct {
	// the metric baseline Id.
	ID *string `json:"id,omitempty"`

	// the name and the display name of the metric, i.e. it is localizable string.
	Name *LocalizableString `json:"name,omitempty"`

	// the properties of the baseline.
	Properties *BaselineProperties `json:"properties,omitempty"`

	// the resource type of the baseline resource.
	Type *string `json:"type,omitempty"`
}

// BaselineResponseResponse is the response envelope for operations that return a BaselineResponse type.
type BaselineResponseResponse struct {
	// The response to a baseline query.
	BaselineResponse *BaselineResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BaselinesListOptions contains the optional parameters for the Baselines.List method.
type BaselinesListOptions struct {
	// The list of aggregation types (comma separated) to retrieve.
	Aggregation *string
	// The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains metadata A, B and C.<br>-
	// Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’ or B eq ‘b2’ and C eq ‘*’**<br>-
	// Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This is invalid because the logical
	// or operator cannot separate two different metadata names.<br>- Return all time series where A = a1, B = b1 and C = c1:<br>**$filter=A
	// eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A = a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and
	// C eq ‘*’**.
	Filter *string
	// The interval (i.e. timegrain) of the query.
	Interval *time.Duration
	// The names of the metrics (comma separated) to retrieve.
	Metricnames *string
	// Metric namespace to query metric definitions for.
	Metricnamespace *string
	// Allows retrieving only metadata of the baseline. On data request all information is retrieved.
	ResultType *ResultType
	// The list of sensitivities (comma separated) to retrieve.
	Sensitivities *string
	// The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.
	Timespan *string
}

// The response to a calculate baseline call.
type CalculateBaselineResponse struct {
	// the baseline values for each sensitivity.
	Baseline *[]Baseline `json:"baseline,omitempty"`

	// the array of timestamps of the baselines.
	Timestamps *[]time.Time `json:"timestamps,omitempty"`

	// the resource type of the baseline resource.
	Type *string `json:"type,omitempty"`
}

// CalculateBaselineResponseResponse is the response envelope for operations that return a CalculateBaselineResponse type.
type CalculateBaselineResponseResponse struct {
	// The response to a calculate baseline call.
	CalculateBaselineResponse *CalculateBaselineResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Specifies the criteria for converting log to metric.
type Criteria struct {
	// List of Dimensions for creating metric
	Dimensions *[]Dimension `json:"dimensions,omitempty"`

	// Name of the metric
	MetricName *string `json:"metricName,omitempty"`
}

// Information about a container with data for a given resource.
type DataContainer struct {
	// Log Analytics workspace information.
	Workspace *WorkspaceInfo `json:"workspace,omitempty"`
}

// The diagnostic settings.
type DiagnosticSettings struct {
	// The resource Id for the event hub authorization rule.
	EventHubAuthorizationRuleID *string `json:"eventHubAuthorizationRuleId,omitempty"`

	// The name of the event hub. If none is specified, the default event hub will be selected.
	EventHubName *string `json:"eventHubName,omitempty"`

	// A string indicating whether the export to Log Analytics should use the default destination type, i.e. AzureDiagnostics,
	// or use a destination type constructed as follows: <normalized service identity>_<normalized category name>. Possible values
	// are: Dedicated and null (null is default.)
	LogAnalyticsDestinationType *string `json:"logAnalyticsDestinationType,omitempty"`

	// The list of logs settings.
	Logs *[]LogSettings `json:"logs,omitempty"`

	// The list of metric settings.
	Metrics *[]MetricSettings `json:"metrics,omitempty"`

	// The service bus rule Id of the diagnostic setting. This is here to maintain backwards compatibility.
	ServiceBusRuleID *string `json:"serviceBusRuleId,omitempty"`

	// The resource ID of the storage account to which you would like to send Diagnostic Logs.
	StorageAccountID *string `json:"storageAccountId,omitempty"`

	// The full ARM resource ID of the Log Analytics workspace to which you would like to send Diagnostic Logs. Example: /subscriptions/4b9e8510-67ab-4e9a-95a9-e2f1e570ea9c/resourceGroups/insights-integration/providers/Microsoft.OperationalInsights/workspaces/viruela2
	WorkspaceID *string `json:"workspaceId,omitempty"`
}

// The diagnostic settings Category.
type DiagnosticSettingsCategory struct {
	// The type of the diagnostic settings category.
	CategoryType *CategoryType `json:"categoryType,omitempty"`
}

// The diagnostic settings category resource.
type DiagnosticSettingsCategoryResource struct {
	ProxyOnlyResource
	// The properties of a Diagnostic Settings Category.
	Properties *DiagnosticSettingsCategory `json:"properties,omitempty"`
}

// Represents a collection of diagnostic setting category resources.
type DiagnosticSettingsCategoryResourceCollection struct {
	// The collection of diagnostic settings category resources.
	Value *[]DiagnosticSettingsCategoryResource `json:"value,omitempty"`
}

// DiagnosticSettingsCategoryResourceCollectionResponse is the response envelope for operations that return a DiagnosticSettingsCategoryResourceCollection
// type.
type DiagnosticSettingsCategoryResourceCollectionResponse struct {
	// Represents a collection of diagnostic setting category resources.
	DiagnosticSettingsCategoryResourceCollection *DiagnosticSettingsCategoryResourceCollection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiagnosticSettingsCategoryResourceResponse is the response envelope for operations that return a DiagnosticSettingsCategoryResource
// type.
type DiagnosticSettingsCategoryResourceResponse struct {
	// The diagnostic settings category resource.
	DiagnosticSettingsCategoryResource *DiagnosticSettingsCategoryResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The diagnostic setting resource.
type DiagnosticSettingsResource struct {
	ProxyOnlyResource
	// Properties of a Diagnostic Settings Resource.
	Properties *DiagnosticSettings `json:"properties,omitempty"`
}

// Represents a collection of alert rule resources.
type DiagnosticSettingsResourceCollection struct {
	// The collection of diagnostic settings resources;.
	Value *[]DiagnosticSettingsResource `json:"value,omitempty"`
}

// DiagnosticSettingsResourceCollectionResponse is the response envelope for operations that return a DiagnosticSettingsResourceCollection
// type.
type DiagnosticSettingsResourceCollectionResponse struct {
	// Represents a collection of alert rule resources.
	DiagnosticSettingsResourceCollection *DiagnosticSettingsResourceCollection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiagnosticSettingsResourceResponse is the response envelope for operations that return a DiagnosticSettingsResource type.
type DiagnosticSettingsResourceResponse struct {
	// The diagnostic setting resource.
	DiagnosticSettingsResource *DiagnosticSettingsResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Specifies the criteria for converting log to metric.
type Dimension struct {
	// Name of the dimension
	Name *string `json:"name,omitempty"`

	// Operator for dimension values
	Operator *Operator `json:"operator,omitempty"`

	// List of dimension values
	Values *[]string `json:"values,omitempty"`
}

// Criterion for dynamic threshold.
type DynamicMetricCriteria struct {
	MultiMetricCriteria
	// The extent of deviation required to trigger an alert. This will affect how tight the threshold is to the metric series
	// pattern.
	AlertSensitivity *DynamicThresholdSensitivity `json:"alertSensitivity,omitempty"`

	// The minimum number of violations required within the selected lookback time window required to raise an alert.
	FailingPeriods *DynamicThresholdFailingPeriods `json:"failingPeriods,omitempty"`

	// Use this option to set the date from which to start learning the metric historical data and calculate the dynamic thresholds
	// (in ISO8601 format)
	IgnoreDataBefore *time.Time `json:"ignoreDataBefore,omitempty"`

	// The operator used to compare the metric value against the threshold.
	Operator *DynamicThresholdOperator `json:"operator,omitempty"`
}

func (d DynamicMetricCriteria) MarshalJSON() ([]byte, error) {
	objectMap := d.MultiMetricCriteria.marshalInternal(CriterionTypeDynamicThresholdCriterion)
	if d.AlertSensitivity != nil {
		objectMap["alertSensitivity"] = d.AlertSensitivity
	}
	if d.FailingPeriods != nil {
		objectMap["failingPeriods"] = d.FailingPeriods
	}
	if d.IgnoreDataBefore != nil {
		objectMap["ignoreDataBefore"] = (*timeRFC3339)(d.IgnoreDataBefore)
	}
	if d.Operator != nil {
		objectMap["operator"] = d.Operator
	}
	return json.Marshal(objectMap)
}

func (d *DynamicMetricCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "alertSensitivity":
			if v != nil {
				err = json.Unmarshal(*v, &d.AlertSensitivity)
			}
		case "failingPeriods":
			if v != nil {
				err = json.Unmarshal(*v, &d.FailingPeriods)
			}
		case "ignoreDataBefore":
			if v != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*v, &aux)
				d.IgnoreDataBefore = (*time.Time)(&aux)
			}
		case "operator":
			if v != nil {
				err = json.Unmarshal(*v, &d.Operator)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.MultiMetricCriteria)
}

// The minimum number of violations required within the selected lookback time window required to raise an alert.
type DynamicThresholdFailingPeriods struct {
	// The number of violations to trigger an alert. Should be smaller or equal to numberOfEvaluationPeriods.
	MinFailingPeriodsToAlert *float32 `json:"minFailingPeriodsToAlert,omitempty"`

	// The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (windowSize)
	// and the selected number of aggregated points.
	NumberOfEvaluationPeriods *float32 `json:"numberOfEvaluationPeriods,omitempty"`
}

// Email notification of an autoscale event.
type EmailNotification struct {
	// the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
	CustomEmails *[]string `json:"customEmails,omitempty"`

	// a value indicating whether to send email to subscription administrator.
	SendToSubscriptionAdministrator *bool `json:"sendToSubscriptionAdministrator,omitempty"`

	// a value indicating whether to send email to subscription co-administrators.
	SendToSubscriptionCoAdministrators *bool `json:"sendToSubscriptionCoAdministrators,omitempty"`
}

// An email receiver.
type EmailReceiver struct {
	// The email address of this receiver.
	EmailAddress *string `json:"emailAddress,omitempty"`

	// The name of the email receiver. Names must be unique across all receivers within an action group.
	Name *string `json:"name,omitempty"`

	// The receiver status of the e-mail.
	Status *ReceiverStatus `json:"status,omitempty"`

	// Indicates whether to use common alert schema.
	UseCommonAlertSchema *bool `json:"useCommonAlertSchema,omitempty"`
}

// Describes a receiver that should be resubscribed.
type EnableRequest struct {
	// The name of the receiver to resubscribe.
	ReceiverName *string `json:"receiverName,omitempty"`
}

// Error details.
type Error struct {
	// Error code identifying the specific error.
	Code *string `json:"code,omitempty"`

	// Error message in the caller's locale.
	Message *string `json:"message,omitempty"`
}

// Describes the format of Error response.
type ErrorResponse struct {
	// Error code
	Code *string `json:"code,omitempty"`

	// Error message indicating why the operation failed.
	Message *string `json:"message,omitempty"`
}

func (e ErrorResponse) Error() string {
	msg := ""
	if e.Code != nil {
		msg += fmt.Sprintf("Code: %v\n", *e.Code)
	}
	if e.Message != nil {
		msg += fmt.Sprintf("Message: %v\n", *e.Message)
	}
	if msg == "" {
		msg = "missing error info"
	}
	return msg
}

// A collection of event categories. Currently possible values are: Administrative, Security, ServiceHealth, Alert, Recommendation,
// Policy.
type EventCategoryCollection struct {
	// the list that includes the Azure event categories.
	Value *[]LocalizableString `json:"value,omitempty"`
}

// EventCategoryCollectionResponse is the response envelope for operations that return a EventCategoryCollection type.
type EventCategoryCollectionResponse struct {
	// A collection of event categories. Currently possible values are: Administrative, Security, ServiceHealth, Alert, Recommendation,
	// Policy.
	EventCategoryCollection *EventCategoryCollection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The Azure event log entries are of type EventData
type EventData struct {
	// The sender authorization information.
	Authorization *SenderAuthorization `json:"authorization,omitempty"`

	// the email address of the user who has performed the operation, the UPN claim or SPN claim based on availability.
	Caller *string `json:"caller,omitempty"`

	// the event category.
	Category *LocalizableString `json:"category,omitempty"`

	// key value pairs to identify ARM permissions.
	Claims *map[string]string `json:"claims,omitempty"`

	// the correlation Id, usually a GUID in the string format. The correlation Id is shared among the events that belong to the
	// same uber operation.
	CorrelationID *string `json:"correlationId,omitempty"`

	// the description of the event.
	Description *string `json:"description,omitempty"`

	// the event data Id. This is a unique identifier for an event.
	EventDataID *string `json:"eventDataId,omitempty"`

	// the event name. This value should not be confused with OperationName. For practical purposes, OperationName might be more
	// appealing to end users.
	EventName *LocalizableString `json:"eventName,omitempty"`

	// the timestamp of when the event was generated by the Azure service processing the request corresponding the event. It in
	// ISO 8601 format.
	EventTimestamp *time.Time `json:"eventTimestamp,omitempty"`

	// the HTTP request info. Usually includes the 'clientRequestId', 'clientIpAddress' (IP address of the user who initiated
	// the event) and 'method' (HTTP method e.g. PUT).
	HTTPRequest *HTTPRequestInfo `json:"httpRequest,omitempty"`

	// the Id of this event as required by ARM for RBAC. It contains the EventDataID and a timestamp information.
	ID *string `json:"id,omitempty"`

	// the event level
	Level *EventLevel `json:"level,omitempty"`

	// It is usually a GUID shared among the events corresponding to single operation. This value should not be confused with
	// EventName.
	OperationID *string `json:"operationId,omitempty"`

	// the operation name.
	OperationName *LocalizableString `json:"operationName,omitempty"`

	// the set of <Key, Value> pairs (usually a Dictionary<String, String>) that includes details about the event.
	Properties *map[string]string `json:"properties,omitempty"`

	// the resource group name of the impacted resource.
	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	// the resource uri that uniquely identifies the resource that caused this event.
	ResourceID *string `json:"resourceId,omitempty"`

	// the resource provider name of the impacted resource.
	ResourceProviderName *LocalizableString `json:"resourceProviderName,omitempty"`

	// the resource type
	ResourceType *LocalizableString `json:"resourceType,omitempty"`

	// a string describing the status of the operation. Some typical values are: Started, In progress, Succeeded, Failed, Resolved.
	Status *LocalizableString `json:"status,omitempty"`

	// the event sub status. Most of the time, when included, this captures the HTTP status code of the REST call. Common values
	// are: OK (HTTP Status Code: 200), Created (HTTP Status Code: 201), Accepted (HTTP Status Code: 202), No Content (HTTP Status
	// Code: 204), Bad Request(HTTP Status Code: 400), Not Found (HTTP Status Code: 404), Conflict (HTTP Status Code: 409), Internal
	// Server Error (HTTP Status Code: 500), Service Unavailable (HTTP Status Code:503), Gateway Timeout (HTTP Status Code: 504)
	SubStatus *LocalizableString `json:"subStatus,omitempty"`

	// the timestamp of when the event became available for querying via this API. It is in ISO 8601 format. This value should
	// not be confused eventTimestamp. As there might be a delay between the occurrence time of the event, and the time that the
	// event is submitted to the Azure logging infrastructure.
	SubmissionTimestamp *time.Time `json:"submissionTimestamp,omitempty"`

	// the Azure subscription Id usually a GUID.
	SubscriptionID *string `json:"subscriptionId,omitempty"`

	// the Azure tenant Id
	TenantID *string `json:"tenantId,omitempty"`
}

func (e EventData) MarshalJSON() ([]byte, error) {
	type alias EventData
	aux := &struct {
		*alias
		EventTimestamp      *timeRFC3339 `json:"eventTimestamp"`
		SubmissionTimestamp *timeRFC3339 `json:"submissionTimestamp"`
	}{
		alias:               (*alias)(&e),
		EventTimestamp:      (*timeRFC3339)(e.EventTimestamp),
		SubmissionTimestamp: (*timeRFC3339)(e.SubmissionTimestamp),
	}
	return json.Marshal(aux)
}

func (e *EventData) UnmarshalJSON(data []byte) error {
	type alias EventData
	aux := &struct {
		*alias
		EventTimestamp      *timeRFC3339 `json:"eventTimestamp"`
		SubmissionTimestamp *timeRFC3339 `json:"submissionTimestamp"`
	}{
		alias: (*alias)(e),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	e.EventTimestamp = (*time.Time)(aux.EventTimestamp)
	e.SubmissionTimestamp = (*time.Time)(aux.SubmissionTimestamp)
	return nil
}

// Represents collection of events.
type EventDataCollection struct {
	// Provides the link to retrieve the next set of events.
	NextLink *string `json:"nextLink,omitempty"`

	// this list that includes the Azure audit logs.
	Value *[]EventData `json:"value,omitempty"`
}

// EventDataCollectionResponse is the response envelope for operations that return a EventDataCollection type.
type EventDataCollectionResponse struct {
	// Represents collection of events.
	EventDataCollection *EventDataCollection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The Http request info.
type HTTPRequestInfo struct {
	// the client Ip Address
	ClientIPAddress *string `json:"clientIpAddress,omitempty"`

	// the client request id.
	ClientRequestID *string `json:"clientRequestId,omitempty"`

	// the Http request method.
	Method *string `json:"method,omitempty"`

	// the Uri.
	URI *string `json:"uri,omitempty"`
}

// An alert incident indicates the activation status of an alert rule.
type Incident struct {
	// The time at which the incident was activated in ISO8601 format.
	ActivatedTime *time.Time `json:"activatedTime,omitempty"`

	// A boolean to indicate whether the incident is active or resolved.
	IsActive *bool `json:"isActive,omitempty"`

	// Incident name.
	Name *string `json:"name,omitempty"`

	// The time at which the incident was resolved in ISO8601 format. If null, it means the incident is still active.
	ResolvedTime *time.Time `json:"resolvedTime,omitempty"`

	// Rule name that is associated with the incident.
	RuleName *string `json:"ruleName,omitempty"`
}

func (i Incident) MarshalJSON() ([]byte, error) {
	type alias Incident
	aux := &struct {
		*alias
		ActivatedTime *timeRFC3339 `json:"activatedTime"`
		ResolvedTime  *timeRFC3339 `json:"resolvedTime"`
	}{
		alias:         (*alias)(&i),
		ActivatedTime: (*timeRFC3339)(i.ActivatedTime),
		ResolvedTime:  (*timeRFC3339)(i.ResolvedTime),
	}
	return json.Marshal(aux)
}

func (i *Incident) UnmarshalJSON(data []byte) error {
	type alias Incident
	aux := &struct {
		*alias
		ActivatedTime *timeRFC3339 `json:"activatedTime"`
		ResolvedTime  *timeRFC3339 `json:"resolvedTime"`
	}{
		alias: (*alias)(i),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	i.ActivatedTime = (*time.Time)(aux.ActivatedTime)
	i.ResolvedTime = (*time.Time)(aux.ResolvedTime)
	return nil
}

// The List incidents operation response.
type IncidentListResult struct {
	// the incident collection.
	Value *[]Incident `json:"value,omitempty"`
}

// IncidentListResultResponse is the response envelope for operations that return a IncidentListResult type.
type IncidentListResultResponse struct {
	// The List incidents operation response.
	IncidentListResult *IncidentListResult

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IncidentResponse is the response envelope for operations that return a Incident type.
type IncidentResponse struct {
	// An alert incident indicates the activation status of an alert rule.
	Incident *Incident

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// An Itsm receiver.
type ItsmReceiver struct {
	// Unique identification of ITSM connection among multiple defined in above workspace.
	ConnectionID *string `json:"connectionId,omitempty"`

	// The name of the Itsm receiver. Names must be unique across all receivers within an action group.
	Name *string `json:"name,omitempty"`

	// Region in which workspace resides. Supported values:'centralindia','japaneast','southeastasia','australiasoutheast','uksouth','westcentralus','canadacentral','eastus','westeurope'
	Region *string `json:"region,omitempty"`

	// JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
	TicketConfiguration *string `json:"ticketConfiguration,omitempty"`

	// OMS LA instance identifier.
	WorkspaceID *string `json:"workspaceId,omitempty"`
}

// The localizable string class.
type LocalizableString struct {
	// the locale specific value.
	LocalizedValue *string `json:"localizedValue,omitempty"`

	// the invariant value.
	Value *string `json:"value,omitempty"`
}

// A rule condition based on a certain number of locations failing.
type LocationThresholdRuleCondition struct {
	RuleCondition
	// the number of locations that must fail to activate the alert.
	FailedLocationCount *int32 `json:"failedLocationCount,omitempty"`

	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified
	// then it must be between 5 minutes and 1 day.
	WindowSize *time.Duration `json:"windowSize,omitempty"`
}

func (l LocationThresholdRuleCondition) MarshalJSON() ([]byte, error) {
	objectMap := l.RuleCondition.marshalInternal("Microsoft.Azure.Management.Insights.Models.LocationThresholdRuleCondition")
	if l.FailedLocationCount != nil {
		objectMap["failedLocationCount"] = l.FailedLocationCount
	}
	if l.WindowSize != nil {
		objectMap["windowSize"] = l.WindowSize
	}
	return json.Marshal(objectMap)
}

func (l *LocationThresholdRuleCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "failedLocationCount":
			if v != nil {
				err = json.Unmarshal(*v, &l.FailedLocationCount)
			}
		case "windowSize":
			if v != nil {
				err = json.Unmarshal(*v, &l.WindowSize)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &l.RuleCondition)
}

// A log metrics trigger descriptor.
type LogMetricTrigger struct {
	// Evaluation of metric on a particular column
	MetricColumn *string `json:"metricColumn,omitempty"`

	// Metric Trigger Type - 'Consecutive' or 'Total'
	MetricTriggerType *MetricTriggerType `json:"metricTriggerType,omitempty"`

	// The threshold of the metric trigger.
	Threshold *float64 `json:"threshold,omitempty"`

	// Evaluation operation for Metric -'GreaterThan' or 'LessThan' or 'Equal'.
	ThresholdOperator *ConditionalOperator `json:"thresholdOperator,omitempty"`
}

// Represents a collection of log profiles.
type LogProfileCollection struct {
	// the values of the log profiles.
	Value *[]LogProfileResource `json:"value,omitempty"`
}

// LogProfileCollectionResponse is the response envelope for operations that return a LogProfileCollection type.
type LogProfileCollectionResponse struct {
	// Represents a collection of log profiles.
	LogProfileCollection *LogProfileCollection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The log profile properties.
type LogProfileProperties struct {
	// the categories of the logs. These categories are created as is convenient to the user. Some values are: 'Write', 'Delete',
	// and/or 'Action.'
	Categories *[]string `json:"categories,omitempty"`

	// List of regions for which Activity Log events should be stored or streamed. It is a comma separated list of valid ARM locations
	// including the 'global' location.
	Locations *[]string `json:"locations,omitempty"`

	// the retention policy for the events in the log.
	RetentionPolicy *RetentionPolicy `json:"retentionPolicy,omitempty"`

	// The service bus rule ID of the service bus namespace in which you would like to have Event Hubs created for streaming the
	// Activity Log. The rule ID is of the format: '{service bus resource ID}/authorizationrules/{key name}'.
	ServiceBusRuleID *string `json:"serviceBusRuleId,omitempty"`

	// the resource id of the storage account to which you would like to send the Activity Log.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// The log profile resource.
type LogProfileResource struct {
	Resource
	// The log profile properties of the resource.
	Properties *LogProfileProperties `json:"properties,omitempty"`
}

// The log profile resource for patch operations.
type LogProfileResourcePatch struct {
	// The log profile properties for an update operation.
	Properties *LogProfileProperties `json:"properties,omitempty"`

	// Resource tags
	Tags *map[string]string `json:"tags,omitempty"`
}

// LogProfileResourceResponse is the response envelope for operations that return a LogProfileResource type.
type LogProfileResourceResponse struct {
	// The log profile resource.
	LogProfileResource *LogProfileResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Log Search Rule Definition
type LogSearchRule struct {
	// Action needs to be taken on rule execution.
	Action ActionClassification `json:"action,omitempty"`

	// The description of the Log Search rule.
	Description *string `json:"description,omitempty"`

	// The flag which indicates whether the Log Search rule is enabled. Value should be true or false
	Enabled *Enabled `json:"enabled,omitempty"`

	// Last time the rule was updated in IS08601 format.
	LastUpdatedTime *time.Time `json:"lastUpdatedTime,omitempty"`

	// Provisioning state of the scheduled query rule
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty"`

	// Schedule (Frequency, Time Window) for rule. Required for action type - AlertingAction
	Schedule *Schedule `json:"schedule,omitempty"`

	// Data Source against which rule will Query Data
	Source *Source `json:"source,omitempty"`
}

func (l *LogSearchRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "action":
			if v != nil {
				l.Action, err = unmarshalActionClassification(*v)
			}
		case "description":
			if v != nil {
				err = json.Unmarshal(*v, &l.Description)
			}
		case "enabled":
			if v != nil {
				err = json.Unmarshal(*v, &l.Enabled)
			}
		case "lastUpdatedTime":
			if v != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*v, &aux)
				l.LastUpdatedTime = (*time.Time)(&aux)
			}
		case "provisioningState":
			if v != nil {
				err = json.Unmarshal(*v, &l.ProvisioningState)
			}
		case "schedule":
			if v != nil {
				err = json.Unmarshal(*v, &l.Schedule)
			}
		case "source":
			if v != nil {
				err = json.Unmarshal(*v, &l.Source)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Log Search Rule Definition for Patching
type LogSearchRulePatch struct {
	// The flag which indicates whether the Log Search rule is enabled. Value should be true or false
	Enabled *Enabled `json:"enabled,omitempty"`
}

// The Log Search Rule resource.
type LogSearchRuleResource struct {
	Resource
	// The rule properties of the resource.
	Properties *LogSearchRule `json:"properties,omitempty"`
}

// Represents a collection of Log Search rule resources.
type LogSearchRuleResourceCollection struct {
	// The values for the Log Search Rule resources.
	Value *[]LogSearchRuleResource `json:"value,omitempty"`
}

// LogSearchRuleResourceCollectionResponse is the response envelope for operations that return a LogSearchRuleResourceCollection
// type.
type LogSearchRuleResourceCollectionResponse struct {
	// Represents a collection of Log Search rule resources.
	LogSearchRuleResourceCollection *LogSearchRuleResourceCollection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The log search rule resource for patch operations.
type LogSearchRuleResourcePatch struct {
	// The log search rule properties of the resource.
	Properties *LogSearchRulePatch `json:"properties,omitempty"`

	// Resource tags
	Tags *map[string]string `json:"tags,omitempty"`
}

// LogSearchRuleResourceResponse is the response envelope for operations that return a LogSearchRuleResource type.
type LogSearchRuleResourceResponse struct {
	// The Log Search Rule resource.
	LogSearchRuleResource *LogSearchRuleResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Part of MultiTenantDiagnosticSettings. Specifies the settings for a particular log.
type LogSettings struct {
	// Name of a Diagnostic Log category for a resource type this setting is applied to. To obtain the list of Diagnostic Log
	// categories for a resource, first perform a GET diagnostic settings operation.
	Category *string `json:"category,omitempty"`

	// a value indicating whether this log is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// the retention policy for this log.
	RetentionPolicy *RetentionPolicy `json:"retentionPolicy,omitempty"`
}

// Specify action need to be taken when rule type is converting log to metric
type LogToMetricAction struct {
	Action
	// Criteria of Metric
	Criteria *[]Criteria `json:"criteria,omitempty"`
}

func (l LogToMetricAction) MarshalJSON() ([]byte, error) {
	objectMap := l.Action.marshalInternal("Microsoft.WindowsAzure.Management.Monitoring.Alerts.Models.Microsoft.AppInsights.Nexus.DataContracts.Resources.ScheduledQueryRules.LogToMetricAction")
	if l.Criteria != nil {
		objectMap["criteria"] = l.Criteria
	}
	return json.Marshal(objectMap)
}

func (l *LogToMetricAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "criteria":
			if v != nil {
				err = json.Unmarshal(*v, &l.Criteria)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &l.Action)
}

// A logic app receiver.
type LogicAppReceiver struct {
	// The callback url where http request sent to.
	CallbackURL *string `json:"callbackUrl,omitempty"`

	// The name of the logic app receiver. Names must be unique across all receivers within an action group.
	Name *string `json:"name,omitempty"`

	// The azure resource id of the logic app receiver.
	ResourceID *string `json:"resourceId,omitempty"`

	// Indicates whether to use common alert schema.
	UseCommonAlertSchema *bool `json:"useCommonAlertSchema,omitempty"`
}

// How the data that is collected should be combined over time.
type ManagementEventAggregationCondition struct {
	// the condition operator.
	Operator *ConditionOperator `json:"operator,omitempty"`

	// The threshold value that activates the alert.
	Threshold *float64 `json:"threshold,omitempty"`

	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified
	// then it must be between 5 minutes and 1 day.
	WindowSize *time.Duration `json:"windowSize,omitempty"`
}

// A management event rule condition.
type ManagementEventRuleCondition struct {
	RuleCondition
	// How the data that is collected should be combined over time and when the alert is activated. Note that for management event
	// alerts aggregation is optional – if it is not provided then any event will cause the alert to activate.
	Aggregation *ManagementEventAggregationCondition `json:"aggregation,omitempty"`
}

func (m ManagementEventRuleCondition) MarshalJSON() ([]byte, error) {
	objectMap := m.RuleCondition.marshalInternal("Microsoft.Azure.Management.Insights.Models.ManagementEventRuleCondition")
	if m.Aggregation != nil {
		objectMap["aggregation"] = m.Aggregation
	}
	return json.Marshal(objectMap)
}

func (m *ManagementEventRuleCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "aggregation":
			if v != nil {
				err = json.Unmarshal(*v, &m.Aggregation)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.RuleCondition)
}

// Represents a metric metadata value.
type MetadataValue struct {
	// the name of the metadata.
	Name *LocalizableString `json:"name,omitempty"`

	// the value of the metadata.
	Value *string `json:"value,omitempty"`
}

// The result data of a query.
type Metric struct {
	// the metric Id.
	ID *string `json:"id,omitempty"`

	// the name and the display name of the metric, i.e. it is localizable string.
	Name *LocalizableString `json:"name,omitempty"`

	// the time series returned when a data query is performed.
	Timeseries *[]TimeSeriesElement `json:"timeseries,omitempty"`

	// the resource type of the metric resource.
	Type *string `json:"type,omitempty"`

	// the unit of the metric.
	Unit *Unit `json:"unit,omitempty"`
}

// An alert action.
type MetricAlertAction struct {
	// the id of the action group to use.
	ActionGroupID *string `json:"actionGroupId,omitempty"`

	// The properties of a webhook object.
	WebHookProperties *map[string]string `json:"webHookProperties,omitempty"`
}

// MetricAlertCriteriaClassification provides polymorphic access to related types.
type MetricAlertCriteriaClassification interface {
	GetMetricAlertCriteria() *MetricAlertCriteria
}

// The rule criteria that defines the conditions of the alert rule.
type MetricAlertCriteria struct {
	// specifies the type of the alert criteria.
	OdataType *Odatatype `json:"odata.type,omitempty"`
}

func (m *MetricAlertCriteria) GetMetricAlertCriteria() *MetricAlertCriteria { return m }

func (m *MetricAlertCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "odata.type":
			if v != nil {
				err = json.Unmarshal(*v, &m.OdataType)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (m MetricAlertCriteria) marshalInternal(discValue Odatatype) map[string]interface{} {
	objectMap := make(map[string]interface{})
	m.OdataType = &discValue
	objectMap["odata.type"] = m.OdataType
	return objectMap
}

// Specifies the metric alert criteria for multiple resource that has multiple metric criteria.
type MetricAlertMultipleResourceMultipleMetricCriteria struct {
	MetricAlertCriteria
	// the list of multiple metric criteria for this 'all of' operation.
	AllOf *[]MultiMetricCriteriaClassification `json:"allOf,omitempty"`
}

func (m MetricAlertMultipleResourceMultipleMetricCriteria) MarshalJSON() ([]byte, error) {
	objectMap := m.MetricAlertCriteria.marshalInternal(OdatatypeMicrosoftAzureMonitorMultipleResourceMultipleMetricCriteria)
	if m.AllOf != nil {
		objectMap["allOf"] = m.AllOf
	}
	return json.Marshal(objectMap)
}

func (m *MetricAlertMultipleResourceMultipleMetricCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "allOf":
			if v != nil {
				m.AllOf, err = unmarshalMultiMetricCriteriaClassificationArray(*v)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.MetricAlertCriteria)
}

// An alert rule.
type MetricAlertProperties struct {
	// the array of actions that are performed when the alert rule becomes active, and when an alert condition is resolved.
	Actions *[]MetricAlertAction `json:"actions,omitempty"`

	// the flag that indicates whether the alert should be auto resolved or not. The default is true.
	AutoMitigate *bool `json:"autoMitigate,omitempty"`

	// defines the specific alert criteria information.
	Criteria MetricAlertCriteriaClassification `json:"criteria,omitempty"`

	// the description of the metric alert that will be included in the alert email.
	Description *string `json:"description,omitempty"`

	// the flag that indicates whether the metric alert is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// how often the metric alert is evaluated represented in ISO 8601 duration format.
	EvaluationFrequency *time.Duration `json:"evaluationFrequency,omitempty"`

	// Last time the rule was updated in ISO8601 format.
	LastUpdatedTime *time.Time `json:"lastUpdatedTime,omitempty"`

	// the list of resource id's that this metric alert is scoped to.
	Scopes *[]string `json:"scopes,omitempty"`

	// Alert severity {0, 1, 2, 3, 4}
	Severity *int32 `json:"severity,omitempty"`

	// the region of the target resource(s) on which the alert is created/updated. Mandatory for MultipleResourceMultipleMetricCriteria.
	TargetResourceRegion *string `json:"targetResourceRegion,omitempty"`

	// the resource type of the target resource(s) on which the alert is created/updated. Mandatory for MultipleResourceMultipleMetricCriteria.
	TargetResourceType *string `json:"targetResourceType,omitempty"`

	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold.
	WindowSize *time.Duration `json:"windowSize,omitempty"`
}

func (m *MetricAlertProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "actions":
			if v != nil {
				err = json.Unmarshal(*v, &m.Actions)
			}
		case "autoMitigate":
			if v != nil {
				err = json.Unmarshal(*v, &m.AutoMitigate)
			}
		case "criteria":
			if v != nil {
				m.Criteria, err = unmarshalMetricAlertCriteriaClassification(*v)
			}
		case "description":
			if v != nil {
				err = json.Unmarshal(*v, &m.Description)
			}
		case "enabled":
			if v != nil {
				err = json.Unmarshal(*v, &m.Enabled)
			}
		case "evaluationFrequency":
			if v != nil {
				err = json.Unmarshal(*v, &m.EvaluationFrequency)
			}
		case "lastUpdatedTime":
			if v != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*v, &aux)
				m.LastUpdatedTime = (*time.Time)(&aux)
			}
		case "scopes":
			if v != nil {
				err = json.Unmarshal(*v, &m.Scopes)
			}
		case "severity":
			if v != nil {
				err = json.Unmarshal(*v, &m.Severity)
			}
		case "targetResourceRegion":
			if v != nil {
				err = json.Unmarshal(*v, &m.TargetResourceRegion)
			}
		case "targetResourceType":
			if v != nil {
				err = json.Unmarshal(*v, &m.TargetResourceType)
			}
		case "windowSize":
			if v != nil {
				err = json.Unmarshal(*v, &m.WindowSize)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The metric alert resource.
type MetricAlertResource struct {
	Resource
	// The alert rule properties of the resource.
	Properties *MetricAlertProperties `json:"properties,omitempty"`
}

// Represents a collection of alert rule resources.
type MetricAlertResourceCollection struct {
	// the values for the alert rule resources.
	Value *[]MetricAlertResource `json:"value,omitempty"`
}

// MetricAlertResourceCollectionResponse is the response envelope for operations that return a MetricAlertResourceCollection
// type.
type MetricAlertResourceCollectionResponse struct {
	// Represents a collection of alert rule resources.
	MetricAlertResourceCollection *MetricAlertResourceCollection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The metric alert resource for patch operations.
type MetricAlertResourcePatch struct {
	// The alert rule properties of the resource.
	Properties *MetricAlertProperties `json:"properties,omitempty"`

	// Resource tags
	Tags *map[string]string `json:"tags,omitempty"`
}

// MetricAlertResourceResponse is the response envelope for operations that return a MetricAlertResource type.
type MetricAlertResourceResponse struct {
	// The metric alert resource.
	MetricAlertResource *MetricAlertResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Specifies the metric alert criteria for a single resource that has multiple metric criteria.
type MetricAlertSingleResourceMultipleMetricCriteria struct {
	MetricAlertCriteria
	// The list of metric criteria for this 'all of' operation.
	AllOf *[]MetricCriteria `json:"allOf,omitempty"`
}

func (m MetricAlertSingleResourceMultipleMetricCriteria) MarshalJSON() ([]byte, error) {
	objectMap := m.MetricAlertCriteria.marshalInternal(OdatatypeMicrosoftAzureMonitorSingleResourceMultipleMetricCriteria)
	if m.AllOf != nil {
		objectMap["allOf"] = m.AllOf
	}
	return json.Marshal(objectMap)
}

func (m *MetricAlertSingleResourceMultipleMetricCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "allOf":
			if v != nil {
				err = json.Unmarshal(*v, &m.AllOf)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.MetricAlertCriteria)
}

// An alert status.
type MetricAlertStatus struct {
	// The alert rule arm id.
	ID *string `json:"id,omitempty"`

	// The status name.
	Name *string `json:"name,omitempty"`

	// The alert status properties of the metric alert status.
	Properties *MetricAlertStatusProperties `json:"properties,omitempty"`

	// The extended resource type name.
	Type *string `json:"type,omitempty"`
}

// Represents a collection of alert rule resources.
type MetricAlertStatusCollection struct {
	// the values for the alert rule resources.
	Value *[]MetricAlertStatus `json:"value,omitempty"`
}

// MetricAlertStatusCollectionResponse is the response envelope for operations that return a MetricAlertStatusCollection type.
type MetricAlertStatusCollectionResponse struct {
	// Represents a collection of alert rule resources.
	MetricAlertStatusCollection *MetricAlertStatusCollection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// An alert status properties.
type MetricAlertStatusProperties struct {
	// An object describing the type of the dimensions.
	Dimensions *map[string]string `json:"dimensions,omitempty"`

	// status value
	Status *string `json:"status,omitempty"`

	// UTC time when the status was checked.
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

func (m MetricAlertStatusProperties) MarshalJSON() ([]byte, error) {
	type alias MetricAlertStatusProperties
	aux := &struct {
		*alias
		Timestamp *timeRFC3339 `json:"timestamp"`
	}{
		alias:     (*alias)(&m),
		Timestamp: (*timeRFC3339)(m.Timestamp),
	}
	return json.Marshal(aux)
}

func (m *MetricAlertStatusProperties) UnmarshalJSON(data []byte) error {
	type alias MetricAlertStatusProperties
	aux := &struct {
		*alias
		Timestamp *timeRFC3339 `json:"timestamp"`
	}{
		alias: (*alias)(m),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	m.Timestamp = (*time.Time)(aux.Timestamp)
	return nil
}

// Metric availability specifies the time grain (aggregation interval or frequency) and the retention period for that time
// grain.
type MetricAvailability struct {
	// the retention period for the metric at the specified timegrain. Expressed as a duration 'PT1M', 'P1D', etc.
	Retention *time.Duration `json:"retention,omitempty"`

	// the time grain specifies the aggregation interval for the metric. Expressed as a duration 'PT1M', 'P1D', etc.
	TimeGrain *time.Duration `json:"timeGrain,omitempty"`
}

// MetricBaselineGetOptions contains the optional parameters for the MetricBaseline.Get method.
type MetricBaselineGetOptions struct {
	// The aggregation type of the metric to retrieve the baseline for.
	Aggregation *string
	// The interval (i.e. timegrain) of the query.
	Interval *time.Duration
	// Allows retrieving only metadata of the baseline. On data request all information is retrieved.
	ResultType *ResultType
	// The list of sensitivities (comma separated) to retrieve.
	Sensitivities *string
	// The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.
	Timespan *string
}

// The response to a metric baselines query.
type MetricBaselinesProperties struct {
	// The baseline for each time series that was queried.
	Baselines *[]TimeSeriesBaseline `json:"baselines,omitempty"`

	// The interval (window size) for which the metric data was returned in. This may be adjusted in the future and returned back
	// from what was originally requested. This is not present if a metadata request was made.
	Interval *time.Duration `json:"interval,omitempty"`

	// The namespace of the metrics been queried.
	Namespace *string `json:"namespace,omitempty"`

	// The timespan for which the data was retrieved. Its value consists of two datetimes concatenated, separated by '/'. This
	// may be adjusted in the future and returned back from what was originally requested.
	Timespan *string `json:"timespan,omitempty"`
}

// A list of metric baselines.
type MetricBaselinesResponse struct {
	// The list of metric baselines.
	Value *[]SingleMetricBaseline `json:"value,omitempty"`
}

// MetricBaselinesResponseResponse is the response envelope for operations that return a MetricBaselinesResponse type.
type MetricBaselinesResponseResponse struct {
	// A list of metric baselines.
	MetricBaselinesResponse *MetricBaselinesResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Criterion to filter metrics.
type MetricCriteria struct {
	MultiMetricCriteria
	// the criteria operator.
	Operator *Operator `json:"operator,omitempty"`

	// the criteria threshold value that activates the alert.
	Threshold *float64 `json:"threshold,omitempty"`
}

func (m MetricCriteria) MarshalJSON() ([]byte, error) {
	objectMap := m.MultiMetricCriteria.marshalInternal(CriterionTypeStaticThresholdCriterion)
	if m.Operator != nil {
		objectMap["operator"] = m.Operator
	}
	if m.Threshold != nil {
		objectMap["threshold"] = m.Threshold
	}
	return json.Marshal(objectMap)
}

func (m *MetricCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "operator":
			if v != nil {
				err = json.Unmarshal(*v, &m.Operator)
			}
		case "threshold":
			if v != nil {
				err = json.Unmarshal(*v, &m.Threshold)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.MultiMetricCriteria)
}

// Metric definition class specifies the metadata for a metric.
type MetricDefinition struct {
	// the name and the display name of the dimension, i.e. it is a localizable string.
	Dimensions *[]LocalizableString `json:"dimensions,omitempty"`

	// the resource identifier of the metric definition.
	ID *string `json:"id,omitempty"`

	// Flag to indicate whether the dimension is required.
	IsDimensionRequired *bool `json:"isDimensionRequired,omitempty"`

	// the collection of what aggregation intervals are available to be queried.
	MetricAvailabilities *[]MetricAvailability `json:"metricAvailabilities,omitempty"`

	// the name and the display name of the metric, i.e. it is a localizable string.
	Name *LocalizableString `json:"name,omitempty"`

	// the namespace the metric belongs to.
	Namespace *string `json:"namespace,omitempty"`

	// the primary aggregation type value defining how to use the values for display.
	PrimaryAggregationType *AggregationType `json:"primaryAggregationType,omitempty"`

	// the resource identifier of the resource that emitted the metric.
	ResourceID *string `json:"resourceId,omitempty"`

	// the collection of what aggregation types are supported.
	SupportedAggregationTypes *[]AggregationType `json:"supportedAggregationTypes,omitempty"`

	// the unit of the metric.
	Unit *Unit `json:"unit,omitempty"`
}

// Represents collection of metric definitions.
type MetricDefinitionCollection struct {
	// the values for the metric definitions.
	Value *[]MetricDefinition `json:"value,omitempty"`
}

// MetricDefinitionCollectionResponse is the response envelope for operations that return a MetricDefinitionCollection type.
type MetricDefinitionCollectionResponse struct {
	// Represents collection of metric definitions.
	MetricDefinitionCollection *MetricDefinitionCollection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MetricDefinitionsListOptions contains the optional parameters for the MetricDefinitions.List method.
type MetricDefinitionsListOptions struct {
	// Metric namespace to query metric definitions for.
	Metricnamespace *string
}

// Specifies a metric dimension.
type MetricDimension struct {
	// Name of the dimension.
	Name *string `json:"name,omitempty"`

	// the dimension operator. Only 'Include' and 'Exclude' are supported
	Operator *string `json:"operator,omitempty"`

	// list of dimension values.
	Values *[]string `json:"values,omitempty"`
}

// Metric namespace class specifies the metadata for a metric namespace.
type MetricNamespace struct {
	// The ID of the metricNamespace.
	ID *string `json:"id,omitempty"`

	// The name of the namespace.
	Name *string `json:"name,omitempty"`

	// Properties which include the fully qualified namespace name.
	Properties *MetricNamespaceName `json:"properties,omitempty"`

	// The type of the namespace.
	Type *string `json:"type,omitempty"`
}

// Represents collection of metric namespaces.
type MetricNamespaceCollection struct {
	// The values for the metric namespaces.
	Value *[]MetricNamespace `json:"value,omitempty"`
}

// MetricNamespaceCollectionResponse is the response envelope for operations that return a MetricNamespaceCollection type.
type MetricNamespaceCollectionResponse struct {
	// Represents collection of metric namespaces.
	MetricNamespaceCollection *MetricNamespaceCollection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The fully qualified metric namespace name.
type MetricNamespaceName struct {
	// The metric namespace name.
	MetricNamespaceName *string `json:"metricNamespaceName,omitempty"`
}

// MetricNamespacesListOptions contains the optional parameters for the MetricNamespaces.List method.
type MetricNamespacesListOptions struct {
	// The ISO 8601 conform Date start time from which to query for metric namespaces.
	StartTime *string
}

// Part of MultiTenantDiagnosticSettings. Specifies the settings for a particular metric.
type MetricSettings struct {
	// Name of a Diagnostic Metric category for a resource type this setting is applied to. To obtain the list of Diagnostic metric
	// categories for a resource, first perform a GET diagnostic settings operation.
	Category *string `json:"category,omitempty"`

	// a value indicating whether this category is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// the retention policy for this category.
	RetentionPolicy *RetentionPolicy `json:"retentionPolicy,omitempty"`

	// the timegrain of the metric in ISO8601 format.
	TimeGrain *time.Duration `json:"timeGrain,omitempty"`
}

// The metric dimension name and value.
type MetricSingleDimension struct {
	// Name of the dimension.
	Name *string `json:"name,omitempty"`

	// Value of the dimension.
	Value *string `json:"value,omitempty"`
}

// The trigger that results in a scaling action.
type MetricTrigger struct {
	// the name of the metric that defines what the rule monitors.
	MetricName *string `json:"metricName,omitempty"`

	// the resource identifier of the resource the rule monitors.
	MetricResourceURI *string `json:"metricResourceUri,omitempty"`

	// the operator that is used to compare the metric data and the threshold.
	Operator *ComparisonOperationType `json:"operator,omitempty"`

	// the metric statistic type. How the metrics from multiple instances are combined.
	Statistic *MetricStatisticType `json:"statistic,omitempty"`

	// the threshold of the metric that triggers the scale action.
	Threshold *float64 `json:"threshold,omitempty"`

	// time aggregation type. How the data that is collected should be combined over time. The default value is Average.
	TimeAggregation *TimeAggregationType `json:"timeAggregation,omitempty"`

	// the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric definitions for
	// the metric. Must be between 12 hours and 1 minute.
	TimeGrain *time.Duration `json:"timeGrain,omitempty"`

	// the range of time in which instance data is collected. This value must be greater than the delay in metric collection,
	// which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.
	TimeWindow *time.Duration `json:"timeWindow,omitempty"`
}

// Represents a metric value.
type MetricValue struct {
	// the average value in the time range.
	Average *float64 `json:"average,omitempty"`

	// the number of samples in the time range. Can be used to determine the number of values that contributed to the average
	// value.
	Count *float64 `json:"count,omitempty"`

	// the greatest value in the time range.
	Maximum *float64 `json:"maximum,omitempty"`

	// the least value in the time range.
	Minimum *float64 `json:"minimum,omitempty"`

	// the timestamp for the metric value in ISO 8601 format.
	TimeStamp *time.Time `json:"timeStamp,omitempty"`

	// the sum of all of the values in the time range.
	Total *float64 `json:"total,omitempty"`
}

func (m MetricValue) MarshalJSON() ([]byte, error) {
	type alias MetricValue
	aux := &struct {
		*alias
		TimeStamp *timeRFC3339 `json:"timeStamp"`
	}{
		alias:     (*alias)(&m),
		TimeStamp: (*timeRFC3339)(m.TimeStamp),
	}
	return json.Marshal(aux)
}

func (m *MetricValue) UnmarshalJSON(data []byte) error {
	type alias MetricValue
	aux := &struct {
		*alias
		TimeStamp *timeRFC3339 `json:"timeStamp"`
	}{
		alias: (*alias)(m),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	m.TimeStamp = (*time.Time)(aux.TimeStamp)
	return nil
}

// MetricsListOptions contains the optional parameters for the Metrics.List method.
type MetricsListOptions struct {
	// The list of aggregation types (comma separated) to retrieve.
	Aggregation *string
	// The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains metadata A, B and C.<br>-
	// Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’ or B eq ‘b2’ and C eq ‘*’**<br>-
	// Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This is invalid because the logical
	// or operator cannot separate two different metadata names.<br>- Return all time series where A = a1, B = b1 and C = c1:<br>**$filter=A
	// eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A = a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and
	// C eq ‘*’**.
	Filter *string
	// The interval (i.e. timegrain) of the query.
	Interval *time.Duration
	// The names of the metrics (comma separated) to retrieve.
	Metricnames *string
	// Metric namespace to query metric definitions for.
	Metricnamespace *string
	// The aggregation to use for sorting results and the direction of the sort.
	// Only one order can be specified.
	// Examples: sum asc.
	Orderby *string
	// Reduces the set of data collected. The syntax allowed depends on the operation. See the operation's description for details.
	ResultType *ResultType
	// The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.
	Timespan *string
	// The maximum number of records to retrieve.
	// Valid only if $filter is specified.
	// Defaults to 10.
	Top *int32
}

// MultiMetricCriteriaClassification provides polymorphic access to related types.
type MultiMetricCriteriaClassification interface {
	GetMultiMetricCriteria() *MultiMetricCriteria
}

// The types of conditions for a multi resource alert.
type MultiMetricCriteria struct {
	// Specifies the type of threshold criteria
	CriterionType *CriterionType `json:"criterionType,omitempty"`

	// List of dimension conditions.
	Dimensions *[]MetricDimension `json:"dimensions,omitempty"`

	// Name of the metric.
	MetricName *string `json:"metricName,omitempty"`

	// Namespace of the metric.
	MetricNamespace *string `json:"metricNamespace,omitempty"`

	// Name of the criteria.
	Name *string `json:"name,omitempty"`

	// the criteria time aggregation types.
	TimeAggregation *AggregationType `json:"timeAggregation,omitempty"`
}

func (m *MultiMetricCriteria) GetMultiMetricCriteria() *MultiMetricCriteria { return m }

func (m *MultiMetricCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "criterionType":
			if v != nil {
				err = json.Unmarshal(*v, &m.CriterionType)
			}
		case "dimensions":
			if v != nil {
				err = json.Unmarshal(*v, &m.Dimensions)
			}
		case "metricName":
			if v != nil {
				err = json.Unmarshal(*v, &m.MetricName)
			}
		case "metricNamespace":
			if v != nil {
				err = json.Unmarshal(*v, &m.MetricNamespace)
			}
		case "name":
			if v != nil {
				err = json.Unmarshal(*v, &m.Name)
			}
		case "timeAggregation":
			if v != nil {
				err = json.Unmarshal(*v, &m.TimeAggregation)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (m MultiMetricCriteria) marshalInternal(discValue CriterionType) map[string]interface{} {
	objectMap := make(map[string]interface{})
	m.CriterionType = &discValue
	objectMap["criterionType"] = m.CriterionType
	if m.Dimensions != nil {
		objectMap["dimensions"] = m.Dimensions
	}
	if m.MetricName != nil {
		objectMap["metricName"] = m.MetricName
	}
	if m.MetricNamespace != nil {
		objectMap["metricNamespace"] = m.MetricNamespace
	}
	if m.Name != nil {
		objectMap["name"] = m.Name
	}
	if m.TimeAggregation != nil {
		objectMap["timeAggregation"] = m.TimeAggregation
	}
	return objectMap
}

// Microsoft Insights API operation definition.
type Operation struct {
	// Display metadata associated with the operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty"`
}

// Display metadata associated with the operation.
type OperationDisplay struct {
	// Operation type: Read, write, delete, etc.
	Operation *string `json:"operation,omitempty"`

	// Service provider: Microsoft.Insights
	Provider *string `json:"provider,omitempty"`

	// Resource on which the operation is performed: AlertRules, Autoscale, etc.
	Resource *string `json:"resource,omitempty"`
}

// Result of the request to list Microsoft.Insights operations. It contains a list of operations and a URL link to get the
// next set of results.
type OperationListResult struct {
	// URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// List of operations supported by the Microsoft.Insights provider.
	Value *[]Operation `json:"value,omitempty"`
}

// OperationListResultResponse is the response envelope for operations that return a OperationListResult type.
type OperationListResultResponse struct {
	// Result of the request to list Microsoft.Insights operations. It contains a list of operations and a URL link to get the
	// next set of results.
	OperationListResult *OperationListResult

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// A proxy only azure resource object
type ProxyOnlyResource struct {
	// Azure resource Id
	ID *string `json:"id,omitempty"`

	// Azure resource name
	Name *string `json:"name,omitempty"`

	// Azure resource type
	Type *string `json:"type,omitempty"`
}

// An azure resource object
type ProxyResource struct {
	// Azure resource Id
	ID *string `json:"id,omitempty"`

	// Azure resource name
	Name *string `json:"name,omitempty"`

	// Azure resource type
	Type *string `json:"type,omitempty"`
}

// The repeating times at which this profile begins. This element is not used if the FixedDate element is used.
type Recurrence struct {
	// the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week
	// will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The
	// frequency property specifies that the schedule is repeated weekly.
	Frequency *RecurrenceFrequency `json:"frequency,omitempty"`

	// the scheduling constraints for when the profile begins.
	Schedule *RecurrentSchedule `json:"schedule,omitempty"`
}

// The scheduling constraints for when the profile begins.
type RecurrentSchedule struct {
	// the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
	Days *[]string `json:"days,omitempty"`

	// A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM times
	// are not supported).
	Hours *[]int32 `json:"hours,omitempty"`

	// A collection of minutes at which the profile takes effect at.
	Minutes *[]int32 `json:"minutes,omitempty"`

	// the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian
	// Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time,
	// Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central
	// Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard
	// Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western
	// Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard
	// Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic
	// Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich
	// Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard
	// Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard
	// Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time,
	// Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab
	// Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard
	// Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard
	// Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard
	// Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia
	// Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia
	// East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time,
	// Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time,
	// E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard
	// Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard
	// Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard
	// Time
	TimeZone *string `json:"timeZone,omitempty"`
}

// An azure resource object
type Resource struct {
	// Azure resource Id
	ID *string `json:"id,omitempty"`

	// Resource location
	Location *string `json:"location,omitempty"`

	// Azure resource name
	Name *string `json:"name,omitempty"`

	// Resource tags
	Tags *map[string]string `json:"tags,omitempty"`

	// Azure resource type
	Type *string `json:"type,omitempty"`
}

// The response to a metrics query.
type Response struct {
	// The integer value representing the cost of the query, for data case.
	Cost *int32 `json:"cost,omitempty"`

	// The interval (window size) for which the metric data was returned in. This may be adjusted in the future and returned back
	// from what was originally requested. This is not present if a metadata request was made.
	Interval *time.Duration `json:"interval,omitempty"`

	// The namespace of the metrics been queried
	Namespace *string `json:"namespace,omitempty"`

	// The region of the resource been queried for metrics.
	Resourceregion *string `json:"resourceregion,omitempty"`

	// The timespan for which the data was retrieved. Its value consists of two datetimes concatenated, separated by '/'. This
	// may be adjusted in the future and returned back from what was originally requested.
	Timespan *string `json:"timespan,omitempty"`

	// the value of the collection.
	Value *[]Metric `json:"value,omitempty"`
}

// ResponseResponse is the response envelope for operations that return a Response type.
type ResponseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// The response to a metrics query.
	Response *Response
}

// An error response from the API.
type ResponseWithError struct {
	// Error information.
	InnerError *Error `json:"error,omitempty"`
}

func (e ResponseWithError) Error() string {
	msg := ""
	if e.InnerError != nil {
		msg += fmt.Sprintf("InnerError: %v\n", *e.InnerError)
	}
	if msg == "" {
		msg = "missing error info"
	}
	return msg
}

// Specifies the retention policy for the log.
type RetentionPolicy struct {
	// the number of days for the retention in days. A value of 0 will retain the events indefinitely.
	Days *int32 `json:"days,omitempty"`

	// a value indicating whether the retention policy is enabled.
	Enabled *bool `json:"enabled,omitempty"`
}

// RuleActionClassification provides polymorphic access to related types.
type RuleActionClassification interface {
	GetRuleAction() *RuleAction
}

// The action that is performed when the alert rule becomes active, and when an alert condition is resolved.
type RuleAction struct {
	// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
	OdataType *string `json:"odata.type,omitempty"`
}

func (r *RuleAction) GetRuleAction() *RuleAction { return r }

func (r *RuleAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "odata.type":
			if v != nil {
				err = json.Unmarshal(*v, &r.OdataType)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (r RuleAction) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	r.OdataType = &discValue
	objectMap["odata.type"] = r.OdataType
	return objectMap
}

// RuleConditionClassification provides polymorphic access to related types.
type RuleConditionClassification interface {
	GetRuleCondition() *RuleCondition
}

// The condition that results in the alert rule being activated.
type RuleCondition struct {
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource RuleDataSourceClassification `json:"dataSource,omitempty"`

	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management
	// events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based
	// on the threshold of a metric).
	OdataType *string `json:"odata.type,omitempty"`
}

func (r *RuleCondition) GetRuleCondition() *RuleCondition { return r }

func (r *RuleCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "dataSource":
			if v != nil {
				r.DataSource, err = unmarshalRuleDataSourceClassification(*v)
			}
		case "odata.type":
			if v != nil {
				err = json.Unmarshal(*v, &r.OdataType)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (r RuleCondition) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if r.DataSource != nil {
		objectMap["dataSource"] = r.DataSource
	}
	r.OdataType = &discValue
	objectMap["odata.type"] = r.OdataType
	return objectMap
}

// RuleDataSourceClassification provides polymorphic access to related types.
type RuleDataSourceClassification interface {
	GetRuleDataSource() *RuleDataSource
}

// The resource from which the rule collects its data.
type RuleDataSource struct {
	// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
	OdataType *string `json:"odata.type,omitempty"`

	// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	ResourceURI *string `json:"resourceUri,omitempty"`
}

func (r *RuleDataSource) GetRuleDataSource() *RuleDataSource { return r }

func (r *RuleDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "odata.type":
			if v != nil {
				err = json.Unmarshal(*v, &r.OdataType)
			}
		case "resourceUri":
			if v != nil {
				err = json.Unmarshal(*v, &r.ResourceURI)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (r RuleDataSource) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	r.OdataType = &discValue
	objectMap["odata.type"] = r.OdataType
	if r.ResourceURI != nil {
		objectMap["resourceUri"] = r.ResourceURI
	}
	return objectMap
}

// Specifies the action to send email when the rule condition is evaluated. The discriminator is always RuleEmailAction in
// this case.
type RuleEmailAction struct {
	RuleAction
	// the list of administrator's custom email addresses to notify of the activation of the alert.
	CustomEmails *[]string `json:"customEmails,omitempty"`

	// Whether the administrators (service and co-administrators) of the service should be notified when the alert is activated.
	SendToServiceOwners *bool `json:"sendToServiceOwners,omitempty"`
}

func (r RuleEmailAction) MarshalJSON() ([]byte, error) {
	objectMap := r.RuleAction.marshalInternal("Microsoft.Azure.Management.Insights.Models.RuleEmailAction")
	if r.CustomEmails != nil {
		objectMap["customEmails"] = r.CustomEmails
	}
	if r.SendToServiceOwners != nil {
		objectMap["sendToServiceOwners"] = r.SendToServiceOwners
	}
	return json.Marshal(objectMap)
}

func (r *RuleEmailAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "customEmails":
			if v != nil {
				err = json.Unmarshal(*v, &r.CustomEmails)
			}
		case "sendToServiceOwners":
			if v != nil {
				err = json.Unmarshal(*v, &r.SendToServiceOwners)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &r.RuleAction)
}

// The claims for a rule management event data source.
type RuleManagementEventClaimsDataSource struct {
	// the email address.
	EmailAddress *string `json:"emailAddress,omitempty"`
}

// A rule management event data source. The discriminator fields is always RuleManagementEventDataSource in this case.
type RuleManagementEventDataSource struct {
	RuleDataSource
	// the claims.
	Claims *RuleManagementEventClaimsDataSource `json:"claims,omitempty"`

	// the event name.
	EventName *string `json:"eventName,omitempty"`

	// the event source.
	EventSource *string `json:"eventSource,omitempty"`

	// the level.
	Level *string `json:"level,omitempty"`

	// The name of the operation that should be checked for. If no name is provided, any operation will match.
	OperationName *string `json:"operationName,omitempty"`

	// the resource group name.
	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	// the resource provider name.
	ResourceProviderName *string `json:"resourceProviderName,omitempty"`

	// The status of the operation that should be checked for. If no status is provided, any status will match.
	Status *string `json:"status,omitempty"`

	// the substatus.
	SubStatus *string `json:"subStatus,omitempty"`
}

func (r RuleManagementEventDataSource) MarshalJSON() ([]byte, error) {
	objectMap := r.RuleDataSource.marshalInternal("Microsoft.Azure.Management.Insights.Models.RuleManagementEventDataSource")
	if r.Claims != nil {
		objectMap["claims"] = r.Claims
	}
	if r.EventName != nil {
		objectMap["eventName"] = r.EventName
	}
	if r.EventSource != nil {
		objectMap["eventSource"] = r.EventSource
	}
	if r.Level != nil {
		objectMap["level"] = r.Level
	}
	if r.OperationName != nil {
		objectMap["operationName"] = r.OperationName
	}
	if r.ResourceGroupName != nil {
		objectMap["resourceGroupName"] = r.ResourceGroupName
	}
	if r.ResourceProviderName != nil {
		objectMap["resourceProviderName"] = r.ResourceProviderName
	}
	if r.Status != nil {
		objectMap["status"] = r.Status
	}
	if r.SubStatus != nil {
		objectMap["subStatus"] = r.SubStatus
	}
	return json.Marshal(objectMap)
}

func (r *RuleManagementEventDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "claims":
			if v != nil {
				err = json.Unmarshal(*v, &r.Claims)
			}
		case "eventName":
			if v != nil {
				err = json.Unmarshal(*v, &r.EventName)
			}
		case "eventSource":
			if v != nil {
				err = json.Unmarshal(*v, &r.EventSource)
			}
		case "level":
			if v != nil {
				err = json.Unmarshal(*v, &r.Level)
			}
		case "operationName":
			if v != nil {
				err = json.Unmarshal(*v, &r.OperationName)
			}
		case "resourceGroupName":
			if v != nil {
				err = json.Unmarshal(*v, &r.ResourceGroupName)
			}
		case "resourceProviderName":
			if v != nil {
				err = json.Unmarshal(*v, &r.ResourceProviderName)
			}
		case "status":
			if v != nil {
				err = json.Unmarshal(*v, &r.Status)
			}
		case "subStatus":
			if v != nil {
				err = json.Unmarshal(*v, &r.SubStatus)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &r.RuleDataSource)
}

// A rule metric data source. The discriminator value is always RuleMetricDataSource in this case.
type RuleMetricDataSource struct {
	RuleDataSource
	// the name of the metric that defines what the rule monitors.
	MetricName *string `json:"metricName,omitempty"`
}

func (r RuleMetricDataSource) MarshalJSON() ([]byte, error) {
	objectMap := r.RuleDataSource.marshalInternal("Microsoft.Azure.Management.Insights.Models.RuleMetricDataSource")
	if r.MetricName != nil {
		objectMap["metricName"] = r.MetricName
	}
	return json.Marshal(objectMap)
}

func (r *RuleMetricDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "metricName":
			if v != nil {
				err = json.Unmarshal(*v, &r.MetricName)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &r.RuleDataSource)
}

// Specifies the action to post to service when the rule condition is evaluated. The discriminator is always RuleWebhookAction
// in this case.
type RuleWebhookAction struct {
	RuleAction
	// the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload.
	Properties *map[string]string `json:"properties,omitempty"`

	// the service uri to Post the notification when the alert activates or resolves.
	ServiceURI *string `json:"serviceUri,omitempty"`
}

func (r RuleWebhookAction) MarshalJSON() ([]byte, error) {
	objectMap := r.RuleAction.marshalInternal("Microsoft.Azure.Management.Insights.Models.RuleWebhookAction")
	if r.Properties != nil {
		objectMap["properties"] = r.Properties
	}
	if r.ServiceURI != nil {
		objectMap["serviceUri"] = r.ServiceURI
	}
	return json.Marshal(objectMap)
}

func (r *RuleWebhookAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "properties":
			if v != nil {
				err = json.Unmarshal(*v, &r.Properties)
			}
		case "serviceUri":
			if v != nil {
				err = json.Unmarshal(*v, &r.ServiceURI)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &r.RuleAction)
}

// The parameters for the scaling action.
type ScaleAction struct {
	// the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week and 1 minute
	// in ISO 8601 format.
	Cooldown *time.Duration `json:"cooldown,omitempty"`

	// the scale direction. Whether the scaling action increases or decreases the number of instances.
	Direction *ScaleDirection `json:"direction,omitempty"`

	// the type of action that should occur when the scale rule fires.
	Type *ScaleType `json:"type,omitempty"`

	// the number of instances that are involved in the scaling action. This value must be 1 or greater. The default value is
	// 1.
	Value *string `json:"value,omitempty"`
}

// The number of instances that can be used during this profile.
type ScaleCapacity struct {
	// the number of instances that will be set if metrics are not available for evaluation. The default is only used if the current
	// instance count is lower than the default.
	Default *string `json:"default,omitempty"`

	// the maximum number of instances for the resource. The actual maximum number of instances is limited by the cores that are
	// available in the subscription.
	Maximum *string `json:"maximum,omitempty"`

	// the minimum number of instances for the resource.
	Minimum *string `json:"minimum,omitempty"`
}

// A rule that provide the triggers and parameters for the scaling action.
type ScaleRule struct {
	// the trigger that results in a scaling action.
	MetricTrigger *MetricTrigger `json:"metricTrigger,omitempty"`

	// the parameters for the scaling action.
	ScaleAction *ScaleAction `json:"scaleAction,omitempty"`
}

// Defines how often to run the search and the time interval.
type Schedule struct {
	// frequency (in minutes) at which rule condition should be evaluated.
	FrequencyInMinutes *int32 `json:"frequencyInMinutes,omitempty"`

	// Time window for which data needs to be fetched for query (should be greater than or equal to frequencyInMinutes).
	TimeWindowInMinutes *int32 `json:"timeWindowInMinutes,omitempty"`
}

// ScheduledQueryRulesListByResourceGroupOptions contains the optional parameters for the ScheduledQueryRules.ListByResourceGroup
// method.
type ScheduledQueryRulesListByResourceGroupOptions struct {
	// The filter to apply on the operation. For more information please see https://msdn.microsoft.com/en-us/library/azure/dn931934.aspx
	Filter *string
}

// ScheduledQueryRulesListBySubscriptionOptions contains the optional parameters for the ScheduledQueryRules.ListBySubscription
// method.
type ScheduledQueryRulesListBySubscriptionOptions struct {
	// The filter to apply on the operation. For more information please see https://msdn.microsoft.com/en-us/library/azure/dn931934.aspx
	Filter *string
}

// the authorization used by the user who has performed the operation that led to this event. This captures the RBAC properties
// of the event. These usually include the 'action', 'role' and the 'scope'
type SenderAuthorization struct {
	// the permissible actions. For instance: microsoft.support/supporttickets/write
	Action *string `json:"action,omitempty"`

	// the role of the user. For instance: Subscription Admin
	Role *string `json:"role,omitempty"`

	// the scope.
	Scope *string `json:"scope,omitempty"`
}

// The baseline values for a single sensitivity value.
type SingleBaseline struct {
	// The high thresholds of the baseline.
	HighThresholds *[]float64 `json:"highThresholds,omitempty"`

	// The low thresholds of the baseline.
	LowThresholds *[]float64 `json:"lowThresholds,omitempty"`

	// the sensitivity of the baseline.
	Sensitivity *BaselineSensitivity `json:"sensitivity,omitempty"`
}

// The baseline results of a single metric.
type SingleMetricBaseline struct {
	// The metric baseline Id.
	ID *string `json:"id,omitempty"`

	// The name of the metric for which the baselines were retrieved.
	Name *string `json:"name,omitempty"`

	// The metric baseline properties of the metric.
	Properties *MetricBaselinesProperties `json:"properties,omitempty"`

	// The resource type of the metric baseline resource.
	Type *string `json:"type,omitempty"`
}

// An SMS receiver.
type SmsReceiver struct {
	// The country code of the SMS receiver.
	CountryCode *string `json:"countryCode,omitempty"`

	// The name of the SMS receiver. Names must be unique across all receivers within an action group.
	Name *string `json:"name,omitempty"`

	// The phone number of the SMS receiver.
	PhoneNumber *string `json:"phoneNumber,omitempty"`

	// The status of the receiver.
	Status *ReceiverStatus `json:"status,omitempty"`
}

// Specifies the log search query.
type Source struct {
	// List of Resource referred into query
	AuthorizedResources *[]string `json:"authorizedResources,omitempty"`

	// The resource uri over which log search query is to be run.
	DataSourceID *string `json:"dataSourceId,omitempty"`

	// Log search query. Required for action type - AlertingAction
	Query *string `json:"query,omitempty"`

	// Set value to 'ResultCount' .
	QueryType *string `json:"queryType,omitempty"`
}

// TenantActivityLogsListOptions contains the optional parameters for the TenantActivityLogs.List method.
type TenantActivityLogsListOptions struct {
	// Reduces the set of data collected. <br>The **$filter** is very restricted and allows only the following patterns.<br>-
	// List events for a resource group: $filter=eventTimestamp ge '<Start Time>' and eventTimestamp le '<End Time>' and eventChannels
	// eq 'Admin, Operation' and resourceGroupName eq '<ResourceGroupName>'.<br>- List events for resource: $filter=eventTimestamp
	// ge '<Start Time>' and eventTimestamp le '<End Time>' and eventChannels eq 'Admin, Operation' and resourceUri eq '<ResourceURI>'.<br>-
	// List events for a subscription: $filter=eventTimestamp ge '<Start Time>' and eventTimestamp le '<End Time>' and eventChannels
	// eq 'Admin, Operation'.<br>- List events for a resource provider: $filter=eventTimestamp ge '<Start Time>' and eventTimestamp
	// le '<End Time>' and eventChannels eq 'Admin, Operation' and resourceProvider eq '<ResourceProviderName>'.<br>- List events
	// for a correlation Id: api-version=2014-04-01&$filter=eventTimestamp ge '2014-07-16T04:36:37.6407898Z' and eventTimestamp
	// le '2014-07-20T04:36:37.6407898Z' and eventChannels eq 'Admin, Operation' and correlationId eq '<CorrelationID>'.<br>**NOTE**:
	// No other syntax is allowed.
	Filter *string
	// Used to fetch events with only the given properties.<br>The **$select** argument is a comma separated list of property
	// names to be returned. Possible values are: *authorization*, *claims*, *correlationId*, *description*, *eventDataId*, *eventName*,
	// *eventTimestamp*, *httpRequest*, *level*, *operationId*, *operationName*, *properties*, *resourceGroupName*, *resourceProviderName*,
	// *resourceId*, *status*, *submissionTimestamp*, *subStatus*, *subscriptionId*
	SelectParameter *string
}

// A rule condition based on a metric crossing a threshold.
type ThresholdRuleCondition struct {
	RuleCondition
	// the operator used to compare the data and the threshold.
	Operator *ConditionOperator `json:"operator,omitempty"`

	// the threshold value that activates the alert.
	Threshold *float64 `json:"threshold,omitempty"`

	// the time aggregation operator. How the data that are collected should be combined over time. The default value is the PrimaryAggregationType
	// of the Metric.
	TimeAggregation *TimeAggregationOperator `json:"timeAggregation,omitempty"`

	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified
	// then it must be between 5 minutes and 1 day.
	WindowSize *time.Duration `json:"windowSize,omitempty"`
}

func (t ThresholdRuleCondition) MarshalJSON() ([]byte, error) {
	objectMap := t.RuleCondition.marshalInternal("Microsoft.Azure.Management.Insights.Models.ThresholdRuleCondition")
	if t.Operator != nil {
		objectMap["operator"] = t.Operator
	}
	if t.Threshold != nil {
		objectMap["threshold"] = t.Threshold
	}
	if t.TimeAggregation != nil {
		objectMap["timeAggregation"] = t.TimeAggregation
	}
	if t.WindowSize != nil {
		objectMap["windowSize"] = t.WindowSize
	}
	return json.Marshal(objectMap)
}

func (t *ThresholdRuleCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "operator":
			if v != nil {
				err = json.Unmarshal(*v, &t.Operator)
			}
		case "threshold":
			if v != nil {
				err = json.Unmarshal(*v, &t.Threshold)
			}
		case "timeAggregation":
			if v != nil {
				err = json.Unmarshal(*v, &t.TimeAggregation)
			}
		case "windowSize":
			if v != nil {
				err = json.Unmarshal(*v, &t.WindowSize)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &t.RuleCondition)
}

// The baseline values for a single time series.
type TimeSeriesBaseline struct {
	// The aggregation type of the metric.
	Aggregation *string `json:"aggregation,omitempty"`

	// The baseline values for each sensitivity.
	Data *[]SingleBaseline `json:"data,omitempty"`

	// The dimensions of this time series.
	Dimensions *[]MetricSingleDimension `json:"dimensions,omitempty"`

	// The baseline metadata values.
	Metadata *[]BaselineMetadata `json:"metadata,omitempty"`

	// The list of timestamps of the baselines.
	Timestamps *[]time.Time `json:"timestamps,omitempty"`
}

// A time series result type. The discriminator value is always TimeSeries in this case.
type TimeSeriesElement struct {
	// An array of data points representing the metric values. This is only returned if a result type of data is specified.
	Data *[]MetricValue `json:"data,omitempty"`

	// the metadata values returned if $filter was specified in the call.
	Metadatavalues *[]MetadataValue `json:"metadatavalues,omitempty"`
}

// The time series info needed for calculating the baseline.
type TimeSeriesInformation struct {
	// the list of sensitivities for calculating the baseline.
	Sensitivities *[]string `json:"sensitivities,omitempty"`

	// the array of timestamps of the baselines.
	Timestamps *[]time.Time `json:"timestamps,omitempty"`

	// The metric values to calculate the baseline.
	Values *[]float64 `json:"values,omitempty"`
}

// A specific date-time for the profile.
type TimeWindow struct {
	// the end time for the profile in ISO 8601 format.
	End *time.Time `json:"end,omitempty"`

	// the start time for the profile in ISO 8601 format.
	Start *time.Time `json:"start,omitempty"`

	// the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time,
	// UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain
	// Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard
	// Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US
	// Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard
	// Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina
	// Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02,
	// Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time,
	// Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European
	// Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle
	// East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE
	// Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard
	// Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian
	// Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus
	// Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time,
	// India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time,
	// N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time,
	// North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard
	// Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard
	// Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan
	// Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New
	// Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line
	// Islands Standard Time
	TimeZone *string `json:"timeZone,omitempty"`
}

func (t TimeWindow) MarshalJSON() ([]byte, error) {
	type alias TimeWindow
	aux := &struct {
		*alias
		End   *timeRFC3339 `json:"end"`
		Start *timeRFC3339 `json:"start"`
	}{
		alias: (*alias)(&t),
		End:   (*timeRFC3339)(t.End),
		Start: (*timeRFC3339)(t.Start),
	}
	return json.Marshal(aux)
}

func (t *TimeWindow) UnmarshalJSON(data []byte) error {
	type alias TimeWindow
	aux := &struct {
		*alias
		End   *timeRFC3339 `json:"end"`
		Start *timeRFC3339 `json:"start"`
	}{
		alias: (*alias)(t),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	t.End = (*time.Time)(aux.End)
	t.Start = (*time.Time)(aux.Start)
	return nil
}

// The condition that results in the Log Search rule.
type TriggerCondition struct {
	// Trigger condition for metric query rule
	MetricTrigger *LogMetricTrigger `json:"metricTrigger,omitempty"`

	// Result or count threshold based on which rule should be triggered.
	Threshold *float64 `json:"threshold,omitempty"`

	// Evaluation operation for rule - 'GreaterThan' or 'LessThan.
	ThresholdOperator *ConditionalOperator `json:"thresholdOperator,omitempty"`
}

// VM Insights onboarding status for a resource.
type VMInsightsOnboardingStatus struct {
	ProxyResource
	// Resource properties.
	Properties *VMInsightsOnboardingStatusProperties `json:"properties,omitempty"`
}

// Resource properties.
type VMInsightsOnboardingStatusProperties struct {
	// Containers that currently store VM Insights data for the specified resource.
	Data *[]DataContainer `json:"data,omitempty"`

	// The status of VM Insights data from the resource. When reported as `present` the data array will contain information about
	// the data containers to which data for the specified resource is being routed.
	DataStatus *DataStatus `json:"dataStatus,omitempty"`

	// The onboarding status for the resource. Note that, a higher level scope, e.g., resource group or subscription, is considered
	// onboarded if at least one resource under it is onboarded.
	OnboardingStatus *OnboardingStatus `json:"onboardingStatus,omitempty"`

	// Azure Resource Manager identifier of the resource whose onboarding status is being represented.
	ResourceID *string `json:"resourceId,omitempty"`
}

// VMInsightsOnboardingStatusResponse is the response envelope for operations that return a VMInsightsOnboardingStatus type.
type VMInsightsOnboardingStatusResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// VM Insights onboarding status for a resource.
	VMInsightsOnboardingStatus *VMInsightsOnboardingStatus
}

// A voice receiver.
type VoiceReceiver struct {
	// The country code of the voice receiver.
	CountryCode *string `json:"countryCode,omitempty"`

	// The name of the voice receiver. Names must be unique across all receivers within an action group.
	Name *string `json:"name,omitempty"`

	// The phone number of the voice receiver.
	PhoneNumber *string `json:"phoneNumber,omitempty"`
}

// Webhook notification of an autoscale event.
type WebhookNotification struct {
	// a property bag of settings. This value can be empty.
	Properties *map[string]string `json:"properties,omitempty"`

	// the service address to receive the notification.
	ServiceURI *string `json:"serviceUri,omitempty"`
}

// A webhook receiver.
type WebhookReceiver struct {
	// Indicates the identifier uri for aad auth.
	IDentifierURI *string `json:"identifierUri,omitempty"`

	// The name of the webhook receiver. Names must be unique across all receivers within an action group.
	Name *string `json:"name,omitempty"`

	// Indicates the webhook app object Id for aad auth.
	ObjectID *string `json:"objectId,omitempty"`

	// The URI where webhooks should be sent.
	ServiceURI *string `json:"serviceUri,omitempty"`

	// Indicates the tenant id for aad auth.
	TenantID *string `json:"tenantId,omitempty"`

	// Indicates whether or not use AAD authentication.
	UseAadAuth *bool `json:"useAadAuth,omitempty"`

	// Indicates whether to use common alert schema.
	UseCommonAlertSchema *bool `json:"useCommonAlertSchema,omitempty"`
}

// Specifies the metric alert rule criteria for a web test resource.
type WebtestLocationAvailabilityCriteria struct {
	MetricAlertCriteria
	// The Application Insights resource Id.
	ComponentID *string `json:"componentId,omitempty"`

	// The number of failed locations.
	FailedLocationCount *float32 `json:"failedLocationCount,omitempty"`

	// The Application Insights web test Id.
	WebTestID *string `json:"webTestId,omitempty"`
}

func (w WebtestLocationAvailabilityCriteria) MarshalJSON() ([]byte, error) {
	objectMap := w.MetricAlertCriteria.marshalInternal(OdatatypeMicrosoftAzureMonitorWebtestLocationAvailabilityCriteria)
	if w.ComponentID != nil {
		objectMap["componentId"] = w.ComponentID
	}
	if w.FailedLocationCount != nil {
		objectMap["failedLocationCount"] = w.FailedLocationCount
	}
	if w.WebTestID != nil {
		objectMap["webTestId"] = w.WebTestID
	}
	return json.Marshal(objectMap)
}

func (w *WebtestLocationAvailabilityCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "componentId":
			if v != nil {
				err = json.Unmarshal(*v, &w.ComponentID)
			}
		case "failedLocationCount":
			if v != nil {
				err = json.Unmarshal(*v, &w.FailedLocationCount)
			}
		case "webTestId":
			if v != nil {
				err = json.Unmarshal(*v, &w.WebTestID)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &w.MetricAlertCriteria)
}

// Information about a Log Analytics Workspace.
type WorkspaceInfo struct {
	// Azure Resource Manager identifier of the Log Analytics Workspace.
	ID *string `json:"id,omitempty"`

	// Location of the Log Analytics workspace.
	Location *string `json:"location,omitempty"`

	// Resource properties.
	Properties *WorkspaceInfoProperties `json:"properties,omitempty"`
}

// Resource properties.
type WorkspaceInfoProperties struct {
	// Log Analytics workspace identifier.
	CustomerID *string `json:"customerId,omitempty"`
}
