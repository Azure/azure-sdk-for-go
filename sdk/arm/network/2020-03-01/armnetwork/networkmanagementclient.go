// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// NetworkManagementClientOperations contains the methods for the NetworkManagementClient group.
type NetworkManagementClientOperations interface {
	// CheckDNSNameAvailability - Checks whether a domain name in the cloudapp.azure.com zone is available for use.
	CheckDNSNameAvailability(ctx context.Context, location string, domainNameLabel string) (*DNSNameAvailabilityResultResponse, error)
	// BeginDeleteBastionShareableLink - Deletes the Bastion Shareable Links for all the VMs specified in the request.
	BeginDeleteBastionShareableLink(ctx context.Context, resourceGroupName string, bastionHostName string, bslRequest BastionShareableLinkListRequest) (*HTTPPollerResponse, error)
	// ResumeDeleteBastionShareableLink - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteBastionShareableLink(token string) (HTTPPoller, error)
	// DisconnectActiveSessions - Returns the list of currently active sessions on the Bastion.
	DisconnectActiveSessions(resourceGroupName string, bastionHostName string, sessionIds SessionIDs) (BastionSessionDeleteResultPager, error)
	// BeginGeneratevirtualwanvpnserverconfigurationvpnprofile - Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination in the specified resource group.
	BeginGeneratevirtualwanvpnserverconfigurationvpnprofile(ctx context.Context, resourceGroupName string, virtualWanName string, vpnClientParams VirtualWanVpnProfileParameters) (*VpnProfileResponsePollerResponse, error)
	// ResumeGeneratevirtualwanvpnserverconfigurationvpnprofile - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeGeneratevirtualwanvpnserverconfigurationvpnprofile(token string) (VpnProfileResponsePoller, error)
	// BeginGetActiveSessions - Returns the list of currently active sessions on the Bastion.
	BeginGetActiveSessions(ctx context.Context, resourceGroupName string, bastionHostName string) (*BastionActiveSessionListResultPagerPollerResponse, error)
	// ResumeGetActiveSessions - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeGetActiveSessions(token string) (BastionActiveSessionListResultPagerPoller, error)
	// GetBastionShareableLink - Return the Bastion Shareable Links for all the VMs specified in the request.
	GetBastionShareableLink(resourceGroupName string, bastionHostName string, bslRequest BastionShareableLinkListRequest) (BastionShareableLinkListResultPager, error)
	// BeginPutBastionShareableLink - Creates a Bastion Shareable Links for all the VMs specified in the request.
	BeginPutBastionShareableLink(ctx context.Context, resourceGroupName string, bastionHostName string, bslRequest BastionShareableLinkListRequest) (*BastionShareableLinkListResultPagerPollerResponse, error)
	// ResumePutBastionShareableLink - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePutBastionShareableLink(token string) (BastionShareableLinkListResultPagerPoller, error)
	// SupportedSecurityProviders - Gives the supported security providers for the virtual wan.
	SupportedSecurityProviders(ctx context.Context, resourceGroupName string, virtualWanName string) (*VirtualWanSecurityProvidersResponse, error)
}

// networkManagementClientOperations implements the NetworkManagementClientOperations interface.
type networkManagementClientOperations struct {
	*Client
	subscriptionID string
}

// CheckDNSNameAvailability - Checks whether a domain name in the cloudapp.azure.com zone is available for use.
func (client *networkManagementClientOperations) CheckDNSNameAvailability(ctx context.Context, location string, domainNameLabel string) (*DNSNameAvailabilityResultResponse, error) {
	req, err := client.checkDnsNameAvailabilityCreateRequest(location, domainNameLabel)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.checkDnsNameAvailabilityHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// checkDnsNameAvailabilityCreateRequest creates the CheckDNSNameAvailability request.
func (client *networkManagementClientOperations) checkDnsNameAvailabilityCreateRequest(location string, domainNameLabel string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/CheckDnsNameAvailability"
	urlPath = strings.ReplaceAll(urlPath, "{location}", url.PathEscape(location))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("domainNameLabel", domainNameLabel)
	query.Set("api-version", "2020-03-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// checkDnsNameAvailabilityHandleResponse handles the CheckDNSNameAvailability response.
func (client *networkManagementClientOperations) checkDnsNameAvailabilityHandleResponse(resp *azcore.Response) (*DNSNameAvailabilityResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.checkDnsNameAvailabilityHandleError(resp)
	}
	result := DNSNameAvailabilityResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DNSNameAvailabilityResult)
}

// checkDnsNameAvailabilityHandleError handles the CheckDNSNameAvailability error response.
func (client *networkManagementClientOperations) checkDnsNameAvailabilityHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DeleteBastionShareableLink - Deletes the Bastion Shareable Links for all the VMs specified in the request.
func (client *networkManagementClientOperations) BeginDeleteBastionShareableLink(ctx context.Context, resourceGroupName string, bastionHostName string, bslRequest BastionShareableLinkListRequest) (*HTTPPollerResponse, error) {
	req, err := client.deleteBastionShareableLinkCreateRequest(resourceGroupName, bastionHostName, bslRequest)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteBastionShareableLinkHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("networkManagementClientOperations.DeleteBastionShareableLink", "location", resp, client.deleteBastionShareableLinkHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *networkManagementClientOperations) ResumeDeleteBastionShareableLink(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("networkManagementClientOperations.DeleteBastionShareableLink", token, client.deleteBastionShareableLinkHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deleteBastionShareableLinkCreateRequest creates the DeleteBastionShareableLink request.
func (client *networkManagementClientOperations) deleteBastionShareableLinkCreateRequest(resourceGroupName string, bastionHostName string, bslRequest BastionShareableLinkListRequest) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/deleteShareableLinks"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{bastionHostName}", url.PathEscape(bastionHostName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2020-03-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(bslRequest)
}

// deleteBastionShareableLinkHandleResponse handles the DeleteBastionShareableLink response.
func (client *networkManagementClientOperations) deleteBastionShareableLinkHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteBastionShareableLinkHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// deleteBastionShareableLinkHandleError handles the DeleteBastionShareableLink error response.
func (client *networkManagementClientOperations) deleteBastionShareableLinkHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DisconnectActiveSessions - Returns the list of currently active sessions on the Bastion.
func (client *networkManagementClientOperations) DisconnectActiveSessions(resourceGroupName string, bastionHostName string, sessionIds SessionIDs) (BastionSessionDeleteResultPager, error) {
	req, err := client.disconnectActiveSessionsCreateRequest(resourceGroupName, bastionHostName, sessionIds)
	if err != nil {
		return nil, err
	}
	return &bastionSessionDeleteResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.disconnectActiveSessionsHandleResponse,
		advancer: func(resp *BastionSessionDeleteResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.BastionSessionDeleteResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.BastionSessionDeleteResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// disconnectActiveSessionsCreateRequest creates the DisconnectActiveSessions request.
func (client *networkManagementClientOperations) disconnectActiveSessionsCreateRequest(resourceGroupName string, bastionHostName string, sessionIds SessionIDs) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/disconnectActiveSessions"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{bastionHostName}", url.PathEscape(bastionHostName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2020-03-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(sessionIds)
}

// disconnectActiveSessionsHandleResponse handles the DisconnectActiveSessions response.
func (client *networkManagementClientOperations) disconnectActiveSessionsHandleResponse(resp *azcore.Response) (*BastionSessionDeleteResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.disconnectActiveSessionsHandleError(resp)
	}
	result := BastionSessionDeleteResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.BastionSessionDeleteResult)
}

// disconnectActiveSessionsHandleError handles the DisconnectActiveSessions error response.
func (client *networkManagementClientOperations) disconnectActiveSessionsHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Generatevirtualwanvpnserverconfigurationvpnprofile - Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination in the specified resource group.
func (client *networkManagementClientOperations) BeginGeneratevirtualwanvpnserverconfigurationvpnprofile(ctx context.Context, resourceGroupName string, virtualWanName string, vpnClientParams VirtualWanVpnProfileParameters) (*VpnProfileResponsePollerResponse, error) {
	req, err := client.generatevirtualwanvpnserverconfigurationvpnprofileCreateRequest(resourceGroupName, virtualWanName, vpnClientParams)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.generatevirtualwanvpnserverconfigurationvpnprofileHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("networkManagementClientOperations.Generatevirtualwanvpnserverconfigurationvpnprofile", "location", resp, client.generatevirtualwanvpnserverconfigurationvpnprofileHandleError)
	if err != nil {
		return nil, err
	}
	poller := &vpnProfileResponsePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*VpnProfileResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *networkManagementClientOperations) ResumeGeneratevirtualwanvpnserverconfigurationvpnprofile(token string) (VpnProfileResponsePoller, error) {
	pt, err := resumePollingTracker("networkManagementClientOperations.Generatevirtualwanvpnserverconfigurationvpnprofile", token, client.generatevirtualwanvpnserverconfigurationvpnprofileHandleError)
	if err != nil {
		return nil, err
	}
	return &vpnProfileResponsePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// generatevirtualwanvpnserverconfigurationvpnprofileCreateRequest creates the Generatevirtualwanvpnserverconfigurationvpnprofile request.
func (client *networkManagementClientOperations) generatevirtualwanvpnserverconfigurationvpnprofileCreateRequest(resourceGroupName string, virtualWanName string, vpnClientParams VirtualWanVpnProfileParameters) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/GenerateVpnProfile"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{virtualWANName}", url.PathEscape(virtualWanName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2020-03-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(vpnClientParams)
}

// generatevirtualwanvpnserverconfigurationvpnprofileHandleResponse handles the Generatevirtualwanvpnserverconfigurationvpnprofile response.
func (client *networkManagementClientOperations) generatevirtualwanvpnserverconfigurationvpnprofileHandleResponse(resp *azcore.Response) (*VpnProfileResponsePollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.generatevirtualwanvpnserverconfigurationvpnprofileHandleError(resp)
	}
	return &VpnProfileResponsePollerResponse{RawResponse: resp.Response}, nil
}

// generatevirtualwanvpnserverconfigurationvpnprofileHandleError handles the Generatevirtualwanvpnserverconfigurationvpnprofile error response.
func (client *networkManagementClientOperations) generatevirtualwanvpnserverconfigurationvpnprofileHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetActiveSessions - Returns the list of currently active sessions on the Bastion.
func (client *networkManagementClientOperations) BeginGetActiveSessions(ctx context.Context, resourceGroupName string, bastionHostName string) (*BastionActiveSessionListResultPagerPollerResponse, error) {
	req, err := client.getActiveSessionsCreateRequest(resourceGroupName, bastionHostName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getActiveSessionsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("networkManagementClientOperations.GetActiveSessions", "location", resp, client.getActiveSessionsHandleError)
	if err != nil {
		return nil, err
	}
	poller := &bastionActiveSessionListResultPagerPoller{
		pt:          pt,
		respHandler: client.bastionActiveSessionListResultPagerHandleResponse,
		pipeline:    client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (BastionActiveSessionListResultPager, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *networkManagementClientOperations) ResumeGetActiveSessions(token string) (BastionActiveSessionListResultPagerPoller, error) {
	pt, err := resumePollingTracker("networkManagementClientOperations.GetActiveSessions", token, client.getActiveSessionsHandleError)
	if err != nil {
		return nil, err
	}
	return &bastionActiveSessionListResultPagerPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// getActiveSessionsCreateRequest creates the GetActiveSessions request.
func (client *networkManagementClientOperations) getActiveSessionsCreateRequest(resourceGroupName string, bastionHostName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getActiveSessions"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{bastionHostName}", url.PathEscape(bastionHostName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2020-03-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// getActiveSessionsHandleResponse handles the GetActiveSessions response.
func (client *networkManagementClientOperations) getActiveSessionsHandleResponse(resp *azcore.Response) (*BastionActiveSessionListResultPagerPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.getActiveSessionsHandleError(resp)
	}
	return &BastionActiveSessionListResultPagerPollerResponse{RawResponse: resp.Response}, nil
}

// getActiveSessionsHandleResponse handles the GetActiveSessions response.
func (client *networkManagementClientOperations) bastionActiveSessionListResultPagerHandleResponse(resp *azcore.Response) (*BastionActiveSessionListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusOK) {
		return nil, client.getActiveSessionsHandleError(resp)
	}
	result := BastionActiveSessionListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.BastionActiveSessionListResult)
}

// getActiveSessionsHandleError handles the GetActiveSessions error response.
func (client *networkManagementClientOperations) getActiveSessionsHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetBastionShareableLink - Return the Bastion Shareable Links for all the VMs specified in the request.
func (client *networkManagementClientOperations) GetBastionShareableLink(resourceGroupName string, bastionHostName string, bslRequest BastionShareableLinkListRequest) (BastionShareableLinkListResultPager, error) {
	req, err := client.getBastionShareableLinkCreateRequest(resourceGroupName, bastionHostName, bslRequest)
	if err != nil {
		return nil, err
	}
	return &bastionShareableLinkListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.getBastionShareableLinkHandleResponse,
		advancer: func(resp *BastionShareableLinkListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.BastionShareableLinkListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.BastionShareableLinkListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getBastionShareableLinkCreateRequest creates the GetBastionShareableLink request.
func (client *networkManagementClientOperations) getBastionShareableLinkCreateRequest(resourceGroupName string, bastionHostName string, bslRequest BastionShareableLinkListRequest) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getShareableLinks"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{bastionHostName}", url.PathEscape(bastionHostName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2020-03-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(bslRequest)
}

// getBastionShareableLinkHandleResponse handles the GetBastionShareableLink response.
func (client *networkManagementClientOperations) getBastionShareableLinkHandleResponse(resp *azcore.Response) (*BastionShareableLinkListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getBastionShareableLinkHandleError(resp)
	}
	result := BastionShareableLinkListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.BastionShareableLinkListResult)
}

// getBastionShareableLinkHandleError handles the GetBastionShareableLink error response.
func (client *networkManagementClientOperations) getBastionShareableLinkHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutBastionShareableLink - Creates a Bastion Shareable Links for all the VMs specified in the request.
func (client *networkManagementClientOperations) BeginPutBastionShareableLink(ctx context.Context, resourceGroupName string, bastionHostName string, bslRequest BastionShareableLinkListRequest) (*BastionShareableLinkListResultPagerPollerResponse, error) {
	req, err := client.putBastionShareableLinkCreateRequest(resourceGroupName, bastionHostName, bslRequest)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putBastionShareableLinkHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("networkManagementClientOperations.PutBastionShareableLink", "location", resp, client.putBastionShareableLinkHandleError)
	if err != nil {
		return nil, err
	}
	poller := &bastionShareableLinkListResultPagerPoller{
		pt:          pt,
		respHandler: client.bastionShareableLinkListResultPagerHandleResponse,
		pipeline:    client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (BastionShareableLinkListResultPager, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *networkManagementClientOperations) ResumePutBastionShareableLink(token string) (BastionShareableLinkListResultPagerPoller, error) {
	pt, err := resumePollingTracker("networkManagementClientOperations.PutBastionShareableLink", token, client.putBastionShareableLinkHandleError)
	if err != nil {
		return nil, err
	}
	return &bastionShareableLinkListResultPagerPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// putBastionShareableLinkCreateRequest creates the PutBastionShareableLink request.
func (client *networkManagementClientOperations) putBastionShareableLinkCreateRequest(resourceGroupName string, bastionHostName string, bslRequest BastionShareableLinkListRequest) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/createShareableLinks"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{bastionHostName}", url.PathEscape(bastionHostName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2020-03-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(bslRequest)
}

// putBastionShareableLinkHandleResponse handles the PutBastionShareableLink response.
func (client *networkManagementClientOperations) putBastionShareableLinkHandleResponse(resp *azcore.Response) (*BastionShareableLinkListResultPagerPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.putBastionShareableLinkHandleError(resp)
	}
	return &BastionShareableLinkListResultPagerPollerResponse{RawResponse: resp.Response}, nil
}

// putBastionShareableLinkHandleResponse handles the PutBastionShareableLink response.
func (client *networkManagementClientOperations) bastionShareableLinkListResultPagerHandleResponse(resp *azcore.Response) (*BastionShareableLinkListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusOK) {
		return nil, client.putBastionShareableLinkHandleError(resp)
	}
	result := BastionShareableLinkListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.BastionShareableLinkListResult)
}

// putBastionShareableLinkHandleError handles the PutBastionShareableLink error response.
func (client *networkManagementClientOperations) putBastionShareableLinkHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// SupportedSecurityProviders - Gives the supported security providers for the virtual wan.
func (client *networkManagementClientOperations) SupportedSecurityProviders(ctx context.Context, resourceGroupName string, virtualWanName string) (*VirtualWanSecurityProvidersResponse, error) {
	req, err := client.supportedSecurityProvidersCreateRequest(resourceGroupName, virtualWanName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.supportedSecurityProvidersHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// supportedSecurityProvidersCreateRequest creates the SupportedSecurityProviders request.
func (client *networkManagementClientOperations) supportedSecurityProvidersCreateRequest(resourceGroupName string, virtualWanName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/supportedSecurityProviders"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{virtualWANName}", url.PathEscape(virtualWanName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2020-03-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// supportedSecurityProvidersHandleResponse handles the SupportedSecurityProviders response.
func (client *networkManagementClientOperations) supportedSecurityProvidersHandleResponse(resp *azcore.Response) (*VirtualWanSecurityProvidersResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.supportedSecurityProvidersHandleError(resp)
	}
	result := VirtualWanSecurityProvidersResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualWanSecurityProviders)
}

// supportedSecurityProvidersHandleError handles the SupportedSecurityProviders error response.
func (client *networkManagementClientOperations) supportedSecurityProvidersHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}
