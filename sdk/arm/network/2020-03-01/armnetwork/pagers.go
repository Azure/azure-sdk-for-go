// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// ApplicationGatewayAvailableSslPredefinedPoliciesPager provides iteration over ApplicationGatewayAvailableSslPredefinedPolicies pages.
type ApplicationGatewayAvailableSslPredefinedPoliciesPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ApplicationGatewayAvailableSslPredefinedPoliciesResponse.
	PageResponse() *ApplicationGatewayAvailableSslPredefinedPoliciesResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type applicationGatewayAvailableSslPredefinedPoliciesHandleResponse func(*azcore.Response) (*ApplicationGatewayAvailableSslPredefinedPoliciesResponse, error)

type applicationGatewayAvailableSslPredefinedPoliciesAdvancePage func(*ApplicationGatewayAvailableSslPredefinedPoliciesResponse) (*azcore.Request, error)

type applicationGatewayAvailableSslPredefinedPoliciesPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder applicationGatewayAvailableSslPredefinedPoliciesHandleResponse
	// callback for advancing to the next page
	advancer applicationGatewayAvailableSslPredefinedPoliciesAdvancePage
	// contains the current response
	current *ApplicationGatewayAvailableSslPredefinedPoliciesResponse
	// any error encountered
	err error
}

func (p *applicationGatewayAvailableSslPredefinedPoliciesPager) Err() error {
	return p.err
}

func (p *applicationGatewayAvailableSslPredefinedPoliciesPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ApplicationGatewayAvailableSslPredefinedPolicies.NextLink == nil || len(*p.current.ApplicationGatewayAvailableSslPredefinedPolicies.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *applicationGatewayAvailableSslPredefinedPoliciesPager) PageResponse() *ApplicationGatewayAvailableSslPredefinedPoliciesResponse {
	return p.current
}

// ApplicationGatewayListResultPager provides iteration over ApplicationGatewayListResult pages.
type ApplicationGatewayListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ApplicationGatewayListResultResponse.
	PageResponse() *ApplicationGatewayListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type applicationGatewayListResultHandleResponse func(*azcore.Response) (*ApplicationGatewayListResultResponse, error)

type applicationGatewayListResultAdvancePage func(*ApplicationGatewayListResultResponse) (*azcore.Request, error)

type applicationGatewayListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder applicationGatewayListResultHandleResponse
	// callback for advancing to the next page
	advancer applicationGatewayListResultAdvancePage
	// contains the current response
	current *ApplicationGatewayListResultResponse
	// any error encountered
	err error
}

func (p *applicationGatewayListResultPager) Err() error {
	return p.err
}

func (p *applicationGatewayListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ApplicationGatewayListResult.NextLink == nil || len(*p.current.ApplicationGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *applicationGatewayListResultPager) PageResponse() *ApplicationGatewayListResultResponse {
	return p.current
}

// ApplicationSecurityGroupListResultPager provides iteration over ApplicationSecurityGroupListResult pages.
type ApplicationSecurityGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ApplicationSecurityGroupListResultResponse.
	PageResponse() *ApplicationSecurityGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type applicationSecurityGroupListResultHandleResponse func(*azcore.Response) (*ApplicationSecurityGroupListResultResponse, error)

type applicationSecurityGroupListResultAdvancePage func(*ApplicationSecurityGroupListResultResponse) (*azcore.Request, error)

type applicationSecurityGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder applicationSecurityGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer applicationSecurityGroupListResultAdvancePage
	// contains the current response
	current *ApplicationSecurityGroupListResultResponse
	// any error encountered
	err error
}

func (p *applicationSecurityGroupListResultPager) Err() error {
	return p.err
}

func (p *applicationSecurityGroupListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ApplicationSecurityGroupListResult.NextLink == nil || len(*p.current.ApplicationSecurityGroupListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *applicationSecurityGroupListResultPager) PageResponse() *ApplicationSecurityGroupListResultResponse {
	return p.current
}

// AuthorizationListResultPager provides iteration over AuthorizationListResult pages.
type AuthorizationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AuthorizationListResultResponse.
	PageResponse() *AuthorizationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type authorizationListResultHandleResponse func(*azcore.Response) (*AuthorizationListResultResponse, error)

type authorizationListResultAdvancePage func(*AuthorizationListResultResponse) (*azcore.Request, error)

type authorizationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder authorizationListResultHandleResponse
	// callback for advancing to the next page
	advancer authorizationListResultAdvancePage
	// contains the current response
	current *AuthorizationListResultResponse
	// any error encountered
	err error
}

func (p *authorizationListResultPager) Err() error {
	return p.err
}

func (p *authorizationListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.AuthorizationListResult.NextLink == nil || len(*p.current.AuthorizationListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *authorizationListResultPager) PageResponse() *AuthorizationListResultResponse {
	return p.current
}

// AutoApprovedPrivateLinkServicesResultPager provides iteration over AutoApprovedPrivateLinkServicesResult pages.
type AutoApprovedPrivateLinkServicesResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AutoApprovedPrivateLinkServicesResultResponse.
	PageResponse() *AutoApprovedPrivateLinkServicesResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type autoApprovedPrivateLinkServicesResultHandleResponse func(*azcore.Response) (*AutoApprovedPrivateLinkServicesResultResponse, error)

type autoApprovedPrivateLinkServicesResultAdvancePage func(*AutoApprovedPrivateLinkServicesResultResponse) (*azcore.Request, error)

type autoApprovedPrivateLinkServicesResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder autoApprovedPrivateLinkServicesResultHandleResponse
	// callback for advancing to the next page
	advancer autoApprovedPrivateLinkServicesResultAdvancePage
	// contains the current response
	current *AutoApprovedPrivateLinkServicesResultResponse
	// any error encountered
	err error
}

func (p *autoApprovedPrivateLinkServicesResultPager) Err() error {
	return p.err
}

func (p *autoApprovedPrivateLinkServicesResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.AutoApprovedPrivateLinkServicesResult.NextLink == nil || len(*p.current.AutoApprovedPrivateLinkServicesResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *autoApprovedPrivateLinkServicesResultPager) PageResponse() *AutoApprovedPrivateLinkServicesResultResponse {
	return p.current
}

// AvailableDelegationsResultPager provides iteration over AvailableDelegationsResult pages.
type AvailableDelegationsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AvailableDelegationsResultResponse.
	PageResponse() *AvailableDelegationsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type availableDelegationsResultHandleResponse func(*azcore.Response) (*AvailableDelegationsResultResponse, error)

type availableDelegationsResultAdvancePage func(*AvailableDelegationsResultResponse) (*azcore.Request, error)

type availableDelegationsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder availableDelegationsResultHandleResponse
	// callback for advancing to the next page
	advancer availableDelegationsResultAdvancePage
	// contains the current response
	current *AvailableDelegationsResultResponse
	// any error encountered
	err error
}

func (p *availableDelegationsResultPager) Err() error {
	return p.err
}

func (p *availableDelegationsResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.AvailableDelegationsResult.NextLink == nil || len(*p.current.AvailableDelegationsResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *availableDelegationsResultPager) PageResponse() *AvailableDelegationsResultResponse {
	return p.current
}

// AvailablePrivateEndpointTypesResultPager provides iteration over AvailablePrivateEndpointTypesResult pages.
type AvailablePrivateEndpointTypesResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AvailablePrivateEndpointTypesResultResponse.
	PageResponse() *AvailablePrivateEndpointTypesResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type availablePrivateEndpointTypesResultHandleResponse func(*azcore.Response) (*AvailablePrivateEndpointTypesResultResponse, error)

type availablePrivateEndpointTypesResultAdvancePage func(*AvailablePrivateEndpointTypesResultResponse) (*azcore.Request, error)

type availablePrivateEndpointTypesResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder availablePrivateEndpointTypesResultHandleResponse
	// callback for advancing to the next page
	advancer availablePrivateEndpointTypesResultAdvancePage
	// contains the current response
	current *AvailablePrivateEndpointTypesResultResponse
	// any error encountered
	err error
}

func (p *availablePrivateEndpointTypesResultPager) Err() error {
	return p.err
}

func (p *availablePrivateEndpointTypesResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.AvailablePrivateEndpointTypesResult.NextLink == nil || len(*p.current.AvailablePrivateEndpointTypesResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *availablePrivateEndpointTypesResultPager) PageResponse() *AvailablePrivateEndpointTypesResultResponse {
	return p.current
}

// AvailableServiceAliasesResultPager provides iteration over AvailableServiceAliasesResult pages.
type AvailableServiceAliasesResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AvailableServiceAliasesResultResponse.
	PageResponse() *AvailableServiceAliasesResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type availableServiceAliasesResultHandleResponse func(*azcore.Response) (*AvailableServiceAliasesResultResponse, error)

type availableServiceAliasesResultAdvancePage func(*AvailableServiceAliasesResultResponse) (*azcore.Request, error)

type availableServiceAliasesResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder availableServiceAliasesResultHandleResponse
	// callback for advancing to the next page
	advancer availableServiceAliasesResultAdvancePage
	// contains the current response
	current *AvailableServiceAliasesResultResponse
	// any error encountered
	err error
}

func (p *availableServiceAliasesResultPager) Err() error {
	return p.err
}

func (p *availableServiceAliasesResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.AvailableServiceAliasesResult.NextLink == nil || len(*p.current.AvailableServiceAliasesResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *availableServiceAliasesResultPager) PageResponse() *AvailableServiceAliasesResultResponse {
	return p.current
}

// AzureFirewallFqdnTagListResultPager provides iteration over AzureFirewallFqdnTagListResult pages.
type AzureFirewallFqdnTagListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AzureFirewallFqdnTagListResultResponse.
	PageResponse() *AzureFirewallFqdnTagListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type azureFirewallFqdnTagListResultHandleResponse func(*azcore.Response) (*AzureFirewallFqdnTagListResultResponse, error)

type azureFirewallFqdnTagListResultAdvancePage func(*AzureFirewallFqdnTagListResultResponse) (*azcore.Request, error)

type azureFirewallFqdnTagListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder azureFirewallFqdnTagListResultHandleResponse
	// callback for advancing to the next page
	advancer azureFirewallFqdnTagListResultAdvancePage
	// contains the current response
	current *AzureFirewallFqdnTagListResultResponse
	// any error encountered
	err error
}

func (p *azureFirewallFqdnTagListResultPager) Err() error {
	return p.err
}

func (p *azureFirewallFqdnTagListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.AzureFirewallFqdnTagListResult.NextLink == nil || len(*p.current.AzureFirewallFqdnTagListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *azureFirewallFqdnTagListResultPager) PageResponse() *AzureFirewallFqdnTagListResultResponse {
	return p.current
}

// AzureFirewallListResultPager provides iteration over AzureFirewallListResult pages.
type AzureFirewallListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AzureFirewallListResultResponse.
	PageResponse() *AzureFirewallListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type azureFirewallListResultHandleResponse func(*azcore.Response) (*AzureFirewallListResultResponse, error)

type azureFirewallListResultAdvancePage func(*AzureFirewallListResultResponse) (*azcore.Request, error)

type azureFirewallListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder azureFirewallListResultHandleResponse
	// callback for advancing to the next page
	advancer azureFirewallListResultAdvancePage
	// contains the current response
	current *AzureFirewallListResultResponse
	// any error encountered
	err error
}

func (p *azureFirewallListResultPager) Err() error {
	return p.err
}

func (p *azureFirewallListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.AzureFirewallListResult.NextLink == nil || len(*p.current.AzureFirewallListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *azureFirewallListResultPager) PageResponse() *AzureFirewallListResultResponse {
	return p.current
}

// BastionActiveSessionListResultPager provides iteration over BastionActiveSessionListResult pages.
type BastionActiveSessionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current BastionActiveSessionListResultResponse.
	PageResponse() *BastionActiveSessionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type bastionActiveSessionListResultHandleResponse func(*azcore.Response) (*BastionActiveSessionListResultResponse, error)

type bastionActiveSessionListResultAdvancePage func(*BastionActiveSessionListResultResponse) (*azcore.Request, error)

type bastionActiveSessionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder bastionActiveSessionListResultHandleResponse
	// callback for advancing to the next page
	advancer bastionActiveSessionListResultAdvancePage
	// contains the current response
	current *BastionActiveSessionListResultResponse
	// any error encountered
	err error
	// previous response from the endpoint
	resp *azcore.Response
}

func (p *bastionActiveSessionListResultPager) Err() error {
	return p.err
}

func (p *bastionActiveSessionListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.BastionActiveSessionListResult.NextLink == nil || len(*p.current.BastionActiveSessionListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp := p.resp
	var err error
	if resp == nil {
		resp, err = p.pipeline.Do(ctx, p.request)
	} else {
		p.resp = nil
	}
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *bastionActiveSessionListResultPager) PageResponse() *BastionActiveSessionListResultResponse {
	return p.current
}

// BastionHostListResultPager provides iteration over BastionHostListResult pages.
type BastionHostListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current BastionHostListResultResponse.
	PageResponse() *BastionHostListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type bastionHostListResultHandleResponse func(*azcore.Response) (*BastionHostListResultResponse, error)

type bastionHostListResultAdvancePage func(*BastionHostListResultResponse) (*azcore.Request, error)

type bastionHostListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder bastionHostListResultHandleResponse
	// callback for advancing to the next page
	advancer bastionHostListResultAdvancePage
	// contains the current response
	current *BastionHostListResultResponse
	// any error encountered
	err error
}

func (p *bastionHostListResultPager) Err() error {
	return p.err
}

func (p *bastionHostListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.BastionHostListResult.NextLink == nil || len(*p.current.BastionHostListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *bastionHostListResultPager) PageResponse() *BastionHostListResultResponse {
	return p.current
}

// BastionSessionDeleteResultPager provides iteration over BastionSessionDeleteResult pages.
type BastionSessionDeleteResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current BastionSessionDeleteResultResponse.
	PageResponse() *BastionSessionDeleteResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type bastionSessionDeleteResultHandleResponse func(*azcore.Response) (*BastionSessionDeleteResultResponse, error)

type bastionSessionDeleteResultAdvancePage func(*BastionSessionDeleteResultResponse) (*azcore.Request, error)

type bastionSessionDeleteResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder bastionSessionDeleteResultHandleResponse
	// callback for advancing to the next page
	advancer bastionSessionDeleteResultAdvancePage
	// contains the current response
	current *BastionSessionDeleteResultResponse
	// any error encountered
	err error
}

func (p *bastionSessionDeleteResultPager) Err() error {
	return p.err
}

func (p *bastionSessionDeleteResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.BastionSessionDeleteResult.NextLink == nil || len(*p.current.BastionSessionDeleteResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *bastionSessionDeleteResultPager) PageResponse() *BastionSessionDeleteResultResponse {
	return p.current
}

// BastionShareableLinkListResultPager provides iteration over BastionShareableLinkListResult pages.
type BastionShareableLinkListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current BastionShareableLinkListResultResponse.
	PageResponse() *BastionShareableLinkListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type bastionShareableLinkListResultHandleResponse func(*azcore.Response) (*BastionShareableLinkListResultResponse, error)

type bastionShareableLinkListResultAdvancePage func(*BastionShareableLinkListResultResponse) (*azcore.Request, error)

type bastionShareableLinkListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder bastionShareableLinkListResultHandleResponse
	// callback for advancing to the next page
	advancer bastionShareableLinkListResultAdvancePage
	// contains the current response
	current *BastionShareableLinkListResultResponse
	// any error encountered
	err error
	// previous response from the endpoint
	resp *azcore.Response
}

func (p *bastionShareableLinkListResultPager) Err() error {
	return p.err
}

func (p *bastionShareableLinkListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.BastionShareableLinkListResult.NextLink == nil || len(*p.current.BastionShareableLinkListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp := p.resp
	var err error
	if resp == nil {
		resp, err = p.pipeline.Do(ctx, p.request)
	} else {
		p.resp = nil
	}
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *bastionShareableLinkListResultPager) PageResponse() *BastionShareableLinkListResultResponse {
	return p.current
}

// BgpServiceCommunityListResultPager provides iteration over BgpServiceCommunityListResult pages.
type BgpServiceCommunityListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current BgpServiceCommunityListResultResponse.
	PageResponse() *BgpServiceCommunityListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type bgpServiceCommunityListResultHandleResponse func(*azcore.Response) (*BgpServiceCommunityListResultResponse, error)

type bgpServiceCommunityListResultAdvancePage func(*BgpServiceCommunityListResultResponse) (*azcore.Request, error)

type bgpServiceCommunityListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder bgpServiceCommunityListResultHandleResponse
	// callback for advancing to the next page
	advancer bgpServiceCommunityListResultAdvancePage
	// contains the current response
	current *BgpServiceCommunityListResultResponse
	// any error encountered
	err error
}

func (p *bgpServiceCommunityListResultPager) Err() error {
	return p.err
}

func (p *bgpServiceCommunityListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.BgpServiceCommunityListResult.NextLink == nil || len(*p.current.BgpServiceCommunityListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *bgpServiceCommunityListResultPager) PageResponse() *BgpServiceCommunityListResultResponse {
	return p.current
}

// DdosProtectionPlanListResultPager provides iteration over DdosProtectionPlanListResult pages.
type DdosProtectionPlanListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current DdosProtectionPlanListResultResponse.
	PageResponse() *DdosProtectionPlanListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type ddosProtectionPlanListResultHandleResponse func(*azcore.Response) (*DdosProtectionPlanListResultResponse, error)

type ddosProtectionPlanListResultAdvancePage func(*DdosProtectionPlanListResultResponse) (*azcore.Request, error)

type ddosProtectionPlanListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder ddosProtectionPlanListResultHandleResponse
	// callback for advancing to the next page
	advancer ddosProtectionPlanListResultAdvancePage
	// contains the current response
	current *DdosProtectionPlanListResultResponse
	// any error encountered
	err error
}

func (p *ddosProtectionPlanListResultPager) Err() error {
	return p.err
}

func (p *ddosProtectionPlanListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.DdosProtectionPlanListResult.NextLink == nil || len(*p.current.DdosProtectionPlanListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *ddosProtectionPlanListResultPager) PageResponse() *DdosProtectionPlanListResultResponse {
	return p.current
}

// EndpointServicesListResultPager provides iteration over EndpointServicesListResult pages.
type EndpointServicesListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current EndpointServicesListResultResponse.
	PageResponse() *EndpointServicesListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type endpointServicesListResultHandleResponse func(*azcore.Response) (*EndpointServicesListResultResponse, error)

type endpointServicesListResultAdvancePage func(*EndpointServicesListResultResponse) (*azcore.Request, error)

type endpointServicesListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder endpointServicesListResultHandleResponse
	// callback for advancing to the next page
	advancer endpointServicesListResultAdvancePage
	// contains the current response
	current *EndpointServicesListResultResponse
	// any error encountered
	err error
}

func (p *endpointServicesListResultPager) Err() error {
	return p.err
}

func (p *endpointServicesListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.EndpointServicesListResult.NextLink == nil || len(*p.current.EndpointServicesListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *endpointServicesListResultPager) PageResponse() *EndpointServicesListResultResponse {
	return p.current
}

// ExpressRouteCircuitConnectionListResultPager provides iteration over ExpressRouteCircuitConnectionListResult pages.
type ExpressRouteCircuitConnectionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteCircuitConnectionListResultResponse.
	PageResponse() *ExpressRouteCircuitConnectionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteCircuitConnectionListResultHandleResponse func(*azcore.Response) (*ExpressRouteCircuitConnectionListResultResponse, error)

type expressRouteCircuitConnectionListResultAdvancePage func(*ExpressRouteCircuitConnectionListResultResponse) (*azcore.Request, error)

type expressRouteCircuitConnectionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder expressRouteCircuitConnectionListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRouteCircuitConnectionListResultAdvancePage
	// contains the current response
	current *ExpressRouteCircuitConnectionListResultResponse
	// any error encountered
	err error
}

func (p *expressRouteCircuitConnectionListResultPager) Err() error {
	return p.err
}

func (p *expressRouteCircuitConnectionListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ExpressRouteCircuitConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteCircuitConnectionListResultPager) PageResponse() *ExpressRouteCircuitConnectionListResultResponse {
	return p.current
}

// ExpressRouteCircuitListResultPager provides iteration over ExpressRouteCircuitListResult pages.
type ExpressRouteCircuitListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteCircuitListResultResponse.
	PageResponse() *ExpressRouteCircuitListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteCircuitListResultHandleResponse func(*azcore.Response) (*ExpressRouteCircuitListResultResponse, error)

type expressRouteCircuitListResultAdvancePage func(*ExpressRouteCircuitListResultResponse) (*azcore.Request, error)

type expressRouteCircuitListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder expressRouteCircuitListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRouteCircuitListResultAdvancePage
	// contains the current response
	current *ExpressRouteCircuitListResultResponse
	// any error encountered
	err error
}

func (p *expressRouteCircuitListResultPager) Err() error {
	return p.err
}

func (p *expressRouteCircuitListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ExpressRouteCircuitListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteCircuitListResultPager) PageResponse() *ExpressRouteCircuitListResultResponse {
	return p.current
}

// ExpressRouteCircuitPeeringListResultPager provides iteration over ExpressRouteCircuitPeeringListResult pages.
type ExpressRouteCircuitPeeringListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteCircuitPeeringListResultResponse.
	PageResponse() *ExpressRouteCircuitPeeringListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteCircuitPeeringListResultHandleResponse func(*azcore.Response) (*ExpressRouteCircuitPeeringListResultResponse, error)

type expressRouteCircuitPeeringListResultAdvancePage func(*ExpressRouteCircuitPeeringListResultResponse) (*azcore.Request, error)

type expressRouteCircuitPeeringListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder expressRouteCircuitPeeringListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRouteCircuitPeeringListResultAdvancePage
	// contains the current response
	current *ExpressRouteCircuitPeeringListResultResponse
	// any error encountered
	err error
}

func (p *expressRouteCircuitPeeringListResultPager) Err() error {
	return p.err
}

func (p *expressRouteCircuitPeeringListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ExpressRouteCircuitPeeringListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitPeeringListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteCircuitPeeringListResultPager) PageResponse() *ExpressRouteCircuitPeeringListResultResponse {
	return p.current
}

// ExpressRouteCrossConnectionListResultPager provides iteration over ExpressRouteCrossConnectionListResult pages.
type ExpressRouteCrossConnectionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteCrossConnectionListResultResponse.
	PageResponse() *ExpressRouteCrossConnectionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteCrossConnectionListResultHandleResponse func(*azcore.Response) (*ExpressRouteCrossConnectionListResultResponse, error)

type expressRouteCrossConnectionListResultAdvancePage func(*ExpressRouteCrossConnectionListResultResponse) (*azcore.Request, error)

type expressRouteCrossConnectionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder expressRouteCrossConnectionListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRouteCrossConnectionListResultAdvancePage
	// contains the current response
	current *ExpressRouteCrossConnectionListResultResponse
	// any error encountered
	err error
}

func (p *expressRouteCrossConnectionListResultPager) Err() error {
	return p.err
}

func (p *expressRouteCrossConnectionListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ExpressRouteCrossConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteCrossConnectionListResultPager) PageResponse() *ExpressRouteCrossConnectionListResultResponse {
	return p.current
}

// ExpressRouteCrossConnectionPeeringListPager provides iteration over ExpressRouteCrossConnectionPeeringList pages.
type ExpressRouteCrossConnectionPeeringListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteCrossConnectionPeeringListResponse.
	PageResponse() *ExpressRouteCrossConnectionPeeringListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteCrossConnectionPeeringListHandleResponse func(*azcore.Response) (*ExpressRouteCrossConnectionPeeringListResponse, error)

type expressRouteCrossConnectionPeeringListAdvancePage func(*ExpressRouteCrossConnectionPeeringListResponse) (*azcore.Request, error)

type expressRouteCrossConnectionPeeringListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder expressRouteCrossConnectionPeeringListHandleResponse
	// callback for advancing to the next page
	advancer expressRouteCrossConnectionPeeringListAdvancePage
	// contains the current response
	current *ExpressRouteCrossConnectionPeeringListResponse
	// any error encountered
	err error
}

func (p *expressRouteCrossConnectionPeeringListPager) Err() error {
	return p.err
}

func (p *expressRouteCrossConnectionPeeringListPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ExpressRouteCrossConnectionPeeringList.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionPeeringList.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteCrossConnectionPeeringListPager) PageResponse() *ExpressRouteCrossConnectionPeeringListResponse {
	return p.current
}

// ExpressRouteLinkListResultPager provides iteration over ExpressRouteLinkListResult pages.
type ExpressRouteLinkListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteLinkListResultResponse.
	PageResponse() *ExpressRouteLinkListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteLinkListResultHandleResponse func(*azcore.Response) (*ExpressRouteLinkListResultResponse, error)

type expressRouteLinkListResultAdvancePage func(*ExpressRouteLinkListResultResponse) (*azcore.Request, error)

type expressRouteLinkListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder expressRouteLinkListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRouteLinkListResultAdvancePage
	// contains the current response
	current *ExpressRouteLinkListResultResponse
	// any error encountered
	err error
}

func (p *expressRouteLinkListResultPager) Err() error {
	return p.err
}

func (p *expressRouteLinkListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ExpressRouteLinkListResult.NextLink == nil || len(*p.current.ExpressRouteLinkListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteLinkListResultPager) PageResponse() *ExpressRouteLinkListResultResponse {
	return p.current
}

// ExpressRoutePortListResultPager provides iteration over ExpressRoutePortListResult pages.
type ExpressRoutePortListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRoutePortListResultResponse.
	PageResponse() *ExpressRoutePortListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRoutePortListResultHandleResponse func(*azcore.Response) (*ExpressRoutePortListResultResponse, error)

type expressRoutePortListResultAdvancePage func(*ExpressRoutePortListResultResponse) (*azcore.Request, error)

type expressRoutePortListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder expressRoutePortListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRoutePortListResultAdvancePage
	// contains the current response
	current *ExpressRoutePortListResultResponse
	// any error encountered
	err error
}

func (p *expressRoutePortListResultPager) Err() error {
	return p.err
}

func (p *expressRoutePortListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ExpressRoutePortListResult.NextLink == nil || len(*p.current.ExpressRoutePortListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRoutePortListResultPager) PageResponse() *ExpressRoutePortListResultResponse {
	return p.current
}

// ExpressRoutePortsLocationListResultPager provides iteration over ExpressRoutePortsLocationListResult pages.
type ExpressRoutePortsLocationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRoutePortsLocationListResultResponse.
	PageResponse() *ExpressRoutePortsLocationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRoutePortsLocationListResultHandleResponse func(*azcore.Response) (*ExpressRoutePortsLocationListResultResponse, error)

type expressRoutePortsLocationListResultAdvancePage func(*ExpressRoutePortsLocationListResultResponse) (*azcore.Request, error)

type expressRoutePortsLocationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder expressRoutePortsLocationListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRoutePortsLocationListResultAdvancePage
	// contains the current response
	current *ExpressRoutePortsLocationListResultResponse
	// any error encountered
	err error
}

func (p *expressRoutePortsLocationListResultPager) Err() error {
	return p.err
}

func (p *expressRoutePortsLocationListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ExpressRoutePortsLocationListResult.NextLink == nil || len(*p.current.ExpressRoutePortsLocationListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRoutePortsLocationListResultPager) PageResponse() *ExpressRoutePortsLocationListResultResponse {
	return p.current
}

// ExpressRouteServiceProviderListResultPager provides iteration over ExpressRouteServiceProviderListResult pages.
type ExpressRouteServiceProviderListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteServiceProviderListResultResponse.
	PageResponse() *ExpressRouteServiceProviderListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteServiceProviderListResultHandleResponse func(*azcore.Response) (*ExpressRouteServiceProviderListResultResponse, error)

type expressRouteServiceProviderListResultAdvancePage func(*ExpressRouteServiceProviderListResultResponse) (*azcore.Request, error)

type expressRouteServiceProviderListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder expressRouteServiceProviderListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRouteServiceProviderListResultAdvancePage
	// contains the current response
	current *ExpressRouteServiceProviderListResultResponse
	// any error encountered
	err error
}

func (p *expressRouteServiceProviderListResultPager) Err() error {
	return p.err
}

func (p *expressRouteServiceProviderListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ExpressRouteServiceProviderListResult.NextLink == nil || len(*p.current.ExpressRouteServiceProviderListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteServiceProviderListResultPager) PageResponse() *ExpressRouteServiceProviderListResultResponse {
	return p.current
}

// FirewallPolicyListResultPager provides iteration over FirewallPolicyListResult pages.
type FirewallPolicyListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current FirewallPolicyListResultResponse.
	PageResponse() *FirewallPolicyListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type firewallPolicyListResultHandleResponse func(*azcore.Response) (*FirewallPolicyListResultResponse, error)

type firewallPolicyListResultAdvancePage func(*FirewallPolicyListResultResponse) (*azcore.Request, error)

type firewallPolicyListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder firewallPolicyListResultHandleResponse
	// callback for advancing to the next page
	advancer firewallPolicyListResultAdvancePage
	// contains the current response
	current *FirewallPolicyListResultResponse
	// any error encountered
	err error
}

func (p *firewallPolicyListResultPager) Err() error {
	return p.err
}

func (p *firewallPolicyListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.FirewallPolicyListResult.NextLink == nil || len(*p.current.FirewallPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *firewallPolicyListResultPager) PageResponse() *FirewallPolicyListResultResponse {
	return p.current
}

// FirewallPolicyRuleGroupListResultPager provides iteration over FirewallPolicyRuleGroupListResult pages.
type FirewallPolicyRuleGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current FirewallPolicyRuleGroupListResultResponse.
	PageResponse() *FirewallPolicyRuleGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type firewallPolicyRuleGroupListResultHandleResponse func(*azcore.Response) (*FirewallPolicyRuleGroupListResultResponse, error)

type firewallPolicyRuleGroupListResultAdvancePage func(*FirewallPolicyRuleGroupListResultResponse) (*azcore.Request, error)

type firewallPolicyRuleGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder firewallPolicyRuleGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer firewallPolicyRuleGroupListResultAdvancePage
	// contains the current response
	current *FirewallPolicyRuleGroupListResultResponse
	// any error encountered
	err error
}

func (p *firewallPolicyRuleGroupListResultPager) Err() error {
	return p.err
}

func (p *firewallPolicyRuleGroupListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.FirewallPolicyRuleGroupListResult.NextLink == nil || len(*p.current.FirewallPolicyRuleGroupListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *firewallPolicyRuleGroupListResultPager) PageResponse() *FirewallPolicyRuleGroupListResultResponse {
	return p.current
}

// FlowLogListResultPager provides iteration over FlowLogListResult pages.
type FlowLogListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current FlowLogListResultResponse.
	PageResponse() *FlowLogListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type flowLogListResultHandleResponse func(*azcore.Response) (*FlowLogListResultResponse, error)

type flowLogListResultAdvancePage func(*FlowLogListResultResponse) (*azcore.Request, error)

type flowLogListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder flowLogListResultHandleResponse
	// callback for advancing to the next page
	advancer flowLogListResultAdvancePage
	// contains the current response
	current *FlowLogListResultResponse
	// any error encountered
	err error
}

func (p *flowLogListResultPager) Err() error {
	return p.err
}

func (p *flowLogListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.FlowLogListResult.NextLink == nil || len(*p.current.FlowLogListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *flowLogListResultPager) PageResponse() *FlowLogListResultResponse {
	return p.current
}

// IPAllocationListResultPager provides iteration over IPAllocationListResult pages.
type IPAllocationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current IPAllocationListResultResponse.
	PageResponse() *IPAllocationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type ipAllocationListResultHandleResponse func(*azcore.Response) (*IPAllocationListResultResponse, error)

type ipAllocationListResultAdvancePage func(*IPAllocationListResultResponse) (*azcore.Request, error)

type ipAllocationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder ipAllocationListResultHandleResponse
	// callback for advancing to the next page
	advancer ipAllocationListResultAdvancePage
	// contains the current response
	current *IPAllocationListResultResponse
	// any error encountered
	err error
}

func (p *ipAllocationListResultPager) Err() error {
	return p.err
}

func (p *ipAllocationListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.IPAllocationListResult.NextLink == nil || len(*p.current.IPAllocationListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *ipAllocationListResultPager) PageResponse() *IPAllocationListResultResponse {
	return p.current
}

// IPGroupListResultPager provides iteration over IPGroupListResult pages.
type IPGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current IPGroupListResultResponse.
	PageResponse() *IPGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type ipGroupListResultHandleResponse func(*azcore.Response) (*IPGroupListResultResponse, error)

type ipGroupListResultAdvancePage func(*IPGroupListResultResponse) (*azcore.Request, error)

type ipGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder ipGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer ipGroupListResultAdvancePage
	// contains the current response
	current *IPGroupListResultResponse
	// any error encountered
	err error
}

func (p *ipGroupListResultPager) Err() error {
	return p.err
}

func (p *ipGroupListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.IPGroupListResult.NextLink == nil || len(*p.current.IPGroupListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *ipGroupListResultPager) PageResponse() *IPGroupListResultResponse {
	return p.current
}

// InboundNatRuleListResultPager provides iteration over InboundNatRuleListResult pages.
type InboundNatRuleListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current InboundNatRuleListResultResponse.
	PageResponse() *InboundNatRuleListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type inboundNatRuleListResultHandleResponse func(*azcore.Response) (*InboundNatRuleListResultResponse, error)

type inboundNatRuleListResultAdvancePage func(*InboundNatRuleListResultResponse) (*azcore.Request, error)

type inboundNatRuleListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder inboundNatRuleListResultHandleResponse
	// callback for advancing to the next page
	advancer inboundNatRuleListResultAdvancePage
	// contains the current response
	current *InboundNatRuleListResultResponse
	// any error encountered
	err error
}

func (p *inboundNatRuleListResultPager) Err() error {
	return p.err
}

func (p *inboundNatRuleListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.InboundNatRuleListResult.NextLink == nil || len(*p.current.InboundNatRuleListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *inboundNatRuleListResultPager) PageResponse() *InboundNatRuleListResultResponse {
	return p.current
}

// ListHubVirtualNetworkConnectionsResultPager provides iteration over ListHubVirtualNetworkConnectionsResult pages.
type ListHubVirtualNetworkConnectionsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListHubVirtualNetworkConnectionsResultResponse.
	PageResponse() *ListHubVirtualNetworkConnectionsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listHubVirtualNetworkConnectionsResultHandleResponse func(*azcore.Response) (*ListHubVirtualNetworkConnectionsResultResponse, error)

type listHubVirtualNetworkConnectionsResultAdvancePage func(*ListHubVirtualNetworkConnectionsResultResponse) (*azcore.Request, error)

type listHubVirtualNetworkConnectionsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder listHubVirtualNetworkConnectionsResultHandleResponse
	// callback for advancing to the next page
	advancer listHubVirtualNetworkConnectionsResultAdvancePage
	// contains the current response
	current *ListHubVirtualNetworkConnectionsResultResponse
	// any error encountered
	err error
}

func (p *listHubVirtualNetworkConnectionsResultPager) Err() error {
	return p.err
}

func (p *listHubVirtualNetworkConnectionsResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ListHubVirtualNetworkConnectionsResult.NextLink == nil || len(*p.current.ListHubVirtualNetworkConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listHubVirtualNetworkConnectionsResultPager) PageResponse() *ListHubVirtualNetworkConnectionsResultResponse {
	return p.current
}

// ListP2SVpnGatewaysResultPager provides iteration over ListP2SVpnGatewaysResult pages.
type ListP2SVpnGatewaysResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListP2SVpnGatewaysResultResponse.
	PageResponse() *ListP2SVpnGatewaysResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listP2SVpnGatewaysResultHandleResponse func(*azcore.Response) (*ListP2SVpnGatewaysResultResponse, error)

type listP2SVpnGatewaysResultAdvancePage func(*ListP2SVpnGatewaysResultResponse) (*azcore.Request, error)

type listP2SVpnGatewaysResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder listP2SVpnGatewaysResultHandleResponse
	// callback for advancing to the next page
	advancer listP2SVpnGatewaysResultAdvancePage
	// contains the current response
	current *ListP2SVpnGatewaysResultResponse
	// any error encountered
	err error
}

func (p *listP2SVpnGatewaysResultPager) Err() error {
	return p.err
}

func (p *listP2SVpnGatewaysResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ListP2SVpnGatewaysResult.NextLink == nil || len(*p.current.ListP2SVpnGatewaysResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listP2SVpnGatewaysResultPager) PageResponse() *ListP2SVpnGatewaysResultResponse {
	return p.current
}

// ListVirtualHubRouteTableV2SResultPager provides iteration over ListVirtualHubRouteTableV2SResult pages.
type ListVirtualHubRouteTableV2SResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVirtualHubRouteTableV2SResultResponse.
	PageResponse() *ListVirtualHubRouteTableV2SResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVirtualHubRouteTableV2SResultHandleResponse func(*azcore.Response) (*ListVirtualHubRouteTableV2SResultResponse, error)

type listVirtualHubRouteTableV2SResultAdvancePage func(*ListVirtualHubRouteTableV2SResultResponse) (*azcore.Request, error)

type listVirtualHubRouteTableV2SResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder listVirtualHubRouteTableV2SResultHandleResponse
	// callback for advancing to the next page
	advancer listVirtualHubRouteTableV2SResultAdvancePage
	// contains the current response
	current *ListVirtualHubRouteTableV2SResultResponse
	// any error encountered
	err error
}

func (p *listVirtualHubRouteTableV2SResultPager) Err() error {
	return p.err
}

func (p *listVirtualHubRouteTableV2SResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ListVirtualHubRouteTableV2SResult.NextLink == nil || len(*p.current.ListVirtualHubRouteTableV2SResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVirtualHubRouteTableV2SResultPager) PageResponse() *ListVirtualHubRouteTableV2SResultResponse {
	return p.current
}

// ListVirtualHubsResultPager provides iteration over ListVirtualHubsResult pages.
type ListVirtualHubsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVirtualHubsResultResponse.
	PageResponse() *ListVirtualHubsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVirtualHubsResultHandleResponse func(*azcore.Response) (*ListVirtualHubsResultResponse, error)

type listVirtualHubsResultAdvancePage func(*ListVirtualHubsResultResponse) (*azcore.Request, error)

type listVirtualHubsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder listVirtualHubsResultHandleResponse
	// callback for advancing to the next page
	advancer listVirtualHubsResultAdvancePage
	// contains the current response
	current *ListVirtualHubsResultResponse
	// any error encountered
	err error
}

func (p *listVirtualHubsResultPager) Err() error {
	return p.err
}

func (p *listVirtualHubsResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ListVirtualHubsResult.NextLink == nil || len(*p.current.ListVirtualHubsResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVirtualHubsResultPager) PageResponse() *ListVirtualHubsResultResponse {
	return p.current
}

// ListVirtualWaNsResultPager provides iteration over ListVirtualWaNsResult pages.
type ListVirtualWaNsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVirtualWaNsResultResponse.
	PageResponse() *ListVirtualWaNsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVirtualWaNsResultHandleResponse func(*azcore.Response) (*ListVirtualWaNsResultResponse, error)

type listVirtualWaNsResultAdvancePage func(*ListVirtualWaNsResultResponse) (*azcore.Request, error)

type listVirtualWaNsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder listVirtualWaNsResultHandleResponse
	// callback for advancing to the next page
	advancer listVirtualWaNsResultAdvancePage
	// contains the current response
	current *ListVirtualWaNsResultResponse
	// any error encountered
	err error
}

func (p *listVirtualWaNsResultPager) Err() error {
	return p.err
}

func (p *listVirtualWaNsResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ListVirtualWaNsResult.NextLink == nil || len(*p.current.ListVirtualWaNsResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVirtualWaNsResultPager) PageResponse() *ListVirtualWaNsResultResponse {
	return p.current
}

// ListVpnConnectionsResultPager provides iteration over ListVpnConnectionsResult pages.
type ListVpnConnectionsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVpnConnectionsResultResponse.
	PageResponse() *ListVpnConnectionsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVpnConnectionsResultHandleResponse func(*azcore.Response) (*ListVpnConnectionsResultResponse, error)

type listVpnConnectionsResultAdvancePage func(*ListVpnConnectionsResultResponse) (*azcore.Request, error)

type listVpnConnectionsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder listVpnConnectionsResultHandleResponse
	// callback for advancing to the next page
	advancer listVpnConnectionsResultAdvancePage
	// contains the current response
	current *ListVpnConnectionsResultResponse
	// any error encountered
	err error
}

func (p *listVpnConnectionsResultPager) Err() error {
	return p.err
}

func (p *listVpnConnectionsResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ListVpnConnectionsResult.NextLink == nil || len(*p.current.ListVpnConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVpnConnectionsResultPager) PageResponse() *ListVpnConnectionsResultResponse {
	return p.current
}

// ListVpnGatewaysResultPager provides iteration over ListVpnGatewaysResult pages.
type ListVpnGatewaysResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVpnGatewaysResultResponse.
	PageResponse() *ListVpnGatewaysResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVpnGatewaysResultHandleResponse func(*azcore.Response) (*ListVpnGatewaysResultResponse, error)

type listVpnGatewaysResultAdvancePage func(*ListVpnGatewaysResultResponse) (*azcore.Request, error)

type listVpnGatewaysResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder listVpnGatewaysResultHandleResponse
	// callback for advancing to the next page
	advancer listVpnGatewaysResultAdvancePage
	// contains the current response
	current *ListVpnGatewaysResultResponse
	// any error encountered
	err error
}

func (p *listVpnGatewaysResultPager) Err() error {
	return p.err
}

func (p *listVpnGatewaysResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ListVpnGatewaysResult.NextLink == nil || len(*p.current.ListVpnGatewaysResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVpnGatewaysResultPager) PageResponse() *ListVpnGatewaysResultResponse {
	return p.current
}

// ListVpnServerConfigurationsResultPager provides iteration over ListVpnServerConfigurationsResult pages.
type ListVpnServerConfigurationsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVpnServerConfigurationsResultResponse.
	PageResponse() *ListVpnServerConfigurationsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVpnServerConfigurationsResultHandleResponse func(*azcore.Response) (*ListVpnServerConfigurationsResultResponse, error)

type listVpnServerConfigurationsResultAdvancePage func(*ListVpnServerConfigurationsResultResponse) (*azcore.Request, error)

type listVpnServerConfigurationsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder listVpnServerConfigurationsResultHandleResponse
	// callback for advancing to the next page
	advancer listVpnServerConfigurationsResultAdvancePage
	// contains the current response
	current *ListVpnServerConfigurationsResultResponse
	// any error encountered
	err error
}

func (p *listVpnServerConfigurationsResultPager) Err() error {
	return p.err
}

func (p *listVpnServerConfigurationsResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ListVpnServerConfigurationsResult.NextLink == nil || len(*p.current.ListVpnServerConfigurationsResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVpnServerConfigurationsResultPager) PageResponse() *ListVpnServerConfigurationsResultResponse {
	return p.current
}

// ListVpnSiteLinkConnectionsResultPager provides iteration over ListVpnSiteLinkConnectionsResult pages.
type ListVpnSiteLinkConnectionsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVpnSiteLinkConnectionsResultResponse.
	PageResponse() *ListVpnSiteLinkConnectionsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVpnSiteLinkConnectionsResultHandleResponse func(*azcore.Response) (*ListVpnSiteLinkConnectionsResultResponse, error)

type listVpnSiteLinkConnectionsResultAdvancePage func(*ListVpnSiteLinkConnectionsResultResponse) (*azcore.Request, error)

type listVpnSiteLinkConnectionsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder listVpnSiteLinkConnectionsResultHandleResponse
	// callback for advancing to the next page
	advancer listVpnSiteLinkConnectionsResultAdvancePage
	// contains the current response
	current *ListVpnSiteLinkConnectionsResultResponse
	// any error encountered
	err error
}

func (p *listVpnSiteLinkConnectionsResultPager) Err() error {
	return p.err
}

func (p *listVpnSiteLinkConnectionsResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ListVpnSiteLinkConnectionsResult.NextLink == nil || len(*p.current.ListVpnSiteLinkConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVpnSiteLinkConnectionsResultPager) PageResponse() *ListVpnSiteLinkConnectionsResultResponse {
	return p.current
}

// ListVpnSiteLinksResultPager provides iteration over ListVpnSiteLinksResult pages.
type ListVpnSiteLinksResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVpnSiteLinksResultResponse.
	PageResponse() *ListVpnSiteLinksResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVpnSiteLinksResultHandleResponse func(*azcore.Response) (*ListVpnSiteLinksResultResponse, error)

type listVpnSiteLinksResultAdvancePage func(*ListVpnSiteLinksResultResponse) (*azcore.Request, error)

type listVpnSiteLinksResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder listVpnSiteLinksResultHandleResponse
	// callback for advancing to the next page
	advancer listVpnSiteLinksResultAdvancePage
	// contains the current response
	current *ListVpnSiteLinksResultResponse
	// any error encountered
	err error
}

func (p *listVpnSiteLinksResultPager) Err() error {
	return p.err
}

func (p *listVpnSiteLinksResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ListVpnSiteLinksResult.NextLink == nil || len(*p.current.ListVpnSiteLinksResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVpnSiteLinksResultPager) PageResponse() *ListVpnSiteLinksResultResponse {
	return p.current
}

// ListVpnSitesResultPager provides iteration over ListVpnSitesResult pages.
type ListVpnSitesResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVpnSitesResultResponse.
	PageResponse() *ListVpnSitesResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVpnSitesResultHandleResponse func(*azcore.Response) (*ListVpnSitesResultResponse, error)

type listVpnSitesResultAdvancePage func(*ListVpnSitesResultResponse) (*azcore.Request, error)

type listVpnSitesResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder listVpnSitesResultHandleResponse
	// callback for advancing to the next page
	advancer listVpnSitesResultAdvancePage
	// contains the current response
	current *ListVpnSitesResultResponse
	// any error encountered
	err error
}

func (p *listVpnSitesResultPager) Err() error {
	return p.err
}

func (p *listVpnSitesResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ListVpnSitesResult.NextLink == nil || len(*p.current.ListVpnSitesResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVpnSitesResultPager) PageResponse() *ListVpnSitesResultResponse {
	return p.current
}

// LoadBalancerBackendAddressPoolListResultPager provides iteration over LoadBalancerBackendAddressPoolListResult pages.
type LoadBalancerBackendAddressPoolListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LoadBalancerBackendAddressPoolListResultResponse.
	PageResponse() *LoadBalancerBackendAddressPoolListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type loadBalancerBackendAddressPoolListResultHandleResponse func(*azcore.Response) (*LoadBalancerBackendAddressPoolListResultResponse, error)

type loadBalancerBackendAddressPoolListResultAdvancePage func(*LoadBalancerBackendAddressPoolListResultResponse) (*azcore.Request, error)

type loadBalancerBackendAddressPoolListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder loadBalancerBackendAddressPoolListResultHandleResponse
	// callback for advancing to the next page
	advancer loadBalancerBackendAddressPoolListResultAdvancePage
	// contains the current response
	current *LoadBalancerBackendAddressPoolListResultResponse
	// any error encountered
	err error
}

func (p *loadBalancerBackendAddressPoolListResultPager) Err() error {
	return p.err
}

func (p *loadBalancerBackendAddressPoolListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.LoadBalancerBackendAddressPoolListResult.NextLink == nil || len(*p.current.LoadBalancerBackendAddressPoolListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *loadBalancerBackendAddressPoolListResultPager) PageResponse() *LoadBalancerBackendAddressPoolListResultResponse {
	return p.current
}

// LoadBalancerFrontendIPConfigurationListResultPager provides iteration over LoadBalancerFrontendIPConfigurationListResult pages.
type LoadBalancerFrontendIPConfigurationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LoadBalancerFrontendIPConfigurationListResultResponse.
	PageResponse() *LoadBalancerFrontendIPConfigurationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type loadBalancerFrontendIPConfigurationListResultHandleResponse func(*azcore.Response) (*LoadBalancerFrontendIPConfigurationListResultResponse, error)

type loadBalancerFrontendIPConfigurationListResultAdvancePage func(*LoadBalancerFrontendIPConfigurationListResultResponse) (*azcore.Request, error)

type loadBalancerFrontendIPConfigurationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder loadBalancerFrontendIPConfigurationListResultHandleResponse
	// callback for advancing to the next page
	advancer loadBalancerFrontendIPConfigurationListResultAdvancePage
	// contains the current response
	current *LoadBalancerFrontendIPConfigurationListResultResponse
	// any error encountered
	err error
}

func (p *loadBalancerFrontendIPConfigurationListResultPager) Err() error {
	return p.err
}

func (p *loadBalancerFrontendIPConfigurationListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.LoadBalancerFrontendIPConfigurationListResult.NextLink == nil || len(*p.current.LoadBalancerFrontendIPConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *loadBalancerFrontendIPConfigurationListResultPager) PageResponse() *LoadBalancerFrontendIPConfigurationListResultResponse {
	return p.current
}

// LoadBalancerListResultPager provides iteration over LoadBalancerListResult pages.
type LoadBalancerListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LoadBalancerListResultResponse.
	PageResponse() *LoadBalancerListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type loadBalancerListResultHandleResponse func(*azcore.Response) (*LoadBalancerListResultResponse, error)

type loadBalancerListResultAdvancePage func(*LoadBalancerListResultResponse) (*azcore.Request, error)

type loadBalancerListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder loadBalancerListResultHandleResponse
	// callback for advancing to the next page
	advancer loadBalancerListResultAdvancePage
	// contains the current response
	current *LoadBalancerListResultResponse
	// any error encountered
	err error
}

func (p *loadBalancerListResultPager) Err() error {
	return p.err
}

func (p *loadBalancerListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.LoadBalancerListResult.NextLink == nil || len(*p.current.LoadBalancerListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *loadBalancerListResultPager) PageResponse() *LoadBalancerListResultResponse {
	return p.current
}

// LoadBalancerLoadBalancingRuleListResultPager provides iteration over LoadBalancerLoadBalancingRuleListResult pages.
type LoadBalancerLoadBalancingRuleListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LoadBalancerLoadBalancingRuleListResultResponse.
	PageResponse() *LoadBalancerLoadBalancingRuleListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type loadBalancerLoadBalancingRuleListResultHandleResponse func(*azcore.Response) (*LoadBalancerLoadBalancingRuleListResultResponse, error)

type loadBalancerLoadBalancingRuleListResultAdvancePage func(*LoadBalancerLoadBalancingRuleListResultResponse) (*azcore.Request, error)

type loadBalancerLoadBalancingRuleListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder loadBalancerLoadBalancingRuleListResultHandleResponse
	// callback for advancing to the next page
	advancer loadBalancerLoadBalancingRuleListResultAdvancePage
	// contains the current response
	current *LoadBalancerLoadBalancingRuleListResultResponse
	// any error encountered
	err error
}

func (p *loadBalancerLoadBalancingRuleListResultPager) Err() error {
	return p.err
}

func (p *loadBalancerLoadBalancingRuleListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.LoadBalancerLoadBalancingRuleListResult.NextLink == nil || len(*p.current.LoadBalancerLoadBalancingRuleListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *loadBalancerLoadBalancingRuleListResultPager) PageResponse() *LoadBalancerLoadBalancingRuleListResultResponse {
	return p.current
}

// LoadBalancerOutboundRuleListResultPager provides iteration over LoadBalancerOutboundRuleListResult pages.
type LoadBalancerOutboundRuleListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LoadBalancerOutboundRuleListResultResponse.
	PageResponse() *LoadBalancerOutboundRuleListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type loadBalancerOutboundRuleListResultHandleResponse func(*azcore.Response) (*LoadBalancerOutboundRuleListResultResponse, error)

type loadBalancerOutboundRuleListResultAdvancePage func(*LoadBalancerOutboundRuleListResultResponse) (*azcore.Request, error)

type loadBalancerOutboundRuleListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder loadBalancerOutboundRuleListResultHandleResponse
	// callback for advancing to the next page
	advancer loadBalancerOutboundRuleListResultAdvancePage
	// contains the current response
	current *LoadBalancerOutboundRuleListResultResponse
	// any error encountered
	err error
}

func (p *loadBalancerOutboundRuleListResultPager) Err() error {
	return p.err
}

func (p *loadBalancerOutboundRuleListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.LoadBalancerOutboundRuleListResult.NextLink == nil || len(*p.current.LoadBalancerOutboundRuleListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *loadBalancerOutboundRuleListResultPager) PageResponse() *LoadBalancerOutboundRuleListResultResponse {
	return p.current
}

// LoadBalancerProbeListResultPager provides iteration over LoadBalancerProbeListResult pages.
type LoadBalancerProbeListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LoadBalancerProbeListResultResponse.
	PageResponse() *LoadBalancerProbeListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type loadBalancerProbeListResultHandleResponse func(*azcore.Response) (*LoadBalancerProbeListResultResponse, error)

type loadBalancerProbeListResultAdvancePage func(*LoadBalancerProbeListResultResponse) (*azcore.Request, error)

type loadBalancerProbeListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder loadBalancerProbeListResultHandleResponse
	// callback for advancing to the next page
	advancer loadBalancerProbeListResultAdvancePage
	// contains the current response
	current *LoadBalancerProbeListResultResponse
	// any error encountered
	err error
}

func (p *loadBalancerProbeListResultPager) Err() error {
	return p.err
}

func (p *loadBalancerProbeListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.LoadBalancerProbeListResult.NextLink == nil || len(*p.current.LoadBalancerProbeListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *loadBalancerProbeListResultPager) PageResponse() *LoadBalancerProbeListResultResponse {
	return p.current
}

// LocalNetworkGatewayListResultPager provides iteration over LocalNetworkGatewayListResult pages.
type LocalNetworkGatewayListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LocalNetworkGatewayListResultResponse.
	PageResponse() *LocalNetworkGatewayListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type localNetworkGatewayListResultHandleResponse func(*azcore.Response) (*LocalNetworkGatewayListResultResponse, error)

type localNetworkGatewayListResultAdvancePage func(*LocalNetworkGatewayListResultResponse) (*azcore.Request, error)

type localNetworkGatewayListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder localNetworkGatewayListResultHandleResponse
	// callback for advancing to the next page
	advancer localNetworkGatewayListResultAdvancePage
	// contains the current response
	current *LocalNetworkGatewayListResultResponse
	// any error encountered
	err error
}

func (p *localNetworkGatewayListResultPager) Err() error {
	return p.err
}

func (p *localNetworkGatewayListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.LocalNetworkGatewayListResult.NextLink == nil || len(*p.current.LocalNetworkGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *localNetworkGatewayListResultPager) PageResponse() *LocalNetworkGatewayListResultResponse {
	return p.current
}

// NatGatewayListResultPager provides iteration over NatGatewayListResult pages.
type NatGatewayListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NatGatewayListResultResponse.
	PageResponse() *NatGatewayListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type natGatewayListResultHandleResponse func(*azcore.Response) (*NatGatewayListResultResponse, error)

type natGatewayListResultAdvancePage func(*NatGatewayListResultResponse) (*azcore.Request, error)

type natGatewayListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder natGatewayListResultHandleResponse
	// callback for advancing to the next page
	advancer natGatewayListResultAdvancePage
	// contains the current response
	current *NatGatewayListResultResponse
	// any error encountered
	err error
}

func (p *natGatewayListResultPager) Err() error {
	return p.err
}

func (p *natGatewayListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.NatGatewayListResult.NextLink == nil || len(*p.current.NatGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *natGatewayListResultPager) PageResponse() *NatGatewayListResultResponse {
	return p.current
}

// NetworkInterfaceIPConfigurationListResultPager provides iteration over NetworkInterfaceIPConfigurationListResult pages.
type NetworkInterfaceIPConfigurationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkInterfaceIPConfigurationListResultResponse.
	PageResponse() *NetworkInterfaceIPConfigurationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkInterfaceIPConfigurationListResultHandleResponse func(*azcore.Response) (*NetworkInterfaceIPConfigurationListResultResponse, error)

type networkInterfaceIPConfigurationListResultAdvancePage func(*NetworkInterfaceIPConfigurationListResultResponse) (*azcore.Request, error)

type networkInterfaceIPConfigurationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder networkInterfaceIPConfigurationListResultHandleResponse
	// callback for advancing to the next page
	advancer networkInterfaceIPConfigurationListResultAdvancePage
	// contains the current response
	current *NetworkInterfaceIPConfigurationListResultResponse
	// any error encountered
	err error
}

func (p *networkInterfaceIPConfigurationListResultPager) Err() error {
	return p.err
}

func (p *networkInterfaceIPConfigurationListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.NetworkInterfaceIPConfigurationListResult.NextLink == nil || len(*p.current.NetworkInterfaceIPConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkInterfaceIPConfigurationListResultPager) PageResponse() *NetworkInterfaceIPConfigurationListResultResponse {
	return p.current
}

// NetworkInterfaceListResultPager provides iteration over NetworkInterfaceListResult pages.
type NetworkInterfaceListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkInterfaceListResultResponse.
	PageResponse() *NetworkInterfaceListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkInterfaceListResultHandleResponse func(*azcore.Response) (*NetworkInterfaceListResultResponse, error)

type networkInterfaceListResultAdvancePage func(*NetworkInterfaceListResultResponse) (*azcore.Request, error)

type networkInterfaceListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder networkInterfaceListResultHandleResponse
	// callback for advancing to the next page
	advancer networkInterfaceListResultAdvancePage
	// contains the current response
	current *NetworkInterfaceListResultResponse
	// any error encountered
	err error
}

func (p *networkInterfaceListResultPager) Err() error {
	return p.err
}

func (p *networkInterfaceListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.NetworkInterfaceListResult.NextLink == nil || len(*p.current.NetworkInterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkInterfaceListResultPager) PageResponse() *NetworkInterfaceListResultResponse {
	return p.current
}

// NetworkInterfaceLoadBalancerListResultPager provides iteration over NetworkInterfaceLoadBalancerListResult pages.
type NetworkInterfaceLoadBalancerListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkInterfaceLoadBalancerListResultResponse.
	PageResponse() *NetworkInterfaceLoadBalancerListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkInterfaceLoadBalancerListResultHandleResponse func(*azcore.Response) (*NetworkInterfaceLoadBalancerListResultResponse, error)

type networkInterfaceLoadBalancerListResultAdvancePage func(*NetworkInterfaceLoadBalancerListResultResponse) (*azcore.Request, error)

type networkInterfaceLoadBalancerListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder networkInterfaceLoadBalancerListResultHandleResponse
	// callback for advancing to the next page
	advancer networkInterfaceLoadBalancerListResultAdvancePage
	// contains the current response
	current *NetworkInterfaceLoadBalancerListResultResponse
	// any error encountered
	err error
}

func (p *networkInterfaceLoadBalancerListResultPager) Err() error {
	return p.err
}

func (p *networkInterfaceLoadBalancerListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.NetworkInterfaceLoadBalancerListResult.NextLink == nil || len(*p.current.NetworkInterfaceLoadBalancerListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkInterfaceLoadBalancerListResultPager) PageResponse() *NetworkInterfaceLoadBalancerListResultResponse {
	return p.current
}

// NetworkInterfaceTapConfigurationListResultPager provides iteration over NetworkInterfaceTapConfigurationListResult pages.
type NetworkInterfaceTapConfigurationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkInterfaceTapConfigurationListResultResponse.
	PageResponse() *NetworkInterfaceTapConfigurationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkInterfaceTapConfigurationListResultHandleResponse func(*azcore.Response) (*NetworkInterfaceTapConfigurationListResultResponse, error)

type networkInterfaceTapConfigurationListResultAdvancePage func(*NetworkInterfaceTapConfigurationListResultResponse) (*azcore.Request, error)

type networkInterfaceTapConfigurationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder networkInterfaceTapConfigurationListResultHandleResponse
	// callback for advancing to the next page
	advancer networkInterfaceTapConfigurationListResultAdvancePage
	// contains the current response
	current *NetworkInterfaceTapConfigurationListResultResponse
	// any error encountered
	err error
}

func (p *networkInterfaceTapConfigurationListResultPager) Err() error {
	return p.err
}

func (p *networkInterfaceTapConfigurationListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.NetworkInterfaceTapConfigurationListResult.NextLink == nil || len(*p.current.NetworkInterfaceTapConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkInterfaceTapConfigurationListResultPager) PageResponse() *NetworkInterfaceTapConfigurationListResultResponse {
	return p.current
}

// NetworkProfileListResultPager provides iteration over NetworkProfileListResult pages.
type NetworkProfileListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkProfileListResultResponse.
	PageResponse() *NetworkProfileListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkProfileListResultHandleResponse func(*azcore.Response) (*NetworkProfileListResultResponse, error)

type networkProfileListResultAdvancePage func(*NetworkProfileListResultResponse) (*azcore.Request, error)

type networkProfileListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder networkProfileListResultHandleResponse
	// callback for advancing to the next page
	advancer networkProfileListResultAdvancePage
	// contains the current response
	current *NetworkProfileListResultResponse
	// any error encountered
	err error
}

func (p *networkProfileListResultPager) Err() error {
	return p.err
}

func (p *networkProfileListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.NetworkProfileListResult.NextLink == nil || len(*p.current.NetworkProfileListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkProfileListResultPager) PageResponse() *NetworkProfileListResultResponse {
	return p.current
}

// NetworkSecurityGroupListResultPager provides iteration over NetworkSecurityGroupListResult pages.
type NetworkSecurityGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkSecurityGroupListResultResponse.
	PageResponse() *NetworkSecurityGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkSecurityGroupListResultHandleResponse func(*azcore.Response) (*NetworkSecurityGroupListResultResponse, error)

type networkSecurityGroupListResultAdvancePage func(*NetworkSecurityGroupListResultResponse) (*azcore.Request, error)

type networkSecurityGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder networkSecurityGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer networkSecurityGroupListResultAdvancePage
	// contains the current response
	current *NetworkSecurityGroupListResultResponse
	// any error encountered
	err error
}

func (p *networkSecurityGroupListResultPager) Err() error {
	return p.err
}

func (p *networkSecurityGroupListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.NetworkSecurityGroupListResult.NextLink == nil || len(*p.current.NetworkSecurityGroupListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkSecurityGroupListResultPager) PageResponse() *NetworkSecurityGroupListResultResponse {
	return p.current
}

// NetworkVirtualApplianceListResultPager provides iteration over NetworkVirtualApplianceListResult pages.
type NetworkVirtualApplianceListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkVirtualApplianceListResultResponse.
	PageResponse() *NetworkVirtualApplianceListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkVirtualApplianceListResultHandleResponse func(*azcore.Response) (*NetworkVirtualApplianceListResultResponse, error)

type networkVirtualApplianceListResultAdvancePage func(*NetworkVirtualApplianceListResultResponse) (*azcore.Request, error)

type networkVirtualApplianceListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder networkVirtualApplianceListResultHandleResponse
	// callback for advancing to the next page
	advancer networkVirtualApplianceListResultAdvancePage
	// contains the current response
	current *NetworkVirtualApplianceListResultResponse
	// any error encountered
	err error
}

func (p *networkVirtualApplianceListResultPager) Err() error {
	return p.err
}

func (p *networkVirtualApplianceListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.NetworkVirtualApplianceListResult.NextLink == nil || len(*p.current.NetworkVirtualApplianceListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkVirtualApplianceListResultPager) PageResponse() *NetworkVirtualApplianceListResultResponse {
	return p.current
}

// OperationListResultPager provides iteration over OperationListResult pages.
type OperationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current OperationListResultResponse.
	PageResponse() *OperationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type operationListResultHandleResponse func(*azcore.Response) (*OperationListResultResponse, error)

type operationListResultAdvancePage func(*OperationListResultResponse) (*azcore.Request, error)

type operationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder operationListResultHandleResponse
	// callback for advancing to the next page
	advancer operationListResultAdvancePage
	// contains the current response
	current *OperationListResultResponse
	// any error encountered
	err error
}

func (p *operationListResultPager) Err() error {
	return p.err
}

func (p *operationListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *operationListResultPager) PageResponse() *OperationListResultResponse {
	return p.current
}

// PeerExpressRouteCircuitConnectionListResultPager provides iteration over PeerExpressRouteCircuitConnectionListResult pages.
type PeerExpressRouteCircuitConnectionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PeerExpressRouteCircuitConnectionListResultResponse.
	PageResponse() *PeerExpressRouteCircuitConnectionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type peerExpressRouteCircuitConnectionListResultHandleResponse func(*azcore.Response) (*PeerExpressRouteCircuitConnectionListResultResponse, error)

type peerExpressRouteCircuitConnectionListResultAdvancePage func(*PeerExpressRouteCircuitConnectionListResultResponse) (*azcore.Request, error)

type peerExpressRouteCircuitConnectionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder peerExpressRouteCircuitConnectionListResultHandleResponse
	// callback for advancing to the next page
	advancer peerExpressRouteCircuitConnectionListResultAdvancePage
	// contains the current response
	current *PeerExpressRouteCircuitConnectionListResultResponse
	// any error encountered
	err error
}

func (p *peerExpressRouteCircuitConnectionListResultPager) Err() error {
	return p.err
}

func (p *peerExpressRouteCircuitConnectionListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.PeerExpressRouteCircuitConnectionListResult.NextLink == nil || len(*p.current.PeerExpressRouteCircuitConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *peerExpressRouteCircuitConnectionListResultPager) PageResponse() *PeerExpressRouteCircuitConnectionListResultResponse {
	return p.current
}

// PrivateDNSZoneGroupListResultPager provides iteration over PrivateDNSZoneGroupListResult pages.
type PrivateDNSZoneGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PrivateDNSZoneGroupListResultResponse.
	PageResponse() *PrivateDNSZoneGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type privateDnsZoneGroupListResultHandleResponse func(*azcore.Response) (*PrivateDNSZoneGroupListResultResponse, error)

type privateDnsZoneGroupListResultAdvancePage func(*PrivateDNSZoneGroupListResultResponse) (*azcore.Request, error)

type privateDnsZoneGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder privateDnsZoneGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer privateDnsZoneGroupListResultAdvancePage
	// contains the current response
	current *PrivateDNSZoneGroupListResultResponse
	// any error encountered
	err error
}

func (p *privateDnsZoneGroupListResultPager) Err() error {
	return p.err
}

func (p *privateDnsZoneGroupListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.PrivateDNSZoneGroupListResult.NextLink == nil || len(*p.current.PrivateDNSZoneGroupListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *privateDnsZoneGroupListResultPager) PageResponse() *PrivateDNSZoneGroupListResultResponse {
	return p.current
}

// PrivateEndpointConnectionListResultPager provides iteration over PrivateEndpointConnectionListResult pages.
type PrivateEndpointConnectionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PrivateEndpointConnectionListResultResponse.
	PageResponse() *PrivateEndpointConnectionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type privateEndpointConnectionListResultHandleResponse func(*azcore.Response) (*PrivateEndpointConnectionListResultResponse, error)

type privateEndpointConnectionListResultAdvancePage func(*PrivateEndpointConnectionListResultResponse) (*azcore.Request, error)

type privateEndpointConnectionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder privateEndpointConnectionListResultHandleResponse
	// callback for advancing to the next page
	advancer privateEndpointConnectionListResultAdvancePage
	// contains the current response
	current *PrivateEndpointConnectionListResultResponse
	// any error encountered
	err error
}

func (p *privateEndpointConnectionListResultPager) Err() error {
	return p.err
}

func (p *privateEndpointConnectionListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.PrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.PrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *privateEndpointConnectionListResultPager) PageResponse() *PrivateEndpointConnectionListResultResponse {
	return p.current
}

// PrivateEndpointListResultPager provides iteration over PrivateEndpointListResult pages.
type PrivateEndpointListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PrivateEndpointListResultResponse.
	PageResponse() *PrivateEndpointListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type privateEndpointListResultHandleResponse func(*azcore.Response) (*PrivateEndpointListResultResponse, error)

type privateEndpointListResultAdvancePage func(*PrivateEndpointListResultResponse) (*azcore.Request, error)

type privateEndpointListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder privateEndpointListResultHandleResponse
	// callback for advancing to the next page
	advancer privateEndpointListResultAdvancePage
	// contains the current response
	current *PrivateEndpointListResultResponse
	// any error encountered
	err error
}

func (p *privateEndpointListResultPager) Err() error {
	return p.err
}

func (p *privateEndpointListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.PrivateEndpointListResult.NextLink == nil || len(*p.current.PrivateEndpointListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *privateEndpointListResultPager) PageResponse() *PrivateEndpointListResultResponse {
	return p.current
}

// PrivateLinkServiceListResultPager provides iteration over PrivateLinkServiceListResult pages.
type PrivateLinkServiceListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PrivateLinkServiceListResultResponse.
	PageResponse() *PrivateLinkServiceListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type privateLinkServiceListResultHandleResponse func(*azcore.Response) (*PrivateLinkServiceListResultResponse, error)

type privateLinkServiceListResultAdvancePage func(*PrivateLinkServiceListResultResponse) (*azcore.Request, error)

type privateLinkServiceListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder privateLinkServiceListResultHandleResponse
	// callback for advancing to the next page
	advancer privateLinkServiceListResultAdvancePage
	// contains the current response
	current *PrivateLinkServiceListResultResponse
	// any error encountered
	err error
}

func (p *privateLinkServiceListResultPager) Err() error {
	return p.err
}

func (p *privateLinkServiceListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.PrivateLinkServiceListResult.NextLink == nil || len(*p.current.PrivateLinkServiceListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *privateLinkServiceListResultPager) PageResponse() *PrivateLinkServiceListResultResponse {
	return p.current
}

// PublicIPAddressListResultPager provides iteration over PublicIPAddressListResult pages.
type PublicIPAddressListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PublicIPAddressListResultResponse.
	PageResponse() *PublicIPAddressListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type publicIPAddressListResultHandleResponse func(*azcore.Response) (*PublicIPAddressListResultResponse, error)

type publicIPAddressListResultAdvancePage func(*PublicIPAddressListResultResponse) (*azcore.Request, error)

type publicIPAddressListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder publicIPAddressListResultHandleResponse
	// callback for advancing to the next page
	advancer publicIPAddressListResultAdvancePage
	// contains the current response
	current *PublicIPAddressListResultResponse
	// any error encountered
	err error
}

func (p *publicIPAddressListResultPager) Err() error {
	return p.err
}

func (p *publicIPAddressListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *publicIPAddressListResultPager) PageResponse() *PublicIPAddressListResultResponse {
	return p.current
}

// PublicIPPrefixListResultPager provides iteration over PublicIPPrefixListResult pages.
type PublicIPPrefixListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PublicIPPrefixListResultResponse.
	PageResponse() *PublicIPPrefixListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type publicIPPrefixListResultHandleResponse func(*azcore.Response) (*PublicIPPrefixListResultResponse, error)

type publicIPPrefixListResultAdvancePage func(*PublicIPPrefixListResultResponse) (*azcore.Request, error)

type publicIPPrefixListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder publicIPPrefixListResultHandleResponse
	// callback for advancing to the next page
	advancer publicIPPrefixListResultAdvancePage
	// contains the current response
	current *PublicIPPrefixListResultResponse
	// any error encountered
	err error
}

func (p *publicIPPrefixListResultPager) Err() error {
	return p.err
}

func (p *publicIPPrefixListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.PublicIPPrefixListResult.NextLink == nil || len(*p.current.PublicIPPrefixListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *publicIPPrefixListResultPager) PageResponse() *PublicIPPrefixListResultResponse {
	return p.current
}

// RouteFilterListResultPager provides iteration over RouteFilterListResult pages.
type RouteFilterListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current RouteFilterListResultResponse.
	PageResponse() *RouteFilterListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type routeFilterListResultHandleResponse func(*azcore.Response) (*RouteFilterListResultResponse, error)

type routeFilterListResultAdvancePage func(*RouteFilterListResultResponse) (*azcore.Request, error)

type routeFilterListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder routeFilterListResultHandleResponse
	// callback for advancing to the next page
	advancer routeFilterListResultAdvancePage
	// contains the current response
	current *RouteFilterListResultResponse
	// any error encountered
	err error
}

func (p *routeFilterListResultPager) Err() error {
	return p.err
}

func (p *routeFilterListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.RouteFilterListResult.NextLink == nil || len(*p.current.RouteFilterListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *routeFilterListResultPager) PageResponse() *RouteFilterListResultResponse {
	return p.current
}

// RouteFilterRuleListResultPager provides iteration over RouteFilterRuleListResult pages.
type RouteFilterRuleListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current RouteFilterRuleListResultResponse.
	PageResponse() *RouteFilterRuleListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type routeFilterRuleListResultHandleResponse func(*azcore.Response) (*RouteFilterRuleListResultResponse, error)

type routeFilterRuleListResultAdvancePage func(*RouteFilterRuleListResultResponse) (*azcore.Request, error)

type routeFilterRuleListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder routeFilterRuleListResultHandleResponse
	// callback for advancing to the next page
	advancer routeFilterRuleListResultAdvancePage
	// contains the current response
	current *RouteFilterRuleListResultResponse
	// any error encountered
	err error
}

func (p *routeFilterRuleListResultPager) Err() error {
	return p.err
}

func (p *routeFilterRuleListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.RouteFilterRuleListResult.NextLink == nil || len(*p.current.RouteFilterRuleListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *routeFilterRuleListResultPager) PageResponse() *RouteFilterRuleListResultResponse {
	return p.current
}

// RouteListResultPager provides iteration over RouteListResult pages.
type RouteListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current RouteListResultResponse.
	PageResponse() *RouteListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type routeListResultHandleResponse func(*azcore.Response) (*RouteListResultResponse, error)

type routeListResultAdvancePage func(*RouteListResultResponse) (*azcore.Request, error)

type routeListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder routeListResultHandleResponse
	// callback for advancing to the next page
	advancer routeListResultAdvancePage
	// contains the current response
	current *RouteListResultResponse
	// any error encountered
	err error
}

func (p *routeListResultPager) Err() error {
	return p.err
}

func (p *routeListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.RouteListResult.NextLink == nil || len(*p.current.RouteListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *routeListResultPager) PageResponse() *RouteListResultResponse {
	return p.current
}

// RouteTableListResultPager provides iteration over RouteTableListResult pages.
type RouteTableListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current RouteTableListResultResponse.
	PageResponse() *RouteTableListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type routeTableListResultHandleResponse func(*azcore.Response) (*RouteTableListResultResponse, error)

type routeTableListResultAdvancePage func(*RouteTableListResultResponse) (*azcore.Request, error)

type routeTableListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder routeTableListResultHandleResponse
	// callback for advancing to the next page
	advancer routeTableListResultAdvancePage
	// contains the current response
	current *RouteTableListResultResponse
	// any error encountered
	err error
}

func (p *routeTableListResultPager) Err() error {
	return p.err
}

func (p *routeTableListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.RouteTableListResult.NextLink == nil || len(*p.current.RouteTableListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *routeTableListResultPager) PageResponse() *RouteTableListResultResponse {
	return p.current
}

// SecurityPartnerProviderListResultPager provides iteration over SecurityPartnerProviderListResult pages.
type SecurityPartnerProviderListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current SecurityPartnerProviderListResultResponse.
	PageResponse() *SecurityPartnerProviderListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type securityPartnerProviderListResultHandleResponse func(*azcore.Response) (*SecurityPartnerProviderListResultResponse, error)

type securityPartnerProviderListResultAdvancePage func(*SecurityPartnerProviderListResultResponse) (*azcore.Request, error)

type securityPartnerProviderListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder securityPartnerProviderListResultHandleResponse
	// callback for advancing to the next page
	advancer securityPartnerProviderListResultAdvancePage
	// contains the current response
	current *SecurityPartnerProviderListResultResponse
	// any error encountered
	err error
}

func (p *securityPartnerProviderListResultPager) Err() error {
	return p.err
}

func (p *securityPartnerProviderListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.SecurityPartnerProviderListResult.NextLink == nil || len(*p.current.SecurityPartnerProviderListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *securityPartnerProviderListResultPager) PageResponse() *SecurityPartnerProviderListResultResponse {
	return p.current
}

// SecurityRuleListResultPager provides iteration over SecurityRuleListResult pages.
type SecurityRuleListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current SecurityRuleListResultResponse.
	PageResponse() *SecurityRuleListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type securityRuleListResultHandleResponse func(*azcore.Response) (*SecurityRuleListResultResponse, error)

type securityRuleListResultAdvancePage func(*SecurityRuleListResultResponse) (*azcore.Request, error)

type securityRuleListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder securityRuleListResultHandleResponse
	// callback for advancing to the next page
	advancer securityRuleListResultAdvancePage
	// contains the current response
	current *SecurityRuleListResultResponse
	// any error encountered
	err error
}

func (p *securityRuleListResultPager) Err() error {
	return p.err
}

func (p *securityRuleListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.SecurityRuleListResult.NextLink == nil || len(*p.current.SecurityRuleListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *securityRuleListResultPager) PageResponse() *SecurityRuleListResultResponse {
	return p.current
}

// ServiceEndpointPolicyDefinitionListResultPager provides iteration over ServiceEndpointPolicyDefinitionListResult pages.
type ServiceEndpointPolicyDefinitionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ServiceEndpointPolicyDefinitionListResultResponse.
	PageResponse() *ServiceEndpointPolicyDefinitionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type serviceEndpointPolicyDefinitionListResultHandleResponse func(*azcore.Response) (*ServiceEndpointPolicyDefinitionListResultResponse, error)

type serviceEndpointPolicyDefinitionListResultAdvancePage func(*ServiceEndpointPolicyDefinitionListResultResponse) (*azcore.Request, error)

type serviceEndpointPolicyDefinitionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder serviceEndpointPolicyDefinitionListResultHandleResponse
	// callback for advancing to the next page
	advancer serviceEndpointPolicyDefinitionListResultAdvancePage
	// contains the current response
	current *ServiceEndpointPolicyDefinitionListResultResponse
	// any error encountered
	err error
}

func (p *serviceEndpointPolicyDefinitionListResultPager) Err() error {
	return p.err
}

func (p *serviceEndpointPolicyDefinitionListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ServiceEndpointPolicyDefinitionListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *serviceEndpointPolicyDefinitionListResultPager) PageResponse() *ServiceEndpointPolicyDefinitionListResultResponse {
	return p.current
}

// ServiceEndpointPolicyListResultPager provides iteration over ServiceEndpointPolicyListResult pages.
type ServiceEndpointPolicyListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ServiceEndpointPolicyListResultResponse.
	PageResponse() *ServiceEndpointPolicyListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type serviceEndpointPolicyListResultHandleResponse func(*azcore.Response) (*ServiceEndpointPolicyListResultResponse, error)

type serviceEndpointPolicyListResultAdvancePage func(*ServiceEndpointPolicyListResultResponse) (*azcore.Request, error)

type serviceEndpointPolicyListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder serviceEndpointPolicyListResultHandleResponse
	// callback for advancing to the next page
	advancer serviceEndpointPolicyListResultAdvancePage
	// contains the current response
	current *ServiceEndpointPolicyListResultResponse
	// any error encountered
	err error
}

func (p *serviceEndpointPolicyListResultPager) Err() error {
	return p.err
}

func (p *serviceEndpointPolicyListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.ServiceEndpointPolicyListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *serviceEndpointPolicyListResultPager) PageResponse() *ServiceEndpointPolicyListResultResponse {
	return p.current
}

// SubnetListResultPager provides iteration over SubnetListResult pages.
type SubnetListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current SubnetListResultResponse.
	PageResponse() *SubnetListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type subnetListResultHandleResponse func(*azcore.Response) (*SubnetListResultResponse, error)

type subnetListResultAdvancePage func(*SubnetListResultResponse) (*azcore.Request, error)

type subnetListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder subnetListResultHandleResponse
	// callback for advancing to the next page
	advancer subnetListResultAdvancePage
	// contains the current response
	current *SubnetListResultResponse
	// any error encountered
	err error
}

func (p *subnetListResultPager) Err() error {
	return p.err
}

func (p *subnetListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.SubnetListResult.NextLink == nil || len(*p.current.SubnetListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *subnetListResultPager) PageResponse() *SubnetListResultResponse {
	return p.current
}

// UsagesListResultPager provides iteration over UsagesListResult pages.
type UsagesListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current UsagesListResultResponse.
	PageResponse() *UsagesListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type usagesListResultHandleResponse func(*azcore.Response) (*UsagesListResultResponse, error)

type usagesListResultAdvancePage func(*UsagesListResultResponse) (*azcore.Request, error)

type usagesListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder usagesListResultHandleResponse
	// callback for advancing to the next page
	advancer usagesListResultAdvancePage
	// contains the current response
	current *UsagesListResultResponse
	// any error encountered
	err error
}

func (p *usagesListResultPager) Err() error {
	return p.err
}

func (p *usagesListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *usagesListResultPager) PageResponse() *UsagesListResultResponse {
	return p.current
}

// VirtualNetworkGatewayConnectionListResultPager provides iteration over VirtualNetworkGatewayConnectionListResult pages.
type VirtualNetworkGatewayConnectionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkGatewayConnectionListResultResponse.
	PageResponse() *VirtualNetworkGatewayConnectionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkGatewayConnectionListResultHandleResponse func(*azcore.Response) (*VirtualNetworkGatewayConnectionListResultResponse, error)

type virtualNetworkGatewayConnectionListResultAdvancePage func(*VirtualNetworkGatewayConnectionListResultResponse) (*azcore.Request, error)

type virtualNetworkGatewayConnectionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualNetworkGatewayConnectionListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkGatewayConnectionListResultAdvancePage
	// contains the current response
	current *VirtualNetworkGatewayConnectionListResultResponse
	// any error encountered
	err error
}

func (p *virtualNetworkGatewayConnectionListResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkGatewayConnectionListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualNetworkGatewayConnectionListResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkGatewayConnectionListResultPager) PageResponse() *VirtualNetworkGatewayConnectionListResultResponse {
	return p.current
}

// VirtualNetworkGatewayListConnectionsResultPager provides iteration over VirtualNetworkGatewayListConnectionsResult pages.
type VirtualNetworkGatewayListConnectionsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkGatewayListConnectionsResultResponse.
	PageResponse() *VirtualNetworkGatewayListConnectionsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkGatewayListConnectionsResultHandleResponse func(*azcore.Response) (*VirtualNetworkGatewayListConnectionsResultResponse, error)

type virtualNetworkGatewayListConnectionsResultAdvancePage func(*VirtualNetworkGatewayListConnectionsResultResponse) (*azcore.Request, error)

type virtualNetworkGatewayListConnectionsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualNetworkGatewayListConnectionsResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkGatewayListConnectionsResultAdvancePage
	// contains the current response
	current *VirtualNetworkGatewayListConnectionsResultResponse
	// any error encountered
	err error
}

func (p *virtualNetworkGatewayListConnectionsResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkGatewayListConnectionsResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualNetworkGatewayListConnectionsResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayListConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkGatewayListConnectionsResultPager) PageResponse() *VirtualNetworkGatewayListConnectionsResultResponse {
	return p.current
}

// VirtualNetworkGatewayListResultPager provides iteration over VirtualNetworkGatewayListResult pages.
type VirtualNetworkGatewayListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkGatewayListResultResponse.
	PageResponse() *VirtualNetworkGatewayListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkGatewayListResultHandleResponse func(*azcore.Response) (*VirtualNetworkGatewayListResultResponse, error)

type virtualNetworkGatewayListResultAdvancePage func(*VirtualNetworkGatewayListResultResponse) (*azcore.Request, error)

type virtualNetworkGatewayListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualNetworkGatewayListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkGatewayListResultAdvancePage
	// contains the current response
	current *VirtualNetworkGatewayListResultResponse
	// any error encountered
	err error
}

func (p *virtualNetworkGatewayListResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkGatewayListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualNetworkGatewayListResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkGatewayListResultPager) PageResponse() *VirtualNetworkGatewayListResultResponse {
	return p.current
}

// VirtualNetworkListResultPager provides iteration over VirtualNetworkListResult pages.
type VirtualNetworkListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkListResultResponse.
	PageResponse() *VirtualNetworkListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkListResultHandleResponse func(*azcore.Response) (*VirtualNetworkListResultResponse, error)

type virtualNetworkListResultAdvancePage func(*VirtualNetworkListResultResponse) (*azcore.Request, error)

type virtualNetworkListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualNetworkListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkListResultAdvancePage
	// contains the current response
	current *VirtualNetworkListResultResponse
	// any error encountered
	err error
}

func (p *virtualNetworkListResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualNetworkListResult.NextLink == nil || len(*p.current.VirtualNetworkListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkListResultPager) PageResponse() *VirtualNetworkListResultResponse {
	return p.current
}

// VirtualNetworkListUsageResultPager provides iteration over VirtualNetworkListUsageResult pages.
type VirtualNetworkListUsageResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkListUsageResultResponse.
	PageResponse() *VirtualNetworkListUsageResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkListUsageResultHandleResponse func(*azcore.Response) (*VirtualNetworkListUsageResultResponse, error)

type virtualNetworkListUsageResultAdvancePage func(*VirtualNetworkListUsageResultResponse) (*azcore.Request, error)

type virtualNetworkListUsageResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualNetworkListUsageResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkListUsageResultAdvancePage
	// contains the current response
	current *VirtualNetworkListUsageResultResponse
	// any error encountered
	err error
}

func (p *virtualNetworkListUsageResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkListUsageResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualNetworkListUsageResult.NextLink == nil || len(*p.current.VirtualNetworkListUsageResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkListUsageResultPager) PageResponse() *VirtualNetworkListUsageResultResponse {
	return p.current
}

// VirtualNetworkPeeringListResultPager provides iteration over VirtualNetworkPeeringListResult pages.
type VirtualNetworkPeeringListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkPeeringListResultResponse.
	PageResponse() *VirtualNetworkPeeringListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkPeeringListResultHandleResponse func(*azcore.Response) (*VirtualNetworkPeeringListResultResponse, error)

type virtualNetworkPeeringListResultAdvancePage func(*VirtualNetworkPeeringListResultResponse) (*azcore.Request, error)

type virtualNetworkPeeringListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualNetworkPeeringListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkPeeringListResultAdvancePage
	// contains the current response
	current *VirtualNetworkPeeringListResultResponse
	// any error encountered
	err error
}

func (p *virtualNetworkPeeringListResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkPeeringListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualNetworkPeeringListResult.NextLink == nil || len(*p.current.VirtualNetworkPeeringListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkPeeringListResultPager) PageResponse() *VirtualNetworkPeeringListResultResponse {
	return p.current
}

// VirtualNetworkTapListResultPager provides iteration over VirtualNetworkTapListResult pages.
type VirtualNetworkTapListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkTapListResultResponse.
	PageResponse() *VirtualNetworkTapListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkTapListResultHandleResponse func(*azcore.Response) (*VirtualNetworkTapListResultResponse, error)

type virtualNetworkTapListResultAdvancePage func(*VirtualNetworkTapListResultResponse) (*azcore.Request, error)

type virtualNetworkTapListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualNetworkTapListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkTapListResultAdvancePage
	// contains the current response
	current *VirtualNetworkTapListResultResponse
	// any error encountered
	err error
}

func (p *virtualNetworkTapListResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkTapListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualNetworkTapListResult.NextLink == nil || len(*p.current.VirtualNetworkTapListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkTapListResultPager) PageResponse() *VirtualNetworkTapListResultResponse {
	return p.current
}

// VirtualRouterListResultPager provides iteration over VirtualRouterListResult pages.
type VirtualRouterListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualRouterListResultResponse.
	PageResponse() *VirtualRouterListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualRouterListResultHandleResponse func(*azcore.Response) (*VirtualRouterListResultResponse, error)

type virtualRouterListResultAdvancePage func(*VirtualRouterListResultResponse) (*azcore.Request, error)

type virtualRouterListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualRouterListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualRouterListResultAdvancePage
	// contains the current response
	current *VirtualRouterListResultResponse
	// any error encountered
	err error
}

func (p *virtualRouterListResultPager) Err() error {
	return p.err
}

func (p *virtualRouterListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualRouterListResult.NextLink == nil || len(*p.current.VirtualRouterListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualRouterListResultPager) PageResponse() *VirtualRouterListResultResponse {
	return p.current
}

// VirtualRouterPeeringListResultPager provides iteration over VirtualRouterPeeringListResult pages.
type VirtualRouterPeeringListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualRouterPeeringListResultResponse.
	PageResponse() *VirtualRouterPeeringListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualRouterPeeringListResultHandleResponse func(*azcore.Response) (*VirtualRouterPeeringListResultResponse, error)

type virtualRouterPeeringListResultAdvancePage func(*VirtualRouterPeeringListResultResponse) (*azcore.Request, error)

type virtualRouterPeeringListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder virtualRouterPeeringListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualRouterPeeringListResultAdvancePage
	// contains the current response
	current *VirtualRouterPeeringListResultResponse
	// any error encountered
	err error
}

func (p *virtualRouterPeeringListResultPager) Err() error {
	return p.err
}

func (p *virtualRouterPeeringListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.VirtualRouterPeeringListResult.NextLink == nil || len(*p.current.VirtualRouterPeeringListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualRouterPeeringListResultPager) PageResponse() *VirtualRouterPeeringListResultResponse {
	return p.current
}

// WebApplicationFirewallPolicyListResultPager provides iteration over WebApplicationFirewallPolicyListResult pages.
type WebApplicationFirewallPolicyListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current WebApplicationFirewallPolicyListResultResponse.
	PageResponse() *WebApplicationFirewallPolicyListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type webApplicationFirewallPolicyListResultHandleResponse func(*azcore.Response) (*WebApplicationFirewallPolicyListResultResponse, error)

type webApplicationFirewallPolicyListResultAdvancePage func(*WebApplicationFirewallPolicyListResultResponse) (*azcore.Request, error)

type webApplicationFirewallPolicyListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// contains the pending request
	request *azcore.Request
	// callback for handling the HTTP response
	responder webApplicationFirewallPolicyListResultHandleResponse
	// callback for advancing to the next page
	advancer webApplicationFirewallPolicyListResultAdvancePage
	// contains the current response
	current *WebApplicationFirewallPolicyListResultResponse
	// any error encountered
	err error
}

func (p *webApplicationFirewallPolicyListResultPager) Err() error {
	return p.err
}

func (p *webApplicationFirewallPolicyListResultPager) NextPage(ctx context.Context) bool {
	if p.current != nil {
		if p.current.WebApplicationFirewallPolicyListResult.NextLink == nil || len(*p.current.WebApplicationFirewallPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err := p.advancer(p.current)
		if err != nil {
			p.err = err
			return false
		}
		p.request = req
	}
	resp, err := p.pipeline.Do(ctx, p.request)
	if err != nil {
		p.err = err
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *webApplicationFirewallPolicyListResultPager) PageResponse() *WebApplicationFirewallPolicyListResultResponse {
	return p.current
}
