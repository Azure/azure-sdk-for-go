// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"time"
)

// ApplicationGatewayBackendHealthOnDemandPoller provides polling facilities until the operation completes
type ApplicationGatewayBackendHealthOnDemandPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ApplicationGatewayBackendHealthOnDemandResponse, error)
	ResumeToken() (string, error)
}

type applicationGatewayBackendHealthOnDemandPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationGatewayBackendHealthOnDemandPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationGatewayBackendHealthOnDemandPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *applicationGatewayBackendHealthOnDemandPoller) FinalResponse(ctx context.Context) (*ApplicationGatewayBackendHealthOnDemandResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ApplicationGatewayBackendHealthOnDemand != ApplicationGatewayBackendHealthOnDemand{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeApplicationGatewayBackendHealthOnDemandPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationGatewayBackendHealthOnDemandPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *applicationGatewayBackendHealthOnDemandPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ApplicationGatewayBackendHealthOnDemandResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *applicationGatewayBackendHealthOnDemandPoller) handleResponse(resp *azcore.Response) (*ApplicationGatewayBackendHealthOnDemandResponse, error) {
	result := ApplicationGatewayBackendHealthOnDemandResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ApplicationGatewayBackendHealthOnDemand)
}

// ApplicationGatewayBackendHealthPoller provides polling facilities until the operation completes
type ApplicationGatewayBackendHealthPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ApplicationGatewayBackendHealthResponse, error)
	ResumeToken() (string, error)
}

type applicationGatewayBackendHealthPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationGatewayBackendHealthPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationGatewayBackendHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *applicationGatewayBackendHealthPoller) FinalResponse(ctx context.Context) (*ApplicationGatewayBackendHealthResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ApplicationGatewayBackendHealth != ApplicationGatewayBackendHealth{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeApplicationGatewayBackendHealthPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationGatewayBackendHealthPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *applicationGatewayBackendHealthPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ApplicationGatewayBackendHealthResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *applicationGatewayBackendHealthPoller) handleResponse(resp *azcore.Response) (*ApplicationGatewayBackendHealthResponse, error) {
	result := ApplicationGatewayBackendHealthResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ApplicationGatewayBackendHealth)
}

// ApplicationGatewayPoller provides polling facilities until the operation completes
type ApplicationGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ApplicationGatewayResponse, error)
	ResumeToken() (string, error)
}

type applicationGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationGatewayPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *applicationGatewayPoller) FinalResponse(ctx context.Context) (*ApplicationGatewayResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ApplicationGateway != ApplicationGateway{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeApplicationGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationGatewayPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *applicationGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ApplicationGatewayResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *applicationGatewayPoller) handleResponse(resp *azcore.Response) (*ApplicationGatewayResponse, error) {
	result := ApplicationGatewayResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ApplicationGateway)
}

// ApplicationSecurityGroupPoller provides polling facilities until the operation completes
type ApplicationSecurityGroupPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ApplicationSecurityGroupResponse, error)
	ResumeToken() (string, error)
}

type applicationSecurityGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationSecurityGroupPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationSecurityGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *applicationSecurityGroupPoller) FinalResponse(ctx context.Context) (*ApplicationSecurityGroupResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ApplicationSecurityGroup != ApplicationSecurityGroup{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeApplicationSecurityGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationSecurityGroupPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *applicationSecurityGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ApplicationSecurityGroupResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *applicationSecurityGroupPoller) handleResponse(resp *azcore.Response) (*ApplicationSecurityGroupResponse, error) {
	result := ApplicationSecurityGroupResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ApplicationSecurityGroup)
}

// AvailableProvidersListPoller provides polling facilities until the operation completes
type AvailableProvidersListPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*AvailableProvidersListResponse, error)
	ResumeToken() (string, error)
}

type availableProvidersListPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *availableProvidersListPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *availableProvidersListPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *availableProvidersListPoller) FinalResponse(ctx context.Context) (*AvailableProvidersListResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.AvailableProvidersList != AvailableProvidersList{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeAvailableProvidersListPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *availableProvidersListPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *availableProvidersListPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*AvailableProvidersListResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *availableProvidersListPoller) handleResponse(resp *azcore.Response) (*AvailableProvidersListResponse, error) {
	result := AvailableProvidersListResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.AvailableProvidersList)
}

// AzureFirewallPoller provides polling facilities until the operation completes
type AzureFirewallPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*AzureFirewallResponse, error)
	ResumeToken() (string, error)
}

type azureFirewallPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *azureFirewallPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *azureFirewallPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *azureFirewallPoller) FinalResponse(ctx context.Context) (*AzureFirewallResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.AzureFirewall != AzureFirewall{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeAzureFirewallPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *azureFirewallPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *azureFirewallPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*AzureFirewallResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *azureFirewallPoller) handleResponse(resp *azcore.Response) (*AzureFirewallResponse, error) {
	result := AzureFirewallResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.AzureFirewall)
}

// AzureReachabilityReportPoller provides polling facilities until the operation completes
type AzureReachabilityReportPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*AzureReachabilityReportResponse, error)
	ResumeToken() (string, error)
}

type azureReachabilityReportPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *azureReachabilityReportPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *azureReachabilityReportPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *azureReachabilityReportPoller) FinalResponse(ctx context.Context) (*AzureReachabilityReportResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.AzureReachabilityReport != AzureReachabilityReport{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeAzureReachabilityReportPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *azureReachabilityReportPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *azureReachabilityReportPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*AzureReachabilityReportResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *azureReachabilityReportPoller) handleResponse(resp *azcore.Response) (*AzureReachabilityReportResponse, error) {
	result := AzureReachabilityReportResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.AzureReachabilityReport)
}

// BastionActiveSessionListResultPagerPoller provides polling facilities until the operation completes
type BastionActiveSessionListResultPagerPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (BastionActiveSessionListResultPager, error)
	ResumeToken() (string, error)
}

type bastionActiveSessionListResultPagerPoller struct {
	// the client for making the request
	pipeline    azcore.Pipeline
	respHandler bastionActiveSessionListResultHandleResponse
	pt          pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bastionActiveSessionListResultPagerPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bastionActiveSessionListResultPagerPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *bastionActiveSessionListResultPagerPoller) FinalResponse(ctx context.Context) (BastionActiveSessionListResultPager, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		return p.handleResponse(p.pt.latestResponse())
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeBastionActiveSessionListResultPagerPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bastionActiveSessionListResultPagerPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *bastionActiveSessionListResultPagerPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BastionActiveSessionListResultPager, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *bastionActiveSessionListResultPagerPoller) handleResponse(resp *azcore.Response) (BastionActiveSessionListResultPager, error) {
	return &bastionActiveSessionListResultPager{
		pipeline:  p.pipeline,
		resp:      resp,
		responder: p.respHandler,
		advancer: func(resp *BastionActiveSessionListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.BastionActiveSessionListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.BastionActiveSessionListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// BastionHostPoller provides polling facilities until the operation completes
type BastionHostPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*BastionHostResponse, error)
	ResumeToken() (string, error)
}

type bastionHostPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bastionHostPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bastionHostPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *bastionHostPoller) FinalResponse(ctx context.Context) (*BastionHostResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.BastionHost != BastionHost{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeBastionHostPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bastionHostPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *bastionHostPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*BastionHostResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *bastionHostPoller) handleResponse(resp *azcore.Response) (*BastionHostResponse, error) {
	result := BastionHostResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.BastionHost)
}

// BastionShareableLinkListResultPagerPoller provides polling facilities until the operation completes
type BastionShareableLinkListResultPagerPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (BastionShareableLinkListResultPager, error)
	ResumeToken() (string, error)
}

type bastionShareableLinkListResultPagerPoller struct {
	// the client for making the request
	pipeline    azcore.Pipeline
	respHandler bastionShareableLinkListResultHandleResponse
	pt          pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bastionShareableLinkListResultPagerPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bastionShareableLinkListResultPagerPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *bastionShareableLinkListResultPagerPoller) FinalResponse(ctx context.Context) (BastionShareableLinkListResultPager, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		return p.handleResponse(p.pt.latestResponse())
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeBastionShareableLinkListResultPagerPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bastionShareableLinkListResultPagerPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *bastionShareableLinkListResultPagerPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BastionShareableLinkListResultPager, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *bastionShareableLinkListResultPagerPoller) handleResponse(resp *azcore.Response) (BastionShareableLinkListResultPager, error) {
	return &bastionShareableLinkListResultPager{
		pipeline:  p.pipeline,
		resp:      resp,
		responder: p.respHandler,
		advancer: func(resp *BastionShareableLinkListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.BastionShareableLinkListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.BastionShareableLinkListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// BgpPeerStatusListResultPoller provides polling facilities until the operation completes
type BgpPeerStatusListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*BgpPeerStatusListResultResponse, error)
	ResumeToken() (string, error)
}

type bgpPeerStatusListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bgpPeerStatusListResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bgpPeerStatusListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *bgpPeerStatusListResultPoller) FinalResponse(ctx context.Context) (*BgpPeerStatusListResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.BgpPeerStatusListResult != BgpPeerStatusListResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeBgpPeerStatusListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bgpPeerStatusListResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *bgpPeerStatusListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*BgpPeerStatusListResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *bgpPeerStatusListResultPoller) handleResponse(resp *azcore.Response) (*BgpPeerStatusListResultResponse, error) {
	result := BgpPeerStatusListResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.BgpPeerStatusListResult)
}

// ConnectionMonitorQueryResultPoller provides polling facilities until the operation completes
type ConnectionMonitorQueryResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ConnectionMonitorQueryResultResponse, error)
	ResumeToken() (string, error)
}

type connectionMonitorQueryResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectionMonitorQueryResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectionMonitorQueryResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *connectionMonitorQueryResultPoller) FinalResponse(ctx context.Context) (*ConnectionMonitorQueryResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ConnectionMonitorQueryResult != ConnectionMonitorQueryResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeConnectionMonitorQueryResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectionMonitorQueryResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *connectionMonitorQueryResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ConnectionMonitorQueryResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *connectionMonitorQueryResultPoller) handleResponse(resp *azcore.Response) (*ConnectionMonitorQueryResultResponse, error) {
	result := ConnectionMonitorQueryResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ConnectionMonitorQueryResult)
}

// ConnectionMonitorResultPoller provides polling facilities until the operation completes
type ConnectionMonitorResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ConnectionMonitorResultResponse, error)
	ResumeToken() (string, error)
}

type connectionMonitorResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectionMonitorResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectionMonitorResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *connectionMonitorResultPoller) FinalResponse(ctx context.Context) (*ConnectionMonitorResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ConnectionMonitorResult != ConnectionMonitorResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeConnectionMonitorResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectionMonitorResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *connectionMonitorResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ConnectionMonitorResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *connectionMonitorResultPoller) handleResponse(resp *azcore.Response) (*ConnectionMonitorResultResponse, error) {
	result := ConnectionMonitorResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ConnectionMonitorResult)
}

// ConnectionResetSharedKeyPoller provides polling facilities until the operation completes
type ConnectionResetSharedKeyPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ConnectionResetSharedKeyResponse, error)
	ResumeToken() (string, error)
}

type connectionResetSharedKeyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectionResetSharedKeyPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectionResetSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *connectionResetSharedKeyPoller) FinalResponse(ctx context.Context) (*ConnectionResetSharedKeyResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ConnectionResetSharedKey != ConnectionResetSharedKey{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeConnectionResetSharedKeyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectionResetSharedKeyPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *connectionResetSharedKeyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ConnectionResetSharedKeyResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *connectionResetSharedKeyPoller) handleResponse(resp *azcore.Response) (*ConnectionResetSharedKeyResponse, error) {
	result := ConnectionResetSharedKeyResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ConnectionResetSharedKey)
}

// ConnectionSharedKeyPoller provides polling facilities until the operation completes
type ConnectionSharedKeyPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ConnectionSharedKeyResponse, error)
	ResumeToken() (string, error)
}

type connectionSharedKeyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectionSharedKeyPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectionSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *connectionSharedKeyPoller) FinalResponse(ctx context.Context) (*ConnectionSharedKeyResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ConnectionSharedKey != ConnectionSharedKey{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeConnectionSharedKeyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectionSharedKeyPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *connectionSharedKeyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ConnectionSharedKeyResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *connectionSharedKeyPoller) handleResponse(resp *azcore.Response) (*ConnectionSharedKeyResponse, error) {
	result := ConnectionSharedKeyResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ConnectionSharedKey)
}

// ConnectivityInformationPoller provides polling facilities until the operation completes
type ConnectivityInformationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ConnectivityInformationResponse, error)
	ResumeToken() (string, error)
}

type connectivityInformationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectivityInformationPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectivityInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *connectivityInformationPoller) FinalResponse(ctx context.Context) (*ConnectivityInformationResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ConnectivityInformation != ConnectivityInformation{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeConnectivityInformationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectivityInformationPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *connectivityInformationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ConnectivityInformationResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *connectivityInformationPoller) handleResponse(resp *azcore.Response) (*ConnectivityInformationResponse, error) {
	result := ConnectivityInformationResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ConnectivityInformation)
}

// DdosCustomPolicyPoller provides polling facilities until the operation completes
type DdosCustomPolicyPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*DdosCustomPolicyResponse, error)
	ResumeToken() (string, error)
}

type ddosCustomPolicyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *ddosCustomPolicyPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *ddosCustomPolicyPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *ddosCustomPolicyPoller) FinalResponse(ctx context.Context) (*DdosCustomPolicyResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.DdosCustomPolicy != DdosCustomPolicy{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeDdosCustomPolicyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *ddosCustomPolicyPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *ddosCustomPolicyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*DdosCustomPolicyResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *ddosCustomPolicyPoller) handleResponse(resp *azcore.Response) (*DdosCustomPolicyResponse, error) {
	result := DdosCustomPolicyResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.DdosCustomPolicy)
}

// DdosProtectionPlanPoller provides polling facilities until the operation completes
type DdosProtectionPlanPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*DdosProtectionPlanResponse, error)
	ResumeToken() (string, error)
}

type ddosProtectionPlanPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *ddosProtectionPlanPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *ddosProtectionPlanPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *ddosProtectionPlanPoller) FinalResponse(ctx context.Context) (*DdosProtectionPlanResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.DdosProtectionPlan != DdosProtectionPlan{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeDdosProtectionPlanPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *ddosProtectionPlanPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *ddosProtectionPlanPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*DdosProtectionPlanResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *ddosProtectionPlanPoller) handleResponse(resp *azcore.Response) (*DdosProtectionPlanResponse, error) {
	result := DdosProtectionPlanResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.DdosProtectionPlan)
}

// EffectiveNetworkSecurityGroupListResultPoller provides polling facilities until the operation completes
type EffectiveNetworkSecurityGroupListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*EffectiveNetworkSecurityGroupListResultResponse, error)
	ResumeToken() (string, error)
}

type effectiveNetworkSecurityGroupListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *effectiveNetworkSecurityGroupListResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *effectiveNetworkSecurityGroupListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *effectiveNetworkSecurityGroupListResultPoller) FinalResponse(ctx context.Context) (*EffectiveNetworkSecurityGroupListResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.EffectiveNetworkSecurityGroupListResult != EffectiveNetworkSecurityGroupListResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeEffectiveNetworkSecurityGroupListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *effectiveNetworkSecurityGroupListResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *effectiveNetworkSecurityGroupListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*EffectiveNetworkSecurityGroupListResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *effectiveNetworkSecurityGroupListResultPoller) handleResponse(resp *azcore.Response) (*EffectiveNetworkSecurityGroupListResultResponse, error) {
	result := EffectiveNetworkSecurityGroupListResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.EffectiveNetworkSecurityGroupListResult)
}

// EffectiveRouteListResultPoller provides polling facilities until the operation completes
type EffectiveRouteListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*EffectiveRouteListResultResponse, error)
	ResumeToken() (string, error)
}

type effectiveRouteListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *effectiveRouteListResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *effectiveRouteListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *effectiveRouteListResultPoller) FinalResponse(ctx context.Context) (*EffectiveRouteListResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.EffectiveRouteListResult != EffectiveRouteListResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeEffectiveRouteListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *effectiveRouteListResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *effectiveRouteListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*EffectiveRouteListResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *effectiveRouteListResultPoller) handleResponse(resp *azcore.Response) (*EffectiveRouteListResultResponse, error) {
	result := EffectiveRouteListResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.EffectiveRouteListResult)
}

// ExpressRouteCircuitAuthorizationPoller provides polling facilities until the operation completes
type ExpressRouteCircuitAuthorizationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitAuthorizationResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitAuthorizationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitAuthorizationPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitAuthorizationPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRouteCircuitAuthorizationPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitAuthorizationResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRouteCircuitAuthorization != ExpressRouteCircuitAuthorization{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitAuthorizationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitAuthorizationPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRouteCircuitAuthorizationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitAuthorizationResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRouteCircuitAuthorizationPoller) handleResponse(resp *azcore.Response) (*ExpressRouteCircuitAuthorizationResponse, error) {
	result := ExpressRouteCircuitAuthorizationResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRouteCircuitAuthorization)
}

// ExpressRouteCircuitConnectionPoller provides polling facilities until the operation completes
type ExpressRouteCircuitConnectionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitConnectionResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitConnectionPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRouteCircuitConnectionPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitConnectionResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRouteCircuitConnection != ExpressRouteCircuitConnection{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitConnectionPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRouteCircuitConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitConnectionResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRouteCircuitConnectionPoller) handleResponse(resp *azcore.Response) (*ExpressRouteCircuitConnectionResponse, error) {
	result := ExpressRouteCircuitConnectionResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRouteCircuitConnection)
}

// ExpressRouteCircuitPeeringPoller provides polling facilities until the operation completes
type ExpressRouteCircuitPeeringPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitPeeringResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitPeeringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitPeeringPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRouteCircuitPeeringPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitPeeringResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRouteCircuitPeering != ExpressRouteCircuitPeering{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitPeeringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitPeeringPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRouteCircuitPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitPeeringResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRouteCircuitPeeringPoller) handleResponse(resp *azcore.Response) (*ExpressRouteCircuitPeeringResponse, error) {
	result := ExpressRouteCircuitPeeringResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRouteCircuitPeering)
}

// ExpressRouteCircuitPoller provides polling facilities until the operation completes
type ExpressRouteCircuitPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRouteCircuitPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRouteCircuit != ExpressRouteCircuit{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRouteCircuitPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRouteCircuitPoller) handleResponse(resp *azcore.Response) (*ExpressRouteCircuitResponse, error) {
	result := ExpressRouteCircuitResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRouteCircuit)
}

// ExpressRouteCircuitsArpTableListResultPoller provides polling facilities until the operation completes
type ExpressRouteCircuitsArpTableListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitsArpTableListResultResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitsArpTableListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitsArpTableListResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitsArpTableListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRouteCircuitsArpTableListResultPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitsArpTableListResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRouteCircuitsArpTableListResult != ExpressRouteCircuitsArpTableListResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitsArpTableListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitsArpTableListResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRouteCircuitsArpTableListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitsArpTableListResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRouteCircuitsArpTableListResultPoller) handleResponse(resp *azcore.Response) (*ExpressRouteCircuitsArpTableListResultResponse, error) {
	result := ExpressRouteCircuitsArpTableListResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRouteCircuitsArpTableListResult)
}

// ExpressRouteCircuitsRoutesTableListResultPoller provides polling facilities until the operation completes
type ExpressRouteCircuitsRoutesTableListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitsRoutesTableListResultResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitsRoutesTableListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitsRoutesTableListResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitsRoutesTableListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRouteCircuitsRoutesTableListResultPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitsRoutesTableListResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRouteCircuitsRoutesTableListResult != ExpressRouteCircuitsRoutesTableListResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitsRoutesTableListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitsRoutesTableListResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRouteCircuitsRoutesTableListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitsRoutesTableListResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRouteCircuitsRoutesTableListResultPoller) handleResponse(resp *azcore.Response) (*ExpressRouteCircuitsRoutesTableListResultResponse, error) {
	result := ExpressRouteCircuitsRoutesTableListResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRouteCircuitsRoutesTableListResult)
}

// ExpressRouteCircuitsRoutesTableSummaryListResultPoller provides polling facilities until the operation completes
type ExpressRouteCircuitsRoutesTableSummaryListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitsRoutesTableSummaryListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRouteCircuitsRoutesTableSummaryListResult != ExpressRouteCircuitsRoutesTableSummaryListResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitsRoutesTableSummaryListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) handleResponse(resp *azcore.Response) (*ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error) {
	result := ExpressRouteCircuitsRoutesTableSummaryListResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRouteCircuitsRoutesTableSummaryListResult)
}

// ExpressRouteConnectionPoller provides polling facilities until the operation completes
type ExpressRouteConnectionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteConnectionResponse, error)
	ResumeToken() (string, error)
}

type expressRouteConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteConnectionPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRouteConnectionPoller) FinalResponse(ctx context.Context) (*ExpressRouteConnectionResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRouteConnection != ExpressRouteConnection{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteConnectionPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRouteConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteConnectionResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRouteConnectionPoller) handleResponse(resp *azcore.Response) (*ExpressRouteConnectionResponse, error) {
	result := ExpressRouteConnectionResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRouteConnection)
}

// ExpressRouteCrossConnectionPeeringPoller provides polling facilities until the operation completes
type ExpressRouteCrossConnectionPeeringPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCrossConnectionPeeringResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCrossConnectionPeeringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCrossConnectionPeeringPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCrossConnectionPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRouteCrossConnectionPeeringPoller) FinalResponse(ctx context.Context) (*ExpressRouteCrossConnectionPeeringResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRouteCrossConnectionPeering != ExpressRouteCrossConnectionPeering{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCrossConnectionPeeringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCrossConnectionPeeringPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRouteCrossConnectionPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCrossConnectionPeeringResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRouteCrossConnectionPeeringPoller) handleResponse(resp *azcore.Response) (*ExpressRouteCrossConnectionPeeringResponse, error) {
	result := ExpressRouteCrossConnectionPeeringResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRouteCrossConnectionPeering)
}

// ExpressRouteCrossConnectionPoller provides polling facilities until the operation completes
type ExpressRouteCrossConnectionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCrossConnectionResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCrossConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCrossConnectionPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCrossConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRouteCrossConnectionPoller) FinalResponse(ctx context.Context) (*ExpressRouteCrossConnectionResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRouteCrossConnection != ExpressRouteCrossConnection{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCrossConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCrossConnectionPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRouteCrossConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCrossConnectionResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRouteCrossConnectionPoller) handleResponse(resp *azcore.Response) (*ExpressRouteCrossConnectionResponse, error) {
	result := ExpressRouteCrossConnectionResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRouteCrossConnection)
}

// ExpressRouteCrossConnectionsRoutesTableSummaryListResultPoller provides polling facilities until the operation completes
type ExpressRouteCrossConnectionsRoutesTableSummaryListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCrossConnectionsRoutesTableSummaryListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) FinalResponse(ctx context.Context) (*ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRouteCrossConnectionsRoutesTableSummaryListResult != ExpressRouteCrossConnectionsRoutesTableSummaryListResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCrossConnectionsRoutesTableSummaryListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) handleResponse(resp *azcore.Response) (*ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error) {
	result := ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
}

// ExpressRouteGatewayPoller provides polling facilities until the operation completes
type ExpressRouteGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteGatewayResponse, error)
	ResumeToken() (string, error)
}

type expressRouteGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteGatewayPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRouteGatewayPoller) FinalResponse(ctx context.Context) (*ExpressRouteGatewayResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRouteGateway != ExpressRouteGateway{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteGatewayPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRouteGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteGatewayResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRouteGatewayPoller) handleResponse(resp *azcore.Response) (*ExpressRouteGatewayResponse, error) {
	result := ExpressRouteGatewayResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRouteGateway)
}

// ExpressRoutePortPoller provides polling facilities until the operation completes
type ExpressRoutePortPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRoutePortResponse, error)
	ResumeToken() (string, error)
}

type expressRoutePortPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRoutePortPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRoutePortPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *expressRoutePortPoller) FinalResponse(ctx context.Context) (*ExpressRoutePortResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ExpressRoutePort != ExpressRoutePort{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeExpressRoutePortPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRoutePortPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *expressRoutePortPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRoutePortResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *expressRoutePortPoller) handleResponse(resp *azcore.Response) (*ExpressRoutePortResponse, error) {
	result := ExpressRoutePortResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ExpressRoutePort)
}

// FirewallPolicyPoller provides polling facilities until the operation completes
type FirewallPolicyPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*FirewallPolicyResponse, error)
	ResumeToken() (string, error)
}

type firewallPolicyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *firewallPolicyPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *firewallPolicyPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *firewallPolicyPoller) FinalResponse(ctx context.Context) (*FirewallPolicyResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.FirewallPolicy != FirewallPolicy{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeFirewallPolicyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *firewallPolicyPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *firewallPolicyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*FirewallPolicyResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *firewallPolicyPoller) handleResponse(resp *azcore.Response) (*FirewallPolicyResponse, error) {
	result := FirewallPolicyResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.FirewallPolicy)
}

// FirewallPolicyRuleGroupPoller provides polling facilities until the operation completes
type FirewallPolicyRuleGroupPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*FirewallPolicyRuleGroupResponse, error)
	ResumeToken() (string, error)
}

type firewallPolicyRuleGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *firewallPolicyRuleGroupPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *firewallPolicyRuleGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *firewallPolicyRuleGroupPoller) FinalResponse(ctx context.Context) (*FirewallPolicyRuleGroupResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.FirewallPolicyRuleGroup != FirewallPolicyRuleGroup{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeFirewallPolicyRuleGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *firewallPolicyRuleGroupPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *firewallPolicyRuleGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*FirewallPolicyRuleGroupResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *firewallPolicyRuleGroupPoller) handleResponse(resp *azcore.Response) (*FirewallPolicyRuleGroupResponse, error) {
	result := FirewallPolicyRuleGroupResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.FirewallPolicyRuleGroup)
}

// FlowLogInformationPoller provides polling facilities until the operation completes
type FlowLogInformationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*FlowLogInformationResponse, error)
	ResumeToken() (string, error)
}

type flowLogInformationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *flowLogInformationPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *flowLogInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *flowLogInformationPoller) FinalResponse(ctx context.Context) (*FlowLogInformationResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.FlowLogInformation != FlowLogInformation{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeFlowLogInformationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *flowLogInformationPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *flowLogInformationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*FlowLogInformationResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *flowLogInformationPoller) handleResponse(resp *azcore.Response) (*FlowLogInformationResponse, error) {
	result := FlowLogInformationResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.FlowLogInformation)
}

// FlowLogPoller provides polling facilities until the operation completes
type FlowLogPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*FlowLogResponse, error)
	ResumeToken() (string, error)
}

type flowLogPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *flowLogPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *flowLogPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *flowLogPoller) FinalResponse(ctx context.Context) (*FlowLogResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.FlowLog != FlowLog{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeFlowLogPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *flowLogPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *flowLogPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*FlowLogResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *flowLogPoller) handleResponse(resp *azcore.Response) (*FlowLogResponse, error) {
	result := FlowLogResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.FlowLog)
}

// GatewayRouteListResultPoller provides polling facilities until the operation completes
type GatewayRouteListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*GatewayRouteListResultResponse, error)
	ResumeToken() (string, error)
}

type gatewayRouteListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *gatewayRouteListResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *gatewayRouteListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *gatewayRouteListResultPoller) FinalResponse(ctx context.Context) (*GatewayRouteListResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.GatewayRouteListResult != GatewayRouteListResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeGatewayRouteListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *gatewayRouteListResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *gatewayRouteListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*GatewayRouteListResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *gatewayRouteListResultPoller) handleResponse(resp *azcore.Response) (*GatewayRouteListResultResponse, error) {
	result := GatewayRouteListResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.GatewayRouteListResult)
}

// HTTPPoller provides polling facilities until the operation completes
type HTTPPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse() *http.Response
	ResumeToken() (string, error)
}

type httpPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *httpPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *httpPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *httpPoller) FinalResponse() *http.Response {
	return p.pt.latestResponse().Response
}

// ResumeToken generates the string token that can be used with the ResumeHTTPPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *httpPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *httpPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*http.Response, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(), nil
}

// IPAllocationPoller provides polling facilities until the operation completes
type IPAllocationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*IPAllocationResponse, error)
	ResumeToken() (string, error)
}

type ipAllocationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *ipAllocationPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *ipAllocationPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *ipAllocationPoller) FinalResponse(ctx context.Context) (*IPAllocationResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.IPAllocation != IPAllocation{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeIPAllocationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *ipAllocationPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *ipAllocationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*IPAllocationResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *ipAllocationPoller) handleResponse(resp *azcore.Response) (*IPAllocationResponse, error) {
	result := IPAllocationResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.IPAllocation)
}

// IPGroupPoller provides polling facilities until the operation completes
type IPGroupPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*IPGroupResponse, error)
	ResumeToken() (string, error)
}

type ipGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *ipGroupPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *ipGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *ipGroupPoller) FinalResponse(ctx context.Context) (*IPGroupResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.IPGroup != IPGroup{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeIPGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *ipGroupPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *ipGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*IPGroupResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *ipGroupPoller) handleResponse(resp *azcore.Response) (*IPGroupResponse, error) {
	result := IPGroupResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.IPGroup)
}

// InboundNatRulePoller provides polling facilities until the operation completes
type InboundNatRulePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*InboundNatRuleResponse, error)
	ResumeToken() (string, error)
}

type inboundNatRulePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *inboundNatRulePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *inboundNatRulePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *inboundNatRulePoller) FinalResponse(ctx context.Context) (*InboundNatRuleResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.InboundNatRule != InboundNatRule{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeInboundNatRulePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *inboundNatRulePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *inboundNatRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*InboundNatRuleResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *inboundNatRulePoller) handleResponse(resp *azcore.Response) (*InboundNatRuleResponse, error) {
	result := InboundNatRuleResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.InboundNatRule)
}

// LoadBalancerPoller provides polling facilities until the operation completes
type LoadBalancerPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*LoadBalancerResponse, error)
	ResumeToken() (string, error)
}

type loadBalancerPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *loadBalancerPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *loadBalancerPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *loadBalancerPoller) FinalResponse(ctx context.Context) (*LoadBalancerResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.LoadBalancer != LoadBalancer{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeLoadBalancerPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *loadBalancerPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *loadBalancerPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*LoadBalancerResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *loadBalancerPoller) handleResponse(resp *azcore.Response) (*LoadBalancerResponse, error) {
	result := LoadBalancerResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.LoadBalancer)
}

// LocalNetworkGatewayPoller provides polling facilities until the operation completes
type LocalNetworkGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*LocalNetworkGatewayResponse, error)
	ResumeToken() (string, error)
}

type localNetworkGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *localNetworkGatewayPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *localNetworkGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *localNetworkGatewayPoller) FinalResponse(ctx context.Context) (*LocalNetworkGatewayResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.LocalNetworkGateway != LocalNetworkGateway{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeLocalNetworkGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *localNetworkGatewayPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *localNetworkGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*LocalNetworkGatewayResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *localNetworkGatewayPoller) handleResponse(resp *azcore.Response) (*LocalNetworkGatewayResponse, error) {
	result := LocalNetworkGatewayResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.LocalNetworkGateway)
}

// NatGatewayPoller provides polling facilities until the operation completes
type NatGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NatGatewayResponse, error)
	ResumeToken() (string, error)
}

type natGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *natGatewayPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *natGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *natGatewayPoller) FinalResponse(ctx context.Context) (*NatGatewayResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.NatGateway != NatGateway{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeNatGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *natGatewayPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *natGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NatGatewayResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *natGatewayPoller) handleResponse(resp *azcore.Response) (*NatGatewayResponse, error) {
	result := NatGatewayResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.NatGateway)
}

// NetworkConfigurationDiagnosticResponsePoller provides polling facilities until the operation completes
type NetworkConfigurationDiagnosticResponsePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NetworkConfigurationDiagnosticResponseResponse, error)
	ResumeToken() (string, error)
}

type networkConfigurationDiagnosticResponsePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkConfigurationDiagnosticResponsePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkConfigurationDiagnosticResponsePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *networkConfigurationDiagnosticResponsePoller) FinalResponse(ctx context.Context) (*NetworkConfigurationDiagnosticResponseResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.NetworkConfigurationDiagnosticResponse != NetworkConfigurationDiagnosticResponse{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeNetworkConfigurationDiagnosticResponsePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkConfigurationDiagnosticResponsePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *networkConfigurationDiagnosticResponsePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NetworkConfigurationDiagnosticResponseResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *networkConfigurationDiagnosticResponsePoller) handleResponse(resp *azcore.Response) (*NetworkConfigurationDiagnosticResponseResponse, error) {
	result := NetworkConfigurationDiagnosticResponseResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.NetworkConfigurationDiagnosticResponse)
}

// NetworkInterfacePoller provides polling facilities until the operation completes
type NetworkInterfacePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NetworkInterfaceResponse, error)
	ResumeToken() (string, error)
}

type networkInterfacePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkInterfacePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkInterfacePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *networkInterfacePoller) FinalResponse(ctx context.Context) (*NetworkInterfaceResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.NetworkInterface != NetworkInterface{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeNetworkInterfacePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkInterfacePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *networkInterfacePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NetworkInterfaceResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *networkInterfacePoller) handleResponse(resp *azcore.Response) (*NetworkInterfaceResponse, error) {
	result := NetworkInterfaceResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.NetworkInterface)
}

// NetworkInterfaceTapConfigurationPoller provides polling facilities until the operation completes
type NetworkInterfaceTapConfigurationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NetworkInterfaceTapConfigurationResponse, error)
	ResumeToken() (string, error)
}

type networkInterfaceTapConfigurationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkInterfaceTapConfigurationPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkInterfaceTapConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *networkInterfaceTapConfigurationPoller) FinalResponse(ctx context.Context) (*NetworkInterfaceTapConfigurationResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.NetworkInterfaceTapConfiguration != NetworkInterfaceTapConfiguration{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeNetworkInterfaceTapConfigurationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkInterfaceTapConfigurationPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *networkInterfaceTapConfigurationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NetworkInterfaceTapConfigurationResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *networkInterfaceTapConfigurationPoller) handleResponse(resp *azcore.Response) (*NetworkInterfaceTapConfigurationResponse, error) {
	result := NetworkInterfaceTapConfigurationResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.NetworkInterfaceTapConfiguration)
}

// NetworkSecurityGroupPoller provides polling facilities until the operation completes
type NetworkSecurityGroupPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NetworkSecurityGroupResponse, error)
	ResumeToken() (string, error)
}

type networkSecurityGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkSecurityGroupPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkSecurityGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *networkSecurityGroupPoller) FinalResponse(ctx context.Context) (*NetworkSecurityGroupResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.NetworkSecurityGroup != NetworkSecurityGroup{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeNetworkSecurityGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkSecurityGroupPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *networkSecurityGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NetworkSecurityGroupResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *networkSecurityGroupPoller) handleResponse(resp *azcore.Response) (*NetworkSecurityGroupResponse, error) {
	result := NetworkSecurityGroupResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.NetworkSecurityGroup)
}

// NetworkVirtualAppliancePoller provides polling facilities until the operation completes
type NetworkVirtualAppliancePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NetworkVirtualApplianceResponse, error)
	ResumeToken() (string, error)
}

type networkVirtualAppliancePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkVirtualAppliancePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkVirtualAppliancePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *networkVirtualAppliancePoller) FinalResponse(ctx context.Context) (*NetworkVirtualApplianceResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.NetworkVirtualAppliance != NetworkVirtualAppliance{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeNetworkVirtualAppliancePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkVirtualAppliancePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *networkVirtualAppliancePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NetworkVirtualApplianceResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *networkVirtualAppliancePoller) handleResponse(resp *azcore.Response) (*NetworkVirtualApplianceResponse, error) {
	result := NetworkVirtualApplianceResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.NetworkVirtualAppliance)
}

// NextHopResultPoller provides polling facilities until the operation completes
type NextHopResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NextHopResultResponse, error)
	ResumeToken() (string, error)
}

type nextHopResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *nextHopResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *nextHopResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *nextHopResultPoller) FinalResponse(ctx context.Context) (*NextHopResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.NextHopResult != NextHopResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeNextHopResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *nextHopResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *nextHopResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NextHopResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *nextHopResultPoller) handleResponse(resp *azcore.Response) (*NextHopResultResponse, error) {
	result := NextHopResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.NextHopResult)
}

// P2SVpnConnectionHealthPoller provides polling facilities until the operation completes
type P2SVpnConnectionHealthPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*P2SVpnConnectionHealthResponse, error)
	ResumeToken() (string, error)
}

type p2SVpnConnectionHealthPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *p2SVpnConnectionHealthPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *p2SVpnConnectionHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *p2SVpnConnectionHealthPoller) FinalResponse(ctx context.Context) (*P2SVpnConnectionHealthResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.P2SVpnConnectionHealth != P2SVpnConnectionHealth{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeP2SVpnConnectionHealthPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *p2SVpnConnectionHealthPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *p2SVpnConnectionHealthPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*P2SVpnConnectionHealthResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *p2SVpnConnectionHealthPoller) handleResponse(resp *azcore.Response) (*P2SVpnConnectionHealthResponse, error) {
	result := P2SVpnConnectionHealthResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.P2SVpnConnectionHealth)
}

// P2SVpnGatewayPoller provides polling facilities until the operation completes
type P2SVpnGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*P2SVpnGatewayResponse, error)
	ResumeToken() (string, error)
}

type p2SVpnGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *p2SVpnGatewayPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *p2SVpnGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *p2SVpnGatewayPoller) FinalResponse(ctx context.Context) (*P2SVpnGatewayResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.P2SVpnGateway != P2SVpnGateway{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeP2SVpnGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *p2SVpnGatewayPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *p2SVpnGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*P2SVpnGatewayResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *p2SVpnGatewayPoller) handleResponse(resp *azcore.Response) (*P2SVpnGatewayResponse, error) {
	result := P2SVpnGatewayResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.P2SVpnGateway)
}

// PacketCaptureQueryStatusResultPoller provides polling facilities until the operation completes
type PacketCaptureQueryStatusResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PacketCaptureQueryStatusResultResponse, error)
	ResumeToken() (string, error)
}

type packetCaptureQueryStatusResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *packetCaptureQueryStatusResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *packetCaptureQueryStatusResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *packetCaptureQueryStatusResultPoller) FinalResponse(ctx context.Context) (*PacketCaptureQueryStatusResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.PacketCaptureQueryStatusResult != PacketCaptureQueryStatusResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumePacketCaptureQueryStatusResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *packetCaptureQueryStatusResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *packetCaptureQueryStatusResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PacketCaptureQueryStatusResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *packetCaptureQueryStatusResultPoller) handleResponse(resp *azcore.Response) (*PacketCaptureQueryStatusResultResponse, error) {
	result := PacketCaptureQueryStatusResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.PacketCaptureQueryStatusResult)
}

// PacketCaptureResultPoller provides polling facilities until the operation completes
type PacketCaptureResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PacketCaptureResultResponse, error)
	ResumeToken() (string, error)
}

type packetCaptureResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *packetCaptureResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *packetCaptureResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *packetCaptureResultPoller) FinalResponse(ctx context.Context) (*PacketCaptureResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.PacketCaptureResult != PacketCaptureResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumePacketCaptureResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *packetCaptureResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *packetCaptureResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PacketCaptureResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *packetCaptureResultPoller) handleResponse(resp *azcore.Response) (*PacketCaptureResultResponse, error) {
	result := PacketCaptureResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.PacketCaptureResult)
}

// PrivateDNSZoneGroupPoller provides polling facilities until the operation completes
type PrivateDNSZoneGroupPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PrivateDNSZoneGroupResponse, error)
	ResumeToken() (string, error)
}

type privateDnsZoneGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *privateDnsZoneGroupPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *privateDnsZoneGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *privateDnsZoneGroupPoller) FinalResponse(ctx context.Context) (*PrivateDNSZoneGroupResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.PrivateDNSZoneGroup != PrivateDNSZoneGroup{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumePrivateDNSZoneGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *privateDnsZoneGroupPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *privateDnsZoneGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PrivateDNSZoneGroupResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *privateDnsZoneGroupPoller) handleResponse(resp *azcore.Response) (*PrivateDNSZoneGroupResponse, error) {
	result := PrivateDNSZoneGroupResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.PrivateDNSZoneGroup)
}

// PrivateEndpointPoller provides polling facilities until the operation completes
type PrivateEndpointPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PrivateEndpointResponse, error)
	ResumeToken() (string, error)
}

type privateEndpointPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *privateEndpointPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *privateEndpointPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *privateEndpointPoller) FinalResponse(ctx context.Context) (*PrivateEndpointResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.PrivateEndpoint != PrivateEndpoint{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumePrivateEndpointPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *privateEndpointPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *privateEndpointPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PrivateEndpointResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *privateEndpointPoller) handleResponse(resp *azcore.Response) (*PrivateEndpointResponse, error) {
	result := PrivateEndpointResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.PrivateEndpoint)
}

// PrivateLinkServicePoller provides polling facilities until the operation completes
type PrivateLinkServicePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PrivateLinkServiceResponse, error)
	ResumeToken() (string, error)
}

type privateLinkServicePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *privateLinkServicePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *privateLinkServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *privateLinkServicePoller) FinalResponse(ctx context.Context) (*PrivateLinkServiceResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.PrivateLinkService != PrivateLinkService{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumePrivateLinkServicePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *privateLinkServicePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *privateLinkServicePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PrivateLinkServiceResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *privateLinkServicePoller) handleResponse(resp *azcore.Response) (*PrivateLinkServiceResponse, error) {
	result := PrivateLinkServiceResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.PrivateLinkService)
}

// PrivateLinkServiceVisibilityPoller provides polling facilities until the operation completes
type PrivateLinkServiceVisibilityPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PrivateLinkServiceVisibilityResponse, error)
	ResumeToken() (string, error)
}

type privateLinkServiceVisibilityPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *privateLinkServiceVisibilityPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *privateLinkServiceVisibilityPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *privateLinkServiceVisibilityPoller) FinalResponse(ctx context.Context) (*PrivateLinkServiceVisibilityResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.PrivateLinkServiceVisibility != PrivateLinkServiceVisibility{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumePrivateLinkServiceVisibilityPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *privateLinkServiceVisibilityPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *privateLinkServiceVisibilityPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PrivateLinkServiceVisibilityResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *privateLinkServiceVisibilityPoller) handleResponse(resp *azcore.Response) (*PrivateLinkServiceVisibilityResponse, error) {
	result := PrivateLinkServiceVisibilityResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.PrivateLinkServiceVisibility)
}

// PublicIPAddressPoller provides polling facilities until the operation completes
type PublicIPAddressPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PublicIPAddressResponse, error)
	ResumeToken() (string, error)
}

type publicIPAddressPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *publicIPAddressPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *publicIPAddressPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *publicIPAddressPoller) FinalResponse(ctx context.Context) (*PublicIPAddressResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.PublicIPAddress != PublicIPAddress{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumePublicIPAddressPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *publicIPAddressPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *publicIPAddressPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PublicIPAddressResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *publicIPAddressPoller) handleResponse(resp *azcore.Response) (*PublicIPAddressResponse, error) {
	result := PublicIPAddressResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.PublicIPAddress)
}

// PublicIPPrefixPoller provides polling facilities until the operation completes
type PublicIPPrefixPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PublicIPPrefixResponse, error)
	ResumeToken() (string, error)
}

type publicIPPrefixPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *publicIPPrefixPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *publicIPPrefixPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *publicIPPrefixPoller) FinalResponse(ctx context.Context) (*PublicIPPrefixResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.PublicIPPrefix != PublicIPPrefix{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumePublicIPPrefixPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *publicIPPrefixPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *publicIPPrefixPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PublicIPPrefixResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *publicIPPrefixPoller) handleResponse(resp *azcore.Response) (*PublicIPPrefixResponse, error) {
	result := PublicIPPrefixResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.PublicIPPrefix)
}

// RouteFilterPoller provides polling facilities until the operation completes
type RouteFilterPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*RouteFilterResponse, error)
	ResumeToken() (string, error)
}

type routeFilterPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *routeFilterPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *routeFilterPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *routeFilterPoller) FinalResponse(ctx context.Context) (*RouteFilterResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.RouteFilter != RouteFilter{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeRouteFilterPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *routeFilterPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *routeFilterPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*RouteFilterResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *routeFilterPoller) handleResponse(resp *azcore.Response) (*RouteFilterResponse, error) {
	result := RouteFilterResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.RouteFilter)
}

// RouteFilterRulePoller provides polling facilities until the operation completes
type RouteFilterRulePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*RouteFilterRuleResponse, error)
	ResumeToken() (string, error)
}

type routeFilterRulePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *routeFilterRulePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *routeFilterRulePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *routeFilterRulePoller) FinalResponse(ctx context.Context) (*RouteFilterRuleResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.RouteFilterRule != RouteFilterRule{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeRouteFilterRulePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *routeFilterRulePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *routeFilterRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*RouteFilterRuleResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *routeFilterRulePoller) handleResponse(resp *azcore.Response) (*RouteFilterRuleResponse, error) {
	result := RouteFilterRuleResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.RouteFilterRule)
}

// RoutePoller provides polling facilities until the operation completes
type RoutePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*RouteResponse, error)
	ResumeToken() (string, error)
}

type routePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *routePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *routePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *routePoller) FinalResponse(ctx context.Context) (*RouteResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.Route != Route{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeRoutePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *routePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *routePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*RouteResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *routePoller) handleResponse(resp *azcore.Response) (*RouteResponse, error) {
	result := RouteResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.Route)
}

// RouteTablePoller provides polling facilities until the operation completes
type RouteTablePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*RouteTableResponse, error)
	ResumeToken() (string, error)
}

type routeTablePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *routeTablePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *routeTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *routeTablePoller) FinalResponse(ctx context.Context) (*RouteTableResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.RouteTable != RouteTable{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeRouteTablePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *routeTablePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *routeTablePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*RouteTableResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *routeTablePoller) handleResponse(resp *azcore.Response) (*RouteTableResponse, error) {
	result := RouteTableResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.RouteTable)
}

// SecurityGroupViewResultPoller provides polling facilities until the operation completes
type SecurityGroupViewResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*SecurityGroupViewResultResponse, error)
	ResumeToken() (string, error)
}

type securityGroupViewResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *securityGroupViewResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *securityGroupViewResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *securityGroupViewResultPoller) FinalResponse(ctx context.Context) (*SecurityGroupViewResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.SecurityGroupViewResult != SecurityGroupViewResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeSecurityGroupViewResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *securityGroupViewResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *securityGroupViewResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*SecurityGroupViewResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *securityGroupViewResultPoller) handleResponse(resp *azcore.Response) (*SecurityGroupViewResultResponse, error) {
	result := SecurityGroupViewResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.SecurityGroupViewResult)
}

// SecurityPartnerProviderPoller provides polling facilities until the operation completes
type SecurityPartnerProviderPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*SecurityPartnerProviderResponse, error)
	ResumeToken() (string, error)
}

type securityPartnerProviderPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *securityPartnerProviderPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *securityPartnerProviderPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *securityPartnerProviderPoller) FinalResponse(ctx context.Context) (*SecurityPartnerProviderResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.SecurityPartnerProvider != SecurityPartnerProvider{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeSecurityPartnerProviderPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *securityPartnerProviderPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *securityPartnerProviderPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*SecurityPartnerProviderResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *securityPartnerProviderPoller) handleResponse(resp *azcore.Response) (*SecurityPartnerProviderResponse, error) {
	result := SecurityPartnerProviderResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.SecurityPartnerProvider)
}

// SecurityRulePoller provides polling facilities until the operation completes
type SecurityRulePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*SecurityRuleResponse, error)
	ResumeToken() (string, error)
}

type securityRulePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *securityRulePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *securityRulePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *securityRulePoller) FinalResponse(ctx context.Context) (*SecurityRuleResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.SecurityRule != SecurityRule{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeSecurityRulePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *securityRulePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *securityRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*SecurityRuleResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *securityRulePoller) handleResponse(resp *azcore.Response) (*SecurityRuleResponse, error) {
	result := SecurityRuleResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.SecurityRule)
}

// ServiceEndpointPolicyDefinitionPoller provides polling facilities until the operation completes
type ServiceEndpointPolicyDefinitionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ServiceEndpointPolicyDefinitionResponse, error)
	ResumeToken() (string, error)
}

type serviceEndpointPolicyDefinitionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *serviceEndpointPolicyDefinitionPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *serviceEndpointPolicyDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *serviceEndpointPolicyDefinitionPoller) FinalResponse(ctx context.Context) (*ServiceEndpointPolicyDefinitionResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ServiceEndpointPolicyDefinition != ServiceEndpointPolicyDefinition{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeServiceEndpointPolicyDefinitionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *serviceEndpointPolicyDefinitionPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *serviceEndpointPolicyDefinitionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ServiceEndpointPolicyDefinitionResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *serviceEndpointPolicyDefinitionPoller) handleResponse(resp *azcore.Response) (*ServiceEndpointPolicyDefinitionResponse, error) {
	result := ServiceEndpointPolicyDefinitionResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ServiceEndpointPolicyDefinition)
}

// ServiceEndpointPolicyPoller provides polling facilities until the operation completes
type ServiceEndpointPolicyPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ServiceEndpointPolicyResponse, error)
	ResumeToken() (string, error)
}

type serviceEndpointPolicyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *serviceEndpointPolicyPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *serviceEndpointPolicyPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *serviceEndpointPolicyPoller) FinalResponse(ctx context.Context) (*ServiceEndpointPolicyResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.ServiceEndpointPolicy != ServiceEndpointPolicy{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeServiceEndpointPolicyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *serviceEndpointPolicyPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *serviceEndpointPolicyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ServiceEndpointPolicyResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *serviceEndpointPolicyPoller) handleResponse(resp *azcore.Response) (*ServiceEndpointPolicyResponse, error) {
	result := ServiceEndpointPolicyResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.ServiceEndpointPolicy)
}

// StringPoller provides polling facilities until the operation completes
type StringPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*StringResponse, error)
	ResumeToken() (string, error)
}

type stringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *stringPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *stringPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *stringPoller) FinalResponse(ctx context.Context) (*StringResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.Value != "") {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeStringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *stringPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *stringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*StringResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *stringPoller) handleResponse(resp *azcore.Response) (*StringResponse, error) {
	result := StringResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// SubnetPoller provides polling facilities until the operation completes
type SubnetPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*SubnetResponse, error)
	ResumeToken() (string, error)
}

type subnetPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *subnetPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *subnetPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *subnetPoller) FinalResponse(ctx context.Context) (*SubnetResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.Subnet != Subnet{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeSubnetPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *subnetPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *subnetPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*SubnetResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *subnetPoller) handleResponse(resp *azcore.Response) (*SubnetResponse, error) {
	result := SubnetResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.Subnet)
}

// TroubleshootingResultPoller provides polling facilities until the operation completes
type TroubleshootingResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*TroubleshootingResultResponse, error)
	ResumeToken() (string, error)
}

type troubleshootingResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *troubleshootingResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *troubleshootingResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *troubleshootingResultPoller) FinalResponse(ctx context.Context) (*TroubleshootingResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.TroubleshootingResult != TroubleshootingResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeTroubleshootingResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *troubleshootingResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *troubleshootingResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*TroubleshootingResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *troubleshootingResultPoller) handleResponse(resp *azcore.Response) (*TroubleshootingResultResponse, error) {
	result := TroubleshootingResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.TroubleshootingResult)
}

// VerificationIPFlowResultPoller provides polling facilities until the operation completes
type VerificationIPFlowResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VerificationIPFlowResultResponse, error)
	ResumeToken() (string, error)
}

type verificationIPFlowResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *verificationIPFlowResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *verificationIPFlowResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *verificationIPFlowResultPoller) FinalResponse(ctx context.Context) (*VerificationIPFlowResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VerificationIPFlowResult != VerificationIPFlowResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVerificationIPFlowResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *verificationIPFlowResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *verificationIPFlowResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VerificationIPFlowResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *verificationIPFlowResultPoller) handleResponse(resp *azcore.Response) (*VerificationIPFlowResultResponse, error) {
	result := VerificationIPFlowResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VerificationIPFlowResult)
}

// VirtualHubPoller provides polling facilities until the operation completes
type VirtualHubPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualHubResponse, error)
	ResumeToken() (string, error)
}

type virtualHubPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualHubPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualHubPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualHubPoller) FinalResponse(ctx context.Context) (*VirtualHubResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualHub != VirtualHub{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualHubPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualHubPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualHubPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualHubResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualHubPoller) handleResponse(resp *azcore.Response) (*VirtualHubResponse, error) {
	result := VirtualHubResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualHub)
}

// VirtualHubRouteTableV2Poller provides polling facilities until the operation completes
type VirtualHubRouteTableV2Poller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualHubRouteTableV2Response, error)
	ResumeToken() (string, error)
}

type virtualHubRouteTableV2Poller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualHubRouteTableV2Poller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualHubRouteTableV2Poller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualHubRouteTableV2Poller) FinalResponse(ctx context.Context) (*VirtualHubRouteTableV2Response, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualHubRouteTableV2 != VirtualHubRouteTableV2{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualHubRouteTableV2Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualHubRouteTableV2Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualHubRouteTableV2Poller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualHubRouteTableV2Response, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualHubRouteTableV2Poller) handleResponse(resp *azcore.Response) (*VirtualHubRouteTableV2Response, error) {
	result := VirtualHubRouteTableV2Response{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualHubRouteTableV2)
}

// VirtualNetworkGatewayConnectionPoller provides polling facilities until the operation completes
type VirtualNetworkGatewayConnectionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualNetworkGatewayConnectionResponse, error)
	ResumeToken() (string, error)
}

type virtualNetworkGatewayConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkGatewayConnectionPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkGatewayConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualNetworkGatewayConnectionPoller) FinalResponse(ctx context.Context) (*VirtualNetworkGatewayConnectionResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualNetworkGatewayConnection != VirtualNetworkGatewayConnection{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkGatewayConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkGatewayConnectionPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualNetworkGatewayConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualNetworkGatewayConnectionResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualNetworkGatewayConnectionPoller) handleResponse(resp *azcore.Response) (*VirtualNetworkGatewayConnectionResponse, error) {
	result := VirtualNetworkGatewayConnectionResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualNetworkGatewayConnection)
}

// VirtualNetworkGatewayPoller provides polling facilities until the operation completes
type VirtualNetworkGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualNetworkGatewayResponse, error)
	ResumeToken() (string, error)
}

type virtualNetworkGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkGatewayPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualNetworkGatewayPoller) FinalResponse(ctx context.Context) (*VirtualNetworkGatewayResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualNetworkGateway != VirtualNetworkGateway{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkGatewayPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualNetworkGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualNetworkGatewayResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualNetworkGatewayPoller) handleResponse(resp *azcore.Response) (*VirtualNetworkGatewayResponse, error) {
	result := VirtualNetworkGatewayResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualNetworkGateway)
}

// VirtualNetworkPeeringPoller provides polling facilities until the operation completes
type VirtualNetworkPeeringPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualNetworkPeeringResponse, error)
	ResumeToken() (string, error)
}

type virtualNetworkPeeringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkPeeringPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualNetworkPeeringPoller) FinalResponse(ctx context.Context) (*VirtualNetworkPeeringResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualNetworkPeering != VirtualNetworkPeering{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkPeeringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkPeeringPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualNetworkPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualNetworkPeeringResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualNetworkPeeringPoller) handleResponse(resp *azcore.Response) (*VirtualNetworkPeeringResponse, error) {
	result := VirtualNetworkPeeringResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualNetworkPeering)
}

// VirtualNetworkPoller provides polling facilities until the operation completes
type VirtualNetworkPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualNetworkResponse, error)
	ResumeToken() (string, error)
}

type virtualNetworkPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualNetworkPoller) FinalResponse(ctx context.Context) (*VirtualNetworkResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualNetwork != VirtualNetwork{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualNetworkPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualNetworkResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualNetworkPoller) handleResponse(resp *azcore.Response) (*VirtualNetworkResponse, error) {
	result := VirtualNetworkResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualNetwork)
}

// VirtualNetworkTapPoller provides polling facilities until the operation completes
type VirtualNetworkTapPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualNetworkTapResponse, error)
	ResumeToken() (string, error)
}

type virtualNetworkTapPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkTapPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkTapPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualNetworkTapPoller) FinalResponse(ctx context.Context) (*VirtualNetworkTapResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualNetworkTap != VirtualNetworkTap{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkTapPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkTapPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualNetworkTapPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualNetworkTapResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualNetworkTapPoller) handleResponse(resp *azcore.Response) (*VirtualNetworkTapResponse, error) {
	result := VirtualNetworkTapResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualNetworkTap)
}

// VirtualRouterPeeringPoller provides polling facilities until the operation completes
type VirtualRouterPeeringPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualRouterPeeringResponse, error)
	ResumeToken() (string, error)
}

type virtualRouterPeeringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualRouterPeeringPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualRouterPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualRouterPeeringPoller) FinalResponse(ctx context.Context) (*VirtualRouterPeeringResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualRouterPeering != VirtualRouterPeering{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualRouterPeeringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualRouterPeeringPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualRouterPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualRouterPeeringResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualRouterPeeringPoller) handleResponse(resp *azcore.Response) (*VirtualRouterPeeringResponse, error) {
	result := VirtualRouterPeeringResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualRouterPeering)
}

// VirtualRouterPoller provides polling facilities until the operation completes
type VirtualRouterPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualRouterResponse, error)
	ResumeToken() (string, error)
}

type virtualRouterPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualRouterPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualRouterPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualRouterPoller) FinalResponse(ctx context.Context) (*VirtualRouterResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualRouter != VirtualRouter{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualRouterPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualRouterPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualRouterPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualRouterResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualRouterPoller) handleResponse(resp *azcore.Response) (*VirtualRouterResponse, error) {
	result := VirtualRouterResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualRouter)
}

// VirtualWanPoller provides polling facilities until the operation completes
type VirtualWanPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualWanResponse, error)
	ResumeToken() (string, error)
}

type virtualWanPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualWanPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualWanPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *virtualWanPoller) FinalResponse(ctx context.Context) (*VirtualWanResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VirtualWan != VirtualWan{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVirtualWanPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualWanPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *virtualWanPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualWanResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *virtualWanPoller) handleResponse(resp *azcore.Response) (*VirtualWanResponse, error) {
	result := VirtualWanResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VirtualWan)
}

// VpnClientConnectionHealthDetailListResultPoller provides polling facilities until the operation completes
type VpnClientConnectionHealthDetailListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnClientConnectionHealthDetailListResultResponse, error)
	ResumeToken() (string, error)
}

type vpnClientConnectionHealthDetailListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnClientConnectionHealthDetailListResultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnClientConnectionHealthDetailListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *vpnClientConnectionHealthDetailListResultPoller) FinalResponse(ctx context.Context) (*VpnClientConnectionHealthDetailListResultResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VpnClientConnectionHealthDetailListResult != VpnClientConnectionHealthDetailListResult{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVpnClientConnectionHealthDetailListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnClientConnectionHealthDetailListResultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *vpnClientConnectionHealthDetailListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnClientConnectionHealthDetailListResultResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *vpnClientConnectionHealthDetailListResultPoller) handleResponse(resp *azcore.Response) (*VpnClientConnectionHealthDetailListResultResponse, error) {
	result := VpnClientConnectionHealthDetailListResultResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VpnClientConnectionHealthDetailListResult)
}

// VpnClientIPsecParametersPoller provides polling facilities until the operation completes
type VpnClientIPsecParametersPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnClientIPsecParametersResponse, error)
	ResumeToken() (string, error)
}

type vpnClientIPsecParametersPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnClientIPsecParametersPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnClientIPsecParametersPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *vpnClientIPsecParametersPoller) FinalResponse(ctx context.Context) (*VpnClientIPsecParametersResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VpnClientIPsecParameters != VpnClientIPsecParameters{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVpnClientIPsecParametersPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnClientIPsecParametersPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *vpnClientIPsecParametersPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnClientIPsecParametersResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *vpnClientIPsecParametersPoller) handleResponse(resp *azcore.Response) (*VpnClientIPsecParametersResponse, error) {
	result := VpnClientIPsecParametersResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VpnClientIPsecParameters)
}

// VpnConnectionPoller provides polling facilities until the operation completes
type VpnConnectionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnConnectionResponse, error)
	ResumeToken() (string, error)
}

type vpnConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnConnectionPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *vpnConnectionPoller) FinalResponse(ctx context.Context) (*VpnConnectionResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VpnConnection != VpnConnection{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVpnConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnConnectionPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *vpnConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnConnectionResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *vpnConnectionPoller) handleResponse(resp *azcore.Response) (*VpnConnectionResponse, error) {
	result := VpnConnectionResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VpnConnection)
}

// VpnGatewayPoller provides polling facilities until the operation completes
type VpnGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnGatewayResponse, error)
	ResumeToken() (string, error)
}

type vpnGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnGatewayPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *vpnGatewayPoller) FinalResponse(ctx context.Context) (*VpnGatewayResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VpnGateway != VpnGateway{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVpnGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnGatewayPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *vpnGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnGatewayResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *vpnGatewayPoller) handleResponse(resp *azcore.Response) (*VpnGatewayResponse, error) {
	result := VpnGatewayResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VpnGateway)
}

// VpnProfileResponsePoller provides polling facilities until the operation completes
type VpnProfileResponsePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnProfileResponseResponse, error)
	ResumeToken() (string, error)
}

type vpnProfileResponsePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnProfileResponsePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnProfileResponsePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *vpnProfileResponsePoller) FinalResponse(ctx context.Context) (*VpnProfileResponseResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VpnProfileResponse != VpnProfileResponse{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVpnProfileResponsePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnProfileResponsePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *vpnProfileResponsePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnProfileResponseResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *vpnProfileResponsePoller) handleResponse(resp *azcore.Response) (*VpnProfileResponseResponse, error) {
	result := VpnProfileResponseResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VpnProfileResponse)
}

// VpnServerConfigurationPoller provides polling facilities until the operation completes
type VpnServerConfigurationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnServerConfigurationResponse, error)
	ResumeToken() (string, error)
}

type vpnServerConfigurationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnServerConfigurationPoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnServerConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *vpnServerConfigurationPoller) FinalResponse(ctx context.Context) (*VpnServerConfigurationResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VpnServerConfiguration != VpnServerConfiguration{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVpnServerConfigurationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnServerConfigurationPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *vpnServerConfigurationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnServerConfigurationResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *vpnServerConfigurationPoller) handleResponse(resp *azcore.Response) (*VpnServerConfigurationResponse, error) {
	result := VpnServerConfigurationResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VpnServerConfiguration)
}

// VpnServerConfigurationsResponsePoller provides polling facilities until the operation completes
type VpnServerConfigurationsResponsePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnServerConfigurationsResponseResponse, error)
	ResumeToken() (string, error)
}

type vpnServerConfigurationsResponsePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnServerConfigurationsResponsePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnServerConfigurationsResponsePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *vpnServerConfigurationsResponsePoller) FinalResponse(ctx context.Context) (*VpnServerConfigurationsResponseResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VpnServerConfigurationsResponse != VpnServerConfigurationsResponse{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVpnServerConfigurationsResponsePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnServerConfigurationsResponsePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *vpnServerConfigurationsResponsePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnServerConfigurationsResponseResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *vpnServerConfigurationsResponsePoller) handleResponse(resp *azcore.Response) (*VpnServerConfigurationsResponseResponse, error) {
	result := VpnServerConfigurationsResponseResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VpnServerConfigurationsResponse)
}

// VpnSitePoller provides polling facilities until the operation completes
type VpnSitePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnSiteResponse, error)
	ResumeToken() (string, error)
}

type vpnSitePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       pollingTracker
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnSitePoller) Done() bool {
	return p.pt.hasTerminated()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnSitePoller) Poll(ctx context.Context) (*http.Response, error) {
	if lroPollDone(ctx, p.pipeline, p.pt) {
		return p.pt.latestResponse().Response, p.pt.pollingError()
	}
	return nil, p.pt.pollingError()
}

func (p *vpnSitePoller) FinalResponse(ctx context.Context) (*VpnSiteResponse, error) {
	if !p.Done() {
		return nil, errors.New("cannot return a final response from a poller in a non-terminal state")
	}
	if p.pt.pollerMethodVerb() == http.MethodPut || p.pt.pollerMethodVerb() == http.MethodPatch {
		res, err := p.handleResponse(p.pt.latestResponse())
		if err != nil {
			return nil, err
		}
		if res != nil && (*res.VpnSite != VpnSite{}) {
			return res, nil
		}
	}
	// checking if there was a FinalStateVia configuration to re-route the final GET
	// request to the value specified in the FinalStateVia property on the poller
	err := p.pt.setFinalState()
	if err != nil {
		return nil, err
	}
	if p.pt.finalGetURL() == "" {
		// we can end up in this situation if the async operation returns a 200
		// with no polling URLs.  in that case return the response which should
		// contain the JSON payload (only do this for successful terminal cases).
		if lr := p.pt.latestResponse(); lr != nil && p.pt.hasSucceeded() {
			result, err := p.handleResponse(lr)
			if err != nil {
				return nil, err
			}
			return result, nil
		}
		return nil, errors.New("missing URL for retrieving result")
	}
	u, err := url.Parse(p.pt.finalGetURL())
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if err != nil {
		return nil, err
	}
	resp, err := p.pipeline.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(resp)
}

// ResumeToken generates the string token that can be used with the ResumeVpnSitePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnSitePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (p *vpnSitePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnSiteResponse, error) {
	// initial check for a retry-after header existing on the initial response
	if retryAfter := azcore.RetryAfter(p.pt.latestResponse().Response); retryAfter > 0 {
		err := delay(ctx, retryAfter)
		if err != nil {
			return nil, err
		}
	}
	// begin polling the endpoint until a terminal state is reached
	for {
		resp, err := p.Poll(ctx)
		if err != nil {
			return nil, err
		}
		if p.Done() {
			break
		}
		d := frequency
		if retryAfter := azcore.RetryAfter(resp); retryAfter > 0 {
			d = retryAfter
		}
		err = delay(ctx, d)
		if err != nil {
			return nil, err
		}
	}
	return p.FinalResponse(ctx)
}

func (p *vpnSitePoller) handleResponse(resp *azcore.Response) (*VpnSiteResponse, error) {
	result := VpnSiteResponse{RawResponse: resp.Response}
	if resp.HasStatusCode(http.StatusNoContent) {
		return &result, nil
	}
	if !resp.HasStatusCode(pollingCodes[:]...) {
		return nil, p.pt.handleError(resp)
	}
	return &result, resp.UnmarshalAsJSON(&result.VpnSite)
}

func delay(ctx context.Context, delay time.Duration) error {
	select {
	case <-time.After(delay):
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}
