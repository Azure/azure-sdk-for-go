// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// ApplicationGatewayAvailableSslPredefinedPoliciesPager provides iteration over ApplicationGatewayAvailableSslPredefinedPolicies pages.
type ApplicationGatewayAvailableSslPredefinedPoliciesPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ApplicationGatewayAvailableSslPredefinedPoliciesResponse.
	PageResponse() *ApplicationGatewayAvailableSslPredefinedPoliciesResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type applicationGatewayAvailableSslPredefinedPoliciesCreateRequest func(context.Context) (*azcore.Request, error)

type applicationGatewayAvailableSslPredefinedPoliciesHandleError func(*azcore.Response) error

type applicationGatewayAvailableSslPredefinedPoliciesHandleResponse func(*azcore.Response) (*ApplicationGatewayAvailableSslPredefinedPoliciesResponse, error)

type applicationGatewayAvailableSslPredefinedPoliciesAdvancePage func(context.Context, *ApplicationGatewayAvailableSslPredefinedPoliciesResponse) (*azcore.Request, error)

type applicationGatewayAvailableSslPredefinedPoliciesPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester applicationGatewayAvailableSslPredefinedPoliciesCreateRequest
	// callback for handling response errors
	errorer applicationGatewayAvailableSslPredefinedPoliciesHandleError
	// callback for handling the HTTP response
	responder applicationGatewayAvailableSslPredefinedPoliciesHandleResponse
	// callback for advancing to the next page
	advancer applicationGatewayAvailableSslPredefinedPoliciesAdvancePage
	// contains the current response
	current *ApplicationGatewayAvailableSslPredefinedPoliciesResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *applicationGatewayAvailableSslPredefinedPoliciesPager) Err() error {
	return p.err
}

func (p *applicationGatewayAvailableSslPredefinedPoliciesPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ApplicationGatewayAvailableSslPredefinedPolicies.NextLink == nil || len(*p.current.ApplicationGatewayAvailableSslPredefinedPolicies.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *applicationGatewayAvailableSslPredefinedPoliciesPager) PageResponse() *ApplicationGatewayAvailableSslPredefinedPoliciesResponse {
	return p.current
}

// ApplicationGatewayListResultPager provides iteration over ApplicationGatewayListResult pages.
type ApplicationGatewayListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ApplicationGatewayListResultResponse.
	PageResponse() *ApplicationGatewayListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type applicationGatewayListResultCreateRequest func(context.Context) (*azcore.Request, error)

type applicationGatewayListResultHandleError func(*azcore.Response) error

type applicationGatewayListResultHandleResponse func(*azcore.Response) (*ApplicationGatewayListResultResponse, error)

type applicationGatewayListResultAdvancePage func(context.Context, *ApplicationGatewayListResultResponse) (*azcore.Request, error)

type applicationGatewayListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester applicationGatewayListResultCreateRequest
	// callback for handling response errors
	errorer applicationGatewayListResultHandleError
	// callback for handling the HTTP response
	responder applicationGatewayListResultHandleResponse
	// callback for advancing to the next page
	advancer applicationGatewayListResultAdvancePage
	// contains the current response
	current *ApplicationGatewayListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *applicationGatewayListResultPager) Err() error {
	return p.err
}

func (p *applicationGatewayListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ApplicationGatewayListResult.NextLink == nil || len(*p.current.ApplicationGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *applicationGatewayListResultPager) PageResponse() *ApplicationGatewayListResultResponse {
	return p.current
}

// ApplicationSecurityGroupListResultPager provides iteration over ApplicationSecurityGroupListResult pages.
type ApplicationSecurityGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ApplicationSecurityGroupListResultResponse.
	PageResponse() *ApplicationSecurityGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type applicationSecurityGroupListResultCreateRequest func(context.Context) (*azcore.Request, error)

type applicationSecurityGroupListResultHandleError func(*azcore.Response) error

type applicationSecurityGroupListResultHandleResponse func(*azcore.Response) (*ApplicationSecurityGroupListResultResponse, error)

type applicationSecurityGroupListResultAdvancePage func(context.Context, *ApplicationSecurityGroupListResultResponse) (*azcore.Request, error)

type applicationSecurityGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester applicationSecurityGroupListResultCreateRequest
	// callback for handling response errors
	errorer applicationSecurityGroupListResultHandleError
	// callback for handling the HTTP response
	responder applicationSecurityGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer applicationSecurityGroupListResultAdvancePage
	// contains the current response
	current *ApplicationSecurityGroupListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *applicationSecurityGroupListResultPager) Err() error {
	return p.err
}

func (p *applicationSecurityGroupListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ApplicationSecurityGroupListResult.NextLink == nil || len(*p.current.ApplicationSecurityGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *applicationSecurityGroupListResultPager) PageResponse() *ApplicationSecurityGroupListResultResponse {
	return p.current
}

// AuthorizationListResultPager provides iteration over AuthorizationListResult pages.
type AuthorizationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AuthorizationListResultResponse.
	PageResponse() *AuthorizationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type authorizationListResultCreateRequest func(context.Context) (*azcore.Request, error)

type authorizationListResultHandleError func(*azcore.Response) error

type authorizationListResultHandleResponse func(*azcore.Response) (*AuthorizationListResultResponse, error)

type authorizationListResultAdvancePage func(context.Context, *AuthorizationListResultResponse) (*azcore.Request, error)

type authorizationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester authorizationListResultCreateRequest
	// callback for handling response errors
	errorer authorizationListResultHandleError
	// callback for handling the HTTP response
	responder authorizationListResultHandleResponse
	// callback for advancing to the next page
	advancer authorizationListResultAdvancePage
	// contains the current response
	current *AuthorizationListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *authorizationListResultPager) Err() error {
	return p.err
}

func (p *authorizationListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.AuthorizationListResult.NextLink == nil || len(*p.current.AuthorizationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *authorizationListResultPager) PageResponse() *AuthorizationListResultResponse {
	return p.current
}

// AutoApprovedPrivateLinkServicesResultPager provides iteration over AutoApprovedPrivateLinkServicesResult pages.
type AutoApprovedPrivateLinkServicesResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AutoApprovedPrivateLinkServicesResultResponse.
	PageResponse() *AutoApprovedPrivateLinkServicesResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type autoApprovedPrivateLinkServicesResultCreateRequest func(context.Context) (*azcore.Request, error)

type autoApprovedPrivateLinkServicesResultHandleError func(*azcore.Response) error

type autoApprovedPrivateLinkServicesResultHandleResponse func(*azcore.Response) (*AutoApprovedPrivateLinkServicesResultResponse, error)

type autoApprovedPrivateLinkServicesResultAdvancePage func(context.Context, *AutoApprovedPrivateLinkServicesResultResponse) (*azcore.Request, error)

type autoApprovedPrivateLinkServicesResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester autoApprovedPrivateLinkServicesResultCreateRequest
	// callback for handling response errors
	errorer autoApprovedPrivateLinkServicesResultHandleError
	// callback for handling the HTTP response
	responder autoApprovedPrivateLinkServicesResultHandleResponse
	// callback for advancing to the next page
	advancer autoApprovedPrivateLinkServicesResultAdvancePage
	// contains the current response
	current *AutoApprovedPrivateLinkServicesResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *autoApprovedPrivateLinkServicesResultPager) Err() error {
	return p.err
}

func (p *autoApprovedPrivateLinkServicesResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.AutoApprovedPrivateLinkServicesResult.NextLink == nil || len(*p.current.AutoApprovedPrivateLinkServicesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *autoApprovedPrivateLinkServicesResultPager) PageResponse() *AutoApprovedPrivateLinkServicesResultResponse {
	return p.current
}

// AvailableDelegationsResultPager provides iteration over AvailableDelegationsResult pages.
type AvailableDelegationsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AvailableDelegationsResultResponse.
	PageResponse() *AvailableDelegationsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type availableDelegationsResultCreateRequest func(context.Context) (*azcore.Request, error)

type availableDelegationsResultHandleError func(*azcore.Response) error

type availableDelegationsResultHandleResponse func(*azcore.Response) (*AvailableDelegationsResultResponse, error)

type availableDelegationsResultAdvancePage func(context.Context, *AvailableDelegationsResultResponse) (*azcore.Request, error)

type availableDelegationsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester availableDelegationsResultCreateRequest
	// callback for handling response errors
	errorer availableDelegationsResultHandleError
	// callback for handling the HTTP response
	responder availableDelegationsResultHandleResponse
	// callback for advancing to the next page
	advancer availableDelegationsResultAdvancePage
	// contains the current response
	current *AvailableDelegationsResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *availableDelegationsResultPager) Err() error {
	return p.err
}

func (p *availableDelegationsResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.AvailableDelegationsResult.NextLink == nil || len(*p.current.AvailableDelegationsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *availableDelegationsResultPager) PageResponse() *AvailableDelegationsResultResponse {
	return p.current
}

// AvailablePrivateEndpointTypesResultPager provides iteration over AvailablePrivateEndpointTypesResult pages.
type AvailablePrivateEndpointTypesResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AvailablePrivateEndpointTypesResultResponse.
	PageResponse() *AvailablePrivateEndpointTypesResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type availablePrivateEndpointTypesResultCreateRequest func(context.Context) (*azcore.Request, error)

type availablePrivateEndpointTypesResultHandleError func(*azcore.Response) error

type availablePrivateEndpointTypesResultHandleResponse func(*azcore.Response) (*AvailablePrivateEndpointTypesResultResponse, error)

type availablePrivateEndpointTypesResultAdvancePage func(context.Context, *AvailablePrivateEndpointTypesResultResponse) (*azcore.Request, error)

type availablePrivateEndpointTypesResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester availablePrivateEndpointTypesResultCreateRequest
	// callback for handling response errors
	errorer availablePrivateEndpointTypesResultHandleError
	// callback for handling the HTTP response
	responder availablePrivateEndpointTypesResultHandleResponse
	// callback for advancing to the next page
	advancer availablePrivateEndpointTypesResultAdvancePage
	// contains the current response
	current *AvailablePrivateEndpointTypesResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *availablePrivateEndpointTypesResultPager) Err() error {
	return p.err
}

func (p *availablePrivateEndpointTypesResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.AvailablePrivateEndpointTypesResult.NextLink == nil || len(*p.current.AvailablePrivateEndpointTypesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *availablePrivateEndpointTypesResultPager) PageResponse() *AvailablePrivateEndpointTypesResultResponse {
	return p.current
}

// AvailableServiceAliasesResultPager provides iteration over AvailableServiceAliasesResult pages.
type AvailableServiceAliasesResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AvailableServiceAliasesResultResponse.
	PageResponse() *AvailableServiceAliasesResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type availableServiceAliasesResultCreateRequest func(context.Context) (*azcore.Request, error)

type availableServiceAliasesResultHandleError func(*azcore.Response) error

type availableServiceAliasesResultHandleResponse func(*azcore.Response) (*AvailableServiceAliasesResultResponse, error)

type availableServiceAliasesResultAdvancePage func(context.Context, *AvailableServiceAliasesResultResponse) (*azcore.Request, error)

type availableServiceAliasesResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester availableServiceAliasesResultCreateRequest
	// callback for handling response errors
	errorer availableServiceAliasesResultHandleError
	// callback for handling the HTTP response
	responder availableServiceAliasesResultHandleResponse
	// callback for advancing to the next page
	advancer availableServiceAliasesResultAdvancePage
	// contains the current response
	current *AvailableServiceAliasesResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *availableServiceAliasesResultPager) Err() error {
	return p.err
}

func (p *availableServiceAliasesResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.AvailableServiceAliasesResult.NextLink == nil || len(*p.current.AvailableServiceAliasesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *availableServiceAliasesResultPager) PageResponse() *AvailableServiceAliasesResultResponse {
	return p.current
}

// AzureFirewallFqdnTagListResultPager provides iteration over AzureFirewallFqdnTagListResult pages.
type AzureFirewallFqdnTagListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AzureFirewallFqdnTagListResultResponse.
	PageResponse() *AzureFirewallFqdnTagListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type azureFirewallFqdnTagListResultCreateRequest func(context.Context) (*azcore.Request, error)

type azureFirewallFqdnTagListResultHandleError func(*azcore.Response) error

type azureFirewallFqdnTagListResultHandleResponse func(*azcore.Response) (*AzureFirewallFqdnTagListResultResponse, error)

type azureFirewallFqdnTagListResultAdvancePage func(context.Context, *AzureFirewallFqdnTagListResultResponse) (*azcore.Request, error)

type azureFirewallFqdnTagListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester azureFirewallFqdnTagListResultCreateRequest
	// callback for handling response errors
	errorer azureFirewallFqdnTagListResultHandleError
	// callback for handling the HTTP response
	responder azureFirewallFqdnTagListResultHandleResponse
	// callback for advancing to the next page
	advancer azureFirewallFqdnTagListResultAdvancePage
	// contains the current response
	current *AzureFirewallFqdnTagListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *azureFirewallFqdnTagListResultPager) Err() error {
	return p.err
}

func (p *azureFirewallFqdnTagListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.AzureFirewallFqdnTagListResult.NextLink == nil || len(*p.current.AzureFirewallFqdnTagListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *azureFirewallFqdnTagListResultPager) PageResponse() *AzureFirewallFqdnTagListResultResponse {
	return p.current
}

// AzureFirewallListResultPager provides iteration over AzureFirewallListResult pages.
type AzureFirewallListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current AzureFirewallListResultResponse.
	PageResponse() *AzureFirewallListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type azureFirewallListResultCreateRequest func(context.Context) (*azcore.Request, error)

type azureFirewallListResultHandleError func(*azcore.Response) error

type azureFirewallListResultHandleResponse func(*azcore.Response) (*AzureFirewallListResultResponse, error)

type azureFirewallListResultAdvancePage func(context.Context, *AzureFirewallListResultResponse) (*azcore.Request, error)

type azureFirewallListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester azureFirewallListResultCreateRequest
	// callback for handling response errors
	errorer azureFirewallListResultHandleError
	// callback for handling the HTTP response
	responder azureFirewallListResultHandleResponse
	// callback for advancing to the next page
	advancer azureFirewallListResultAdvancePage
	// contains the current response
	current *AzureFirewallListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *azureFirewallListResultPager) Err() error {
	return p.err
}

func (p *azureFirewallListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.AzureFirewallListResult.NextLink == nil || len(*p.current.AzureFirewallListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *azureFirewallListResultPager) PageResponse() *AzureFirewallListResultResponse {
	return p.current
}

// BastionActiveSessionListResultPager provides iteration over BastionActiveSessionListResult pages.
type BastionActiveSessionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current BastionActiveSessionListResultResponse.
	PageResponse() *BastionActiveSessionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type bastionActiveSessionListResultCreateRequest func(context.Context) (*azcore.Request, error)

type bastionActiveSessionListResultHandleError func(*azcore.Response) error

type bastionActiveSessionListResultHandleResponse func(*azcore.Response) (*BastionActiveSessionListResultResponse, error)

type bastionActiveSessionListResultAdvancePage func(context.Context, *BastionActiveSessionListResultResponse) (*azcore.Request, error)

type bastionActiveSessionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester bastionActiveSessionListResultCreateRequest
	// callback for handling response errors
	errorer bastionActiveSessionListResultHandleError
	// callback for handling the HTTP response
	responder bastionActiveSessionListResultHandleResponse
	// callback for advancing to the next page
	advancer bastionActiveSessionListResultAdvancePage
	// contains the current response
	current *BastionActiveSessionListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
	// previous response from the endpoint (LRO case)
	resp *azcore.Response
}

func (p *bastionActiveSessionListResultPager) Err() error {
	return p.err
}

func (p *bastionActiveSessionListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.BastionActiveSessionListResult.NextLink == nil || len(*p.current.BastionActiveSessionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else if p.resp == nil {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp := p.resp
	if resp == nil {
		resp, err = p.pipeline.Do(req)
	} else {
		p.resp = nil
	}
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *bastionActiveSessionListResultPager) PageResponse() *BastionActiveSessionListResultResponse {
	return p.current
}

// BastionHostListResultPager provides iteration over BastionHostListResult pages.
type BastionHostListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current BastionHostListResultResponse.
	PageResponse() *BastionHostListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type bastionHostListResultCreateRequest func(context.Context) (*azcore.Request, error)

type bastionHostListResultHandleError func(*azcore.Response) error

type bastionHostListResultHandleResponse func(*azcore.Response) (*BastionHostListResultResponse, error)

type bastionHostListResultAdvancePage func(context.Context, *BastionHostListResultResponse) (*azcore.Request, error)

type bastionHostListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester bastionHostListResultCreateRequest
	// callback for handling response errors
	errorer bastionHostListResultHandleError
	// callback for handling the HTTP response
	responder bastionHostListResultHandleResponse
	// callback for advancing to the next page
	advancer bastionHostListResultAdvancePage
	// contains the current response
	current *BastionHostListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *bastionHostListResultPager) Err() error {
	return p.err
}

func (p *bastionHostListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.BastionHostListResult.NextLink == nil || len(*p.current.BastionHostListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *bastionHostListResultPager) PageResponse() *BastionHostListResultResponse {
	return p.current
}

// BastionSessionDeleteResultPager provides iteration over BastionSessionDeleteResult pages.
type BastionSessionDeleteResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current BastionSessionDeleteResultResponse.
	PageResponse() *BastionSessionDeleteResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type bastionSessionDeleteResultCreateRequest func(context.Context) (*azcore.Request, error)

type bastionSessionDeleteResultHandleError func(*azcore.Response) error

type bastionSessionDeleteResultHandleResponse func(*azcore.Response) (*BastionSessionDeleteResultResponse, error)

type bastionSessionDeleteResultAdvancePage func(context.Context, *BastionSessionDeleteResultResponse) (*azcore.Request, error)

type bastionSessionDeleteResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester bastionSessionDeleteResultCreateRequest
	// callback for handling response errors
	errorer bastionSessionDeleteResultHandleError
	// callback for handling the HTTP response
	responder bastionSessionDeleteResultHandleResponse
	// callback for advancing to the next page
	advancer bastionSessionDeleteResultAdvancePage
	// contains the current response
	current *BastionSessionDeleteResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *bastionSessionDeleteResultPager) Err() error {
	return p.err
}

func (p *bastionSessionDeleteResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.BastionSessionDeleteResult.NextLink == nil || len(*p.current.BastionSessionDeleteResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *bastionSessionDeleteResultPager) PageResponse() *BastionSessionDeleteResultResponse {
	return p.current
}

// BastionShareableLinkListResultPager provides iteration over BastionShareableLinkListResult pages.
type BastionShareableLinkListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current BastionShareableLinkListResultResponse.
	PageResponse() *BastionShareableLinkListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type bastionShareableLinkListResultCreateRequest func(context.Context) (*azcore.Request, error)

type bastionShareableLinkListResultHandleError func(*azcore.Response) error

type bastionShareableLinkListResultHandleResponse func(*azcore.Response) (*BastionShareableLinkListResultResponse, error)

type bastionShareableLinkListResultAdvancePage func(context.Context, *BastionShareableLinkListResultResponse) (*azcore.Request, error)

type bastionShareableLinkListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester bastionShareableLinkListResultCreateRequest
	// callback for handling response errors
	errorer bastionShareableLinkListResultHandleError
	// callback for handling the HTTP response
	responder bastionShareableLinkListResultHandleResponse
	// callback for advancing to the next page
	advancer bastionShareableLinkListResultAdvancePage
	// contains the current response
	current *BastionShareableLinkListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
	// previous response from the endpoint (LRO case)
	resp *azcore.Response
}

func (p *bastionShareableLinkListResultPager) Err() error {
	return p.err
}

func (p *bastionShareableLinkListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.BastionShareableLinkListResult.NextLink == nil || len(*p.current.BastionShareableLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else if p.resp == nil {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp := p.resp
	if resp == nil {
		resp, err = p.pipeline.Do(req)
	} else {
		p.resp = nil
	}
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *bastionShareableLinkListResultPager) PageResponse() *BastionShareableLinkListResultResponse {
	return p.current
}

// BgpServiceCommunityListResultPager provides iteration over BgpServiceCommunityListResult pages.
type BgpServiceCommunityListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current BgpServiceCommunityListResultResponse.
	PageResponse() *BgpServiceCommunityListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type bgpServiceCommunityListResultCreateRequest func(context.Context) (*azcore.Request, error)

type bgpServiceCommunityListResultHandleError func(*azcore.Response) error

type bgpServiceCommunityListResultHandleResponse func(*azcore.Response) (*BgpServiceCommunityListResultResponse, error)

type bgpServiceCommunityListResultAdvancePage func(context.Context, *BgpServiceCommunityListResultResponse) (*azcore.Request, error)

type bgpServiceCommunityListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester bgpServiceCommunityListResultCreateRequest
	// callback for handling response errors
	errorer bgpServiceCommunityListResultHandleError
	// callback for handling the HTTP response
	responder bgpServiceCommunityListResultHandleResponse
	// callback for advancing to the next page
	advancer bgpServiceCommunityListResultAdvancePage
	// contains the current response
	current *BgpServiceCommunityListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *bgpServiceCommunityListResultPager) Err() error {
	return p.err
}

func (p *bgpServiceCommunityListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.BgpServiceCommunityListResult.NextLink == nil || len(*p.current.BgpServiceCommunityListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *bgpServiceCommunityListResultPager) PageResponse() *BgpServiceCommunityListResultResponse {
	return p.current
}

// DdosProtectionPlanListResultPager provides iteration over DdosProtectionPlanListResult pages.
type DdosProtectionPlanListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current DdosProtectionPlanListResultResponse.
	PageResponse() *DdosProtectionPlanListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type ddosProtectionPlanListResultCreateRequest func(context.Context) (*azcore.Request, error)

type ddosProtectionPlanListResultHandleError func(*azcore.Response) error

type ddosProtectionPlanListResultHandleResponse func(*azcore.Response) (*DdosProtectionPlanListResultResponse, error)

type ddosProtectionPlanListResultAdvancePage func(context.Context, *DdosProtectionPlanListResultResponse) (*azcore.Request, error)

type ddosProtectionPlanListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester ddosProtectionPlanListResultCreateRequest
	// callback for handling response errors
	errorer ddosProtectionPlanListResultHandleError
	// callback for handling the HTTP response
	responder ddosProtectionPlanListResultHandleResponse
	// callback for advancing to the next page
	advancer ddosProtectionPlanListResultAdvancePage
	// contains the current response
	current *DdosProtectionPlanListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *ddosProtectionPlanListResultPager) Err() error {
	return p.err
}

func (p *ddosProtectionPlanListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.DdosProtectionPlanListResult.NextLink == nil || len(*p.current.DdosProtectionPlanListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *ddosProtectionPlanListResultPager) PageResponse() *DdosProtectionPlanListResultResponse {
	return p.current
}

// EndpointServicesListResultPager provides iteration over EndpointServicesListResult pages.
type EndpointServicesListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current EndpointServicesListResultResponse.
	PageResponse() *EndpointServicesListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type endpointServicesListResultCreateRequest func(context.Context) (*azcore.Request, error)

type endpointServicesListResultHandleError func(*azcore.Response) error

type endpointServicesListResultHandleResponse func(*azcore.Response) (*EndpointServicesListResultResponse, error)

type endpointServicesListResultAdvancePage func(context.Context, *EndpointServicesListResultResponse) (*azcore.Request, error)

type endpointServicesListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester endpointServicesListResultCreateRequest
	// callback for handling response errors
	errorer endpointServicesListResultHandleError
	// callback for handling the HTTP response
	responder endpointServicesListResultHandleResponse
	// callback for advancing to the next page
	advancer endpointServicesListResultAdvancePage
	// contains the current response
	current *EndpointServicesListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *endpointServicesListResultPager) Err() error {
	return p.err
}

func (p *endpointServicesListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.EndpointServicesListResult.NextLink == nil || len(*p.current.EndpointServicesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *endpointServicesListResultPager) PageResponse() *EndpointServicesListResultResponse {
	return p.current
}

// ExpressRouteCircuitConnectionListResultPager provides iteration over ExpressRouteCircuitConnectionListResult pages.
type ExpressRouteCircuitConnectionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteCircuitConnectionListResultResponse.
	PageResponse() *ExpressRouteCircuitConnectionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteCircuitConnectionListResultCreateRequest func(context.Context) (*azcore.Request, error)

type expressRouteCircuitConnectionListResultHandleError func(*azcore.Response) error

type expressRouteCircuitConnectionListResultHandleResponse func(*azcore.Response) (*ExpressRouteCircuitConnectionListResultResponse, error)

type expressRouteCircuitConnectionListResultAdvancePage func(context.Context, *ExpressRouteCircuitConnectionListResultResponse) (*azcore.Request, error)

type expressRouteCircuitConnectionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester expressRouteCircuitConnectionListResultCreateRequest
	// callback for handling response errors
	errorer expressRouteCircuitConnectionListResultHandleError
	// callback for handling the HTTP response
	responder expressRouteCircuitConnectionListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRouteCircuitConnectionListResultAdvancePage
	// contains the current response
	current *ExpressRouteCircuitConnectionListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *expressRouteCircuitConnectionListResultPager) Err() error {
	return p.err
}

func (p *expressRouteCircuitConnectionListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ExpressRouteCircuitConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteCircuitConnectionListResultPager) PageResponse() *ExpressRouteCircuitConnectionListResultResponse {
	return p.current
}

// ExpressRouteCircuitListResultPager provides iteration over ExpressRouteCircuitListResult pages.
type ExpressRouteCircuitListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteCircuitListResultResponse.
	PageResponse() *ExpressRouteCircuitListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteCircuitListResultCreateRequest func(context.Context) (*azcore.Request, error)

type expressRouteCircuitListResultHandleError func(*azcore.Response) error

type expressRouteCircuitListResultHandleResponse func(*azcore.Response) (*ExpressRouteCircuitListResultResponse, error)

type expressRouteCircuitListResultAdvancePage func(context.Context, *ExpressRouteCircuitListResultResponse) (*azcore.Request, error)

type expressRouteCircuitListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester expressRouteCircuitListResultCreateRequest
	// callback for handling response errors
	errorer expressRouteCircuitListResultHandleError
	// callback for handling the HTTP response
	responder expressRouteCircuitListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRouteCircuitListResultAdvancePage
	// contains the current response
	current *ExpressRouteCircuitListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *expressRouteCircuitListResultPager) Err() error {
	return p.err
}

func (p *expressRouteCircuitListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ExpressRouteCircuitListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteCircuitListResultPager) PageResponse() *ExpressRouteCircuitListResultResponse {
	return p.current
}

// ExpressRouteCircuitPeeringListResultPager provides iteration over ExpressRouteCircuitPeeringListResult pages.
type ExpressRouteCircuitPeeringListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteCircuitPeeringListResultResponse.
	PageResponse() *ExpressRouteCircuitPeeringListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteCircuitPeeringListResultCreateRequest func(context.Context) (*azcore.Request, error)

type expressRouteCircuitPeeringListResultHandleError func(*azcore.Response) error

type expressRouteCircuitPeeringListResultHandleResponse func(*azcore.Response) (*ExpressRouteCircuitPeeringListResultResponse, error)

type expressRouteCircuitPeeringListResultAdvancePage func(context.Context, *ExpressRouteCircuitPeeringListResultResponse) (*azcore.Request, error)

type expressRouteCircuitPeeringListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester expressRouteCircuitPeeringListResultCreateRequest
	// callback for handling response errors
	errorer expressRouteCircuitPeeringListResultHandleError
	// callback for handling the HTTP response
	responder expressRouteCircuitPeeringListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRouteCircuitPeeringListResultAdvancePage
	// contains the current response
	current *ExpressRouteCircuitPeeringListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *expressRouteCircuitPeeringListResultPager) Err() error {
	return p.err
}

func (p *expressRouteCircuitPeeringListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ExpressRouteCircuitPeeringListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitPeeringListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteCircuitPeeringListResultPager) PageResponse() *ExpressRouteCircuitPeeringListResultResponse {
	return p.current
}

// ExpressRouteCrossConnectionListResultPager provides iteration over ExpressRouteCrossConnectionListResult pages.
type ExpressRouteCrossConnectionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteCrossConnectionListResultResponse.
	PageResponse() *ExpressRouteCrossConnectionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteCrossConnectionListResultCreateRequest func(context.Context) (*azcore.Request, error)

type expressRouteCrossConnectionListResultHandleError func(*azcore.Response) error

type expressRouteCrossConnectionListResultHandleResponse func(*azcore.Response) (*ExpressRouteCrossConnectionListResultResponse, error)

type expressRouteCrossConnectionListResultAdvancePage func(context.Context, *ExpressRouteCrossConnectionListResultResponse) (*azcore.Request, error)

type expressRouteCrossConnectionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester expressRouteCrossConnectionListResultCreateRequest
	// callback for handling response errors
	errorer expressRouteCrossConnectionListResultHandleError
	// callback for handling the HTTP response
	responder expressRouteCrossConnectionListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRouteCrossConnectionListResultAdvancePage
	// contains the current response
	current *ExpressRouteCrossConnectionListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *expressRouteCrossConnectionListResultPager) Err() error {
	return p.err
}

func (p *expressRouteCrossConnectionListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ExpressRouteCrossConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteCrossConnectionListResultPager) PageResponse() *ExpressRouteCrossConnectionListResultResponse {
	return p.current
}

// ExpressRouteCrossConnectionPeeringListPager provides iteration over ExpressRouteCrossConnectionPeeringList pages.
type ExpressRouteCrossConnectionPeeringListPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteCrossConnectionPeeringListResponse.
	PageResponse() *ExpressRouteCrossConnectionPeeringListResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteCrossConnectionPeeringListCreateRequest func(context.Context) (*azcore.Request, error)

type expressRouteCrossConnectionPeeringListHandleError func(*azcore.Response) error

type expressRouteCrossConnectionPeeringListHandleResponse func(*azcore.Response) (*ExpressRouteCrossConnectionPeeringListResponse, error)

type expressRouteCrossConnectionPeeringListAdvancePage func(context.Context, *ExpressRouteCrossConnectionPeeringListResponse) (*azcore.Request, error)

type expressRouteCrossConnectionPeeringListPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester expressRouteCrossConnectionPeeringListCreateRequest
	// callback for handling response errors
	errorer expressRouteCrossConnectionPeeringListHandleError
	// callback for handling the HTTP response
	responder expressRouteCrossConnectionPeeringListHandleResponse
	// callback for advancing to the next page
	advancer expressRouteCrossConnectionPeeringListAdvancePage
	// contains the current response
	current *ExpressRouteCrossConnectionPeeringListResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *expressRouteCrossConnectionPeeringListPager) Err() error {
	return p.err
}

func (p *expressRouteCrossConnectionPeeringListPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ExpressRouteCrossConnectionPeeringList.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionPeeringList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteCrossConnectionPeeringListPager) PageResponse() *ExpressRouteCrossConnectionPeeringListResponse {
	return p.current
}

// ExpressRouteLinkListResultPager provides iteration over ExpressRouteLinkListResult pages.
type ExpressRouteLinkListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteLinkListResultResponse.
	PageResponse() *ExpressRouteLinkListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteLinkListResultCreateRequest func(context.Context) (*azcore.Request, error)

type expressRouteLinkListResultHandleError func(*azcore.Response) error

type expressRouteLinkListResultHandleResponse func(*azcore.Response) (*ExpressRouteLinkListResultResponse, error)

type expressRouteLinkListResultAdvancePage func(context.Context, *ExpressRouteLinkListResultResponse) (*azcore.Request, error)

type expressRouteLinkListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester expressRouteLinkListResultCreateRequest
	// callback for handling response errors
	errorer expressRouteLinkListResultHandleError
	// callback for handling the HTTP response
	responder expressRouteLinkListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRouteLinkListResultAdvancePage
	// contains the current response
	current *ExpressRouteLinkListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *expressRouteLinkListResultPager) Err() error {
	return p.err
}

func (p *expressRouteLinkListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ExpressRouteLinkListResult.NextLink == nil || len(*p.current.ExpressRouteLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteLinkListResultPager) PageResponse() *ExpressRouteLinkListResultResponse {
	return p.current
}

// ExpressRoutePortListResultPager provides iteration over ExpressRoutePortListResult pages.
type ExpressRoutePortListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRoutePortListResultResponse.
	PageResponse() *ExpressRoutePortListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRoutePortListResultCreateRequest func(context.Context) (*azcore.Request, error)

type expressRoutePortListResultHandleError func(*azcore.Response) error

type expressRoutePortListResultHandleResponse func(*azcore.Response) (*ExpressRoutePortListResultResponse, error)

type expressRoutePortListResultAdvancePage func(context.Context, *ExpressRoutePortListResultResponse) (*azcore.Request, error)

type expressRoutePortListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester expressRoutePortListResultCreateRequest
	// callback for handling response errors
	errorer expressRoutePortListResultHandleError
	// callback for handling the HTTP response
	responder expressRoutePortListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRoutePortListResultAdvancePage
	// contains the current response
	current *ExpressRoutePortListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *expressRoutePortListResultPager) Err() error {
	return p.err
}

func (p *expressRoutePortListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ExpressRoutePortListResult.NextLink == nil || len(*p.current.ExpressRoutePortListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRoutePortListResultPager) PageResponse() *ExpressRoutePortListResultResponse {
	return p.current
}

// ExpressRoutePortsLocationListResultPager provides iteration over ExpressRoutePortsLocationListResult pages.
type ExpressRoutePortsLocationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRoutePortsLocationListResultResponse.
	PageResponse() *ExpressRoutePortsLocationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRoutePortsLocationListResultCreateRequest func(context.Context) (*azcore.Request, error)

type expressRoutePortsLocationListResultHandleError func(*azcore.Response) error

type expressRoutePortsLocationListResultHandleResponse func(*azcore.Response) (*ExpressRoutePortsLocationListResultResponse, error)

type expressRoutePortsLocationListResultAdvancePage func(context.Context, *ExpressRoutePortsLocationListResultResponse) (*azcore.Request, error)

type expressRoutePortsLocationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester expressRoutePortsLocationListResultCreateRequest
	// callback for handling response errors
	errorer expressRoutePortsLocationListResultHandleError
	// callback for handling the HTTP response
	responder expressRoutePortsLocationListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRoutePortsLocationListResultAdvancePage
	// contains the current response
	current *ExpressRoutePortsLocationListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *expressRoutePortsLocationListResultPager) Err() error {
	return p.err
}

func (p *expressRoutePortsLocationListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ExpressRoutePortsLocationListResult.NextLink == nil || len(*p.current.ExpressRoutePortsLocationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRoutePortsLocationListResultPager) PageResponse() *ExpressRoutePortsLocationListResultResponse {
	return p.current
}

// ExpressRouteServiceProviderListResultPager provides iteration over ExpressRouteServiceProviderListResult pages.
type ExpressRouteServiceProviderListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ExpressRouteServiceProviderListResultResponse.
	PageResponse() *ExpressRouteServiceProviderListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type expressRouteServiceProviderListResultCreateRequest func(context.Context) (*azcore.Request, error)

type expressRouteServiceProviderListResultHandleError func(*azcore.Response) error

type expressRouteServiceProviderListResultHandleResponse func(*azcore.Response) (*ExpressRouteServiceProviderListResultResponse, error)

type expressRouteServiceProviderListResultAdvancePage func(context.Context, *ExpressRouteServiceProviderListResultResponse) (*azcore.Request, error)

type expressRouteServiceProviderListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester expressRouteServiceProviderListResultCreateRequest
	// callback for handling response errors
	errorer expressRouteServiceProviderListResultHandleError
	// callback for handling the HTTP response
	responder expressRouteServiceProviderListResultHandleResponse
	// callback for advancing to the next page
	advancer expressRouteServiceProviderListResultAdvancePage
	// contains the current response
	current *ExpressRouteServiceProviderListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *expressRouteServiceProviderListResultPager) Err() error {
	return p.err
}

func (p *expressRouteServiceProviderListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ExpressRouteServiceProviderListResult.NextLink == nil || len(*p.current.ExpressRouteServiceProviderListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *expressRouteServiceProviderListResultPager) PageResponse() *ExpressRouteServiceProviderListResultResponse {
	return p.current
}

// FirewallPolicyListResultPager provides iteration over FirewallPolicyListResult pages.
type FirewallPolicyListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current FirewallPolicyListResultResponse.
	PageResponse() *FirewallPolicyListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type firewallPolicyListResultCreateRequest func(context.Context) (*azcore.Request, error)

type firewallPolicyListResultHandleError func(*azcore.Response) error

type firewallPolicyListResultHandleResponse func(*azcore.Response) (*FirewallPolicyListResultResponse, error)

type firewallPolicyListResultAdvancePage func(context.Context, *FirewallPolicyListResultResponse) (*azcore.Request, error)

type firewallPolicyListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester firewallPolicyListResultCreateRequest
	// callback for handling response errors
	errorer firewallPolicyListResultHandleError
	// callback for handling the HTTP response
	responder firewallPolicyListResultHandleResponse
	// callback for advancing to the next page
	advancer firewallPolicyListResultAdvancePage
	// contains the current response
	current *FirewallPolicyListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *firewallPolicyListResultPager) Err() error {
	return p.err
}

func (p *firewallPolicyListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.FirewallPolicyListResult.NextLink == nil || len(*p.current.FirewallPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *firewallPolicyListResultPager) PageResponse() *FirewallPolicyListResultResponse {
	return p.current
}

// FirewallPolicyRuleGroupListResultPager provides iteration over FirewallPolicyRuleGroupListResult pages.
type FirewallPolicyRuleGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current FirewallPolicyRuleGroupListResultResponse.
	PageResponse() *FirewallPolicyRuleGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type firewallPolicyRuleGroupListResultCreateRequest func(context.Context) (*azcore.Request, error)

type firewallPolicyRuleGroupListResultHandleError func(*azcore.Response) error

type firewallPolicyRuleGroupListResultHandleResponse func(*azcore.Response) (*FirewallPolicyRuleGroupListResultResponse, error)

type firewallPolicyRuleGroupListResultAdvancePage func(context.Context, *FirewallPolicyRuleGroupListResultResponse) (*azcore.Request, error)

type firewallPolicyRuleGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester firewallPolicyRuleGroupListResultCreateRequest
	// callback for handling response errors
	errorer firewallPolicyRuleGroupListResultHandleError
	// callback for handling the HTTP response
	responder firewallPolicyRuleGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer firewallPolicyRuleGroupListResultAdvancePage
	// contains the current response
	current *FirewallPolicyRuleGroupListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *firewallPolicyRuleGroupListResultPager) Err() error {
	return p.err
}

func (p *firewallPolicyRuleGroupListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.FirewallPolicyRuleGroupListResult.NextLink == nil || len(*p.current.FirewallPolicyRuleGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *firewallPolicyRuleGroupListResultPager) PageResponse() *FirewallPolicyRuleGroupListResultResponse {
	return p.current
}

// FlowLogListResultPager provides iteration over FlowLogListResult pages.
type FlowLogListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current FlowLogListResultResponse.
	PageResponse() *FlowLogListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type flowLogListResultCreateRequest func(context.Context) (*azcore.Request, error)

type flowLogListResultHandleError func(*azcore.Response) error

type flowLogListResultHandleResponse func(*azcore.Response) (*FlowLogListResultResponse, error)

type flowLogListResultAdvancePage func(context.Context, *FlowLogListResultResponse) (*azcore.Request, error)

type flowLogListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester flowLogListResultCreateRequest
	// callback for handling response errors
	errorer flowLogListResultHandleError
	// callback for handling the HTTP response
	responder flowLogListResultHandleResponse
	// callback for advancing to the next page
	advancer flowLogListResultAdvancePage
	// contains the current response
	current *FlowLogListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *flowLogListResultPager) Err() error {
	return p.err
}

func (p *flowLogListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.FlowLogListResult.NextLink == nil || len(*p.current.FlowLogListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *flowLogListResultPager) PageResponse() *FlowLogListResultResponse {
	return p.current
}

// IPAllocationListResultPager provides iteration over IPAllocationListResult pages.
type IPAllocationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current IPAllocationListResultResponse.
	PageResponse() *IPAllocationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type ipAllocationListResultCreateRequest func(context.Context) (*azcore.Request, error)

type ipAllocationListResultHandleError func(*azcore.Response) error

type ipAllocationListResultHandleResponse func(*azcore.Response) (*IPAllocationListResultResponse, error)

type ipAllocationListResultAdvancePage func(context.Context, *IPAllocationListResultResponse) (*azcore.Request, error)

type ipAllocationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester ipAllocationListResultCreateRequest
	// callback for handling response errors
	errorer ipAllocationListResultHandleError
	// callback for handling the HTTP response
	responder ipAllocationListResultHandleResponse
	// callback for advancing to the next page
	advancer ipAllocationListResultAdvancePage
	// contains the current response
	current *IPAllocationListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *ipAllocationListResultPager) Err() error {
	return p.err
}

func (p *ipAllocationListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.IPAllocationListResult.NextLink == nil || len(*p.current.IPAllocationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *ipAllocationListResultPager) PageResponse() *IPAllocationListResultResponse {
	return p.current
}

// IPGroupListResultPager provides iteration over IPGroupListResult pages.
type IPGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current IPGroupListResultResponse.
	PageResponse() *IPGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type ipGroupListResultCreateRequest func(context.Context) (*azcore.Request, error)

type ipGroupListResultHandleError func(*azcore.Response) error

type ipGroupListResultHandleResponse func(*azcore.Response) (*IPGroupListResultResponse, error)

type ipGroupListResultAdvancePage func(context.Context, *IPGroupListResultResponse) (*azcore.Request, error)

type ipGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester ipGroupListResultCreateRequest
	// callback for handling response errors
	errorer ipGroupListResultHandleError
	// callback for handling the HTTP response
	responder ipGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer ipGroupListResultAdvancePage
	// contains the current response
	current *IPGroupListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *ipGroupListResultPager) Err() error {
	return p.err
}

func (p *ipGroupListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.IPGroupListResult.NextLink == nil || len(*p.current.IPGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *ipGroupListResultPager) PageResponse() *IPGroupListResultResponse {
	return p.current
}

// InboundNatRuleListResultPager provides iteration over InboundNatRuleListResult pages.
type InboundNatRuleListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current InboundNatRuleListResultResponse.
	PageResponse() *InboundNatRuleListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type inboundNatRuleListResultCreateRequest func(context.Context) (*azcore.Request, error)

type inboundNatRuleListResultHandleError func(*azcore.Response) error

type inboundNatRuleListResultHandleResponse func(*azcore.Response) (*InboundNatRuleListResultResponse, error)

type inboundNatRuleListResultAdvancePage func(context.Context, *InboundNatRuleListResultResponse) (*azcore.Request, error)

type inboundNatRuleListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester inboundNatRuleListResultCreateRequest
	// callback for handling response errors
	errorer inboundNatRuleListResultHandleError
	// callback for handling the HTTP response
	responder inboundNatRuleListResultHandleResponse
	// callback for advancing to the next page
	advancer inboundNatRuleListResultAdvancePage
	// contains the current response
	current *InboundNatRuleListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *inboundNatRuleListResultPager) Err() error {
	return p.err
}

func (p *inboundNatRuleListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.InboundNatRuleListResult.NextLink == nil || len(*p.current.InboundNatRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *inboundNatRuleListResultPager) PageResponse() *InboundNatRuleListResultResponse {
	return p.current
}

// ListHubVirtualNetworkConnectionsResultPager provides iteration over ListHubVirtualNetworkConnectionsResult pages.
type ListHubVirtualNetworkConnectionsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListHubVirtualNetworkConnectionsResultResponse.
	PageResponse() *ListHubVirtualNetworkConnectionsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listHubVirtualNetworkConnectionsResultCreateRequest func(context.Context) (*azcore.Request, error)

type listHubVirtualNetworkConnectionsResultHandleError func(*azcore.Response) error

type listHubVirtualNetworkConnectionsResultHandleResponse func(*azcore.Response) (*ListHubVirtualNetworkConnectionsResultResponse, error)

type listHubVirtualNetworkConnectionsResultAdvancePage func(context.Context, *ListHubVirtualNetworkConnectionsResultResponse) (*azcore.Request, error)

type listHubVirtualNetworkConnectionsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester listHubVirtualNetworkConnectionsResultCreateRequest
	// callback for handling response errors
	errorer listHubVirtualNetworkConnectionsResultHandleError
	// callback for handling the HTTP response
	responder listHubVirtualNetworkConnectionsResultHandleResponse
	// callback for advancing to the next page
	advancer listHubVirtualNetworkConnectionsResultAdvancePage
	// contains the current response
	current *ListHubVirtualNetworkConnectionsResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *listHubVirtualNetworkConnectionsResultPager) Err() error {
	return p.err
}

func (p *listHubVirtualNetworkConnectionsResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ListHubVirtualNetworkConnectionsResult.NextLink == nil || len(*p.current.ListHubVirtualNetworkConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listHubVirtualNetworkConnectionsResultPager) PageResponse() *ListHubVirtualNetworkConnectionsResultResponse {
	return p.current
}

// ListP2SVpnGatewaysResultPager provides iteration over ListP2SVpnGatewaysResult pages.
type ListP2SVpnGatewaysResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListP2SVpnGatewaysResultResponse.
	PageResponse() *ListP2SVpnGatewaysResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listP2SVpnGatewaysResultCreateRequest func(context.Context) (*azcore.Request, error)

type listP2SVpnGatewaysResultHandleError func(*azcore.Response) error

type listP2SVpnGatewaysResultHandleResponse func(*azcore.Response) (*ListP2SVpnGatewaysResultResponse, error)

type listP2SVpnGatewaysResultAdvancePage func(context.Context, *ListP2SVpnGatewaysResultResponse) (*azcore.Request, error)

type listP2SVpnGatewaysResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester listP2SVpnGatewaysResultCreateRequest
	// callback for handling response errors
	errorer listP2SVpnGatewaysResultHandleError
	// callback for handling the HTTP response
	responder listP2SVpnGatewaysResultHandleResponse
	// callback for advancing to the next page
	advancer listP2SVpnGatewaysResultAdvancePage
	// contains the current response
	current *ListP2SVpnGatewaysResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *listP2SVpnGatewaysResultPager) Err() error {
	return p.err
}

func (p *listP2SVpnGatewaysResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ListP2SVpnGatewaysResult.NextLink == nil || len(*p.current.ListP2SVpnGatewaysResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listP2SVpnGatewaysResultPager) PageResponse() *ListP2SVpnGatewaysResultResponse {
	return p.current
}

// ListVirtualHubRouteTableV2SResultPager provides iteration over ListVirtualHubRouteTableV2SResult pages.
type ListVirtualHubRouteTableV2SResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVirtualHubRouteTableV2SResultResponse.
	PageResponse() *ListVirtualHubRouteTableV2SResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVirtualHubRouteTableV2SResultCreateRequest func(context.Context) (*azcore.Request, error)

type listVirtualHubRouteTableV2SResultHandleError func(*azcore.Response) error

type listVirtualHubRouteTableV2SResultHandleResponse func(*azcore.Response) (*ListVirtualHubRouteTableV2SResultResponse, error)

type listVirtualHubRouteTableV2SResultAdvancePage func(context.Context, *ListVirtualHubRouteTableV2SResultResponse) (*azcore.Request, error)

type listVirtualHubRouteTableV2SResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester listVirtualHubRouteTableV2SResultCreateRequest
	// callback for handling response errors
	errorer listVirtualHubRouteTableV2SResultHandleError
	// callback for handling the HTTP response
	responder listVirtualHubRouteTableV2SResultHandleResponse
	// callback for advancing to the next page
	advancer listVirtualHubRouteTableV2SResultAdvancePage
	// contains the current response
	current *ListVirtualHubRouteTableV2SResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *listVirtualHubRouteTableV2SResultPager) Err() error {
	return p.err
}

func (p *listVirtualHubRouteTableV2SResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ListVirtualHubRouteTableV2SResult.NextLink == nil || len(*p.current.ListVirtualHubRouteTableV2SResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVirtualHubRouteTableV2SResultPager) PageResponse() *ListVirtualHubRouteTableV2SResultResponse {
	return p.current
}

// ListVirtualHubsResultPager provides iteration over ListVirtualHubsResult pages.
type ListVirtualHubsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVirtualHubsResultResponse.
	PageResponse() *ListVirtualHubsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVirtualHubsResultCreateRequest func(context.Context) (*azcore.Request, error)

type listVirtualHubsResultHandleError func(*azcore.Response) error

type listVirtualHubsResultHandleResponse func(*azcore.Response) (*ListVirtualHubsResultResponse, error)

type listVirtualHubsResultAdvancePage func(context.Context, *ListVirtualHubsResultResponse) (*azcore.Request, error)

type listVirtualHubsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester listVirtualHubsResultCreateRequest
	// callback for handling response errors
	errorer listVirtualHubsResultHandleError
	// callback for handling the HTTP response
	responder listVirtualHubsResultHandleResponse
	// callback for advancing to the next page
	advancer listVirtualHubsResultAdvancePage
	// contains the current response
	current *ListVirtualHubsResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *listVirtualHubsResultPager) Err() error {
	return p.err
}

func (p *listVirtualHubsResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ListVirtualHubsResult.NextLink == nil || len(*p.current.ListVirtualHubsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVirtualHubsResultPager) PageResponse() *ListVirtualHubsResultResponse {
	return p.current
}

// ListVirtualWaNsResultPager provides iteration over ListVirtualWaNsResult pages.
type ListVirtualWaNsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVirtualWaNsResultResponse.
	PageResponse() *ListVirtualWaNsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVirtualWaNsResultCreateRequest func(context.Context) (*azcore.Request, error)

type listVirtualWaNsResultHandleError func(*azcore.Response) error

type listVirtualWaNsResultHandleResponse func(*azcore.Response) (*ListVirtualWaNsResultResponse, error)

type listVirtualWaNsResultAdvancePage func(context.Context, *ListVirtualWaNsResultResponse) (*azcore.Request, error)

type listVirtualWaNsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester listVirtualWaNsResultCreateRequest
	// callback for handling response errors
	errorer listVirtualWaNsResultHandleError
	// callback for handling the HTTP response
	responder listVirtualWaNsResultHandleResponse
	// callback for advancing to the next page
	advancer listVirtualWaNsResultAdvancePage
	// contains the current response
	current *ListVirtualWaNsResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *listVirtualWaNsResultPager) Err() error {
	return p.err
}

func (p *listVirtualWaNsResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ListVirtualWaNsResult.NextLink == nil || len(*p.current.ListVirtualWaNsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVirtualWaNsResultPager) PageResponse() *ListVirtualWaNsResultResponse {
	return p.current
}

// ListVpnConnectionsResultPager provides iteration over ListVpnConnectionsResult pages.
type ListVpnConnectionsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVpnConnectionsResultResponse.
	PageResponse() *ListVpnConnectionsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVpnConnectionsResultCreateRequest func(context.Context) (*azcore.Request, error)

type listVpnConnectionsResultHandleError func(*azcore.Response) error

type listVpnConnectionsResultHandleResponse func(*azcore.Response) (*ListVpnConnectionsResultResponse, error)

type listVpnConnectionsResultAdvancePage func(context.Context, *ListVpnConnectionsResultResponse) (*azcore.Request, error)

type listVpnConnectionsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester listVpnConnectionsResultCreateRequest
	// callback for handling response errors
	errorer listVpnConnectionsResultHandleError
	// callback for handling the HTTP response
	responder listVpnConnectionsResultHandleResponse
	// callback for advancing to the next page
	advancer listVpnConnectionsResultAdvancePage
	// contains the current response
	current *ListVpnConnectionsResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *listVpnConnectionsResultPager) Err() error {
	return p.err
}

func (p *listVpnConnectionsResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ListVpnConnectionsResult.NextLink == nil || len(*p.current.ListVpnConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVpnConnectionsResultPager) PageResponse() *ListVpnConnectionsResultResponse {
	return p.current
}

// ListVpnGatewaysResultPager provides iteration over ListVpnGatewaysResult pages.
type ListVpnGatewaysResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVpnGatewaysResultResponse.
	PageResponse() *ListVpnGatewaysResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVpnGatewaysResultCreateRequest func(context.Context) (*azcore.Request, error)

type listVpnGatewaysResultHandleError func(*azcore.Response) error

type listVpnGatewaysResultHandleResponse func(*azcore.Response) (*ListVpnGatewaysResultResponse, error)

type listVpnGatewaysResultAdvancePage func(context.Context, *ListVpnGatewaysResultResponse) (*azcore.Request, error)

type listVpnGatewaysResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester listVpnGatewaysResultCreateRequest
	// callback for handling response errors
	errorer listVpnGatewaysResultHandleError
	// callback for handling the HTTP response
	responder listVpnGatewaysResultHandleResponse
	// callback for advancing to the next page
	advancer listVpnGatewaysResultAdvancePage
	// contains the current response
	current *ListVpnGatewaysResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *listVpnGatewaysResultPager) Err() error {
	return p.err
}

func (p *listVpnGatewaysResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ListVpnGatewaysResult.NextLink == nil || len(*p.current.ListVpnGatewaysResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVpnGatewaysResultPager) PageResponse() *ListVpnGatewaysResultResponse {
	return p.current
}

// ListVpnServerConfigurationsResultPager provides iteration over ListVpnServerConfigurationsResult pages.
type ListVpnServerConfigurationsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVpnServerConfigurationsResultResponse.
	PageResponse() *ListVpnServerConfigurationsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVpnServerConfigurationsResultCreateRequest func(context.Context) (*azcore.Request, error)

type listVpnServerConfigurationsResultHandleError func(*azcore.Response) error

type listVpnServerConfigurationsResultHandleResponse func(*azcore.Response) (*ListVpnServerConfigurationsResultResponse, error)

type listVpnServerConfigurationsResultAdvancePage func(context.Context, *ListVpnServerConfigurationsResultResponse) (*azcore.Request, error)

type listVpnServerConfigurationsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester listVpnServerConfigurationsResultCreateRequest
	// callback for handling response errors
	errorer listVpnServerConfigurationsResultHandleError
	// callback for handling the HTTP response
	responder listVpnServerConfigurationsResultHandleResponse
	// callback for advancing to the next page
	advancer listVpnServerConfigurationsResultAdvancePage
	// contains the current response
	current *ListVpnServerConfigurationsResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *listVpnServerConfigurationsResultPager) Err() error {
	return p.err
}

func (p *listVpnServerConfigurationsResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ListVpnServerConfigurationsResult.NextLink == nil || len(*p.current.ListVpnServerConfigurationsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVpnServerConfigurationsResultPager) PageResponse() *ListVpnServerConfigurationsResultResponse {
	return p.current
}

// ListVpnSiteLinkConnectionsResultPager provides iteration over ListVpnSiteLinkConnectionsResult pages.
type ListVpnSiteLinkConnectionsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVpnSiteLinkConnectionsResultResponse.
	PageResponse() *ListVpnSiteLinkConnectionsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVpnSiteLinkConnectionsResultCreateRequest func(context.Context) (*azcore.Request, error)

type listVpnSiteLinkConnectionsResultHandleError func(*azcore.Response) error

type listVpnSiteLinkConnectionsResultHandleResponse func(*azcore.Response) (*ListVpnSiteLinkConnectionsResultResponse, error)

type listVpnSiteLinkConnectionsResultAdvancePage func(context.Context, *ListVpnSiteLinkConnectionsResultResponse) (*azcore.Request, error)

type listVpnSiteLinkConnectionsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester listVpnSiteLinkConnectionsResultCreateRequest
	// callback for handling response errors
	errorer listVpnSiteLinkConnectionsResultHandleError
	// callback for handling the HTTP response
	responder listVpnSiteLinkConnectionsResultHandleResponse
	// callback for advancing to the next page
	advancer listVpnSiteLinkConnectionsResultAdvancePage
	// contains the current response
	current *ListVpnSiteLinkConnectionsResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *listVpnSiteLinkConnectionsResultPager) Err() error {
	return p.err
}

func (p *listVpnSiteLinkConnectionsResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ListVpnSiteLinkConnectionsResult.NextLink == nil || len(*p.current.ListVpnSiteLinkConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVpnSiteLinkConnectionsResultPager) PageResponse() *ListVpnSiteLinkConnectionsResultResponse {
	return p.current
}

// ListVpnSiteLinksResultPager provides iteration over ListVpnSiteLinksResult pages.
type ListVpnSiteLinksResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVpnSiteLinksResultResponse.
	PageResponse() *ListVpnSiteLinksResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVpnSiteLinksResultCreateRequest func(context.Context) (*azcore.Request, error)

type listVpnSiteLinksResultHandleError func(*azcore.Response) error

type listVpnSiteLinksResultHandleResponse func(*azcore.Response) (*ListVpnSiteLinksResultResponse, error)

type listVpnSiteLinksResultAdvancePage func(context.Context, *ListVpnSiteLinksResultResponse) (*azcore.Request, error)

type listVpnSiteLinksResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester listVpnSiteLinksResultCreateRequest
	// callback for handling response errors
	errorer listVpnSiteLinksResultHandleError
	// callback for handling the HTTP response
	responder listVpnSiteLinksResultHandleResponse
	// callback for advancing to the next page
	advancer listVpnSiteLinksResultAdvancePage
	// contains the current response
	current *ListVpnSiteLinksResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *listVpnSiteLinksResultPager) Err() error {
	return p.err
}

func (p *listVpnSiteLinksResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ListVpnSiteLinksResult.NextLink == nil || len(*p.current.ListVpnSiteLinksResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVpnSiteLinksResultPager) PageResponse() *ListVpnSiteLinksResultResponse {
	return p.current
}

// ListVpnSitesResultPager provides iteration over ListVpnSitesResult pages.
type ListVpnSitesResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ListVpnSitesResultResponse.
	PageResponse() *ListVpnSitesResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type listVpnSitesResultCreateRequest func(context.Context) (*azcore.Request, error)

type listVpnSitesResultHandleError func(*azcore.Response) error

type listVpnSitesResultHandleResponse func(*azcore.Response) (*ListVpnSitesResultResponse, error)

type listVpnSitesResultAdvancePage func(context.Context, *ListVpnSitesResultResponse) (*azcore.Request, error)

type listVpnSitesResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester listVpnSitesResultCreateRequest
	// callback for handling response errors
	errorer listVpnSitesResultHandleError
	// callback for handling the HTTP response
	responder listVpnSitesResultHandleResponse
	// callback for advancing to the next page
	advancer listVpnSitesResultAdvancePage
	// contains the current response
	current *ListVpnSitesResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *listVpnSitesResultPager) Err() error {
	return p.err
}

func (p *listVpnSitesResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ListVpnSitesResult.NextLink == nil || len(*p.current.ListVpnSitesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *listVpnSitesResultPager) PageResponse() *ListVpnSitesResultResponse {
	return p.current
}

// LoadBalancerBackendAddressPoolListResultPager provides iteration over LoadBalancerBackendAddressPoolListResult pages.
type LoadBalancerBackendAddressPoolListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LoadBalancerBackendAddressPoolListResultResponse.
	PageResponse() *LoadBalancerBackendAddressPoolListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type loadBalancerBackendAddressPoolListResultCreateRequest func(context.Context) (*azcore.Request, error)

type loadBalancerBackendAddressPoolListResultHandleError func(*azcore.Response) error

type loadBalancerBackendAddressPoolListResultHandleResponse func(*azcore.Response) (*LoadBalancerBackendAddressPoolListResultResponse, error)

type loadBalancerBackendAddressPoolListResultAdvancePage func(context.Context, *LoadBalancerBackendAddressPoolListResultResponse) (*azcore.Request, error)

type loadBalancerBackendAddressPoolListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester loadBalancerBackendAddressPoolListResultCreateRequest
	// callback for handling response errors
	errorer loadBalancerBackendAddressPoolListResultHandleError
	// callback for handling the HTTP response
	responder loadBalancerBackendAddressPoolListResultHandleResponse
	// callback for advancing to the next page
	advancer loadBalancerBackendAddressPoolListResultAdvancePage
	// contains the current response
	current *LoadBalancerBackendAddressPoolListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *loadBalancerBackendAddressPoolListResultPager) Err() error {
	return p.err
}

func (p *loadBalancerBackendAddressPoolListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.LoadBalancerBackendAddressPoolListResult.NextLink == nil || len(*p.current.LoadBalancerBackendAddressPoolListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *loadBalancerBackendAddressPoolListResultPager) PageResponse() *LoadBalancerBackendAddressPoolListResultResponse {
	return p.current
}

// LoadBalancerFrontendIPConfigurationListResultPager provides iteration over LoadBalancerFrontendIPConfigurationListResult pages.
type LoadBalancerFrontendIPConfigurationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LoadBalancerFrontendIPConfigurationListResultResponse.
	PageResponse() *LoadBalancerFrontendIPConfigurationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type loadBalancerFrontendIPConfigurationListResultCreateRequest func(context.Context) (*azcore.Request, error)

type loadBalancerFrontendIPConfigurationListResultHandleError func(*azcore.Response) error

type loadBalancerFrontendIPConfigurationListResultHandleResponse func(*azcore.Response) (*LoadBalancerFrontendIPConfigurationListResultResponse, error)

type loadBalancerFrontendIPConfigurationListResultAdvancePage func(context.Context, *LoadBalancerFrontendIPConfigurationListResultResponse) (*azcore.Request, error)

type loadBalancerFrontendIPConfigurationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester loadBalancerFrontendIPConfigurationListResultCreateRequest
	// callback for handling response errors
	errorer loadBalancerFrontendIPConfigurationListResultHandleError
	// callback for handling the HTTP response
	responder loadBalancerFrontendIPConfigurationListResultHandleResponse
	// callback for advancing to the next page
	advancer loadBalancerFrontendIPConfigurationListResultAdvancePage
	// contains the current response
	current *LoadBalancerFrontendIPConfigurationListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *loadBalancerFrontendIPConfigurationListResultPager) Err() error {
	return p.err
}

func (p *loadBalancerFrontendIPConfigurationListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.LoadBalancerFrontendIPConfigurationListResult.NextLink == nil || len(*p.current.LoadBalancerFrontendIPConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *loadBalancerFrontendIPConfigurationListResultPager) PageResponse() *LoadBalancerFrontendIPConfigurationListResultResponse {
	return p.current
}

// LoadBalancerListResultPager provides iteration over LoadBalancerListResult pages.
type LoadBalancerListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LoadBalancerListResultResponse.
	PageResponse() *LoadBalancerListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type loadBalancerListResultCreateRequest func(context.Context) (*azcore.Request, error)

type loadBalancerListResultHandleError func(*azcore.Response) error

type loadBalancerListResultHandleResponse func(*azcore.Response) (*LoadBalancerListResultResponse, error)

type loadBalancerListResultAdvancePage func(context.Context, *LoadBalancerListResultResponse) (*azcore.Request, error)

type loadBalancerListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester loadBalancerListResultCreateRequest
	// callback for handling response errors
	errorer loadBalancerListResultHandleError
	// callback for handling the HTTP response
	responder loadBalancerListResultHandleResponse
	// callback for advancing to the next page
	advancer loadBalancerListResultAdvancePage
	// contains the current response
	current *LoadBalancerListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *loadBalancerListResultPager) Err() error {
	return p.err
}

func (p *loadBalancerListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.LoadBalancerListResult.NextLink == nil || len(*p.current.LoadBalancerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *loadBalancerListResultPager) PageResponse() *LoadBalancerListResultResponse {
	return p.current
}

// LoadBalancerLoadBalancingRuleListResultPager provides iteration over LoadBalancerLoadBalancingRuleListResult pages.
type LoadBalancerLoadBalancingRuleListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LoadBalancerLoadBalancingRuleListResultResponse.
	PageResponse() *LoadBalancerLoadBalancingRuleListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type loadBalancerLoadBalancingRuleListResultCreateRequest func(context.Context) (*azcore.Request, error)

type loadBalancerLoadBalancingRuleListResultHandleError func(*azcore.Response) error

type loadBalancerLoadBalancingRuleListResultHandleResponse func(*azcore.Response) (*LoadBalancerLoadBalancingRuleListResultResponse, error)

type loadBalancerLoadBalancingRuleListResultAdvancePage func(context.Context, *LoadBalancerLoadBalancingRuleListResultResponse) (*azcore.Request, error)

type loadBalancerLoadBalancingRuleListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester loadBalancerLoadBalancingRuleListResultCreateRequest
	// callback for handling response errors
	errorer loadBalancerLoadBalancingRuleListResultHandleError
	// callback for handling the HTTP response
	responder loadBalancerLoadBalancingRuleListResultHandleResponse
	// callback for advancing to the next page
	advancer loadBalancerLoadBalancingRuleListResultAdvancePage
	// contains the current response
	current *LoadBalancerLoadBalancingRuleListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *loadBalancerLoadBalancingRuleListResultPager) Err() error {
	return p.err
}

func (p *loadBalancerLoadBalancingRuleListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.LoadBalancerLoadBalancingRuleListResult.NextLink == nil || len(*p.current.LoadBalancerLoadBalancingRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *loadBalancerLoadBalancingRuleListResultPager) PageResponse() *LoadBalancerLoadBalancingRuleListResultResponse {
	return p.current
}

// LoadBalancerOutboundRuleListResultPager provides iteration over LoadBalancerOutboundRuleListResult pages.
type LoadBalancerOutboundRuleListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LoadBalancerOutboundRuleListResultResponse.
	PageResponse() *LoadBalancerOutboundRuleListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type loadBalancerOutboundRuleListResultCreateRequest func(context.Context) (*azcore.Request, error)

type loadBalancerOutboundRuleListResultHandleError func(*azcore.Response) error

type loadBalancerOutboundRuleListResultHandleResponse func(*azcore.Response) (*LoadBalancerOutboundRuleListResultResponse, error)

type loadBalancerOutboundRuleListResultAdvancePage func(context.Context, *LoadBalancerOutboundRuleListResultResponse) (*azcore.Request, error)

type loadBalancerOutboundRuleListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester loadBalancerOutboundRuleListResultCreateRequest
	// callback for handling response errors
	errorer loadBalancerOutboundRuleListResultHandleError
	// callback for handling the HTTP response
	responder loadBalancerOutboundRuleListResultHandleResponse
	// callback for advancing to the next page
	advancer loadBalancerOutboundRuleListResultAdvancePage
	// contains the current response
	current *LoadBalancerOutboundRuleListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *loadBalancerOutboundRuleListResultPager) Err() error {
	return p.err
}

func (p *loadBalancerOutboundRuleListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.LoadBalancerOutboundRuleListResult.NextLink == nil || len(*p.current.LoadBalancerOutboundRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *loadBalancerOutboundRuleListResultPager) PageResponse() *LoadBalancerOutboundRuleListResultResponse {
	return p.current
}

// LoadBalancerProbeListResultPager provides iteration over LoadBalancerProbeListResult pages.
type LoadBalancerProbeListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LoadBalancerProbeListResultResponse.
	PageResponse() *LoadBalancerProbeListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type loadBalancerProbeListResultCreateRequest func(context.Context) (*azcore.Request, error)

type loadBalancerProbeListResultHandleError func(*azcore.Response) error

type loadBalancerProbeListResultHandleResponse func(*azcore.Response) (*LoadBalancerProbeListResultResponse, error)

type loadBalancerProbeListResultAdvancePage func(context.Context, *LoadBalancerProbeListResultResponse) (*azcore.Request, error)

type loadBalancerProbeListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester loadBalancerProbeListResultCreateRequest
	// callback for handling response errors
	errorer loadBalancerProbeListResultHandleError
	// callback for handling the HTTP response
	responder loadBalancerProbeListResultHandleResponse
	// callback for advancing to the next page
	advancer loadBalancerProbeListResultAdvancePage
	// contains the current response
	current *LoadBalancerProbeListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *loadBalancerProbeListResultPager) Err() error {
	return p.err
}

func (p *loadBalancerProbeListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.LoadBalancerProbeListResult.NextLink == nil || len(*p.current.LoadBalancerProbeListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *loadBalancerProbeListResultPager) PageResponse() *LoadBalancerProbeListResultResponse {
	return p.current
}

// LocalNetworkGatewayListResultPager provides iteration over LocalNetworkGatewayListResult pages.
type LocalNetworkGatewayListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current LocalNetworkGatewayListResultResponse.
	PageResponse() *LocalNetworkGatewayListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type localNetworkGatewayListResultCreateRequest func(context.Context) (*azcore.Request, error)

type localNetworkGatewayListResultHandleError func(*azcore.Response) error

type localNetworkGatewayListResultHandleResponse func(*azcore.Response) (*LocalNetworkGatewayListResultResponse, error)

type localNetworkGatewayListResultAdvancePage func(context.Context, *LocalNetworkGatewayListResultResponse) (*azcore.Request, error)

type localNetworkGatewayListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester localNetworkGatewayListResultCreateRequest
	// callback for handling response errors
	errorer localNetworkGatewayListResultHandleError
	// callback for handling the HTTP response
	responder localNetworkGatewayListResultHandleResponse
	// callback for advancing to the next page
	advancer localNetworkGatewayListResultAdvancePage
	// contains the current response
	current *LocalNetworkGatewayListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *localNetworkGatewayListResultPager) Err() error {
	return p.err
}

func (p *localNetworkGatewayListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.LocalNetworkGatewayListResult.NextLink == nil || len(*p.current.LocalNetworkGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *localNetworkGatewayListResultPager) PageResponse() *LocalNetworkGatewayListResultResponse {
	return p.current
}

// NatGatewayListResultPager provides iteration over NatGatewayListResult pages.
type NatGatewayListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NatGatewayListResultResponse.
	PageResponse() *NatGatewayListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type natGatewayListResultCreateRequest func(context.Context) (*azcore.Request, error)

type natGatewayListResultHandleError func(*azcore.Response) error

type natGatewayListResultHandleResponse func(*azcore.Response) (*NatGatewayListResultResponse, error)

type natGatewayListResultAdvancePage func(context.Context, *NatGatewayListResultResponse) (*azcore.Request, error)

type natGatewayListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester natGatewayListResultCreateRequest
	// callback for handling response errors
	errorer natGatewayListResultHandleError
	// callback for handling the HTTP response
	responder natGatewayListResultHandleResponse
	// callback for advancing to the next page
	advancer natGatewayListResultAdvancePage
	// contains the current response
	current *NatGatewayListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *natGatewayListResultPager) Err() error {
	return p.err
}

func (p *natGatewayListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.NatGatewayListResult.NextLink == nil || len(*p.current.NatGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *natGatewayListResultPager) PageResponse() *NatGatewayListResultResponse {
	return p.current
}

// NetworkInterfaceIPConfigurationListResultPager provides iteration over NetworkInterfaceIPConfigurationListResult pages.
type NetworkInterfaceIPConfigurationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkInterfaceIPConfigurationListResultResponse.
	PageResponse() *NetworkInterfaceIPConfigurationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkInterfaceIPConfigurationListResultCreateRequest func(context.Context) (*azcore.Request, error)

type networkInterfaceIPConfigurationListResultHandleError func(*azcore.Response) error

type networkInterfaceIPConfigurationListResultHandleResponse func(*azcore.Response) (*NetworkInterfaceIPConfigurationListResultResponse, error)

type networkInterfaceIPConfigurationListResultAdvancePage func(context.Context, *NetworkInterfaceIPConfigurationListResultResponse) (*azcore.Request, error)

type networkInterfaceIPConfigurationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester networkInterfaceIPConfigurationListResultCreateRequest
	// callback for handling response errors
	errorer networkInterfaceIPConfigurationListResultHandleError
	// callback for handling the HTTP response
	responder networkInterfaceIPConfigurationListResultHandleResponse
	// callback for advancing to the next page
	advancer networkInterfaceIPConfigurationListResultAdvancePage
	// contains the current response
	current *NetworkInterfaceIPConfigurationListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *networkInterfaceIPConfigurationListResultPager) Err() error {
	return p.err
}

func (p *networkInterfaceIPConfigurationListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.NetworkInterfaceIPConfigurationListResult.NextLink == nil || len(*p.current.NetworkInterfaceIPConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkInterfaceIPConfigurationListResultPager) PageResponse() *NetworkInterfaceIPConfigurationListResultResponse {
	return p.current
}

// NetworkInterfaceListResultPager provides iteration over NetworkInterfaceListResult pages.
type NetworkInterfaceListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkInterfaceListResultResponse.
	PageResponse() *NetworkInterfaceListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkInterfaceListResultCreateRequest func(context.Context) (*azcore.Request, error)

type networkInterfaceListResultHandleError func(*azcore.Response) error

type networkInterfaceListResultHandleResponse func(*azcore.Response) (*NetworkInterfaceListResultResponse, error)

type networkInterfaceListResultAdvancePage func(context.Context, *NetworkInterfaceListResultResponse) (*azcore.Request, error)

type networkInterfaceListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester networkInterfaceListResultCreateRequest
	// callback for handling response errors
	errorer networkInterfaceListResultHandleError
	// callback for handling the HTTP response
	responder networkInterfaceListResultHandleResponse
	// callback for advancing to the next page
	advancer networkInterfaceListResultAdvancePage
	// contains the current response
	current *NetworkInterfaceListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *networkInterfaceListResultPager) Err() error {
	return p.err
}

func (p *networkInterfaceListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.NetworkInterfaceListResult.NextLink == nil || len(*p.current.NetworkInterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkInterfaceListResultPager) PageResponse() *NetworkInterfaceListResultResponse {
	return p.current
}

// NetworkInterfaceLoadBalancerListResultPager provides iteration over NetworkInterfaceLoadBalancerListResult pages.
type NetworkInterfaceLoadBalancerListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkInterfaceLoadBalancerListResultResponse.
	PageResponse() *NetworkInterfaceLoadBalancerListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkInterfaceLoadBalancerListResultCreateRequest func(context.Context) (*azcore.Request, error)

type networkInterfaceLoadBalancerListResultHandleError func(*azcore.Response) error

type networkInterfaceLoadBalancerListResultHandleResponse func(*azcore.Response) (*NetworkInterfaceLoadBalancerListResultResponse, error)

type networkInterfaceLoadBalancerListResultAdvancePage func(context.Context, *NetworkInterfaceLoadBalancerListResultResponse) (*azcore.Request, error)

type networkInterfaceLoadBalancerListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester networkInterfaceLoadBalancerListResultCreateRequest
	// callback for handling response errors
	errorer networkInterfaceLoadBalancerListResultHandleError
	// callback for handling the HTTP response
	responder networkInterfaceLoadBalancerListResultHandleResponse
	// callback for advancing to the next page
	advancer networkInterfaceLoadBalancerListResultAdvancePage
	// contains the current response
	current *NetworkInterfaceLoadBalancerListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *networkInterfaceLoadBalancerListResultPager) Err() error {
	return p.err
}

func (p *networkInterfaceLoadBalancerListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.NetworkInterfaceLoadBalancerListResult.NextLink == nil || len(*p.current.NetworkInterfaceLoadBalancerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkInterfaceLoadBalancerListResultPager) PageResponse() *NetworkInterfaceLoadBalancerListResultResponse {
	return p.current
}

// NetworkInterfaceTapConfigurationListResultPager provides iteration over NetworkInterfaceTapConfigurationListResult pages.
type NetworkInterfaceTapConfigurationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkInterfaceTapConfigurationListResultResponse.
	PageResponse() *NetworkInterfaceTapConfigurationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkInterfaceTapConfigurationListResultCreateRequest func(context.Context) (*azcore.Request, error)

type networkInterfaceTapConfigurationListResultHandleError func(*azcore.Response) error

type networkInterfaceTapConfigurationListResultHandleResponse func(*azcore.Response) (*NetworkInterfaceTapConfigurationListResultResponse, error)

type networkInterfaceTapConfigurationListResultAdvancePage func(context.Context, *NetworkInterfaceTapConfigurationListResultResponse) (*azcore.Request, error)

type networkInterfaceTapConfigurationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester networkInterfaceTapConfigurationListResultCreateRequest
	// callback for handling response errors
	errorer networkInterfaceTapConfigurationListResultHandleError
	// callback for handling the HTTP response
	responder networkInterfaceTapConfigurationListResultHandleResponse
	// callback for advancing to the next page
	advancer networkInterfaceTapConfigurationListResultAdvancePage
	// contains the current response
	current *NetworkInterfaceTapConfigurationListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *networkInterfaceTapConfigurationListResultPager) Err() error {
	return p.err
}

func (p *networkInterfaceTapConfigurationListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.NetworkInterfaceTapConfigurationListResult.NextLink == nil || len(*p.current.NetworkInterfaceTapConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkInterfaceTapConfigurationListResultPager) PageResponse() *NetworkInterfaceTapConfigurationListResultResponse {
	return p.current
}

// NetworkProfileListResultPager provides iteration over NetworkProfileListResult pages.
type NetworkProfileListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkProfileListResultResponse.
	PageResponse() *NetworkProfileListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkProfileListResultCreateRequest func(context.Context) (*azcore.Request, error)

type networkProfileListResultHandleError func(*azcore.Response) error

type networkProfileListResultHandleResponse func(*azcore.Response) (*NetworkProfileListResultResponse, error)

type networkProfileListResultAdvancePage func(context.Context, *NetworkProfileListResultResponse) (*azcore.Request, error)

type networkProfileListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester networkProfileListResultCreateRequest
	// callback for handling response errors
	errorer networkProfileListResultHandleError
	// callback for handling the HTTP response
	responder networkProfileListResultHandleResponse
	// callback for advancing to the next page
	advancer networkProfileListResultAdvancePage
	// contains the current response
	current *NetworkProfileListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *networkProfileListResultPager) Err() error {
	return p.err
}

func (p *networkProfileListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.NetworkProfileListResult.NextLink == nil || len(*p.current.NetworkProfileListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkProfileListResultPager) PageResponse() *NetworkProfileListResultResponse {
	return p.current
}

// NetworkSecurityGroupListResultPager provides iteration over NetworkSecurityGroupListResult pages.
type NetworkSecurityGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkSecurityGroupListResultResponse.
	PageResponse() *NetworkSecurityGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkSecurityGroupListResultCreateRequest func(context.Context) (*azcore.Request, error)

type networkSecurityGroupListResultHandleError func(*azcore.Response) error

type networkSecurityGroupListResultHandleResponse func(*azcore.Response) (*NetworkSecurityGroupListResultResponse, error)

type networkSecurityGroupListResultAdvancePage func(context.Context, *NetworkSecurityGroupListResultResponse) (*azcore.Request, error)

type networkSecurityGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester networkSecurityGroupListResultCreateRequest
	// callback for handling response errors
	errorer networkSecurityGroupListResultHandleError
	// callback for handling the HTTP response
	responder networkSecurityGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer networkSecurityGroupListResultAdvancePage
	// contains the current response
	current *NetworkSecurityGroupListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *networkSecurityGroupListResultPager) Err() error {
	return p.err
}

func (p *networkSecurityGroupListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.NetworkSecurityGroupListResult.NextLink == nil || len(*p.current.NetworkSecurityGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkSecurityGroupListResultPager) PageResponse() *NetworkSecurityGroupListResultResponse {
	return p.current
}

// NetworkVirtualApplianceListResultPager provides iteration over NetworkVirtualApplianceListResult pages.
type NetworkVirtualApplianceListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current NetworkVirtualApplianceListResultResponse.
	PageResponse() *NetworkVirtualApplianceListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type networkVirtualApplianceListResultCreateRequest func(context.Context) (*azcore.Request, error)

type networkVirtualApplianceListResultHandleError func(*azcore.Response) error

type networkVirtualApplianceListResultHandleResponse func(*azcore.Response) (*NetworkVirtualApplianceListResultResponse, error)

type networkVirtualApplianceListResultAdvancePage func(context.Context, *NetworkVirtualApplianceListResultResponse) (*azcore.Request, error)

type networkVirtualApplianceListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester networkVirtualApplianceListResultCreateRequest
	// callback for handling response errors
	errorer networkVirtualApplianceListResultHandleError
	// callback for handling the HTTP response
	responder networkVirtualApplianceListResultHandleResponse
	// callback for advancing to the next page
	advancer networkVirtualApplianceListResultAdvancePage
	// contains the current response
	current *NetworkVirtualApplianceListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *networkVirtualApplianceListResultPager) Err() error {
	return p.err
}

func (p *networkVirtualApplianceListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.NetworkVirtualApplianceListResult.NextLink == nil || len(*p.current.NetworkVirtualApplianceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *networkVirtualApplianceListResultPager) PageResponse() *NetworkVirtualApplianceListResultResponse {
	return p.current
}

// OperationListResultPager provides iteration over OperationListResult pages.
type OperationListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current OperationListResultResponse.
	PageResponse() *OperationListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type operationListResultCreateRequest func(context.Context) (*azcore.Request, error)

type operationListResultHandleError func(*azcore.Response) error

type operationListResultHandleResponse func(*azcore.Response) (*OperationListResultResponse, error)

type operationListResultAdvancePage func(context.Context, *OperationListResultResponse) (*azcore.Request, error)

type operationListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester operationListResultCreateRequest
	// callback for handling response errors
	errorer operationListResultHandleError
	// callback for handling the HTTP response
	responder operationListResultHandleResponse
	// callback for advancing to the next page
	advancer operationListResultAdvancePage
	// contains the current response
	current *OperationListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *operationListResultPager) Err() error {
	return p.err
}

func (p *operationListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *operationListResultPager) PageResponse() *OperationListResultResponse {
	return p.current
}

// PeerExpressRouteCircuitConnectionListResultPager provides iteration over PeerExpressRouteCircuitConnectionListResult pages.
type PeerExpressRouteCircuitConnectionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PeerExpressRouteCircuitConnectionListResultResponse.
	PageResponse() *PeerExpressRouteCircuitConnectionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type peerExpressRouteCircuitConnectionListResultCreateRequest func(context.Context) (*azcore.Request, error)

type peerExpressRouteCircuitConnectionListResultHandleError func(*azcore.Response) error

type peerExpressRouteCircuitConnectionListResultHandleResponse func(*azcore.Response) (*PeerExpressRouteCircuitConnectionListResultResponse, error)

type peerExpressRouteCircuitConnectionListResultAdvancePage func(context.Context, *PeerExpressRouteCircuitConnectionListResultResponse) (*azcore.Request, error)

type peerExpressRouteCircuitConnectionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester peerExpressRouteCircuitConnectionListResultCreateRequest
	// callback for handling response errors
	errorer peerExpressRouteCircuitConnectionListResultHandleError
	// callback for handling the HTTP response
	responder peerExpressRouteCircuitConnectionListResultHandleResponse
	// callback for advancing to the next page
	advancer peerExpressRouteCircuitConnectionListResultAdvancePage
	// contains the current response
	current *PeerExpressRouteCircuitConnectionListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *peerExpressRouteCircuitConnectionListResultPager) Err() error {
	return p.err
}

func (p *peerExpressRouteCircuitConnectionListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.PeerExpressRouteCircuitConnectionListResult.NextLink == nil || len(*p.current.PeerExpressRouteCircuitConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *peerExpressRouteCircuitConnectionListResultPager) PageResponse() *PeerExpressRouteCircuitConnectionListResultResponse {
	return p.current
}

// PrivateDNSZoneGroupListResultPager provides iteration over PrivateDNSZoneGroupListResult pages.
type PrivateDNSZoneGroupListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PrivateDNSZoneGroupListResultResponse.
	PageResponse() *PrivateDNSZoneGroupListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type privateDnsZoneGroupListResultCreateRequest func(context.Context) (*azcore.Request, error)

type privateDnsZoneGroupListResultHandleError func(*azcore.Response) error

type privateDnsZoneGroupListResultHandleResponse func(*azcore.Response) (*PrivateDNSZoneGroupListResultResponse, error)

type privateDnsZoneGroupListResultAdvancePage func(context.Context, *PrivateDNSZoneGroupListResultResponse) (*azcore.Request, error)

type privateDnsZoneGroupListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester privateDnsZoneGroupListResultCreateRequest
	// callback for handling response errors
	errorer privateDnsZoneGroupListResultHandleError
	// callback for handling the HTTP response
	responder privateDnsZoneGroupListResultHandleResponse
	// callback for advancing to the next page
	advancer privateDnsZoneGroupListResultAdvancePage
	// contains the current response
	current *PrivateDNSZoneGroupListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *privateDnsZoneGroupListResultPager) Err() error {
	return p.err
}

func (p *privateDnsZoneGroupListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.PrivateDNSZoneGroupListResult.NextLink == nil || len(*p.current.PrivateDNSZoneGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *privateDnsZoneGroupListResultPager) PageResponse() *PrivateDNSZoneGroupListResultResponse {
	return p.current
}

// PrivateEndpointConnectionListResultPager provides iteration over PrivateEndpointConnectionListResult pages.
type PrivateEndpointConnectionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PrivateEndpointConnectionListResultResponse.
	PageResponse() *PrivateEndpointConnectionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type privateEndpointConnectionListResultCreateRequest func(context.Context) (*azcore.Request, error)

type privateEndpointConnectionListResultHandleError func(*azcore.Response) error

type privateEndpointConnectionListResultHandleResponse func(*azcore.Response) (*PrivateEndpointConnectionListResultResponse, error)

type privateEndpointConnectionListResultAdvancePage func(context.Context, *PrivateEndpointConnectionListResultResponse) (*azcore.Request, error)

type privateEndpointConnectionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester privateEndpointConnectionListResultCreateRequest
	// callback for handling response errors
	errorer privateEndpointConnectionListResultHandleError
	// callback for handling the HTTP response
	responder privateEndpointConnectionListResultHandleResponse
	// callback for advancing to the next page
	advancer privateEndpointConnectionListResultAdvancePage
	// contains the current response
	current *PrivateEndpointConnectionListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *privateEndpointConnectionListResultPager) Err() error {
	return p.err
}

func (p *privateEndpointConnectionListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.PrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.PrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *privateEndpointConnectionListResultPager) PageResponse() *PrivateEndpointConnectionListResultResponse {
	return p.current
}

// PrivateEndpointListResultPager provides iteration over PrivateEndpointListResult pages.
type PrivateEndpointListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PrivateEndpointListResultResponse.
	PageResponse() *PrivateEndpointListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type privateEndpointListResultCreateRequest func(context.Context) (*azcore.Request, error)

type privateEndpointListResultHandleError func(*azcore.Response) error

type privateEndpointListResultHandleResponse func(*azcore.Response) (*PrivateEndpointListResultResponse, error)

type privateEndpointListResultAdvancePage func(context.Context, *PrivateEndpointListResultResponse) (*azcore.Request, error)

type privateEndpointListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester privateEndpointListResultCreateRequest
	// callback for handling response errors
	errorer privateEndpointListResultHandleError
	// callback for handling the HTTP response
	responder privateEndpointListResultHandleResponse
	// callback for advancing to the next page
	advancer privateEndpointListResultAdvancePage
	// contains the current response
	current *PrivateEndpointListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *privateEndpointListResultPager) Err() error {
	return p.err
}

func (p *privateEndpointListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.PrivateEndpointListResult.NextLink == nil || len(*p.current.PrivateEndpointListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *privateEndpointListResultPager) PageResponse() *PrivateEndpointListResultResponse {
	return p.current
}

// PrivateLinkServiceListResultPager provides iteration over PrivateLinkServiceListResult pages.
type PrivateLinkServiceListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PrivateLinkServiceListResultResponse.
	PageResponse() *PrivateLinkServiceListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type privateLinkServiceListResultCreateRequest func(context.Context) (*azcore.Request, error)

type privateLinkServiceListResultHandleError func(*azcore.Response) error

type privateLinkServiceListResultHandleResponse func(*azcore.Response) (*PrivateLinkServiceListResultResponse, error)

type privateLinkServiceListResultAdvancePage func(context.Context, *PrivateLinkServiceListResultResponse) (*azcore.Request, error)

type privateLinkServiceListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester privateLinkServiceListResultCreateRequest
	// callback for handling response errors
	errorer privateLinkServiceListResultHandleError
	// callback for handling the HTTP response
	responder privateLinkServiceListResultHandleResponse
	// callback for advancing to the next page
	advancer privateLinkServiceListResultAdvancePage
	// contains the current response
	current *PrivateLinkServiceListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *privateLinkServiceListResultPager) Err() error {
	return p.err
}

func (p *privateLinkServiceListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.PrivateLinkServiceListResult.NextLink == nil || len(*p.current.PrivateLinkServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *privateLinkServiceListResultPager) PageResponse() *PrivateLinkServiceListResultResponse {
	return p.current
}

// PublicIPAddressListResultPager provides iteration over PublicIPAddressListResult pages.
type PublicIPAddressListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PublicIPAddressListResultResponse.
	PageResponse() *PublicIPAddressListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type publicIPAddressListResultCreateRequest func(context.Context) (*azcore.Request, error)

type publicIPAddressListResultHandleError func(*azcore.Response) error

type publicIPAddressListResultHandleResponse func(*azcore.Response) (*PublicIPAddressListResultResponse, error)

type publicIPAddressListResultAdvancePage func(context.Context, *PublicIPAddressListResultResponse) (*azcore.Request, error)

type publicIPAddressListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester publicIPAddressListResultCreateRequest
	// callback for handling response errors
	errorer publicIPAddressListResultHandleError
	// callback for handling the HTTP response
	responder publicIPAddressListResultHandleResponse
	// callback for advancing to the next page
	advancer publicIPAddressListResultAdvancePage
	// contains the current response
	current *PublicIPAddressListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *publicIPAddressListResultPager) Err() error {
	return p.err
}

func (p *publicIPAddressListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *publicIPAddressListResultPager) PageResponse() *PublicIPAddressListResultResponse {
	return p.current
}

// PublicIPPrefixListResultPager provides iteration over PublicIPPrefixListResult pages.
type PublicIPPrefixListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current PublicIPPrefixListResultResponse.
	PageResponse() *PublicIPPrefixListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type publicIPPrefixListResultCreateRequest func(context.Context) (*azcore.Request, error)

type publicIPPrefixListResultHandleError func(*azcore.Response) error

type publicIPPrefixListResultHandleResponse func(*azcore.Response) (*PublicIPPrefixListResultResponse, error)

type publicIPPrefixListResultAdvancePage func(context.Context, *PublicIPPrefixListResultResponse) (*azcore.Request, error)

type publicIPPrefixListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester publicIPPrefixListResultCreateRequest
	// callback for handling response errors
	errorer publicIPPrefixListResultHandleError
	// callback for handling the HTTP response
	responder publicIPPrefixListResultHandleResponse
	// callback for advancing to the next page
	advancer publicIPPrefixListResultAdvancePage
	// contains the current response
	current *PublicIPPrefixListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *publicIPPrefixListResultPager) Err() error {
	return p.err
}

func (p *publicIPPrefixListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.PublicIPPrefixListResult.NextLink == nil || len(*p.current.PublicIPPrefixListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *publicIPPrefixListResultPager) PageResponse() *PublicIPPrefixListResultResponse {
	return p.current
}

// RouteFilterListResultPager provides iteration over RouteFilterListResult pages.
type RouteFilterListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current RouteFilterListResultResponse.
	PageResponse() *RouteFilterListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type routeFilterListResultCreateRequest func(context.Context) (*azcore.Request, error)

type routeFilterListResultHandleError func(*azcore.Response) error

type routeFilterListResultHandleResponse func(*azcore.Response) (*RouteFilterListResultResponse, error)

type routeFilterListResultAdvancePage func(context.Context, *RouteFilterListResultResponse) (*azcore.Request, error)

type routeFilterListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester routeFilterListResultCreateRequest
	// callback for handling response errors
	errorer routeFilterListResultHandleError
	// callback for handling the HTTP response
	responder routeFilterListResultHandleResponse
	// callback for advancing to the next page
	advancer routeFilterListResultAdvancePage
	// contains the current response
	current *RouteFilterListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *routeFilterListResultPager) Err() error {
	return p.err
}

func (p *routeFilterListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.RouteFilterListResult.NextLink == nil || len(*p.current.RouteFilterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *routeFilterListResultPager) PageResponse() *RouteFilterListResultResponse {
	return p.current
}

// RouteFilterRuleListResultPager provides iteration over RouteFilterRuleListResult pages.
type RouteFilterRuleListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current RouteFilterRuleListResultResponse.
	PageResponse() *RouteFilterRuleListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type routeFilterRuleListResultCreateRequest func(context.Context) (*azcore.Request, error)

type routeFilterRuleListResultHandleError func(*azcore.Response) error

type routeFilterRuleListResultHandleResponse func(*azcore.Response) (*RouteFilterRuleListResultResponse, error)

type routeFilterRuleListResultAdvancePage func(context.Context, *RouteFilterRuleListResultResponse) (*azcore.Request, error)

type routeFilterRuleListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester routeFilterRuleListResultCreateRequest
	// callback for handling response errors
	errorer routeFilterRuleListResultHandleError
	// callback for handling the HTTP response
	responder routeFilterRuleListResultHandleResponse
	// callback for advancing to the next page
	advancer routeFilterRuleListResultAdvancePage
	// contains the current response
	current *RouteFilterRuleListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *routeFilterRuleListResultPager) Err() error {
	return p.err
}

func (p *routeFilterRuleListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.RouteFilterRuleListResult.NextLink == nil || len(*p.current.RouteFilterRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *routeFilterRuleListResultPager) PageResponse() *RouteFilterRuleListResultResponse {
	return p.current
}

// RouteListResultPager provides iteration over RouteListResult pages.
type RouteListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current RouteListResultResponse.
	PageResponse() *RouteListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type routeListResultCreateRequest func(context.Context) (*azcore.Request, error)

type routeListResultHandleError func(*azcore.Response) error

type routeListResultHandleResponse func(*azcore.Response) (*RouteListResultResponse, error)

type routeListResultAdvancePage func(context.Context, *RouteListResultResponse) (*azcore.Request, error)

type routeListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester routeListResultCreateRequest
	// callback for handling response errors
	errorer routeListResultHandleError
	// callback for handling the HTTP response
	responder routeListResultHandleResponse
	// callback for advancing to the next page
	advancer routeListResultAdvancePage
	// contains the current response
	current *RouteListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *routeListResultPager) Err() error {
	return p.err
}

func (p *routeListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.RouteListResult.NextLink == nil || len(*p.current.RouteListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *routeListResultPager) PageResponse() *RouteListResultResponse {
	return p.current
}

// RouteTableListResultPager provides iteration over RouteTableListResult pages.
type RouteTableListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current RouteTableListResultResponse.
	PageResponse() *RouteTableListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type routeTableListResultCreateRequest func(context.Context) (*azcore.Request, error)

type routeTableListResultHandleError func(*azcore.Response) error

type routeTableListResultHandleResponse func(*azcore.Response) (*RouteTableListResultResponse, error)

type routeTableListResultAdvancePage func(context.Context, *RouteTableListResultResponse) (*azcore.Request, error)

type routeTableListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester routeTableListResultCreateRequest
	// callback for handling response errors
	errorer routeTableListResultHandleError
	// callback for handling the HTTP response
	responder routeTableListResultHandleResponse
	// callback for advancing to the next page
	advancer routeTableListResultAdvancePage
	// contains the current response
	current *RouteTableListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *routeTableListResultPager) Err() error {
	return p.err
}

func (p *routeTableListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.RouteTableListResult.NextLink == nil || len(*p.current.RouteTableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *routeTableListResultPager) PageResponse() *RouteTableListResultResponse {
	return p.current
}

// SecurityPartnerProviderListResultPager provides iteration over SecurityPartnerProviderListResult pages.
type SecurityPartnerProviderListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current SecurityPartnerProviderListResultResponse.
	PageResponse() *SecurityPartnerProviderListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type securityPartnerProviderListResultCreateRequest func(context.Context) (*azcore.Request, error)

type securityPartnerProviderListResultHandleError func(*azcore.Response) error

type securityPartnerProviderListResultHandleResponse func(*azcore.Response) (*SecurityPartnerProviderListResultResponse, error)

type securityPartnerProviderListResultAdvancePage func(context.Context, *SecurityPartnerProviderListResultResponse) (*azcore.Request, error)

type securityPartnerProviderListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester securityPartnerProviderListResultCreateRequest
	// callback for handling response errors
	errorer securityPartnerProviderListResultHandleError
	// callback for handling the HTTP response
	responder securityPartnerProviderListResultHandleResponse
	// callback for advancing to the next page
	advancer securityPartnerProviderListResultAdvancePage
	// contains the current response
	current *SecurityPartnerProviderListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *securityPartnerProviderListResultPager) Err() error {
	return p.err
}

func (p *securityPartnerProviderListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.SecurityPartnerProviderListResult.NextLink == nil || len(*p.current.SecurityPartnerProviderListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *securityPartnerProviderListResultPager) PageResponse() *SecurityPartnerProviderListResultResponse {
	return p.current
}

// SecurityRuleListResultPager provides iteration over SecurityRuleListResult pages.
type SecurityRuleListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current SecurityRuleListResultResponse.
	PageResponse() *SecurityRuleListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type securityRuleListResultCreateRequest func(context.Context) (*azcore.Request, error)

type securityRuleListResultHandleError func(*azcore.Response) error

type securityRuleListResultHandleResponse func(*azcore.Response) (*SecurityRuleListResultResponse, error)

type securityRuleListResultAdvancePage func(context.Context, *SecurityRuleListResultResponse) (*azcore.Request, error)

type securityRuleListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester securityRuleListResultCreateRequest
	// callback for handling response errors
	errorer securityRuleListResultHandleError
	// callback for handling the HTTP response
	responder securityRuleListResultHandleResponse
	// callback for advancing to the next page
	advancer securityRuleListResultAdvancePage
	// contains the current response
	current *SecurityRuleListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *securityRuleListResultPager) Err() error {
	return p.err
}

func (p *securityRuleListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.SecurityRuleListResult.NextLink == nil || len(*p.current.SecurityRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *securityRuleListResultPager) PageResponse() *SecurityRuleListResultResponse {
	return p.current
}

// ServiceEndpointPolicyDefinitionListResultPager provides iteration over ServiceEndpointPolicyDefinitionListResult pages.
type ServiceEndpointPolicyDefinitionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ServiceEndpointPolicyDefinitionListResultResponse.
	PageResponse() *ServiceEndpointPolicyDefinitionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type serviceEndpointPolicyDefinitionListResultCreateRequest func(context.Context) (*azcore.Request, error)

type serviceEndpointPolicyDefinitionListResultHandleError func(*azcore.Response) error

type serviceEndpointPolicyDefinitionListResultHandleResponse func(*azcore.Response) (*ServiceEndpointPolicyDefinitionListResultResponse, error)

type serviceEndpointPolicyDefinitionListResultAdvancePage func(context.Context, *ServiceEndpointPolicyDefinitionListResultResponse) (*azcore.Request, error)

type serviceEndpointPolicyDefinitionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester serviceEndpointPolicyDefinitionListResultCreateRequest
	// callback for handling response errors
	errorer serviceEndpointPolicyDefinitionListResultHandleError
	// callback for handling the HTTP response
	responder serviceEndpointPolicyDefinitionListResultHandleResponse
	// callback for advancing to the next page
	advancer serviceEndpointPolicyDefinitionListResultAdvancePage
	// contains the current response
	current *ServiceEndpointPolicyDefinitionListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *serviceEndpointPolicyDefinitionListResultPager) Err() error {
	return p.err
}

func (p *serviceEndpointPolicyDefinitionListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ServiceEndpointPolicyDefinitionListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *serviceEndpointPolicyDefinitionListResultPager) PageResponse() *ServiceEndpointPolicyDefinitionListResultResponse {
	return p.current
}

// ServiceEndpointPolicyListResultPager provides iteration over ServiceEndpointPolicyListResult pages.
type ServiceEndpointPolicyListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current ServiceEndpointPolicyListResultResponse.
	PageResponse() *ServiceEndpointPolicyListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type serviceEndpointPolicyListResultCreateRequest func(context.Context) (*azcore.Request, error)

type serviceEndpointPolicyListResultHandleError func(*azcore.Response) error

type serviceEndpointPolicyListResultHandleResponse func(*azcore.Response) (*ServiceEndpointPolicyListResultResponse, error)

type serviceEndpointPolicyListResultAdvancePage func(context.Context, *ServiceEndpointPolicyListResultResponse) (*azcore.Request, error)

type serviceEndpointPolicyListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester serviceEndpointPolicyListResultCreateRequest
	// callback for handling response errors
	errorer serviceEndpointPolicyListResultHandleError
	// callback for handling the HTTP response
	responder serviceEndpointPolicyListResultHandleResponse
	// callback for advancing to the next page
	advancer serviceEndpointPolicyListResultAdvancePage
	// contains the current response
	current *ServiceEndpointPolicyListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *serviceEndpointPolicyListResultPager) Err() error {
	return p.err
}

func (p *serviceEndpointPolicyListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.ServiceEndpointPolicyListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *serviceEndpointPolicyListResultPager) PageResponse() *ServiceEndpointPolicyListResultResponse {
	return p.current
}

// SubnetListResultPager provides iteration over SubnetListResult pages.
type SubnetListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current SubnetListResultResponse.
	PageResponse() *SubnetListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type subnetListResultCreateRequest func(context.Context) (*azcore.Request, error)

type subnetListResultHandleError func(*azcore.Response) error

type subnetListResultHandleResponse func(*azcore.Response) (*SubnetListResultResponse, error)

type subnetListResultAdvancePage func(context.Context, *SubnetListResultResponse) (*azcore.Request, error)

type subnetListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester subnetListResultCreateRequest
	// callback for handling response errors
	errorer subnetListResultHandleError
	// callback for handling the HTTP response
	responder subnetListResultHandleResponse
	// callback for advancing to the next page
	advancer subnetListResultAdvancePage
	// contains the current response
	current *SubnetListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *subnetListResultPager) Err() error {
	return p.err
}

func (p *subnetListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.SubnetListResult.NextLink == nil || len(*p.current.SubnetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *subnetListResultPager) PageResponse() *SubnetListResultResponse {
	return p.current
}

// UsagesListResultPager provides iteration over UsagesListResult pages.
type UsagesListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current UsagesListResultResponse.
	PageResponse() *UsagesListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type usagesListResultCreateRequest func(context.Context) (*azcore.Request, error)

type usagesListResultHandleError func(*azcore.Response) error

type usagesListResultHandleResponse func(*azcore.Response) (*UsagesListResultResponse, error)

type usagesListResultAdvancePage func(context.Context, *UsagesListResultResponse) (*azcore.Request, error)

type usagesListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester usagesListResultCreateRequest
	// callback for handling response errors
	errorer usagesListResultHandleError
	// callback for handling the HTTP response
	responder usagesListResultHandleResponse
	// callback for advancing to the next page
	advancer usagesListResultAdvancePage
	// contains the current response
	current *UsagesListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *usagesListResultPager) Err() error {
	return p.err
}

func (p *usagesListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *usagesListResultPager) PageResponse() *UsagesListResultResponse {
	return p.current
}

// VirtualNetworkGatewayConnectionListResultPager provides iteration over VirtualNetworkGatewayConnectionListResult pages.
type VirtualNetworkGatewayConnectionListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkGatewayConnectionListResultResponse.
	PageResponse() *VirtualNetworkGatewayConnectionListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkGatewayConnectionListResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualNetworkGatewayConnectionListResultHandleError func(*azcore.Response) error

type virtualNetworkGatewayConnectionListResultHandleResponse func(*azcore.Response) (*VirtualNetworkGatewayConnectionListResultResponse, error)

type virtualNetworkGatewayConnectionListResultAdvancePage func(context.Context, *VirtualNetworkGatewayConnectionListResultResponse) (*azcore.Request, error)

type virtualNetworkGatewayConnectionListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualNetworkGatewayConnectionListResultCreateRequest
	// callback for handling response errors
	errorer virtualNetworkGatewayConnectionListResultHandleError
	// callback for handling the HTTP response
	responder virtualNetworkGatewayConnectionListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkGatewayConnectionListResultAdvancePage
	// contains the current response
	current *VirtualNetworkGatewayConnectionListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualNetworkGatewayConnectionListResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkGatewayConnectionListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualNetworkGatewayConnectionListResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkGatewayConnectionListResultPager) PageResponse() *VirtualNetworkGatewayConnectionListResultResponse {
	return p.current
}

// VirtualNetworkGatewayListConnectionsResultPager provides iteration over VirtualNetworkGatewayListConnectionsResult pages.
type VirtualNetworkGatewayListConnectionsResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkGatewayListConnectionsResultResponse.
	PageResponse() *VirtualNetworkGatewayListConnectionsResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkGatewayListConnectionsResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualNetworkGatewayListConnectionsResultHandleError func(*azcore.Response) error

type virtualNetworkGatewayListConnectionsResultHandleResponse func(*azcore.Response) (*VirtualNetworkGatewayListConnectionsResultResponse, error)

type virtualNetworkGatewayListConnectionsResultAdvancePage func(context.Context, *VirtualNetworkGatewayListConnectionsResultResponse) (*azcore.Request, error)

type virtualNetworkGatewayListConnectionsResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualNetworkGatewayListConnectionsResultCreateRequest
	// callback for handling response errors
	errorer virtualNetworkGatewayListConnectionsResultHandleError
	// callback for handling the HTTP response
	responder virtualNetworkGatewayListConnectionsResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkGatewayListConnectionsResultAdvancePage
	// contains the current response
	current *VirtualNetworkGatewayListConnectionsResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualNetworkGatewayListConnectionsResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkGatewayListConnectionsResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualNetworkGatewayListConnectionsResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayListConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkGatewayListConnectionsResultPager) PageResponse() *VirtualNetworkGatewayListConnectionsResultResponse {
	return p.current
}

// VirtualNetworkGatewayListResultPager provides iteration over VirtualNetworkGatewayListResult pages.
type VirtualNetworkGatewayListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkGatewayListResultResponse.
	PageResponse() *VirtualNetworkGatewayListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkGatewayListResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualNetworkGatewayListResultHandleError func(*azcore.Response) error

type virtualNetworkGatewayListResultHandleResponse func(*azcore.Response) (*VirtualNetworkGatewayListResultResponse, error)

type virtualNetworkGatewayListResultAdvancePage func(context.Context, *VirtualNetworkGatewayListResultResponse) (*azcore.Request, error)

type virtualNetworkGatewayListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualNetworkGatewayListResultCreateRequest
	// callback for handling response errors
	errorer virtualNetworkGatewayListResultHandleError
	// callback for handling the HTTP response
	responder virtualNetworkGatewayListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkGatewayListResultAdvancePage
	// contains the current response
	current *VirtualNetworkGatewayListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualNetworkGatewayListResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkGatewayListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualNetworkGatewayListResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkGatewayListResultPager) PageResponse() *VirtualNetworkGatewayListResultResponse {
	return p.current
}

// VirtualNetworkListResultPager provides iteration over VirtualNetworkListResult pages.
type VirtualNetworkListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkListResultResponse.
	PageResponse() *VirtualNetworkListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkListResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualNetworkListResultHandleError func(*azcore.Response) error

type virtualNetworkListResultHandleResponse func(*azcore.Response) (*VirtualNetworkListResultResponse, error)

type virtualNetworkListResultAdvancePage func(context.Context, *VirtualNetworkListResultResponse) (*azcore.Request, error)

type virtualNetworkListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualNetworkListResultCreateRequest
	// callback for handling response errors
	errorer virtualNetworkListResultHandleError
	// callback for handling the HTTP response
	responder virtualNetworkListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkListResultAdvancePage
	// contains the current response
	current *VirtualNetworkListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualNetworkListResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualNetworkListResult.NextLink == nil || len(*p.current.VirtualNetworkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkListResultPager) PageResponse() *VirtualNetworkListResultResponse {
	return p.current
}

// VirtualNetworkListUsageResultPager provides iteration over VirtualNetworkListUsageResult pages.
type VirtualNetworkListUsageResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkListUsageResultResponse.
	PageResponse() *VirtualNetworkListUsageResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkListUsageResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualNetworkListUsageResultHandleError func(*azcore.Response) error

type virtualNetworkListUsageResultHandleResponse func(*azcore.Response) (*VirtualNetworkListUsageResultResponse, error)

type virtualNetworkListUsageResultAdvancePage func(context.Context, *VirtualNetworkListUsageResultResponse) (*azcore.Request, error)

type virtualNetworkListUsageResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualNetworkListUsageResultCreateRequest
	// callback for handling response errors
	errorer virtualNetworkListUsageResultHandleError
	// callback for handling the HTTP response
	responder virtualNetworkListUsageResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkListUsageResultAdvancePage
	// contains the current response
	current *VirtualNetworkListUsageResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualNetworkListUsageResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkListUsageResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualNetworkListUsageResult.NextLink == nil || len(*p.current.VirtualNetworkListUsageResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkListUsageResultPager) PageResponse() *VirtualNetworkListUsageResultResponse {
	return p.current
}

// VirtualNetworkPeeringListResultPager provides iteration over VirtualNetworkPeeringListResult pages.
type VirtualNetworkPeeringListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkPeeringListResultResponse.
	PageResponse() *VirtualNetworkPeeringListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkPeeringListResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualNetworkPeeringListResultHandleError func(*azcore.Response) error

type virtualNetworkPeeringListResultHandleResponse func(*azcore.Response) (*VirtualNetworkPeeringListResultResponse, error)

type virtualNetworkPeeringListResultAdvancePage func(context.Context, *VirtualNetworkPeeringListResultResponse) (*azcore.Request, error)

type virtualNetworkPeeringListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualNetworkPeeringListResultCreateRequest
	// callback for handling response errors
	errorer virtualNetworkPeeringListResultHandleError
	// callback for handling the HTTP response
	responder virtualNetworkPeeringListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkPeeringListResultAdvancePage
	// contains the current response
	current *VirtualNetworkPeeringListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualNetworkPeeringListResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkPeeringListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualNetworkPeeringListResult.NextLink == nil || len(*p.current.VirtualNetworkPeeringListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkPeeringListResultPager) PageResponse() *VirtualNetworkPeeringListResultResponse {
	return p.current
}

// VirtualNetworkTapListResultPager provides iteration over VirtualNetworkTapListResult pages.
type VirtualNetworkTapListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualNetworkTapListResultResponse.
	PageResponse() *VirtualNetworkTapListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualNetworkTapListResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualNetworkTapListResultHandleError func(*azcore.Response) error

type virtualNetworkTapListResultHandleResponse func(*azcore.Response) (*VirtualNetworkTapListResultResponse, error)

type virtualNetworkTapListResultAdvancePage func(context.Context, *VirtualNetworkTapListResultResponse) (*azcore.Request, error)

type virtualNetworkTapListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualNetworkTapListResultCreateRequest
	// callback for handling response errors
	errorer virtualNetworkTapListResultHandleError
	// callback for handling the HTTP response
	responder virtualNetworkTapListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualNetworkTapListResultAdvancePage
	// contains the current response
	current *VirtualNetworkTapListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualNetworkTapListResultPager) Err() error {
	return p.err
}

func (p *virtualNetworkTapListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualNetworkTapListResult.NextLink == nil || len(*p.current.VirtualNetworkTapListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualNetworkTapListResultPager) PageResponse() *VirtualNetworkTapListResultResponse {
	return p.current
}

// VirtualRouterListResultPager provides iteration over VirtualRouterListResult pages.
type VirtualRouterListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualRouterListResultResponse.
	PageResponse() *VirtualRouterListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualRouterListResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualRouterListResultHandleError func(*azcore.Response) error

type virtualRouterListResultHandleResponse func(*azcore.Response) (*VirtualRouterListResultResponse, error)

type virtualRouterListResultAdvancePage func(context.Context, *VirtualRouterListResultResponse) (*azcore.Request, error)

type virtualRouterListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualRouterListResultCreateRequest
	// callback for handling response errors
	errorer virtualRouterListResultHandleError
	// callback for handling the HTTP response
	responder virtualRouterListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualRouterListResultAdvancePage
	// contains the current response
	current *VirtualRouterListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualRouterListResultPager) Err() error {
	return p.err
}

func (p *virtualRouterListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualRouterListResult.NextLink == nil || len(*p.current.VirtualRouterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualRouterListResultPager) PageResponse() *VirtualRouterListResultResponse {
	return p.current
}

// VirtualRouterPeeringListResultPager provides iteration over VirtualRouterPeeringListResult pages.
type VirtualRouterPeeringListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current VirtualRouterPeeringListResultResponse.
	PageResponse() *VirtualRouterPeeringListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type virtualRouterPeeringListResultCreateRequest func(context.Context) (*azcore.Request, error)

type virtualRouterPeeringListResultHandleError func(*azcore.Response) error

type virtualRouterPeeringListResultHandleResponse func(*azcore.Response) (*VirtualRouterPeeringListResultResponse, error)

type virtualRouterPeeringListResultAdvancePage func(context.Context, *VirtualRouterPeeringListResultResponse) (*azcore.Request, error)

type virtualRouterPeeringListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester virtualRouterPeeringListResultCreateRequest
	// callback for handling response errors
	errorer virtualRouterPeeringListResultHandleError
	// callback for handling the HTTP response
	responder virtualRouterPeeringListResultHandleResponse
	// callback for advancing to the next page
	advancer virtualRouterPeeringListResultAdvancePage
	// contains the current response
	current *VirtualRouterPeeringListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *virtualRouterPeeringListResultPager) Err() error {
	return p.err
}

func (p *virtualRouterPeeringListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.VirtualRouterPeeringListResult.NextLink == nil || len(*p.current.VirtualRouterPeeringListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *virtualRouterPeeringListResultPager) PageResponse() *VirtualRouterPeeringListResultResponse {
	return p.current
}

// WebApplicationFirewallPolicyListResultPager provides iteration over WebApplicationFirewallPolicyListResult pages.
type WebApplicationFirewallPolicyListResultPager interface {
	// NextPage returns true if the pager advanced to the next page.
	// Returns false if there are no more pages or an error occurred.
	NextPage(context.Context) bool

	// Page returns the current WebApplicationFirewallPolicyListResultResponse.
	PageResponse() *WebApplicationFirewallPolicyListResultResponse

	// Err returns the last error encountered while paging.
	Err() error
}

type webApplicationFirewallPolicyListResultCreateRequest func(context.Context) (*azcore.Request, error)

type webApplicationFirewallPolicyListResultHandleError func(*azcore.Response) error

type webApplicationFirewallPolicyListResultHandleResponse func(*azcore.Response) (*WebApplicationFirewallPolicyListResultResponse, error)

type webApplicationFirewallPolicyListResultAdvancePage func(context.Context, *WebApplicationFirewallPolicyListResultResponse) (*azcore.Request, error)

type webApplicationFirewallPolicyListResultPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester webApplicationFirewallPolicyListResultCreateRequest
	// callback for handling response errors
	errorer webApplicationFirewallPolicyListResultHandleError
	// callback for handling the HTTP response
	responder webApplicationFirewallPolicyListResultHandleResponse
	// callback for advancing to the next page
	advancer webApplicationFirewallPolicyListResultAdvancePage
	// contains the current response
	current *WebApplicationFirewallPolicyListResultResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *webApplicationFirewallPolicyListResultPager) Err() error {
	return p.err
}

func (p *webApplicationFirewallPolicyListResultPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if p.current != nil {
		if p.current.WebApplicationFirewallPolicyListResult.NextLink == nil || len(*p.current.WebApplicationFirewallPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *webApplicationFirewallPolicyListResultPager) PageResponse() *WebApplicationFirewallPolicyListResultResponse {
	return p.current
}
