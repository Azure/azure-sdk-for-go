// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// ApplicationGatewayBackendHealthOnDemandPoller provides polling facilities until the operation completes
type ApplicationGatewayBackendHealthOnDemandPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ApplicationGatewayBackendHealthOnDemandResponse, error)
	ResumeToken() (string, error)
}

type applicationGatewayBackendHealthOnDemandPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationGatewayBackendHealthOnDemandPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationGatewayBackendHealthOnDemandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *applicationGatewayBackendHealthOnDemandPoller) FinalResponse(ctx context.Context) (*ApplicationGatewayBackendHealthOnDemandResponse, error) {
	respType := &ApplicationGatewayBackendHealthOnDemandResponse{ApplicationGatewayBackendHealthOnDemand: &ApplicationGatewayBackendHealthOnDemand{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationGatewayBackendHealthOnDemand)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeApplicationGatewayBackendHealthOnDemandPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationGatewayBackendHealthOnDemandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewayBackendHealthOnDemandPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ApplicationGatewayBackendHealthOnDemandResponse, error) {
	respType := &ApplicationGatewayBackendHealthOnDemandResponse{ApplicationGatewayBackendHealthOnDemand: &ApplicationGatewayBackendHealthOnDemand{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationGatewayBackendHealthOnDemand)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationGatewayBackendHealthPoller provides polling facilities until the operation completes
type ApplicationGatewayBackendHealthPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ApplicationGatewayBackendHealthResponse, error)
	ResumeToken() (string, error)
}

type applicationGatewayBackendHealthPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationGatewayBackendHealthPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationGatewayBackendHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *applicationGatewayBackendHealthPoller) FinalResponse(ctx context.Context) (*ApplicationGatewayBackendHealthResponse, error) {
	respType := &ApplicationGatewayBackendHealthResponse{ApplicationGatewayBackendHealth: &ApplicationGatewayBackendHealth{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationGatewayBackendHealth)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeApplicationGatewayBackendHealthPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationGatewayBackendHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewayBackendHealthPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ApplicationGatewayBackendHealthResponse, error) {
	respType := &ApplicationGatewayBackendHealthResponse{ApplicationGatewayBackendHealth: &ApplicationGatewayBackendHealth{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationGatewayBackendHealth)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationGatewayPoller provides polling facilities until the operation completes
type ApplicationGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ApplicationGatewayResponse, error)
	ResumeToken() (string, error)
}

type applicationGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *applicationGatewayPoller) FinalResponse(ctx context.Context) (*ApplicationGatewayResponse, error) {
	respType := &ApplicationGatewayResponse{ApplicationGateway: &ApplicationGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeApplicationGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ApplicationGatewayResponse, error) {
	respType := &ApplicationGatewayResponse{ApplicationGateway: &ApplicationGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationSecurityGroupPoller provides polling facilities until the operation completes
type ApplicationSecurityGroupPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ApplicationSecurityGroupResponse, error)
	ResumeToken() (string, error)
}

type applicationSecurityGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationSecurityGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationSecurityGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *applicationSecurityGroupPoller) FinalResponse(ctx context.Context) (*ApplicationSecurityGroupResponse, error) {
	respType := &ApplicationSecurityGroupResponse{ApplicationSecurityGroup: &ApplicationSecurityGroup{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationSecurityGroup)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeApplicationSecurityGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationSecurityGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationSecurityGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ApplicationSecurityGroupResponse, error) {
	respType := &ApplicationSecurityGroupResponse{ApplicationSecurityGroup: &ApplicationSecurityGroup{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationSecurityGroup)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AvailableProvidersListPoller provides polling facilities until the operation completes
type AvailableProvidersListPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*AvailableProvidersListResponse, error)
	ResumeToken() (string, error)
}

type availableProvidersListPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *availableProvidersListPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *availableProvidersListPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *availableProvidersListPoller) FinalResponse(ctx context.Context) (*AvailableProvidersListResponse, error) {
	respType := &AvailableProvidersListResponse{AvailableProvidersList: &AvailableProvidersList{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.AvailableProvidersList)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeAvailableProvidersListPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *availableProvidersListPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *availableProvidersListPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*AvailableProvidersListResponse, error) {
	respType := &AvailableProvidersListResponse{AvailableProvidersList: &AvailableProvidersList{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.AvailableProvidersList)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AzureFirewallPoller provides polling facilities until the operation completes
type AzureFirewallPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*AzureFirewallResponse, error)
	ResumeToken() (string, error)
}

type azureFirewallPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *azureFirewallPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *azureFirewallPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *azureFirewallPoller) FinalResponse(ctx context.Context) (*AzureFirewallResponse, error) {
	respType := &AzureFirewallResponse{AzureFirewall: &AzureFirewall{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.AzureFirewall)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeAzureFirewallPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *azureFirewallPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *azureFirewallPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*AzureFirewallResponse, error) {
	respType := &AzureFirewallResponse{AzureFirewall: &AzureFirewall{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.AzureFirewall)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AzureReachabilityReportPoller provides polling facilities until the operation completes
type AzureReachabilityReportPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*AzureReachabilityReportResponse, error)
	ResumeToken() (string, error)
}

type azureReachabilityReportPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *azureReachabilityReportPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *azureReachabilityReportPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *azureReachabilityReportPoller) FinalResponse(ctx context.Context) (*AzureReachabilityReportResponse, error) {
	respType := &AzureReachabilityReportResponse{AzureReachabilityReport: &AzureReachabilityReport{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.AzureReachabilityReport)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeAzureReachabilityReportPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *azureReachabilityReportPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *azureReachabilityReportPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*AzureReachabilityReportResponse, error) {
	respType := &AzureReachabilityReportResponse{AzureReachabilityReport: &AzureReachabilityReport{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.AzureReachabilityReport)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// BastionActiveSessionListResultPagerPoller provides polling facilities until the operation completes
type BastionActiveSessionListResultPagerPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (BastionActiveSessionListResultPager, error)
	ResumeToken() (string, error)
}

type bastionActiveSessionListResultPagerPoller struct {
	// the client for making the request
	pipeline    azcore.Pipeline
	errHandler  bastionActiveSessionListResultHandleError
	respHandler bastionActiveSessionListResultHandleResponse
	statusCodes []int
	pt          armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bastionActiveSessionListResultPagerPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bastionActiveSessionListResultPagerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *bastionActiveSessionListResultPagerPoller) FinalResponse(ctx context.Context) (BastionActiveSessionListResultPager, error) {
	respType := &bastionActiveSessionListResultPager{}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(&azcore.Response{Response: resp})
}

// ResumeToken generates the string token that can be used with the ResumeBastionActiveSessionListResultPagerPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bastionActiveSessionListResultPagerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bastionActiveSessionListResultPagerPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BastionActiveSessionListResultPager, error) {
	respType := &bastionActiveSessionListResultPager{}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(&azcore.Response{Response: resp})
}

func (p *bastionActiveSessionListResultPagerPoller) handleResponse(resp *azcore.Response) (BastionActiveSessionListResultPager, error) {
	return &bastionActiveSessionListResultPager{
		pipeline:  p.pipeline,
		resp:      resp,
		errorer:   p.errHandler,
		responder: p.respHandler,
		advancer: func(ctx context.Context, resp *BastionActiveSessionListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.BastionActiveSessionListResult.NextLink)
		},
		statusCodes: p.statusCodes,
	}, nil
}

// BastionHostPoller provides polling facilities until the operation completes
type BastionHostPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*BastionHostResponse, error)
	ResumeToken() (string, error)
}

type bastionHostPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bastionHostPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bastionHostPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *bastionHostPoller) FinalResponse(ctx context.Context) (*BastionHostResponse, error) {
	respType := &BastionHostResponse{BastionHost: &BastionHost{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.BastionHost)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeBastionHostPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bastionHostPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bastionHostPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*BastionHostResponse, error) {
	respType := &BastionHostResponse{BastionHost: &BastionHost{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.BastionHost)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// BastionShareableLinkListResultPagerPoller provides polling facilities until the operation completes
type BastionShareableLinkListResultPagerPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (BastionShareableLinkListResultPager, error)
	ResumeToken() (string, error)
}

type bastionShareableLinkListResultPagerPoller struct {
	// the client for making the request
	pipeline    azcore.Pipeline
	errHandler  bastionShareableLinkListResultHandleError
	respHandler bastionShareableLinkListResultHandleResponse
	statusCodes []int
	pt          armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bastionShareableLinkListResultPagerPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bastionShareableLinkListResultPagerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *bastionShareableLinkListResultPagerPoller) FinalResponse(ctx context.Context) (BastionShareableLinkListResultPager, error) {
	respType := &bastionShareableLinkListResultPager{}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(&azcore.Response{Response: resp})
}

// ResumeToken generates the string token that can be used with the ResumeBastionShareableLinkListResultPagerPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bastionShareableLinkListResultPagerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bastionShareableLinkListResultPagerPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BastionShareableLinkListResultPager, error) {
	respType := &bastionShareableLinkListResultPager{}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(&azcore.Response{Response: resp})
}

func (p *bastionShareableLinkListResultPagerPoller) handleResponse(resp *azcore.Response) (BastionShareableLinkListResultPager, error) {
	return &bastionShareableLinkListResultPager{
		pipeline:  p.pipeline,
		resp:      resp,
		errorer:   p.errHandler,
		responder: p.respHandler,
		advancer: func(ctx context.Context, resp *BastionShareableLinkListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.BastionShareableLinkListResult.NextLink)
		},
		statusCodes: p.statusCodes,
	}, nil
}

// BgpPeerStatusListResultPoller provides polling facilities until the operation completes
type BgpPeerStatusListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*BgpPeerStatusListResultResponse, error)
	ResumeToken() (string, error)
}

type bgpPeerStatusListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bgpPeerStatusListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bgpPeerStatusListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *bgpPeerStatusListResultPoller) FinalResponse(ctx context.Context) (*BgpPeerStatusListResultResponse, error) {
	respType := &BgpPeerStatusListResultResponse{BgpPeerStatusListResult: &BgpPeerStatusListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.BgpPeerStatusListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeBgpPeerStatusListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bgpPeerStatusListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bgpPeerStatusListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*BgpPeerStatusListResultResponse, error) {
	respType := &BgpPeerStatusListResultResponse{BgpPeerStatusListResult: &BgpPeerStatusListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.BgpPeerStatusListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionMonitorQueryResultPoller provides polling facilities until the operation completes
type ConnectionMonitorQueryResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ConnectionMonitorQueryResultResponse, error)
	ResumeToken() (string, error)
}

type connectionMonitorQueryResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectionMonitorQueryResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectionMonitorQueryResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *connectionMonitorQueryResultPoller) FinalResponse(ctx context.Context) (*ConnectionMonitorQueryResultResponse, error) {
	respType := &ConnectionMonitorQueryResultResponse{ConnectionMonitorQueryResult: &ConnectionMonitorQueryResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectionMonitorQueryResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeConnectionMonitorQueryResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectionMonitorQueryResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionMonitorQueryResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ConnectionMonitorQueryResultResponse, error) {
	respType := &ConnectionMonitorQueryResultResponse{ConnectionMonitorQueryResult: &ConnectionMonitorQueryResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectionMonitorQueryResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionMonitorResultPoller provides polling facilities until the operation completes
type ConnectionMonitorResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ConnectionMonitorResultResponse, error)
	ResumeToken() (string, error)
}

type connectionMonitorResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectionMonitorResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectionMonitorResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *connectionMonitorResultPoller) FinalResponse(ctx context.Context) (*ConnectionMonitorResultResponse, error) {
	respType := &ConnectionMonitorResultResponse{ConnectionMonitorResult: &ConnectionMonitorResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectionMonitorResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeConnectionMonitorResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectionMonitorResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionMonitorResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ConnectionMonitorResultResponse, error) {
	respType := &ConnectionMonitorResultResponse{ConnectionMonitorResult: &ConnectionMonitorResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectionMonitorResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionResetSharedKeyPoller provides polling facilities until the operation completes
type ConnectionResetSharedKeyPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ConnectionResetSharedKeyResponse, error)
	ResumeToken() (string, error)
}

type connectionResetSharedKeyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectionResetSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectionResetSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *connectionResetSharedKeyPoller) FinalResponse(ctx context.Context) (*ConnectionResetSharedKeyResponse, error) {
	respType := &ConnectionResetSharedKeyResponse{ConnectionResetSharedKey: &ConnectionResetSharedKey{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectionResetSharedKey)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeConnectionResetSharedKeyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectionResetSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionResetSharedKeyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ConnectionResetSharedKeyResponse, error) {
	respType := &ConnectionResetSharedKeyResponse{ConnectionResetSharedKey: &ConnectionResetSharedKey{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectionResetSharedKey)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionSharedKeyPoller provides polling facilities until the operation completes
type ConnectionSharedKeyPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ConnectionSharedKeyResponse, error)
	ResumeToken() (string, error)
}

type connectionSharedKeyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectionSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectionSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *connectionSharedKeyPoller) FinalResponse(ctx context.Context) (*ConnectionSharedKeyResponse, error) {
	respType := &ConnectionSharedKeyResponse{ConnectionSharedKey: &ConnectionSharedKey{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectionSharedKey)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeConnectionSharedKeyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectionSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionSharedKeyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ConnectionSharedKeyResponse, error) {
	respType := &ConnectionSharedKeyResponse{ConnectionSharedKey: &ConnectionSharedKey{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectionSharedKey)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectivityInformationPoller provides polling facilities until the operation completes
type ConnectivityInformationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ConnectivityInformationResponse, error)
	ResumeToken() (string, error)
}

type connectivityInformationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectivityInformationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectivityInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *connectivityInformationPoller) FinalResponse(ctx context.Context) (*ConnectivityInformationResponse, error) {
	respType := &ConnectivityInformationResponse{ConnectivityInformation: &ConnectivityInformation{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectivityInformation)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeConnectivityInformationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectivityInformationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectivityInformationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ConnectivityInformationResponse, error) {
	respType := &ConnectivityInformationResponse{ConnectivityInformation: &ConnectivityInformation{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectivityInformation)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DdosCustomPolicyPoller provides polling facilities until the operation completes
type DdosCustomPolicyPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*DdosCustomPolicyResponse, error)
	ResumeToken() (string, error)
}

type ddosCustomPolicyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *ddosCustomPolicyPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *ddosCustomPolicyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *ddosCustomPolicyPoller) FinalResponse(ctx context.Context) (*DdosCustomPolicyResponse, error) {
	respType := &DdosCustomPolicyResponse{DdosCustomPolicy: &DdosCustomPolicy{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.DdosCustomPolicy)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeDdosCustomPolicyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *ddosCustomPolicyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ddosCustomPolicyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*DdosCustomPolicyResponse, error) {
	respType := &DdosCustomPolicyResponse{DdosCustomPolicy: &DdosCustomPolicy{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.DdosCustomPolicy)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DdosProtectionPlanPoller provides polling facilities until the operation completes
type DdosProtectionPlanPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*DdosProtectionPlanResponse, error)
	ResumeToken() (string, error)
}

type ddosProtectionPlanPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *ddosProtectionPlanPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *ddosProtectionPlanPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *ddosProtectionPlanPoller) FinalResponse(ctx context.Context) (*DdosProtectionPlanResponse, error) {
	respType := &DdosProtectionPlanResponse{DdosProtectionPlan: &DdosProtectionPlan{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.DdosProtectionPlan)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeDdosProtectionPlanPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *ddosProtectionPlanPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ddosProtectionPlanPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*DdosProtectionPlanResponse, error) {
	respType := &DdosProtectionPlanResponse{DdosProtectionPlan: &DdosProtectionPlan{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.DdosProtectionPlan)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EffectiveNetworkSecurityGroupListResultPoller provides polling facilities until the operation completes
type EffectiveNetworkSecurityGroupListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*EffectiveNetworkSecurityGroupListResultResponse, error)
	ResumeToken() (string, error)
}

type effectiveNetworkSecurityGroupListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *effectiveNetworkSecurityGroupListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *effectiveNetworkSecurityGroupListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *effectiveNetworkSecurityGroupListResultPoller) FinalResponse(ctx context.Context) (*EffectiveNetworkSecurityGroupListResultResponse, error) {
	respType := &EffectiveNetworkSecurityGroupListResultResponse{EffectiveNetworkSecurityGroupListResult: &EffectiveNetworkSecurityGroupListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.EffectiveNetworkSecurityGroupListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeEffectiveNetworkSecurityGroupListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *effectiveNetworkSecurityGroupListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *effectiveNetworkSecurityGroupListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*EffectiveNetworkSecurityGroupListResultResponse, error) {
	respType := &EffectiveNetworkSecurityGroupListResultResponse{EffectiveNetworkSecurityGroupListResult: &EffectiveNetworkSecurityGroupListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.EffectiveNetworkSecurityGroupListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EffectiveRouteListResultPoller provides polling facilities until the operation completes
type EffectiveRouteListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*EffectiveRouteListResultResponse, error)
	ResumeToken() (string, error)
}

type effectiveRouteListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *effectiveRouteListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *effectiveRouteListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *effectiveRouteListResultPoller) FinalResponse(ctx context.Context) (*EffectiveRouteListResultResponse, error) {
	respType := &EffectiveRouteListResultResponse{EffectiveRouteListResult: &EffectiveRouteListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.EffectiveRouteListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeEffectiveRouteListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *effectiveRouteListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *effectiveRouteListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*EffectiveRouteListResultResponse, error) {
	respType := &EffectiveRouteListResultResponse{EffectiveRouteListResult: &EffectiveRouteListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.EffectiveRouteListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitAuthorizationPoller provides polling facilities until the operation completes
type ExpressRouteCircuitAuthorizationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitAuthorizationResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitAuthorizationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitAuthorizationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitAuthorizationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitAuthorizationPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitAuthorizationResponse, error) {
	respType := &ExpressRouteCircuitAuthorizationResponse{ExpressRouteCircuitAuthorization: &ExpressRouteCircuitAuthorization{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitAuthorization)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitAuthorizationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitAuthorizationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitAuthorizationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitAuthorizationResponse, error) {
	respType := &ExpressRouteCircuitAuthorizationResponse{ExpressRouteCircuitAuthorization: &ExpressRouteCircuitAuthorization{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitAuthorization)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitConnectionPoller provides polling facilities until the operation completes
type ExpressRouteCircuitConnectionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitConnectionResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitConnectionPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitConnectionResponse, error) {
	respType := &ExpressRouteCircuitConnectionResponse{ExpressRouteCircuitConnection: &ExpressRouteCircuitConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitConnection)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitConnectionResponse, error) {
	respType := &ExpressRouteCircuitConnectionResponse{ExpressRouteCircuitConnection: &ExpressRouteCircuitConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitConnection)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitPeeringPoller provides polling facilities until the operation completes
type ExpressRouteCircuitPeeringPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitPeeringResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitPeeringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitPeeringPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitPeeringPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitPeeringResponse, error) {
	respType := &ExpressRouteCircuitPeeringResponse{ExpressRouteCircuitPeering: &ExpressRouteCircuitPeering{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitPeering)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitPeeringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitPeeringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitPeeringResponse, error) {
	respType := &ExpressRouteCircuitPeeringResponse{ExpressRouteCircuitPeering: &ExpressRouteCircuitPeering{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitPeering)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitPoller provides polling facilities until the operation completes
type ExpressRouteCircuitPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitResponse, error) {
	respType := &ExpressRouteCircuitResponse{ExpressRouteCircuit: &ExpressRouteCircuit{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuit)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitResponse, error) {
	respType := &ExpressRouteCircuitResponse{ExpressRouteCircuit: &ExpressRouteCircuit{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuit)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitsArpTableListResultPoller provides polling facilities until the operation completes
type ExpressRouteCircuitsArpTableListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitsArpTableListResultResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitsArpTableListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitsArpTableListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitsArpTableListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitsArpTableListResultPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitsArpTableListResultResponse, error) {
	respType := &ExpressRouteCircuitsArpTableListResultResponse{ExpressRouteCircuitsArpTableListResult: &ExpressRouteCircuitsArpTableListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitsArpTableListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitsArpTableListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitsArpTableListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitsArpTableListResultResponse, error) {
	respType := &ExpressRouteCircuitsArpTableListResultResponse{ExpressRouteCircuitsArpTableListResult: &ExpressRouteCircuitsArpTableListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitsRoutesTableListResultPoller provides polling facilities until the operation completes
type ExpressRouteCircuitsRoutesTableListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitsRoutesTableListResultResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitsRoutesTableListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitsRoutesTableListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitsRoutesTableListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitsRoutesTableListResultPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitsRoutesTableListResultResponse, error) {
	respType := &ExpressRouteCircuitsRoutesTableListResultResponse{ExpressRouteCircuitsRoutesTableListResult: &ExpressRouteCircuitsRoutesTableListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitsRoutesTableListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitsRoutesTableListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitsRoutesTableListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitsRoutesTableListResultResponse, error) {
	respType := &ExpressRouteCircuitsRoutesTableListResultResponse{ExpressRouteCircuitsRoutesTableListResult: &ExpressRouteCircuitsRoutesTableListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitsRoutesTableSummaryListResultPoller provides polling facilities until the operation completes
type ExpressRouteCircuitsRoutesTableSummaryListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCircuitsRoutesTableSummaryListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) FinalResponse(ctx context.Context) (*ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error) {
	respType := &ExpressRouteCircuitsRoutesTableSummaryListResultResponse{ExpressRouteCircuitsRoutesTableSummaryListResult: &ExpressRouteCircuitsRoutesTableSummaryListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitsRoutesTableSummaryListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitsRoutesTableSummaryListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error) {
	respType := &ExpressRouteCircuitsRoutesTableSummaryListResultResponse{ExpressRouteCircuitsRoutesTableSummaryListResult: &ExpressRouteCircuitsRoutesTableSummaryListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitsRoutesTableSummaryListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteConnectionPoller provides polling facilities until the operation completes
type ExpressRouteConnectionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteConnectionResponse, error)
	ResumeToken() (string, error)
}

type expressRouteConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteConnectionPoller) FinalResponse(ctx context.Context) (*ExpressRouteConnectionResponse, error) {
	respType := &ExpressRouteConnectionResponse{ExpressRouteConnection: &ExpressRouteConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteConnection)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteConnectionResponse, error) {
	respType := &ExpressRouteConnectionResponse{ExpressRouteConnection: &ExpressRouteConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteConnection)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCrossConnectionPeeringPoller provides polling facilities until the operation completes
type ExpressRouteCrossConnectionPeeringPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCrossConnectionPeeringResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCrossConnectionPeeringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCrossConnectionPeeringPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCrossConnectionPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCrossConnectionPeeringPoller) FinalResponse(ctx context.Context) (*ExpressRouteCrossConnectionPeeringResponse, error) {
	respType := &ExpressRouteCrossConnectionPeeringResponse{ExpressRouteCrossConnectionPeering: &ExpressRouteCrossConnectionPeering{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCrossConnectionPeering)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCrossConnectionPeeringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCrossConnectionPeeringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCrossConnectionPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCrossConnectionPeeringResponse, error) {
	respType := &ExpressRouteCrossConnectionPeeringResponse{ExpressRouteCrossConnectionPeering: &ExpressRouteCrossConnectionPeering{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCrossConnectionPeering)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCrossConnectionPoller provides polling facilities until the operation completes
type ExpressRouteCrossConnectionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCrossConnectionResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCrossConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCrossConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCrossConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCrossConnectionPoller) FinalResponse(ctx context.Context) (*ExpressRouteCrossConnectionResponse, error) {
	respType := &ExpressRouteCrossConnectionResponse{ExpressRouteCrossConnection: &ExpressRouteCrossConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCrossConnection)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCrossConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCrossConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCrossConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCrossConnectionResponse, error) {
	respType := &ExpressRouteCrossConnectionResponse{ExpressRouteCrossConnection: &ExpressRouteCrossConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCrossConnection)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCrossConnectionsRoutesTableSummaryListResultPoller provides polling facilities until the operation completes
type ExpressRouteCrossConnectionsRoutesTableSummaryListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error)
	ResumeToken() (string, error)
}

type expressRouteCrossConnectionsRoutesTableSummaryListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) FinalResponse(ctx context.Context) (*ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error) {
	respType := &ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse{ExpressRouteCrossConnectionsRoutesTableSummaryListResult: &ExpressRouteCrossConnectionsRoutesTableSummaryListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCrossConnectionsRoutesTableSummaryListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error) {
	respType := &ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse{ExpressRouteCrossConnectionsRoutesTableSummaryListResult: &ExpressRouteCrossConnectionsRoutesTableSummaryListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteGatewayPoller provides polling facilities until the operation completes
type ExpressRouteGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRouteGatewayResponse, error)
	ResumeToken() (string, error)
}

type expressRouteGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteGatewayPoller) FinalResponse(ctx context.Context) (*ExpressRouteGatewayResponse, error) {
	respType := &ExpressRouteGatewayResponse{ExpressRouteGateway: &ExpressRouteGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRouteGatewayResponse, error) {
	respType := &ExpressRouteGatewayResponse{ExpressRouteGateway: &ExpressRouteGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRoutePortPoller provides polling facilities until the operation completes
type ExpressRoutePortPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ExpressRoutePortResponse, error)
	ResumeToken() (string, error)
}

type expressRoutePortPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRoutePortPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRoutePortPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRoutePortPoller) FinalResponse(ctx context.Context) (*ExpressRoutePortResponse, error) {
	respType := &ExpressRoutePortResponse{ExpressRoutePort: &ExpressRoutePort{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRoutePort)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRoutePortPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRoutePortPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRoutePortPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ExpressRoutePortResponse, error) {
	respType := &ExpressRoutePortResponse{ExpressRoutePort: &ExpressRoutePort{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRoutePort)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FirewallPolicyPoller provides polling facilities until the operation completes
type FirewallPolicyPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*FirewallPolicyResponse, error)
	ResumeToken() (string, error)
}

type firewallPolicyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *firewallPolicyPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *firewallPolicyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *firewallPolicyPoller) FinalResponse(ctx context.Context) (*FirewallPolicyResponse, error) {
	respType := &FirewallPolicyResponse{FirewallPolicy: &FirewallPolicy{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.FirewallPolicy)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeFirewallPolicyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *firewallPolicyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *firewallPolicyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*FirewallPolicyResponse, error) {
	respType := &FirewallPolicyResponse{FirewallPolicy: &FirewallPolicy{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.FirewallPolicy)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FirewallPolicyRuleGroupPoller provides polling facilities until the operation completes
type FirewallPolicyRuleGroupPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*FirewallPolicyRuleGroupResponse, error)
	ResumeToken() (string, error)
}

type firewallPolicyRuleGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *firewallPolicyRuleGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *firewallPolicyRuleGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *firewallPolicyRuleGroupPoller) FinalResponse(ctx context.Context) (*FirewallPolicyRuleGroupResponse, error) {
	respType := &FirewallPolicyRuleGroupResponse{FirewallPolicyRuleGroup: &FirewallPolicyRuleGroup{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.FirewallPolicyRuleGroup)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeFirewallPolicyRuleGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *firewallPolicyRuleGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *firewallPolicyRuleGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*FirewallPolicyRuleGroupResponse, error) {
	respType := &FirewallPolicyRuleGroupResponse{FirewallPolicyRuleGroup: &FirewallPolicyRuleGroup{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.FirewallPolicyRuleGroup)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FlowLogInformationPoller provides polling facilities until the operation completes
type FlowLogInformationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*FlowLogInformationResponse, error)
	ResumeToken() (string, error)
}

type flowLogInformationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *flowLogInformationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *flowLogInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *flowLogInformationPoller) FinalResponse(ctx context.Context) (*FlowLogInformationResponse, error) {
	respType := &FlowLogInformationResponse{FlowLogInformation: &FlowLogInformation{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.FlowLogInformation)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeFlowLogInformationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *flowLogInformationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *flowLogInformationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*FlowLogInformationResponse, error) {
	respType := &FlowLogInformationResponse{FlowLogInformation: &FlowLogInformation{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.FlowLogInformation)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FlowLogPoller provides polling facilities until the operation completes
type FlowLogPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*FlowLogResponse, error)
	ResumeToken() (string, error)
}

type flowLogPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *flowLogPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *flowLogPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *flowLogPoller) FinalResponse(ctx context.Context) (*FlowLogResponse, error) {
	respType := &FlowLogResponse{FlowLog: &FlowLog{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.FlowLog)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeFlowLogPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *flowLogPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *flowLogPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*FlowLogResponse, error) {
	respType := &FlowLogResponse{FlowLog: &FlowLog{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.FlowLog)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GatewayRouteListResultPoller provides polling facilities until the operation completes
type GatewayRouteListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*GatewayRouteListResultResponse, error)
	ResumeToken() (string, error)
}

type gatewayRouteListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *gatewayRouteListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *gatewayRouteListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *gatewayRouteListResultPoller) FinalResponse(ctx context.Context) (*GatewayRouteListResultResponse, error) {
	respType := &GatewayRouteListResultResponse{GatewayRouteListResult: &GatewayRouteListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.GatewayRouteListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeGatewayRouteListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *gatewayRouteListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *gatewayRouteListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*GatewayRouteListResultResponse, error) {
	respType := &GatewayRouteListResultResponse{GatewayRouteListResult: &GatewayRouteListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.GatewayRouteListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// HTTPPoller provides polling facilities until the operation completes
type HTTPPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*http.Response, error)
	ResumeToken() (string, error)
}

type httpPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *httpPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *httpPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *httpPoller) FinalResponse(ctx context.Context) (*http.Response, error) {
	return p.pt.FinalResponse(ctx, p.pipeline, nil)
}

// ResumeToken generates the string token that can be used with the ResumeHTTPPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *httpPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *httpPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*http.Response, error) {
	return p.pt.PollUntilDone(ctx, frequency, p.pipeline, nil)
}

// IPAllocationPoller provides polling facilities until the operation completes
type IPAllocationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*IPAllocationResponse, error)
	ResumeToken() (string, error)
}

type ipAllocationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *ipAllocationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *ipAllocationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *ipAllocationPoller) FinalResponse(ctx context.Context) (*IPAllocationResponse, error) {
	respType := &IPAllocationResponse{IPAllocation: &IPAllocation{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.IPAllocation)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeIPAllocationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *ipAllocationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ipAllocationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*IPAllocationResponse, error) {
	respType := &IPAllocationResponse{IPAllocation: &IPAllocation{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.IPAllocation)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// IPGroupPoller provides polling facilities until the operation completes
type IPGroupPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*IPGroupResponse, error)
	ResumeToken() (string, error)
}

type ipGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *ipGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *ipGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *ipGroupPoller) FinalResponse(ctx context.Context) (*IPGroupResponse, error) {
	respType := &IPGroupResponse{IPGroup: &IPGroup{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.IPGroup)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeIPGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *ipGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ipGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*IPGroupResponse, error) {
	respType := &IPGroupResponse{IPGroup: &IPGroup{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.IPGroup)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// InboundNatRulePoller provides polling facilities until the operation completes
type InboundNatRulePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*InboundNatRuleResponse, error)
	ResumeToken() (string, error)
}

type inboundNatRulePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *inboundNatRulePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *inboundNatRulePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *inboundNatRulePoller) FinalResponse(ctx context.Context) (*InboundNatRuleResponse, error) {
	respType := &InboundNatRuleResponse{InboundNatRule: &InboundNatRule{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.InboundNatRule)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeInboundNatRulePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *inboundNatRulePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *inboundNatRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*InboundNatRuleResponse, error) {
	respType := &InboundNatRuleResponse{InboundNatRule: &InboundNatRule{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.InboundNatRule)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LoadBalancerPoller provides polling facilities until the operation completes
type LoadBalancerPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*LoadBalancerResponse, error)
	ResumeToken() (string, error)
}

type loadBalancerPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *loadBalancerPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *loadBalancerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *loadBalancerPoller) FinalResponse(ctx context.Context) (*LoadBalancerResponse, error) {
	respType := &LoadBalancerResponse{LoadBalancer: &LoadBalancer{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.LoadBalancer)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeLoadBalancerPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *loadBalancerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *loadBalancerPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*LoadBalancerResponse, error) {
	respType := &LoadBalancerResponse{LoadBalancer: &LoadBalancer{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.LoadBalancer)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LocalNetworkGatewayPoller provides polling facilities until the operation completes
type LocalNetworkGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*LocalNetworkGatewayResponse, error)
	ResumeToken() (string, error)
}

type localNetworkGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *localNetworkGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *localNetworkGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *localNetworkGatewayPoller) FinalResponse(ctx context.Context) (*LocalNetworkGatewayResponse, error) {
	respType := &LocalNetworkGatewayResponse{LocalNetworkGateway: &LocalNetworkGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.LocalNetworkGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeLocalNetworkGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *localNetworkGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *localNetworkGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*LocalNetworkGatewayResponse, error) {
	respType := &LocalNetworkGatewayResponse{LocalNetworkGateway: &LocalNetworkGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.LocalNetworkGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NatGatewayPoller provides polling facilities until the operation completes
type NatGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NatGatewayResponse, error)
	ResumeToken() (string, error)
}

type natGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *natGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *natGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *natGatewayPoller) FinalResponse(ctx context.Context) (*NatGatewayResponse, error) {
	respType := &NatGatewayResponse{NatGateway: &NatGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NatGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNatGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *natGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *natGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NatGatewayResponse, error) {
	respType := &NatGatewayResponse{NatGateway: &NatGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NatGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkConfigurationDiagnosticResponsePoller provides polling facilities until the operation completes
type NetworkConfigurationDiagnosticResponsePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NetworkConfigurationDiagnosticResponseResponse, error)
	ResumeToken() (string, error)
}

type networkConfigurationDiagnosticResponsePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkConfigurationDiagnosticResponsePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkConfigurationDiagnosticResponsePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *networkConfigurationDiagnosticResponsePoller) FinalResponse(ctx context.Context) (*NetworkConfigurationDiagnosticResponseResponse, error) {
	respType := &NetworkConfigurationDiagnosticResponseResponse{NetworkConfigurationDiagnosticResponse: &NetworkConfigurationDiagnosticResponse{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkConfigurationDiagnosticResponse)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNetworkConfigurationDiagnosticResponsePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkConfigurationDiagnosticResponsePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkConfigurationDiagnosticResponsePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NetworkConfigurationDiagnosticResponseResponse, error) {
	respType := &NetworkConfigurationDiagnosticResponseResponse{NetworkConfigurationDiagnosticResponse: &NetworkConfigurationDiagnosticResponse{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkConfigurationDiagnosticResponse)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkInterfacePoller provides polling facilities until the operation completes
type NetworkInterfacePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NetworkInterfaceResponse, error)
	ResumeToken() (string, error)
}

type networkInterfacePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkInterfacePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkInterfacePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *networkInterfacePoller) FinalResponse(ctx context.Context) (*NetworkInterfaceResponse, error) {
	respType := &NetworkInterfaceResponse{NetworkInterface: &NetworkInterface{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkInterface)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNetworkInterfacePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkInterfacePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkInterfacePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NetworkInterfaceResponse, error) {
	respType := &NetworkInterfaceResponse{NetworkInterface: &NetworkInterface{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkInterface)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkInterfaceTapConfigurationPoller provides polling facilities until the operation completes
type NetworkInterfaceTapConfigurationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NetworkInterfaceTapConfigurationResponse, error)
	ResumeToken() (string, error)
}

type networkInterfaceTapConfigurationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkInterfaceTapConfigurationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkInterfaceTapConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *networkInterfaceTapConfigurationPoller) FinalResponse(ctx context.Context) (*NetworkInterfaceTapConfigurationResponse, error) {
	respType := &NetworkInterfaceTapConfigurationResponse{NetworkInterfaceTapConfiguration: &NetworkInterfaceTapConfiguration{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkInterfaceTapConfiguration)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNetworkInterfaceTapConfigurationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkInterfaceTapConfigurationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkInterfaceTapConfigurationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NetworkInterfaceTapConfigurationResponse, error) {
	respType := &NetworkInterfaceTapConfigurationResponse{NetworkInterfaceTapConfiguration: &NetworkInterfaceTapConfiguration{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkInterfaceTapConfiguration)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkSecurityGroupPoller provides polling facilities until the operation completes
type NetworkSecurityGroupPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NetworkSecurityGroupResponse, error)
	ResumeToken() (string, error)
}

type networkSecurityGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkSecurityGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkSecurityGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *networkSecurityGroupPoller) FinalResponse(ctx context.Context) (*NetworkSecurityGroupResponse, error) {
	respType := &NetworkSecurityGroupResponse{NetworkSecurityGroup: &NetworkSecurityGroup{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkSecurityGroup)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNetworkSecurityGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkSecurityGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkSecurityGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NetworkSecurityGroupResponse, error) {
	respType := &NetworkSecurityGroupResponse{NetworkSecurityGroup: &NetworkSecurityGroup{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkSecurityGroup)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkVirtualAppliancePoller provides polling facilities until the operation completes
type NetworkVirtualAppliancePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NetworkVirtualApplianceResponse, error)
	ResumeToken() (string, error)
}

type networkVirtualAppliancePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkVirtualAppliancePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkVirtualAppliancePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *networkVirtualAppliancePoller) FinalResponse(ctx context.Context) (*NetworkVirtualApplianceResponse, error) {
	respType := &NetworkVirtualApplianceResponse{NetworkVirtualAppliance: &NetworkVirtualAppliance{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkVirtualAppliance)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNetworkVirtualAppliancePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkVirtualAppliancePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkVirtualAppliancePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NetworkVirtualApplianceResponse, error) {
	respType := &NetworkVirtualApplianceResponse{NetworkVirtualAppliance: &NetworkVirtualAppliance{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkVirtualAppliance)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NextHopResultPoller provides polling facilities until the operation completes
type NextHopResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*NextHopResultResponse, error)
	ResumeToken() (string, error)
}

type nextHopResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *nextHopResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *nextHopResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *nextHopResultPoller) FinalResponse(ctx context.Context) (*NextHopResultResponse, error) {
	respType := &NextHopResultResponse{NextHopResult: &NextHopResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NextHopResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNextHopResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *nextHopResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *nextHopResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*NextHopResultResponse, error) {
	respType := &NextHopResultResponse{NextHopResult: &NextHopResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NextHopResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// P2SVpnConnectionHealthPoller provides polling facilities until the operation completes
type P2SVpnConnectionHealthPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*P2SVpnConnectionHealthResponse, error)
	ResumeToken() (string, error)
}

type p2SVpnConnectionHealthPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *p2SVpnConnectionHealthPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *p2SVpnConnectionHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *p2SVpnConnectionHealthPoller) FinalResponse(ctx context.Context) (*P2SVpnConnectionHealthResponse, error) {
	respType := &P2SVpnConnectionHealthResponse{P2SVpnConnectionHealth: &P2SVpnConnectionHealth{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.P2SVpnConnectionHealth)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeP2SVpnConnectionHealthPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *p2SVpnConnectionHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *p2SVpnConnectionHealthPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*P2SVpnConnectionHealthResponse, error) {
	respType := &P2SVpnConnectionHealthResponse{P2SVpnConnectionHealth: &P2SVpnConnectionHealth{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.P2SVpnConnectionHealth)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// P2SVpnGatewayPoller provides polling facilities until the operation completes
type P2SVpnGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*P2SVpnGatewayResponse, error)
	ResumeToken() (string, error)
}

type p2SVpnGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *p2SVpnGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *p2SVpnGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *p2SVpnGatewayPoller) FinalResponse(ctx context.Context) (*P2SVpnGatewayResponse, error) {
	respType := &P2SVpnGatewayResponse{P2SVpnGateway: &P2SVpnGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.P2SVpnGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeP2SVpnGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *p2SVpnGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *p2SVpnGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*P2SVpnGatewayResponse, error) {
	respType := &P2SVpnGatewayResponse{P2SVpnGateway: &P2SVpnGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.P2SVpnGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PacketCaptureQueryStatusResultPoller provides polling facilities until the operation completes
type PacketCaptureQueryStatusResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PacketCaptureQueryStatusResultResponse, error)
	ResumeToken() (string, error)
}

type packetCaptureQueryStatusResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *packetCaptureQueryStatusResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *packetCaptureQueryStatusResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *packetCaptureQueryStatusResultPoller) FinalResponse(ctx context.Context) (*PacketCaptureQueryStatusResultResponse, error) {
	respType := &PacketCaptureQueryStatusResultResponse{PacketCaptureQueryStatusResult: &PacketCaptureQueryStatusResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PacketCaptureQueryStatusResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePacketCaptureQueryStatusResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *packetCaptureQueryStatusResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *packetCaptureQueryStatusResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PacketCaptureQueryStatusResultResponse, error) {
	respType := &PacketCaptureQueryStatusResultResponse{PacketCaptureQueryStatusResult: &PacketCaptureQueryStatusResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PacketCaptureQueryStatusResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PacketCaptureResultPoller provides polling facilities until the operation completes
type PacketCaptureResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PacketCaptureResultResponse, error)
	ResumeToken() (string, error)
}

type packetCaptureResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *packetCaptureResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *packetCaptureResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *packetCaptureResultPoller) FinalResponse(ctx context.Context) (*PacketCaptureResultResponse, error) {
	respType := &PacketCaptureResultResponse{PacketCaptureResult: &PacketCaptureResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PacketCaptureResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePacketCaptureResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *packetCaptureResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *packetCaptureResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PacketCaptureResultResponse, error) {
	respType := &PacketCaptureResultResponse{PacketCaptureResult: &PacketCaptureResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PacketCaptureResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateDNSZoneGroupPoller provides polling facilities until the operation completes
type PrivateDNSZoneGroupPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PrivateDNSZoneGroupResponse, error)
	ResumeToken() (string, error)
}

type privateDnsZoneGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *privateDnsZoneGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *privateDnsZoneGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *privateDnsZoneGroupPoller) FinalResponse(ctx context.Context) (*PrivateDNSZoneGroupResponse, error) {
	respType := &PrivateDNSZoneGroupResponse{PrivateDNSZoneGroup: &PrivateDNSZoneGroup{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateDNSZoneGroup)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePrivateDNSZoneGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *privateDnsZoneGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateDnsZoneGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PrivateDNSZoneGroupResponse, error) {
	respType := &PrivateDNSZoneGroupResponse{PrivateDNSZoneGroup: &PrivateDNSZoneGroup{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PrivateDNSZoneGroup)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateEndpointPoller provides polling facilities until the operation completes
type PrivateEndpointPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PrivateEndpointResponse, error)
	ResumeToken() (string, error)
}

type privateEndpointPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *privateEndpointPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *privateEndpointPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *privateEndpointPoller) FinalResponse(ctx context.Context) (*PrivateEndpointResponse, error) {
	respType := &PrivateEndpointResponse{PrivateEndpoint: &PrivateEndpoint{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateEndpoint)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePrivateEndpointPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *privateEndpointPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateEndpointPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PrivateEndpointResponse, error) {
	respType := &PrivateEndpointResponse{PrivateEndpoint: &PrivateEndpoint{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PrivateEndpoint)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateLinkServicePoller provides polling facilities until the operation completes
type PrivateLinkServicePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PrivateLinkServiceResponse, error)
	ResumeToken() (string, error)
}

type privateLinkServicePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *privateLinkServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *privateLinkServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *privateLinkServicePoller) FinalResponse(ctx context.Context) (*PrivateLinkServiceResponse, error) {
	respType := &PrivateLinkServiceResponse{PrivateLinkService: &PrivateLinkService{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateLinkService)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePrivateLinkServicePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *privateLinkServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateLinkServicePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PrivateLinkServiceResponse, error) {
	respType := &PrivateLinkServiceResponse{PrivateLinkService: &PrivateLinkService{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PrivateLinkService)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateLinkServiceVisibilityPoller provides polling facilities until the operation completes
type PrivateLinkServiceVisibilityPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PrivateLinkServiceVisibilityResponse, error)
	ResumeToken() (string, error)
}

type privateLinkServiceVisibilityPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *privateLinkServiceVisibilityPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *privateLinkServiceVisibilityPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *privateLinkServiceVisibilityPoller) FinalResponse(ctx context.Context) (*PrivateLinkServiceVisibilityResponse, error) {
	respType := &PrivateLinkServiceVisibilityResponse{PrivateLinkServiceVisibility: &PrivateLinkServiceVisibility{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateLinkServiceVisibility)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePrivateLinkServiceVisibilityPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *privateLinkServiceVisibilityPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateLinkServiceVisibilityPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PrivateLinkServiceVisibilityResponse, error) {
	respType := &PrivateLinkServiceVisibilityResponse{PrivateLinkServiceVisibility: &PrivateLinkServiceVisibility{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PrivateLinkServiceVisibility)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PublicIPAddressPoller provides polling facilities until the operation completes
type PublicIPAddressPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PublicIPAddressResponse, error)
	ResumeToken() (string, error)
}

type publicIPAddressPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *publicIPAddressPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *publicIPAddressPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *publicIPAddressPoller) FinalResponse(ctx context.Context) (*PublicIPAddressResponse, error) {
	respType := &PublicIPAddressResponse{PublicIPAddress: &PublicIPAddress{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PublicIPAddress)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePublicIPAddressPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *publicIPAddressPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *publicIPAddressPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PublicIPAddressResponse, error) {
	respType := &PublicIPAddressResponse{PublicIPAddress: &PublicIPAddress{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PublicIPAddress)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PublicIPPrefixPoller provides polling facilities until the operation completes
type PublicIPPrefixPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*PublicIPPrefixResponse, error)
	ResumeToken() (string, error)
}

type publicIPPrefixPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *publicIPPrefixPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *publicIPPrefixPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *publicIPPrefixPoller) FinalResponse(ctx context.Context) (*PublicIPPrefixResponse, error) {
	respType := &PublicIPPrefixResponse{PublicIPPrefix: &PublicIPPrefix{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PublicIPPrefix)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePublicIPPrefixPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *publicIPPrefixPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *publicIPPrefixPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*PublicIPPrefixResponse, error) {
	respType := &PublicIPPrefixResponse{PublicIPPrefix: &PublicIPPrefix{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PublicIPPrefix)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RouteFilterPoller provides polling facilities until the operation completes
type RouteFilterPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*RouteFilterResponse, error)
	ResumeToken() (string, error)
}

type routeFilterPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *routeFilterPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *routeFilterPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *routeFilterPoller) FinalResponse(ctx context.Context) (*RouteFilterResponse, error) {
	respType := &RouteFilterResponse{RouteFilter: &RouteFilter{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.RouteFilter)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeRouteFilterPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *routeFilterPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routeFilterPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*RouteFilterResponse, error) {
	respType := &RouteFilterResponse{RouteFilter: &RouteFilter{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.RouteFilter)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RouteFilterRulePoller provides polling facilities until the operation completes
type RouteFilterRulePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*RouteFilterRuleResponse, error)
	ResumeToken() (string, error)
}

type routeFilterRulePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *routeFilterRulePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *routeFilterRulePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *routeFilterRulePoller) FinalResponse(ctx context.Context) (*RouteFilterRuleResponse, error) {
	respType := &RouteFilterRuleResponse{RouteFilterRule: &RouteFilterRule{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.RouteFilterRule)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeRouteFilterRulePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *routeFilterRulePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routeFilterRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*RouteFilterRuleResponse, error) {
	respType := &RouteFilterRuleResponse{RouteFilterRule: &RouteFilterRule{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.RouteFilterRule)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RoutePoller provides polling facilities until the operation completes
type RoutePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*RouteResponse, error)
	ResumeToken() (string, error)
}

type routePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *routePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *routePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *routePoller) FinalResponse(ctx context.Context) (*RouteResponse, error) {
	respType := &RouteResponse{Route: &Route{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.Route)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeRoutePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *routePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*RouteResponse, error) {
	respType := &RouteResponse{Route: &Route{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.Route)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RouteTablePoller provides polling facilities until the operation completes
type RouteTablePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*RouteTableResponse, error)
	ResumeToken() (string, error)
}

type routeTablePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *routeTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *routeTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *routeTablePoller) FinalResponse(ctx context.Context) (*RouteTableResponse, error) {
	respType := &RouteTableResponse{RouteTable: &RouteTable{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.RouteTable)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeRouteTablePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *routeTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routeTablePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*RouteTableResponse, error) {
	respType := &RouteTableResponse{RouteTable: &RouteTable{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.RouteTable)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityGroupViewResultPoller provides polling facilities until the operation completes
type SecurityGroupViewResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*SecurityGroupViewResultResponse, error)
	ResumeToken() (string, error)
}

type securityGroupViewResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *securityGroupViewResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *securityGroupViewResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *securityGroupViewResultPoller) FinalResponse(ctx context.Context) (*SecurityGroupViewResultResponse, error) {
	respType := &SecurityGroupViewResultResponse{SecurityGroupViewResult: &SecurityGroupViewResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.SecurityGroupViewResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeSecurityGroupViewResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *securityGroupViewResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityGroupViewResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*SecurityGroupViewResultResponse, error) {
	respType := &SecurityGroupViewResultResponse{SecurityGroupViewResult: &SecurityGroupViewResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.SecurityGroupViewResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityPartnerProviderPoller provides polling facilities until the operation completes
type SecurityPartnerProviderPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*SecurityPartnerProviderResponse, error)
	ResumeToken() (string, error)
}

type securityPartnerProviderPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *securityPartnerProviderPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *securityPartnerProviderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *securityPartnerProviderPoller) FinalResponse(ctx context.Context) (*SecurityPartnerProviderResponse, error) {
	respType := &SecurityPartnerProviderResponse{SecurityPartnerProvider: &SecurityPartnerProvider{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.SecurityPartnerProvider)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeSecurityPartnerProviderPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *securityPartnerProviderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityPartnerProviderPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*SecurityPartnerProviderResponse, error) {
	respType := &SecurityPartnerProviderResponse{SecurityPartnerProvider: &SecurityPartnerProvider{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.SecurityPartnerProvider)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityRulePoller provides polling facilities until the operation completes
type SecurityRulePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*SecurityRuleResponse, error)
	ResumeToken() (string, error)
}

type securityRulePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *securityRulePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *securityRulePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *securityRulePoller) FinalResponse(ctx context.Context) (*SecurityRuleResponse, error) {
	respType := &SecurityRuleResponse{SecurityRule: &SecurityRule{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.SecurityRule)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeSecurityRulePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *securityRulePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*SecurityRuleResponse, error) {
	respType := &SecurityRuleResponse{SecurityRule: &SecurityRule{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.SecurityRule)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServiceEndpointPolicyDefinitionPoller provides polling facilities until the operation completes
type ServiceEndpointPolicyDefinitionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ServiceEndpointPolicyDefinitionResponse, error)
	ResumeToken() (string, error)
}

type serviceEndpointPolicyDefinitionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *serviceEndpointPolicyDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *serviceEndpointPolicyDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *serviceEndpointPolicyDefinitionPoller) FinalResponse(ctx context.Context) (*ServiceEndpointPolicyDefinitionResponse, error) {
	respType := &ServiceEndpointPolicyDefinitionResponse{ServiceEndpointPolicyDefinition: &ServiceEndpointPolicyDefinition{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ServiceEndpointPolicyDefinition)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeServiceEndpointPolicyDefinitionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *serviceEndpointPolicyDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serviceEndpointPolicyDefinitionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ServiceEndpointPolicyDefinitionResponse, error) {
	respType := &ServiceEndpointPolicyDefinitionResponse{ServiceEndpointPolicyDefinition: &ServiceEndpointPolicyDefinition{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ServiceEndpointPolicyDefinition)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServiceEndpointPolicyPoller provides polling facilities until the operation completes
type ServiceEndpointPolicyPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*ServiceEndpointPolicyResponse, error)
	ResumeToken() (string, error)
}

type serviceEndpointPolicyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *serviceEndpointPolicyPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *serviceEndpointPolicyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *serviceEndpointPolicyPoller) FinalResponse(ctx context.Context) (*ServiceEndpointPolicyResponse, error) {
	respType := &ServiceEndpointPolicyResponse{ServiceEndpointPolicy: &ServiceEndpointPolicy{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ServiceEndpointPolicy)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeServiceEndpointPolicyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *serviceEndpointPolicyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serviceEndpointPolicyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*ServiceEndpointPolicyResponse, error) {
	respType := &ServiceEndpointPolicyResponse{ServiceEndpointPolicy: &ServiceEndpointPolicy{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ServiceEndpointPolicy)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// StringPoller provides polling facilities until the operation completes
type StringPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*StringResponse, error)
	ResumeToken() (string, error)
}

type stringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *stringPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *stringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *stringPoller) FinalResponse(ctx context.Context) (*StringResponse, error) {
	respType := &StringResponse{}

	resp, err := p.pt.FinalResponse(ctx, p.pipeline, &respType.Value)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeStringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *stringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *stringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*StringResponse, error) {
	respType := &StringResponse{}

	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, &respType.Value)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SubnetPoller provides polling facilities until the operation completes
type SubnetPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*SubnetResponse, error)
	ResumeToken() (string, error)
}

type subnetPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *subnetPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *subnetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *subnetPoller) FinalResponse(ctx context.Context) (*SubnetResponse, error) {
	respType := &SubnetResponse{Subnet: &Subnet{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.Subnet)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeSubnetPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *subnetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *subnetPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*SubnetResponse, error) {
	respType := &SubnetResponse{Subnet: &Subnet{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.Subnet)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// TroubleshootingResultPoller provides polling facilities until the operation completes
type TroubleshootingResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*TroubleshootingResultResponse, error)
	ResumeToken() (string, error)
}

type troubleshootingResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *troubleshootingResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *troubleshootingResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *troubleshootingResultPoller) FinalResponse(ctx context.Context) (*TroubleshootingResultResponse, error) {
	respType := &TroubleshootingResultResponse{TroubleshootingResult: &TroubleshootingResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.TroubleshootingResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeTroubleshootingResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *troubleshootingResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *troubleshootingResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*TroubleshootingResultResponse, error) {
	respType := &TroubleshootingResultResponse{TroubleshootingResult: &TroubleshootingResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.TroubleshootingResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VerificationIPFlowResultPoller provides polling facilities until the operation completes
type VerificationIPFlowResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VerificationIPFlowResultResponse, error)
	ResumeToken() (string, error)
}

type verificationIPFlowResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *verificationIPFlowResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *verificationIPFlowResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *verificationIPFlowResultPoller) FinalResponse(ctx context.Context) (*VerificationIPFlowResultResponse, error) {
	respType := &VerificationIPFlowResultResponse{VerificationIPFlowResult: &VerificationIPFlowResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VerificationIPFlowResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVerificationIPFlowResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *verificationIPFlowResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *verificationIPFlowResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VerificationIPFlowResultResponse, error) {
	respType := &VerificationIPFlowResultResponse{VerificationIPFlowResult: &VerificationIPFlowResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VerificationIPFlowResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualHubPoller provides polling facilities until the operation completes
type VirtualHubPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualHubResponse, error)
	ResumeToken() (string, error)
}

type virtualHubPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualHubPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualHubPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualHubPoller) FinalResponse(ctx context.Context) (*VirtualHubResponse, error) {
	respType := &VirtualHubResponse{VirtualHub: &VirtualHub{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualHub)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualHubPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualHubPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualHubPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualHubResponse, error) {
	respType := &VirtualHubResponse{VirtualHub: &VirtualHub{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualHub)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualHubRouteTableV2Poller provides polling facilities until the operation completes
type VirtualHubRouteTableV2Poller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualHubRouteTableV2Response, error)
	ResumeToken() (string, error)
}

type virtualHubRouteTableV2Poller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualHubRouteTableV2Poller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualHubRouteTableV2Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualHubRouteTableV2Poller) FinalResponse(ctx context.Context) (*VirtualHubRouteTableV2Response, error) {
	respType := &VirtualHubRouteTableV2Response{VirtualHubRouteTableV2: &VirtualHubRouteTableV2{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualHubRouteTableV2)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualHubRouteTableV2Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualHubRouteTableV2Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualHubRouteTableV2Poller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualHubRouteTableV2Response, error) {
	respType := &VirtualHubRouteTableV2Response{VirtualHubRouteTableV2: &VirtualHubRouteTableV2{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualHubRouteTableV2)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewayConnectionPoller provides polling facilities until the operation completes
type VirtualNetworkGatewayConnectionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualNetworkGatewayConnectionResponse, error)
	ResumeToken() (string, error)
}

type virtualNetworkGatewayConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkGatewayConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkGatewayConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualNetworkGatewayConnectionPoller) FinalResponse(ctx context.Context) (*VirtualNetworkGatewayConnectionResponse, error) {
	respType := &VirtualNetworkGatewayConnectionResponse{VirtualNetworkGatewayConnection: &VirtualNetworkGatewayConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkGatewayConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkGatewayConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewayConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualNetworkGatewayConnectionResponse, error) {
	respType := &VirtualNetworkGatewayConnectionResponse{VirtualNetworkGatewayConnection: &VirtualNetworkGatewayConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewayPoller provides polling facilities until the operation completes
type VirtualNetworkGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualNetworkGatewayResponse, error)
	ResumeToken() (string, error)
}

type virtualNetworkGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualNetworkGatewayPoller) FinalResponse(ctx context.Context) (*VirtualNetworkGatewayResponse, error) {
	respType := &VirtualNetworkGatewayResponse{VirtualNetworkGateway: &VirtualNetworkGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetworkGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualNetworkGatewayResponse, error) {
	respType := &VirtualNetworkGatewayResponse{VirtualNetworkGateway: &VirtualNetworkGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetworkGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkPeeringPoller provides polling facilities until the operation completes
type VirtualNetworkPeeringPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualNetworkPeeringResponse, error)
	ResumeToken() (string, error)
}

type virtualNetworkPeeringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkPeeringPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualNetworkPeeringPoller) FinalResponse(ctx context.Context) (*VirtualNetworkPeeringResponse, error) {
	respType := &VirtualNetworkPeeringResponse{VirtualNetworkPeering: &VirtualNetworkPeering{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetworkPeering)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkPeeringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkPeeringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualNetworkPeeringResponse, error) {
	respType := &VirtualNetworkPeeringResponse{VirtualNetworkPeering: &VirtualNetworkPeering{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetworkPeering)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkPoller provides polling facilities until the operation completes
type VirtualNetworkPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualNetworkResponse, error)
	ResumeToken() (string, error)
}

type virtualNetworkPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualNetworkPoller) FinalResponse(ctx context.Context) (*VirtualNetworkResponse, error) {
	respType := &VirtualNetworkResponse{VirtualNetwork: &VirtualNetwork{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetwork)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualNetworkResponse, error) {
	respType := &VirtualNetworkResponse{VirtualNetwork: &VirtualNetwork{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetwork)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkTapPoller provides polling facilities until the operation completes
type VirtualNetworkTapPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualNetworkTapResponse, error)
	ResumeToken() (string, error)
}

type virtualNetworkTapPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkTapPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkTapPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualNetworkTapPoller) FinalResponse(ctx context.Context) (*VirtualNetworkTapResponse, error) {
	respType := &VirtualNetworkTapResponse{VirtualNetworkTap: &VirtualNetworkTap{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetworkTap)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkTapPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkTapPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkTapPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualNetworkTapResponse, error) {
	respType := &VirtualNetworkTapResponse{VirtualNetworkTap: &VirtualNetworkTap{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetworkTap)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualRouterPeeringPoller provides polling facilities until the operation completes
type VirtualRouterPeeringPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualRouterPeeringResponse, error)
	ResumeToken() (string, error)
}

type virtualRouterPeeringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualRouterPeeringPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualRouterPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualRouterPeeringPoller) FinalResponse(ctx context.Context) (*VirtualRouterPeeringResponse, error) {
	respType := &VirtualRouterPeeringResponse{VirtualRouterPeering: &VirtualRouterPeering{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualRouterPeering)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualRouterPeeringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualRouterPeeringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualRouterPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualRouterPeeringResponse, error) {
	respType := &VirtualRouterPeeringResponse{VirtualRouterPeering: &VirtualRouterPeering{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualRouterPeering)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualRouterPoller provides polling facilities until the operation completes
type VirtualRouterPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualRouterResponse, error)
	ResumeToken() (string, error)
}

type virtualRouterPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualRouterPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualRouterPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualRouterPoller) FinalResponse(ctx context.Context) (*VirtualRouterResponse, error) {
	respType := &VirtualRouterResponse{VirtualRouter: &VirtualRouter{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualRouter)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualRouterPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualRouterPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualRouterPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualRouterResponse, error) {
	respType := &VirtualRouterResponse{VirtualRouter: &VirtualRouter{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualRouter)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualWanPoller provides polling facilities until the operation completes
type VirtualWanPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VirtualWanResponse, error)
	ResumeToken() (string, error)
}

type virtualWanPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualWanPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualWanPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualWanPoller) FinalResponse(ctx context.Context) (*VirtualWanResponse, error) {
	respType := &VirtualWanResponse{VirtualWan: &VirtualWan{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualWan)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualWanPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualWanPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualWanPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VirtualWanResponse, error) {
	respType := &VirtualWanResponse{VirtualWan: &VirtualWan{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualWan)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VpnClientConnectionHealthDetailListResultPoller provides polling facilities until the operation completes
type VpnClientConnectionHealthDetailListResultPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnClientConnectionHealthDetailListResultResponse, error)
	ResumeToken() (string, error)
}

type vpnClientConnectionHealthDetailListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnClientConnectionHealthDetailListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnClientConnectionHealthDetailListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnClientConnectionHealthDetailListResultPoller) FinalResponse(ctx context.Context) (*VpnClientConnectionHealthDetailListResultResponse, error) {
	respType := &VpnClientConnectionHealthDetailListResultResponse{VpnClientConnectionHealthDetailListResult: &VpnClientConnectionHealthDetailListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VpnClientConnectionHealthDetailListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVpnClientConnectionHealthDetailListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnClientConnectionHealthDetailListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnClientConnectionHealthDetailListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnClientConnectionHealthDetailListResultResponse, error) {
	respType := &VpnClientConnectionHealthDetailListResultResponse{VpnClientConnectionHealthDetailListResult: &VpnClientConnectionHealthDetailListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VpnClientConnectionHealthDetailListResult)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VpnClientIPsecParametersPoller provides polling facilities until the operation completes
type VpnClientIPsecParametersPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnClientIPsecParametersResponse, error)
	ResumeToken() (string, error)
}

type vpnClientIPsecParametersPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnClientIPsecParametersPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnClientIPsecParametersPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnClientIPsecParametersPoller) FinalResponse(ctx context.Context) (*VpnClientIPsecParametersResponse, error) {
	respType := &VpnClientIPsecParametersResponse{VpnClientIPsecParameters: &VpnClientIPsecParameters{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VpnClientIPsecParameters)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVpnClientIPsecParametersPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnClientIPsecParametersPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnClientIPsecParametersPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnClientIPsecParametersResponse, error) {
	respType := &VpnClientIPsecParametersResponse{VpnClientIPsecParameters: &VpnClientIPsecParameters{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VpnClientIPsecParameters)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VpnConnectionPoller provides polling facilities until the operation completes
type VpnConnectionPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnConnectionResponse, error)
	ResumeToken() (string, error)
}

type vpnConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnConnectionPoller) FinalResponse(ctx context.Context) (*VpnConnectionResponse, error) {
	respType := &VpnConnectionResponse{VpnConnection: &VpnConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VpnConnection)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVpnConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnConnectionResponse, error) {
	respType := &VpnConnectionResponse{VpnConnection: &VpnConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VpnConnection)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VpnGatewayPoller provides polling facilities until the operation completes
type VpnGatewayPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnGatewayResponse, error)
	ResumeToken() (string, error)
}

type vpnGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnGatewayPoller) FinalResponse(ctx context.Context) (*VpnGatewayResponse, error) {
	respType := &VpnGatewayResponse{VpnGateway: &VpnGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VpnGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVpnGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnGatewayResponse, error) {
	respType := &VpnGatewayResponse{VpnGateway: &VpnGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VpnGateway)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VpnProfileResponsePoller provides polling facilities until the operation completes
type VpnProfileResponsePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnProfileResponseResponse, error)
	ResumeToken() (string, error)
}

type vpnProfileResponsePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnProfileResponsePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnProfileResponsePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnProfileResponsePoller) FinalResponse(ctx context.Context) (*VpnProfileResponseResponse, error) {
	respType := &VpnProfileResponseResponse{VpnProfileResponse: &VpnProfileResponse{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VpnProfileResponse)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVpnProfileResponsePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnProfileResponsePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnProfileResponsePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnProfileResponseResponse, error) {
	respType := &VpnProfileResponseResponse{VpnProfileResponse: &VpnProfileResponse{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VpnProfileResponse)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VpnServerConfigurationPoller provides polling facilities until the operation completes
type VpnServerConfigurationPoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnServerConfigurationResponse, error)
	ResumeToken() (string, error)
}

type vpnServerConfigurationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnServerConfigurationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnServerConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnServerConfigurationPoller) FinalResponse(ctx context.Context) (*VpnServerConfigurationResponse, error) {
	respType := &VpnServerConfigurationResponse{VpnServerConfiguration: &VpnServerConfiguration{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VpnServerConfiguration)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVpnServerConfigurationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnServerConfigurationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnServerConfigurationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnServerConfigurationResponse, error) {
	respType := &VpnServerConfigurationResponse{VpnServerConfiguration: &VpnServerConfiguration{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VpnServerConfiguration)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VpnServerConfigurationsResponsePoller provides polling facilities until the operation completes
type VpnServerConfigurationsResponsePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnServerConfigurationsResponseResponse, error)
	ResumeToken() (string, error)
}

type vpnServerConfigurationsResponsePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnServerConfigurationsResponsePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnServerConfigurationsResponsePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnServerConfigurationsResponsePoller) FinalResponse(ctx context.Context) (*VpnServerConfigurationsResponseResponse, error) {
	respType := &VpnServerConfigurationsResponseResponse{VpnServerConfigurationsResponse: &VpnServerConfigurationsResponse{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VpnServerConfigurationsResponse)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVpnServerConfigurationsResponsePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnServerConfigurationsResponsePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnServerConfigurationsResponsePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnServerConfigurationsResponseResponse, error) {
	respType := &VpnServerConfigurationsResponseResponse{VpnServerConfigurationsResponse: &VpnServerConfigurationsResponse{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VpnServerConfigurationsResponse)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VpnSitePoller provides polling facilities until the operation completes
type VpnSitePoller interface {
	Done() bool
	Poll(ctx context.Context) (*http.Response, error)
	FinalResponse(ctx context.Context) (*VpnSiteResponse, error)
	ResumeToken() (string, error)
}

type vpnSitePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnSitePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnSitePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnSitePoller) FinalResponse(ctx context.Context) (*VpnSiteResponse, error) {
	respType := &VpnSiteResponse{VpnSite: &VpnSite{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VpnSite)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVpnSitePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnSitePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnSitePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*VpnSiteResponse, error) {
	respType := &VpnSiteResponse{VpnSite: &VpnSite{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VpnSite)
	if err != nil {
		return nil, err
	}
	respType.RawResponse = resp
	return respType, nil
}
