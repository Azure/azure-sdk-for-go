// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// ApplicationGatewayBackendHealthOnDemandPoller provides polling facilities until the operation completes
type ApplicationGatewayBackendHealthOnDemandPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationGatewayBackendHealthOnDemandResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationGatewayBackendHealthOnDemandResponse, error)
}

type applicationGatewayBackendHealthOnDemandPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationGatewayBackendHealthOnDemandPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationGatewayBackendHealthOnDemandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *applicationGatewayBackendHealthOnDemandPoller) FinalResponse(ctx context.Context) (ApplicationGatewayBackendHealthOnDemandResponse, error) {
	respType := ApplicationGatewayBackendHealthOnDemandResponse{ApplicationGatewayBackendHealthOnDemand: &ApplicationGatewayBackendHealthOnDemand{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationGatewayBackendHealthOnDemand)
	if err != nil {
		return ApplicationGatewayBackendHealthOnDemandResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeApplicationGatewayBackendHealthOnDemandPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationGatewayBackendHealthOnDemandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewayBackendHealthOnDemandPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ApplicationGatewayBackendHealthOnDemandResponse, error) {
	respType := ApplicationGatewayBackendHealthOnDemandResponse{ApplicationGatewayBackendHealthOnDemand: &ApplicationGatewayBackendHealthOnDemand{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationGatewayBackendHealthOnDemand)
	if err != nil {
		return ApplicationGatewayBackendHealthOnDemandResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationGatewayBackendHealthPoller provides polling facilities until the operation completes
type ApplicationGatewayBackendHealthPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationGatewayBackendHealthResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationGatewayBackendHealthResponse, error)
}

type applicationGatewayBackendHealthPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationGatewayBackendHealthPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationGatewayBackendHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *applicationGatewayBackendHealthPoller) FinalResponse(ctx context.Context) (ApplicationGatewayBackendHealthResponse, error) {
	respType := ApplicationGatewayBackendHealthResponse{ApplicationGatewayBackendHealth: &ApplicationGatewayBackendHealth{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationGatewayBackendHealth)
	if err != nil {
		return ApplicationGatewayBackendHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeApplicationGatewayBackendHealthPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationGatewayBackendHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewayBackendHealthPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ApplicationGatewayBackendHealthResponse, error) {
	respType := ApplicationGatewayBackendHealthResponse{ApplicationGatewayBackendHealth: &ApplicationGatewayBackendHealth{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationGatewayBackendHealth)
	if err != nil {
		return ApplicationGatewayBackendHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationGatewayPoller provides polling facilities until the operation completes
type ApplicationGatewayPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationGatewayResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationGatewayResponse, error)
}

type applicationGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *applicationGatewayPoller) FinalResponse(ctx context.Context) (ApplicationGatewayResponse, error) {
	respType := ApplicationGatewayResponse{ApplicationGateway: &ApplicationGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationGateway)
	if err != nil {
		return ApplicationGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeApplicationGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ApplicationGatewayResponse, error) {
	respType := ApplicationGatewayResponse{ApplicationGateway: &ApplicationGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationGateway)
	if err != nil {
		return ApplicationGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationGatewayPrivateEndpointConnectionPoller provides polling facilities until the operation completes
type ApplicationGatewayPrivateEndpointConnectionPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationGatewayPrivateEndpointConnectionResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationGatewayPrivateEndpointConnectionResponse, error)
}

type applicationGatewayPrivateEndpointConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationGatewayPrivateEndpointConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationGatewayPrivateEndpointConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *applicationGatewayPrivateEndpointConnectionPoller) FinalResponse(ctx context.Context) (ApplicationGatewayPrivateEndpointConnectionResponse, error) {
	respType := ApplicationGatewayPrivateEndpointConnectionResponse{ApplicationGatewayPrivateEndpointConnection: &ApplicationGatewayPrivateEndpointConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationGatewayPrivateEndpointConnection)
	if err != nil {
		return ApplicationGatewayPrivateEndpointConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeApplicationGatewayPrivateEndpointConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationGatewayPrivateEndpointConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewayPrivateEndpointConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ApplicationGatewayPrivateEndpointConnectionResponse, error) {
	respType := ApplicationGatewayPrivateEndpointConnectionResponse{ApplicationGatewayPrivateEndpointConnection: &ApplicationGatewayPrivateEndpointConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationGatewayPrivateEndpointConnection)
	if err != nil {
		return ApplicationGatewayPrivateEndpointConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationSecurityGroupPoller provides polling facilities until the operation completes
type ApplicationSecurityGroupPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationSecurityGroupResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationSecurityGroupResponse, error)
}

type applicationSecurityGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *applicationSecurityGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *applicationSecurityGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *applicationSecurityGroupPoller) FinalResponse(ctx context.Context) (ApplicationSecurityGroupResponse, error) {
	respType := ApplicationSecurityGroupResponse{ApplicationSecurityGroup: &ApplicationSecurityGroup{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationSecurityGroup)
	if err != nil {
		return ApplicationSecurityGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeApplicationSecurityGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *applicationSecurityGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationSecurityGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ApplicationSecurityGroupResponse, error) {
	respType := ApplicationSecurityGroupResponse{ApplicationSecurityGroup: &ApplicationSecurityGroup{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationSecurityGroup)
	if err != nil {
		return ApplicationSecurityGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AvailableProvidersListPoller provides polling facilities until the operation completes
type AvailableProvidersListPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AvailableProvidersListResponse will be returned.
	FinalResponse(ctx context.Context) (AvailableProvidersListResponse, error)
}

type availableProvidersListPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *availableProvidersListPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *availableProvidersListPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *availableProvidersListPoller) FinalResponse(ctx context.Context) (AvailableProvidersListResponse, error) {
	respType := AvailableProvidersListResponse{AvailableProvidersList: &AvailableProvidersList{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.AvailableProvidersList)
	if err != nil {
		return AvailableProvidersListResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeAvailableProvidersListPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *availableProvidersListPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *availableProvidersListPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (AvailableProvidersListResponse, error) {
	respType := AvailableProvidersListResponse{AvailableProvidersList: &AvailableProvidersList{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.AvailableProvidersList)
	if err != nil {
		return AvailableProvidersListResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AzureFirewallPoller provides polling facilities until the operation completes
type AzureFirewallPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AzureFirewallResponse will be returned.
	FinalResponse(ctx context.Context) (AzureFirewallResponse, error)
}

type azureFirewallPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *azureFirewallPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *azureFirewallPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *azureFirewallPoller) FinalResponse(ctx context.Context) (AzureFirewallResponse, error) {
	respType := AzureFirewallResponse{AzureFirewall: &AzureFirewall{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.AzureFirewall)
	if err != nil {
		return AzureFirewallResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeAzureFirewallPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *azureFirewallPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *azureFirewallPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (AzureFirewallResponse, error) {
	respType := AzureFirewallResponse{AzureFirewall: &AzureFirewall{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.AzureFirewall)
	if err != nil {
		return AzureFirewallResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AzureReachabilityReportPoller provides polling facilities until the operation completes
type AzureReachabilityReportPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AzureReachabilityReportResponse will be returned.
	FinalResponse(ctx context.Context) (AzureReachabilityReportResponse, error)
}

type azureReachabilityReportPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *azureReachabilityReportPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *azureReachabilityReportPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *azureReachabilityReportPoller) FinalResponse(ctx context.Context) (AzureReachabilityReportResponse, error) {
	respType := AzureReachabilityReportResponse{AzureReachabilityReport: &AzureReachabilityReport{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.AzureReachabilityReport)
	if err != nil {
		return AzureReachabilityReportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeAzureReachabilityReportPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *azureReachabilityReportPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *azureReachabilityReportPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (AzureReachabilityReportResponse, error) {
	respType := AzureReachabilityReportResponse{AzureReachabilityReport: &AzureReachabilityReport{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.AzureReachabilityReport)
	if err != nil {
		return AzureReachabilityReportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// BackendAddressPoolPoller provides polling facilities until the operation completes
type BackendAddressPoolPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BackendAddressPoolResponse will be returned.
	FinalResponse(ctx context.Context) (BackendAddressPoolResponse, error)
}

type backendAddressPoolPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *backendAddressPoolPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *backendAddressPoolPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *backendAddressPoolPoller) FinalResponse(ctx context.Context) (BackendAddressPoolResponse, error) {
	respType := BackendAddressPoolResponse{BackendAddressPool: &BackendAddressPool{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.BackendAddressPool)
	if err != nil {
		return BackendAddressPoolResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeBackendAddressPoolPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *backendAddressPoolPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *backendAddressPoolPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BackendAddressPoolResponse, error) {
	respType := BackendAddressPoolResponse{BackendAddressPool: &BackendAddressPool{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.BackendAddressPool)
	if err != nil {
		return BackendAddressPoolResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// BastionActiveSessionListResultPagerPoller provides polling facilities until the operation completes
type BastionActiveSessionListResultPagerPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BastionActiveSessionListResultPager will be returned.
	FinalResponse(ctx context.Context) (BastionActiveSessionListResultPager, error)
}

type bastionActiveSessionListResultPagerPoller struct {
	// the client for making the request
	pipeline    azcore.Pipeline
	errHandler  bastionActiveSessionListResultHandleError
	respHandler bastionActiveSessionListResultHandleResponse
	statusCodes []int
	pt          armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bastionActiveSessionListResultPagerPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bastionActiveSessionListResultPagerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *bastionActiveSessionListResultPagerPoller) FinalResponse(ctx context.Context) (BastionActiveSessionListResultPager, error) {
	respType := &bastionActiveSessionListResultPager{}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(&azcore.Response{Response: resp})
}

// ResumeToken generates the string token that can be used with the ResumeBastionActiveSessionListResultPagerPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bastionActiveSessionListResultPagerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bastionActiveSessionListResultPagerPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BastionActiveSessionListResultPager, error) {
	respType := &bastionActiveSessionListResultPager{}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(&azcore.Response{Response: resp})
}

func (p *bastionActiveSessionListResultPagerPoller) handleResponse(resp *azcore.Response) (BastionActiveSessionListResultPager, error) {
	return &bastionActiveSessionListResultPager{
		pipeline:  p.pipeline,
		resp:      resp,
		errorer:   p.errHandler,
		responder: p.respHandler,
		advancer: func(ctx context.Context, resp BastionActiveSessionListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.BastionActiveSessionListResult.NextLink)
		},
		statusCodes: p.statusCodes,
	}, nil
}

// BastionHostPoller provides polling facilities until the operation completes
type BastionHostPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BastionHostResponse will be returned.
	FinalResponse(ctx context.Context) (BastionHostResponse, error)
}

type bastionHostPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bastionHostPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bastionHostPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *bastionHostPoller) FinalResponse(ctx context.Context) (BastionHostResponse, error) {
	respType := BastionHostResponse{BastionHost: &BastionHost{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.BastionHost)
	if err != nil {
		return BastionHostResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeBastionHostPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bastionHostPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bastionHostPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BastionHostResponse, error) {
	respType := BastionHostResponse{BastionHost: &BastionHost{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.BastionHost)
	if err != nil {
		return BastionHostResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// BastionShareableLinkListResultPagerPoller provides polling facilities until the operation completes
type BastionShareableLinkListResultPagerPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BastionShareableLinkListResultPager will be returned.
	FinalResponse(ctx context.Context) (BastionShareableLinkListResultPager, error)
}

type bastionShareableLinkListResultPagerPoller struct {
	// the client for making the request
	pipeline    azcore.Pipeline
	errHandler  bastionShareableLinkListResultHandleError
	respHandler bastionShareableLinkListResultHandleResponse
	statusCodes []int
	pt          armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bastionShareableLinkListResultPagerPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bastionShareableLinkListResultPagerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *bastionShareableLinkListResultPagerPoller) FinalResponse(ctx context.Context) (BastionShareableLinkListResultPager, error) {
	respType := &bastionShareableLinkListResultPager{}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(&azcore.Response{Response: resp})
}

// ResumeToken generates the string token that can be used with the ResumeBastionShareableLinkListResultPagerPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bastionShareableLinkListResultPagerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bastionShareableLinkListResultPagerPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BastionShareableLinkListResultPager, error) {
	respType := &bastionShareableLinkListResultPager{}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType)
	if err != nil {
		return nil, err
	}
	return p.handleResponse(&azcore.Response{Response: resp})
}

func (p *bastionShareableLinkListResultPagerPoller) handleResponse(resp *azcore.Response) (BastionShareableLinkListResultPager, error) {
	return &bastionShareableLinkListResultPager{
		pipeline:  p.pipeline,
		resp:      resp,
		errorer:   p.errHandler,
		responder: p.respHandler,
		advancer: func(ctx context.Context, resp BastionShareableLinkListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.BastionShareableLinkListResult.NextLink)
		},
		statusCodes: p.statusCodes,
	}, nil
}

// BgpConnectionPoller provides polling facilities until the operation completes
type BgpConnectionPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BgpConnectionResponse will be returned.
	FinalResponse(ctx context.Context) (BgpConnectionResponse, error)
}

type bgpConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bgpConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bgpConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *bgpConnectionPoller) FinalResponse(ctx context.Context) (BgpConnectionResponse, error) {
	respType := BgpConnectionResponse{BgpConnection: &BgpConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.BgpConnection)
	if err != nil {
		return BgpConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeBgpConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bgpConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bgpConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BgpConnectionResponse, error) {
	respType := BgpConnectionResponse{BgpConnection: &BgpConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.BgpConnection)
	if err != nil {
		return BgpConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// BgpPeerStatusListResultPoller provides polling facilities until the operation completes
type BgpPeerStatusListResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BgpPeerStatusListResultResponse will be returned.
	FinalResponse(ctx context.Context) (BgpPeerStatusListResultResponse, error)
}

type bgpPeerStatusListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *bgpPeerStatusListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *bgpPeerStatusListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *bgpPeerStatusListResultPoller) FinalResponse(ctx context.Context) (BgpPeerStatusListResultResponse, error) {
	respType := BgpPeerStatusListResultResponse{BgpPeerStatusListResult: &BgpPeerStatusListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.BgpPeerStatusListResult)
	if err != nil {
		return BgpPeerStatusListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeBgpPeerStatusListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *bgpPeerStatusListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bgpPeerStatusListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BgpPeerStatusListResultResponse, error) {
	respType := BgpPeerStatusListResultResponse{BgpPeerStatusListResult: &BgpPeerStatusListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.BgpPeerStatusListResult)
	if err != nil {
		return BgpPeerStatusListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionMonitorQueryResultPoller provides polling facilities until the operation completes
type ConnectionMonitorQueryResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConnectionMonitorQueryResultResponse will be returned.
	FinalResponse(ctx context.Context) (ConnectionMonitorQueryResultResponse, error)
}

type connectionMonitorQueryResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectionMonitorQueryResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectionMonitorQueryResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *connectionMonitorQueryResultPoller) FinalResponse(ctx context.Context) (ConnectionMonitorQueryResultResponse, error) {
	respType := ConnectionMonitorQueryResultResponse{ConnectionMonitorQueryResult: &ConnectionMonitorQueryResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectionMonitorQueryResult)
	if err != nil {
		return ConnectionMonitorQueryResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeConnectionMonitorQueryResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectionMonitorQueryResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionMonitorQueryResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ConnectionMonitorQueryResultResponse, error) {
	respType := ConnectionMonitorQueryResultResponse{ConnectionMonitorQueryResult: &ConnectionMonitorQueryResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectionMonitorQueryResult)
	if err != nil {
		return ConnectionMonitorQueryResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionMonitorResultPoller provides polling facilities until the operation completes
type ConnectionMonitorResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConnectionMonitorResultResponse will be returned.
	FinalResponse(ctx context.Context) (ConnectionMonitorResultResponse, error)
}

type connectionMonitorResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectionMonitorResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectionMonitorResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *connectionMonitorResultPoller) FinalResponse(ctx context.Context) (ConnectionMonitorResultResponse, error) {
	respType := ConnectionMonitorResultResponse{ConnectionMonitorResult: &ConnectionMonitorResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectionMonitorResult)
	if err != nil {
		return ConnectionMonitorResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeConnectionMonitorResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectionMonitorResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionMonitorResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ConnectionMonitorResultResponse, error) {
	respType := ConnectionMonitorResultResponse{ConnectionMonitorResult: &ConnectionMonitorResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectionMonitorResult)
	if err != nil {
		return ConnectionMonitorResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionResetSharedKeyPoller provides polling facilities until the operation completes
type ConnectionResetSharedKeyPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConnectionResetSharedKeyResponse will be returned.
	FinalResponse(ctx context.Context) (ConnectionResetSharedKeyResponse, error)
}

type connectionResetSharedKeyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectionResetSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectionResetSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *connectionResetSharedKeyPoller) FinalResponse(ctx context.Context) (ConnectionResetSharedKeyResponse, error) {
	respType := ConnectionResetSharedKeyResponse{ConnectionResetSharedKey: &ConnectionResetSharedKey{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectionResetSharedKey)
	if err != nil {
		return ConnectionResetSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeConnectionResetSharedKeyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectionResetSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionResetSharedKeyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ConnectionResetSharedKeyResponse, error) {
	respType := ConnectionResetSharedKeyResponse{ConnectionResetSharedKey: &ConnectionResetSharedKey{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectionResetSharedKey)
	if err != nil {
		return ConnectionResetSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionSharedKeyPoller provides polling facilities until the operation completes
type ConnectionSharedKeyPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConnectionSharedKeyResponse will be returned.
	FinalResponse(ctx context.Context) (ConnectionSharedKeyResponse, error)
}

type connectionSharedKeyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectionSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectionSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *connectionSharedKeyPoller) FinalResponse(ctx context.Context) (ConnectionSharedKeyResponse, error) {
	respType := ConnectionSharedKeyResponse{ConnectionSharedKey: &ConnectionSharedKey{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectionSharedKey)
	if err != nil {
		return ConnectionSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeConnectionSharedKeyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectionSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionSharedKeyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ConnectionSharedKeyResponse, error) {
	respType := ConnectionSharedKeyResponse{ConnectionSharedKey: &ConnectionSharedKey{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectionSharedKey)
	if err != nil {
		return ConnectionSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectivityInformationPoller provides polling facilities until the operation completes
type ConnectivityInformationPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConnectivityInformationResponse will be returned.
	FinalResponse(ctx context.Context) (ConnectivityInformationResponse, error)
}

type connectivityInformationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *connectivityInformationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *connectivityInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *connectivityInformationPoller) FinalResponse(ctx context.Context) (ConnectivityInformationResponse, error) {
	respType := ConnectivityInformationResponse{ConnectivityInformation: &ConnectivityInformation{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectivityInformation)
	if err != nil {
		return ConnectivityInformationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeConnectivityInformationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *connectivityInformationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectivityInformationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ConnectivityInformationResponse, error) {
	respType := ConnectivityInformationResponse{ConnectivityInformation: &ConnectivityInformation{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectivityInformation)
	if err != nil {
		return ConnectivityInformationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CustomIPPrefixPoller provides polling facilities until the operation completes
type CustomIPPrefixPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CustomIPPrefixResponse will be returned.
	FinalResponse(ctx context.Context) (CustomIPPrefixResponse, error)
}

type customIPPrefixPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *customIPPrefixPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *customIPPrefixPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *customIPPrefixPoller) FinalResponse(ctx context.Context) (CustomIPPrefixResponse, error) {
	respType := CustomIPPrefixResponse{CustomIPPrefix: &CustomIPPrefix{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.CustomIPPrefix)
	if err != nil {
		return CustomIPPrefixResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeCustomIPPrefixPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *customIPPrefixPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *customIPPrefixPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (CustomIPPrefixResponse, error) {
	respType := CustomIPPrefixResponse{CustomIPPrefix: &CustomIPPrefix{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.CustomIPPrefix)
	if err != nil {
		return CustomIPPrefixResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DdosCustomPolicyPoller provides polling facilities until the operation completes
type DdosCustomPolicyPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DdosCustomPolicyResponse will be returned.
	FinalResponse(ctx context.Context) (DdosCustomPolicyResponse, error)
}

type ddosCustomPolicyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *ddosCustomPolicyPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *ddosCustomPolicyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *ddosCustomPolicyPoller) FinalResponse(ctx context.Context) (DdosCustomPolicyResponse, error) {
	respType := DdosCustomPolicyResponse{DdosCustomPolicy: &DdosCustomPolicy{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.DdosCustomPolicy)
	if err != nil {
		return DdosCustomPolicyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeDdosCustomPolicyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *ddosCustomPolicyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ddosCustomPolicyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (DdosCustomPolicyResponse, error) {
	respType := DdosCustomPolicyResponse{DdosCustomPolicy: &DdosCustomPolicy{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.DdosCustomPolicy)
	if err != nil {
		return DdosCustomPolicyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DdosProtectionPlanPoller provides polling facilities until the operation completes
type DdosProtectionPlanPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DdosProtectionPlanResponse will be returned.
	FinalResponse(ctx context.Context) (DdosProtectionPlanResponse, error)
}

type ddosProtectionPlanPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *ddosProtectionPlanPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *ddosProtectionPlanPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *ddosProtectionPlanPoller) FinalResponse(ctx context.Context) (DdosProtectionPlanResponse, error) {
	respType := DdosProtectionPlanResponse{DdosProtectionPlan: &DdosProtectionPlan{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.DdosProtectionPlan)
	if err != nil {
		return DdosProtectionPlanResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeDdosProtectionPlanPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *ddosProtectionPlanPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ddosProtectionPlanPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (DdosProtectionPlanResponse, error) {
	respType := DdosProtectionPlanResponse{DdosProtectionPlan: &DdosProtectionPlan{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.DdosProtectionPlan)
	if err != nil {
		return DdosProtectionPlanResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DscpConfigurationPoller provides polling facilities until the operation completes
type DscpConfigurationPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DscpConfigurationResponse will be returned.
	FinalResponse(ctx context.Context) (DscpConfigurationResponse, error)
}

type dscpConfigurationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *dscpConfigurationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *dscpConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *dscpConfigurationPoller) FinalResponse(ctx context.Context) (DscpConfigurationResponse, error) {
	respType := DscpConfigurationResponse{DscpConfiguration: &DscpConfiguration{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.DscpConfiguration)
	if err != nil {
		return DscpConfigurationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeDscpConfigurationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *dscpConfigurationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *dscpConfigurationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (DscpConfigurationResponse, error) {
	respType := DscpConfigurationResponse{DscpConfiguration: &DscpConfiguration{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.DscpConfiguration)
	if err != nil {
		return DscpConfigurationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EffectiveNetworkSecurityGroupListResultPoller provides polling facilities until the operation completes
type EffectiveNetworkSecurityGroupListResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EffectiveNetworkSecurityGroupListResultResponse will be returned.
	FinalResponse(ctx context.Context) (EffectiveNetworkSecurityGroupListResultResponse, error)
}

type effectiveNetworkSecurityGroupListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *effectiveNetworkSecurityGroupListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *effectiveNetworkSecurityGroupListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *effectiveNetworkSecurityGroupListResultPoller) FinalResponse(ctx context.Context) (EffectiveNetworkSecurityGroupListResultResponse, error) {
	respType := EffectiveNetworkSecurityGroupListResultResponse{EffectiveNetworkSecurityGroupListResult: &EffectiveNetworkSecurityGroupListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.EffectiveNetworkSecurityGroupListResult)
	if err != nil {
		return EffectiveNetworkSecurityGroupListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeEffectiveNetworkSecurityGroupListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *effectiveNetworkSecurityGroupListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *effectiveNetworkSecurityGroupListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (EffectiveNetworkSecurityGroupListResultResponse, error) {
	respType := EffectiveNetworkSecurityGroupListResultResponse{EffectiveNetworkSecurityGroupListResult: &EffectiveNetworkSecurityGroupListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.EffectiveNetworkSecurityGroupListResult)
	if err != nil {
		return EffectiveNetworkSecurityGroupListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EffectiveRouteListResultPoller provides polling facilities until the operation completes
type EffectiveRouteListResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EffectiveRouteListResultResponse will be returned.
	FinalResponse(ctx context.Context) (EffectiveRouteListResultResponse, error)
}

type effectiveRouteListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *effectiveRouteListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *effectiveRouteListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *effectiveRouteListResultPoller) FinalResponse(ctx context.Context) (EffectiveRouteListResultResponse, error) {
	respType := EffectiveRouteListResultResponse{EffectiveRouteListResult: &EffectiveRouteListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.EffectiveRouteListResult)
	if err != nil {
		return EffectiveRouteListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeEffectiveRouteListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *effectiveRouteListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *effectiveRouteListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (EffectiveRouteListResultResponse, error) {
	respType := EffectiveRouteListResultResponse{EffectiveRouteListResult: &EffectiveRouteListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.EffectiveRouteListResult)
	if err != nil {
		return EffectiveRouteListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitAuthorizationPoller provides polling facilities until the operation completes
type ExpressRouteCircuitAuthorizationPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitAuthorizationResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitAuthorizationResponse, error)
}

type expressRouteCircuitAuthorizationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitAuthorizationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitAuthorizationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitAuthorizationPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitAuthorizationResponse, error) {
	respType := ExpressRouteCircuitAuthorizationResponse{ExpressRouteCircuitAuthorization: &ExpressRouteCircuitAuthorization{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitAuthorization)
	if err != nil {
		return ExpressRouteCircuitAuthorizationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitAuthorizationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitAuthorizationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitAuthorizationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitAuthorizationResponse, error) {
	respType := ExpressRouteCircuitAuthorizationResponse{ExpressRouteCircuitAuthorization: &ExpressRouteCircuitAuthorization{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitAuthorization)
	if err != nil {
		return ExpressRouteCircuitAuthorizationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitConnectionPoller provides polling facilities until the operation completes
type ExpressRouteCircuitConnectionPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitConnectionResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitConnectionResponse, error)
}

type expressRouteCircuitConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitConnectionPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitConnectionResponse, error) {
	respType := ExpressRouteCircuitConnectionResponse{ExpressRouteCircuitConnection: &ExpressRouteCircuitConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitConnection)
	if err != nil {
		return ExpressRouteCircuitConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitConnectionResponse, error) {
	respType := ExpressRouteCircuitConnectionResponse{ExpressRouteCircuitConnection: &ExpressRouteCircuitConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitConnection)
	if err != nil {
		return ExpressRouteCircuitConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitPeeringPoller provides polling facilities until the operation completes
type ExpressRouteCircuitPeeringPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitPeeringResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitPeeringResponse, error)
}

type expressRouteCircuitPeeringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitPeeringPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitPeeringPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitPeeringResponse, error) {
	respType := ExpressRouteCircuitPeeringResponse{ExpressRouteCircuitPeering: &ExpressRouteCircuitPeering{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitPeering)
	if err != nil {
		return ExpressRouteCircuitPeeringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitPeeringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitPeeringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitPeeringResponse, error) {
	respType := ExpressRouteCircuitPeeringResponse{ExpressRouteCircuitPeering: &ExpressRouteCircuitPeering{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitPeering)
	if err != nil {
		return ExpressRouteCircuitPeeringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitPoller provides polling facilities until the operation completes
type ExpressRouteCircuitPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitResponse, error)
}

type expressRouteCircuitPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitResponse, error) {
	respType := ExpressRouteCircuitResponse{ExpressRouteCircuit: &ExpressRouteCircuit{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuit)
	if err != nil {
		return ExpressRouteCircuitResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitResponse, error) {
	respType := ExpressRouteCircuitResponse{ExpressRouteCircuit: &ExpressRouteCircuit{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuit)
	if err != nil {
		return ExpressRouteCircuitResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitsArpTableListResultPoller provides polling facilities until the operation completes
type ExpressRouteCircuitsArpTableListResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitsArpTableListResultResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitsArpTableListResultResponse, error)
}

type expressRouteCircuitsArpTableListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitsArpTableListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitsArpTableListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitsArpTableListResultPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsArpTableListResultResponse, error) {
	respType := ExpressRouteCircuitsArpTableListResultResponse{ExpressRouteCircuitsArpTableListResult: &ExpressRouteCircuitsArpTableListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return ExpressRouteCircuitsArpTableListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitsArpTableListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitsArpTableListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitsArpTableListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitsArpTableListResultResponse, error) {
	respType := ExpressRouteCircuitsArpTableListResultResponse{ExpressRouteCircuitsArpTableListResult: &ExpressRouteCircuitsArpTableListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return ExpressRouteCircuitsArpTableListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitsRoutesTableListResultPoller provides polling facilities until the operation completes
type ExpressRouteCircuitsRoutesTableListResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitsRoutesTableListResultResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitsRoutesTableListResultResponse, error)
}

type expressRouteCircuitsRoutesTableListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitsRoutesTableListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitsRoutesTableListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitsRoutesTableListResultPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsRoutesTableListResultResponse, error) {
	respType := ExpressRouteCircuitsRoutesTableListResultResponse{ExpressRouteCircuitsRoutesTableListResult: &ExpressRouteCircuitsRoutesTableListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return ExpressRouteCircuitsRoutesTableListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitsRoutesTableListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitsRoutesTableListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitsRoutesTableListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitsRoutesTableListResultResponse, error) {
	respType := ExpressRouteCircuitsRoutesTableListResultResponse{ExpressRouteCircuitsRoutesTableListResult: &ExpressRouteCircuitsRoutesTableListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return ExpressRouteCircuitsRoutesTableListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitsRoutesTableSummaryListResultPoller provides polling facilities until the operation completes
type ExpressRouteCircuitsRoutesTableSummaryListResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitsRoutesTableSummaryListResultResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error)
}

type expressRouteCircuitsRoutesTableSummaryListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error) {
	respType := ExpressRouteCircuitsRoutesTableSummaryListResultResponse{ExpressRouteCircuitsRoutesTableSummaryListResult: &ExpressRouteCircuitsRoutesTableSummaryListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitsRoutesTableSummaryListResult)
	if err != nil {
		return ExpressRouteCircuitsRoutesTableSummaryListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitsRoutesTableSummaryListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error) {
	respType := ExpressRouteCircuitsRoutesTableSummaryListResultResponse{ExpressRouteCircuitsRoutesTableSummaryListResult: &ExpressRouteCircuitsRoutesTableSummaryListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitsRoutesTableSummaryListResult)
	if err != nil {
		return ExpressRouteCircuitsRoutesTableSummaryListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteConnectionPoller provides polling facilities until the operation completes
type ExpressRouteConnectionPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteConnectionResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteConnectionResponse, error)
}

type expressRouteConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteConnectionPoller) FinalResponse(ctx context.Context) (ExpressRouteConnectionResponse, error) {
	respType := ExpressRouteConnectionResponse{ExpressRouteConnection: &ExpressRouteConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteConnection)
	if err != nil {
		return ExpressRouteConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteConnectionResponse, error) {
	respType := ExpressRouteConnectionResponse{ExpressRouteConnection: &ExpressRouteConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteConnection)
	if err != nil {
		return ExpressRouteConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCrossConnectionPeeringPoller provides polling facilities until the operation completes
type ExpressRouteCrossConnectionPeeringPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCrossConnectionPeeringResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionPeeringResponse, error)
}

type expressRouteCrossConnectionPeeringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCrossConnectionPeeringPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCrossConnectionPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCrossConnectionPeeringPoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionPeeringResponse, error) {
	respType := ExpressRouteCrossConnectionPeeringResponse{ExpressRouteCrossConnectionPeering: &ExpressRouteCrossConnectionPeering{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCrossConnectionPeering)
	if err != nil {
		return ExpressRouteCrossConnectionPeeringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCrossConnectionPeeringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCrossConnectionPeeringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCrossConnectionPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCrossConnectionPeeringResponse, error) {
	respType := ExpressRouteCrossConnectionPeeringResponse{ExpressRouteCrossConnectionPeering: &ExpressRouteCrossConnectionPeering{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCrossConnectionPeering)
	if err != nil {
		return ExpressRouteCrossConnectionPeeringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCrossConnectionPoller provides polling facilities until the operation completes
type ExpressRouteCrossConnectionPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCrossConnectionResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionResponse, error)
}

type expressRouteCrossConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCrossConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCrossConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCrossConnectionPoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionResponse, error) {
	respType := ExpressRouteCrossConnectionResponse{ExpressRouteCrossConnection: &ExpressRouteCrossConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCrossConnection)
	if err != nil {
		return ExpressRouteCrossConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCrossConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCrossConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCrossConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCrossConnectionResponse, error) {
	respType := ExpressRouteCrossConnectionResponse{ExpressRouteCrossConnection: &ExpressRouteCrossConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCrossConnection)
	if err != nil {
		return ExpressRouteCrossConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCrossConnectionsRoutesTableSummaryListResultPoller provides polling facilities until the operation completes
type ExpressRouteCrossConnectionsRoutesTableSummaryListResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error)
}

type expressRouteCrossConnectionsRoutesTableSummaryListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error) {
	respType := ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse{ExpressRouteCrossConnectionsRoutesTableSummaryListResult: &ExpressRouteCrossConnectionsRoutesTableSummaryListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
	if err != nil {
		return ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteCrossConnectionsRoutesTableSummaryListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error) {
	respType := ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse{ExpressRouteCrossConnectionsRoutesTableSummaryListResult: &ExpressRouteCrossConnectionsRoutesTableSummaryListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
	if err != nil {
		return ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteGatewayPoller provides polling facilities until the operation completes
type ExpressRouteGatewayPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteGatewayResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteGatewayResponse, error)
}

type expressRouteGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRouteGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRouteGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRouteGatewayPoller) FinalResponse(ctx context.Context) (ExpressRouteGatewayResponse, error) {
	respType := ExpressRouteGatewayResponse{ExpressRouteGateway: &ExpressRouteGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteGateway)
	if err != nil {
		return ExpressRouteGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRouteGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRouteGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteGatewayResponse, error) {
	respType := ExpressRouteGatewayResponse{ExpressRouteGateway: &ExpressRouteGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteGateway)
	if err != nil {
		return ExpressRouteGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRoutePortPoller provides polling facilities until the operation completes
type ExpressRoutePortPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRoutePortResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRoutePortResponse, error)
}

type expressRoutePortPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *expressRoutePortPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *expressRoutePortPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *expressRoutePortPoller) FinalResponse(ctx context.Context) (ExpressRoutePortResponse, error) {
	respType := ExpressRoutePortResponse{ExpressRoutePort: &ExpressRoutePort{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRoutePort)
	if err != nil {
		return ExpressRoutePortResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeExpressRoutePortPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *expressRoutePortPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRoutePortPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRoutePortResponse, error) {
	respType := ExpressRoutePortResponse{ExpressRoutePort: &ExpressRoutePort{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRoutePort)
	if err != nil {
		return ExpressRoutePortResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FirewallPolicyPoller provides polling facilities until the operation completes
type FirewallPolicyPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FirewallPolicyResponse will be returned.
	FinalResponse(ctx context.Context) (FirewallPolicyResponse, error)
}

type firewallPolicyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *firewallPolicyPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *firewallPolicyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *firewallPolicyPoller) FinalResponse(ctx context.Context) (FirewallPolicyResponse, error) {
	respType := FirewallPolicyResponse{FirewallPolicy: &FirewallPolicy{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.FirewallPolicy)
	if err != nil {
		return FirewallPolicyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeFirewallPolicyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *firewallPolicyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *firewallPolicyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (FirewallPolicyResponse, error) {
	respType := FirewallPolicyResponse{FirewallPolicy: &FirewallPolicy{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.FirewallPolicy)
	if err != nil {
		return FirewallPolicyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FirewallPolicyRuleCollectionGroupPoller provides polling facilities until the operation completes
type FirewallPolicyRuleCollectionGroupPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FirewallPolicyRuleCollectionGroupResponse will be returned.
	FinalResponse(ctx context.Context) (FirewallPolicyRuleCollectionGroupResponse, error)
}

type firewallPolicyRuleCollectionGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *firewallPolicyRuleCollectionGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *firewallPolicyRuleCollectionGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *firewallPolicyRuleCollectionGroupPoller) FinalResponse(ctx context.Context) (FirewallPolicyRuleCollectionGroupResponse, error) {
	respType := FirewallPolicyRuleCollectionGroupResponse{FirewallPolicyRuleCollectionGroup: &FirewallPolicyRuleCollectionGroup{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.FirewallPolicyRuleCollectionGroup)
	if err != nil {
		return FirewallPolicyRuleCollectionGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeFirewallPolicyRuleCollectionGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *firewallPolicyRuleCollectionGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *firewallPolicyRuleCollectionGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (FirewallPolicyRuleCollectionGroupResponse, error) {
	respType := FirewallPolicyRuleCollectionGroupResponse{FirewallPolicyRuleCollectionGroup: &FirewallPolicyRuleCollectionGroup{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.FirewallPolicyRuleCollectionGroup)
	if err != nil {
		return FirewallPolicyRuleCollectionGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FlowLogInformationPoller provides polling facilities until the operation completes
type FlowLogInformationPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FlowLogInformationResponse will be returned.
	FinalResponse(ctx context.Context) (FlowLogInformationResponse, error)
}

type flowLogInformationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *flowLogInformationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *flowLogInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *flowLogInformationPoller) FinalResponse(ctx context.Context) (FlowLogInformationResponse, error) {
	respType := FlowLogInformationResponse{FlowLogInformation: &FlowLogInformation{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.FlowLogInformation)
	if err != nil {
		return FlowLogInformationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeFlowLogInformationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *flowLogInformationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *flowLogInformationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (FlowLogInformationResponse, error) {
	respType := FlowLogInformationResponse{FlowLogInformation: &FlowLogInformation{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.FlowLogInformation)
	if err != nil {
		return FlowLogInformationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FlowLogPoller provides polling facilities until the operation completes
type FlowLogPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FlowLogResponse will be returned.
	FinalResponse(ctx context.Context) (FlowLogResponse, error)
}

type flowLogPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *flowLogPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *flowLogPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *flowLogPoller) FinalResponse(ctx context.Context) (FlowLogResponse, error) {
	respType := FlowLogResponse{FlowLog: &FlowLog{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.FlowLog)
	if err != nil {
		return FlowLogResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeFlowLogPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *flowLogPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *flowLogPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (FlowLogResponse, error) {
	respType := FlowLogResponse{FlowLog: &FlowLog{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.FlowLog)
	if err != nil {
		return FlowLogResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GatewayRouteListResultPoller provides polling facilities until the operation completes
type GatewayRouteListResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GatewayRouteListResultResponse will be returned.
	FinalResponse(ctx context.Context) (GatewayRouteListResultResponse, error)
}

type gatewayRouteListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *gatewayRouteListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *gatewayRouteListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *gatewayRouteListResultPoller) FinalResponse(ctx context.Context) (GatewayRouteListResultResponse, error) {
	respType := GatewayRouteListResultResponse{GatewayRouteListResult: &GatewayRouteListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.GatewayRouteListResult)
	if err != nil {
		return GatewayRouteListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeGatewayRouteListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *gatewayRouteListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *gatewayRouteListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (GatewayRouteListResultResponse, error) {
	respType := GatewayRouteListResultResponse{GatewayRouteListResult: &GatewayRouteListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.GatewayRouteListResult)
	if err != nil {
		return GatewayRouteListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// HTTPPoller provides polling facilities until the operation completes
type HTTPPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final HTTPResponse will be returned.
	FinalResponse(ctx context.Context) (*http.Response, error)
}

type httpPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *httpPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *httpPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *httpPoller) FinalResponse(ctx context.Context) (*http.Response, error) {
	return p.pt.FinalResponse(ctx, p.pipeline, nil)
}

// ResumeToken generates the string token that can be used with the ResumeHTTPPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *httpPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *httpPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*http.Response, error) {
	return p.pt.PollUntilDone(ctx, frequency, p.pipeline, nil)
}

// HubIPConfigurationPoller provides polling facilities until the operation completes
type HubIPConfigurationPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final HubIPConfigurationResponse will be returned.
	FinalResponse(ctx context.Context) (HubIPConfigurationResponse, error)
}

type hubIPConfigurationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *hubIPConfigurationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *hubIPConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *hubIPConfigurationPoller) FinalResponse(ctx context.Context) (HubIPConfigurationResponse, error) {
	respType := HubIPConfigurationResponse{HubIPConfiguration: &HubIPConfiguration{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.HubIPConfiguration)
	if err != nil {
		return HubIPConfigurationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeHubIPConfigurationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *hubIPConfigurationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *hubIPConfigurationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (HubIPConfigurationResponse, error) {
	respType := HubIPConfigurationResponse{HubIPConfiguration: &HubIPConfiguration{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.HubIPConfiguration)
	if err != nil {
		return HubIPConfigurationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// HubRouteTablePoller provides polling facilities until the operation completes
type HubRouteTablePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final HubRouteTableResponse will be returned.
	FinalResponse(ctx context.Context) (HubRouteTableResponse, error)
}

type hubRouteTablePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *hubRouteTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *hubRouteTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *hubRouteTablePoller) FinalResponse(ctx context.Context) (HubRouteTableResponse, error) {
	respType := HubRouteTableResponse{HubRouteTable: &HubRouteTable{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.HubRouteTable)
	if err != nil {
		return HubRouteTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeHubRouteTablePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *hubRouteTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *hubRouteTablePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (HubRouteTableResponse, error) {
	respType := HubRouteTableResponse{HubRouteTable: &HubRouteTable{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.HubRouteTable)
	if err != nil {
		return HubRouteTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// HubVirtualNetworkConnectionPoller provides polling facilities until the operation completes
type HubVirtualNetworkConnectionPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final HubVirtualNetworkConnectionResponse will be returned.
	FinalResponse(ctx context.Context) (HubVirtualNetworkConnectionResponse, error)
}

type hubVirtualNetworkConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *hubVirtualNetworkConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *hubVirtualNetworkConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *hubVirtualNetworkConnectionPoller) FinalResponse(ctx context.Context) (HubVirtualNetworkConnectionResponse, error) {
	respType := HubVirtualNetworkConnectionResponse{HubVirtualNetworkConnection: &HubVirtualNetworkConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.HubVirtualNetworkConnection)
	if err != nil {
		return HubVirtualNetworkConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeHubVirtualNetworkConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *hubVirtualNetworkConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *hubVirtualNetworkConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (HubVirtualNetworkConnectionResponse, error) {
	respType := HubVirtualNetworkConnectionResponse{HubVirtualNetworkConnection: &HubVirtualNetworkConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.HubVirtualNetworkConnection)
	if err != nil {
		return HubVirtualNetworkConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// IPAllocationPoller provides polling facilities until the operation completes
type IPAllocationPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final IPAllocationResponse will be returned.
	FinalResponse(ctx context.Context) (IPAllocationResponse, error)
}

type ipAllocationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *ipAllocationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *ipAllocationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *ipAllocationPoller) FinalResponse(ctx context.Context) (IPAllocationResponse, error) {
	respType := IPAllocationResponse{IPAllocation: &IPAllocation{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.IPAllocation)
	if err != nil {
		return IPAllocationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeIPAllocationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *ipAllocationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ipAllocationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (IPAllocationResponse, error) {
	respType := IPAllocationResponse{IPAllocation: &IPAllocation{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.IPAllocation)
	if err != nil {
		return IPAllocationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// IPGroupPoller provides polling facilities until the operation completes
type IPGroupPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final IPGroupResponse will be returned.
	FinalResponse(ctx context.Context) (IPGroupResponse, error)
}

type ipGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *ipGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *ipGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *ipGroupPoller) FinalResponse(ctx context.Context) (IPGroupResponse, error) {
	respType := IPGroupResponse{IPGroup: &IPGroup{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.IPGroup)
	if err != nil {
		return IPGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeIPGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *ipGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ipGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (IPGroupResponse, error) {
	respType := IPGroupResponse{IPGroup: &IPGroup{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.IPGroup)
	if err != nil {
		return IPGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// InboundNatRulePoller provides polling facilities until the operation completes
type InboundNatRulePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final InboundNatRuleResponse will be returned.
	FinalResponse(ctx context.Context) (InboundNatRuleResponse, error)
}

type inboundNatRulePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *inboundNatRulePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *inboundNatRulePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *inboundNatRulePoller) FinalResponse(ctx context.Context) (InboundNatRuleResponse, error) {
	respType := InboundNatRuleResponse{InboundNatRule: &InboundNatRule{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.InboundNatRule)
	if err != nil {
		return InboundNatRuleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeInboundNatRulePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *inboundNatRulePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *inboundNatRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (InboundNatRuleResponse, error) {
	respType := InboundNatRuleResponse{InboundNatRule: &InboundNatRule{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.InboundNatRule)
	if err != nil {
		return InboundNatRuleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// InboundSecurityRulePoller provides polling facilities until the operation completes
type InboundSecurityRulePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final InboundSecurityRuleResponse will be returned.
	FinalResponse(ctx context.Context) (InboundSecurityRuleResponse, error)
}

type inboundSecurityRulePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *inboundSecurityRulePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *inboundSecurityRulePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *inboundSecurityRulePoller) FinalResponse(ctx context.Context) (InboundSecurityRuleResponse, error) {
	respType := InboundSecurityRuleResponse{InboundSecurityRule: &InboundSecurityRule{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.InboundSecurityRule)
	if err != nil {
		return InboundSecurityRuleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeInboundSecurityRulePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *inboundSecurityRulePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *inboundSecurityRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (InboundSecurityRuleResponse, error) {
	respType := InboundSecurityRuleResponse{InboundSecurityRule: &InboundSecurityRule{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.InboundSecurityRule)
	if err != nil {
		return InboundSecurityRuleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LoadBalancerPoller provides polling facilities until the operation completes
type LoadBalancerPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LoadBalancerResponse will be returned.
	FinalResponse(ctx context.Context) (LoadBalancerResponse, error)
}

type loadBalancerPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *loadBalancerPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *loadBalancerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *loadBalancerPoller) FinalResponse(ctx context.Context) (LoadBalancerResponse, error) {
	respType := LoadBalancerResponse{LoadBalancer: &LoadBalancer{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.LoadBalancer)
	if err != nil {
		return LoadBalancerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeLoadBalancerPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *loadBalancerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *loadBalancerPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (LoadBalancerResponse, error) {
	respType := LoadBalancerResponse{LoadBalancer: &LoadBalancer{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.LoadBalancer)
	if err != nil {
		return LoadBalancerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LocalNetworkGatewayPoller provides polling facilities until the operation completes
type LocalNetworkGatewayPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LocalNetworkGatewayResponse will be returned.
	FinalResponse(ctx context.Context) (LocalNetworkGatewayResponse, error)
}

type localNetworkGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *localNetworkGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *localNetworkGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *localNetworkGatewayPoller) FinalResponse(ctx context.Context) (LocalNetworkGatewayResponse, error) {
	respType := LocalNetworkGatewayResponse{LocalNetworkGateway: &LocalNetworkGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.LocalNetworkGateway)
	if err != nil {
		return LocalNetworkGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeLocalNetworkGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *localNetworkGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *localNetworkGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (LocalNetworkGatewayResponse, error) {
	respType := LocalNetworkGatewayResponse{LocalNetworkGateway: &LocalNetworkGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.LocalNetworkGateway)
	if err != nil {
		return LocalNetworkGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NatGatewayPoller provides polling facilities until the operation completes
type NatGatewayPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NatGatewayResponse will be returned.
	FinalResponse(ctx context.Context) (NatGatewayResponse, error)
}

type natGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *natGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *natGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *natGatewayPoller) FinalResponse(ctx context.Context) (NatGatewayResponse, error) {
	respType := NatGatewayResponse{NatGateway: &NatGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NatGateway)
	if err != nil {
		return NatGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNatGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *natGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *natGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NatGatewayResponse, error) {
	respType := NatGatewayResponse{NatGateway: &NatGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NatGateway)
	if err != nil {
		return NatGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkConfigurationDiagnosticResponsePoller provides polling facilities until the operation completes
type NetworkConfigurationDiagnosticResponsePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkConfigurationDiagnosticResponseResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkConfigurationDiagnosticResponseResponse, error)
}

type networkConfigurationDiagnosticResponsePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkConfigurationDiagnosticResponsePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkConfigurationDiagnosticResponsePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *networkConfigurationDiagnosticResponsePoller) FinalResponse(ctx context.Context) (NetworkConfigurationDiagnosticResponseResponse, error) {
	respType := NetworkConfigurationDiagnosticResponseResponse{NetworkConfigurationDiagnosticResponse: &NetworkConfigurationDiagnosticResponse{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkConfigurationDiagnosticResponse)
	if err != nil {
		return NetworkConfigurationDiagnosticResponseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNetworkConfigurationDiagnosticResponsePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkConfigurationDiagnosticResponsePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkConfigurationDiagnosticResponsePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NetworkConfigurationDiagnosticResponseResponse, error) {
	respType := NetworkConfigurationDiagnosticResponseResponse{NetworkConfigurationDiagnosticResponse: &NetworkConfigurationDiagnosticResponse{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkConfigurationDiagnosticResponse)
	if err != nil {
		return NetworkConfigurationDiagnosticResponseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkInterfacePoller provides polling facilities until the operation completes
type NetworkInterfacePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkInterfaceResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkInterfaceResponse, error)
}

type networkInterfacePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkInterfacePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkInterfacePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *networkInterfacePoller) FinalResponse(ctx context.Context) (NetworkInterfaceResponse, error) {
	respType := NetworkInterfaceResponse{NetworkInterface: &NetworkInterface{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkInterface)
	if err != nil {
		return NetworkInterfaceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNetworkInterfacePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkInterfacePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkInterfacePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NetworkInterfaceResponse, error) {
	respType := NetworkInterfaceResponse{NetworkInterface: &NetworkInterface{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkInterface)
	if err != nil {
		return NetworkInterfaceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkInterfaceTapConfigurationPoller provides polling facilities until the operation completes
type NetworkInterfaceTapConfigurationPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkInterfaceTapConfigurationResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkInterfaceTapConfigurationResponse, error)
}

type networkInterfaceTapConfigurationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkInterfaceTapConfigurationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkInterfaceTapConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *networkInterfaceTapConfigurationPoller) FinalResponse(ctx context.Context) (NetworkInterfaceTapConfigurationResponse, error) {
	respType := NetworkInterfaceTapConfigurationResponse{NetworkInterfaceTapConfiguration: &NetworkInterfaceTapConfiguration{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkInterfaceTapConfiguration)
	if err != nil {
		return NetworkInterfaceTapConfigurationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNetworkInterfaceTapConfigurationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkInterfaceTapConfigurationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkInterfaceTapConfigurationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NetworkInterfaceTapConfigurationResponse, error) {
	respType := NetworkInterfaceTapConfigurationResponse{NetworkInterfaceTapConfiguration: &NetworkInterfaceTapConfiguration{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkInterfaceTapConfiguration)
	if err != nil {
		return NetworkInterfaceTapConfigurationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkSecurityGroupPoller provides polling facilities until the operation completes
type NetworkSecurityGroupPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkSecurityGroupResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkSecurityGroupResponse, error)
}

type networkSecurityGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkSecurityGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkSecurityGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *networkSecurityGroupPoller) FinalResponse(ctx context.Context) (NetworkSecurityGroupResponse, error) {
	respType := NetworkSecurityGroupResponse{NetworkSecurityGroup: &NetworkSecurityGroup{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkSecurityGroup)
	if err != nil {
		return NetworkSecurityGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNetworkSecurityGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkSecurityGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkSecurityGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NetworkSecurityGroupResponse, error) {
	respType := NetworkSecurityGroupResponse{NetworkSecurityGroup: &NetworkSecurityGroup{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkSecurityGroup)
	if err != nil {
		return NetworkSecurityGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkVirtualAppliancePoller provides polling facilities until the operation completes
type NetworkVirtualAppliancePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkVirtualApplianceResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkVirtualApplianceResponse, error)
}

type networkVirtualAppliancePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *networkVirtualAppliancePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *networkVirtualAppliancePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *networkVirtualAppliancePoller) FinalResponse(ctx context.Context) (NetworkVirtualApplianceResponse, error) {
	respType := NetworkVirtualApplianceResponse{NetworkVirtualAppliance: &NetworkVirtualAppliance{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkVirtualAppliance)
	if err != nil {
		return NetworkVirtualApplianceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNetworkVirtualAppliancePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *networkVirtualAppliancePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkVirtualAppliancePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NetworkVirtualApplianceResponse, error) {
	respType := NetworkVirtualApplianceResponse{NetworkVirtualAppliance: &NetworkVirtualAppliance{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkVirtualAppliance)
	if err != nil {
		return NetworkVirtualApplianceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NextHopResultPoller provides polling facilities until the operation completes
type NextHopResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NextHopResultResponse will be returned.
	FinalResponse(ctx context.Context) (NextHopResultResponse, error)
}

type nextHopResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *nextHopResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *nextHopResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *nextHopResultPoller) FinalResponse(ctx context.Context) (NextHopResultResponse, error) {
	respType := NextHopResultResponse{NextHopResult: &NextHopResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NextHopResult)
	if err != nil {
		return NextHopResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeNextHopResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *nextHopResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *nextHopResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NextHopResultResponse, error) {
	respType := NextHopResultResponse{NextHopResult: &NextHopResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NextHopResult)
	if err != nil {
		return NextHopResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// P2SVPNConnectionHealthPoller provides polling facilities until the operation completes
type P2SVPNConnectionHealthPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final P2SVPNConnectionHealthResponse will be returned.
	FinalResponse(ctx context.Context) (P2SVPNConnectionHealthResponse, error)
}

type p2SVPNConnectionHealthPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *p2SVPNConnectionHealthPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *p2SVPNConnectionHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *p2SVPNConnectionHealthPoller) FinalResponse(ctx context.Context) (P2SVPNConnectionHealthResponse, error) {
	respType := P2SVPNConnectionHealthResponse{P2SVPNConnectionHealth: &P2SVPNConnectionHealth{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.P2SVPNConnectionHealth)
	if err != nil {
		return P2SVPNConnectionHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeP2SVPNConnectionHealthPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *p2SVPNConnectionHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *p2SVPNConnectionHealthPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (P2SVPNConnectionHealthResponse, error) {
	respType := P2SVPNConnectionHealthResponse{P2SVPNConnectionHealth: &P2SVPNConnectionHealth{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.P2SVPNConnectionHealth)
	if err != nil {
		return P2SVPNConnectionHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// P2SVPNGatewayPoller provides polling facilities until the operation completes
type P2SVPNGatewayPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final P2SVPNGatewayResponse will be returned.
	FinalResponse(ctx context.Context) (P2SVPNGatewayResponse, error)
}

type p2SVPNGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *p2SVPNGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *p2SVPNGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *p2SVPNGatewayPoller) FinalResponse(ctx context.Context) (P2SVPNGatewayResponse, error) {
	respType := P2SVPNGatewayResponse{P2SVPNGateway: &P2SVPNGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.P2SVPNGateway)
	if err != nil {
		return P2SVPNGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeP2SVPNGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *p2SVPNGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *p2SVPNGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (P2SVPNGatewayResponse, error) {
	respType := P2SVPNGatewayResponse{P2SVPNGateway: &P2SVPNGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.P2SVPNGateway)
	if err != nil {
		return P2SVPNGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PacketCaptureQueryStatusResultPoller provides polling facilities until the operation completes
type PacketCaptureQueryStatusResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PacketCaptureQueryStatusResultResponse will be returned.
	FinalResponse(ctx context.Context) (PacketCaptureQueryStatusResultResponse, error)
}

type packetCaptureQueryStatusResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *packetCaptureQueryStatusResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *packetCaptureQueryStatusResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *packetCaptureQueryStatusResultPoller) FinalResponse(ctx context.Context) (PacketCaptureQueryStatusResultResponse, error) {
	respType := PacketCaptureQueryStatusResultResponse{PacketCaptureQueryStatusResult: &PacketCaptureQueryStatusResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PacketCaptureQueryStatusResult)
	if err != nil {
		return PacketCaptureQueryStatusResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePacketCaptureQueryStatusResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *packetCaptureQueryStatusResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *packetCaptureQueryStatusResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PacketCaptureQueryStatusResultResponse, error) {
	respType := PacketCaptureQueryStatusResultResponse{PacketCaptureQueryStatusResult: &PacketCaptureQueryStatusResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PacketCaptureQueryStatusResult)
	if err != nil {
		return PacketCaptureQueryStatusResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PacketCaptureResultPoller provides polling facilities until the operation completes
type PacketCaptureResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PacketCaptureResultResponse will be returned.
	FinalResponse(ctx context.Context) (PacketCaptureResultResponse, error)
}

type packetCaptureResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *packetCaptureResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *packetCaptureResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *packetCaptureResultPoller) FinalResponse(ctx context.Context) (PacketCaptureResultResponse, error) {
	respType := PacketCaptureResultResponse{PacketCaptureResult: &PacketCaptureResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PacketCaptureResult)
	if err != nil {
		return PacketCaptureResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePacketCaptureResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *packetCaptureResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *packetCaptureResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PacketCaptureResultResponse, error) {
	respType := PacketCaptureResultResponse{PacketCaptureResult: &PacketCaptureResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PacketCaptureResult)
	if err != nil {
		return PacketCaptureResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PeerRouteListPoller provides polling facilities until the operation completes
type PeerRouteListPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PeerRouteListResponse will be returned.
	FinalResponse(ctx context.Context) (PeerRouteListResponse, error)
}

type peerRouteListPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *peerRouteListPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *peerRouteListPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *peerRouteListPoller) FinalResponse(ctx context.Context) (PeerRouteListResponse, error) {
	respType := PeerRouteListResponse{PeerRouteList: &PeerRouteList{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PeerRouteList)
	if err != nil {
		return PeerRouteListResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePeerRouteListPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *peerRouteListPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *peerRouteListPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PeerRouteListResponse, error) {
	respType := PeerRouteListResponse{PeerRouteList: &PeerRouteList{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PeerRouteList)
	if err != nil {
		return PeerRouteListResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateDNSZoneGroupPoller provides polling facilities until the operation completes
type PrivateDNSZoneGroupPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateDNSZoneGroupResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateDNSZoneGroupResponse, error)
}

type privateDNSZoneGroupPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *privateDNSZoneGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *privateDNSZoneGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *privateDNSZoneGroupPoller) FinalResponse(ctx context.Context) (PrivateDNSZoneGroupResponse, error) {
	respType := PrivateDNSZoneGroupResponse{PrivateDNSZoneGroup: &PrivateDNSZoneGroup{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateDNSZoneGroup)
	if err != nil {
		return PrivateDNSZoneGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePrivateDNSZoneGroupPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *privateDNSZoneGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateDNSZoneGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PrivateDNSZoneGroupResponse, error) {
	respType := PrivateDNSZoneGroupResponse{PrivateDNSZoneGroup: &PrivateDNSZoneGroup{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PrivateDNSZoneGroup)
	if err != nil {
		return PrivateDNSZoneGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateEndpointPoller provides polling facilities until the operation completes
type PrivateEndpointPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateEndpointResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateEndpointResponse, error)
}

type privateEndpointPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *privateEndpointPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *privateEndpointPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *privateEndpointPoller) FinalResponse(ctx context.Context) (PrivateEndpointResponse, error) {
	respType := PrivateEndpointResponse{PrivateEndpoint: &PrivateEndpoint{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateEndpoint)
	if err != nil {
		return PrivateEndpointResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePrivateEndpointPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *privateEndpointPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateEndpointPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PrivateEndpointResponse, error) {
	respType := PrivateEndpointResponse{PrivateEndpoint: &PrivateEndpoint{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PrivateEndpoint)
	if err != nil {
		return PrivateEndpointResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateLinkServicePoller provides polling facilities until the operation completes
type PrivateLinkServicePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateLinkServiceResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateLinkServiceResponse, error)
}

type privateLinkServicePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *privateLinkServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *privateLinkServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *privateLinkServicePoller) FinalResponse(ctx context.Context) (PrivateLinkServiceResponse, error) {
	respType := PrivateLinkServiceResponse{PrivateLinkService: &PrivateLinkService{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateLinkService)
	if err != nil {
		return PrivateLinkServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePrivateLinkServicePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *privateLinkServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateLinkServicePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PrivateLinkServiceResponse, error) {
	respType := PrivateLinkServiceResponse{PrivateLinkService: &PrivateLinkService{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PrivateLinkService)
	if err != nil {
		return PrivateLinkServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateLinkServiceVisibilityPoller provides polling facilities until the operation completes
type PrivateLinkServiceVisibilityPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateLinkServiceVisibilityResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateLinkServiceVisibilityResponse, error)
}

type privateLinkServiceVisibilityPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *privateLinkServiceVisibilityPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *privateLinkServiceVisibilityPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *privateLinkServiceVisibilityPoller) FinalResponse(ctx context.Context) (PrivateLinkServiceVisibilityResponse, error) {
	respType := PrivateLinkServiceVisibilityResponse{PrivateLinkServiceVisibility: &PrivateLinkServiceVisibility{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateLinkServiceVisibility)
	if err != nil {
		return PrivateLinkServiceVisibilityResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePrivateLinkServiceVisibilityPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *privateLinkServiceVisibilityPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateLinkServiceVisibilityPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PrivateLinkServiceVisibilityResponse, error) {
	respType := PrivateLinkServiceVisibilityResponse{PrivateLinkServiceVisibility: &PrivateLinkServiceVisibility{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PrivateLinkServiceVisibility)
	if err != nil {
		return PrivateLinkServiceVisibilityResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PublicIPAddressPoller provides polling facilities until the operation completes
type PublicIPAddressPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PublicIPAddressResponse will be returned.
	FinalResponse(ctx context.Context) (PublicIPAddressResponse, error)
}

type publicIPAddressPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *publicIPAddressPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *publicIPAddressPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *publicIPAddressPoller) FinalResponse(ctx context.Context) (PublicIPAddressResponse, error) {
	respType := PublicIPAddressResponse{PublicIPAddress: &PublicIPAddress{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PublicIPAddress)
	if err != nil {
		return PublicIPAddressResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePublicIPAddressPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *publicIPAddressPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *publicIPAddressPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PublicIPAddressResponse, error) {
	respType := PublicIPAddressResponse{PublicIPAddress: &PublicIPAddress{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PublicIPAddress)
	if err != nil {
		return PublicIPAddressResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PublicIPPrefixPoller provides polling facilities until the operation completes
type PublicIPPrefixPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PublicIPPrefixResponse will be returned.
	FinalResponse(ctx context.Context) (PublicIPPrefixResponse, error)
}

type publicIPPrefixPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *publicIPPrefixPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *publicIPPrefixPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *publicIPPrefixPoller) FinalResponse(ctx context.Context) (PublicIPPrefixResponse, error) {
	respType := PublicIPPrefixResponse{PublicIPPrefix: &PublicIPPrefix{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PublicIPPrefix)
	if err != nil {
		return PublicIPPrefixResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumePublicIPPrefixPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *publicIPPrefixPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *publicIPPrefixPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PublicIPPrefixResponse, error) {
	respType := PublicIPPrefixResponse{PublicIPPrefix: &PublicIPPrefix{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PublicIPPrefix)
	if err != nil {
		return PublicIPPrefixResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RouteFilterPoller provides polling facilities until the operation completes
type RouteFilterPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RouteFilterResponse will be returned.
	FinalResponse(ctx context.Context) (RouteFilterResponse, error)
}

type routeFilterPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *routeFilterPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *routeFilterPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *routeFilterPoller) FinalResponse(ctx context.Context) (RouteFilterResponse, error) {
	respType := RouteFilterResponse{RouteFilter: &RouteFilter{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.RouteFilter)
	if err != nil {
		return RouteFilterResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeRouteFilterPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *routeFilterPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routeFilterPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (RouteFilterResponse, error) {
	respType := RouteFilterResponse{RouteFilter: &RouteFilter{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.RouteFilter)
	if err != nil {
		return RouteFilterResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RouteFilterRulePoller provides polling facilities until the operation completes
type RouteFilterRulePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RouteFilterRuleResponse will be returned.
	FinalResponse(ctx context.Context) (RouteFilterRuleResponse, error)
}

type routeFilterRulePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *routeFilterRulePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *routeFilterRulePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *routeFilterRulePoller) FinalResponse(ctx context.Context) (RouteFilterRuleResponse, error) {
	respType := RouteFilterRuleResponse{RouteFilterRule: &RouteFilterRule{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.RouteFilterRule)
	if err != nil {
		return RouteFilterRuleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeRouteFilterRulePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *routeFilterRulePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routeFilterRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (RouteFilterRuleResponse, error) {
	respType := RouteFilterRuleResponse{RouteFilterRule: &RouteFilterRule{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.RouteFilterRule)
	if err != nil {
		return RouteFilterRuleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RoutePoller provides polling facilities until the operation completes
type RoutePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RouteResponse will be returned.
	FinalResponse(ctx context.Context) (RouteResponse, error)
}

type routePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *routePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *routePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *routePoller) FinalResponse(ctx context.Context) (RouteResponse, error) {
	respType := RouteResponse{Route: &Route{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.Route)
	if err != nil {
		return RouteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeRoutePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *routePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (RouteResponse, error) {
	respType := RouteResponse{Route: &Route{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.Route)
	if err != nil {
		return RouteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RouteTablePoller provides polling facilities until the operation completes
type RouteTablePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RouteTableResponse will be returned.
	FinalResponse(ctx context.Context) (RouteTableResponse, error)
}

type routeTablePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *routeTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *routeTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *routeTablePoller) FinalResponse(ctx context.Context) (RouteTableResponse, error) {
	respType := RouteTableResponse{RouteTable: &RouteTable{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.RouteTable)
	if err != nil {
		return RouteTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeRouteTablePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *routeTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routeTablePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (RouteTableResponse, error) {
	respType := RouteTableResponse{RouteTable: &RouteTable{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.RouteTable)
	if err != nil {
		return RouteTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityGroupViewResultPoller provides polling facilities until the operation completes
type SecurityGroupViewResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecurityGroupViewResultResponse will be returned.
	FinalResponse(ctx context.Context) (SecurityGroupViewResultResponse, error)
}

type securityGroupViewResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *securityGroupViewResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *securityGroupViewResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *securityGroupViewResultPoller) FinalResponse(ctx context.Context) (SecurityGroupViewResultResponse, error) {
	respType := SecurityGroupViewResultResponse{SecurityGroupViewResult: &SecurityGroupViewResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.SecurityGroupViewResult)
	if err != nil {
		return SecurityGroupViewResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeSecurityGroupViewResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *securityGroupViewResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityGroupViewResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (SecurityGroupViewResultResponse, error) {
	respType := SecurityGroupViewResultResponse{SecurityGroupViewResult: &SecurityGroupViewResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.SecurityGroupViewResult)
	if err != nil {
		return SecurityGroupViewResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityPartnerProviderPoller provides polling facilities until the operation completes
type SecurityPartnerProviderPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecurityPartnerProviderResponse will be returned.
	FinalResponse(ctx context.Context) (SecurityPartnerProviderResponse, error)
}

type securityPartnerProviderPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *securityPartnerProviderPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *securityPartnerProviderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *securityPartnerProviderPoller) FinalResponse(ctx context.Context) (SecurityPartnerProviderResponse, error) {
	respType := SecurityPartnerProviderResponse{SecurityPartnerProvider: &SecurityPartnerProvider{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.SecurityPartnerProvider)
	if err != nil {
		return SecurityPartnerProviderResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeSecurityPartnerProviderPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *securityPartnerProviderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityPartnerProviderPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (SecurityPartnerProviderResponse, error) {
	respType := SecurityPartnerProviderResponse{SecurityPartnerProvider: &SecurityPartnerProvider{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.SecurityPartnerProvider)
	if err != nil {
		return SecurityPartnerProviderResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityRulePoller provides polling facilities until the operation completes
type SecurityRulePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecurityRuleResponse will be returned.
	FinalResponse(ctx context.Context) (SecurityRuleResponse, error)
}

type securityRulePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *securityRulePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *securityRulePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *securityRulePoller) FinalResponse(ctx context.Context) (SecurityRuleResponse, error) {
	respType := SecurityRuleResponse{SecurityRule: &SecurityRule{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.SecurityRule)
	if err != nil {
		return SecurityRuleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeSecurityRulePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *securityRulePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (SecurityRuleResponse, error) {
	respType := SecurityRuleResponse{SecurityRule: &SecurityRule{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.SecurityRule)
	if err != nil {
		return SecurityRuleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServiceEndpointPolicyDefinitionPoller provides polling facilities until the operation completes
type ServiceEndpointPolicyDefinitionPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServiceEndpointPolicyDefinitionResponse will be returned.
	FinalResponse(ctx context.Context) (ServiceEndpointPolicyDefinitionResponse, error)
}

type serviceEndpointPolicyDefinitionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *serviceEndpointPolicyDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *serviceEndpointPolicyDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *serviceEndpointPolicyDefinitionPoller) FinalResponse(ctx context.Context) (ServiceEndpointPolicyDefinitionResponse, error) {
	respType := ServiceEndpointPolicyDefinitionResponse{ServiceEndpointPolicyDefinition: &ServiceEndpointPolicyDefinition{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ServiceEndpointPolicyDefinition)
	if err != nil {
		return ServiceEndpointPolicyDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeServiceEndpointPolicyDefinitionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *serviceEndpointPolicyDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serviceEndpointPolicyDefinitionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ServiceEndpointPolicyDefinitionResponse, error) {
	respType := ServiceEndpointPolicyDefinitionResponse{ServiceEndpointPolicyDefinition: &ServiceEndpointPolicyDefinition{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ServiceEndpointPolicyDefinition)
	if err != nil {
		return ServiceEndpointPolicyDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServiceEndpointPolicyPoller provides polling facilities until the operation completes
type ServiceEndpointPolicyPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServiceEndpointPolicyResponse will be returned.
	FinalResponse(ctx context.Context) (ServiceEndpointPolicyResponse, error)
}

type serviceEndpointPolicyPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *serviceEndpointPolicyPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *serviceEndpointPolicyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *serviceEndpointPolicyPoller) FinalResponse(ctx context.Context) (ServiceEndpointPolicyResponse, error) {
	respType := ServiceEndpointPolicyResponse{ServiceEndpointPolicy: &ServiceEndpointPolicy{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ServiceEndpointPolicy)
	if err != nil {
		return ServiceEndpointPolicyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeServiceEndpointPolicyPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *serviceEndpointPolicyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serviceEndpointPolicyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ServiceEndpointPolicyResponse, error) {
	respType := ServiceEndpointPolicyResponse{ServiceEndpointPolicy: &ServiceEndpointPolicy{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ServiceEndpointPolicy)
	if err != nil {
		return ServiceEndpointPolicyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// StringPoller provides polling facilities until the operation completes
type StringPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final StringResponse will be returned.
	FinalResponse(ctx context.Context) (StringResponse, error)
}

type stringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *stringPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *stringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *stringPoller) FinalResponse(ctx context.Context) (StringResponse, error) {
	respType := StringResponse{}

	resp, err := p.pt.FinalResponse(ctx, p.pipeline, &respType.Value)
	if err != nil {
		return StringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeStringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *stringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *stringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (StringResponse, error) {
	respType := StringResponse{}

	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, &respType.Value)
	if err != nil {
		return StringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SubnetPoller provides polling facilities until the operation completes
type SubnetPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SubnetResponse will be returned.
	FinalResponse(ctx context.Context) (SubnetResponse, error)
}

type subnetPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *subnetPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *subnetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *subnetPoller) FinalResponse(ctx context.Context) (SubnetResponse, error) {
	respType := SubnetResponse{Subnet: &Subnet{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.Subnet)
	if err != nil {
		return SubnetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeSubnetPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *subnetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *subnetPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (SubnetResponse, error) {
	respType := SubnetResponse{Subnet: &Subnet{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.Subnet)
	if err != nil {
		return SubnetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// TroubleshootingResultPoller provides polling facilities until the operation completes
type TroubleshootingResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final TroubleshootingResultResponse will be returned.
	FinalResponse(ctx context.Context) (TroubleshootingResultResponse, error)
}

type troubleshootingResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *troubleshootingResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *troubleshootingResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *troubleshootingResultPoller) FinalResponse(ctx context.Context) (TroubleshootingResultResponse, error) {
	respType := TroubleshootingResultResponse{TroubleshootingResult: &TroubleshootingResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.TroubleshootingResult)
	if err != nil {
		return TroubleshootingResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeTroubleshootingResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *troubleshootingResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *troubleshootingResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (TroubleshootingResultResponse, error) {
	respType := TroubleshootingResultResponse{TroubleshootingResult: &TroubleshootingResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.TroubleshootingResult)
	if err != nil {
		return TroubleshootingResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNClientConnectionHealthDetailListResultPoller provides polling facilities until the operation completes
type VPNClientConnectionHealthDetailListResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNClientConnectionHealthDetailListResultResponse will be returned.
	FinalResponse(ctx context.Context) (VPNClientConnectionHealthDetailListResultResponse, error)
}

type vpnClientConnectionHealthDetailListResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnClientConnectionHealthDetailListResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnClientConnectionHealthDetailListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnClientConnectionHealthDetailListResultPoller) FinalResponse(ctx context.Context) (VPNClientConnectionHealthDetailListResultResponse, error) {
	respType := VPNClientConnectionHealthDetailListResultResponse{VPNClientConnectionHealthDetailListResult: &VPNClientConnectionHealthDetailListResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNClientConnectionHealthDetailListResult)
	if err != nil {
		return VPNClientConnectionHealthDetailListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVPNClientConnectionHealthDetailListResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnClientConnectionHealthDetailListResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnClientConnectionHealthDetailListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNClientConnectionHealthDetailListResultResponse, error) {
	respType := VPNClientConnectionHealthDetailListResultResponse{VPNClientConnectionHealthDetailListResult: &VPNClientConnectionHealthDetailListResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNClientConnectionHealthDetailListResult)
	if err != nil {
		return VPNClientConnectionHealthDetailListResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNClientIPsecParametersPoller provides polling facilities until the operation completes
type VPNClientIPsecParametersPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNClientIPsecParametersResponse will be returned.
	FinalResponse(ctx context.Context) (VPNClientIPsecParametersResponse, error)
}

type vpnClientIPSecParametersPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnClientIPSecParametersPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnClientIPSecParametersPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnClientIPSecParametersPoller) FinalResponse(ctx context.Context) (VPNClientIPsecParametersResponse, error) {
	respType := VPNClientIPsecParametersResponse{VPNClientIPsecParameters: &VPNClientIPsecParameters{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNClientIPsecParameters)
	if err != nil {
		return VPNClientIPsecParametersResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVPNClientIPsecParametersPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnClientIPSecParametersPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnClientIPSecParametersPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNClientIPsecParametersResponse, error) {
	respType := VPNClientIPsecParametersResponse{VPNClientIPsecParameters: &VPNClientIPsecParameters{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNClientIPsecParameters)
	if err != nil {
		return VPNClientIPsecParametersResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNConnectionPoller provides polling facilities until the operation completes
type VPNConnectionPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNConnectionResponse will be returned.
	FinalResponse(ctx context.Context) (VPNConnectionResponse, error)
}

type vpnConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnConnectionPoller) FinalResponse(ctx context.Context) (VPNConnectionResponse, error) {
	respType := VPNConnectionResponse{VPNConnection: &VPNConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNConnection)
	if err != nil {
		return VPNConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVPNConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNConnectionResponse, error) {
	respType := VPNConnectionResponse{VPNConnection: &VPNConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNConnection)
	if err != nil {
		return VPNConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNGatewayPoller provides polling facilities until the operation completes
type VPNGatewayPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNGatewayResponse will be returned.
	FinalResponse(ctx context.Context) (VPNGatewayResponse, error)
}

type vpnGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnGatewayPoller) FinalResponse(ctx context.Context) (VPNGatewayResponse, error) {
	respType := VPNGatewayResponse{VPNGateway: &VPNGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNGateway)
	if err != nil {
		return VPNGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVPNGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNGatewayResponse, error) {
	respType := VPNGatewayResponse{VPNGateway: &VPNGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNGateway)
	if err != nil {
		return VPNGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNProfileResponsePoller provides polling facilities until the operation completes
type VPNProfileResponsePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNProfileResponseResponse will be returned.
	FinalResponse(ctx context.Context) (VPNProfileResponseResponse, error)
}

type vpnProfileResponsePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnProfileResponsePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnProfileResponsePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnProfileResponsePoller) FinalResponse(ctx context.Context) (VPNProfileResponseResponse, error) {
	respType := VPNProfileResponseResponse{VPNProfileResponse: &VPNProfileResponse{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNProfileResponse)
	if err != nil {
		return VPNProfileResponseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVPNProfileResponsePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnProfileResponsePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnProfileResponsePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNProfileResponseResponse, error) {
	respType := VPNProfileResponseResponse{VPNProfileResponse: &VPNProfileResponse{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNProfileResponse)
	if err != nil {
		return VPNProfileResponseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNServerConfigurationPoller provides polling facilities until the operation completes
type VPNServerConfigurationPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNServerConfigurationResponse will be returned.
	FinalResponse(ctx context.Context) (VPNServerConfigurationResponse, error)
}

type vpnServerConfigurationPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnServerConfigurationPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnServerConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnServerConfigurationPoller) FinalResponse(ctx context.Context) (VPNServerConfigurationResponse, error) {
	respType := VPNServerConfigurationResponse{VPNServerConfiguration: &VPNServerConfiguration{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNServerConfiguration)
	if err != nil {
		return VPNServerConfigurationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVPNServerConfigurationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnServerConfigurationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnServerConfigurationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNServerConfigurationResponse, error) {
	respType := VPNServerConfigurationResponse{VPNServerConfiguration: &VPNServerConfiguration{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNServerConfiguration)
	if err != nil {
		return VPNServerConfigurationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNServerConfigurationsResponsePoller provides polling facilities until the operation completes
type VPNServerConfigurationsResponsePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNServerConfigurationsResponseResponse will be returned.
	FinalResponse(ctx context.Context) (VPNServerConfigurationsResponseResponse, error)
}

type vpnServerConfigurationsResponsePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnServerConfigurationsResponsePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnServerConfigurationsResponsePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnServerConfigurationsResponsePoller) FinalResponse(ctx context.Context) (VPNServerConfigurationsResponseResponse, error) {
	respType := VPNServerConfigurationsResponseResponse{VPNServerConfigurationsResponse: &VPNServerConfigurationsResponse{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNServerConfigurationsResponse)
	if err != nil {
		return VPNServerConfigurationsResponseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVPNServerConfigurationsResponsePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnServerConfigurationsResponsePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnServerConfigurationsResponsePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNServerConfigurationsResponseResponse, error) {
	respType := VPNServerConfigurationsResponseResponse{VPNServerConfigurationsResponse: &VPNServerConfigurationsResponse{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNServerConfigurationsResponse)
	if err != nil {
		return VPNServerConfigurationsResponseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNSitePoller provides polling facilities until the operation completes
type VPNSitePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNSiteResponse will be returned.
	FinalResponse(ctx context.Context) (VPNSiteResponse, error)
}

type vpnSitePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *vpnSitePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *vpnSitePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *vpnSitePoller) FinalResponse(ctx context.Context) (VPNSiteResponse, error) {
	respType := VPNSiteResponse{VPNSite: &VPNSite{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNSite)
	if err != nil {
		return VPNSiteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVPNSitePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *vpnSitePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnSitePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNSiteResponse, error) {
	respType := VPNSiteResponse{VPNSite: &VPNSite{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNSite)
	if err != nil {
		return VPNSiteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VerificationIPFlowResultPoller provides polling facilities until the operation completes
type VerificationIPFlowResultPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VerificationIPFlowResultResponse will be returned.
	FinalResponse(ctx context.Context) (VerificationIPFlowResultResponse, error)
}

type verificationIPFlowResultPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *verificationIPFlowResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *verificationIPFlowResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *verificationIPFlowResultPoller) FinalResponse(ctx context.Context) (VerificationIPFlowResultResponse, error) {
	respType := VerificationIPFlowResultResponse{VerificationIPFlowResult: &VerificationIPFlowResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VerificationIPFlowResult)
	if err != nil {
		return VerificationIPFlowResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVerificationIPFlowResultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *verificationIPFlowResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *verificationIPFlowResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VerificationIPFlowResultResponse, error) {
	respType := VerificationIPFlowResultResponse{VerificationIPFlowResult: &VerificationIPFlowResult{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VerificationIPFlowResult)
	if err != nil {
		return VerificationIPFlowResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualApplianceSitePoller provides polling facilities until the operation completes
type VirtualApplianceSitePoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualApplianceSiteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualApplianceSiteResponse, error)
}

type virtualApplianceSitePoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualApplianceSitePoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualApplianceSitePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualApplianceSitePoller) FinalResponse(ctx context.Context) (VirtualApplianceSiteResponse, error) {
	respType := VirtualApplianceSiteResponse{VirtualApplianceSite: &VirtualApplianceSite{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualApplianceSite)
	if err != nil {
		return VirtualApplianceSiteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualApplianceSitePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualApplianceSitePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualApplianceSitePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualApplianceSiteResponse, error) {
	respType := VirtualApplianceSiteResponse{VirtualApplianceSite: &VirtualApplianceSite{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualApplianceSite)
	if err != nil {
		return VirtualApplianceSiteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualHubPoller provides polling facilities until the operation completes
type VirtualHubPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualHubResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualHubResponse, error)
}

type virtualHubPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualHubPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualHubPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualHubPoller) FinalResponse(ctx context.Context) (VirtualHubResponse, error) {
	respType := VirtualHubResponse{VirtualHub: &VirtualHub{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualHub)
	if err != nil {
		return VirtualHubResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualHubPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualHubPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualHubPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualHubResponse, error) {
	respType := VirtualHubResponse{VirtualHub: &VirtualHub{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualHub)
	if err != nil {
		return VirtualHubResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualHubRouteTableV2Poller provides polling facilities until the operation completes
type VirtualHubRouteTableV2Poller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualHubRouteTableV2Response will be returned.
	FinalResponse(ctx context.Context) (VirtualHubRouteTableV2Response, error)
}

type virtualHubRouteTableV2Poller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualHubRouteTableV2Poller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualHubRouteTableV2Poller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualHubRouteTableV2Poller) FinalResponse(ctx context.Context) (VirtualHubRouteTableV2Response, error) {
	respType := VirtualHubRouteTableV2Response{VirtualHubRouteTableV2: &VirtualHubRouteTableV2{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualHubRouteTableV2)
	if err != nil {
		return VirtualHubRouteTableV2Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualHubRouteTableV2Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualHubRouteTableV2Poller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualHubRouteTableV2Poller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualHubRouteTableV2Response, error) {
	respType := VirtualHubRouteTableV2Response{VirtualHubRouteTableV2: &VirtualHubRouteTableV2{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualHubRouteTableV2)
	if err != nil {
		return VirtualHubRouteTableV2Response{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewayConnectionPoller provides polling facilities until the operation completes
type VirtualNetworkGatewayConnectionPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewayConnectionResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionResponse, error)
}

type virtualNetworkGatewayConnectionPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkGatewayConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkGatewayConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualNetworkGatewayConnectionPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionResponse, error) {
	respType := VirtualNetworkGatewayConnectionResponse{VirtualNetworkGatewayConnection: &VirtualNetworkGatewayConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return VirtualNetworkGatewayConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkGatewayConnectionPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkGatewayConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewayConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualNetworkGatewayConnectionResponse, error) {
	respType := VirtualNetworkGatewayConnectionResponse{VirtualNetworkGatewayConnection: &VirtualNetworkGatewayConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return VirtualNetworkGatewayConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewayPoller provides polling facilities until the operation completes
type VirtualNetworkGatewayPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewayResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewayResponse, error)
}

type virtualNetworkGatewayPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualNetworkGatewayPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayResponse, error) {
	respType := VirtualNetworkGatewayResponse{VirtualNetworkGateway: &VirtualNetworkGateway{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetworkGateway)
	if err != nil {
		return VirtualNetworkGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkGatewayPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualNetworkGatewayResponse, error) {
	respType := VirtualNetworkGatewayResponse{VirtualNetworkGateway: &VirtualNetworkGateway{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetworkGateway)
	if err != nil {
		return VirtualNetworkGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkPeeringPoller provides polling facilities until the operation completes
type VirtualNetworkPeeringPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkPeeringResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkPeeringResponse, error)
}

type virtualNetworkPeeringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkPeeringPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualNetworkPeeringPoller) FinalResponse(ctx context.Context) (VirtualNetworkPeeringResponse, error) {
	respType := VirtualNetworkPeeringResponse{VirtualNetworkPeering: &VirtualNetworkPeering{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetworkPeering)
	if err != nil {
		return VirtualNetworkPeeringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkPeeringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkPeeringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualNetworkPeeringResponse, error) {
	respType := VirtualNetworkPeeringResponse{VirtualNetworkPeering: &VirtualNetworkPeering{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetworkPeering)
	if err != nil {
		return VirtualNetworkPeeringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkPoller provides polling facilities until the operation completes
type VirtualNetworkPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkResponse, error)
}

type virtualNetworkPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualNetworkPoller) FinalResponse(ctx context.Context) (VirtualNetworkResponse, error) {
	respType := VirtualNetworkResponse{VirtualNetwork: &VirtualNetwork{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetwork)
	if err != nil {
		return VirtualNetworkResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualNetworkResponse, error) {
	respType := VirtualNetworkResponse{VirtualNetwork: &VirtualNetwork{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetwork)
	if err != nil {
		return VirtualNetworkResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkTapPoller provides polling facilities until the operation completes
type VirtualNetworkTapPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkTapResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkTapResponse, error)
}

type virtualNetworkTapPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualNetworkTapPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualNetworkTapPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualNetworkTapPoller) FinalResponse(ctx context.Context) (VirtualNetworkTapResponse, error) {
	respType := VirtualNetworkTapResponse{VirtualNetworkTap: &VirtualNetworkTap{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetworkTap)
	if err != nil {
		return VirtualNetworkTapResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualNetworkTapPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualNetworkTapPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkTapPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualNetworkTapResponse, error) {
	respType := VirtualNetworkTapResponse{VirtualNetworkTap: &VirtualNetworkTap{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetworkTap)
	if err != nil {
		return VirtualNetworkTapResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualRouterPeeringPoller provides polling facilities until the operation completes
type VirtualRouterPeeringPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualRouterPeeringResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualRouterPeeringResponse, error)
}

type virtualRouterPeeringPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualRouterPeeringPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualRouterPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualRouterPeeringPoller) FinalResponse(ctx context.Context) (VirtualRouterPeeringResponse, error) {
	respType := VirtualRouterPeeringResponse{VirtualRouterPeering: &VirtualRouterPeering{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualRouterPeering)
	if err != nil {
		return VirtualRouterPeeringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualRouterPeeringPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualRouterPeeringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualRouterPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualRouterPeeringResponse, error) {
	respType := VirtualRouterPeeringResponse{VirtualRouterPeering: &VirtualRouterPeering{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualRouterPeering)
	if err != nil {
		return VirtualRouterPeeringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualRouterPoller provides polling facilities until the operation completes
type VirtualRouterPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualRouterResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualRouterResponse, error)
}

type virtualRouterPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualRouterPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualRouterPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualRouterPoller) FinalResponse(ctx context.Context) (VirtualRouterResponse, error) {
	respType := VirtualRouterResponse{VirtualRouter: &VirtualRouter{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualRouter)
	if err != nil {
		return VirtualRouterResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualRouterPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualRouterPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualRouterPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualRouterResponse, error) {
	respType := VirtualRouterResponse{VirtualRouter: &VirtualRouter{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualRouter)
	if err != nil {
		return VirtualRouterResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualWANPoller provides polling facilities until the operation completes
type VirtualWANPoller interface {
	azcore.Poller

	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualWANResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualWANResponse, error)
}

type virtualWANPoller struct {
	// the client for making the request
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

// Done returns true if there was an error or polling has reached a terminal state
func (p *virtualWANPoller) Done() bool {
	return p.pt.Done()
}

// Poll will send poll the service endpoint and return an http.Response or error received from the service
func (p *virtualWANPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualWANPoller) FinalResponse(ctx context.Context) (VirtualWANResponse, error) {
	respType := VirtualWANResponse{VirtualWAN: &VirtualWAN{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualWAN)
	if err != nil {
		return VirtualWANResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken generates the string token that can be used with the ResumeVirtualWANPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *virtualWANPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualWANPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualWANResponse, error) {
	respType := VirtualWANResponse{VirtualWAN: &VirtualWAN{}}
	resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualWAN)
	if err != nil {
		return VirtualWANResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}
