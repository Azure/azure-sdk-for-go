// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// ApplicationGatewayBackendHealthOnDemandPoller provides polling facilities until the operation completes
      type ApplicationGatewayBackendHealthOnDemandPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ApplicationGatewayBackendHealthOnDemandResponse will be returned.
        FinalResponse(ctx context.Context) (ApplicationGatewayBackendHealthOnDemandResponse, error)
      }

      type applicationGatewayBackendHealthOnDemandPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *applicationGatewayBackendHealthOnDemandPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *applicationGatewayBackendHealthOnDemandPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *applicationGatewayBackendHealthOnDemandPoller) FinalResponse(ctx context.Context) (ApplicationGatewayBackendHealthOnDemandResponse, error) {
      respType := ApplicationGatewayBackendHealthOnDemandResponse{ApplicationGatewayBackendHealthOnDemand: &ApplicationGatewayBackendHealthOnDemand{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationGatewayBackendHealthOnDemand)
		if err != nil {
			return ApplicationGatewayBackendHealthOnDemandResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeApplicationGatewayBackendHealthOnDemandPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *applicationGatewayBackendHealthOnDemandPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *applicationGatewayBackendHealthOnDemandPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ApplicationGatewayBackendHealthOnDemandResponse, error) {
      respType := ApplicationGatewayBackendHealthOnDemandResponse{ApplicationGatewayBackendHealthOnDemand: &ApplicationGatewayBackendHealthOnDemand{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationGatewayBackendHealthOnDemand)
		if err != nil {
			return ApplicationGatewayBackendHealthOnDemandResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ApplicationGatewayBackendHealthPoller provides polling facilities until the operation completes
      type ApplicationGatewayBackendHealthPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ApplicationGatewayBackendHealthResponse will be returned.
        FinalResponse(ctx context.Context) (ApplicationGatewayBackendHealthResponse, error)
      }

      type applicationGatewayBackendHealthPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *applicationGatewayBackendHealthPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *applicationGatewayBackendHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *applicationGatewayBackendHealthPoller) FinalResponse(ctx context.Context) (ApplicationGatewayBackendHealthResponse, error) {
      respType := ApplicationGatewayBackendHealthResponse{ApplicationGatewayBackendHealth: &ApplicationGatewayBackendHealth{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationGatewayBackendHealth)
		if err != nil {
			return ApplicationGatewayBackendHealthResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeApplicationGatewayBackendHealthPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *applicationGatewayBackendHealthPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *applicationGatewayBackendHealthPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ApplicationGatewayBackendHealthResponse, error) {
      respType := ApplicationGatewayBackendHealthResponse{ApplicationGatewayBackendHealth: &ApplicationGatewayBackendHealth{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationGatewayBackendHealth)
		if err != nil {
			return ApplicationGatewayBackendHealthResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ApplicationGatewayPoller provides polling facilities until the operation completes
      type ApplicationGatewayPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ApplicationGatewayResponse will be returned.
        FinalResponse(ctx context.Context) (ApplicationGatewayResponse, error)
      }

      type applicationGatewayPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *applicationGatewayPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *applicationGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *applicationGatewayPoller) FinalResponse(ctx context.Context) (ApplicationGatewayResponse, error) {
      respType := ApplicationGatewayResponse{ApplicationGateway: &ApplicationGateway{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationGateway)
		if err != nil {
			return ApplicationGatewayResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeApplicationGatewayPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *applicationGatewayPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *applicationGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ApplicationGatewayResponse, error) {
      respType := ApplicationGatewayResponse{ApplicationGateway: &ApplicationGateway{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationGateway)
		if err != nil {
			return ApplicationGatewayResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ApplicationGatewayPrivateEndpointConnectionPoller provides polling facilities until the operation completes
      type ApplicationGatewayPrivateEndpointConnectionPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ApplicationGatewayPrivateEndpointConnectionResponse will be returned.
        FinalResponse(ctx context.Context) (ApplicationGatewayPrivateEndpointConnectionResponse, error)
      }

      type applicationGatewayPrivateEndpointConnectionPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *applicationGatewayPrivateEndpointConnectionPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *applicationGatewayPrivateEndpointConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *applicationGatewayPrivateEndpointConnectionPoller) FinalResponse(ctx context.Context) (ApplicationGatewayPrivateEndpointConnectionResponse, error) {
      respType := ApplicationGatewayPrivateEndpointConnectionResponse{ApplicationGatewayPrivateEndpointConnection: &ApplicationGatewayPrivateEndpointConnection{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationGatewayPrivateEndpointConnection)
		if err != nil {
			return ApplicationGatewayPrivateEndpointConnectionResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeApplicationGatewayPrivateEndpointConnectionPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *applicationGatewayPrivateEndpointConnectionPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *applicationGatewayPrivateEndpointConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ApplicationGatewayPrivateEndpointConnectionResponse, error) {
      respType := ApplicationGatewayPrivateEndpointConnectionResponse{ApplicationGatewayPrivateEndpointConnection: &ApplicationGatewayPrivateEndpointConnection{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationGatewayPrivateEndpointConnection)
		if err != nil {
			return ApplicationGatewayPrivateEndpointConnectionResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ApplicationSecurityGroupPoller provides polling facilities until the operation completes
      type ApplicationSecurityGroupPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ApplicationSecurityGroupResponse will be returned.
        FinalResponse(ctx context.Context) (ApplicationSecurityGroupResponse, error)
      }

      type applicationSecurityGroupPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *applicationSecurityGroupPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *applicationSecurityGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *applicationSecurityGroupPoller) FinalResponse(ctx context.Context) (ApplicationSecurityGroupResponse, error) {
      respType := ApplicationSecurityGroupResponse{ApplicationSecurityGroup: &ApplicationSecurityGroup{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ApplicationSecurityGroup)
		if err != nil {
			return ApplicationSecurityGroupResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeApplicationSecurityGroupPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *applicationSecurityGroupPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *applicationSecurityGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ApplicationSecurityGroupResponse, error) {
      respType := ApplicationSecurityGroupResponse{ApplicationSecurityGroup: &ApplicationSecurityGroup{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ApplicationSecurityGroup)
		if err != nil {
			return ApplicationSecurityGroupResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // AvailableProvidersListPoller provides polling facilities until the operation completes
      type AvailableProvidersListPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final AvailableProvidersListResponse will be returned.
        FinalResponse(ctx context.Context) (AvailableProvidersListResponse, error)
      }

      type availableProvidersListPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *availableProvidersListPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *availableProvidersListPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *availableProvidersListPoller) FinalResponse(ctx context.Context) (AvailableProvidersListResponse, error) {
      respType := AvailableProvidersListResponse{AvailableProvidersList: &AvailableProvidersList{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.AvailableProvidersList)
		if err != nil {
			return AvailableProvidersListResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeAvailableProvidersListPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *availableProvidersListPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *availableProvidersListPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (AvailableProvidersListResponse, error) {
      respType := AvailableProvidersListResponse{AvailableProvidersList: &AvailableProvidersList{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.AvailableProvidersList)
		if err != nil {
			return AvailableProvidersListResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // AzureFirewallPoller provides polling facilities until the operation completes
      type AzureFirewallPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final AzureFirewallResponse will be returned.
        FinalResponse(ctx context.Context) (AzureFirewallResponse, error)
      }

      type azureFirewallPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *azureFirewallPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *azureFirewallPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *azureFirewallPoller) FinalResponse(ctx context.Context) (AzureFirewallResponse, error) {
      respType := AzureFirewallResponse{AzureFirewall: &AzureFirewall{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.AzureFirewall)
		if err != nil {
			return AzureFirewallResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeAzureFirewallPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *azureFirewallPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *azureFirewallPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (AzureFirewallResponse, error) {
      respType := AzureFirewallResponse{AzureFirewall: &AzureFirewall{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.AzureFirewall)
		if err != nil {
			return AzureFirewallResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // AzureReachabilityReportPoller provides polling facilities until the operation completes
      type AzureReachabilityReportPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final AzureReachabilityReportResponse will be returned.
        FinalResponse(ctx context.Context) (AzureReachabilityReportResponse, error)
      }

      type azureReachabilityReportPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *azureReachabilityReportPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *azureReachabilityReportPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *azureReachabilityReportPoller) FinalResponse(ctx context.Context) (AzureReachabilityReportResponse, error) {
      respType := AzureReachabilityReportResponse{AzureReachabilityReport: &AzureReachabilityReport{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.AzureReachabilityReport)
		if err != nil {
			return AzureReachabilityReportResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeAzureReachabilityReportPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *azureReachabilityReportPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *azureReachabilityReportPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (AzureReachabilityReportResponse, error) {
      respType := AzureReachabilityReportResponse{AzureReachabilityReport: &AzureReachabilityReport{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.AzureReachabilityReport)
		if err != nil {
			return AzureReachabilityReportResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // BackendAddressPoolPoller provides polling facilities until the operation completes
      type BackendAddressPoolPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final BackendAddressPoolResponse will be returned.
        FinalResponse(ctx context.Context) (BackendAddressPoolResponse, error)
      }

      type backendAddressPoolPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *backendAddressPoolPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *backendAddressPoolPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *backendAddressPoolPoller) FinalResponse(ctx context.Context) (BackendAddressPoolResponse, error) {
      respType := BackendAddressPoolResponse{BackendAddressPool: &BackendAddressPool{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.BackendAddressPool)
		if err != nil {
			return BackendAddressPoolResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeBackendAddressPoolPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *backendAddressPoolPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *backendAddressPoolPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BackendAddressPoolResponse, error) {
      respType := BackendAddressPoolResponse{BackendAddressPool: &BackendAddressPool{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.BackendAddressPool)
		if err != nil {
			return BackendAddressPoolResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // BastionActiveSessionListResultPagerPoller provides polling facilities until the operation completes
      type BastionActiveSessionListResultPagerPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final BastionActiveSessionListResultPager will be returned.
        FinalResponse(ctx context.Context) (BastionActiveSessionListResultPager, error)
      }

      type bastionActiveSessionListResultPagerPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
      errHandler  bastionActiveSessionListResultHandleError
      respHandler bastionActiveSessionListResultHandleResponse
      statusCodes []int
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *bastionActiveSessionListResultPagerPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *bastionActiveSessionListResultPagerPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *bastionActiveSessionListResultPagerPoller) FinalResponse(ctx context.Context) (BastionActiveSessionListResultPager, error) {
      respType := &bastionActiveSessionListResultPager{}
                resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType)
                if err != nil {
                  return nil, err
                }
                return p.handleResponse(&azcore.Response{Response: resp})
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeBastionActiveSessionListResultPagerPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *bastionActiveSessionListResultPagerPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *bastionActiveSessionListResultPagerPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BastionActiveSessionListResultPager, error) {
      respType := &bastionActiveSessionListResultPager{}
                resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType)
                if err != nil {
                  return nil, err
                }
                return p.handleResponse(&azcore.Response{Response: resp})
      }
  
      func (p *bastionActiveSessionListResultPagerPoller) handleResponse(resp *azcore.Response) (BastionActiveSessionListResultPager, error) {
        	return &bastionActiveSessionListResultPager{
		pipeline: p.pipeline,
		resp: resp,
		errorer: p.errHandler,
		responder: p.respHandler,
		advancer: func(ctx context.Context, resp BastionActiveSessionListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.BastionActiveSessionListResult.NextLink)
		},
		statusCodes: p.statusCodes,
	}, nil
      }
      
  // BastionHostPoller provides polling facilities until the operation completes
      type BastionHostPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final BastionHostResponse will be returned.
        FinalResponse(ctx context.Context) (BastionHostResponse, error)
      }

      type bastionHostPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *bastionHostPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *bastionHostPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *bastionHostPoller) FinalResponse(ctx context.Context) (BastionHostResponse, error) {
      respType := BastionHostResponse{BastionHost: &BastionHost{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.BastionHost)
		if err != nil {
			return BastionHostResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeBastionHostPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *bastionHostPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *bastionHostPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BastionHostResponse, error) {
      respType := BastionHostResponse{BastionHost: &BastionHost{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.BastionHost)
		if err != nil {
			return BastionHostResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // BastionShareableLinkListResultPagerPoller provides polling facilities until the operation completes
      type BastionShareableLinkListResultPagerPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final BastionShareableLinkListResultPager will be returned.
        FinalResponse(ctx context.Context) (BastionShareableLinkListResultPager, error)
      }

      type bastionShareableLinkListResultPagerPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
      errHandler  bastionShareableLinkListResultHandleError
      respHandler bastionShareableLinkListResultHandleResponse
      statusCodes []int
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *bastionShareableLinkListResultPagerPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *bastionShareableLinkListResultPagerPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *bastionShareableLinkListResultPagerPoller) FinalResponse(ctx context.Context) (BastionShareableLinkListResultPager, error) {
      respType := &bastionShareableLinkListResultPager{}
                resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType)
                if err != nil {
                  return nil, err
                }
                return p.handleResponse(&azcore.Response{Response: resp})
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeBastionShareableLinkListResultPagerPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *bastionShareableLinkListResultPagerPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *bastionShareableLinkListResultPagerPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BastionShareableLinkListResultPager, error) {
      respType := &bastionShareableLinkListResultPager{}
                resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType)
                if err != nil {
                  return nil, err
                }
                return p.handleResponse(&azcore.Response{Response: resp})
      }
  
      func (p *bastionShareableLinkListResultPagerPoller) handleResponse(resp *azcore.Response) (BastionShareableLinkListResultPager, error) {
        	return &bastionShareableLinkListResultPager{
		pipeline: p.pipeline,
		resp: resp,
		errorer: p.errHandler,
		responder: p.respHandler,
		advancer: func(ctx context.Context, resp BastionShareableLinkListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.BastionShareableLinkListResult.NextLink)
		},
		statusCodes: p.statusCodes,
	}, nil
      }
      
  // BgpConnectionPoller provides polling facilities until the operation completes
      type BgpConnectionPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final BgpConnectionResponse will be returned.
        FinalResponse(ctx context.Context) (BgpConnectionResponse, error)
      }

      type bgpConnectionPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *bgpConnectionPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *bgpConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *bgpConnectionPoller) FinalResponse(ctx context.Context) (BgpConnectionResponse, error) {
      respType := BgpConnectionResponse{BgpConnection: &BgpConnection{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.BgpConnection)
		if err != nil {
			return BgpConnectionResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeBgpConnectionPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *bgpConnectionPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *bgpConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BgpConnectionResponse, error) {
      respType := BgpConnectionResponse{BgpConnection: &BgpConnection{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.BgpConnection)
		if err != nil {
			return BgpConnectionResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // BgpPeerStatusListResultPoller provides polling facilities until the operation completes
      type BgpPeerStatusListResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final BgpPeerStatusListResultResponse will be returned.
        FinalResponse(ctx context.Context) (BgpPeerStatusListResultResponse, error)
      }

      type bgpPeerStatusListResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *bgpPeerStatusListResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *bgpPeerStatusListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *bgpPeerStatusListResultPoller) FinalResponse(ctx context.Context) (BgpPeerStatusListResultResponse, error) {
      respType := BgpPeerStatusListResultResponse{BgpPeerStatusListResult: &BgpPeerStatusListResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.BgpPeerStatusListResult)
		if err != nil {
			return BgpPeerStatusListResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeBgpPeerStatusListResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *bgpPeerStatusListResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *bgpPeerStatusListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (BgpPeerStatusListResultResponse, error) {
      respType := BgpPeerStatusListResultResponse{BgpPeerStatusListResult: &BgpPeerStatusListResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.BgpPeerStatusListResult)
		if err != nil {
			return BgpPeerStatusListResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ConnectionMonitorQueryResultPoller provides polling facilities until the operation completes
      type ConnectionMonitorQueryResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ConnectionMonitorQueryResultResponse will be returned.
        FinalResponse(ctx context.Context) (ConnectionMonitorQueryResultResponse, error)
      }

      type connectionMonitorQueryResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *connectionMonitorQueryResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *connectionMonitorQueryResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *connectionMonitorQueryResultPoller) FinalResponse(ctx context.Context) (ConnectionMonitorQueryResultResponse, error) {
      respType := ConnectionMonitorQueryResultResponse{ConnectionMonitorQueryResult: &ConnectionMonitorQueryResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectionMonitorQueryResult)
		if err != nil {
			return ConnectionMonitorQueryResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeConnectionMonitorQueryResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *connectionMonitorQueryResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *connectionMonitorQueryResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ConnectionMonitorQueryResultResponse, error) {
      respType := ConnectionMonitorQueryResultResponse{ConnectionMonitorQueryResult: &ConnectionMonitorQueryResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectionMonitorQueryResult)
		if err != nil {
			return ConnectionMonitorQueryResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ConnectionMonitorResultPoller provides polling facilities until the operation completes
      type ConnectionMonitorResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ConnectionMonitorResultResponse will be returned.
        FinalResponse(ctx context.Context) (ConnectionMonitorResultResponse, error)
      }

      type connectionMonitorResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *connectionMonitorResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *connectionMonitorResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *connectionMonitorResultPoller) FinalResponse(ctx context.Context) (ConnectionMonitorResultResponse, error) {
      respType := ConnectionMonitorResultResponse{ConnectionMonitorResult: &ConnectionMonitorResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectionMonitorResult)
		if err != nil {
			return ConnectionMonitorResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeConnectionMonitorResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *connectionMonitorResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *connectionMonitorResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ConnectionMonitorResultResponse, error) {
      respType := ConnectionMonitorResultResponse{ConnectionMonitorResult: &ConnectionMonitorResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectionMonitorResult)
		if err != nil {
			return ConnectionMonitorResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ConnectionResetSharedKeyPoller provides polling facilities until the operation completes
      type ConnectionResetSharedKeyPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ConnectionResetSharedKeyResponse will be returned.
        FinalResponse(ctx context.Context) (ConnectionResetSharedKeyResponse, error)
      }

      type connectionResetSharedKeyPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *connectionResetSharedKeyPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *connectionResetSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *connectionResetSharedKeyPoller) FinalResponse(ctx context.Context) (ConnectionResetSharedKeyResponse, error) {
      respType := ConnectionResetSharedKeyResponse{ConnectionResetSharedKey: &ConnectionResetSharedKey{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectionResetSharedKey)
		if err != nil {
			return ConnectionResetSharedKeyResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeConnectionResetSharedKeyPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *connectionResetSharedKeyPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *connectionResetSharedKeyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ConnectionResetSharedKeyResponse, error) {
      respType := ConnectionResetSharedKeyResponse{ConnectionResetSharedKey: &ConnectionResetSharedKey{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectionResetSharedKey)
		if err != nil {
			return ConnectionResetSharedKeyResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ConnectionSharedKeyPoller provides polling facilities until the operation completes
      type ConnectionSharedKeyPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ConnectionSharedKeyResponse will be returned.
        FinalResponse(ctx context.Context) (ConnectionSharedKeyResponse, error)
      }

      type connectionSharedKeyPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *connectionSharedKeyPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *connectionSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *connectionSharedKeyPoller) FinalResponse(ctx context.Context) (ConnectionSharedKeyResponse, error) {
      respType := ConnectionSharedKeyResponse{ConnectionSharedKey: &ConnectionSharedKey{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectionSharedKey)
		if err != nil {
			return ConnectionSharedKeyResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeConnectionSharedKeyPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *connectionSharedKeyPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *connectionSharedKeyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ConnectionSharedKeyResponse, error) {
      respType := ConnectionSharedKeyResponse{ConnectionSharedKey: &ConnectionSharedKey{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectionSharedKey)
		if err != nil {
			return ConnectionSharedKeyResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ConnectivityInformationPoller provides polling facilities until the operation completes
      type ConnectivityInformationPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ConnectivityInformationResponse will be returned.
        FinalResponse(ctx context.Context) (ConnectivityInformationResponse, error)
      }

      type connectivityInformationPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *connectivityInformationPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *connectivityInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *connectivityInformationPoller) FinalResponse(ctx context.Context) (ConnectivityInformationResponse, error) {
      respType := ConnectivityInformationResponse{ConnectivityInformation: &ConnectivityInformation{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ConnectivityInformation)
		if err != nil {
			return ConnectivityInformationResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeConnectivityInformationPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *connectivityInformationPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *connectivityInformationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ConnectivityInformationResponse, error) {
      respType := ConnectivityInformationResponse{ConnectivityInformation: &ConnectivityInformation{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ConnectivityInformation)
		if err != nil {
			return ConnectivityInformationResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // CustomIPPrefixPoller provides polling facilities until the operation completes
      type CustomIPPrefixPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final CustomIPPrefixResponse will be returned.
        FinalResponse(ctx context.Context) (CustomIPPrefixResponse, error)
      }

      type customIPPrefixPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *customIPPrefixPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *customIPPrefixPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *customIPPrefixPoller) FinalResponse(ctx context.Context) (CustomIPPrefixResponse, error) {
      respType := CustomIPPrefixResponse{CustomIPPrefix: &CustomIPPrefix{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.CustomIPPrefix)
		if err != nil {
			return CustomIPPrefixResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeCustomIPPrefixPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *customIPPrefixPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *customIPPrefixPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (CustomIPPrefixResponse, error) {
      respType := CustomIPPrefixResponse{CustomIPPrefix: &CustomIPPrefix{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.CustomIPPrefix)
		if err != nil {
			return CustomIPPrefixResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // DdosCustomPolicyPoller provides polling facilities until the operation completes
      type DdosCustomPolicyPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final DdosCustomPolicyResponse will be returned.
        FinalResponse(ctx context.Context) (DdosCustomPolicyResponse, error)
      }

      type ddosCustomPolicyPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *ddosCustomPolicyPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *ddosCustomPolicyPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *ddosCustomPolicyPoller) FinalResponse(ctx context.Context) (DdosCustomPolicyResponse, error) {
      respType := DdosCustomPolicyResponse{DdosCustomPolicy: &DdosCustomPolicy{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.DdosCustomPolicy)
		if err != nil {
			return DdosCustomPolicyResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeDdosCustomPolicyPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *ddosCustomPolicyPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *ddosCustomPolicyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (DdosCustomPolicyResponse, error) {
      respType := DdosCustomPolicyResponse{DdosCustomPolicy: &DdosCustomPolicy{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.DdosCustomPolicy)
		if err != nil {
			return DdosCustomPolicyResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // DdosProtectionPlanPoller provides polling facilities until the operation completes
      type DdosProtectionPlanPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final DdosProtectionPlanResponse will be returned.
        FinalResponse(ctx context.Context) (DdosProtectionPlanResponse, error)
      }

      type ddosProtectionPlanPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *ddosProtectionPlanPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *ddosProtectionPlanPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *ddosProtectionPlanPoller) FinalResponse(ctx context.Context) (DdosProtectionPlanResponse, error) {
      respType := DdosProtectionPlanResponse{DdosProtectionPlan: &DdosProtectionPlan{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.DdosProtectionPlan)
		if err != nil {
			return DdosProtectionPlanResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeDdosProtectionPlanPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *ddosProtectionPlanPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *ddosProtectionPlanPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (DdosProtectionPlanResponse, error) {
      respType := DdosProtectionPlanResponse{DdosProtectionPlan: &DdosProtectionPlan{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.DdosProtectionPlan)
		if err != nil {
			return DdosProtectionPlanResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // DscpConfigurationPoller provides polling facilities until the operation completes
      type DscpConfigurationPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final DscpConfigurationResponse will be returned.
        FinalResponse(ctx context.Context) (DscpConfigurationResponse, error)
      }

      type dscpConfigurationPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *dscpConfigurationPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *dscpConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *dscpConfigurationPoller) FinalResponse(ctx context.Context) (DscpConfigurationResponse, error) {
      respType := DscpConfigurationResponse{DscpConfiguration: &DscpConfiguration{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.DscpConfiguration)
		if err != nil {
			return DscpConfigurationResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeDscpConfigurationPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *dscpConfigurationPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *dscpConfigurationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (DscpConfigurationResponse, error) {
      respType := DscpConfigurationResponse{DscpConfiguration: &DscpConfiguration{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.DscpConfiguration)
		if err != nil {
			return DscpConfigurationResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // EffectiveNetworkSecurityGroupListResultPoller provides polling facilities until the operation completes
      type EffectiveNetworkSecurityGroupListResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final EffectiveNetworkSecurityGroupListResultResponse will be returned.
        FinalResponse(ctx context.Context) (EffectiveNetworkSecurityGroupListResultResponse, error)
      }

      type effectiveNetworkSecurityGroupListResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *effectiveNetworkSecurityGroupListResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *effectiveNetworkSecurityGroupListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *effectiveNetworkSecurityGroupListResultPoller) FinalResponse(ctx context.Context) (EffectiveNetworkSecurityGroupListResultResponse, error) {
      respType := EffectiveNetworkSecurityGroupListResultResponse{EffectiveNetworkSecurityGroupListResult: &EffectiveNetworkSecurityGroupListResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.EffectiveNetworkSecurityGroupListResult)
		if err != nil {
			return EffectiveNetworkSecurityGroupListResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeEffectiveNetworkSecurityGroupListResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *effectiveNetworkSecurityGroupListResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *effectiveNetworkSecurityGroupListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (EffectiveNetworkSecurityGroupListResultResponse, error) {
      respType := EffectiveNetworkSecurityGroupListResultResponse{EffectiveNetworkSecurityGroupListResult: &EffectiveNetworkSecurityGroupListResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.EffectiveNetworkSecurityGroupListResult)
		if err != nil {
			return EffectiveNetworkSecurityGroupListResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // EffectiveRouteListResultPoller provides polling facilities until the operation completes
      type EffectiveRouteListResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final EffectiveRouteListResultResponse will be returned.
        FinalResponse(ctx context.Context) (EffectiveRouteListResultResponse, error)
      }

      type effectiveRouteListResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *effectiveRouteListResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *effectiveRouteListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *effectiveRouteListResultPoller) FinalResponse(ctx context.Context) (EffectiveRouteListResultResponse, error) {
      respType := EffectiveRouteListResultResponse{EffectiveRouteListResult: &EffectiveRouteListResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.EffectiveRouteListResult)
		if err != nil {
			return EffectiveRouteListResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeEffectiveRouteListResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *effectiveRouteListResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *effectiveRouteListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (EffectiveRouteListResultResponse, error) {
      respType := EffectiveRouteListResultResponse{EffectiveRouteListResult: &EffectiveRouteListResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.EffectiveRouteListResult)
		if err != nil {
			return EffectiveRouteListResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRouteCircuitAuthorizationPoller provides polling facilities until the operation completes
      type ExpressRouteCircuitAuthorizationPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRouteCircuitAuthorizationResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRouteCircuitAuthorizationResponse, error)
      }

      type expressRouteCircuitAuthorizationPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRouteCircuitAuthorizationPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRouteCircuitAuthorizationPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRouteCircuitAuthorizationPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitAuthorizationResponse, error) {
      respType := ExpressRouteCircuitAuthorizationResponse{ExpressRouteCircuitAuthorization: &ExpressRouteCircuitAuthorization{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitAuthorization)
		if err != nil {
			return ExpressRouteCircuitAuthorizationResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitAuthorizationPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRouteCircuitAuthorizationPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRouteCircuitAuthorizationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitAuthorizationResponse, error) {
      respType := ExpressRouteCircuitAuthorizationResponse{ExpressRouteCircuitAuthorization: &ExpressRouteCircuitAuthorization{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitAuthorization)
		if err != nil {
			return ExpressRouteCircuitAuthorizationResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRouteCircuitConnectionPoller provides polling facilities until the operation completes
      type ExpressRouteCircuitConnectionPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRouteCircuitConnectionResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRouteCircuitConnectionResponse, error)
      }

      type expressRouteCircuitConnectionPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRouteCircuitConnectionPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRouteCircuitConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRouteCircuitConnectionPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitConnectionResponse, error) {
      respType := ExpressRouteCircuitConnectionResponse{ExpressRouteCircuitConnection: &ExpressRouteCircuitConnection{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitConnection)
		if err != nil {
			return ExpressRouteCircuitConnectionResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitConnectionPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRouteCircuitConnectionPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRouteCircuitConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitConnectionResponse, error) {
      respType := ExpressRouteCircuitConnectionResponse{ExpressRouteCircuitConnection: &ExpressRouteCircuitConnection{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitConnection)
		if err != nil {
			return ExpressRouteCircuitConnectionResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRouteCircuitPeeringPoller provides polling facilities until the operation completes
      type ExpressRouteCircuitPeeringPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRouteCircuitPeeringResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRouteCircuitPeeringResponse, error)
      }

      type expressRouteCircuitPeeringPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRouteCircuitPeeringPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRouteCircuitPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRouteCircuitPeeringPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitPeeringResponse, error) {
      respType := ExpressRouteCircuitPeeringResponse{ExpressRouteCircuitPeering: &ExpressRouteCircuitPeering{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitPeering)
		if err != nil {
			return ExpressRouteCircuitPeeringResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitPeeringPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRouteCircuitPeeringPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRouteCircuitPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitPeeringResponse, error) {
      respType := ExpressRouteCircuitPeeringResponse{ExpressRouteCircuitPeering: &ExpressRouteCircuitPeering{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitPeering)
		if err != nil {
			return ExpressRouteCircuitPeeringResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRouteCircuitPoller provides polling facilities until the operation completes
      type ExpressRouteCircuitPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRouteCircuitResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRouteCircuitResponse, error)
      }

      type expressRouteCircuitPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRouteCircuitPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRouteCircuitPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRouteCircuitPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitResponse, error) {
      respType := ExpressRouteCircuitResponse{ExpressRouteCircuit: &ExpressRouteCircuit{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuit)
		if err != nil {
			return ExpressRouteCircuitResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRouteCircuitPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRouteCircuitPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitResponse, error) {
      respType := ExpressRouteCircuitResponse{ExpressRouteCircuit: &ExpressRouteCircuit{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuit)
		if err != nil {
			return ExpressRouteCircuitResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRouteCircuitsArpTableListResultPoller provides polling facilities until the operation completes
      type ExpressRouteCircuitsArpTableListResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRouteCircuitsArpTableListResultResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRouteCircuitsArpTableListResultResponse, error)
      }

      type expressRouteCircuitsArpTableListResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRouteCircuitsArpTableListResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRouteCircuitsArpTableListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRouteCircuitsArpTableListResultPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsArpTableListResultResponse, error) {
      respType := ExpressRouteCircuitsArpTableListResultResponse{ExpressRouteCircuitsArpTableListResult: &ExpressRouteCircuitsArpTableListResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitsArpTableListResult)
		if err != nil {
			return ExpressRouteCircuitsArpTableListResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitsArpTableListResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRouteCircuitsArpTableListResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRouteCircuitsArpTableListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitsArpTableListResultResponse, error) {
      respType := ExpressRouteCircuitsArpTableListResultResponse{ExpressRouteCircuitsArpTableListResult: &ExpressRouteCircuitsArpTableListResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitsArpTableListResult)
		if err != nil {
			return ExpressRouteCircuitsArpTableListResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRouteCircuitsRoutesTableListResultPoller provides polling facilities until the operation completes
      type ExpressRouteCircuitsRoutesTableListResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRouteCircuitsRoutesTableListResultResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRouteCircuitsRoutesTableListResultResponse, error)
      }

      type expressRouteCircuitsRoutesTableListResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRouteCircuitsRoutesTableListResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRouteCircuitsRoutesTableListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRouteCircuitsRoutesTableListResultPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsRoutesTableListResultResponse, error) {
      respType := ExpressRouteCircuitsRoutesTableListResultResponse{ExpressRouteCircuitsRoutesTableListResult: &ExpressRouteCircuitsRoutesTableListResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitsRoutesTableListResult)
		if err != nil {
			return ExpressRouteCircuitsRoutesTableListResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitsRoutesTableListResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRouteCircuitsRoutesTableListResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRouteCircuitsRoutesTableListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitsRoutesTableListResultResponse, error) {
      respType := ExpressRouteCircuitsRoutesTableListResultResponse{ExpressRouteCircuitsRoutesTableListResult: &ExpressRouteCircuitsRoutesTableListResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitsRoutesTableListResult)
		if err != nil {
			return ExpressRouteCircuitsRoutesTableListResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRouteCircuitsRoutesTableSummaryListResultPoller provides polling facilities until the operation completes
      type ExpressRouteCircuitsRoutesTableSummaryListResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRouteCircuitsRoutesTableSummaryListResultResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error)
      }

      type expressRouteCircuitsRoutesTableSummaryListResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error) {
      respType := ExpressRouteCircuitsRoutesTableSummaryListResultResponse{ExpressRouteCircuitsRoutesTableSummaryListResult: &ExpressRouteCircuitsRoutesTableSummaryListResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCircuitsRoutesTableSummaryListResult)
		if err != nil {
			return ExpressRouteCircuitsRoutesTableSummaryListResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRouteCircuitsRoutesTableSummaryListResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRouteCircuitsRoutesTableSummaryListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCircuitsRoutesTableSummaryListResultResponse, error) {
      respType := ExpressRouteCircuitsRoutesTableSummaryListResultResponse{ExpressRouteCircuitsRoutesTableSummaryListResult: &ExpressRouteCircuitsRoutesTableSummaryListResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCircuitsRoutesTableSummaryListResult)
		if err != nil {
			return ExpressRouteCircuitsRoutesTableSummaryListResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRouteConnectionPoller provides polling facilities until the operation completes
      type ExpressRouteConnectionPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRouteConnectionResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRouteConnectionResponse, error)
      }

      type expressRouteConnectionPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRouteConnectionPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRouteConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRouteConnectionPoller) FinalResponse(ctx context.Context) (ExpressRouteConnectionResponse, error) {
      respType := ExpressRouteConnectionResponse{ExpressRouteConnection: &ExpressRouteConnection{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteConnection)
		if err != nil {
			return ExpressRouteConnectionResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRouteConnectionPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRouteConnectionPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRouteConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteConnectionResponse, error) {
      respType := ExpressRouteConnectionResponse{ExpressRouteConnection: &ExpressRouteConnection{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteConnection)
		if err != nil {
			return ExpressRouteConnectionResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRouteCrossConnectionPeeringPoller provides polling facilities until the operation completes
      type ExpressRouteCrossConnectionPeeringPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRouteCrossConnectionPeeringResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionPeeringResponse, error)
      }

      type expressRouteCrossConnectionPeeringPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRouteCrossConnectionPeeringPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRouteCrossConnectionPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRouteCrossConnectionPeeringPoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionPeeringResponse, error) {
      respType := ExpressRouteCrossConnectionPeeringResponse{ExpressRouteCrossConnectionPeering: &ExpressRouteCrossConnectionPeering{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCrossConnectionPeering)
		if err != nil {
			return ExpressRouteCrossConnectionPeeringResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRouteCrossConnectionPeeringPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRouteCrossConnectionPeeringPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRouteCrossConnectionPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCrossConnectionPeeringResponse, error) {
      respType := ExpressRouteCrossConnectionPeeringResponse{ExpressRouteCrossConnectionPeering: &ExpressRouteCrossConnectionPeering{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCrossConnectionPeering)
		if err != nil {
			return ExpressRouteCrossConnectionPeeringResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRouteCrossConnectionPoller provides polling facilities until the operation completes
      type ExpressRouteCrossConnectionPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRouteCrossConnectionResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionResponse, error)
      }

      type expressRouteCrossConnectionPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRouteCrossConnectionPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRouteCrossConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRouteCrossConnectionPoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionResponse, error) {
      respType := ExpressRouteCrossConnectionResponse{ExpressRouteCrossConnection: &ExpressRouteCrossConnection{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCrossConnection)
		if err != nil {
			return ExpressRouteCrossConnectionResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRouteCrossConnectionPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRouteCrossConnectionPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRouteCrossConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCrossConnectionResponse, error) {
      respType := ExpressRouteCrossConnectionResponse{ExpressRouteCrossConnection: &ExpressRouteCrossConnection{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCrossConnection)
		if err != nil {
			return ExpressRouteCrossConnectionResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRouteCrossConnectionsRoutesTableSummaryListResultPoller provides polling facilities until the operation completes
      type ExpressRouteCrossConnectionsRoutesTableSummaryListResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error)
      }

      type expressRouteCrossConnectionsRoutesTableSummaryListResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error) {
      respType := ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse{ExpressRouteCrossConnectionsRoutesTableSummaryListResult: &ExpressRouteCrossConnectionsRoutesTableSummaryListResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
		if err != nil {
			return ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRouteCrossConnectionsRoutesTableSummaryListResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRouteCrossConnectionsRoutesTableSummaryListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse, error) {
      respType := ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse{ExpressRouteCrossConnectionsRoutesTableSummaryListResult: &ExpressRouteCrossConnectionsRoutesTableSummaryListResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
		if err != nil {
			return ExpressRouteCrossConnectionsRoutesTableSummaryListResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRouteGatewayPoller provides polling facilities until the operation completes
      type ExpressRouteGatewayPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRouteGatewayResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRouteGatewayResponse, error)
      }

      type expressRouteGatewayPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRouteGatewayPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRouteGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRouteGatewayPoller) FinalResponse(ctx context.Context) (ExpressRouteGatewayResponse, error) {
      respType := ExpressRouteGatewayResponse{ExpressRouteGateway: &ExpressRouteGateway{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRouteGateway)
		if err != nil {
			return ExpressRouteGatewayResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRouteGatewayPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRouteGatewayPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRouteGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRouteGatewayResponse, error) {
      respType := ExpressRouteGatewayResponse{ExpressRouteGateway: &ExpressRouteGateway{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRouteGateway)
		if err != nil {
			return ExpressRouteGatewayResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ExpressRoutePortPoller provides polling facilities until the operation completes
      type ExpressRoutePortPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ExpressRoutePortResponse will be returned.
        FinalResponse(ctx context.Context) (ExpressRoutePortResponse, error)
      }

      type expressRoutePortPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *expressRoutePortPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *expressRoutePortPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *expressRoutePortPoller) FinalResponse(ctx context.Context) (ExpressRoutePortResponse, error) {
      respType := ExpressRoutePortResponse{ExpressRoutePort: &ExpressRoutePort{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ExpressRoutePort)
		if err != nil {
			return ExpressRoutePortResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeExpressRoutePortPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *expressRoutePortPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *expressRoutePortPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ExpressRoutePortResponse, error) {
      respType := ExpressRoutePortResponse{ExpressRoutePort: &ExpressRoutePort{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ExpressRoutePort)
		if err != nil {
			return ExpressRoutePortResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // FirewallPolicyPoller provides polling facilities until the operation completes
      type FirewallPolicyPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final FirewallPolicyResponse will be returned.
        FinalResponse(ctx context.Context) (FirewallPolicyResponse, error)
      }

      type firewallPolicyPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *firewallPolicyPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *firewallPolicyPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *firewallPolicyPoller) FinalResponse(ctx context.Context) (FirewallPolicyResponse, error) {
      respType := FirewallPolicyResponse{FirewallPolicy: &FirewallPolicy{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.FirewallPolicy)
		if err != nil {
			return FirewallPolicyResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeFirewallPolicyPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *firewallPolicyPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *firewallPolicyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (FirewallPolicyResponse, error) {
      respType := FirewallPolicyResponse{FirewallPolicy: &FirewallPolicy{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.FirewallPolicy)
		if err != nil {
			return FirewallPolicyResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // FirewallPolicyRuleCollectionGroupPoller provides polling facilities until the operation completes
      type FirewallPolicyRuleCollectionGroupPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final FirewallPolicyRuleCollectionGroupResponse will be returned.
        FinalResponse(ctx context.Context) (FirewallPolicyRuleCollectionGroupResponse, error)
      }

      type firewallPolicyRuleCollectionGroupPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *firewallPolicyRuleCollectionGroupPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *firewallPolicyRuleCollectionGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *firewallPolicyRuleCollectionGroupPoller) FinalResponse(ctx context.Context) (FirewallPolicyRuleCollectionGroupResponse, error) {
      respType := FirewallPolicyRuleCollectionGroupResponse{FirewallPolicyRuleCollectionGroup: &FirewallPolicyRuleCollectionGroup{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.FirewallPolicyRuleCollectionGroup)
		if err != nil {
			return FirewallPolicyRuleCollectionGroupResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeFirewallPolicyRuleCollectionGroupPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *firewallPolicyRuleCollectionGroupPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *firewallPolicyRuleCollectionGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (FirewallPolicyRuleCollectionGroupResponse, error) {
      respType := FirewallPolicyRuleCollectionGroupResponse{FirewallPolicyRuleCollectionGroup: &FirewallPolicyRuleCollectionGroup{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.FirewallPolicyRuleCollectionGroup)
		if err != nil {
			return FirewallPolicyRuleCollectionGroupResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // FlowLogInformationPoller provides polling facilities until the operation completes
      type FlowLogInformationPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final FlowLogInformationResponse will be returned.
        FinalResponse(ctx context.Context) (FlowLogInformationResponse, error)
      }

      type flowLogInformationPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *flowLogInformationPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *flowLogInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *flowLogInformationPoller) FinalResponse(ctx context.Context) (FlowLogInformationResponse, error) {
      respType := FlowLogInformationResponse{FlowLogInformation: &FlowLogInformation{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.FlowLogInformation)
		if err != nil {
			return FlowLogInformationResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeFlowLogInformationPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *flowLogInformationPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *flowLogInformationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (FlowLogInformationResponse, error) {
      respType := FlowLogInformationResponse{FlowLogInformation: &FlowLogInformation{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.FlowLogInformation)
		if err != nil {
			return FlowLogInformationResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // FlowLogPoller provides polling facilities until the operation completes
      type FlowLogPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final FlowLogResponse will be returned.
        FinalResponse(ctx context.Context) (FlowLogResponse, error)
      }

      type flowLogPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *flowLogPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *flowLogPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *flowLogPoller) FinalResponse(ctx context.Context) (FlowLogResponse, error) {
      respType := FlowLogResponse{FlowLog: &FlowLog{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.FlowLog)
		if err != nil {
			return FlowLogResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeFlowLogPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *flowLogPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *flowLogPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (FlowLogResponse, error) {
      respType := FlowLogResponse{FlowLog: &FlowLog{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.FlowLog)
		if err != nil {
			return FlowLogResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // GatewayRouteListResultPoller provides polling facilities until the operation completes
      type GatewayRouteListResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final GatewayRouteListResultResponse will be returned.
        FinalResponse(ctx context.Context) (GatewayRouteListResultResponse, error)
      }

      type gatewayRouteListResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *gatewayRouteListResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *gatewayRouteListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *gatewayRouteListResultPoller) FinalResponse(ctx context.Context) (GatewayRouteListResultResponse, error) {
      respType := GatewayRouteListResultResponse{GatewayRouteListResult: &GatewayRouteListResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.GatewayRouteListResult)
		if err != nil {
			return GatewayRouteListResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeGatewayRouteListResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *gatewayRouteListResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *gatewayRouteListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (GatewayRouteListResultResponse, error) {
      respType := GatewayRouteListResultResponse{GatewayRouteListResult: &GatewayRouteListResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.GatewayRouteListResult)
		if err != nil {
			return GatewayRouteListResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // HTTPPoller provides polling facilities until the operation completes
      type HTTPPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final HTTPResponse will be returned.
        FinalResponse(ctx context.Context) (*http.Response, error)
      }

      type httpPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *httpPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *httpPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *httpPoller) FinalResponse(ctx context.Context) (*http.Response, error) {
        return p.pt.FinalResponse(ctx, p.pipeline, nil)
      }

      // ResumeToken generates the string token that can be used with the ResumeHTTPPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *httpPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *httpPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (*http.Response, error) {
      return p.pt.PollUntilDone(ctx, frequency, p.pipeline, nil)
      }
  
  // HubIPConfigurationPoller provides polling facilities until the operation completes
      type HubIPConfigurationPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final HubIPConfigurationResponse will be returned.
        FinalResponse(ctx context.Context) (HubIPConfigurationResponse, error)
      }

      type hubIPConfigurationPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *hubIPConfigurationPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *hubIPConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *hubIPConfigurationPoller) FinalResponse(ctx context.Context) (HubIPConfigurationResponse, error) {
      respType := HubIPConfigurationResponse{HubIPConfiguration: &HubIPConfiguration{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.HubIPConfiguration)
		if err != nil {
			return HubIPConfigurationResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeHubIPConfigurationPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *hubIPConfigurationPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *hubIPConfigurationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (HubIPConfigurationResponse, error) {
      respType := HubIPConfigurationResponse{HubIPConfiguration: &HubIPConfiguration{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.HubIPConfiguration)
		if err != nil {
			return HubIPConfigurationResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // HubRouteTablePoller provides polling facilities until the operation completes
      type HubRouteTablePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final HubRouteTableResponse will be returned.
        FinalResponse(ctx context.Context) (HubRouteTableResponse, error)
      }

      type hubRouteTablePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *hubRouteTablePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *hubRouteTablePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *hubRouteTablePoller) FinalResponse(ctx context.Context) (HubRouteTableResponse, error) {
      respType := HubRouteTableResponse{HubRouteTable: &HubRouteTable{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.HubRouteTable)
		if err != nil {
			return HubRouteTableResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeHubRouteTablePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *hubRouteTablePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *hubRouteTablePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (HubRouteTableResponse, error) {
      respType := HubRouteTableResponse{HubRouteTable: &HubRouteTable{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.HubRouteTable)
		if err != nil {
			return HubRouteTableResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // HubVirtualNetworkConnectionPoller provides polling facilities until the operation completes
      type HubVirtualNetworkConnectionPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final HubVirtualNetworkConnectionResponse will be returned.
        FinalResponse(ctx context.Context) (HubVirtualNetworkConnectionResponse, error)
      }

      type hubVirtualNetworkConnectionPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *hubVirtualNetworkConnectionPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *hubVirtualNetworkConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *hubVirtualNetworkConnectionPoller) FinalResponse(ctx context.Context) (HubVirtualNetworkConnectionResponse, error) {
      respType := HubVirtualNetworkConnectionResponse{HubVirtualNetworkConnection: &HubVirtualNetworkConnection{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.HubVirtualNetworkConnection)
		if err != nil {
			return HubVirtualNetworkConnectionResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeHubVirtualNetworkConnectionPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *hubVirtualNetworkConnectionPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *hubVirtualNetworkConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (HubVirtualNetworkConnectionResponse, error) {
      respType := HubVirtualNetworkConnectionResponse{HubVirtualNetworkConnection: &HubVirtualNetworkConnection{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.HubVirtualNetworkConnection)
		if err != nil {
			return HubVirtualNetworkConnectionResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // IPAllocationPoller provides polling facilities until the operation completes
      type IPAllocationPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final IPAllocationResponse will be returned.
        FinalResponse(ctx context.Context) (IPAllocationResponse, error)
      }

      type ipAllocationPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *ipAllocationPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *ipAllocationPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *ipAllocationPoller) FinalResponse(ctx context.Context) (IPAllocationResponse, error) {
      respType := IPAllocationResponse{IPAllocation: &IPAllocation{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.IPAllocation)
		if err != nil {
			return IPAllocationResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeIPAllocationPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *ipAllocationPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *ipAllocationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (IPAllocationResponse, error) {
      respType := IPAllocationResponse{IPAllocation: &IPAllocation{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.IPAllocation)
		if err != nil {
			return IPAllocationResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // IPGroupPoller provides polling facilities until the operation completes
      type IPGroupPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final IPGroupResponse will be returned.
        FinalResponse(ctx context.Context) (IPGroupResponse, error)
      }

      type ipGroupPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *ipGroupPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *ipGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *ipGroupPoller) FinalResponse(ctx context.Context) (IPGroupResponse, error) {
      respType := IPGroupResponse{IPGroup: &IPGroup{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.IPGroup)
		if err != nil {
			return IPGroupResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeIPGroupPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *ipGroupPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *ipGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (IPGroupResponse, error) {
      respType := IPGroupResponse{IPGroup: &IPGroup{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.IPGroup)
		if err != nil {
			return IPGroupResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // InboundNatRulePoller provides polling facilities until the operation completes
      type InboundNatRulePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final InboundNatRuleResponse will be returned.
        FinalResponse(ctx context.Context) (InboundNatRuleResponse, error)
      }

      type inboundNatRulePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *inboundNatRulePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *inboundNatRulePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *inboundNatRulePoller) FinalResponse(ctx context.Context) (InboundNatRuleResponse, error) {
      respType := InboundNatRuleResponse{InboundNatRule: &InboundNatRule{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.InboundNatRule)
		if err != nil {
			return InboundNatRuleResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeInboundNatRulePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *inboundNatRulePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *inboundNatRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (InboundNatRuleResponse, error) {
      respType := InboundNatRuleResponse{InboundNatRule: &InboundNatRule{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.InboundNatRule)
		if err != nil {
			return InboundNatRuleResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // InboundSecurityRulePoller provides polling facilities until the operation completes
      type InboundSecurityRulePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final InboundSecurityRuleResponse will be returned.
        FinalResponse(ctx context.Context) (InboundSecurityRuleResponse, error)
      }

      type inboundSecurityRulePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *inboundSecurityRulePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *inboundSecurityRulePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *inboundSecurityRulePoller) FinalResponse(ctx context.Context) (InboundSecurityRuleResponse, error) {
      respType := InboundSecurityRuleResponse{InboundSecurityRule: &InboundSecurityRule{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.InboundSecurityRule)
		if err != nil {
			return InboundSecurityRuleResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeInboundSecurityRulePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *inboundSecurityRulePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *inboundSecurityRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (InboundSecurityRuleResponse, error) {
      respType := InboundSecurityRuleResponse{InboundSecurityRule: &InboundSecurityRule{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.InboundSecurityRule)
		if err != nil {
			return InboundSecurityRuleResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // LoadBalancerPoller provides polling facilities until the operation completes
      type LoadBalancerPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final LoadBalancerResponse will be returned.
        FinalResponse(ctx context.Context) (LoadBalancerResponse, error)
      }

      type loadBalancerPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *loadBalancerPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *loadBalancerPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *loadBalancerPoller) FinalResponse(ctx context.Context) (LoadBalancerResponse, error) {
      respType := LoadBalancerResponse{LoadBalancer: &LoadBalancer{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.LoadBalancer)
		if err != nil {
			return LoadBalancerResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeLoadBalancerPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *loadBalancerPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *loadBalancerPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (LoadBalancerResponse, error) {
      respType := LoadBalancerResponse{LoadBalancer: &LoadBalancer{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.LoadBalancer)
		if err != nil {
			return LoadBalancerResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // LocalNetworkGatewayPoller provides polling facilities until the operation completes
      type LocalNetworkGatewayPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final LocalNetworkGatewayResponse will be returned.
        FinalResponse(ctx context.Context) (LocalNetworkGatewayResponse, error)
      }

      type localNetworkGatewayPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *localNetworkGatewayPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *localNetworkGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *localNetworkGatewayPoller) FinalResponse(ctx context.Context) (LocalNetworkGatewayResponse, error) {
      respType := LocalNetworkGatewayResponse{LocalNetworkGateway: &LocalNetworkGateway{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.LocalNetworkGateway)
		if err != nil {
			return LocalNetworkGatewayResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeLocalNetworkGatewayPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *localNetworkGatewayPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *localNetworkGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (LocalNetworkGatewayResponse, error) {
      respType := LocalNetworkGatewayResponse{LocalNetworkGateway: &LocalNetworkGateway{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.LocalNetworkGateway)
		if err != nil {
			return LocalNetworkGatewayResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // NatGatewayPoller provides polling facilities until the operation completes
      type NatGatewayPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final NatGatewayResponse will be returned.
        FinalResponse(ctx context.Context) (NatGatewayResponse, error)
      }

      type natGatewayPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *natGatewayPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *natGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *natGatewayPoller) FinalResponse(ctx context.Context) (NatGatewayResponse, error) {
      respType := NatGatewayResponse{NatGateway: &NatGateway{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NatGateway)
		if err != nil {
			return NatGatewayResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeNatGatewayPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *natGatewayPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *natGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NatGatewayResponse, error) {
      respType := NatGatewayResponse{NatGateway: &NatGateway{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NatGateway)
		if err != nil {
			return NatGatewayResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // NetworkConfigurationDiagnosticResponsePoller provides polling facilities until the operation completes
      type NetworkConfigurationDiagnosticResponsePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final NetworkConfigurationDiagnosticResponseResponse will be returned.
        FinalResponse(ctx context.Context) (NetworkConfigurationDiagnosticResponseResponse, error)
      }

      type networkConfigurationDiagnosticResponsePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *networkConfigurationDiagnosticResponsePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *networkConfigurationDiagnosticResponsePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *networkConfigurationDiagnosticResponsePoller) FinalResponse(ctx context.Context) (NetworkConfigurationDiagnosticResponseResponse, error) {
      respType := NetworkConfigurationDiagnosticResponseResponse{NetworkConfigurationDiagnosticResponse: &NetworkConfigurationDiagnosticResponse{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkConfigurationDiagnosticResponse)
		if err != nil {
			return NetworkConfigurationDiagnosticResponseResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeNetworkConfigurationDiagnosticResponsePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *networkConfigurationDiagnosticResponsePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *networkConfigurationDiagnosticResponsePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NetworkConfigurationDiagnosticResponseResponse, error) {
      respType := NetworkConfigurationDiagnosticResponseResponse{NetworkConfigurationDiagnosticResponse: &NetworkConfigurationDiagnosticResponse{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkConfigurationDiagnosticResponse)
		if err != nil {
			return NetworkConfigurationDiagnosticResponseResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // NetworkInterfacePoller provides polling facilities until the operation completes
      type NetworkInterfacePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final NetworkInterfaceResponse will be returned.
        FinalResponse(ctx context.Context) (NetworkInterfaceResponse, error)
      }

      type networkInterfacePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *networkInterfacePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *networkInterfacePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *networkInterfacePoller) FinalResponse(ctx context.Context) (NetworkInterfaceResponse, error) {
      respType := NetworkInterfaceResponse{NetworkInterface: &NetworkInterface{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkInterface)
		if err != nil {
			return NetworkInterfaceResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeNetworkInterfacePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *networkInterfacePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *networkInterfacePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NetworkInterfaceResponse, error) {
      respType := NetworkInterfaceResponse{NetworkInterface: &NetworkInterface{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkInterface)
		if err != nil {
			return NetworkInterfaceResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // NetworkInterfaceTapConfigurationPoller provides polling facilities until the operation completes
      type NetworkInterfaceTapConfigurationPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final NetworkInterfaceTapConfigurationResponse will be returned.
        FinalResponse(ctx context.Context) (NetworkInterfaceTapConfigurationResponse, error)
      }

      type networkInterfaceTapConfigurationPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *networkInterfaceTapConfigurationPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *networkInterfaceTapConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *networkInterfaceTapConfigurationPoller) FinalResponse(ctx context.Context) (NetworkInterfaceTapConfigurationResponse, error) {
      respType := NetworkInterfaceTapConfigurationResponse{NetworkInterfaceTapConfiguration: &NetworkInterfaceTapConfiguration{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkInterfaceTapConfiguration)
		if err != nil {
			return NetworkInterfaceTapConfigurationResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeNetworkInterfaceTapConfigurationPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *networkInterfaceTapConfigurationPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *networkInterfaceTapConfigurationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NetworkInterfaceTapConfigurationResponse, error) {
      respType := NetworkInterfaceTapConfigurationResponse{NetworkInterfaceTapConfiguration: &NetworkInterfaceTapConfiguration{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkInterfaceTapConfiguration)
		if err != nil {
			return NetworkInterfaceTapConfigurationResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // NetworkSecurityGroupPoller provides polling facilities until the operation completes
      type NetworkSecurityGroupPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final NetworkSecurityGroupResponse will be returned.
        FinalResponse(ctx context.Context) (NetworkSecurityGroupResponse, error)
      }

      type networkSecurityGroupPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *networkSecurityGroupPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *networkSecurityGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *networkSecurityGroupPoller) FinalResponse(ctx context.Context) (NetworkSecurityGroupResponse, error) {
      respType := NetworkSecurityGroupResponse{NetworkSecurityGroup: &NetworkSecurityGroup{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkSecurityGroup)
		if err != nil {
			return NetworkSecurityGroupResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeNetworkSecurityGroupPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *networkSecurityGroupPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *networkSecurityGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NetworkSecurityGroupResponse, error) {
      respType := NetworkSecurityGroupResponse{NetworkSecurityGroup: &NetworkSecurityGroup{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkSecurityGroup)
		if err != nil {
			return NetworkSecurityGroupResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // NetworkVirtualAppliancePoller provides polling facilities until the operation completes
      type NetworkVirtualAppliancePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final NetworkVirtualApplianceResponse will be returned.
        FinalResponse(ctx context.Context) (NetworkVirtualApplianceResponse, error)
      }

      type networkVirtualAppliancePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *networkVirtualAppliancePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *networkVirtualAppliancePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *networkVirtualAppliancePoller) FinalResponse(ctx context.Context) (NetworkVirtualApplianceResponse, error) {
      respType := NetworkVirtualApplianceResponse{NetworkVirtualAppliance: &NetworkVirtualAppliance{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NetworkVirtualAppliance)
		if err != nil {
			return NetworkVirtualApplianceResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeNetworkVirtualAppliancePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *networkVirtualAppliancePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *networkVirtualAppliancePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NetworkVirtualApplianceResponse, error) {
      respType := NetworkVirtualApplianceResponse{NetworkVirtualAppliance: &NetworkVirtualAppliance{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NetworkVirtualAppliance)
		if err != nil {
			return NetworkVirtualApplianceResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // NextHopResultPoller provides polling facilities until the operation completes
      type NextHopResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final NextHopResultResponse will be returned.
        FinalResponse(ctx context.Context) (NextHopResultResponse, error)
      }

      type nextHopResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *nextHopResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *nextHopResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *nextHopResultPoller) FinalResponse(ctx context.Context) (NextHopResultResponse, error) {
      respType := NextHopResultResponse{NextHopResult: &NextHopResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.NextHopResult)
		if err != nil {
			return NextHopResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeNextHopResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *nextHopResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *nextHopResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (NextHopResultResponse, error) {
      respType := NextHopResultResponse{NextHopResult: &NextHopResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.NextHopResult)
		if err != nil {
			return NextHopResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // P2SVPNConnectionHealthPoller provides polling facilities until the operation completes
      type P2SVPNConnectionHealthPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final P2SVPNConnectionHealthResponse will be returned.
        FinalResponse(ctx context.Context) (P2SVPNConnectionHealthResponse, error)
      }

      type p2SVPNConnectionHealthPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *p2SVPNConnectionHealthPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *p2SVPNConnectionHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *p2SVPNConnectionHealthPoller) FinalResponse(ctx context.Context) (P2SVPNConnectionHealthResponse, error) {
      respType := P2SVPNConnectionHealthResponse{P2SVPNConnectionHealth: &P2SVPNConnectionHealth{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.P2SVPNConnectionHealth)
		if err != nil {
			return P2SVPNConnectionHealthResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeP2SVPNConnectionHealthPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *p2SVPNConnectionHealthPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *p2SVPNConnectionHealthPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (P2SVPNConnectionHealthResponse, error) {
      respType := P2SVPNConnectionHealthResponse{P2SVPNConnectionHealth: &P2SVPNConnectionHealth{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.P2SVPNConnectionHealth)
		if err != nil {
			return P2SVPNConnectionHealthResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // P2SVPNGatewayPoller provides polling facilities until the operation completes
      type P2SVPNGatewayPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final P2SVPNGatewayResponse will be returned.
        FinalResponse(ctx context.Context) (P2SVPNGatewayResponse, error)
      }

      type p2SVPNGatewayPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *p2SVPNGatewayPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *p2SVPNGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *p2SVPNGatewayPoller) FinalResponse(ctx context.Context) (P2SVPNGatewayResponse, error) {
      respType := P2SVPNGatewayResponse{P2SVPNGateway: &P2SVPNGateway{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.P2SVPNGateway)
		if err != nil {
			return P2SVPNGatewayResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeP2SVPNGatewayPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *p2SVPNGatewayPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *p2SVPNGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (P2SVPNGatewayResponse, error) {
      respType := P2SVPNGatewayResponse{P2SVPNGateway: &P2SVPNGateway{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.P2SVPNGateway)
		if err != nil {
			return P2SVPNGatewayResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // PacketCaptureQueryStatusResultPoller provides polling facilities until the operation completes
      type PacketCaptureQueryStatusResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final PacketCaptureQueryStatusResultResponse will be returned.
        FinalResponse(ctx context.Context) (PacketCaptureQueryStatusResultResponse, error)
      }

      type packetCaptureQueryStatusResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *packetCaptureQueryStatusResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *packetCaptureQueryStatusResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *packetCaptureQueryStatusResultPoller) FinalResponse(ctx context.Context) (PacketCaptureQueryStatusResultResponse, error) {
      respType := PacketCaptureQueryStatusResultResponse{PacketCaptureQueryStatusResult: &PacketCaptureQueryStatusResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PacketCaptureQueryStatusResult)
		if err != nil {
			return PacketCaptureQueryStatusResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumePacketCaptureQueryStatusResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *packetCaptureQueryStatusResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *packetCaptureQueryStatusResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PacketCaptureQueryStatusResultResponse, error) {
      respType := PacketCaptureQueryStatusResultResponse{PacketCaptureQueryStatusResult: &PacketCaptureQueryStatusResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PacketCaptureQueryStatusResult)
		if err != nil {
			return PacketCaptureQueryStatusResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // PacketCaptureResultPoller provides polling facilities until the operation completes
      type PacketCaptureResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final PacketCaptureResultResponse will be returned.
        FinalResponse(ctx context.Context) (PacketCaptureResultResponse, error)
      }

      type packetCaptureResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *packetCaptureResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *packetCaptureResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *packetCaptureResultPoller) FinalResponse(ctx context.Context) (PacketCaptureResultResponse, error) {
      respType := PacketCaptureResultResponse{PacketCaptureResult: &PacketCaptureResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PacketCaptureResult)
		if err != nil {
			return PacketCaptureResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumePacketCaptureResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *packetCaptureResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *packetCaptureResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PacketCaptureResultResponse, error) {
      respType := PacketCaptureResultResponse{PacketCaptureResult: &PacketCaptureResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PacketCaptureResult)
		if err != nil {
			return PacketCaptureResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // PeerRouteListPoller provides polling facilities until the operation completes
      type PeerRouteListPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final PeerRouteListResponse will be returned.
        FinalResponse(ctx context.Context) (PeerRouteListResponse, error)
      }

      type peerRouteListPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *peerRouteListPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *peerRouteListPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *peerRouteListPoller) FinalResponse(ctx context.Context) (PeerRouteListResponse, error) {
      respType := PeerRouteListResponse{PeerRouteList: &PeerRouteList{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PeerRouteList)
		if err != nil {
			return PeerRouteListResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumePeerRouteListPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *peerRouteListPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *peerRouteListPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PeerRouteListResponse, error) {
      respType := PeerRouteListResponse{PeerRouteList: &PeerRouteList{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PeerRouteList)
		if err != nil {
			return PeerRouteListResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // PrivateDNSZoneGroupPoller provides polling facilities until the operation completes
      type PrivateDNSZoneGroupPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final PrivateDNSZoneGroupResponse will be returned.
        FinalResponse(ctx context.Context) (PrivateDNSZoneGroupResponse, error)
      }

      type privateDNSZoneGroupPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *privateDNSZoneGroupPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *privateDNSZoneGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *privateDNSZoneGroupPoller) FinalResponse(ctx context.Context) (PrivateDNSZoneGroupResponse, error) {
      respType := PrivateDNSZoneGroupResponse{PrivateDNSZoneGroup: &PrivateDNSZoneGroup{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateDNSZoneGroup)
		if err != nil {
			return PrivateDNSZoneGroupResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumePrivateDNSZoneGroupPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *privateDNSZoneGroupPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *privateDNSZoneGroupPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PrivateDNSZoneGroupResponse, error) {
      respType := PrivateDNSZoneGroupResponse{PrivateDNSZoneGroup: &PrivateDNSZoneGroup{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PrivateDNSZoneGroup)
		if err != nil {
			return PrivateDNSZoneGroupResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // PrivateEndpointPoller provides polling facilities until the operation completes
      type PrivateEndpointPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final PrivateEndpointResponse will be returned.
        FinalResponse(ctx context.Context) (PrivateEndpointResponse, error)
      }

      type privateEndpointPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *privateEndpointPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *privateEndpointPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *privateEndpointPoller) FinalResponse(ctx context.Context) (PrivateEndpointResponse, error) {
      respType := PrivateEndpointResponse{PrivateEndpoint: &PrivateEndpoint{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateEndpoint)
		if err != nil {
			return PrivateEndpointResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumePrivateEndpointPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *privateEndpointPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *privateEndpointPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PrivateEndpointResponse, error) {
      respType := PrivateEndpointResponse{PrivateEndpoint: &PrivateEndpoint{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PrivateEndpoint)
		if err != nil {
			return PrivateEndpointResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // PrivateLinkServicePoller provides polling facilities until the operation completes
      type PrivateLinkServicePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final PrivateLinkServiceResponse will be returned.
        FinalResponse(ctx context.Context) (PrivateLinkServiceResponse, error)
      }

      type privateLinkServicePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *privateLinkServicePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *privateLinkServicePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *privateLinkServicePoller) FinalResponse(ctx context.Context) (PrivateLinkServiceResponse, error) {
      respType := PrivateLinkServiceResponse{PrivateLinkService: &PrivateLinkService{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateLinkService)
		if err != nil {
			return PrivateLinkServiceResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumePrivateLinkServicePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *privateLinkServicePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *privateLinkServicePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PrivateLinkServiceResponse, error) {
      respType := PrivateLinkServiceResponse{PrivateLinkService: &PrivateLinkService{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PrivateLinkService)
		if err != nil {
			return PrivateLinkServiceResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // PrivateLinkServiceVisibilityPoller provides polling facilities until the operation completes
      type PrivateLinkServiceVisibilityPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final PrivateLinkServiceVisibilityResponse will be returned.
        FinalResponse(ctx context.Context) (PrivateLinkServiceVisibilityResponse, error)
      }

      type privateLinkServiceVisibilityPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *privateLinkServiceVisibilityPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *privateLinkServiceVisibilityPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *privateLinkServiceVisibilityPoller) FinalResponse(ctx context.Context) (PrivateLinkServiceVisibilityResponse, error) {
      respType := PrivateLinkServiceVisibilityResponse{PrivateLinkServiceVisibility: &PrivateLinkServiceVisibility{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateLinkServiceVisibility)
		if err != nil {
			return PrivateLinkServiceVisibilityResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumePrivateLinkServiceVisibilityPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *privateLinkServiceVisibilityPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *privateLinkServiceVisibilityPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PrivateLinkServiceVisibilityResponse, error) {
      respType := PrivateLinkServiceVisibilityResponse{PrivateLinkServiceVisibility: &PrivateLinkServiceVisibility{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PrivateLinkServiceVisibility)
		if err != nil {
			return PrivateLinkServiceVisibilityResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // PublicIPAddressPoller provides polling facilities until the operation completes
      type PublicIPAddressPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final PublicIPAddressResponse will be returned.
        FinalResponse(ctx context.Context) (PublicIPAddressResponse, error)
      }

      type publicIPAddressPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *publicIPAddressPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *publicIPAddressPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *publicIPAddressPoller) FinalResponse(ctx context.Context) (PublicIPAddressResponse, error) {
      respType := PublicIPAddressResponse{PublicIPAddress: &PublicIPAddress{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PublicIPAddress)
		if err != nil {
			return PublicIPAddressResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumePublicIPAddressPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *publicIPAddressPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *publicIPAddressPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PublicIPAddressResponse, error) {
      respType := PublicIPAddressResponse{PublicIPAddress: &PublicIPAddress{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PublicIPAddress)
		if err != nil {
			return PublicIPAddressResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // PublicIPPrefixPoller provides polling facilities until the operation completes
      type PublicIPPrefixPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final PublicIPPrefixResponse will be returned.
        FinalResponse(ctx context.Context) (PublicIPPrefixResponse, error)
      }

      type publicIPPrefixPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *publicIPPrefixPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *publicIPPrefixPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *publicIPPrefixPoller) FinalResponse(ctx context.Context) (PublicIPPrefixResponse, error) {
      respType := PublicIPPrefixResponse{PublicIPPrefix: &PublicIPPrefix{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PublicIPPrefix)
		if err != nil {
			return PublicIPPrefixResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumePublicIPPrefixPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *publicIPPrefixPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *publicIPPrefixPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (PublicIPPrefixResponse, error) {
      respType := PublicIPPrefixResponse{PublicIPPrefix: &PublicIPPrefix{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.PublicIPPrefix)
		if err != nil {
			return PublicIPPrefixResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // RouteFilterPoller provides polling facilities until the operation completes
      type RouteFilterPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final RouteFilterResponse will be returned.
        FinalResponse(ctx context.Context) (RouteFilterResponse, error)
      }

      type routeFilterPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *routeFilterPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *routeFilterPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *routeFilterPoller) FinalResponse(ctx context.Context) (RouteFilterResponse, error) {
      respType := RouteFilterResponse{RouteFilter: &RouteFilter{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.RouteFilter)
		if err != nil {
			return RouteFilterResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeRouteFilterPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *routeFilterPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *routeFilterPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (RouteFilterResponse, error) {
      respType := RouteFilterResponse{RouteFilter: &RouteFilter{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.RouteFilter)
		if err != nil {
			return RouteFilterResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // RouteFilterRulePoller provides polling facilities until the operation completes
      type RouteFilterRulePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final RouteFilterRuleResponse will be returned.
        FinalResponse(ctx context.Context) (RouteFilterRuleResponse, error)
      }

      type routeFilterRulePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *routeFilterRulePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *routeFilterRulePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *routeFilterRulePoller) FinalResponse(ctx context.Context) (RouteFilterRuleResponse, error) {
      respType := RouteFilterRuleResponse{RouteFilterRule: &RouteFilterRule{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.RouteFilterRule)
		if err != nil {
			return RouteFilterRuleResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeRouteFilterRulePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *routeFilterRulePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *routeFilterRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (RouteFilterRuleResponse, error) {
      respType := RouteFilterRuleResponse{RouteFilterRule: &RouteFilterRule{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.RouteFilterRule)
		if err != nil {
			return RouteFilterRuleResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // RoutePoller provides polling facilities until the operation completes
      type RoutePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final RouteResponse will be returned.
        FinalResponse(ctx context.Context) (RouteResponse, error)
      }

      type routePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *routePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *routePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *routePoller) FinalResponse(ctx context.Context) (RouteResponse, error) {
      respType := RouteResponse{Route: &Route{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.Route)
		if err != nil {
			return RouteResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeRoutePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *routePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *routePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (RouteResponse, error) {
      respType := RouteResponse{Route: &Route{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.Route)
		if err != nil {
			return RouteResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // RouteTablePoller provides polling facilities until the operation completes
      type RouteTablePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final RouteTableResponse will be returned.
        FinalResponse(ctx context.Context) (RouteTableResponse, error)
      }

      type routeTablePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *routeTablePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *routeTablePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *routeTablePoller) FinalResponse(ctx context.Context) (RouteTableResponse, error) {
      respType := RouteTableResponse{RouteTable: &RouteTable{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.RouteTable)
		if err != nil {
			return RouteTableResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeRouteTablePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *routeTablePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *routeTablePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (RouteTableResponse, error) {
      respType := RouteTableResponse{RouteTable: &RouteTable{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.RouteTable)
		if err != nil {
			return RouteTableResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // SecurityGroupViewResultPoller provides polling facilities until the operation completes
      type SecurityGroupViewResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final SecurityGroupViewResultResponse will be returned.
        FinalResponse(ctx context.Context) (SecurityGroupViewResultResponse, error)
      }

      type securityGroupViewResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *securityGroupViewResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *securityGroupViewResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *securityGroupViewResultPoller) FinalResponse(ctx context.Context) (SecurityGroupViewResultResponse, error) {
      respType := SecurityGroupViewResultResponse{SecurityGroupViewResult: &SecurityGroupViewResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.SecurityGroupViewResult)
		if err != nil {
			return SecurityGroupViewResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeSecurityGroupViewResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *securityGroupViewResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *securityGroupViewResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (SecurityGroupViewResultResponse, error) {
      respType := SecurityGroupViewResultResponse{SecurityGroupViewResult: &SecurityGroupViewResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.SecurityGroupViewResult)
		if err != nil {
			return SecurityGroupViewResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // SecurityPartnerProviderPoller provides polling facilities until the operation completes
      type SecurityPartnerProviderPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final SecurityPartnerProviderResponse will be returned.
        FinalResponse(ctx context.Context) (SecurityPartnerProviderResponse, error)
      }

      type securityPartnerProviderPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *securityPartnerProviderPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *securityPartnerProviderPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *securityPartnerProviderPoller) FinalResponse(ctx context.Context) (SecurityPartnerProviderResponse, error) {
      respType := SecurityPartnerProviderResponse{SecurityPartnerProvider: &SecurityPartnerProvider{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.SecurityPartnerProvider)
		if err != nil {
			return SecurityPartnerProviderResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeSecurityPartnerProviderPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *securityPartnerProviderPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *securityPartnerProviderPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (SecurityPartnerProviderResponse, error) {
      respType := SecurityPartnerProviderResponse{SecurityPartnerProvider: &SecurityPartnerProvider{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.SecurityPartnerProvider)
		if err != nil {
			return SecurityPartnerProviderResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // SecurityRulePoller provides polling facilities until the operation completes
      type SecurityRulePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final SecurityRuleResponse will be returned.
        FinalResponse(ctx context.Context) (SecurityRuleResponse, error)
      }

      type securityRulePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *securityRulePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *securityRulePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *securityRulePoller) FinalResponse(ctx context.Context) (SecurityRuleResponse, error) {
      respType := SecurityRuleResponse{SecurityRule: &SecurityRule{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.SecurityRule)
		if err != nil {
			return SecurityRuleResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeSecurityRulePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *securityRulePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *securityRulePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (SecurityRuleResponse, error) {
      respType := SecurityRuleResponse{SecurityRule: &SecurityRule{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.SecurityRule)
		if err != nil {
			return SecurityRuleResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ServiceEndpointPolicyDefinitionPoller provides polling facilities until the operation completes
      type ServiceEndpointPolicyDefinitionPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ServiceEndpointPolicyDefinitionResponse will be returned.
        FinalResponse(ctx context.Context) (ServiceEndpointPolicyDefinitionResponse, error)
      }

      type serviceEndpointPolicyDefinitionPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *serviceEndpointPolicyDefinitionPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *serviceEndpointPolicyDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *serviceEndpointPolicyDefinitionPoller) FinalResponse(ctx context.Context) (ServiceEndpointPolicyDefinitionResponse, error) {
      respType := ServiceEndpointPolicyDefinitionResponse{ServiceEndpointPolicyDefinition: &ServiceEndpointPolicyDefinition{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ServiceEndpointPolicyDefinition)
		if err != nil {
			return ServiceEndpointPolicyDefinitionResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeServiceEndpointPolicyDefinitionPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *serviceEndpointPolicyDefinitionPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *serviceEndpointPolicyDefinitionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ServiceEndpointPolicyDefinitionResponse, error) {
      respType := ServiceEndpointPolicyDefinitionResponse{ServiceEndpointPolicyDefinition: &ServiceEndpointPolicyDefinition{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ServiceEndpointPolicyDefinition)
		if err != nil {
			return ServiceEndpointPolicyDefinitionResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // ServiceEndpointPolicyPoller provides polling facilities until the operation completes
      type ServiceEndpointPolicyPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final ServiceEndpointPolicyResponse will be returned.
        FinalResponse(ctx context.Context) (ServiceEndpointPolicyResponse, error)
      }

      type serviceEndpointPolicyPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *serviceEndpointPolicyPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *serviceEndpointPolicyPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *serviceEndpointPolicyPoller) FinalResponse(ctx context.Context) (ServiceEndpointPolicyResponse, error) {
      respType := ServiceEndpointPolicyResponse{ServiceEndpointPolicy: &ServiceEndpointPolicy{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.ServiceEndpointPolicy)
		if err != nil {
			return ServiceEndpointPolicyResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeServiceEndpointPolicyPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *serviceEndpointPolicyPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *serviceEndpointPolicyPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (ServiceEndpointPolicyResponse, error) {
      respType := ServiceEndpointPolicyResponse{ServiceEndpointPolicy: &ServiceEndpointPolicy{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.ServiceEndpointPolicy)
		if err != nil {
			return ServiceEndpointPolicyResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // StringPoller provides polling facilities until the operation completes
      type StringPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final StringResponse will be returned.
        FinalResponse(ctx context.Context) (StringResponse, error)
      }

      type stringPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *stringPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *stringPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *stringPoller) FinalResponse(ctx context.Context) (StringResponse, error) {
      respType := StringResponse{}

		resp, err := p.pt.FinalResponse(ctx, p.pipeline, &respType.Value)
		if err != nil {
			return StringResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeStringPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *stringPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *stringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (StringResponse, error) {
      respType := StringResponse{}

		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, &respType.Value)
		if err != nil {
			return StringResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // SubnetPoller provides polling facilities until the operation completes
      type SubnetPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final SubnetResponse will be returned.
        FinalResponse(ctx context.Context) (SubnetResponse, error)
      }

      type subnetPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *subnetPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *subnetPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *subnetPoller) FinalResponse(ctx context.Context) (SubnetResponse, error) {
      respType := SubnetResponse{Subnet: &Subnet{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.Subnet)
		if err != nil {
			return SubnetResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeSubnetPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *subnetPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *subnetPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (SubnetResponse, error) {
      respType := SubnetResponse{Subnet: &Subnet{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.Subnet)
		if err != nil {
			return SubnetResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // TroubleshootingResultPoller provides polling facilities until the operation completes
      type TroubleshootingResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final TroubleshootingResultResponse will be returned.
        FinalResponse(ctx context.Context) (TroubleshootingResultResponse, error)
      }

      type troubleshootingResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *troubleshootingResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *troubleshootingResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *troubleshootingResultPoller) FinalResponse(ctx context.Context) (TroubleshootingResultResponse, error) {
      respType := TroubleshootingResultResponse{TroubleshootingResult: &TroubleshootingResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.TroubleshootingResult)
		if err != nil {
			return TroubleshootingResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeTroubleshootingResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *troubleshootingResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *troubleshootingResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (TroubleshootingResultResponse, error) {
      respType := TroubleshootingResultResponse{TroubleshootingResult: &TroubleshootingResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.TroubleshootingResult)
		if err != nil {
			return TroubleshootingResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VPNClientConnectionHealthDetailListResultPoller provides polling facilities until the operation completes
      type VPNClientConnectionHealthDetailListResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VPNClientConnectionHealthDetailListResultResponse will be returned.
        FinalResponse(ctx context.Context) (VPNClientConnectionHealthDetailListResultResponse, error)
      }

      type vpnClientConnectionHealthDetailListResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *vpnClientConnectionHealthDetailListResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *vpnClientConnectionHealthDetailListResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *vpnClientConnectionHealthDetailListResultPoller) FinalResponse(ctx context.Context) (VPNClientConnectionHealthDetailListResultResponse, error) {
      respType := VPNClientConnectionHealthDetailListResultResponse{VPNClientConnectionHealthDetailListResult: &VPNClientConnectionHealthDetailListResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNClientConnectionHealthDetailListResult)
		if err != nil {
			return VPNClientConnectionHealthDetailListResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVPNClientConnectionHealthDetailListResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *vpnClientConnectionHealthDetailListResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *vpnClientConnectionHealthDetailListResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNClientConnectionHealthDetailListResultResponse, error) {
      respType := VPNClientConnectionHealthDetailListResultResponse{VPNClientConnectionHealthDetailListResult: &VPNClientConnectionHealthDetailListResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNClientConnectionHealthDetailListResult)
		if err != nil {
			return VPNClientConnectionHealthDetailListResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VPNClientIPsecParametersPoller provides polling facilities until the operation completes
      type VPNClientIPsecParametersPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VPNClientIPsecParametersResponse will be returned.
        FinalResponse(ctx context.Context) (VPNClientIPsecParametersResponse, error)
      }

      type vpnClientIPSecParametersPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *vpnClientIPSecParametersPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *vpnClientIPSecParametersPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *vpnClientIPSecParametersPoller) FinalResponse(ctx context.Context) (VPNClientIPsecParametersResponse, error) {
      respType := VPNClientIPsecParametersResponse{VPNClientIPsecParameters: &VPNClientIPsecParameters{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNClientIPsecParameters)
		if err != nil {
			return VPNClientIPsecParametersResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVPNClientIPsecParametersPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *vpnClientIPSecParametersPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *vpnClientIPSecParametersPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNClientIPsecParametersResponse, error) {
      respType := VPNClientIPsecParametersResponse{VPNClientIPsecParameters: &VPNClientIPsecParameters{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNClientIPsecParameters)
		if err != nil {
			return VPNClientIPsecParametersResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VPNConnectionPoller provides polling facilities until the operation completes
      type VPNConnectionPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VPNConnectionResponse will be returned.
        FinalResponse(ctx context.Context) (VPNConnectionResponse, error)
      }

      type vpnConnectionPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *vpnConnectionPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *vpnConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *vpnConnectionPoller) FinalResponse(ctx context.Context) (VPNConnectionResponse, error) {
      respType := VPNConnectionResponse{VPNConnection: &VPNConnection{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNConnection)
		if err != nil {
			return VPNConnectionResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVPNConnectionPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *vpnConnectionPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *vpnConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNConnectionResponse, error) {
      respType := VPNConnectionResponse{VPNConnection: &VPNConnection{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNConnection)
		if err != nil {
			return VPNConnectionResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VPNGatewayPoller provides polling facilities until the operation completes
      type VPNGatewayPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VPNGatewayResponse will be returned.
        FinalResponse(ctx context.Context) (VPNGatewayResponse, error)
      }

      type vpnGatewayPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *vpnGatewayPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *vpnGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *vpnGatewayPoller) FinalResponse(ctx context.Context) (VPNGatewayResponse, error) {
      respType := VPNGatewayResponse{VPNGateway: &VPNGateway{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNGateway)
		if err != nil {
			return VPNGatewayResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVPNGatewayPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *vpnGatewayPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *vpnGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNGatewayResponse, error) {
      respType := VPNGatewayResponse{VPNGateway: &VPNGateway{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNGateway)
		if err != nil {
			return VPNGatewayResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VPNProfileResponsePoller provides polling facilities until the operation completes
      type VPNProfileResponsePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VPNProfileResponseResponse will be returned.
        FinalResponse(ctx context.Context) (VPNProfileResponseResponse, error)
      }

      type vpnProfileResponsePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *vpnProfileResponsePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *vpnProfileResponsePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *vpnProfileResponsePoller) FinalResponse(ctx context.Context) (VPNProfileResponseResponse, error) {
      respType := VPNProfileResponseResponse{VPNProfileResponse: &VPNProfileResponse{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNProfileResponse)
		if err != nil {
			return VPNProfileResponseResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVPNProfileResponsePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *vpnProfileResponsePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *vpnProfileResponsePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNProfileResponseResponse, error) {
      respType := VPNProfileResponseResponse{VPNProfileResponse: &VPNProfileResponse{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNProfileResponse)
		if err != nil {
			return VPNProfileResponseResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VPNServerConfigurationPoller provides polling facilities until the operation completes
      type VPNServerConfigurationPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VPNServerConfigurationResponse will be returned.
        FinalResponse(ctx context.Context) (VPNServerConfigurationResponse, error)
      }

      type vpnServerConfigurationPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *vpnServerConfigurationPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *vpnServerConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *vpnServerConfigurationPoller) FinalResponse(ctx context.Context) (VPNServerConfigurationResponse, error) {
      respType := VPNServerConfigurationResponse{VPNServerConfiguration: &VPNServerConfiguration{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNServerConfiguration)
		if err != nil {
			return VPNServerConfigurationResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVPNServerConfigurationPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *vpnServerConfigurationPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *vpnServerConfigurationPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNServerConfigurationResponse, error) {
      respType := VPNServerConfigurationResponse{VPNServerConfiguration: &VPNServerConfiguration{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNServerConfiguration)
		if err != nil {
			return VPNServerConfigurationResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VPNServerConfigurationsResponsePoller provides polling facilities until the operation completes
      type VPNServerConfigurationsResponsePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VPNServerConfigurationsResponseResponse will be returned.
        FinalResponse(ctx context.Context) (VPNServerConfigurationsResponseResponse, error)
      }

      type vpnServerConfigurationsResponsePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *vpnServerConfigurationsResponsePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *vpnServerConfigurationsResponsePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *vpnServerConfigurationsResponsePoller) FinalResponse(ctx context.Context) (VPNServerConfigurationsResponseResponse, error) {
      respType := VPNServerConfigurationsResponseResponse{VPNServerConfigurationsResponse: &VPNServerConfigurationsResponse{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNServerConfigurationsResponse)
		if err != nil {
			return VPNServerConfigurationsResponseResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVPNServerConfigurationsResponsePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *vpnServerConfigurationsResponsePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *vpnServerConfigurationsResponsePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNServerConfigurationsResponseResponse, error) {
      respType := VPNServerConfigurationsResponseResponse{VPNServerConfigurationsResponse: &VPNServerConfigurationsResponse{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNServerConfigurationsResponse)
		if err != nil {
			return VPNServerConfigurationsResponseResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VPNSitePoller provides polling facilities until the operation completes
      type VPNSitePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VPNSiteResponse will be returned.
        FinalResponse(ctx context.Context) (VPNSiteResponse, error)
      }

      type vpnSitePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *vpnSitePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *vpnSitePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *vpnSitePoller) FinalResponse(ctx context.Context) (VPNSiteResponse, error) {
      respType := VPNSiteResponse{VPNSite: &VPNSite{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VPNSite)
		if err != nil {
			return VPNSiteResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVPNSitePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *vpnSitePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *vpnSitePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VPNSiteResponse, error) {
      respType := VPNSiteResponse{VPNSite: &VPNSite{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VPNSite)
		if err != nil {
			return VPNSiteResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VerificationIPFlowResultPoller provides polling facilities until the operation completes
      type VerificationIPFlowResultPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VerificationIPFlowResultResponse will be returned.
        FinalResponse(ctx context.Context) (VerificationIPFlowResultResponse, error)
      }

      type verificationIPFlowResultPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *verificationIPFlowResultPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *verificationIPFlowResultPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *verificationIPFlowResultPoller) FinalResponse(ctx context.Context) (VerificationIPFlowResultResponse, error) {
      respType := VerificationIPFlowResultResponse{VerificationIPFlowResult: &VerificationIPFlowResult{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VerificationIPFlowResult)
		if err != nil {
			return VerificationIPFlowResultResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVerificationIPFlowResultPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *verificationIPFlowResultPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *verificationIPFlowResultPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VerificationIPFlowResultResponse, error) {
      respType := VerificationIPFlowResultResponse{VerificationIPFlowResult: &VerificationIPFlowResult{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VerificationIPFlowResult)
		if err != nil {
			return VerificationIPFlowResultResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VirtualApplianceSitePoller provides polling facilities until the operation completes
      type VirtualApplianceSitePoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VirtualApplianceSiteResponse will be returned.
        FinalResponse(ctx context.Context) (VirtualApplianceSiteResponse, error)
      }

      type virtualApplianceSitePoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *virtualApplianceSitePoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *virtualApplianceSitePoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *virtualApplianceSitePoller) FinalResponse(ctx context.Context) (VirtualApplianceSiteResponse, error) {
      respType := VirtualApplianceSiteResponse{VirtualApplianceSite: &VirtualApplianceSite{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualApplianceSite)
		if err != nil {
			return VirtualApplianceSiteResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVirtualApplianceSitePoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *virtualApplianceSitePoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *virtualApplianceSitePoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualApplianceSiteResponse, error) {
      respType := VirtualApplianceSiteResponse{VirtualApplianceSite: &VirtualApplianceSite{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualApplianceSite)
		if err != nil {
			return VirtualApplianceSiteResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VirtualHubPoller provides polling facilities until the operation completes
      type VirtualHubPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VirtualHubResponse will be returned.
        FinalResponse(ctx context.Context) (VirtualHubResponse, error)
      }

      type virtualHubPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *virtualHubPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *virtualHubPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *virtualHubPoller) FinalResponse(ctx context.Context) (VirtualHubResponse, error) {
      respType := VirtualHubResponse{VirtualHub: &VirtualHub{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualHub)
		if err != nil {
			return VirtualHubResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVirtualHubPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *virtualHubPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *virtualHubPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualHubResponse, error) {
      respType := VirtualHubResponse{VirtualHub: &VirtualHub{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualHub)
		if err != nil {
			return VirtualHubResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VirtualHubRouteTableV2Poller provides polling facilities until the operation completes
      type VirtualHubRouteTableV2Poller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VirtualHubRouteTableV2Response will be returned.
        FinalResponse(ctx context.Context) (VirtualHubRouteTableV2Response, error)
      }

      type virtualHubRouteTableV2Poller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *virtualHubRouteTableV2Poller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *virtualHubRouteTableV2Poller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *virtualHubRouteTableV2Poller) FinalResponse(ctx context.Context) (VirtualHubRouteTableV2Response, error) {
      respType := VirtualHubRouteTableV2Response{VirtualHubRouteTableV2: &VirtualHubRouteTableV2{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualHubRouteTableV2)
		if err != nil {
			return VirtualHubRouteTableV2Response{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVirtualHubRouteTableV2Poller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *virtualHubRouteTableV2Poller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *virtualHubRouteTableV2Poller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualHubRouteTableV2Response, error) {
      respType := VirtualHubRouteTableV2Response{VirtualHubRouteTableV2: &VirtualHubRouteTableV2{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualHubRouteTableV2)
		if err != nil {
			return VirtualHubRouteTableV2Response{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VirtualNetworkGatewayConnectionPoller provides polling facilities until the operation completes
      type VirtualNetworkGatewayConnectionPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VirtualNetworkGatewayConnectionResponse will be returned.
        FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionResponse, error)
      }

      type virtualNetworkGatewayConnectionPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *virtualNetworkGatewayConnectionPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *virtualNetworkGatewayConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *virtualNetworkGatewayConnectionPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionResponse, error) {
      respType := VirtualNetworkGatewayConnectionResponse{VirtualNetworkGatewayConnection: &VirtualNetworkGatewayConnection{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetworkGatewayConnection)
		if err != nil {
			return VirtualNetworkGatewayConnectionResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVirtualNetworkGatewayConnectionPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *virtualNetworkGatewayConnectionPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *virtualNetworkGatewayConnectionPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualNetworkGatewayConnectionResponse, error) {
      respType := VirtualNetworkGatewayConnectionResponse{VirtualNetworkGatewayConnection: &VirtualNetworkGatewayConnection{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetworkGatewayConnection)
		if err != nil {
			return VirtualNetworkGatewayConnectionResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VirtualNetworkGatewayPoller provides polling facilities until the operation completes
      type VirtualNetworkGatewayPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VirtualNetworkGatewayResponse will be returned.
        FinalResponse(ctx context.Context) (VirtualNetworkGatewayResponse, error)
      }

      type virtualNetworkGatewayPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *virtualNetworkGatewayPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *virtualNetworkGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *virtualNetworkGatewayPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayResponse, error) {
      respType := VirtualNetworkGatewayResponse{VirtualNetworkGateway: &VirtualNetworkGateway{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetworkGateway)
		if err != nil {
			return VirtualNetworkGatewayResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVirtualNetworkGatewayPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *virtualNetworkGatewayPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *virtualNetworkGatewayPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualNetworkGatewayResponse, error) {
      respType := VirtualNetworkGatewayResponse{VirtualNetworkGateway: &VirtualNetworkGateway{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetworkGateway)
		if err != nil {
			return VirtualNetworkGatewayResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VirtualNetworkPeeringPoller provides polling facilities until the operation completes
      type VirtualNetworkPeeringPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VirtualNetworkPeeringResponse will be returned.
        FinalResponse(ctx context.Context) (VirtualNetworkPeeringResponse, error)
      }

      type virtualNetworkPeeringPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *virtualNetworkPeeringPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *virtualNetworkPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *virtualNetworkPeeringPoller) FinalResponse(ctx context.Context) (VirtualNetworkPeeringResponse, error) {
      respType := VirtualNetworkPeeringResponse{VirtualNetworkPeering: &VirtualNetworkPeering{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetworkPeering)
		if err != nil {
			return VirtualNetworkPeeringResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVirtualNetworkPeeringPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *virtualNetworkPeeringPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *virtualNetworkPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualNetworkPeeringResponse, error) {
      respType := VirtualNetworkPeeringResponse{VirtualNetworkPeering: &VirtualNetworkPeering{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetworkPeering)
		if err != nil {
			return VirtualNetworkPeeringResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VirtualNetworkPoller provides polling facilities until the operation completes
      type VirtualNetworkPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VirtualNetworkResponse will be returned.
        FinalResponse(ctx context.Context) (VirtualNetworkResponse, error)
      }

      type virtualNetworkPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *virtualNetworkPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *virtualNetworkPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *virtualNetworkPoller) FinalResponse(ctx context.Context) (VirtualNetworkResponse, error) {
      respType := VirtualNetworkResponse{VirtualNetwork: &VirtualNetwork{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetwork)
		if err != nil {
			return VirtualNetworkResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVirtualNetworkPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *virtualNetworkPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *virtualNetworkPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualNetworkResponse, error) {
      respType := VirtualNetworkResponse{VirtualNetwork: &VirtualNetwork{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetwork)
		if err != nil {
			return VirtualNetworkResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VirtualNetworkTapPoller provides polling facilities until the operation completes
      type VirtualNetworkTapPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VirtualNetworkTapResponse will be returned.
        FinalResponse(ctx context.Context) (VirtualNetworkTapResponse, error)
      }

      type virtualNetworkTapPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *virtualNetworkTapPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *virtualNetworkTapPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *virtualNetworkTapPoller) FinalResponse(ctx context.Context) (VirtualNetworkTapResponse, error) {
      respType := VirtualNetworkTapResponse{VirtualNetworkTap: &VirtualNetworkTap{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualNetworkTap)
		if err != nil {
			return VirtualNetworkTapResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVirtualNetworkTapPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *virtualNetworkTapPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *virtualNetworkTapPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualNetworkTapResponse, error) {
      respType := VirtualNetworkTapResponse{VirtualNetworkTap: &VirtualNetworkTap{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualNetworkTap)
		if err != nil {
			return VirtualNetworkTapResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VirtualRouterPeeringPoller provides polling facilities until the operation completes
      type VirtualRouterPeeringPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VirtualRouterPeeringResponse will be returned.
        FinalResponse(ctx context.Context) (VirtualRouterPeeringResponse, error)
      }

      type virtualRouterPeeringPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *virtualRouterPeeringPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *virtualRouterPeeringPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *virtualRouterPeeringPoller) FinalResponse(ctx context.Context) (VirtualRouterPeeringResponse, error) {
      respType := VirtualRouterPeeringResponse{VirtualRouterPeering: &VirtualRouterPeering{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualRouterPeering)
		if err != nil {
			return VirtualRouterPeeringResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVirtualRouterPeeringPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *virtualRouterPeeringPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *virtualRouterPeeringPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualRouterPeeringResponse, error) {
      respType := VirtualRouterPeeringResponse{VirtualRouterPeering: &VirtualRouterPeering{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualRouterPeering)
		if err != nil {
			return VirtualRouterPeeringResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VirtualRouterPoller provides polling facilities until the operation completes
      type VirtualRouterPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VirtualRouterResponse will be returned.
        FinalResponse(ctx context.Context) (VirtualRouterResponse, error)
      }

      type virtualRouterPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *virtualRouterPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *virtualRouterPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *virtualRouterPoller) FinalResponse(ctx context.Context) (VirtualRouterResponse, error) {
      respType := VirtualRouterResponse{VirtualRouter: &VirtualRouter{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualRouter)
		if err != nil {
			return VirtualRouterResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVirtualRouterPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *virtualRouterPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *virtualRouterPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualRouterResponse, error) {
      respType := VirtualRouterResponse{VirtualRouter: &VirtualRouter{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualRouter)
		if err != nil {
			return VirtualRouterResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  // VirtualWANPoller provides polling facilities until the operation completes
      type VirtualWANPoller interface {
        azcore.Poller

        // FinalResponse performs a final GET to the service and returns the final response
        // for the polling operation. If there is an error performing the final GET then an error is returned.
        // If the final GET succeeded then the final VirtualWANResponse will be returned.
        FinalResponse(ctx context.Context) (VirtualWANResponse, error)
      }

      type virtualWANPoller struct {
        // the client for making the request
        pipeline azcore.Pipeline
        pt armcore.Poller
      }

      // Done returns true if there was an error or polling has reached a terminal state
      func (p *virtualWANPoller) Done() bool {
        return p.pt.Done()
      }

      // Poll will send poll the service endpoint and return an http.Response or error received from the service
      func (p *virtualWANPoller) Poll(ctx context.Context) (*http.Response, error) {
        return p.pt.Poll(ctx, p.pipeline)
      }

      func (p *virtualWANPoller) FinalResponse(ctx context.Context) (VirtualWANResponse, error) {
      respType := VirtualWANResponse{VirtualWAN: &VirtualWAN{}}
		resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualWAN)
		if err != nil {
			return VirtualWANResponse{}, err
    }
    respType.RawResponse = resp
		return respType, nil
	  }
      

      // ResumeToken generates the string token that can be used with the ResumeVirtualWANPoller method
      // on the client to create a new poller from the data held in the current poller type
      func (p *virtualWANPoller) ResumeToken() (string, error) {
        return p.pt.ResumeToken()
      }

      func (p *virtualWANPoller) pollUntilDone(ctx context.Context, frequency time.Duration) (VirtualWANResponse, error) {
      respType := VirtualWANResponse{VirtualWAN: &VirtualWAN{}}
		resp, err := p.pt.PollUntilDone(ctx, frequency, p.pipeline, respType.VirtualWAN)
		if err != nil {
			return VirtualWANResponse{}, err
    }
    respType.RawResponse = resp
    return respType, nil
      }
  
  