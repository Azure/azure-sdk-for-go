// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armresources

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// DeploymentsOperations contains the methods for the Deployments group.
type DeploymentsOperations interface {
	// CalculateTemplateHash - Calculate the hash of the given template.
	CalculateTemplateHash(ctx context.Context, templateParameter interface{}) (*TemplateHashResultResponse, error)
	// Cancel - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resource group partially deployed.
	Cancel(ctx context.Context, resourceGroupName string, deploymentName string) (*http.Response, error)
	// CancelAtManagementGroupScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
	CancelAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string) (*http.Response, error)
	// CancelAtSubscriptionScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
	CancelAtSubscriptionScope(ctx context.Context, deploymentName string) (*http.Response, error)
	// CheckExistence - Checks whether the deployment exists.
	CheckExistence(ctx context.Context, resourceGroupName string, deploymentName string) (*http.Response, error)
	// CheckExistenceAtManagementGroupScope - Checks whether the deployment exists.
	CheckExistenceAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string) (*http.Response, error)
	// CheckExistenceAtSubscriptionScope - Checks whether the deployment exists.
	CheckExistenceAtSubscriptionScope(ctx context.Context, deploymentName string) (*http.Response, error)
	// BeginCreateOrUpdate - You can provide the template and parameters directly in the request or link to JSON files.
	BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment) (*DeploymentExtendedPollerResponse, error)
	// ResumeCreateOrUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdate(token string) (DeploymentExtendedPoller, error)
	// BeginCreateOrUpdateAtManagementGroupScope - You can provide the template and parameters directly in the request or link to JSON files.
	BeginCreateOrUpdateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters Deployment) (*DeploymentExtendedPollerResponse, error)
	// ResumeCreateOrUpdateAtManagementGroupScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdateAtManagementGroupScope(token string) (DeploymentExtendedPoller, error)
	// BeginCreateOrUpdateAtSubscriptionScope - You can provide the template and parameters directly in the request or link to JSON files.
	BeginCreateOrUpdateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment) (*DeploymentExtendedPollerResponse, error)
	// ResumeCreateOrUpdateAtSubscriptionScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdateAtSubscriptionScope(token string) (DeploymentExtendedPoller, error)
	// BeginDelete - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
	BeginDelete(ctx context.Context, resourceGroupName string, deploymentName string) (*HTTPPollerResponse, error)
	// ResumeDelete - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDelete(token string) (HTTPPoller, error)
	// BeginDeleteAtManagementGroupScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
	BeginDeleteAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string) (*HTTPPollerResponse, error)
	// ResumeDeleteAtManagementGroupScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAtManagementGroupScope(token string) (HTTPPoller, error)
	// BeginDeleteAtSubscriptionScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
	BeginDeleteAtSubscriptionScope(ctx context.Context, deploymentName string) (*HTTPPollerResponse, error)
	// ResumeDeleteAtSubscriptionScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAtSubscriptionScope(token string) (HTTPPoller, error)
	// ExportTemplate - Exports the template used for specified deployment.
	ExportTemplate(ctx context.Context, resourceGroupName string, deploymentName string) (*DeploymentExportResultResponse, error)
	// ExportTemplateAtManagementGroupScope - Exports the template used for specified deployment.
	ExportTemplateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string) (*DeploymentExportResultResponse, error)
	// ExportTemplateAtSubscriptionScope - Exports the template used for specified deployment.
	ExportTemplateAtSubscriptionScope(ctx context.Context, deploymentName string) (*DeploymentExportResultResponse, error)
	// Get - Gets a deployment.
	Get(ctx context.Context, resourceGroupName string, deploymentName string) (*DeploymentExtendedResponse, error)
	// GetAtManagementGroupScope - Gets a deployment.
	GetAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string) (*DeploymentExtendedResponse, error)
	// GetAtSubscriptionScope - Gets a deployment.
	GetAtSubscriptionScope(ctx context.Context, deploymentName string) (*DeploymentExtendedResponse, error)
	// ListAtManagementGroupScope - Get all the deployments for a management group.
	ListAtManagementGroupScope(groupId string, deploymentsListAtManagementGroupScopeOptions *DeploymentsListAtManagementGroupScopeOptions) (DeploymentListResultPager, error)
	// ListAtSubscriptionScope - Get all the deployments for a subscription.
	ListAtSubscriptionScope(deploymentsListAtSubscriptionScopeOptions *DeploymentsListAtSubscriptionScopeOptions) (DeploymentListResultPager, error)
	// ListByResourceGroup - Get all the deployments for a resource group.
	ListByResourceGroup(resourceGroupName string, deploymentsListByResourceGroupOptions *DeploymentsListByResourceGroupOptions) (DeploymentListResultPager, error)
	// Validate - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
	Validate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment) (*DeploymentValidateResultResponse, error)
	// ValidateAtManagementGroupScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
	ValidateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters Deployment) (*DeploymentValidateResultResponse, error)
	// ValidateAtSubscriptionScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
	ValidateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment) (*DeploymentValidateResultResponse, error)
}

// deploymentsOperations implements the DeploymentsOperations interface.
type deploymentsOperations struct {
	*Client
	subscriptionID string
}

// CalculateTemplateHash - Calculate the hash of the given template.
func (client *deploymentsOperations) CalculateTemplateHash(ctx context.Context, templateParameter interface{}) (*TemplateHashResultResponse, error) {
	req, err := client.calculateTemplateHashCreateRequest(templateParameter)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.calculateTemplateHashHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// calculateTemplateHashCreateRequest creates the CalculateTemplateHash request.
func (client *deploymentsOperations) calculateTemplateHashCreateRequest(templateParameter interface{}) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/calculateTemplateHash"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(templateParameter)
}

// calculateTemplateHashHandleResponse handles the CalculateTemplateHash response.
func (client *deploymentsOperations) calculateTemplateHashHandleResponse(resp *azcore.Response) (*TemplateHashResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.calculateTemplateHashHandleError(resp)
	}
	result := TemplateHashResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.TemplateHashResult)
}

// calculateTemplateHashHandleError handles the CalculateTemplateHash error response.
func (client *deploymentsOperations) calculateTemplateHashHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Cancel - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resource group partially deployed.
func (client *deploymentsOperations) Cancel(ctx context.Context, resourceGroupName string, deploymentName string) (*http.Response, error) {
	req, err := client.cancelCreateRequest(resourceGroupName, deploymentName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.cancelHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// cancelCreateRequest creates the Cancel request.
func (client *deploymentsOperations) cancelCreateRequest(resourceGroupName string, deploymentName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// cancelHandleResponse handles the Cancel response.
func (client *deploymentsOperations) cancelHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.cancelHandleError(resp)
	}
	return resp.Response, nil
}

// cancelHandleError handles the Cancel error response.
func (client *deploymentsOperations) cancelHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// CancelAtManagementGroupScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
func (client *deploymentsOperations) CancelAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string) (*http.Response, error) {
	req, err := client.cancelAtManagementGroupScopeCreateRequest(groupId, deploymentName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.cancelAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// cancelAtManagementGroupScopeCreateRequest creates the CancelAtManagementGroupScope request.
func (client *deploymentsOperations) cancelAtManagementGroupScopeCreateRequest(groupId string, deploymentName string) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// cancelAtManagementGroupScopeHandleResponse handles the CancelAtManagementGroupScope response.
func (client *deploymentsOperations) cancelAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.cancelAtManagementGroupScopeHandleError(resp)
	}
	return resp.Response, nil
}

// cancelAtManagementGroupScopeHandleError handles the CancelAtManagementGroupScope error response.
func (client *deploymentsOperations) cancelAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// CancelAtSubscriptionScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
func (client *deploymentsOperations) CancelAtSubscriptionScope(ctx context.Context, deploymentName string) (*http.Response, error) {
	req, err := client.cancelAtSubscriptionScopeCreateRequest(deploymentName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.cancelAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// cancelAtSubscriptionScopeCreateRequest creates the CancelAtSubscriptionScope request.
func (client *deploymentsOperations) cancelAtSubscriptionScopeCreateRequest(deploymentName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// cancelAtSubscriptionScopeHandleResponse handles the CancelAtSubscriptionScope response.
func (client *deploymentsOperations) cancelAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.cancelAtSubscriptionScopeHandleError(resp)
	}
	return resp.Response, nil
}

// cancelAtSubscriptionScopeHandleError handles the CancelAtSubscriptionScope error response.
func (client *deploymentsOperations) cancelAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// CheckExistence - Checks whether the deployment exists.
func (client *deploymentsOperations) CheckExistence(ctx context.Context, resourceGroupName string, deploymentName string) (*http.Response, error) {
	req, err := client.checkExistenceCreateRequest(resourceGroupName, deploymentName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.checkExistenceHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// checkExistenceCreateRequest creates the CheckExistence request.
func (client *deploymentsOperations) checkExistenceCreateRequest(resourceGroupName string, deploymentName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodHead, *u)
	return req, nil
}

// checkExistenceHandleResponse handles the CheckExistence response.
func (client *deploymentsOperations) checkExistenceHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusNoContent, http.StatusNotFound) {
		return nil, client.checkExistenceHandleError(resp)
	}
	return resp.Response, nil
}

// checkExistenceHandleError handles the CheckExistence error response.
func (client *deploymentsOperations) checkExistenceHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// CheckExistenceAtManagementGroupScope - Checks whether the deployment exists.
func (client *deploymentsOperations) CheckExistenceAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string) (*http.Response, error) {
	req, err := client.checkExistenceAtManagementGroupScopeCreateRequest(groupId, deploymentName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.checkExistenceAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// checkExistenceAtManagementGroupScopeCreateRequest creates the CheckExistenceAtManagementGroupScope request.
func (client *deploymentsOperations) checkExistenceAtManagementGroupScopeCreateRequest(groupId string, deploymentName string) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodHead, *u)
	return req, nil
}

// checkExistenceAtManagementGroupScopeHandleResponse handles the CheckExistenceAtManagementGroupScope response.
func (client *deploymentsOperations) checkExistenceAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusNoContent, http.StatusNotFound) {
		return nil, client.checkExistenceAtManagementGroupScopeHandleError(resp)
	}
	return resp.Response, nil
}

// checkExistenceAtManagementGroupScopeHandleError handles the CheckExistenceAtManagementGroupScope error response.
func (client *deploymentsOperations) checkExistenceAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// CheckExistenceAtSubscriptionScope - Checks whether the deployment exists.
func (client *deploymentsOperations) CheckExistenceAtSubscriptionScope(ctx context.Context, deploymentName string) (*http.Response, error) {
	req, err := client.checkExistenceAtSubscriptionScopeCreateRequest(deploymentName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.checkExistenceAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// checkExistenceAtSubscriptionScopeCreateRequest creates the CheckExistenceAtSubscriptionScope request.
func (client *deploymentsOperations) checkExistenceAtSubscriptionScopeCreateRequest(deploymentName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodHead, *u)
	return req, nil
}

// checkExistenceAtSubscriptionScopeHandleResponse handles the CheckExistenceAtSubscriptionScope response.
func (client *deploymentsOperations) checkExistenceAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusNoContent, http.StatusNotFound) {
		return nil, client.checkExistenceAtSubscriptionScopeHandleError(resp)
	}
	return resp.Response, nil
}

// checkExistenceAtSubscriptionScopeHandleError handles the CheckExistenceAtSubscriptionScope error response.
func (client *deploymentsOperations) checkExistenceAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// CreateOrUpdate - You can provide the template and parameters directly in the request or link to JSON files.
func (client *deploymentsOperations) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment) (*DeploymentExtendedPollerResponse, error) {
	req, err := client.createOrUpdateCreateRequest(resourceGroupName, deploymentName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createOrUpdateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("deploymentsOperations.CreateOrUpdate", "", resp, client.createOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentExtendedPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *deploymentsOperations) ResumeCreateOrUpdate(token string) (DeploymentExtendedPoller, error) {
	pt, err := resumePollingTracker("deploymentsOperations.CreateOrUpdate", token, client.createOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentExtendedPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *deploymentsOperations) createOrUpdateCreateRequest(resourceGroupName string, deploymentName string, parameters Deployment) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateHandleResponse handles the CreateOrUpdate response.
func (client *deploymentsOperations) createOrUpdateHandleResponse(resp *azcore.Response) (*DeploymentExtendedPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusNoContent) {
		return nil, client.createOrUpdateHandleError(resp)
	}
	return &DeploymentExtendedPollerResponse{RawResponse: resp.Response}, nil
}

// createOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *deploymentsOperations) createOrUpdateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// CreateOrUpdateAtManagementGroupScope - You can provide the template and parameters directly in the request or link to JSON files.
func (client *deploymentsOperations) BeginCreateOrUpdateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters Deployment) (*DeploymentExtendedPollerResponse, error) {
	req, err := client.createOrUpdateAtManagementGroupScopeCreateRequest(groupId, deploymentName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createOrUpdateAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("deploymentsOperations.CreateOrUpdateAtManagementGroupScope", "", resp, client.createOrUpdateAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentExtendedPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *deploymentsOperations) ResumeCreateOrUpdateAtManagementGroupScope(token string) (DeploymentExtendedPoller, error) {
	pt, err := resumePollingTracker("deploymentsOperations.CreateOrUpdateAtManagementGroupScope", token, client.createOrUpdateAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentExtendedPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// createOrUpdateAtManagementGroupScopeCreateRequest creates the CreateOrUpdateAtManagementGroupScope request.
func (client *deploymentsOperations) createOrUpdateAtManagementGroupScopeCreateRequest(groupId string, deploymentName string, parameters Deployment) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateAtManagementGroupScopeHandleResponse handles the CreateOrUpdateAtManagementGroupScope response.
func (client *deploymentsOperations) createOrUpdateAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusNoContent) {
		return nil, client.createOrUpdateAtManagementGroupScopeHandleError(resp)
	}
	return &DeploymentExtendedPollerResponse{RawResponse: resp.Response}, nil
}

// createOrUpdateAtManagementGroupScopeHandleError handles the CreateOrUpdateAtManagementGroupScope error response.
func (client *deploymentsOperations) createOrUpdateAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// CreateOrUpdateAtSubscriptionScope - You can provide the template and parameters directly in the request or link to JSON files.
func (client *deploymentsOperations) BeginCreateOrUpdateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment) (*DeploymentExtendedPollerResponse, error) {
	req, err := client.createOrUpdateAtSubscriptionScopeCreateRequest(deploymentName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createOrUpdateAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("deploymentsOperations.CreateOrUpdateAtSubscriptionScope", "", resp, client.createOrUpdateAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentExtendedPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *deploymentsOperations) ResumeCreateOrUpdateAtSubscriptionScope(token string) (DeploymentExtendedPoller, error) {
	pt, err := resumePollingTracker("deploymentsOperations.CreateOrUpdateAtSubscriptionScope", token, client.createOrUpdateAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentExtendedPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// createOrUpdateAtSubscriptionScopeCreateRequest creates the CreateOrUpdateAtSubscriptionScope request.
func (client *deploymentsOperations) createOrUpdateAtSubscriptionScopeCreateRequest(deploymentName string, parameters Deployment) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateAtSubscriptionScopeHandleResponse handles the CreateOrUpdateAtSubscriptionScope response.
func (client *deploymentsOperations) createOrUpdateAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusNoContent) {
		return nil, client.createOrUpdateAtSubscriptionScopeHandleError(resp)
	}
	return &DeploymentExtendedPollerResponse{RawResponse: resp.Response}, nil
}

// createOrUpdateAtSubscriptionScopeHandleError handles the CreateOrUpdateAtSubscriptionScope error response.
func (client *deploymentsOperations) createOrUpdateAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Delete - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
func (client *deploymentsOperations) BeginDelete(ctx context.Context, resourceGroupName string, deploymentName string) (*HTTPPollerResponse, error) {
	req, err := client.deleteCreateRequest(resourceGroupName, deploymentName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("deploymentsOperations.Delete", "", resp, client.deleteHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *deploymentsOperations) ResumeDelete(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("deploymentsOperations.Delete", token, client.deleteHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *deploymentsOperations) deleteCreateRequest(resourceGroupName string, deploymentName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *deploymentsOperations) deleteHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// deleteHandleError handles the Delete error response.
func (client *deploymentsOperations) deleteHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// DeleteAtManagementGroupScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
func (client *deploymentsOperations) BeginDeleteAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string) (*HTTPPollerResponse, error) {
	req, err := client.deleteAtManagementGroupScopeCreateRequest(groupId, deploymentName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("deploymentsOperations.DeleteAtManagementGroupScope", "", resp, client.deleteAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *deploymentsOperations) ResumeDeleteAtManagementGroupScope(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("deploymentsOperations.DeleteAtManagementGroupScope", token, client.deleteAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deleteAtManagementGroupScopeCreateRequest creates the DeleteAtManagementGroupScope request.
func (client *deploymentsOperations) deleteAtManagementGroupScopeCreateRequest(groupId string, deploymentName string) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAtManagementGroupScopeHandleResponse handles the DeleteAtManagementGroupScope response.
func (client *deploymentsOperations) deleteAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteAtManagementGroupScopeHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// deleteAtManagementGroupScopeHandleError handles the DeleteAtManagementGroupScope error response.
func (client *deploymentsOperations) deleteAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// DeleteAtSubscriptionScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
func (client *deploymentsOperations) BeginDeleteAtSubscriptionScope(ctx context.Context, deploymentName string) (*HTTPPollerResponse, error) {
	req, err := client.deleteAtSubscriptionScopeCreateRequest(deploymentName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("deploymentsOperations.DeleteAtSubscriptionScope", "", resp, client.deleteAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *deploymentsOperations) ResumeDeleteAtSubscriptionScope(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("deploymentsOperations.DeleteAtSubscriptionScope", token, client.deleteAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deleteAtSubscriptionScopeCreateRequest creates the DeleteAtSubscriptionScope request.
func (client *deploymentsOperations) deleteAtSubscriptionScopeCreateRequest(deploymentName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAtSubscriptionScopeHandleResponse handles the DeleteAtSubscriptionScope response.
func (client *deploymentsOperations) deleteAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*HTTPPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteAtSubscriptionScopeHandleError(resp)
	}
	return &HTTPPollerResponse{RawResponse: resp.Response}, nil
}

// deleteAtSubscriptionScopeHandleError handles the DeleteAtSubscriptionScope error response.
func (client *deploymentsOperations) deleteAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ExportTemplate - Exports the template used for specified deployment.
func (client *deploymentsOperations) ExportTemplate(ctx context.Context, resourceGroupName string, deploymentName string) (*DeploymentExportResultResponse, error) {
	req, err := client.exportTemplateCreateRequest(resourceGroupName, deploymentName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.exportTemplateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// exportTemplateCreateRequest creates the ExportTemplate request.
func (client *deploymentsOperations) exportTemplateCreateRequest(resourceGroupName string, deploymentName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// exportTemplateHandleResponse handles the ExportTemplate response.
func (client *deploymentsOperations) exportTemplateHandleResponse(resp *azcore.Response) (*DeploymentExportResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.exportTemplateHandleError(resp)
	}
	result := DeploymentExportResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExportResult)
}

// exportTemplateHandleError handles the ExportTemplate error response.
func (client *deploymentsOperations) exportTemplateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ExportTemplateAtManagementGroupScope - Exports the template used for specified deployment.
func (client *deploymentsOperations) ExportTemplateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string) (*DeploymentExportResultResponse, error) {
	req, err := client.exportTemplateAtManagementGroupScopeCreateRequest(groupId, deploymentName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.exportTemplateAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// exportTemplateAtManagementGroupScopeCreateRequest creates the ExportTemplateAtManagementGroupScope request.
func (client *deploymentsOperations) exportTemplateAtManagementGroupScopeCreateRequest(groupId string, deploymentName string) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// exportTemplateAtManagementGroupScopeHandleResponse handles the ExportTemplateAtManagementGroupScope response.
func (client *deploymentsOperations) exportTemplateAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentExportResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.exportTemplateAtManagementGroupScopeHandleError(resp)
	}
	result := DeploymentExportResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExportResult)
}

// exportTemplateAtManagementGroupScopeHandleError handles the ExportTemplateAtManagementGroupScope error response.
func (client *deploymentsOperations) exportTemplateAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ExportTemplateAtSubscriptionScope - Exports the template used for specified deployment.
func (client *deploymentsOperations) ExportTemplateAtSubscriptionScope(ctx context.Context, deploymentName string) (*DeploymentExportResultResponse, error) {
	req, err := client.exportTemplateAtSubscriptionScopeCreateRequest(deploymentName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.exportTemplateAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// exportTemplateAtSubscriptionScopeCreateRequest creates the ExportTemplateAtSubscriptionScope request.
func (client *deploymentsOperations) exportTemplateAtSubscriptionScopeCreateRequest(deploymentName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// exportTemplateAtSubscriptionScopeHandleResponse handles the ExportTemplateAtSubscriptionScope response.
func (client *deploymentsOperations) exportTemplateAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentExportResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.exportTemplateAtSubscriptionScopeHandleError(resp)
	}
	result := DeploymentExportResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExportResult)
}

// exportTemplateAtSubscriptionScopeHandleError handles the ExportTemplateAtSubscriptionScope error response.
func (client *deploymentsOperations) exportTemplateAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Get - Gets a deployment.
func (client *deploymentsOperations) Get(ctx context.Context, resourceGroupName string, deploymentName string) (*DeploymentExtendedResponse, error) {
	req, err := client.getCreateRequest(resourceGroupName, deploymentName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getCreateRequest creates the Get request.
func (client *deploymentsOperations) getCreateRequest(resourceGroupName string, deploymentName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *deploymentsOperations) getHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getHandleError(resp)
	}
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// getHandleError handles the Get error response.
func (client *deploymentsOperations) getHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetAtManagementGroupScope - Gets a deployment.
func (client *deploymentsOperations) GetAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string) (*DeploymentExtendedResponse, error) {
	req, err := client.getAtManagementGroupScopeCreateRequest(groupId, deploymentName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getAtManagementGroupScopeCreateRequest creates the GetAtManagementGroupScope request.
func (client *deploymentsOperations) getAtManagementGroupScopeCreateRequest(groupId string, deploymentName string) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getAtManagementGroupScopeHandleResponse handles the GetAtManagementGroupScope response.
func (client *deploymentsOperations) getAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getAtManagementGroupScopeHandleError(resp)
	}
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// getAtManagementGroupScopeHandleError handles the GetAtManagementGroupScope error response.
func (client *deploymentsOperations) getAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetAtSubscriptionScope - Gets a deployment.
func (client *deploymentsOperations) GetAtSubscriptionScope(ctx context.Context, deploymentName string) (*DeploymentExtendedResponse, error) {
	req, err := client.getAtSubscriptionScopeCreateRequest(deploymentName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getAtSubscriptionScopeCreateRequest creates the GetAtSubscriptionScope request.
func (client *deploymentsOperations) getAtSubscriptionScopeCreateRequest(deploymentName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getAtSubscriptionScopeHandleResponse handles the GetAtSubscriptionScope response.
func (client *deploymentsOperations) getAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getAtSubscriptionScopeHandleError(resp)
	}
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// getAtSubscriptionScopeHandleError handles the GetAtSubscriptionScope error response.
func (client *deploymentsOperations) getAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ListAtManagementGroupScope - Get all the deployments for a management group.
func (client *deploymentsOperations) ListAtManagementGroupScope(groupId string, deploymentsListAtManagementGroupScopeOptions *DeploymentsListAtManagementGroupScopeOptions) (DeploymentListResultPager, error) {
	req, err := client.listAtManagementGroupScopeCreateRequest(groupId, deploymentsListAtManagementGroupScopeOptions)
	if err != nil {
		return nil, err
	}
	return &deploymentListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listAtManagementGroupScopeHandleResponse,
		advancer: func(resp *DeploymentListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.DeploymentListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.DeploymentListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listAtManagementGroupScopeCreateRequest creates the ListAtManagementGroupScope request.
func (client *deploymentsOperations) listAtManagementGroupScopeCreateRequest(groupId string, deploymentsListAtManagementGroupScopeOptions *DeploymentsListAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	if deploymentsListAtManagementGroupScopeOptions != nil && deploymentsListAtManagementGroupScopeOptions.Filter != nil {
		query.Set("$filter", *deploymentsListAtManagementGroupScopeOptions.Filter)
	}
	if deploymentsListAtManagementGroupScopeOptions != nil && deploymentsListAtManagementGroupScopeOptions.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*deploymentsListAtManagementGroupScopeOptions.Top), 10))
	}
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listAtManagementGroupScopeHandleResponse handles the ListAtManagementGroupScope response.
func (client *deploymentsOperations) listAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listAtManagementGroupScopeHandleError(resp)
	}
	result := DeploymentListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentListResult)
}

// listAtManagementGroupScopeHandleError handles the ListAtManagementGroupScope error response.
func (client *deploymentsOperations) listAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ListAtSubscriptionScope - Get all the deployments for a subscription.
func (client *deploymentsOperations) ListAtSubscriptionScope(deploymentsListAtSubscriptionScopeOptions *DeploymentsListAtSubscriptionScopeOptions) (DeploymentListResultPager, error) {
	req, err := client.listAtSubscriptionScopeCreateRequest(deploymentsListAtSubscriptionScopeOptions)
	if err != nil {
		return nil, err
	}
	return &deploymentListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listAtSubscriptionScopeHandleResponse,
		advancer: func(resp *DeploymentListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.DeploymentListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.DeploymentListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listAtSubscriptionScopeCreateRequest creates the ListAtSubscriptionScope request.
func (client *deploymentsOperations) listAtSubscriptionScopeCreateRequest(deploymentsListAtSubscriptionScopeOptions *DeploymentsListAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	if deploymentsListAtSubscriptionScopeOptions != nil && deploymentsListAtSubscriptionScopeOptions.Filter != nil {
		query.Set("$filter", *deploymentsListAtSubscriptionScopeOptions.Filter)
	}
	if deploymentsListAtSubscriptionScopeOptions != nil && deploymentsListAtSubscriptionScopeOptions.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*deploymentsListAtSubscriptionScopeOptions.Top), 10))
	}
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listAtSubscriptionScopeHandleResponse handles the ListAtSubscriptionScope response.
func (client *deploymentsOperations) listAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listAtSubscriptionScopeHandleError(resp)
	}
	result := DeploymentListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentListResult)
}

// listAtSubscriptionScopeHandleError handles the ListAtSubscriptionScope error response.
func (client *deploymentsOperations) listAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ListByResourceGroup - Get all the deployments for a resource group.
func (client *deploymentsOperations) ListByResourceGroup(resourceGroupName string, deploymentsListByResourceGroupOptions *DeploymentsListByResourceGroupOptions) (DeploymentListResultPager, error) {
	req, err := client.listByResourceGroupCreateRequest(resourceGroupName, deploymentsListByResourceGroupOptions)
	if err != nil {
		return nil, err
	}
	return &deploymentListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listByResourceGroupHandleResponse,
		advancer: func(resp *DeploymentListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.DeploymentListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.DeploymentListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *deploymentsOperations) listByResourceGroupCreateRequest(resourceGroupName string, deploymentsListByResourceGroupOptions *DeploymentsListByResourceGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	if deploymentsListByResourceGroupOptions != nil && deploymentsListByResourceGroupOptions.Filter != nil {
		query.Set("$filter", *deploymentsListByResourceGroupOptions.Filter)
	}
	if deploymentsListByResourceGroupOptions != nil && deploymentsListByResourceGroupOptions.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*deploymentsListByResourceGroupOptions.Top), 10))
	}
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *deploymentsOperations) listByResourceGroupHandleResponse(resp *azcore.Response) (*DeploymentListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listByResourceGroupHandleError(resp)
	}
	result := DeploymentListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentListResult)
}

// listByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *deploymentsOperations) listByResourceGroupHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Validate - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
func (client *deploymentsOperations) Validate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment) (*DeploymentValidateResultResponse, error) {
	req, err := client.validateCreateRequest(resourceGroupName, deploymentName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.validateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// validateCreateRequest creates the Validate request.
func (client *deploymentsOperations) validateCreateRequest(resourceGroupName string, deploymentName string, parameters Deployment) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(parameters)
}

// validateHandleResponse handles the Validate response.
func (client *deploymentsOperations) validateHandleResponse(resp *azcore.Response) (*DeploymentValidateResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusBadRequest) {
		return nil, client.validateHandleError(resp)
	}
	result := DeploymentValidateResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentValidateResult)
}

// validateHandleError handles the Validate error response.
func (client *deploymentsOperations) validateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ValidateAtManagementGroupScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
func (client *deploymentsOperations) ValidateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters Deployment) (*DeploymentValidateResultResponse, error) {
	req, err := client.validateAtManagementGroupScopeCreateRequest(groupId, deploymentName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.validateAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// validateAtManagementGroupScopeCreateRequest creates the ValidateAtManagementGroupScope request.
func (client *deploymentsOperations) validateAtManagementGroupScopeCreateRequest(groupId string, deploymentName string, parameters Deployment) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(parameters)
}

// validateAtManagementGroupScopeHandleResponse handles the ValidateAtManagementGroupScope response.
func (client *deploymentsOperations) validateAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentValidateResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusBadRequest) {
		return nil, client.validateAtManagementGroupScopeHandleError(resp)
	}
	result := DeploymentValidateResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentValidateResult)
}

// validateAtManagementGroupScopeHandleError handles the ValidateAtManagementGroupScope error response.
func (client *deploymentsOperations) validateAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ValidateAtSubscriptionScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
func (client *deploymentsOperations) ValidateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment) (*DeploymentValidateResultResponse, error) {
	req, err := client.validateAtSubscriptionScopeCreateRequest(deploymentName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.validateAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// validateAtSubscriptionScopeCreateRequest creates the ValidateAtSubscriptionScope request.
func (client *deploymentsOperations) validateAtSubscriptionScopeCreateRequest(deploymentName string, parameters Deployment) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(parameters)
}

// validateAtSubscriptionScopeHandleResponse handles the ValidateAtSubscriptionScope response.
func (client *deploymentsOperations) validateAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentValidateResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusBadRequest) {
		return nil, client.validateAtSubscriptionScopeHandleError(resp)
	}
	result := DeploymentValidateResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentValidateResult)
}

// validateAtSubscriptionScopeHandleError handles the ValidateAtSubscriptionScope error response.
func (client *deploymentsOperations) validateAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}
