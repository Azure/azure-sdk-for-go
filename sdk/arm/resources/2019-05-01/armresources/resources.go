// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armresources

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// ResourcesOperations contains the methods for the Resources group.
type ResourcesOperations interface {
	// CheckExistence - Checks whether a resource exists.
	CheckExistence(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*http.Response, error)
	// CheckExistenceByID - Checks by ID whether a resource exists.
	CheckExistenceByID(ctx context.Context, resourceId string) (*http.Response, error)
	// BeginCreateOrUpdate - Creates a resource.
	BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*GenericResourceResponse, error)
	// ResumeCreateOrUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdate(token string) (GenericResourcePoller, error)
	// BeginCreateOrUpdateByID - Create a resource by ID.
	BeginCreateOrUpdateByID(ctx context.Context, resourceId string, parameters GenericResource) (*GenericResourceResponse, error)
	// ResumeCreateOrUpdateByID - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdateByID(token string) (GenericResourcePoller, error)
	// BeginDelete - Deletes a resource.
	BeginDelete(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*HTTPResponse, error)
	// ResumeDelete - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDelete(token string) (HTTPPoller, error)
	// BeginDeleteByID - Deletes a resource by ID.
	BeginDeleteByID(ctx context.Context, resourceId string) (*HTTPResponse, error)
	// ResumeDeleteByID - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteByID(token string) (HTTPPoller, error)
	// Get - Gets a resource.
	Get(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*GenericResourceResponse, error)
	// GetByID - Gets a resource by ID.
	GetByID(ctx context.Context, resourceId string) (*GenericResourceResponse, error)
	// List - Get all the resources in a subscription.
	List(resourcesListOptions *ResourcesListOptions) (ResourceListResultPager, error)
	// ListByResourceGroup - Get all the resources for a resource group.
	ListByResourceGroup(resourceGroupName string, resourcesListByResourceGroupOptions *ResourcesListByResourceGroupOptions) (ResourceListResultPager, error)
	// BeginMoveResources - The resources to move must be in the same source resource group. The target resource group may be in a different subscription. When moving resources, both the source group and the target group are locked for the duration of the operation. Write and delete operations are blocked on the groups until the move completes.
	BeginMoveResources(ctx context.Context, sourceResourceGroupName string, parameters ResourcesMoveInfo) (*HTTPResponse, error)
	// ResumeMoveResources - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeMoveResources(token string) (HTTPPoller, error)
	// BeginUpdate - Updates a resource.
	BeginUpdate(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*GenericResourceResponse, error)
	// ResumeUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeUpdate(token string) (GenericResourcePoller, error)
	// BeginUpdateByID - Updates a resource by ID.
	BeginUpdateByID(ctx context.Context, resourceId string, parameters GenericResource) (*GenericResourceResponse, error)
	// ResumeUpdateByID - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeUpdateByID(token string) (GenericResourcePoller, error)
	// BeginValidateMoveResources - This operation checks whether the specified resources can be moved to the target. The resources to move must be in the same source resource group. The target resource group may be in a different subscription. If validation succeeds, it returns HTTP response code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an error message. Retrieve the URL in the Location header value to check the result of the long-running operation.
	BeginValidateMoveResources(ctx context.Context, sourceResourceGroupName string, parameters ResourcesMoveInfo) (*HTTPResponse, error)
	// ResumeValidateMoveResources - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeValidateMoveResources(token string) (HTTPPoller, error)
}

// resourcesOperations implements the ResourcesOperations interface.
type resourcesOperations struct {
	*Client
	subscriptionID string
}

// CheckExistence - Checks whether a resource exists.
func (client *resourcesOperations) CheckExistence(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*http.Response, error) {
	req, err := client.checkExistenceCreateRequest(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.checkExistenceHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// checkExistenceCreateRequest creates the CheckExistence request.
func (client *resourcesOperations) checkExistenceCreateRequest(resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodHead, *u)
	return req, nil
}

// checkExistenceHandleResponse handles the CheckExistence response.
func (client *resourcesOperations) checkExistenceHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusNoContent, http.StatusNotFound) {
		return nil, client.checkExistenceHandleError(resp)
	}
	return resp.Response, nil
}

// checkExistenceHandleError handles the CheckExistence error response.
func (client *resourcesOperations) checkExistenceHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// CheckExistenceByID - Checks by ID whether a resource exists.
func (client *resourcesOperations) CheckExistenceByID(ctx context.Context, resourceId string) (*http.Response, error) {
	req, err := client.checkExistenceByIdCreateRequest(resourceId)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.checkExistenceByIdHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// checkExistenceByIdCreateRequest creates the CheckExistenceByID request.
func (client *resourcesOperations) checkExistenceByIdCreateRequest(resourceId string) (*azcore.Request, error) {
	urlPath := "/{resourceId}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceId)
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodHead, *u)
	return req, nil
}

// checkExistenceByIdHandleResponse handles the CheckExistenceByID response.
func (client *resourcesOperations) checkExistenceByIdHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusNoContent, http.StatusNotFound) {
		return nil, client.checkExistenceByIdHandleError(resp)
	}
	return resp.Response, nil
}

// checkExistenceByIdHandleError handles the CheckExistenceByID error response.
func (client *resourcesOperations) checkExistenceByIdHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// CreateOrUpdate - Creates a resource.
func (client *resourcesOperations) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*GenericResourceResponse, error) {
	req, err := client.createOrUpdateCreateRequest(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createOrUpdateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("resourcesOperations.CreateOrUpdate", "", resp, client.createOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &genericResourcePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*GenericResourceResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *resourcesOperations) ResumeCreateOrUpdate(token string) (GenericResourcePoller, error) {
	pt, err := resumePollingTracker("resourcesOperations.CreateOrUpdate", token, client.createOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	return &genericResourcePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *resourcesOperations) createOrUpdateCreateRequest(resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateHandleResponse handles the CreateOrUpdate response.
func (client *resourcesOperations) createOrUpdateHandleResponse(resp *azcore.Response) (*GenericResourceResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.createOrUpdateHandleError(resp)
	}
	result := GenericResourceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.GenericResource)
}

// createOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *resourcesOperations) createOrUpdateHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// CreateOrUpdateByID - Create a resource by ID.
func (client *resourcesOperations) BeginCreateOrUpdateByID(ctx context.Context, resourceId string, parameters GenericResource) (*GenericResourceResponse, error) {
	req, err := client.createOrUpdateByIdCreateRequest(resourceId, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createOrUpdateByIdHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("resourcesOperations.CreateOrUpdateByID", "", resp, client.createOrUpdateByIdHandleError)
	if err != nil {
		return nil, err
	}
	poller := &genericResourcePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*GenericResourceResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *resourcesOperations) ResumeCreateOrUpdateByID(token string) (GenericResourcePoller, error) {
	pt, err := resumePollingTracker("resourcesOperations.CreateOrUpdateByID", token, client.createOrUpdateByIdHandleError)
	if err != nil {
		return nil, err
	}
	return &genericResourcePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// createOrUpdateByIdCreateRequest creates the CreateOrUpdateByID request.
func (client *resourcesOperations) createOrUpdateByIdCreateRequest(resourceId string, parameters GenericResource) (*azcore.Request, error) {
	urlPath := "/{resourceId}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceId)
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateByIdHandleResponse handles the CreateOrUpdateByID response.
func (client *resourcesOperations) createOrUpdateByIdHandleResponse(resp *azcore.Response) (*GenericResourceResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.createOrUpdateByIdHandleError(resp)
	}
	result := GenericResourceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.GenericResource)
}

// createOrUpdateByIdHandleError handles the CreateOrUpdateByID error response.
func (client *resourcesOperations) createOrUpdateByIdHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Delete - Deletes a resource.
func (client *resourcesOperations) BeginDelete(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*HTTPResponse, error) {
	req, err := client.deleteCreateRequest(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("resourcesOperations.Delete", "", resp, client.deleteHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *resourcesOperations) ResumeDelete(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("resourcesOperations.Delete", token, client.deleteHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *resourcesOperations) deleteCreateRequest(resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *resourcesOperations) deleteHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// deleteHandleError handles the Delete error response.
func (client *resourcesOperations) deleteHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// DeleteByID - Deletes a resource by ID.
func (client *resourcesOperations) BeginDeleteByID(ctx context.Context, resourceId string) (*HTTPResponse, error) {
	req, err := client.deleteByIdCreateRequest(resourceId)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteByIdHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("resourcesOperations.DeleteByID", "", resp, client.deleteByIdHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *resourcesOperations) ResumeDeleteByID(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("resourcesOperations.DeleteByID", token, client.deleteByIdHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deleteByIdCreateRequest creates the DeleteByID request.
func (client *resourcesOperations) deleteByIdCreateRequest(resourceId string) (*azcore.Request, error) {
	urlPath := "/{resourceId}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceId)
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteByIdHandleResponse handles the DeleteByID response.
func (client *resourcesOperations) deleteByIdHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteByIdHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// deleteByIdHandleError handles the DeleteByID error response.
func (client *resourcesOperations) deleteByIdHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Get - Gets a resource.
func (client *resourcesOperations) Get(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*GenericResourceResponse, error) {
	req, err := client.getCreateRequest(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getCreateRequest creates the Get request.
func (client *resourcesOperations) getCreateRequest(resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *resourcesOperations) getHandleResponse(resp *azcore.Response) (*GenericResourceResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getHandleError(resp)
	}
	result := GenericResourceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.GenericResource)
}

// getHandleError handles the Get error response.
func (client *resourcesOperations) getHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetByID - Gets a resource by ID.
func (client *resourcesOperations) GetByID(ctx context.Context, resourceId string) (*GenericResourceResponse, error) {
	req, err := client.getByIdCreateRequest(resourceId)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getByIdHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getByIdCreateRequest creates the GetByID request.
func (client *resourcesOperations) getByIdCreateRequest(resourceId string) (*azcore.Request, error) {
	urlPath := "/{resourceId}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceId)
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getByIdHandleResponse handles the GetByID response.
func (client *resourcesOperations) getByIdHandleResponse(resp *azcore.Response) (*GenericResourceResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getByIdHandleError(resp)
	}
	result := GenericResourceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.GenericResource)
}

// getByIdHandleError handles the GetByID error response.
func (client *resourcesOperations) getByIdHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// List - Get all the resources in a subscription.
func (client *resourcesOperations) List(resourcesListOptions *ResourcesListOptions) (ResourceListResultPager, error) {
	req, err := client.listCreateRequest(resourcesListOptions)
	if err != nil {
		return nil, err
	}
	return &resourceListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listHandleResponse,
		advancer: func(resp *ResourceListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ResourceListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ResourceListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listCreateRequest creates the List request.
func (client *resourcesOperations) listCreateRequest(resourcesListOptions *ResourcesListOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resources"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	if resourcesListOptions != nil && resourcesListOptions.Filter != nil {
		query.Set("$filter", *resourcesListOptions.Filter)
	}
	if resourcesListOptions != nil && resourcesListOptions.Expand != nil {
		query.Set("$expand", *resourcesListOptions.Expand)
	}
	if resourcesListOptions != nil && resourcesListOptions.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*resourcesListOptions.Top), 10))
	}
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listHandleResponse handles the List response.
func (client *resourcesOperations) listHandleResponse(resp *azcore.Response) (*ResourceListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listHandleError(resp)
	}
	result := ResourceListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ResourceListResult)
}

// listHandleError handles the List error response.
func (client *resourcesOperations) listHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// ListByResourceGroup - Get all the resources for a resource group.
func (client *resourcesOperations) ListByResourceGroup(resourceGroupName string, resourcesListByResourceGroupOptions *ResourcesListByResourceGroupOptions) (ResourceListResultPager, error) {
	req, err := client.listByResourceGroupCreateRequest(resourceGroupName, resourcesListByResourceGroupOptions)
	if err != nil {
		return nil, err
	}
	return &resourceListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listByResourceGroupHandleResponse,
		advancer: func(resp *ResourceListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ResourceListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ResourceListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *resourcesOperations) listByResourceGroupCreateRequest(resourceGroupName string, resourcesListByResourceGroupOptions *ResourcesListByResourceGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/resources"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	if resourcesListByResourceGroupOptions != nil && resourcesListByResourceGroupOptions.Filter != nil {
		query.Set("$filter", *resourcesListByResourceGroupOptions.Filter)
	}
	if resourcesListByResourceGroupOptions != nil && resourcesListByResourceGroupOptions.Expand != nil {
		query.Set("$expand", *resourcesListByResourceGroupOptions.Expand)
	}
	if resourcesListByResourceGroupOptions != nil && resourcesListByResourceGroupOptions.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*resourcesListByResourceGroupOptions.Top), 10))
	}
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *resourcesOperations) listByResourceGroupHandleResponse(resp *azcore.Response) (*ResourceListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listByResourceGroupHandleError(resp)
	}
	result := ResourceListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ResourceListResult)
}

// listByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *resourcesOperations) listByResourceGroupHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// MoveResources - The resources to move must be in the same source resource group. The target resource group may be in a different subscription. When moving resources, both the source group and the target group are locked for the duration of the operation. Write and delete operations are blocked on the groups until the move completes.
func (client *resourcesOperations) BeginMoveResources(ctx context.Context, sourceResourceGroupName string, parameters ResourcesMoveInfo) (*HTTPResponse, error) {
	req, err := client.moveResourcesCreateRequest(sourceResourceGroupName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.moveResourcesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("resourcesOperations.MoveResources", "", resp, client.moveResourcesHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *resourcesOperations) ResumeMoveResources(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("resourcesOperations.MoveResources", token, client.moveResourcesHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// moveResourcesCreateRequest creates the MoveResources request.
func (client *resourcesOperations) moveResourcesCreateRequest(sourceResourceGroupName string, parameters ResourcesMoveInfo) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/moveResources"
	urlPath = strings.ReplaceAll(urlPath, "{sourceResourceGroupName}", url.PathEscape(sourceResourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(parameters)
}

// moveResourcesHandleResponse handles the MoveResources response.
func (client *resourcesOperations) moveResourcesHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.moveResourcesHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// moveResourcesHandleError handles the MoveResources error response.
func (client *resourcesOperations) moveResourcesHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Update - Updates a resource.
func (client *resourcesOperations) BeginUpdate(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*GenericResourceResponse, error) {
	req, err := client.updateCreateRequest(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.updateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("resourcesOperations.Update", "", resp, client.updateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &genericResourcePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*GenericResourceResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *resourcesOperations) ResumeUpdate(token string) (GenericResourcePoller, error) {
	pt, err := resumePollingTracker("resourcesOperations.Update", token, client.updateHandleError)
	if err != nil {
		return nil, err
	}
	return &genericResourcePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// updateCreateRequest creates the Update request.
func (client *resourcesOperations) updateCreateRequest(resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPatch, *u)
	return req, req.MarshalAsJSON(parameters)
}

// updateHandleResponse handles the Update response.
func (client *resourcesOperations) updateHandleResponse(resp *azcore.Response) (*GenericResourceResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.updateHandleError(resp)
	}
	result := GenericResourceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.GenericResource)
}

// updateHandleError handles the Update error response.
func (client *resourcesOperations) updateHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// UpdateByID - Updates a resource by ID.
func (client *resourcesOperations) BeginUpdateByID(ctx context.Context, resourceId string, parameters GenericResource) (*GenericResourceResponse, error) {
	req, err := client.updateByIdCreateRequest(resourceId, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.updateByIdHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("resourcesOperations.UpdateByID", "", resp, client.updateByIdHandleError)
	if err != nil {
		return nil, err
	}
	poller := &genericResourcePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*GenericResourceResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *resourcesOperations) ResumeUpdateByID(token string) (GenericResourcePoller, error) {
	pt, err := resumePollingTracker("resourcesOperations.UpdateByID", token, client.updateByIdHandleError)
	if err != nil {
		return nil, err
	}
	return &genericResourcePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// updateByIdCreateRequest creates the UpdateByID request.
func (client *resourcesOperations) updateByIdCreateRequest(resourceId string, parameters GenericResource) (*azcore.Request, error) {
	urlPath := "/{resourceId}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceId)
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPatch, *u)
	return req, req.MarshalAsJSON(parameters)
}

// updateByIdHandleResponse handles the UpdateByID response.
func (client *resourcesOperations) updateByIdHandleResponse(resp *azcore.Response) (*GenericResourceResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.updateByIdHandleError(resp)
	}
	result := GenericResourceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.GenericResource)
}

// updateByIdHandleError handles the UpdateByID error response.
func (client *resourcesOperations) updateByIdHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// ValidateMoveResources - This operation checks whether the specified resources can be moved to the target. The resources to move must be in the same source resource group. The target resource group may be in a different subscription. If validation succeeds, it returns HTTP response code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an error message. Retrieve the URL in the Location header value to check the result of the long-running operation.
func (client *resourcesOperations) BeginValidateMoveResources(ctx context.Context, sourceResourceGroupName string, parameters ResourcesMoveInfo) (*HTTPResponse, error) {
	req, err := client.validateMoveResourcesCreateRequest(sourceResourceGroupName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.validateMoveResourcesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("resourcesOperations.ValidateMoveResources", "", resp, client.validateMoveResourcesHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *resourcesOperations) ResumeValidateMoveResources(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("resourcesOperations.ValidateMoveResources", token, client.validateMoveResourcesHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// validateMoveResourcesCreateRequest creates the ValidateMoveResources request.
func (client *resourcesOperations) validateMoveResourcesCreateRequest(sourceResourceGroupName string, parameters ResourcesMoveInfo) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/validateMoveResources"
	urlPath = strings.ReplaceAll(urlPath, "{sourceResourceGroupName}", url.PathEscape(sourceResourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-05-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(parameters)
}

// validateMoveResourcesHandleResponse handles the ValidateMoveResources response.
func (client *resourcesOperations) validateMoveResourcesHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent, http.StatusConflict) {
		return nil, client.validateMoveResourcesHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// validateMoveResourcesHandleError handles the ValidateMoveResources error response.
func (client *resourcesOperations) validateMoveResourcesHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}
