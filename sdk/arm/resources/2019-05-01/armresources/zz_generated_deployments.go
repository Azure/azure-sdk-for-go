// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armresources

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// DeploymentsOperations contains the methods for the Deployments group.
type DeploymentsOperations interface {
	// CalculateTemplateHash - Calculate the hash of the given template.
	CalculateTemplateHash(ctx context.Context, templateParameter interface{}, options *DeploymentsCalculateTemplateHashOptions) (*TemplateHashResultResponse, error)
	// Cancel - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resource group partially deployed.
	Cancel(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCancelOptions) (*http.Response, error)
	// CancelAtManagementGroupScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
	CancelAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsCancelAtManagementGroupScopeOptions) (*http.Response, error)
	// CancelAtSubscriptionScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
	CancelAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsCancelAtSubscriptionScopeOptions) (*http.Response, error)
	// CheckExistence - Checks whether the deployment exists.
	CheckExistence(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCheckExistenceOptions) (*http.Response, error)
	// CheckExistenceAtManagementGroupScope - Checks whether the deployment exists.
	CheckExistenceAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsCheckExistenceAtManagementGroupScopeOptions) (*http.Response, error)
	// CheckExistenceAtSubscriptionScope - Checks whether the deployment exists.
	CheckExistenceAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtSubscriptionScopeOptions) (*http.Response, error)
	// BeginCreateOrUpdate - You can provide the template and parameters directly in the request or link to JSON files.
	BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateOptions) (*DeploymentExtendedPollerResponse, error)
	// ResumeCreateOrUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdate(token string) (DeploymentExtendedPoller, error)
	// BeginCreateOrUpdateAtManagementGroupScope - You can provide the template and parameters directly in the request or link to JSON files.
	BeginCreateOrUpdateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtManagementGroupScopeOptions) (*DeploymentExtendedPollerResponse, error)
	// ResumeCreateOrUpdateAtManagementGroupScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdateAtManagementGroupScope(token string) (DeploymentExtendedPoller, error)
	// BeginCreateOrUpdateAtSubscriptionScope - You can provide the template and parameters directly in the request or link to JSON files.
	BeginCreateOrUpdateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtSubscriptionScopeOptions) (*DeploymentExtendedPollerResponse, error)
	// ResumeCreateOrUpdateAtSubscriptionScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdateAtSubscriptionScope(token string) (DeploymentExtendedPoller, error)
	// BeginDelete - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
	BeginDelete(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsDeleteOptions) (*HTTPPollerResponse, error)
	// ResumeDelete - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDelete(token string) (HTTPPoller, error)
	// BeginDeleteAtManagementGroupScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
	BeginDeleteAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsDeleteAtManagementGroupScopeOptions) (*HTTPPollerResponse, error)
	// ResumeDeleteAtManagementGroupScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAtManagementGroupScope(token string) (HTTPPoller, error)
	// BeginDeleteAtSubscriptionScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
	BeginDeleteAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsDeleteAtSubscriptionScopeOptions) (*HTTPPollerResponse, error)
	// ResumeDeleteAtSubscriptionScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAtSubscriptionScope(token string) (HTTPPoller, error)
	// ExportTemplate - Exports the template used for specified deployment.
	ExportTemplate(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsExportTemplateOptions) (*DeploymentExportResultResponse, error)
	// ExportTemplateAtManagementGroupScope - Exports the template used for specified deployment.
	ExportTemplateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsExportTemplateAtManagementGroupScopeOptions) (*DeploymentExportResultResponse, error)
	// ExportTemplateAtSubscriptionScope - Exports the template used for specified deployment.
	ExportTemplateAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtSubscriptionScopeOptions) (*DeploymentExportResultResponse, error)
	// Get - Gets a deployment.
	Get(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsGetOptions) (*DeploymentExtendedResponse, error)
	// GetAtManagementGroupScope - Gets a deployment.
	GetAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsGetAtManagementGroupScopeOptions) (*DeploymentExtendedResponse, error)
	// GetAtSubscriptionScope - Gets a deployment.
	GetAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsGetAtSubscriptionScopeOptions) (*DeploymentExtendedResponse, error)
	// ListAtManagementGroupScope - Get all the deployments for a management group.
	ListAtManagementGroupScope(groupId string, options *DeploymentsListAtManagementGroupScopeOptions) DeploymentListResultPager
	// ListAtSubscriptionScope - Get all the deployments for a subscription.
	ListAtSubscriptionScope(options *DeploymentsListAtSubscriptionScopeOptions) DeploymentListResultPager
	// ListByResourceGroup - Get all the deployments for a resource group.
	ListByResourceGroup(resourceGroupName string, options *DeploymentsListByResourceGroupOptions) DeploymentListResultPager
	// Validate - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
	Validate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsValidateOptions) (*DeploymentValidateResultResponse, error)
	// ValidateAtManagementGroupScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
	ValidateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters Deployment, options *DeploymentsValidateAtManagementGroupScopeOptions) (*DeploymentValidateResultResponse, error)
	// ValidateAtSubscriptionScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
	ValidateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsValidateAtSubscriptionScopeOptions) (*DeploymentValidateResultResponse, error)
}

// DeploymentsClient implements the DeploymentsOperations interface.
// Don't use this type directly, use NewDeploymentsClient() instead.
type DeploymentsClient struct {
	*Client
	subscriptionID string
}

// NewDeploymentsClient creates a new instance of DeploymentsClient with the specified values.
func NewDeploymentsClient(c *Client, subscriptionID string) DeploymentsOperations {
	return &DeploymentsClient{Client: c, subscriptionID: subscriptionID}
}

// Do invokes the Do() method on the pipeline associated with this client.
func (client *DeploymentsClient) Do(req *azcore.Request) (*azcore.Response, error) {
	return client.p.Do(req)
}

// CalculateTemplateHash - Calculate the hash of the given template.
func (client *DeploymentsClient) CalculateTemplateHash(ctx context.Context, templateParameter interface{}, options *DeploymentsCalculateTemplateHashOptions) (*TemplateHashResultResponse, error) {
	req, err := client.CalculateTemplateHashCreateRequest(ctx, templateParameter, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.CalculateTemplateHashHandleError(resp)
	}
	result, err := client.CalculateTemplateHashHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// CalculateTemplateHashCreateRequest creates the CalculateTemplateHash request.
func (client *DeploymentsClient) CalculateTemplateHashCreateRequest(ctx context.Context, templateParameter interface{}, options *DeploymentsCalculateTemplateHashOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/calculateTemplateHash"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(templateParameter)
}

// CalculateTemplateHashHandleResponse handles the CalculateTemplateHash response.
func (client *DeploymentsClient) CalculateTemplateHashHandleResponse(resp *azcore.Response) (*TemplateHashResultResponse, error) {
	result := TemplateHashResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.TemplateHashResult)
}

// CalculateTemplateHashHandleError handles the CalculateTemplateHash error response.
func (client *DeploymentsClient) CalculateTemplateHashHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// Cancel - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resource group partially deployed.
func (client *DeploymentsClient) Cancel(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCancelOptions) (*http.Response, error) {
	req, err := client.CancelCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.CancelHandleError(resp)
	}
	return resp.Response, nil
}

// CancelCreateRequest creates the Cancel request.
func (client *DeploymentsClient) CancelCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCancelOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// CancelHandleError handles the Cancel error response.
func (client *DeploymentsClient) CancelHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// CancelAtManagementGroupScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
func (client *DeploymentsClient) CancelAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsCancelAtManagementGroupScopeOptions) (*http.Response, error) {
	req, err := client.CancelAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.CancelAtManagementGroupScopeHandleError(resp)
	}
	return resp.Response, nil
}

// CancelAtManagementGroupScopeCreateRequest creates the CancelAtManagementGroupScope request.
func (client *DeploymentsClient) CancelAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, options *DeploymentsCancelAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// CancelAtManagementGroupScopeHandleError handles the CancelAtManagementGroupScope error response.
func (client *DeploymentsClient) CancelAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// CancelAtSubscriptionScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
func (client *DeploymentsClient) CancelAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsCancelAtSubscriptionScopeOptions) (*http.Response, error) {
	req, err := client.CancelAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.CancelAtSubscriptionScopeHandleError(resp)
	}
	return resp.Response, nil
}

// CancelAtSubscriptionScopeCreateRequest creates the CancelAtSubscriptionScope request.
func (client *DeploymentsClient) CancelAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsCancelAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// CancelAtSubscriptionScopeHandleError handles the CancelAtSubscriptionScope error response.
func (client *DeploymentsClient) CancelAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// CheckExistence - Checks whether the deployment exists.
func (client *DeploymentsClient) CheckExistence(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCheckExistenceOptions) (*http.Response, error) {
	req, err := client.CheckExistenceCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent, http.StatusNotFound) {
		return nil, client.CheckExistenceHandleError(resp)
	}
	return resp.Response, nil
}

// CheckExistenceCreateRequest creates the CheckExistence request.
func (client *DeploymentsClient) CheckExistenceCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCheckExistenceOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// CheckExistenceHandleError handles the CheckExistence error response.
func (client *DeploymentsClient) CheckExistenceHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// CheckExistenceAtManagementGroupScope - Checks whether the deployment exists.
func (client *DeploymentsClient) CheckExistenceAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsCheckExistenceAtManagementGroupScopeOptions) (*http.Response, error) {
	req, err := client.CheckExistenceAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent, http.StatusNotFound) {
		return nil, client.CheckExistenceAtManagementGroupScopeHandleError(resp)
	}
	return resp.Response, nil
}

// CheckExistenceAtManagementGroupScopeCreateRequest creates the CheckExistenceAtManagementGroupScope request.
func (client *DeploymentsClient) CheckExistenceAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, options *DeploymentsCheckExistenceAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// CheckExistenceAtManagementGroupScopeHandleError handles the CheckExistenceAtManagementGroupScope error response.
func (client *DeploymentsClient) CheckExistenceAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// CheckExistenceAtSubscriptionScope - Checks whether the deployment exists.
func (client *DeploymentsClient) CheckExistenceAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtSubscriptionScopeOptions) (*http.Response, error) {
	req, err := client.CheckExistenceAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent, http.StatusNotFound) {
		return nil, client.CheckExistenceAtSubscriptionScopeHandleError(resp)
	}
	return resp.Response, nil
}

// CheckExistenceAtSubscriptionScopeCreateRequest creates the CheckExistenceAtSubscriptionScope request.
func (client *DeploymentsClient) CheckExistenceAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// CheckExistenceAtSubscriptionScopeHandleError handles the CheckExistenceAtSubscriptionScope error response.
func (client *DeploymentsClient) CheckExistenceAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *DeploymentsClient) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateOptions) (*DeploymentExtendedPollerResponse, error) {
	resp, err := client.CreateOrUpdate(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdate", "", resp, client.CreateOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentExtendedPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeCreateOrUpdate(token string) (DeploymentExtendedPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdate", token, client.CreateOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentExtendedPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// CreateOrUpdate - You can provide the template and parameters directly in the request or link to JSON files.
func (client *DeploymentsClient) CreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateOptions) (*azcore.Response, error) {
	req, err := client.CreateOrUpdateCreateRequest(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.CreateOrUpdateHandleError(resp)
	}
	return resp, nil
}

// CreateOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *DeploymentsClient) CreateOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// CreateOrUpdateHandleResponse handles the CreateOrUpdate response.
func (client *DeploymentsClient) CreateOrUpdateHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// CreateOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *DeploymentsClient) CreateOrUpdateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *DeploymentsClient) BeginCreateOrUpdateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtManagementGroupScopeOptions) (*DeploymentExtendedPollerResponse, error) {
	resp, err := client.CreateOrUpdateAtManagementGroupScope(ctx, groupId, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdateAtManagementGroupScope", "", resp, client.CreateOrUpdateAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentExtendedPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeCreateOrUpdateAtManagementGroupScope(token string) (DeploymentExtendedPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtManagementGroupScope", token, client.CreateOrUpdateAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentExtendedPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// CreateOrUpdateAtManagementGroupScope - You can provide the template and parameters directly in the request or link to JSON files.
func (client *DeploymentsClient) CreateOrUpdateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtManagementGroupScopeOptions) (*azcore.Response, error) {
	req, err := client.CreateOrUpdateAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.CreateOrUpdateAtManagementGroupScopeHandleError(resp)
	}
	return resp, nil
}

// CreateOrUpdateAtManagementGroupScopeCreateRequest creates the CreateOrUpdateAtManagementGroupScope request.
func (client *DeploymentsClient) CreateOrUpdateAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// CreateOrUpdateAtManagementGroupScopeHandleResponse handles the CreateOrUpdateAtManagementGroupScope response.
func (client *DeploymentsClient) CreateOrUpdateAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// CreateOrUpdateAtManagementGroupScopeHandleError handles the CreateOrUpdateAtManagementGroupScope error response.
func (client *DeploymentsClient) CreateOrUpdateAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *DeploymentsClient) BeginCreateOrUpdateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtSubscriptionScopeOptions) (*DeploymentExtendedPollerResponse, error) {
	resp, err := client.CreateOrUpdateAtSubscriptionScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdateAtSubscriptionScope", "", resp, client.CreateOrUpdateAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentExtendedPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeCreateOrUpdateAtSubscriptionScope(token string) (DeploymentExtendedPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtSubscriptionScope", token, client.CreateOrUpdateAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentExtendedPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// CreateOrUpdateAtSubscriptionScope - You can provide the template and parameters directly in the request or link to JSON files.
func (client *DeploymentsClient) CreateOrUpdateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtSubscriptionScopeOptions) (*azcore.Response, error) {
	req, err := client.CreateOrUpdateAtSubscriptionScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.CreateOrUpdateAtSubscriptionScopeHandleError(resp)
	}
	return resp, nil
}

// CreateOrUpdateAtSubscriptionScopeCreateRequest creates the CreateOrUpdateAtSubscriptionScope request.
func (client *DeploymentsClient) CreateOrUpdateAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// CreateOrUpdateAtSubscriptionScopeHandleResponse handles the CreateOrUpdateAtSubscriptionScope response.
func (client *DeploymentsClient) CreateOrUpdateAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// CreateOrUpdateAtSubscriptionScopeHandleError handles the CreateOrUpdateAtSubscriptionScope error response.
func (client *DeploymentsClient) CreateOrUpdateAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *DeploymentsClient) BeginDelete(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsDeleteOptions) (*HTTPPollerResponse, error) {
	resp, err := client.Delete(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.Delete", "", resp, client.DeleteHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeDelete(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.Delete", token, client.DeleteHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Delete - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
func (client *DeploymentsClient) Delete(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsDeleteOptions) (*azcore.Response, error) {
	req, err := client.DeleteCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.DeleteHandleError(resp)
	}
	return resp, nil
}

// DeleteCreateRequest creates the Delete request.
func (client *DeploymentsClient) DeleteCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsDeleteOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// DeleteHandleError handles the Delete error response.
func (client *DeploymentsClient) DeleteHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *DeploymentsClient) BeginDeleteAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsDeleteAtManagementGroupScopeOptions) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteAtManagementGroupScope(ctx, groupId, deploymentName, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.DeleteAtManagementGroupScope", "", resp, client.DeleteAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeDeleteAtManagementGroupScope(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.DeleteAtManagementGroupScope", token, client.DeleteAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// DeleteAtManagementGroupScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
func (client *DeploymentsClient) DeleteAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsDeleteAtManagementGroupScopeOptions) (*azcore.Response, error) {
	req, err := client.DeleteAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.DeleteAtManagementGroupScopeHandleError(resp)
	}
	return resp, nil
}

// DeleteAtManagementGroupScopeCreateRequest creates the DeleteAtManagementGroupScope request.
func (client *DeploymentsClient) DeleteAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, options *DeploymentsDeleteAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// DeleteAtManagementGroupScopeHandleError handles the DeleteAtManagementGroupScope error response.
func (client *DeploymentsClient) DeleteAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *DeploymentsClient) BeginDeleteAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsDeleteAtSubscriptionScopeOptions) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteAtSubscriptionScope(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.DeleteAtSubscriptionScope", "", resp, client.DeleteAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeDeleteAtSubscriptionScope(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.DeleteAtSubscriptionScope", token, client.DeleteAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// DeleteAtSubscriptionScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
func (client *DeploymentsClient) DeleteAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsDeleteAtSubscriptionScopeOptions) (*azcore.Response, error) {
	req, err := client.DeleteAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.DeleteAtSubscriptionScopeHandleError(resp)
	}
	return resp, nil
}

// DeleteAtSubscriptionScopeCreateRequest creates the DeleteAtSubscriptionScope request.
func (client *DeploymentsClient) DeleteAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsDeleteAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// DeleteAtSubscriptionScopeHandleError handles the DeleteAtSubscriptionScope error response.
func (client *DeploymentsClient) DeleteAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ExportTemplate - Exports the template used for specified deployment.
func (client *DeploymentsClient) ExportTemplate(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsExportTemplateOptions) (*DeploymentExportResultResponse, error) {
	req, err := client.ExportTemplateCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ExportTemplateHandleError(resp)
	}
	result, err := client.ExportTemplateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ExportTemplateCreateRequest creates the ExportTemplate request.
func (client *DeploymentsClient) ExportTemplateCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsExportTemplateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ExportTemplateHandleResponse handles the ExportTemplate response.
func (client *DeploymentsClient) ExportTemplateHandleResponse(resp *azcore.Response) (*DeploymentExportResultResponse, error) {
	result := DeploymentExportResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExportResult)
}

// ExportTemplateHandleError handles the ExportTemplate error response.
func (client *DeploymentsClient) ExportTemplateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ExportTemplateAtManagementGroupScope - Exports the template used for specified deployment.
func (client *DeploymentsClient) ExportTemplateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsExportTemplateAtManagementGroupScopeOptions) (*DeploymentExportResultResponse, error) {
	req, err := client.ExportTemplateAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ExportTemplateAtManagementGroupScopeHandleError(resp)
	}
	result, err := client.ExportTemplateAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ExportTemplateAtManagementGroupScopeCreateRequest creates the ExportTemplateAtManagementGroupScope request.
func (client *DeploymentsClient) ExportTemplateAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, options *DeploymentsExportTemplateAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ExportTemplateAtManagementGroupScopeHandleResponse handles the ExportTemplateAtManagementGroupScope response.
func (client *DeploymentsClient) ExportTemplateAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentExportResultResponse, error) {
	result := DeploymentExportResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExportResult)
}

// ExportTemplateAtManagementGroupScopeHandleError handles the ExportTemplateAtManagementGroupScope error response.
func (client *DeploymentsClient) ExportTemplateAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ExportTemplateAtSubscriptionScope - Exports the template used for specified deployment.
func (client *DeploymentsClient) ExportTemplateAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtSubscriptionScopeOptions) (*DeploymentExportResultResponse, error) {
	req, err := client.ExportTemplateAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ExportTemplateAtSubscriptionScopeHandleError(resp)
	}
	result, err := client.ExportTemplateAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ExportTemplateAtSubscriptionScopeCreateRequest creates the ExportTemplateAtSubscriptionScope request.
func (client *DeploymentsClient) ExportTemplateAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ExportTemplateAtSubscriptionScopeHandleResponse handles the ExportTemplateAtSubscriptionScope response.
func (client *DeploymentsClient) ExportTemplateAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentExportResultResponse, error) {
	result := DeploymentExportResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExportResult)
}

// ExportTemplateAtSubscriptionScopeHandleError handles the ExportTemplateAtSubscriptionScope error response.
func (client *DeploymentsClient) ExportTemplateAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// Get - Gets a deployment.
func (client *DeploymentsClient) Get(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsGetOptions) (*DeploymentExtendedResponse, error) {
	req, err := client.GetCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetHandleError(resp)
	}
	result, err := client.GetHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetCreateRequest creates the Get request.
func (client *DeploymentsClient) GetCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsGetOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetHandleResponse handles the Get response.
func (client *DeploymentsClient) GetHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// GetHandleError handles the Get error response.
func (client *DeploymentsClient) GetHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetAtManagementGroupScope - Gets a deployment.
func (client *DeploymentsClient) GetAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsGetAtManagementGroupScopeOptions) (*DeploymentExtendedResponse, error) {
	req, err := client.GetAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetAtManagementGroupScopeHandleError(resp)
	}
	result, err := client.GetAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetAtManagementGroupScopeCreateRequest creates the GetAtManagementGroupScope request.
func (client *DeploymentsClient) GetAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, options *DeploymentsGetAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetAtManagementGroupScopeHandleResponse handles the GetAtManagementGroupScope response.
func (client *DeploymentsClient) GetAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// GetAtManagementGroupScopeHandleError handles the GetAtManagementGroupScope error response.
func (client *DeploymentsClient) GetAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetAtSubscriptionScope - Gets a deployment.
func (client *DeploymentsClient) GetAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsGetAtSubscriptionScopeOptions) (*DeploymentExtendedResponse, error) {
	req, err := client.GetAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetAtSubscriptionScopeHandleError(resp)
	}
	result, err := client.GetAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetAtSubscriptionScopeCreateRequest creates the GetAtSubscriptionScope request.
func (client *DeploymentsClient) GetAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsGetAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetAtSubscriptionScopeHandleResponse handles the GetAtSubscriptionScope response.
func (client *DeploymentsClient) GetAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// GetAtSubscriptionScopeHandleError handles the GetAtSubscriptionScope error response.
func (client *DeploymentsClient) GetAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListAtManagementGroupScope - Get all the deployments for a management group.
func (client *DeploymentsClient) ListAtManagementGroupScope(groupId string, options *DeploymentsListAtManagementGroupScopeOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.ListAtManagementGroupScopeCreateRequest(ctx, groupId, options)
		},
		responder: client.ListAtManagementGroupScopeHandleResponse,
		errorer:   client.ListAtManagementGroupScopeHandleError,
		advancer: func(ctx context.Context, resp *DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// ListAtManagementGroupScopeCreateRequest creates the ListAtManagementGroupScope request.
func (client *DeploymentsClient) ListAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, options *DeploymentsListAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if options != nil && options.Filter != nil {
		query.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListAtManagementGroupScopeHandleResponse handles the ListAtManagementGroupScope response.
func (client *DeploymentsClient) ListAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentListResultResponse, error) {
	result := DeploymentListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentListResult)
}

// ListAtManagementGroupScopeHandleError handles the ListAtManagementGroupScope error response.
func (client *DeploymentsClient) ListAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListAtSubscriptionScope - Get all the deployments for a subscription.
func (client *DeploymentsClient) ListAtSubscriptionScope(options *DeploymentsListAtSubscriptionScopeOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.ListAtSubscriptionScopeCreateRequest(ctx, options)
		},
		responder: client.ListAtSubscriptionScopeHandleResponse,
		errorer:   client.ListAtSubscriptionScopeHandleError,
		advancer: func(ctx context.Context, resp *DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// ListAtSubscriptionScopeCreateRequest creates the ListAtSubscriptionScope request.
func (client *DeploymentsClient) ListAtSubscriptionScopeCreateRequest(ctx context.Context, options *DeploymentsListAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if options != nil && options.Filter != nil {
		query.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListAtSubscriptionScopeHandleResponse handles the ListAtSubscriptionScope response.
func (client *DeploymentsClient) ListAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentListResultResponse, error) {
	result := DeploymentListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentListResult)
}

// ListAtSubscriptionScopeHandleError handles the ListAtSubscriptionScope error response.
func (client *DeploymentsClient) ListAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListByResourceGroup - Get all the deployments for a resource group.
func (client *DeploymentsClient) ListByResourceGroup(resourceGroupName string, options *DeploymentsListByResourceGroupOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.ListByResourceGroupCreateRequest(ctx, resourceGroupName, options)
		},
		responder: client.ListByResourceGroupHandleResponse,
		errorer:   client.ListByResourceGroupHandleError,
		advancer: func(ctx context.Context, resp *DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// ListByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *DeploymentsClient) ListByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *DeploymentsListByResourceGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if options != nil && options.Filter != nil {
		query.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *DeploymentsClient) ListByResourceGroupHandleResponse(resp *azcore.Response) (*DeploymentListResultResponse, error) {
	result := DeploymentListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentListResult)
}

// ListByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *DeploymentsClient) ListByResourceGroupHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// Validate - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
func (client *DeploymentsClient) Validate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsValidateOptions) (*DeploymentValidateResultResponse, error) {
	req, err := client.ValidateCreateRequest(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusBadRequest) {
		return nil, client.ValidateHandleError(resp)
	}
	result, err := client.ValidateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ValidateCreateRequest creates the Validate request.
func (client *DeploymentsClient) ValidateCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsValidateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// ValidateHandleResponse handles the Validate response.
func (client *DeploymentsClient) ValidateHandleResponse(resp *azcore.Response) (*DeploymentValidateResultResponse, error) {
	result := DeploymentValidateResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentValidateResult)
}

// ValidateHandleError handles the Validate error response.
func (client *DeploymentsClient) ValidateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ValidateAtManagementGroupScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
func (client *DeploymentsClient) ValidateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters Deployment, options *DeploymentsValidateAtManagementGroupScopeOptions) (*DeploymentValidateResultResponse, error) {
	req, err := client.ValidateAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusBadRequest) {
		return nil, client.ValidateAtManagementGroupScopeHandleError(resp)
	}
	result, err := client.ValidateAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ValidateAtManagementGroupScopeCreateRequest creates the ValidateAtManagementGroupScope request.
func (client *DeploymentsClient) ValidateAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, parameters Deployment, options *DeploymentsValidateAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// ValidateAtManagementGroupScopeHandleResponse handles the ValidateAtManagementGroupScope response.
func (client *DeploymentsClient) ValidateAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentValidateResultResponse, error) {
	result := DeploymentValidateResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentValidateResult)
}

// ValidateAtManagementGroupScopeHandleError handles the ValidateAtManagementGroupScope error response.
func (client *DeploymentsClient) ValidateAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ValidateAtSubscriptionScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
func (client *DeploymentsClient) ValidateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsValidateAtSubscriptionScopeOptions) (*DeploymentValidateResultResponse, error) {
	req, err := client.ValidateAtSubscriptionScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusBadRequest) {
		return nil, client.ValidateAtSubscriptionScopeHandleError(resp)
	}
	result, err := client.ValidateAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ValidateAtSubscriptionScopeCreateRequest creates the ValidateAtSubscriptionScope request.
func (client *DeploymentsClient) ValidateAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsValidateAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// ValidateAtSubscriptionScopeHandleResponse handles the ValidateAtSubscriptionScope response.
func (client *DeploymentsClient) ValidateAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentValidateResultResponse, error) {
	result := DeploymentValidateResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentValidateResult)
}

// ValidateAtSubscriptionScopeHandleError handles the ValidateAtSubscriptionScope error response.
func (client *DeploymentsClient) ValidateAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}
