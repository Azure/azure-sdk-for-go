// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armresources

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// ResourcesOperations contains the methods for the Resources group.
type ResourcesOperations interface {
	// CheckExistence - Checks whether a resource exists.
	CheckExistence(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*http.Response, error)
	// CheckExistenceByID - Checks by ID whether a resource exists.
	CheckExistenceByID(ctx context.Context, resourceId string) (*http.Response, error)
	// BeginCreateOrUpdate - Creates a resource.
	BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*GenericResourcePollerResponse, error)
	// ResumeCreateOrUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdate(token string) (GenericResourcePoller, error)
	// BeginCreateOrUpdateByID - Create a resource by ID.
	BeginCreateOrUpdateByID(ctx context.Context, resourceId string, parameters GenericResource) (*GenericResourcePollerResponse, error)
	// ResumeCreateOrUpdateByID - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdateByID(token string) (GenericResourcePoller, error)
	// BeginDelete - Deletes a resource.
	BeginDelete(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*HTTPPollerResponse, error)
	// ResumeDelete - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDelete(token string) (HTTPPoller, error)
	// BeginDeleteByID - Deletes a resource by ID.
	BeginDeleteByID(ctx context.Context, resourceId string) (*HTTPPollerResponse, error)
	// ResumeDeleteByID - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteByID(token string) (HTTPPoller, error)
	// Get - Gets a resource.
	Get(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*GenericResourceResponse, error)
	// GetByID - Gets a resource by ID.
	GetByID(ctx context.Context, resourceId string) (*GenericResourceResponse, error)
	// List - Get all the resources in a subscription.
	List(resourcesListOptions *ResourcesListOptions) ResourceListResultPager
	// ListByResourceGroup - Get all the resources for a resource group.
	ListByResourceGroup(resourceGroupName string, resourcesListByResourceGroupOptions *ResourcesListByResourceGroupOptions) ResourceListResultPager
	// BeginMoveResources - The resources to move must be in the same source resource group. The target resource group may be in a different subscription. When moving resources, both the source group and the target group are locked for the duration of the operation. Write and delete operations are blocked on the groups until the move completes.
	BeginMoveResources(ctx context.Context, sourceResourceGroupName string, parameters ResourcesMoveInfo) (*HTTPPollerResponse, error)
	// ResumeMoveResources - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeMoveResources(token string) (HTTPPoller, error)
	// BeginUpdate - Updates a resource.
	BeginUpdate(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*GenericResourcePollerResponse, error)
	// ResumeUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeUpdate(token string) (GenericResourcePoller, error)
	// BeginUpdateByID - Updates a resource by ID.
	BeginUpdateByID(ctx context.Context, resourceId string, parameters GenericResource) (*GenericResourcePollerResponse, error)
	// ResumeUpdateByID - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeUpdateByID(token string) (GenericResourcePoller, error)
	// BeginValidateMoveResources - This operation checks whether the specified resources can be moved to the target. The resources to move must be in the same source resource group. The target resource group may be in a different subscription. If validation succeeds, it returns HTTP response code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an error message. Retrieve the URL in the Location header value to check the result of the long-running operation.
	BeginValidateMoveResources(ctx context.Context, sourceResourceGroupName string, parameters ResourcesMoveInfo) (*HTTPPollerResponse, error)
	// ResumeValidateMoveResources - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeValidateMoveResources(token string) (HTTPPoller, error)
}

// ResourcesClient implements the ResourcesOperations interface.
// Don't use this type directly, use NewResourcesClient() instead.
type ResourcesClient struct {
	*Client
	subscriptionID string
}

// NewResourcesClient creates a new instance of ResourcesClient with the specified values.
func NewResourcesClient(c *Client, subscriptionID string) ResourcesOperations {
	return &ResourcesClient{Client: c, subscriptionID: subscriptionID}
}

// Do invokes the Do() method on the pipeline associated with this client.
func (client *ResourcesClient) Do(req *azcore.Request) (*azcore.Response, error) {
	return client.p.Do(req)
}

// CheckExistence - Checks whether a resource exists.
func (client *ResourcesClient) CheckExistence(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*http.Response, error) {
	req, err := client.CheckExistenceCreateRequest(ctx, resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent, http.StatusNotFound) {
		return nil, client.CheckExistenceHandleError(resp)
	}
	return resp.Response, nil
}

// CheckExistenceCreateRequest creates the CheckExistence request.
func (client *ResourcesClient) CheckExistenceCreateRequest(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// CheckExistenceHandleError handles the CheckExistence error response.
func (client *ResourcesClient) CheckExistenceHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// CheckExistenceByID - Checks by ID whether a resource exists.
func (client *ResourcesClient) CheckExistenceByID(ctx context.Context, resourceId string) (*http.Response, error) {
	req, err := client.CheckExistenceByIDCreateRequest(ctx, resourceId)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent, http.StatusNotFound) {
		return nil, client.CheckExistenceByIDHandleError(resp)
	}
	return resp.Response, nil
}

// CheckExistenceByIDCreateRequest creates the CheckExistenceByID request.
func (client *ResourcesClient) CheckExistenceByIDCreateRequest(ctx context.Context, resourceId string) (*azcore.Request, error) {
	urlPath := "/{resourceId}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceId)
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// CheckExistenceByIDHandleError handles the CheckExistenceByID error response.
func (client *ResourcesClient) CheckExistenceByIDHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

func (client *ResourcesClient) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*GenericResourcePollerResponse, error) {
	resp, err := client.CreateOrUpdate(ctx, resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, parameters)
	if err != nil {
		return nil, err
	}
	result := &GenericResourcePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("ResourcesClient.CreateOrUpdate", "", resp, client.CreateOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &genericResourcePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*GenericResourceResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *ResourcesClient) ResumeCreateOrUpdate(token string) (GenericResourcePoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("ResourcesClient.CreateOrUpdate", token, client.CreateOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	return &genericResourcePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// CreateOrUpdate - Creates a resource.
func (client *ResourcesClient) CreateOrUpdate(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*azcore.Response, error) {
	req, err := client.CreateOrUpdateCreateRequest(ctx, resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return nil, client.CreateOrUpdateHandleError(resp)
	}
	return resp, nil
}

// CreateOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *ResourcesClient) CreateOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// CreateOrUpdateHandleResponse handles the CreateOrUpdate response.
func (client *ResourcesClient) CreateOrUpdateHandleResponse(resp *azcore.Response) (*GenericResourceResponse, error) {
	result := GenericResourceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.GenericResource)
}

// CreateOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *ResourcesClient) CreateOrUpdateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

func (client *ResourcesClient) BeginCreateOrUpdateByID(ctx context.Context, resourceId string, parameters GenericResource) (*GenericResourcePollerResponse, error) {
	resp, err := client.CreateOrUpdateByID(ctx, resourceId, parameters)
	if err != nil {
		return nil, err
	}
	result := &GenericResourcePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("ResourcesClient.CreateOrUpdateByID", "", resp, client.CreateOrUpdateByIDHandleError)
	if err != nil {
		return nil, err
	}
	poller := &genericResourcePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*GenericResourceResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *ResourcesClient) ResumeCreateOrUpdateByID(token string) (GenericResourcePoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("ResourcesClient.CreateOrUpdateByID", token, client.CreateOrUpdateByIDHandleError)
	if err != nil {
		return nil, err
	}
	return &genericResourcePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// CreateOrUpdateByID - Create a resource by ID.
func (client *ResourcesClient) CreateOrUpdateByID(ctx context.Context, resourceId string, parameters GenericResource) (*azcore.Response, error) {
	req, err := client.CreateOrUpdateByIDCreateRequest(ctx, resourceId, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return nil, client.CreateOrUpdateByIDHandleError(resp)
	}
	return resp, nil
}

// CreateOrUpdateByIDCreateRequest creates the CreateOrUpdateByID request.
func (client *ResourcesClient) CreateOrUpdateByIDCreateRequest(ctx context.Context, resourceId string, parameters GenericResource) (*azcore.Request, error) {
	urlPath := "/{resourceId}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceId)
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// CreateOrUpdateByIDHandleResponse handles the CreateOrUpdateByID response.
func (client *ResourcesClient) CreateOrUpdateByIDHandleResponse(resp *azcore.Response) (*GenericResourceResponse, error) {
	result := GenericResourceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.GenericResource)
}

// CreateOrUpdateByIDHandleError handles the CreateOrUpdateByID error response.
func (client *ResourcesClient) CreateOrUpdateByIDHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

func (client *ResourcesClient) BeginDelete(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*HTTPPollerResponse, error) {
	resp, err := client.Delete(ctx, resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("ResourcesClient.Delete", "", resp, client.DeleteHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *ResourcesClient) ResumeDelete(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("ResourcesClient.Delete", token, client.DeleteHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Delete - Deletes a resource.
func (client *ResourcesClient) Delete(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*azcore.Response, error) {
	req, err := client.DeleteCreateRequest(ctx, resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.DeleteHandleError(resp)
	}
	return resp, nil
}

// DeleteCreateRequest creates the Delete request.
func (client *ResourcesClient) DeleteCreateRequest(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// DeleteHandleError handles the Delete error response.
func (client *ResourcesClient) DeleteHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

func (client *ResourcesClient) BeginDeleteByID(ctx context.Context, resourceId string) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteByID(ctx, resourceId)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("ResourcesClient.DeleteByID", "", resp, client.DeleteByIDHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *ResourcesClient) ResumeDeleteByID(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("ResourcesClient.DeleteByID", token, client.DeleteByIDHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// DeleteByID - Deletes a resource by ID.
func (client *ResourcesClient) DeleteByID(ctx context.Context, resourceId string) (*azcore.Response, error) {
	req, err := client.DeleteByIDCreateRequest(ctx, resourceId)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.DeleteByIDHandleError(resp)
	}
	return resp, nil
}

// DeleteByIDCreateRequest creates the DeleteByID request.
func (client *ResourcesClient) DeleteByIDCreateRequest(ctx context.Context, resourceId string) (*azcore.Request, error) {
	urlPath := "/{resourceId}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceId)
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// DeleteByIDHandleError handles the DeleteByID error response.
func (client *ResourcesClient) DeleteByIDHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// Get - Gets a resource.
func (client *ResourcesClient) Get(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*GenericResourceResponse, error) {
	req, err := client.GetCreateRequest(ctx, resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetHandleError(resp)
	}
	result, err := client.GetHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetCreateRequest creates the Get request.
func (client *ResourcesClient) GetCreateRequest(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetHandleResponse handles the Get response.
func (client *ResourcesClient) GetHandleResponse(resp *azcore.Response) (*GenericResourceResponse, error) {
	result := GenericResourceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.GenericResource)
}

// GetHandleError handles the Get error response.
func (client *ResourcesClient) GetHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetByID - Gets a resource by ID.
func (client *ResourcesClient) GetByID(ctx context.Context, resourceId string) (*GenericResourceResponse, error) {
	req, err := client.GetByIDCreateRequest(ctx, resourceId)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetByIDHandleError(resp)
	}
	result, err := client.GetByIDHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetByIDCreateRequest creates the GetByID request.
func (client *ResourcesClient) GetByIDCreateRequest(ctx context.Context, resourceId string) (*azcore.Request, error) {
	urlPath := "/{resourceId}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceId)
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetByIDHandleResponse handles the GetByID response.
func (client *ResourcesClient) GetByIDHandleResponse(resp *azcore.Response) (*GenericResourceResponse, error) {
	result := GenericResourceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.GenericResource)
}

// GetByIDHandleError handles the GetByID error response.
func (client *ResourcesClient) GetByIDHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// List - Get all the resources in a subscription.
func (client *ResourcesClient) List(resourcesListOptions *ResourcesListOptions) ResourceListResultPager {
	return &resourceListResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.ListCreateRequest(ctx, resourcesListOptions)
		},
		responder: client.ListHandleResponse,
		errorer:   client.ListHandleError,
		advancer: func(ctx context.Context, resp *ResourceListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ResourceListResult.NextLink)
		},
	}
}

// ListCreateRequest creates the List request.
func (client *ResourcesClient) ListCreateRequest(ctx context.Context, resourcesListOptions *ResourcesListOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resources"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if resourcesListOptions != nil && resourcesListOptions.Filter != nil {
		query.Set("$filter", *resourcesListOptions.Filter)
	}
	if resourcesListOptions != nil && resourcesListOptions.Expand != nil {
		query.Set("$expand", *resourcesListOptions.Expand)
	}
	if resourcesListOptions != nil && resourcesListOptions.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*resourcesListOptions.Top), 10))
	}
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListHandleResponse handles the List response.
func (client *ResourcesClient) ListHandleResponse(resp *azcore.Response) (*ResourceListResultResponse, error) {
	result := ResourceListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ResourceListResult)
}

// ListHandleError handles the List error response.
func (client *ResourcesClient) ListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ListByResourceGroup - Get all the resources for a resource group.
func (client *ResourcesClient) ListByResourceGroup(resourceGroupName string, resourcesListByResourceGroupOptions *ResourcesListByResourceGroupOptions) ResourceListResultPager {
	return &resourceListResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.ListByResourceGroupCreateRequest(ctx, resourceGroupName, resourcesListByResourceGroupOptions)
		},
		responder: client.ListByResourceGroupHandleResponse,
		errorer:   client.ListByResourceGroupHandleError,
		advancer: func(ctx context.Context, resp *ResourceListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ResourceListResult.NextLink)
		},
	}
}

// ListByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *ResourcesClient) ListByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, resourcesListByResourceGroupOptions *ResourcesListByResourceGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/resources"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if resourcesListByResourceGroupOptions != nil && resourcesListByResourceGroupOptions.Filter != nil {
		query.Set("$filter", *resourcesListByResourceGroupOptions.Filter)
	}
	if resourcesListByResourceGroupOptions != nil && resourcesListByResourceGroupOptions.Expand != nil {
		query.Set("$expand", *resourcesListByResourceGroupOptions.Expand)
	}
	if resourcesListByResourceGroupOptions != nil && resourcesListByResourceGroupOptions.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*resourcesListByResourceGroupOptions.Top), 10))
	}
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *ResourcesClient) ListByResourceGroupHandleResponse(resp *azcore.Response) (*ResourceListResultResponse, error) {
	result := ResourceListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ResourceListResult)
}

// ListByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *ResourcesClient) ListByResourceGroupHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

func (client *ResourcesClient) BeginMoveResources(ctx context.Context, sourceResourceGroupName string, parameters ResourcesMoveInfo) (*HTTPPollerResponse, error) {
	resp, err := client.MoveResources(ctx, sourceResourceGroupName, parameters)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("ResourcesClient.MoveResources", "", resp, client.MoveResourcesHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *ResourcesClient) ResumeMoveResources(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("ResourcesClient.MoveResources", token, client.MoveResourcesHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// MoveResources - The resources to move must be in the same source resource group. The target resource group may be in a different subscription. When moving resources, both the source group and the target group are locked for the duration of the operation. Write and delete operations are blocked on the groups until the move completes.
func (client *ResourcesClient) MoveResources(ctx context.Context, sourceResourceGroupName string, parameters ResourcesMoveInfo) (*azcore.Response, error) {
	req, err := client.MoveResourcesCreateRequest(ctx, sourceResourceGroupName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.MoveResourcesHandleError(resp)
	}
	return resp, nil
}

// MoveResourcesCreateRequest creates the MoveResources request.
func (client *ResourcesClient) MoveResourcesCreateRequest(ctx context.Context, sourceResourceGroupName string, parameters ResourcesMoveInfo) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/moveResources"
	urlPath = strings.ReplaceAll(urlPath, "{sourceResourceGroupName}", url.PathEscape(sourceResourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, req.MarshalAsJSON(parameters)
}

// MoveResourcesHandleError handles the MoveResources error response.
func (client *ResourcesClient) MoveResourcesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

func (client *ResourcesClient) BeginUpdate(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*GenericResourcePollerResponse, error) {
	resp, err := client.Update(ctx, resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, parameters)
	if err != nil {
		return nil, err
	}
	result := &GenericResourcePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("ResourcesClient.Update", "", resp, client.UpdateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &genericResourcePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*GenericResourceResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *ResourcesClient) ResumeUpdate(token string) (GenericResourcePoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("ResourcesClient.Update", token, client.UpdateHandleError)
	if err != nil {
		return nil, err
	}
	return &genericResourcePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Update - Updates a resource.
func (client *ResourcesClient) Update(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*azcore.Response, error) {
	req, err := client.UpdateCreateRequest(ctx, resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.UpdateHandleError(resp)
	}
	return resp, nil
}

// UpdateCreateRequest creates the Update request.
func (client *ResourcesClient) UpdateCreateRequest(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, parameters GenericResource) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// UpdateHandleResponse handles the Update response.
func (client *ResourcesClient) UpdateHandleResponse(resp *azcore.Response) (*GenericResourceResponse, error) {
	result := GenericResourceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.GenericResource)
}

// UpdateHandleError handles the Update error response.
func (client *ResourcesClient) UpdateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

func (client *ResourcesClient) BeginUpdateByID(ctx context.Context, resourceId string, parameters GenericResource) (*GenericResourcePollerResponse, error) {
	resp, err := client.UpdateByID(ctx, resourceId, parameters)
	if err != nil {
		return nil, err
	}
	result := &GenericResourcePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("ResourcesClient.UpdateByID", "", resp, client.UpdateByIDHandleError)
	if err != nil {
		return nil, err
	}
	poller := &genericResourcePoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*GenericResourceResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *ResourcesClient) ResumeUpdateByID(token string) (GenericResourcePoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("ResourcesClient.UpdateByID", token, client.UpdateByIDHandleError)
	if err != nil {
		return nil, err
	}
	return &genericResourcePoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// UpdateByID - Updates a resource by ID.
func (client *ResourcesClient) UpdateByID(ctx context.Context, resourceId string, parameters GenericResource) (*azcore.Response, error) {
	req, err := client.UpdateByIDCreateRequest(ctx, resourceId, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.UpdateByIDHandleError(resp)
	}
	return resp, nil
}

// UpdateByIDCreateRequest creates the UpdateByID request.
func (client *ResourcesClient) UpdateByIDCreateRequest(ctx context.Context, resourceId string, parameters GenericResource) (*azcore.Request, error) {
	urlPath := "/{resourceId}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceId)
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// UpdateByIDHandleResponse handles the UpdateByID response.
func (client *ResourcesClient) UpdateByIDHandleResponse(resp *azcore.Response) (*GenericResourceResponse, error) {
	result := GenericResourceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.GenericResource)
}

// UpdateByIDHandleError handles the UpdateByID error response.
func (client *ResourcesClient) UpdateByIDHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

func (client *ResourcesClient) BeginValidateMoveResources(ctx context.Context, sourceResourceGroupName string, parameters ResourcesMoveInfo) (*HTTPPollerResponse, error) {
	resp, err := client.ValidateMoveResources(ctx, sourceResourceGroupName, parameters)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("ResourcesClient.ValidateMoveResources", "", resp, client.ValidateMoveResourcesHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *ResourcesClient) ResumeValidateMoveResources(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("ResourcesClient.ValidateMoveResources", token, client.ValidateMoveResourcesHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// ValidateMoveResources - This operation checks whether the specified resources can be moved to the target. The resources to move must be in the same source resource group. The target resource group may be in a different subscription. If validation succeeds, it returns HTTP response code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an error message. Retrieve the URL in the Location header value to check the result of the long-running operation.
func (client *ResourcesClient) ValidateMoveResources(ctx context.Context, sourceResourceGroupName string, parameters ResourcesMoveInfo) (*azcore.Response, error) {
	req, err := client.ValidateMoveResourcesCreateRequest(ctx, sourceResourceGroupName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent, http.StatusConflict) {
		return nil, client.ValidateMoveResourcesHandleError(resp)
	}
	return resp, nil
}

// ValidateMoveResourcesCreateRequest creates the ValidateMoveResources request.
func (client *ResourcesClient) ValidateMoveResourcesCreateRequest(ctx context.Context, sourceResourceGroupName string, parameters ResourcesMoveInfo) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/validateMoveResources"
	urlPath = strings.ReplaceAll(urlPath, "{sourceResourceGroupName}", url.PathEscape(sourceResourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-05-01")
	req.URL.RawQuery = query.Encode()
	return req, req.MarshalAsJSON(parameters)
}

// ValidateMoveResourcesHandleError handles the ValidateMoveResources error response.
func (client *ResourcesClient) ValidateMoveResourcesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}
