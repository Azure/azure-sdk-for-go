// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armresources

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// DeploymentsOperations contains the methods for the Deployments group.
type DeploymentsOperations interface {
	// CalculateTemplateHash - Calculate the hash of the given template.
	CalculateTemplateHash(ctx context.Context, templateParameter interface{}, options *DeploymentsCalculateTemplateHashOptions) (*TemplateHashResultResponse, error)
	// Cancel - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is
	// set to Canceled. Canceling a template deployment stops the
	// currently running template deployment and leaves the resource group partially deployed.
	Cancel(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCancelOptions) (*http.Response, error)
	// CancelAtManagementGroupScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the
	// provisioningState is set to Canceled. Canceling a template deployment stops the
	// currently running template deployment and leaves the resources partially deployed.
	CancelAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsCancelAtManagementGroupScopeOptions) (*http.Response, error)
	// CancelAtScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState
	// is set to Canceled. Canceling a template deployment stops the
	// currently running template deployment and leaves the resources partially deployed.
	CancelAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsCancelAtScopeOptions) (*http.Response, error)
	// CancelAtSubscriptionScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState
	// is set to Canceled. Canceling a template deployment stops the
	// currently running template deployment and leaves the resources partially deployed.
	CancelAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsCancelAtSubscriptionScopeOptions) (*http.Response, error)
	// CancelAtTenantScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState
	// is set to Canceled. Canceling a template deployment stops the
	// currently running template deployment and leaves the resources partially deployed.
	CancelAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsCancelAtTenantScopeOptions) (*http.Response, error)
	// CheckExistence - Checks whether the deployment exists.
	CheckExistence(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCheckExistenceOptions) (*BooleanResponse, error)
	// CheckExistenceAtManagementGroupScope - Checks whether the deployment exists.
	CheckExistenceAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsCheckExistenceAtManagementGroupScopeOptions) (*BooleanResponse, error)
	// CheckExistenceAtScope - Checks whether the deployment exists.
	CheckExistenceAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsCheckExistenceAtScopeOptions) (*BooleanResponse, error)
	// CheckExistenceAtSubscriptionScope - Checks whether the deployment exists.
	CheckExistenceAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtSubscriptionScopeOptions) (*BooleanResponse, error)
	// CheckExistenceAtTenantScope - Checks whether the deployment exists.
	CheckExistenceAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtTenantScopeOptions) (*BooleanResponse, error)
	// BeginCreateOrUpdate - You can provide the template and parameters directly in the request or link to JSON files.
	BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateOptions) (*DeploymentExtendedPollerResponse, error)
	// ResumeCreateOrUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdate(token string) (DeploymentExtendedPoller, error)
	// BeginCreateOrUpdateAtManagementGroupScope - You can provide the template and parameters directly in the request or link to JSON files.
	BeginCreateOrUpdateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters ScopedDeployment, options *DeploymentsCreateOrUpdateAtManagementGroupScopeOptions) (*DeploymentExtendedPollerResponse, error)
	// ResumeCreateOrUpdateAtManagementGroupScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdateAtManagementGroupScope(token string) (DeploymentExtendedPoller, error)
	// BeginCreateOrUpdateAtScope - You can provide the template and parameters directly in the request or link to JSON files.
	BeginCreateOrUpdateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtScopeOptions) (*DeploymentExtendedPollerResponse, error)
	// ResumeCreateOrUpdateAtScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdateAtScope(token string) (DeploymentExtendedPoller, error)
	// BeginCreateOrUpdateAtSubscriptionScope - You can provide the template and parameters directly in the request or link to JSON files.
	BeginCreateOrUpdateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtSubscriptionScopeOptions) (*DeploymentExtendedPollerResponse, error)
	// ResumeCreateOrUpdateAtSubscriptionScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdateAtSubscriptionScope(token string) (DeploymentExtendedPoller, error)
	// BeginCreateOrUpdateAtTenantScope - You can provide the template and parameters directly in the request or link to JSON files.
	BeginCreateOrUpdateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsCreateOrUpdateAtTenantScopeOptions) (*DeploymentExtendedPollerResponse, error)
	// ResumeCreateOrUpdateAtTenantScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdateAtTenantScope(token string) (DeploymentExtendedPoller, error)
	// BeginDelete - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations.
	// Deleting a template deployment does not affect the state
	// of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location
	// response header contains the URI that is used
	// to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process
	// finishes, the URI in the Location header returns a
	// status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
	BeginDelete(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsDeleteOptions) (*HTTPPollerResponse, error)
	// ResumeDelete - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDelete(token string) (HTTPPoller, error)
	// BeginDeleteAtManagementGroupScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated
	// deployment operations. This is an asynchronous operation that returns a status
	// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
	// process. While the process is running, a call to
	// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
	// If the asynchronous request failed, the URI in the
	// Location header returns an error-level status code.
	BeginDeleteAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsDeleteAtManagementGroupScopeOptions) (*HTTPPollerResponse, error)
	// ResumeDeleteAtManagementGroupScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAtManagementGroupScope(token string) (HTTPPoller, error)
	// BeginDeleteAtScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment
	// operations. This is an asynchronous operation that returns a status
	// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
	// process. While the process is running, a call to
	// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
	// If the asynchronous request failed, the URI in the
	// Location header returns an error-level status code.
	BeginDeleteAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsDeleteAtScopeOptions) (*HTTPPollerResponse, error)
	// ResumeDeleteAtScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAtScope(token string) (HTTPPoller, error)
	// BeginDeleteAtSubscriptionScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated
	// deployment operations. This is an asynchronous operation that returns a status
	// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
	// process. While the process is running, a call to
	// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
	// If the asynchronous request failed, the URI in the
	// Location header returns an error-level status code.
	BeginDeleteAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsDeleteAtSubscriptionScopeOptions) (*HTTPPollerResponse, error)
	// ResumeDeleteAtSubscriptionScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAtSubscriptionScope(token string) (HTTPPoller, error)
	// BeginDeleteAtTenantScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment
	// operations. This is an asynchronous operation that returns a status
	// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
	// process. While the process is running, a call to
	// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
	// If the asynchronous request failed, the URI in the
	// Location header returns an error-level status code.
	BeginDeleteAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsDeleteAtTenantScopeOptions) (*HTTPPollerResponse, error)
	// ResumeDeleteAtTenantScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteAtTenantScope(token string) (HTTPPoller, error)
	// ExportTemplate - Exports the template used for specified deployment.
	ExportTemplate(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsExportTemplateOptions) (*DeploymentExportResultResponse, error)
	// ExportTemplateAtManagementGroupScope - Exports the template used for specified deployment.
	ExportTemplateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsExportTemplateAtManagementGroupScopeOptions) (*DeploymentExportResultResponse, error)
	// ExportTemplateAtScope - Exports the template used for specified deployment.
	ExportTemplateAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsExportTemplateAtScopeOptions) (*DeploymentExportResultResponse, error)
	// ExportTemplateAtSubscriptionScope - Exports the template used for specified deployment.
	ExportTemplateAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtSubscriptionScopeOptions) (*DeploymentExportResultResponse, error)
	// ExportTemplateAtTenantScope - Exports the template used for specified deployment.
	ExportTemplateAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtTenantScopeOptions) (*DeploymentExportResultResponse, error)
	// Get - Gets a deployment.
	Get(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsGetOptions) (*DeploymentExtendedResponse, error)
	// GetAtManagementGroupScope - Gets a deployment.
	GetAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsGetAtManagementGroupScopeOptions) (*DeploymentExtendedResponse, error)
	// GetAtScope - Gets a deployment.
	GetAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsGetAtScopeOptions) (*DeploymentExtendedResponse, error)
	// GetAtSubscriptionScope - Gets a deployment.
	GetAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsGetAtSubscriptionScopeOptions) (*DeploymentExtendedResponse, error)
	// GetAtTenantScope - Gets a deployment.
	GetAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsGetAtTenantScopeOptions) (*DeploymentExtendedResponse, error)
	// ListAtManagementGroupScope - Get all the deployments for a management group.
	ListAtManagementGroupScope(groupId string, options *DeploymentsListAtManagementGroupScopeOptions) DeploymentListResultPager
	// ListAtScope - Get all the deployments at the given scope.
	ListAtScope(scope string, options *DeploymentsListAtScopeOptions) DeploymentListResultPager
	// ListAtSubscriptionScope - Get all the deployments for a subscription.
	ListAtSubscriptionScope(options *DeploymentsListAtSubscriptionScopeOptions) DeploymentListResultPager
	// ListAtTenantScope - Get all the deployments at the tenant scope.
	ListAtTenantScope(options *DeploymentsListAtTenantScopeOptions) DeploymentListResultPager
	// ListByResourceGroup - Get all the deployments for a resource group.
	ListByResourceGroup(resourceGroupName string, options *DeploymentsListByResourceGroupOptions) DeploymentListResultPager
	// BeginValidate - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
	BeginValidate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsValidateOptions) (*DeploymentValidateResultPollerResponse, error)
	// ResumeValidate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeValidate(token string) (DeploymentValidateResultPoller, error)
	// BeginValidateAtManagementGroupScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
	BeginValidateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters ScopedDeployment, options *DeploymentsValidateAtManagementGroupScopeOptions) (*DeploymentValidateResultPollerResponse, error)
	// ResumeValidateAtManagementGroupScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeValidateAtManagementGroupScope(token string) (DeploymentValidateResultPoller, error)
	// BeginValidateAtScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
	BeginValidateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsValidateAtScopeOptions) (*DeploymentValidateResultPollerResponse, error)
	// ResumeValidateAtScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeValidateAtScope(token string) (DeploymentValidateResultPoller, error)
	// BeginValidateAtSubscriptionScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
	BeginValidateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsValidateAtSubscriptionScopeOptions) (*DeploymentValidateResultPollerResponse, error)
	// ResumeValidateAtSubscriptionScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeValidateAtSubscriptionScope(token string) (DeploymentValidateResultPoller, error)
	// BeginValidateAtTenantScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
	BeginValidateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsValidateAtTenantScopeOptions) (*DeploymentValidateResultPollerResponse, error)
	// ResumeValidateAtTenantScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeValidateAtTenantScope(token string) (DeploymentValidateResultPoller, error)
	// BeginWhatIf - Returns changes that will be made by the deployment if executed at the scope of the resource group.
	BeginWhatIf(ctx context.Context, resourceGroupName string, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsWhatIfOptions) (*WhatIfOperationResultPollerResponse, error)
	// ResumeWhatIf - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeWhatIf(token string) (WhatIfOperationResultPoller, error)
	// BeginWhatIfAtManagementGroupScope - Returns changes that will be made by the deployment if executed at the scope of the management group.
	BeginWhatIfAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsWhatIfAtManagementGroupScopeOptions) (*WhatIfOperationResultPollerResponse, error)
	// ResumeWhatIfAtManagementGroupScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeWhatIfAtManagementGroupScope(token string) (WhatIfOperationResultPoller, error)
	// BeginWhatIfAtSubscriptionScope - Returns changes that will be made by the deployment if executed at the scope of the subscription.
	BeginWhatIfAtSubscriptionScope(ctx context.Context, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsWhatIfAtSubscriptionScopeOptions) (*WhatIfOperationResultPollerResponse, error)
	// ResumeWhatIfAtSubscriptionScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeWhatIfAtSubscriptionScope(token string) (WhatIfOperationResultPoller, error)
	// BeginWhatIfAtTenantScope - Returns changes that will be made by the deployment if executed at the scope of the tenant group.
	BeginWhatIfAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsWhatIfAtTenantScopeOptions) (*WhatIfOperationResultPollerResponse, error)
	// ResumeWhatIfAtTenantScope - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeWhatIfAtTenantScope(token string) (WhatIfOperationResultPoller, error)
}

// DeploymentsClient implements the DeploymentsOperations interface.
// Don't use this type directly, use NewDeploymentsClient() instead.
type DeploymentsClient struct {
	con            *armcore.Connection
	subscriptionID string
}

// NewDeploymentsClient creates a new instance of DeploymentsClient with the specified values.
func NewDeploymentsClient(con *armcore.Connection, subscriptionID string) DeploymentsOperations {
	return &DeploymentsClient{con: con, subscriptionID: subscriptionID}
}

// Pipeline returns the pipeline associated with this client.
func (client *DeploymentsClient) Pipeline() azcore.Pipeline {
	return client.con.Pipeline()
}

// CalculateTemplateHash - Calculate the hash of the given template.
func (client *DeploymentsClient) CalculateTemplateHash(ctx context.Context, templateParameter interface{}, options *DeploymentsCalculateTemplateHashOptions) (*TemplateHashResultResponse, error) {
	req, err := client.CalculateTemplateHashCreateRequest(ctx, templateParameter, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.CalculateTemplateHashHandleError(resp)
	}
	result, err := client.CalculateTemplateHashHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// CalculateTemplateHashCreateRequest creates the CalculateTemplateHash request.
func (client *DeploymentsClient) CalculateTemplateHashCreateRequest(ctx context.Context, templateParameter interface{}, options *DeploymentsCalculateTemplateHashOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/calculateTemplateHash"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(templateParameter)
}

// CalculateTemplateHashHandleResponse handles the CalculateTemplateHash response.
func (client *DeploymentsClient) CalculateTemplateHashHandleResponse(resp *azcore.Response) (*TemplateHashResultResponse, error) {
	result := TemplateHashResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.TemplateHashResult)
}

// CalculateTemplateHashHandleError handles the CalculateTemplateHash error response.
func (client *DeploymentsClient) CalculateTemplateHashHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// Cancel - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is
// set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resource group partially deployed.
func (client *DeploymentsClient) Cancel(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCancelOptions) (*http.Response, error) {
	req, err := client.CancelCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.CancelHandleError(resp)
	}
	return resp.Response, nil
}

// CancelCreateRequest creates the Cancel request.
func (client *DeploymentsClient) CancelCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCancelOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// CancelHandleError handles the Cancel error response.
func (client *DeploymentsClient) CancelHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// CancelAtManagementGroupScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the
// provisioningState is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resources partially deployed.
func (client *DeploymentsClient) CancelAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsCancelAtManagementGroupScopeOptions) (*http.Response, error) {
	req, err := client.CancelAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.CancelAtManagementGroupScopeHandleError(resp)
	}
	return resp.Response, nil
}

// CancelAtManagementGroupScopeCreateRequest creates the CancelAtManagementGroupScope request.
func (client *DeploymentsClient) CancelAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, options *DeploymentsCancelAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// CancelAtManagementGroupScopeHandleError handles the CancelAtManagementGroupScope error response.
func (client *DeploymentsClient) CancelAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// CancelAtScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState
// is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resources partially deployed.
func (client *DeploymentsClient) CancelAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsCancelAtScopeOptions) (*http.Response, error) {
	req, err := client.CancelAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.CancelAtScopeHandleError(resp)
	}
	return resp.Response, nil
}

// CancelAtScopeCreateRequest creates the CancelAtScope request.
func (client *DeploymentsClient) CancelAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, options *DeploymentsCancelAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// CancelAtScopeHandleError handles the CancelAtScope error response.
func (client *DeploymentsClient) CancelAtScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// CancelAtSubscriptionScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState
// is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resources partially deployed.
func (client *DeploymentsClient) CancelAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsCancelAtSubscriptionScopeOptions) (*http.Response, error) {
	req, err := client.CancelAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.CancelAtSubscriptionScopeHandleError(resp)
	}
	return resp.Response, nil
}

// CancelAtSubscriptionScopeCreateRequest creates the CancelAtSubscriptionScope request.
func (client *DeploymentsClient) CancelAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsCancelAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// CancelAtSubscriptionScopeHandleError handles the CancelAtSubscriptionScope error response.
func (client *DeploymentsClient) CancelAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// CancelAtTenantScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState
// is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resources partially deployed.
func (client *DeploymentsClient) CancelAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsCancelAtTenantScopeOptions) (*http.Response, error) {
	req, err := client.CancelAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.CancelAtTenantScopeHandleError(resp)
	}
	return resp.Response, nil
}

// CancelAtTenantScopeCreateRequest creates the CancelAtTenantScope request.
func (client *DeploymentsClient) CancelAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsCancelAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// CancelAtTenantScopeHandleError handles the CancelAtTenantScope error response.
func (client *DeploymentsClient) CancelAtTenantScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// CheckExistence - Checks whether the deployment exists.
func (client *DeploymentsClient) CheckExistence(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCheckExistenceOptions) (*BooleanResponse, error) {
	req, err := client.CheckExistenceCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		return &BooleanResponse{RawResponse: resp.Response, Success: true}, nil
	} else if resp.StatusCode >= 400 && resp.StatusCode < 500 {
		return &BooleanResponse{RawResponse: resp.Response, Success: false}, nil
	} else {
		return nil, client.CheckExistenceHandleError(resp)
	}
}

// CheckExistenceCreateRequest creates the CheckExistence request.
func (client *DeploymentsClient) CheckExistenceCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCheckExistenceOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// CheckExistenceHandleError handles the CheckExistence error response.
func (client *DeploymentsClient) CheckExistenceHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// CheckExistenceAtManagementGroupScope - Checks whether the deployment exists.
func (client *DeploymentsClient) CheckExistenceAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsCheckExistenceAtManagementGroupScopeOptions) (*BooleanResponse, error) {
	req, err := client.CheckExistenceAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		return &BooleanResponse{RawResponse: resp.Response, Success: true}, nil
	} else if resp.StatusCode >= 400 && resp.StatusCode < 500 {
		return &BooleanResponse{RawResponse: resp.Response, Success: false}, nil
	} else {
		return nil, client.CheckExistenceAtManagementGroupScopeHandleError(resp)
	}
}

// CheckExistenceAtManagementGroupScopeCreateRequest creates the CheckExistenceAtManagementGroupScope request.
func (client *DeploymentsClient) CheckExistenceAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, options *DeploymentsCheckExistenceAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// CheckExistenceAtManagementGroupScopeHandleError handles the CheckExistenceAtManagementGroupScope error response.
func (client *DeploymentsClient) CheckExistenceAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// CheckExistenceAtScope - Checks whether the deployment exists.
func (client *DeploymentsClient) CheckExistenceAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsCheckExistenceAtScopeOptions) (*BooleanResponse, error) {
	req, err := client.CheckExistenceAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		return &BooleanResponse{RawResponse: resp.Response, Success: true}, nil
	} else if resp.StatusCode >= 400 && resp.StatusCode < 500 {
		return &BooleanResponse{RawResponse: resp.Response, Success: false}, nil
	} else {
		return nil, client.CheckExistenceAtScopeHandleError(resp)
	}
}

// CheckExistenceAtScopeCreateRequest creates the CheckExistenceAtScope request.
func (client *DeploymentsClient) CheckExistenceAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, options *DeploymentsCheckExistenceAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// CheckExistenceAtScopeHandleError handles the CheckExistenceAtScope error response.
func (client *DeploymentsClient) CheckExistenceAtScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// CheckExistenceAtSubscriptionScope - Checks whether the deployment exists.
func (client *DeploymentsClient) CheckExistenceAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtSubscriptionScopeOptions) (*BooleanResponse, error) {
	req, err := client.CheckExistenceAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		return &BooleanResponse{RawResponse: resp.Response, Success: true}, nil
	} else if resp.StatusCode >= 400 && resp.StatusCode < 500 {
		return &BooleanResponse{RawResponse: resp.Response, Success: false}, nil
	} else {
		return nil, client.CheckExistenceAtSubscriptionScopeHandleError(resp)
	}
}

// CheckExistenceAtSubscriptionScopeCreateRequest creates the CheckExistenceAtSubscriptionScope request.
func (client *DeploymentsClient) CheckExistenceAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// CheckExistenceAtSubscriptionScopeHandleError handles the CheckExistenceAtSubscriptionScope error response.
func (client *DeploymentsClient) CheckExistenceAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// CheckExistenceAtTenantScope - Checks whether the deployment exists.
func (client *DeploymentsClient) CheckExistenceAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtTenantScopeOptions) (*BooleanResponse, error) {
	req, err := client.CheckExistenceAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		return &BooleanResponse{RawResponse: resp.Response, Success: true}, nil
	} else if resp.StatusCode >= 400 && resp.StatusCode < 500 {
		return &BooleanResponse{RawResponse: resp.Response, Success: false}, nil
	} else {
		return nil, client.CheckExistenceAtTenantScopeHandleError(resp)
	}
}

// CheckExistenceAtTenantScopeCreateRequest creates the CheckExistenceAtTenantScope request.
func (client *DeploymentsClient) CheckExistenceAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// CheckExistenceAtTenantScopeHandleError handles the CheckExistenceAtTenantScope error response.
func (client *DeploymentsClient) CheckExistenceAtTenantScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateOptions) (*DeploymentExtendedPollerResponse, error) {
	resp, err := client.CreateOrUpdate(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdate", "", resp, client.CreateOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentExtendedPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeCreateOrUpdate(token string) (DeploymentExtendedPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdate", token, client.CreateOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// CreateOrUpdate - You can provide the template and parameters directly in the request or link to JSON files.
func (client *DeploymentsClient) CreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateOptions) (*azcore.Response, error) {
	req, err := client.CreateOrUpdateCreateRequest(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.CreateOrUpdateHandleError(resp)
	}
	return resp, nil
}

// CreateOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *DeploymentsClient) CreateOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// CreateOrUpdateHandleResponse handles the CreateOrUpdate response.
func (client *DeploymentsClient) CreateOrUpdateHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// CreateOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *DeploymentsClient) CreateOrUpdateHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginCreateOrUpdateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters ScopedDeployment, options *DeploymentsCreateOrUpdateAtManagementGroupScopeOptions) (*DeploymentExtendedPollerResponse, error) {
	resp, err := client.CreateOrUpdateAtManagementGroupScope(ctx, groupId, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdateAtManagementGroupScope", "", resp, client.CreateOrUpdateAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentExtendedPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeCreateOrUpdateAtManagementGroupScope(token string) (DeploymentExtendedPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtManagementGroupScope", token, client.CreateOrUpdateAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// CreateOrUpdateAtManagementGroupScope - You can provide the template and parameters directly in the request or link to JSON files.
func (client *DeploymentsClient) CreateOrUpdateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters ScopedDeployment, options *DeploymentsCreateOrUpdateAtManagementGroupScopeOptions) (*azcore.Response, error) {
	req, err := client.CreateOrUpdateAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.CreateOrUpdateAtManagementGroupScopeHandleError(resp)
	}
	return resp, nil
}

// CreateOrUpdateAtManagementGroupScopeCreateRequest creates the CreateOrUpdateAtManagementGroupScope request.
func (client *DeploymentsClient) CreateOrUpdateAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, parameters ScopedDeployment, options *DeploymentsCreateOrUpdateAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// CreateOrUpdateAtManagementGroupScopeHandleResponse handles the CreateOrUpdateAtManagementGroupScope response.
func (client *DeploymentsClient) CreateOrUpdateAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// CreateOrUpdateAtManagementGroupScopeHandleError handles the CreateOrUpdateAtManagementGroupScope error response.
func (client *DeploymentsClient) CreateOrUpdateAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginCreateOrUpdateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtScopeOptions) (*DeploymentExtendedPollerResponse, error) {
	resp, err := client.CreateOrUpdateAtScope(ctx, scope, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdateAtScope", "", resp, client.CreateOrUpdateAtScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentExtendedPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeCreateOrUpdateAtScope(token string) (DeploymentExtendedPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtScope", token, client.CreateOrUpdateAtScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// CreateOrUpdateAtScope - You can provide the template and parameters directly in the request or link to JSON files.
func (client *DeploymentsClient) CreateOrUpdateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtScopeOptions) (*azcore.Response, error) {
	req, err := client.CreateOrUpdateAtScopeCreateRequest(ctx, scope, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.CreateOrUpdateAtScopeHandleError(resp)
	}
	return resp, nil
}

// CreateOrUpdateAtScopeCreateRequest creates the CreateOrUpdateAtScope request.
func (client *DeploymentsClient) CreateOrUpdateAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// CreateOrUpdateAtScopeHandleResponse handles the CreateOrUpdateAtScope response.
func (client *DeploymentsClient) CreateOrUpdateAtScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// CreateOrUpdateAtScopeHandleError handles the CreateOrUpdateAtScope error response.
func (client *DeploymentsClient) CreateOrUpdateAtScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginCreateOrUpdateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtSubscriptionScopeOptions) (*DeploymentExtendedPollerResponse, error) {
	resp, err := client.CreateOrUpdateAtSubscriptionScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdateAtSubscriptionScope", "", resp, client.CreateOrUpdateAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentExtendedPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeCreateOrUpdateAtSubscriptionScope(token string) (DeploymentExtendedPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtSubscriptionScope", token, client.CreateOrUpdateAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// CreateOrUpdateAtSubscriptionScope - You can provide the template and parameters directly in the request or link to JSON files.
func (client *DeploymentsClient) CreateOrUpdateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtSubscriptionScopeOptions) (*azcore.Response, error) {
	req, err := client.CreateOrUpdateAtSubscriptionScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.CreateOrUpdateAtSubscriptionScopeHandleError(resp)
	}
	return resp, nil
}

// CreateOrUpdateAtSubscriptionScopeCreateRequest creates the CreateOrUpdateAtSubscriptionScope request.
func (client *DeploymentsClient) CreateOrUpdateAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsCreateOrUpdateAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// CreateOrUpdateAtSubscriptionScopeHandleResponse handles the CreateOrUpdateAtSubscriptionScope response.
func (client *DeploymentsClient) CreateOrUpdateAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// CreateOrUpdateAtSubscriptionScopeHandleError handles the CreateOrUpdateAtSubscriptionScope error response.
func (client *DeploymentsClient) CreateOrUpdateAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginCreateOrUpdateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsCreateOrUpdateAtTenantScopeOptions) (*DeploymentExtendedPollerResponse, error) {
	resp, err := client.CreateOrUpdateAtTenantScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdateAtTenantScope", "", resp, client.CreateOrUpdateAtTenantScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentExtendedPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeCreateOrUpdateAtTenantScope(token string) (DeploymentExtendedPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtTenantScope", token, client.CreateOrUpdateAtTenantScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// CreateOrUpdateAtTenantScope - You can provide the template and parameters directly in the request or link to JSON files.
func (client *DeploymentsClient) CreateOrUpdateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsCreateOrUpdateAtTenantScopeOptions) (*azcore.Response, error) {
	req, err := client.CreateOrUpdateAtTenantScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.CreateOrUpdateAtTenantScopeHandleError(resp)
	}
	return resp, nil
}

// CreateOrUpdateAtTenantScopeCreateRequest creates the CreateOrUpdateAtTenantScope request.
func (client *DeploymentsClient) CreateOrUpdateAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsCreateOrUpdateAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// CreateOrUpdateAtTenantScopeHandleResponse handles the CreateOrUpdateAtTenantScope response.
func (client *DeploymentsClient) CreateOrUpdateAtTenantScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// CreateOrUpdateAtTenantScopeHandleError handles the CreateOrUpdateAtTenantScope error response.
func (client *DeploymentsClient) CreateOrUpdateAtTenantScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginDelete(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsDeleteOptions) (*HTTPPollerResponse, error) {
	resp, err := client.Delete(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.Delete", "", resp, client.DeleteHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeDelete(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.Delete", token, client.DeleteHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// Delete - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations.
// Deleting a template deployment does not affect the state
// of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location
// response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process
// finishes, the URI in the Location header returns a
// status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
func (client *DeploymentsClient) Delete(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsDeleteOptions) (*azcore.Response, error) {
	req, err := client.DeleteCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.DeleteHandleError(resp)
	}
	return resp, nil
}

// DeleteCreateRequest creates the Delete request.
func (client *DeploymentsClient) DeleteCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsDeleteOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteHandleError handles the Delete error response.
func (client *DeploymentsClient) DeleteHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginDeleteAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsDeleteAtManagementGroupScopeOptions) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteAtManagementGroupScope(ctx, groupId, deploymentName, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.DeleteAtManagementGroupScope", "", resp, client.DeleteAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeDeleteAtManagementGroupScope(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.DeleteAtManagementGroupScope", token, client.DeleteAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// DeleteAtManagementGroupScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated
// deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
// process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
// If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
func (client *DeploymentsClient) DeleteAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsDeleteAtManagementGroupScopeOptions) (*azcore.Response, error) {
	req, err := client.DeleteAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.DeleteAtManagementGroupScopeHandleError(resp)
	}
	return resp, nil
}

// DeleteAtManagementGroupScopeCreateRequest creates the DeleteAtManagementGroupScope request.
func (client *DeploymentsClient) DeleteAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, options *DeploymentsDeleteAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteAtManagementGroupScopeHandleError handles the DeleteAtManagementGroupScope error response.
func (client *DeploymentsClient) DeleteAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginDeleteAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsDeleteAtScopeOptions) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteAtScope(ctx, scope, deploymentName, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.DeleteAtScope", "", resp, client.DeleteAtScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeDeleteAtScope(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.DeleteAtScope", token, client.DeleteAtScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// DeleteAtScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations.
// This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
// process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
// If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
func (client *DeploymentsClient) DeleteAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsDeleteAtScopeOptions) (*azcore.Response, error) {
	req, err := client.DeleteAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.DeleteAtScopeHandleError(resp)
	}
	return resp, nil
}

// DeleteAtScopeCreateRequest creates the DeleteAtScope request.
func (client *DeploymentsClient) DeleteAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, options *DeploymentsDeleteAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteAtScopeHandleError handles the DeleteAtScope error response.
func (client *DeploymentsClient) DeleteAtScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginDeleteAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsDeleteAtSubscriptionScopeOptions) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteAtSubscriptionScope(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.DeleteAtSubscriptionScope", "", resp, client.DeleteAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeDeleteAtSubscriptionScope(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.DeleteAtSubscriptionScope", token, client.DeleteAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// DeleteAtSubscriptionScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated
// deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
// process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
// If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
func (client *DeploymentsClient) DeleteAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsDeleteAtSubscriptionScopeOptions) (*azcore.Response, error) {
	req, err := client.DeleteAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.DeleteAtSubscriptionScopeHandleError(resp)
	}
	return resp, nil
}

// DeleteAtSubscriptionScopeCreateRequest creates the DeleteAtSubscriptionScope request.
func (client *DeploymentsClient) DeleteAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsDeleteAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteAtSubscriptionScopeHandleError handles the DeleteAtSubscriptionScope error response.
func (client *DeploymentsClient) DeleteAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginDeleteAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsDeleteAtTenantScopeOptions) (*HTTPPollerResponse, error) {
	resp, err := client.DeleteAtTenantScope(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.DeleteAtTenantScope", "", resp, client.DeleteAtTenantScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeDeleteAtTenantScope(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.DeleteAtTenantScope", token, client.DeleteAtTenantScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// DeleteAtTenantScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment
// operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
// process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
// If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
func (client *DeploymentsClient) DeleteAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsDeleteAtTenantScopeOptions) (*azcore.Response, error) {
	req, err := client.DeleteAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.DeleteAtTenantScopeHandleError(resp)
	}
	return resp, nil
}

// DeleteAtTenantScopeCreateRequest creates the DeleteAtTenantScope request.
func (client *DeploymentsClient) DeleteAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsDeleteAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DeleteAtTenantScopeHandleError handles the DeleteAtTenantScope error response.
func (client *DeploymentsClient) DeleteAtTenantScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ExportTemplate - Exports the template used for specified deployment.
func (client *DeploymentsClient) ExportTemplate(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsExportTemplateOptions) (*DeploymentExportResultResponse, error) {
	req, err := client.ExportTemplateCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ExportTemplateHandleError(resp)
	}
	result, err := client.ExportTemplateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ExportTemplateCreateRequest creates the ExportTemplate request.
func (client *DeploymentsClient) ExportTemplateCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsExportTemplateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ExportTemplateHandleResponse handles the ExportTemplate response.
func (client *DeploymentsClient) ExportTemplateHandleResponse(resp *azcore.Response) (*DeploymentExportResultResponse, error) {
	result := DeploymentExportResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExportResult)
}

// ExportTemplateHandleError handles the ExportTemplate error response.
func (client *DeploymentsClient) ExportTemplateHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ExportTemplateAtManagementGroupScope - Exports the template used for specified deployment.
func (client *DeploymentsClient) ExportTemplateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsExportTemplateAtManagementGroupScopeOptions) (*DeploymentExportResultResponse, error) {
	req, err := client.ExportTemplateAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ExportTemplateAtManagementGroupScopeHandleError(resp)
	}
	result, err := client.ExportTemplateAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ExportTemplateAtManagementGroupScopeCreateRequest creates the ExportTemplateAtManagementGroupScope request.
func (client *DeploymentsClient) ExportTemplateAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, options *DeploymentsExportTemplateAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ExportTemplateAtManagementGroupScopeHandleResponse handles the ExportTemplateAtManagementGroupScope response.
func (client *DeploymentsClient) ExportTemplateAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentExportResultResponse, error) {
	result := DeploymentExportResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExportResult)
}

// ExportTemplateAtManagementGroupScopeHandleError handles the ExportTemplateAtManagementGroupScope error response.
func (client *DeploymentsClient) ExportTemplateAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ExportTemplateAtScope - Exports the template used for specified deployment.
func (client *DeploymentsClient) ExportTemplateAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsExportTemplateAtScopeOptions) (*DeploymentExportResultResponse, error) {
	req, err := client.ExportTemplateAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ExportTemplateAtScopeHandleError(resp)
	}
	result, err := client.ExportTemplateAtScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ExportTemplateAtScopeCreateRequest creates the ExportTemplateAtScope request.
func (client *DeploymentsClient) ExportTemplateAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, options *DeploymentsExportTemplateAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ExportTemplateAtScopeHandleResponse handles the ExportTemplateAtScope response.
func (client *DeploymentsClient) ExportTemplateAtScopeHandleResponse(resp *azcore.Response) (*DeploymentExportResultResponse, error) {
	result := DeploymentExportResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExportResult)
}

// ExportTemplateAtScopeHandleError handles the ExportTemplateAtScope error response.
func (client *DeploymentsClient) ExportTemplateAtScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ExportTemplateAtSubscriptionScope - Exports the template used for specified deployment.
func (client *DeploymentsClient) ExportTemplateAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtSubscriptionScopeOptions) (*DeploymentExportResultResponse, error) {
	req, err := client.ExportTemplateAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ExportTemplateAtSubscriptionScopeHandleError(resp)
	}
	result, err := client.ExportTemplateAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ExportTemplateAtSubscriptionScopeCreateRequest creates the ExportTemplateAtSubscriptionScope request.
func (client *DeploymentsClient) ExportTemplateAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ExportTemplateAtSubscriptionScopeHandleResponse handles the ExportTemplateAtSubscriptionScope response.
func (client *DeploymentsClient) ExportTemplateAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentExportResultResponse, error) {
	result := DeploymentExportResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExportResult)
}

// ExportTemplateAtSubscriptionScopeHandleError handles the ExportTemplateAtSubscriptionScope error response.
func (client *DeploymentsClient) ExportTemplateAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ExportTemplateAtTenantScope - Exports the template used for specified deployment.
func (client *DeploymentsClient) ExportTemplateAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtTenantScopeOptions) (*DeploymentExportResultResponse, error) {
	req, err := client.ExportTemplateAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ExportTemplateAtTenantScopeHandleError(resp)
	}
	result, err := client.ExportTemplateAtTenantScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ExportTemplateAtTenantScopeCreateRequest creates the ExportTemplateAtTenantScope request.
func (client *DeploymentsClient) ExportTemplateAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ExportTemplateAtTenantScopeHandleResponse handles the ExportTemplateAtTenantScope response.
func (client *DeploymentsClient) ExportTemplateAtTenantScopeHandleResponse(resp *azcore.Response) (*DeploymentExportResultResponse, error) {
	result := DeploymentExportResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExportResult)
}

// ExportTemplateAtTenantScopeHandleError handles the ExportTemplateAtTenantScope error response.
func (client *DeploymentsClient) ExportTemplateAtTenantScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// Get - Gets a deployment.
func (client *DeploymentsClient) Get(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsGetOptions) (*DeploymentExtendedResponse, error) {
	req, err := client.GetCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetHandleError(resp)
	}
	result, err := client.GetHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetCreateRequest creates the Get request.
func (client *DeploymentsClient) GetCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsGetOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetHandleResponse handles the Get response.
func (client *DeploymentsClient) GetHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// GetHandleError handles the Get error response.
func (client *DeploymentsClient) GetHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetAtManagementGroupScope - Gets a deployment.
func (client *DeploymentsClient) GetAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, options *DeploymentsGetAtManagementGroupScopeOptions) (*DeploymentExtendedResponse, error) {
	req, err := client.GetAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetAtManagementGroupScopeHandleError(resp)
	}
	result, err := client.GetAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetAtManagementGroupScopeCreateRequest creates the GetAtManagementGroupScope request.
func (client *DeploymentsClient) GetAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, options *DeploymentsGetAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetAtManagementGroupScopeHandleResponse handles the GetAtManagementGroupScope response.
func (client *DeploymentsClient) GetAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// GetAtManagementGroupScopeHandleError handles the GetAtManagementGroupScope error response.
func (client *DeploymentsClient) GetAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetAtScope - Gets a deployment.
func (client *DeploymentsClient) GetAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsGetAtScopeOptions) (*DeploymentExtendedResponse, error) {
	req, err := client.GetAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetAtScopeHandleError(resp)
	}
	result, err := client.GetAtScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetAtScopeCreateRequest creates the GetAtScope request.
func (client *DeploymentsClient) GetAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, options *DeploymentsGetAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetAtScopeHandleResponse handles the GetAtScope response.
func (client *DeploymentsClient) GetAtScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// GetAtScopeHandleError handles the GetAtScope error response.
func (client *DeploymentsClient) GetAtScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetAtSubscriptionScope - Gets a deployment.
func (client *DeploymentsClient) GetAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsGetAtSubscriptionScopeOptions) (*DeploymentExtendedResponse, error) {
	req, err := client.GetAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetAtSubscriptionScopeHandleError(resp)
	}
	result, err := client.GetAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetAtSubscriptionScopeCreateRequest creates the GetAtSubscriptionScope request.
func (client *DeploymentsClient) GetAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsGetAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetAtSubscriptionScopeHandleResponse handles the GetAtSubscriptionScope response.
func (client *DeploymentsClient) GetAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// GetAtSubscriptionScopeHandleError handles the GetAtSubscriptionScope error response.
func (client *DeploymentsClient) GetAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetAtTenantScope - Gets a deployment.
func (client *DeploymentsClient) GetAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsGetAtTenantScopeOptions) (*DeploymentExtendedResponse, error) {
	req, err := client.GetAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetAtTenantScopeHandleError(resp)
	}
	result, err := client.GetAtTenantScopeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetAtTenantScopeCreateRequest creates the GetAtTenantScope request.
func (client *DeploymentsClient) GetAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsGetAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetAtTenantScopeHandleResponse handles the GetAtTenantScope response.
func (client *DeploymentsClient) GetAtTenantScopeHandleResponse(resp *azcore.Response) (*DeploymentExtendedResponse, error) {
	result := DeploymentExtendedResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentExtended)
}

// GetAtTenantScopeHandleError handles the GetAtTenantScope error response.
func (client *DeploymentsClient) GetAtTenantScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ListAtManagementGroupScope - Get all the deployments for a management group.
func (client *DeploymentsClient) ListAtManagementGroupScope(groupId string, options *DeploymentsListAtManagementGroupScopeOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.ListAtManagementGroupScopeCreateRequest(ctx, groupId, options)
		},
		responder: client.ListAtManagementGroupScopeHandleResponse,
		errorer:   client.ListAtManagementGroupScopeHandleError,
		advancer: func(ctx context.Context, resp *DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// ListAtManagementGroupScopeCreateRequest creates the ListAtManagementGroupScope request.
func (client *DeploymentsClient) ListAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, options *DeploymentsListAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if options != nil && options.Filter != nil {
		query.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListAtManagementGroupScopeHandleResponse handles the ListAtManagementGroupScope response.
func (client *DeploymentsClient) ListAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentListResultResponse, error) {
	result := DeploymentListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentListResult)
}

// ListAtManagementGroupScopeHandleError handles the ListAtManagementGroupScope error response.
func (client *DeploymentsClient) ListAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ListAtScope - Get all the deployments at the given scope.
func (client *DeploymentsClient) ListAtScope(scope string, options *DeploymentsListAtScopeOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.ListAtScopeCreateRequest(ctx, scope, options)
		},
		responder: client.ListAtScopeHandleResponse,
		errorer:   client.ListAtScopeHandleError,
		advancer: func(ctx context.Context, resp *DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// ListAtScopeCreateRequest creates the ListAtScope request.
func (client *DeploymentsClient) ListAtScopeCreateRequest(ctx context.Context, scope string, options *DeploymentsListAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if options != nil && options.Filter != nil {
		query.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListAtScopeHandleResponse handles the ListAtScope response.
func (client *DeploymentsClient) ListAtScopeHandleResponse(resp *azcore.Response) (*DeploymentListResultResponse, error) {
	result := DeploymentListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentListResult)
}

// ListAtScopeHandleError handles the ListAtScope error response.
func (client *DeploymentsClient) ListAtScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ListAtSubscriptionScope - Get all the deployments for a subscription.
func (client *DeploymentsClient) ListAtSubscriptionScope(options *DeploymentsListAtSubscriptionScopeOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.ListAtSubscriptionScopeCreateRequest(ctx, options)
		},
		responder: client.ListAtSubscriptionScopeHandleResponse,
		errorer:   client.ListAtSubscriptionScopeHandleError,
		advancer: func(ctx context.Context, resp *DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// ListAtSubscriptionScopeCreateRequest creates the ListAtSubscriptionScope request.
func (client *DeploymentsClient) ListAtSubscriptionScopeCreateRequest(ctx context.Context, options *DeploymentsListAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if options != nil && options.Filter != nil {
		query.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListAtSubscriptionScopeHandleResponse handles the ListAtSubscriptionScope response.
func (client *DeploymentsClient) ListAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentListResultResponse, error) {
	result := DeploymentListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentListResult)
}

// ListAtSubscriptionScopeHandleError handles the ListAtSubscriptionScope error response.
func (client *DeploymentsClient) ListAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ListAtTenantScope - Get all the deployments at the tenant scope.
func (client *DeploymentsClient) ListAtTenantScope(options *DeploymentsListAtTenantScopeOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.ListAtTenantScopeCreateRequest(ctx, options)
		},
		responder: client.ListAtTenantScopeHandleResponse,
		errorer:   client.ListAtTenantScopeHandleError,
		advancer: func(ctx context.Context, resp *DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// ListAtTenantScopeCreateRequest creates the ListAtTenantScope request.
func (client *DeploymentsClient) ListAtTenantScopeCreateRequest(ctx context.Context, options *DeploymentsListAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if options != nil && options.Filter != nil {
		query.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListAtTenantScopeHandleResponse handles the ListAtTenantScope response.
func (client *DeploymentsClient) ListAtTenantScopeHandleResponse(resp *azcore.Response) (*DeploymentListResultResponse, error) {
	result := DeploymentListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentListResult)
}

// ListAtTenantScopeHandleError handles the ListAtTenantScope error response.
func (client *DeploymentsClient) ListAtTenantScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ListByResourceGroup - Get all the deployments for a resource group.
func (client *DeploymentsClient) ListByResourceGroup(resourceGroupName string, options *DeploymentsListByResourceGroupOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.ListByResourceGroupCreateRequest(ctx, resourceGroupName, options)
		},
		responder: client.ListByResourceGroupHandleResponse,
		errorer:   client.ListByResourceGroupHandleError,
		advancer: func(ctx context.Context, resp *DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// ListByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *DeploymentsClient) ListByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *DeploymentsListByResourceGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if options != nil && options.Filter != nil {
		query.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		query.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *DeploymentsClient) ListByResourceGroupHandleResponse(resp *azcore.Response) (*DeploymentListResultResponse, error) {
	result := DeploymentListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentListResult)
}

// ListByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *DeploymentsClient) ListByResourceGroupHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginValidate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsValidateOptions) (*DeploymentValidateResultPollerResponse, error) {
	resp, err := client.Validate(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentValidateResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.Validate", "", resp, client.ValidateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentValidateResultPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeValidate(token string) (DeploymentValidateResultPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.Validate", token, client.ValidateHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// Validate - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
func (client *DeploymentsClient) Validate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsValidateOptions) (*azcore.Response, error) {
	req, err := client.ValidateCreateRequest(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		return nil, client.ValidateHandleError(resp)
	}
	return resp, nil
}

// ValidateCreateRequest creates the Validate request.
func (client *DeploymentsClient) ValidateCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsValidateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// ValidateHandleResponse handles the Validate response.
func (client *DeploymentsClient) ValidateHandleResponse(resp *azcore.Response) (*DeploymentValidateResultResponse, error) {
	result := DeploymentValidateResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentValidateResult)
}

// ValidateHandleError handles the Validate error response.
func (client *DeploymentsClient) ValidateHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginValidateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters ScopedDeployment, options *DeploymentsValidateAtManagementGroupScopeOptions) (*DeploymentValidateResultPollerResponse, error) {
	resp, err := client.ValidateAtManagementGroupScope(ctx, groupId, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentValidateResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.ValidateAtManagementGroupScope", "", resp, client.ValidateAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentValidateResultPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeValidateAtManagementGroupScope(token string) (DeploymentValidateResultPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.ValidateAtManagementGroupScope", token, client.ValidateAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// ValidateAtManagementGroupScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
func (client *DeploymentsClient) ValidateAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters ScopedDeployment, options *DeploymentsValidateAtManagementGroupScopeOptions) (*azcore.Response, error) {
	req, err := client.ValidateAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		return nil, client.ValidateAtManagementGroupScopeHandleError(resp)
	}
	return resp, nil
}

// ValidateAtManagementGroupScopeCreateRequest creates the ValidateAtManagementGroupScope request.
func (client *DeploymentsClient) ValidateAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, parameters ScopedDeployment, options *DeploymentsValidateAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// ValidateAtManagementGroupScopeHandleResponse handles the ValidateAtManagementGroupScope response.
func (client *DeploymentsClient) ValidateAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*DeploymentValidateResultResponse, error) {
	result := DeploymentValidateResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentValidateResult)
}

// ValidateAtManagementGroupScopeHandleError handles the ValidateAtManagementGroupScope error response.
func (client *DeploymentsClient) ValidateAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginValidateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsValidateAtScopeOptions) (*DeploymentValidateResultPollerResponse, error) {
	resp, err := client.ValidateAtScope(ctx, scope, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentValidateResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.ValidateAtScope", "", resp, client.ValidateAtScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentValidateResultPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeValidateAtScope(token string) (DeploymentValidateResultPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.ValidateAtScope", token, client.ValidateAtScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// ValidateAtScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
func (client *DeploymentsClient) ValidateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsValidateAtScopeOptions) (*azcore.Response, error) {
	req, err := client.ValidateAtScopeCreateRequest(ctx, scope, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		return nil, client.ValidateAtScopeHandleError(resp)
	}
	return resp, nil
}

// ValidateAtScopeCreateRequest creates the ValidateAtScope request.
func (client *DeploymentsClient) ValidateAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsValidateAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// ValidateAtScopeHandleResponse handles the ValidateAtScope response.
func (client *DeploymentsClient) ValidateAtScopeHandleResponse(resp *azcore.Response) (*DeploymentValidateResultResponse, error) {
	result := DeploymentValidateResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentValidateResult)
}

// ValidateAtScopeHandleError handles the ValidateAtScope error response.
func (client *DeploymentsClient) ValidateAtScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginValidateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsValidateAtSubscriptionScopeOptions) (*DeploymentValidateResultPollerResponse, error) {
	resp, err := client.ValidateAtSubscriptionScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentValidateResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.ValidateAtSubscriptionScope", "", resp, client.ValidateAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentValidateResultPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeValidateAtSubscriptionScope(token string) (DeploymentValidateResultPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.ValidateAtSubscriptionScope", token, client.ValidateAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// ValidateAtSubscriptionScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
func (client *DeploymentsClient) ValidateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsValidateAtSubscriptionScopeOptions) (*azcore.Response, error) {
	req, err := client.ValidateAtSubscriptionScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		return nil, client.ValidateAtSubscriptionScopeHandleError(resp)
	}
	return resp, nil
}

// ValidateAtSubscriptionScopeCreateRequest creates the ValidateAtSubscriptionScope request.
func (client *DeploymentsClient) ValidateAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsValidateAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// ValidateAtSubscriptionScopeHandleResponse handles the ValidateAtSubscriptionScope response.
func (client *DeploymentsClient) ValidateAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*DeploymentValidateResultResponse, error) {
	result := DeploymentValidateResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentValidateResult)
}

// ValidateAtSubscriptionScopeHandleError handles the ValidateAtSubscriptionScope error response.
func (client *DeploymentsClient) ValidateAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginValidateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsValidateAtTenantScopeOptions) (*DeploymentValidateResultPollerResponse, error) {
	resp, err := client.ValidateAtTenantScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &DeploymentValidateResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.ValidateAtTenantScope", "", resp, client.ValidateAtTenantScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &deploymentValidateResultPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeValidateAtTenantScope(token string) (DeploymentValidateResultPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.ValidateAtTenantScope", token, client.ValidateAtTenantScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// ValidateAtTenantScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
func (client *DeploymentsClient) ValidateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsValidateAtTenantScopeOptions) (*azcore.Response, error) {
	req, err := client.ValidateAtTenantScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		return nil, client.ValidateAtTenantScopeHandleError(resp)
	}
	return resp, nil
}

// ValidateAtTenantScopeCreateRequest creates the ValidateAtTenantScope request.
func (client *DeploymentsClient) ValidateAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsValidateAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// ValidateAtTenantScopeHandleResponse handles the ValidateAtTenantScope response.
func (client *DeploymentsClient) ValidateAtTenantScopeHandleResponse(resp *azcore.Response) (*DeploymentValidateResultResponse, error) {
	result := DeploymentValidateResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.DeploymentValidateResult)
}

// ValidateAtTenantScopeHandleError handles the ValidateAtTenantScope error response.
func (client *DeploymentsClient) ValidateAtTenantScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginWhatIf(ctx context.Context, resourceGroupName string, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsWhatIfOptions) (*WhatIfOperationResultPollerResponse, error) {
	resp, err := client.WhatIf(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &WhatIfOperationResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.WhatIf", "location", resp, client.WhatIfHandleError)
	if err != nil {
		return nil, err
	}
	poller := &whatIfOperationResultPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*WhatIfOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeWhatIf(token string) (WhatIfOperationResultPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.WhatIf", token, client.WhatIfHandleError)
	if err != nil {
		return nil, err
	}
	return &whatIfOperationResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// WhatIf - Returns changes that will be made by the deployment if executed at the scope of the resource group.
func (client *DeploymentsClient) WhatIf(ctx context.Context, resourceGroupName string, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsWhatIfOptions) (*azcore.Response, error) {
	req, err := client.WhatIfCreateRequest(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.WhatIfHandleError(resp)
	}
	return resp, nil
}

// WhatIfCreateRequest creates the WhatIf request.
func (client *DeploymentsClient) WhatIfCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsWhatIfOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// WhatIfHandleResponse handles the WhatIf response.
func (client *DeploymentsClient) WhatIfHandleResponse(resp *azcore.Response) (*WhatIfOperationResultResponse, error) {
	result := WhatIfOperationResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.WhatIfOperationResult)
}

// WhatIfHandleError handles the WhatIf error response.
func (client *DeploymentsClient) WhatIfHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginWhatIfAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsWhatIfAtManagementGroupScopeOptions) (*WhatIfOperationResultPollerResponse, error) {
	resp, err := client.WhatIfAtManagementGroupScope(ctx, groupId, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &WhatIfOperationResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.WhatIfAtManagementGroupScope", "location", resp, client.WhatIfAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &whatIfOperationResultPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*WhatIfOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeWhatIfAtManagementGroupScope(token string) (WhatIfOperationResultPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.WhatIfAtManagementGroupScope", token, client.WhatIfAtManagementGroupScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &whatIfOperationResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// WhatIfAtManagementGroupScope - Returns changes that will be made by the deployment if executed at the scope of the management group.
func (client *DeploymentsClient) WhatIfAtManagementGroupScope(ctx context.Context, groupId string, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsWhatIfAtManagementGroupScopeOptions) (*azcore.Response, error) {
	req, err := client.WhatIfAtManagementGroupScopeCreateRequest(ctx, groupId, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.WhatIfAtManagementGroupScopeHandleError(resp)
	}
	return resp, nil
}

// WhatIfAtManagementGroupScopeCreateRequest creates the WhatIfAtManagementGroupScope request.
func (client *DeploymentsClient) WhatIfAtManagementGroupScopeCreateRequest(ctx context.Context, groupId string, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsWhatIfAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupId))
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// WhatIfAtManagementGroupScopeHandleResponse handles the WhatIfAtManagementGroupScope response.
func (client *DeploymentsClient) WhatIfAtManagementGroupScopeHandleResponse(resp *azcore.Response) (*WhatIfOperationResultResponse, error) {
	result := WhatIfOperationResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.WhatIfOperationResult)
}

// WhatIfAtManagementGroupScopeHandleError handles the WhatIfAtManagementGroupScope error response.
func (client *DeploymentsClient) WhatIfAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginWhatIfAtSubscriptionScope(ctx context.Context, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsWhatIfAtSubscriptionScopeOptions) (*WhatIfOperationResultPollerResponse, error) {
	resp, err := client.WhatIfAtSubscriptionScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &WhatIfOperationResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.WhatIfAtSubscriptionScope", "location", resp, client.WhatIfAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &whatIfOperationResultPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*WhatIfOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeWhatIfAtSubscriptionScope(token string) (WhatIfOperationResultPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.WhatIfAtSubscriptionScope", token, client.WhatIfAtSubscriptionScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &whatIfOperationResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// WhatIfAtSubscriptionScope - Returns changes that will be made by the deployment if executed at the scope of the subscription.
func (client *DeploymentsClient) WhatIfAtSubscriptionScope(ctx context.Context, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsWhatIfAtSubscriptionScopeOptions) (*azcore.Response, error) {
	req, err := client.WhatIfAtSubscriptionScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.WhatIfAtSubscriptionScopeHandleError(resp)
	}
	return resp, nil
}

// WhatIfAtSubscriptionScopeCreateRequest creates the WhatIfAtSubscriptionScope request.
func (client *DeploymentsClient) WhatIfAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsWhatIfAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// WhatIfAtSubscriptionScopeHandleResponse handles the WhatIfAtSubscriptionScope response.
func (client *DeploymentsClient) WhatIfAtSubscriptionScopeHandleResponse(resp *azcore.Response) (*WhatIfOperationResultResponse, error) {
	result := WhatIfOperationResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.WhatIfOperationResult)
}

// WhatIfAtSubscriptionScopeHandleError handles the WhatIfAtSubscriptionScope error response.
func (client *DeploymentsClient) WhatIfAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

func (client *DeploymentsClient) BeginWhatIfAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsWhatIfAtTenantScopeOptions) (*WhatIfOperationResultPollerResponse, error) {
	resp, err := client.WhatIfAtTenantScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &WhatIfOperationResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.WhatIfAtTenantScope", "location", resp, client.WhatIfAtTenantScopeHandleError)
	if err != nil {
		return nil, err
	}
	poller := &whatIfOperationResultPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*WhatIfOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *DeploymentsClient) ResumeWhatIfAtTenantScope(token string) (WhatIfOperationResultPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.WhatIfAtTenantScope", token, client.WhatIfAtTenantScopeHandleError)
	if err != nil {
		return nil, err
	}
	return &whatIfOperationResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// WhatIfAtTenantScope - Returns changes that will be made by the deployment if executed at the scope of the tenant group.
func (client *DeploymentsClient) WhatIfAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsWhatIfAtTenantScopeOptions) (*azcore.Response, error) {
	req, err := client.WhatIfAtTenantScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.WhatIfAtTenantScopeHandleError(resp)
	}
	return resp, nil
}

// WhatIfAtTenantScopeCreateRequest creates the WhatIfAtTenantScope request.
func (client *DeploymentsClient) WhatIfAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsWhatIfAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2020-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// WhatIfAtTenantScopeHandleResponse handles the WhatIfAtTenantScope response.
func (client *DeploymentsClient) WhatIfAtTenantScopeHandleResponse(resp *azcore.Response) (*WhatIfOperationResultResponse, error) {
	result := WhatIfOperationResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.WhatIfOperationResult)
}

// WhatIfAtTenantScopeHandleError handles the WhatIfAtTenantScope error response.
func (client *DeploymentsClient) WhatIfAtTenantScopeHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}
