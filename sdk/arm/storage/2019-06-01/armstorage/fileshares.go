// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorage

import (
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strings"
)

// FileSharesOperations contains the methods for the FileShares group.
type FileSharesOperations interface {
	// Create - Creates a new share under the specified account as described by request body. The share resource includes metadata and properties for that share. It does not include a list of the files contained by the share.
	Create(ctx context.Context, resourceGroupName string, accountName string, shareName string, fileShare FileShare) (*FileShareResponse, error)
	// Delete - Deletes specified share under its account.
	Delete(ctx context.Context, resourceGroupName string, accountName string, shareName string) (*http.Response, error)
	// Get - Gets properties of a specified share.
	Get(ctx context.Context, resourceGroupName string, accountName string, shareName string) (*FileShareResponse, error)
	// List - Lists all shares.
	List(resourceGroupName string, accountName string, fileSharesListOptions *FileSharesListOptions) (FileShareItemsPager, error)
	// Restore - Restore a file share within a valid retention days if share soft delete is enabled
	Restore(ctx context.Context, resourceGroupName string, accountName string, shareName string, deletedShare DeletedShare) (*http.Response, error)
	// Update - Updates share properties as specified in request body. Properties not mentioned in the request will not be changed. Update fails if the specified share does not already exist.
	Update(ctx context.Context, resourceGroupName string, accountName string, shareName string, fileShare FileShare) (*FileShareResponse, error)
}

// fileSharesOperations implements the FileSharesOperations interface.
type fileSharesOperations struct {
	*Client
	subscriptionID string
}

// Create - Creates a new share under the specified account as described by request body. The share resource includes metadata and properties for that share. It does not include a list of the files contained by the share.
func (client *fileSharesOperations) Create(ctx context.Context, resourceGroupName string, accountName string, shareName string, fileShare FileShare) (*FileShareResponse, error) {
	req, err := client.createCreateRequest(resourceGroupName, accountName, shareName, fileShare)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// createCreateRequest creates the Create request.
func (client *fileSharesOperations) createCreateRequest(resourceGroupName string, accountName string, shareName string, fileShare FileShare) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares/{shareName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{shareName}", url.PathEscape(shareName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(fileShare)
}

// createHandleResponse handles the Create response.
func (client *fileSharesOperations) createHandleResponse(resp *azcore.Response) (*FileShareResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.createHandleError(resp)
	}
	result := FileShareResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.FileShare)
}

// createHandleError handles the Create error response.
func (client *fileSharesOperations) createHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Delete - Deletes specified share under its account.
func (client *fileSharesOperations) Delete(ctx context.Context, resourceGroupName string, accountName string, shareName string) (*http.Response, error) {
	req, err := client.deleteCreateRequest(resourceGroupName, accountName, shareName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// deleteCreateRequest creates the Delete request.
func (client *fileSharesOperations) deleteCreateRequest(resourceGroupName string, accountName string, shareName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares/{shareName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{shareName}", url.PathEscape(shareName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *fileSharesOperations) deleteHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	return resp.Response, nil
}

// deleteHandleError handles the Delete error response.
func (client *fileSharesOperations) deleteHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Get - Gets properties of a specified share.
func (client *fileSharesOperations) Get(ctx context.Context, resourceGroupName string, accountName string, shareName string) (*FileShareResponse, error) {
	req, err := client.getCreateRequest(resourceGroupName, accountName, shareName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getCreateRequest creates the Get request.
func (client *fileSharesOperations) getCreateRequest(resourceGroupName string, accountName string, shareName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares/{shareName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{shareName}", url.PathEscape(shareName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *fileSharesOperations) getHandleResponse(resp *azcore.Response) (*FileShareResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getHandleError(resp)
	}
	result := FileShareResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.FileShare)
}

// getHandleError handles the Get error response.
func (client *fileSharesOperations) getHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// List - Lists all shares.
func (client *fileSharesOperations) List(resourceGroupName string, accountName string, fileSharesListOptions *FileSharesListOptions) (FileShareItemsPager, error) {
	req, err := client.listCreateRequest(resourceGroupName, accountName, fileSharesListOptions)
	if err != nil {
		return nil, err
	}
	return &fileShareItemsPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listHandleResponse,
		advancer: func(resp *FileShareItemsResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.FileShareItems.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.FileShareItems.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listCreateRequest creates the List request.
func (client *fileSharesOperations) listCreateRequest(resourceGroupName string, accountName string, fileSharesListOptions *FileSharesListOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	if fileSharesListOptions != nil && fileSharesListOptions.Maxpagesize != nil {
		query.Set("$maxpagesize", *fileSharesListOptions.Maxpagesize)
	}
	if fileSharesListOptions != nil && fileSharesListOptions.Filter != nil {
		query.Set("$filter", *fileSharesListOptions.Filter)
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listHandleResponse handles the List response.
func (client *fileSharesOperations) listHandleResponse(resp *azcore.Response) (*FileShareItemsResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listHandleError(resp)
	}
	result := FileShareItemsResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.FileShareItems)
}

// listHandleError handles the List error response.
func (client *fileSharesOperations) listHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Restore - Restore a file share within a valid retention days if share soft delete is enabled
func (client *fileSharesOperations) Restore(ctx context.Context, resourceGroupName string, accountName string, shareName string, deletedShare DeletedShare) (*http.Response, error) {
	req, err := client.restoreCreateRequest(resourceGroupName, accountName, shareName, deletedShare)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.restoreHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// restoreCreateRequest creates the Restore request.
func (client *fileSharesOperations) restoreCreateRequest(resourceGroupName string, accountName string, shareName string, deletedShare DeletedShare) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares/{shareName}/restore"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{shareName}", url.PathEscape(shareName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(deletedShare)
}

// restoreHandleResponse handles the Restore response.
func (client *fileSharesOperations) restoreHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.restoreHandleError(resp)
	}
	return resp.Response, nil
}

// restoreHandleError handles the Restore error response.
func (client *fileSharesOperations) restoreHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Update - Updates share properties as specified in request body. Properties not mentioned in the request will not be changed. Update fails if the specified share does not already exist.
func (client *fileSharesOperations) Update(ctx context.Context, resourceGroupName string, accountName string, shareName string, fileShare FileShare) (*FileShareResponse, error) {
	req, err := client.updateCreateRequest(resourceGroupName, accountName, shareName, fileShare)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.updateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// updateCreateRequest creates the Update request.
func (client *fileSharesOperations) updateCreateRequest(resourceGroupName string, accountName string, shareName string, fileShare FileShare) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/fileServices/default/shares/{shareName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{shareName}", url.PathEscape(shareName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPatch, *u)
	return req, req.MarshalAsJSON(fileShare)
}

// updateHandleResponse handles the Update response.
func (client *fileSharesOperations) updateHandleResponse(resp *azcore.Response) (*FileShareResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.updateHandleError(resp)
	}
	result := FileShareResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.FileShare)
}

// updateHandleError handles the Update error response.
func (client *fileSharesOperations) updateHandleError(resp *azcore.Response) error {
	var err CloudError
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}
