// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorage

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// StorageAccountsOperations contains the methods for the StorageAccounts group.
type StorageAccountsOperations interface {
	// CheckNameAvailability - Checks that the storage account name is valid and is not already in use.
	CheckNameAvailability(ctx context.Context, accountName StorageAccountCheckNameAvailabilityParameters) (*CheckNameAvailabilityResultResponse, error)
	// BeginCreate - Asynchronously creates a new storage account with the specified parameters. If an account is already created and a subsequent create request is issued with different properties, the account properties will be updated. If an account is already created and a subsequent create or update request is issued with the exact same set of properties, the request will succeed.
	BeginCreate(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountCreateParameters) (*StorageAccountResponse, error)
	// ResumeCreate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreate(token string) (StorageAccountPoller, error)
	// Delete - Deletes a storage account in Microsoft Azure.
	Delete(ctx context.Context, resourceGroupName string, accountName string) (*http.Response, error)
	// BeginFailover - Failover request can be triggered for a storage account in case of availability issues. The failover occurs from the storage account's primary cluster to secondary cluster for RA-GRS accounts. The secondary cluster will become primary after failover.
	BeginFailover(ctx context.Context, resourceGroupName string, accountName string) (*HTTPResponse, error)
	// ResumeFailover - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeFailover(token string) (HTTPPoller, error)
	// GetProperties - Returns the properties for the specified storage account including but not limited to name, SKU name, location, and account status. The ListKeys operation should be used to retrieve storage keys.
	GetProperties(ctx context.Context, resourceGroupName string, accountName string, storageAccountsGetPropertiesOptions *StorageAccountsGetPropertiesOptions) (*StorageAccountResponse, error)
	// List - Lists all the storage accounts available under the subscription. Note that storage keys are not returned; use the ListKeys operation for this.
	List() (StorageAccountListResultPager, error)
	// ListAccountSas - List SAS credentials of a storage account.
	ListAccountSas(ctx context.Context, resourceGroupName string, accountName string, parameters AccountSasParameters) (*ListAccountSasResponseResponse, error)
	// ListByResourceGroup - Lists all the storage accounts available under the given resource group. Note that storage keys are not returned; use the ListKeys operation for this.
	ListByResourceGroup(ctx context.Context, resourceGroupName string) (*StorageAccountListResultResponse, error)
	// ListKeys - Lists the access keys or Kerberos keys (if active directory enabled) for the specified storage account.
	ListKeys(ctx context.Context, resourceGroupName string, accountName string) (*StorageAccountListKeysResultResponse, error)
	// ListServiceSas - List service SAS credentials of a specific resource.
	ListServiceSas(ctx context.Context, resourceGroupName string, accountName string, parameters ServiceSasParameters) (*ListServiceSasResponseResponse, error)
	// RegenerateKey - Regenerates one of the access keys or Kerberos keys for the specified storage account.
	RegenerateKey(ctx context.Context, resourceGroupName string, accountName string, regenerateKey StorageAccountRegenerateKeyParameters) (*StorageAccountListKeysResultResponse, error)
	// BeginRestoreBlobRanges - Restore blobs in the specified blob ranges
	BeginRestoreBlobRanges(ctx context.Context, resourceGroupName string, accountName string, parameters BlobRestoreParameters) (*BlobRestoreStatusResponse, error)
	// ResumeRestoreBlobRanges - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeRestoreBlobRanges(token string) (BlobRestoreStatusPoller, error)
	// RevokeUserDelegationKeys - Revoke user delegation keys.
	RevokeUserDelegationKeys(ctx context.Context, resourceGroupName string, accountName string) (*http.Response, error)
	// Update - The update operation can be used to update the SKU, encryption, access tier, or tags for a storage account. It can also be used to map the account to a custom domain. Only one custom domain is supported per storage account; the replacement/change of custom domain is not supported. In order to replace an old custom domain, the old value must be cleared/unregistered before a new value can be set. The update of multiple properties is supported. This call does not change the storage keys for the account. If you want to change the storage account keys, use the regenerate keys operation. The location and name of the storage account cannot be changed after creation.
	Update(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountUpdateParameters) (*StorageAccountResponse, error)
}

// storageAccountsOperations implements the StorageAccountsOperations interface.
type storageAccountsOperations struct {
	*Client
	subscriptionID string
}

// CheckNameAvailability - Checks that the storage account name is valid and is not already in use.
func (client *storageAccountsOperations) CheckNameAvailability(ctx context.Context, accountName StorageAccountCheckNameAvailabilityParameters) (*CheckNameAvailabilityResultResponse, error) {
	req, err := client.checkNameAvailabilityCreateRequest(accountName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.checkNameAvailabilityHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// checkNameAvailabilityCreateRequest creates the CheckNameAvailability request.
func (client *storageAccountsOperations) checkNameAvailabilityCreateRequest(accountName StorageAccountCheckNameAvailabilityParameters) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/checkNameAvailability"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(accountName)
}

// checkNameAvailabilityHandleResponse handles the CheckNameAvailability response.
func (client *storageAccountsOperations) checkNameAvailabilityHandleResponse(resp *azcore.Response) (*CheckNameAvailabilityResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.checkNameAvailabilityHandleError(resp)
	}
	result := CheckNameAvailabilityResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.CheckNameAvailabilityResult)
}

// checkNameAvailabilityHandleError handles the CheckNameAvailability error response.
func (client *storageAccountsOperations) checkNameAvailabilityHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Create - Asynchronously creates a new storage account with the specified parameters. If an account is already created and a subsequent create request is issued with different properties, the account properties will be updated. If an account is already created and a subsequent create or update request is issued with the exact same set of properties, the request will succeed.
func (client *storageAccountsOperations) BeginCreate(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountCreateParameters) (*StorageAccountResponse, error) {
	req, err := client.createCreateRequest(resourceGroupName, accountName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("storageAccountsOperations.Create", "", resp, client.createHandleError)
	if err != nil {
		return nil, err
	}
	poller := &storageAccountPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*StorageAccountResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *storageAccountsOperations) ResumeCreate(token string) (StorageAccountPoller, error) {
	pt, err := resumePollingTracker("storageAccountsOperations.Create", token, client.createHandleError)
	if err != nil {
		return nil, err
	}
	return &storageAccountPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// createCreateRequest creates the Create request.
func (client *storageAccountsOperations) createCreateRequest(resourceGroupName string, accountName string, parameters StorageAccountCreateParameters) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(parameters)
}

// createHandleResponse handles the Create response.
func (client *storageAccountsOperations) createHandleResponse(resp *azcore.Response) (*StorageAccountResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.createHandleError(resp)
	}
	result := StorageAccountResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccount)
}

// createHandleError handles the Create error response.
func (client *storageAccountsOperations) createHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Delete - Deletes a storage account in Microsoft Azure.
func (client *storageAccountsOperations) Delete(ctx context.Context, resourceGroupName string, accountName string) (*http.Response, error) {
	req, err := client.deleteCreateRequest(resourceGroupName, accountName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// deleteCreateRequest creates the Delete request.
func (client *storageAccountsOperations) deleteCreateRequest(resourceGroupName string, accountName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *storageAccountsOperations) deleteHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	return resp.Response, nil
}

// deleteHandleError handles the Delete error response.
func (client *storageAccountsOperations) deleteHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Failover - Failover request can be triggered for a storage account in case of availability issues. The failover occurs from the storage account's primary cluster to secondary cluster for RA-GRS accounts. The secondary cluster will become primary after failover.
func (client *storageAccountsOperations) BeginFailover(ctx context.Context, resourceGroupName string, accountName string) (*HTTPResponse, error) {
	req, err := client.failoverCreateRequest(resourceGroupName, accountName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.failoverHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("storageAccountsOperations.Failover", "location", resp, client.failoverHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *storageAccountsOperations) ResumeFailover(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("storageAccountsOperations.Failover", token, client.failoverHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// failoverCreateRequest creates the Failover request.
func (client *storageAccountsOperations) failoverCreateRequest(resourceGroupName string, accountName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/failover"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// failoverHandleResponse handles the Failover response.
func (client *storageAccountsOperations) failoverHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.failoverHandleError(resp)
	}
	result := HTTPResponse{RawResponse: resp.Response}
	return &result, nil
}

// failoverHandleError handles the Failover error response.
func (client *storageAccountsOperations) failoverHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetProperties - Returns the properties for the specified storage account including but not limited to name, SKU name, location, and account status. The ListKeys operation should be used to retrieve storage keys.
func (client *storageAccountsOperations) GetProperties(ctx context.Context, resourceGroupName string, accountName string, storageAccountsGetPropertiesOptions *StorageAccountsGetPropertiesOptions) (*StorageAccountResponse, error) {
	req, err := client.getPropertiesCreateRequest(resourceGroupName, accountName, storageAccountsGetPropertiesOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getPropertiesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *storageAccountsOperations) getPropertiesCreateRequest(resourceGroupName string, accountName string, storageAccountsGetPropertiesOptions *StorageAccountsGetPropertiesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	if storageAccountsGetPropertiesOptions != nil && storageAccountsGetPropertiesOptions.Expand != nil {
		query.Set("$expand", string(*storageAccountsGetPropertiesOptions.Expand))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *storageAccountsOperations) getPropertiesHandleResponse(resp *azcore.Response) (*StorageAccountResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getPropertiesHandleError(resp)
	}
	result := StorageAccountResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccount)
}

// getPropertiesHandleError handles the GetProperties error response.
func (client *storageAccountsOperations) getPropertiesHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// List - Lists all the storage accounts available under the subscription. Note that storage keys are not returned; use the ListKeys operation for this.
func (client *storageAccountsOperations) List() (StorageAccountListResultPager, error) {
	req, err := client.listCreateRequest()
	if err != nil {
		return nil, err
	}
	return &storageAccountListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listHandleResponse,
		advancer: func(resp *StorageAccountListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.StorageAccountListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.StorageAccountListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listCreateRequest creates the List request.
func (client *storageAccountsOperations) listCreateRequest() (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/storageAccounts"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listHandleResponse handles the List response.
func (client *storageAccountsOperations) listHandleResponse(resp *azcore.Response) (*StorageAccountListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listHandleError(resp)
	}
	result := StorageAccountListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccountListResult)
}

// listHandleError handles the List error response.
func (client *storageAccountsOperations) listHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// ListAccountSas - List SAS credentials of a storage account.
func (client *storageAccountsOperations) ListAccountSas(ctx context.Context, resourceGroupName string, accountName string, parameters AccountSasParameters) (*ListAccountSasResponseResponse, error) {
	req, err := client.listAccountSasCreateRequest(resourceGroupName, accountName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.listAccountSasHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// listAccountSasCreateRequest creates the ListAccountSas request.
func (client *storageAccountsOperations) listAccountSasCreateRequest(resourceGroupName string, accountName string, parameters AccountSasParameters) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/ListAccountSas"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(parameters)
}

// listAccountSasHandleResponse handles the ListAccountSas response.
func (client *storageAccountsOperations) listAccountSasHandleResponse(resp *azcore.Response) (*ListAccountSasResponseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listAccountSasHandleError(resp)
	}
	result := ListAccountSasResponseResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ListAccountSasResponse)
}

// listAccountSasHandleError handles the ListAccountSas error response.
func (client *storageAccountsOperations) listAccountSasHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// ListByResourceGroup - Lists all the storage accounts available under the given resource group. Note that storage keys are not returned; use the ListKeys operation for this.
func (client *storageAccountsOperations) ListByResourceGroup(ctx context.Context, resourceGroupName string) (*StorageAccountListResultResponse, error) {
	req, err := client.listByResourceGroupCreateRequest(resourceGroupName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *storageAccountsOperations) listByResourceGroupCreateRequest(resourceGroupName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *storageAccountsOperations) listByResourceGroupHandleResponse(resp *azcore.Response) (*StorageAccountListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listByResourceGroupHandleError(resp)
	}
	result := StorageAccountListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccountListResult)
}

// listByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *storageAccountsOperations) listByResourceGroupHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// ListKeys - Lists the access keys or Kerberos keys (if active directory enabled) for the specified storage account.
func (client *storageAccountsOperations) ListKeys(ctx context.Context, resourceGroupName string, accountName string) (*StorageAccountListKeysResultResponse, error) {
	req, err := client.listKeysCreateRequest(resourceGroupName, accountName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.listKeysHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// listKeysCreateRequest creates the ListKeys request.
func (client *storageAccountsOperations) listKeysCreateRequest(resourceGroupName string, accountName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/listKeys"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// listKeysHandleResponse handles the ListKeys response.
func (client *storageAccountsOperations) listKeysHandleResponse(resp *azcore.Response) (*StorageAccountListKeysResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listKeysHandleError(resp)
	}
	result := StorageAccountListKeysResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccountListKeysResult)
}

// listKeysHandleError handles the ListKeys error response.
func (client *storageAccountsOperations) listKeysHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// ListServiceSas - List service SAS credentials of a specific resource.
func (client *storageAccountsOperations) ListServiceSas(ctx context.Context, resourceGroupName string, accountName string, parameters ServiceSasParameters) (*ListServiceSasResponseResponse, error) {
	req, err := client.listServiceSasCreateRequest(resourceGroupName, accountName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.listServiceSasHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// listServiceSasCreateRequest creates the ListServiceSas request.
func (client *storageAccountsOperations) listServiceSasCreateRequest(resourceGroupName string, accountName string, parameters ServiceSasParameters) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/ListServiceSas"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(parameters)
}

// listServiceSasHandleResponse handles the ListServiceSas response.
func (client *storageAccountsOperations) listServiceSasHandleResponse(resp *azcore.Response) (*ListServiceSasResponseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listServiceSasHandleError(resp)
	}
	result := ListServiceSasResponseResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ListServiceSasResponse)
}

// listServiceSasHandleError handles the ListServiceSas error response.
func (client *storageAccountsOperations) listServiceSasHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// RegenerateKey - Regenerates one of the access keys or Kerberos keys for the specified storage account.
func (client *storageAccountsOperations) RegenerateKey(ctx context.Context, resourceGroupName string, accountName string, regenerateKey StorageAccountRegenerateKeyParameters) (*StorageAccountListKeysResultResponse, error) {
	req, err := client.regenerateKeyCreateRequest(resourceGroupName, accountName, regenerateKey)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.regenerateKeyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// regenerateKeyCreateRequest creates the RegenerateKey request.
func (client *storageAccountsOperations) regenerateKeyCreateRequest(resourceGroupName string, accountName string, regenerateKey StorageAccountRegenerateKeyParameters) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/regenerateKey"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(regenerateKey)
}

// regenerateKeyHandleResponse handles the RegenerateKey response.
func (client *storageAccountsOperations) regenerateKeyHandleResponse(resp *azcore.Response) (*StorageAccountListKeysResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.regenerateKeyHandleError(resp)
	}
	result := StorageAccountListKeysResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccountListKeysResult)
}

// regenerateKeyHandleError handles the RegenerateKey error response.
func (client *storageAccountsOperations) regenerateKeyHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// RestoreBlobRanges - Restore blobs in the specified blob ranges
func (client *storageAccountsOperations) BeginRestoreBlobRanges(ctx context.Context, resourceGroupName string, accountName string, parameters BlobRestoreParameters) (*BlobRestoreStatusResponse, error) {
	req, err := client.restoreBlobRangesCreateRequest(resourceGroupName, accountName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.restoreBlobRangesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("storageAccountsOperations.RestoreBlobRanges", "location", resp, client.restoreBlobRangesHandleError)
	if err != nil {
		return nil, err
	}
	poller := &blobRestoreStatusPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*BlobRestoreStatusResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *storageAccountsOperations) ResumeRestoreBlobRanges(token string) (BlobRestoreStatusPoller, error) {
	pt, err := resumePollingTracker("storageAccountsOperations.RestoreBlobRanges", token, client.restoreBlobRangesHandleError)
	if err != nil {
		return nil, err
	}
	return &blobRestoreStatusPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// restoreBlobRangesCreateRequest creates the RestoreBlobRanges request.
func (client *storageAccountsOperations) restoreBlobRangesCreateRequest(resourceGroupName string, accountName string, parameters BlobRestoreParameters) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/restoreBlobRanges"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(parameters)
}

// restoreBlobRangesHandleResponse handles the RestoreBlobRanges response.
func (client *storageAccountsOperations) restoreBlobRangesHandleResponse(resp *azcore.Response) (*BlobRestoreStatusResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.restoreBlobRangesHandleError(resp)
	}
	result := BlobRestoreStatusResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.BlobRestoreStatus)
}

// restoreBlobRangesHandleError handles the RestoreBlobRanges error response.
func (client *storageAccountsOperations) restoreBlobRangesHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// RevokeUserDelegationKeys - Revoke user delegation keys.
func (client *storageAccountsOperations) RevokeUserDelegationKeys(ctx context.Context, resourceGroupName string, accountName string) (*http.Response, error) {
	req, err := client.revokeUserDelegationKeysCreateRequest(resourceGroupName, accountName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.revokeUserDelegationKeysHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// revokeUserDelegationKeysCreateRequest creates the RevokeUserDelegationKeys request.
func (client *storageAccountsOperations) revokeUserDelegationKeysCreateRequest(resourceGroupName string, accountName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/revokeUserDelegationKeys"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// revokeUserDelegationKeysHandleResponse handles the RevokeUserDelegationKeys response.
func (client *storageAccountsOperations) revokeUserDelegationKeysHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.revokeUserDelegationKeysHandleError(resp)
	}
	return resp.Response, nil
}

// revokeUserDelegationKeysHandleError handles the RevokeUserDelegationKeys error response.
func (client *storageAccountsOperations) revokeUserDelegationKeysHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Update - The update operation can be used to update the SKU, encryption, access tier, or tags for a storage account. It can also be used to map the account to a custom domain. Only one custom domain is supported per storage account; the replacement/change of custom domain is not supported. In order to replace an old custom domain, the old value must be cleared/unregistered before a new value can be set. The update of multiple properties is supported. This call does not change the storage keys for the account. If you want to change the storage account keys, use the regenerate keys operation. The location and name of the storage account cannot be changed after creation.
func (client *storageAccountsOperations) Update(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountUpdateParameters) (*StorageAccountResponse, error) {
	req, err := client.updateCreateRequest(resourceGroupName, accountName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.updateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// updateCreateRequest creates the Update request.
func (client *storageAccountsOperations) updateCreateRequest(resourceGroupName string, accountName string, parameters StorageAccountUpdateParameters) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPatch, *u)
	return req, req.MarshalAsJSON(parameters)
}

// updateHandleResponse handles the Update response.
func (client *storageAccountsOperations) updateHandleResponse(resp *azcore.Response) (*StorageAccountResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.updateHandleError(resp)
	}
	result := StorageAccountResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccount)
}

// updateHandleError handles the Update error response.
func (client *storageAccountsOperations) updateHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}
