// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorage

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

// The parameters to list SAS credentials of a storage account.
type AccountSasParameters struct {
	// An IP address or a range of IP addresses from which to accept requests.
	IPAddressOrRange *string `json:"signedIp,omitempty"`

	// The key to sign the account SAS token with.
	KeyToSign *string `json:"keyToSign,omitempty"`

	// The signed permissions for the account SAS. Possible values include: Read (r), Write (w), Delete (d), List (l), Add (a), Create (c), Update (u) and Process
	// (p).
	Permissions *Permissions `json:"signedPermission,omitempty"`

	// The protocol permitted for a request made with the account SAS.
	Protocols *HTTPProtocol `json:"signedProtocol,omitempty"`

	// The signed resource types that are accessible with the account SAS. Service (s): Access to service-level APIs; Container (c): Access to container-level
	// APIs; Object (o): Access to object-level APIs
	// for blobs, queue messages, table entities, and files.
	ResourceTypes *SignedResourceTypes `json:"signedResourceTypes,omitempty"`

	// The signed services accessible with the account SAS. Possible values include: Blob (b), Queue (q), Table (t), File (f).
	Services *Services `json:"signedServices,omitempty"`

	// The time at which the shared access signature becomes invalid.
	SharedAccessExpiryTime *time.Time `json:"signedExpiry,omitempty"`

	// The time at which the SAS becomes valid.
	SharedAccessStartTime *time.Time `json:"signedStart,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountSasParameters.
func (a AccountSasParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.IPAddressOrRange != nil {
		objectMap["signedIp"] = a.IPAddressOrRange
	}
	if a.KeyToSign != nil {
		objectMap["keyToSign"] = a.KeyToSign
	}
	if a.Permissions != nil {
		objectMap["signedPermission"] = a.Permissions
	}
	if a.Protocols != nil {
		objectMap["signedProtocol"] = a.Protocols
	}
	if a.ResourceTypes != nil {
		objectMap["signedResourceTypes"] = a.ResourceTypes
	}
	if a.Services != nil {
		objectMap["signedServices"] = a.Services
	}
	if a.SharedAccessExpiryTime != nil {
		objectMap["signedExpiry"] = (*timeRFC3339)(a.SharedAccessExpiryTime)
	}
	if a.SharedAccessStartTime != nil {
		objectMap["signedStart"] = (*timeRFC3339)(a.SharedAccessStartTime)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountSasParameters.
func (a *AccountSasParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "signedIp":
			if val != nil {
				err = json.Unmarshal(*val, &a.IPAddressOrRange)
			}
			delete(rawMsg, key)
		case "keyToSign":
			if val != nil {
				err = json.Unmarshal(*val, &a.KeyToSign)
			}
			delete(rawMsg, key)
		case "signedPermission":
			if val != nil {
				err = json.Unmarshal(*val, &a.Permissions)
			}
			delete(rawMsg, key)
		case "signedProtocol":
			if val != nil {
				err = json.Unmarshal(*val, &a.Protocols)
			}
			delete(rawMsg, key)
		case "signedResourceTypes":
			if val != nil {
				err = json.Unmarshal(*val, &a.ResourceTypes)
			}
			delete(rawMsg, key)
		case "signedServices":
			if val != nil {
				err = json.Unmarshal(*val, &a.Services)
			}
			delete(rawMsg, key)
		case "signedExpiry":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				a.SharedAccessExpiryTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "signedStart":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				a.SharedAccessStartTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Settings properties for Active Directory (AD).
type ActiveDirectoryProperties struct {
	// Specifies the security identifier (SID) for Azure Storage.
	AzureStorageSid *string `json:"azureStorageSid,omitempty"`

	// Specifies the domain GUID.
	DomainGUID *string `json:"domainGuid,omitempty"`

	// Specifies the primary domain that the AD DNS server is authoritative for.
	DomainName *string `json:"domainName,omitempty"`

	// Specifies the security identifier (SID).
	DomainSid *string `json:"domainSid,omitempty"`

	// Specifies the Active Directory forest to get.
	ForestName *string `json:"forestName,omitempty"`

	// Specifies the NetBIOS domain name.
	NetBiosDomainName *string `json:"netBiosDomainName,omitempty"`
}

// The resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	Resource
	// READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty" azure:"ro"`
}

// Settings for Azure Files identity based authentication.
type AzureFilesIDentityBasedAuthentication struct {
	// Required if choose AD.
	ActiveDirectoryProperties *ActiveDirectoryProperties `json:"activeDirectoryProperties,omitempty"`

	// Indicates the directory service used.
	DirectoryServiceOptions *DirectoryServiceOptions `json:"directoryServiceOptions,omitempty"`
}

// Properties of the blob container, including Id, resource name, resource type, Etag.
type BlobContainer struct {
	AzureEntityResource
	// Properties of the blob container.
	ContainerProperties *ContainerProperties `json:"properties,omitempty"`
}

// BlobContainerResponse is the response envelope for operations that return a BlobContainer type.
type BlobContainerResponse struct {
	// Properties of the blob container, including Id, resource name, resource type, Etag.
	BlobContainer *BlobContainer

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BlobContainersClearLegalHoldOptions contains the optional parameters for the BlobContainers.ClearLegalHold method.
type BlobContainersClearLegalHoldOptions struct {
	// placeholder for future optional parameters
}

// BlobContainersCreateOptions contains the optional parameters for the BlobContainers.Create method.
type BlobContainersCreateOptions struct {
	// placeholder for future optional parameters
}

// BlobContainersCreateOrUpdateImmutabilityPolicyOptions contains the optional parameters for the BlobContainers.CreateOrUpdateImmutabilityPolicy method.
type BlobContainersCreateOrUpdateImmutabilityPolicyOptions struct {
	// The entity state (ETag) version of the immutability policy to update. A value of "*" can be used to apply the operation only if the immutability policy
	// already exists. If omitted, this operation will always be applied.
	IfMatch *string
	// The ImmutabilityPolicy Properties that will be created or updated to a blob container.
	Parameters *ImmutabilityPolicy
}

// BlobContainersDeleteImmutabilityPolicyOptions contains the optional parameters for the BlobContainers.DeleteImmutabilityPolicy method.
type BlobContainersDeleteImmutabilityPolicyOptions struct {
	// placeholder for future optional parameters
}

// BlobContainersDeleteOptions contains the optional parameters for the BlobContainers.Delete method.
type BlobContainersDeleteOptions struct {
	// placeholder for future optional parameters
}

// BlobContainersExtendImmutabilityPolicyOptions contains the optional parameters for the BlobContainers.ExtendImmutabilityPolicy method.
type BlobContainersExtendImmutabilityPolicyOptions struct {
	// The ImmutabilityPolicy Properties that will be extended for a blob container.
	Parameters *ImmutabilityPolicy
}

// BlobContainersGetImmutabilityPolicyOptions contains the optional parameters for the BlobContainers.GetImmutabilityPolicy method.
type BlobContainersGetImmutabilityPolicyOptions struct {
	// The entity state (ETag) version of the immutability policy to update. A value of "*" can be used to apply the operation only if the immutability policy
	// already exists. If omitted, this operation will always be applied.
	IfMatch *string
}

// BlobContainersGetOptions contains the optional parameters for the BlobContainers.Get method.
type BlobContainersGetOptions struct {
	// placeholder for future optional parameters
}

// BlobContainersLeaseOptions contains the optional parameters for the BlobContainers.Lease method.
type BlobContainersLeaseOptions struct {
	// Lease Container request body.
	Parameters *LeaseContainerRequest
}

// BlobContainersListOptions contains the optional parameters for the BlobContainers.List method.
type BlobContainersListOptions struct {
	// Optional. When specified, only container names starting with the filter will be listed.
	Filter *string
	// Optional, used to include the properties for soft deleted blob containers.
	Include *ListContainersInclude
	// Optional. Specified maximum number of containers that can be included in the list.
	Maxpagesize *string
}

// BlobContainersLockImmutabilityPolicyOptions contains the optional parameters for the BlobContainers.LockImmutabilityPolicy method.
type BlobContainersLockImmutabilityPolicyOptions struct {
	// placeholder for future optional parameters
}

// BlobContainersSetLegalHoldOptions contains the optional parameters for the BlobContainers.SetLegalHold method.
type BlobContainersSetLegalHoldOptions struct {
	// placeholder for future optional parameters
}

// BlobContainersUpdateOptions contains the optional parameters for the BlobContainers.Update method.
type BlobContainersUpdateOptions struct {
	// placeholder for future optional parameters
}

// Blob restore parameters
type BlobRestoreParameters struct {
	// Blob ranges to restore.
	BlobRanges *[]BlobRestoreRange `json:"blobRanges,omitempty"`

	// Restore blob to the specified time.
	TimeToRestore *time.Time `json:"timeToRestore,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BlobRestoreParameters.
func (b BlobRestoreParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if b.BlobRanges != nil {
		objectMap["blobRanges"] = b.BlobRanges
	}
	if b.TimeToRestore != nil {
		objectMap["timeToRestore"] = (*timeRFC3339)(b.TimeToRestore)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobRestoreParameters.
func (b *BlobRestoreParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobRanges":
			if val != nil {
				err = json.Unmarshal(*val, &b.BlobRanges)
			}
			delete(rawMsg, key)
		case "timeToRestore":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				b.TimeToRestore = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Blob range
type BlobRestoreRange struct {
	// Blob end range. This is exclusive. Empty means account end.
	EndRange *string `json:"endRange,omitempty"`

	// Blob start range. This is inclusive. Empty means account start.
	StartRange *string `json:"startRange,omitempty"`
}

// Blob restore status.
type BlobRestoreStatus struct {
	// READ-ONLY; Failure reason when blob restore is failed.
	FailureReason *string `json:"failureReason,omitempty" azure:"ro"`

	// READ-ONLY; Blob restore request parameters.
	Parameters *BlobRestoreParameters `json:"parameters,omitempty" azure:"ro"`

	// READ-ONLY; Id for tracking blob restore request.
	RestoreID *string `json:"restoreId,omitempty" azure:"ro"`

	// READ-ONLY; The status of blob restore progress. Possible values are: - InProgress: Indicates that blob restore is ongoing. - Complete: Indicates that
	// blob restore has been completed successfully. - Failed:
	// Indicates that blob restore is failed.
	Status *BlobRestoreProgressStatus `json:"status,omitempty" azure:"ro"`
}

// BlobRestoreStatusPollerResponse is the response envelope for operations that asynchronously return a BlobRestoreStatus type.
type BlobRestoreStatusPollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (BlobRestoreStatusResponse, error)

	// Poller contains an initialized poller.
	Poller BlobRestoreStatusPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BlobRestoreStatusResponse is the response envelope for operations that return a BlobRestoreStatus type.
type BlobRestoreStatusResponse struct {
	// Blob restore status.
	BlobRestoreStatus *BlobRestoreStatus

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type BlobServiceItems struct {
	// READ-ONLY; List of blob services returned.
	Value *[]BlobServiceProperties `json:"value,omitempty" azure:"ro"`
}

// BlobServiceItemsResponse is the response envelope for operations that return a BlobServiceItems type.
type BlobServiceItemsResponse struct {
	BlobServiceItems *BlobServiceItems

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The properties of a storage account’s Blob service.
type BlobServiceProperties struct {
	Resource
	// The properties of a storage account’s Blob service.
	BlobServiceProperties *BlobServicePropertiesAutoGenerated `json:"properties,omitempty"`

	// READ-ONLY; Sku name and tier.
	SKU *SKU `json:"sku,omitempty" azure:"ro"`
}

// The properties of a storage account’s Blob service.
type BlobServicePropertiesAutoGenerated struct {
	// Deprecated in favor of isVersioningEnabled property.
	AutomaticSnapshotPolicyEnabled *bool `json:"automaticSnapshotPolicyEnabled,omitempty"`

	// The blob service properties for change feed events.
	ChangeFeed *ChangeFeed `json:"changeFeed,omitempty"`

	// The blob service properties for container soft delete.
	ContainerDeleteRetentionPolicy *DeleteRetentionPolicy `json:"containerDeleteRetentionPolicy,omitempty"`

	// Specifies CORS rules for the Blob service. You can include up to five CorsRule elements in the request. If no CorsRule elements are included in the request
	// body, all CORS rules will be deleted, and
	// CORS will be disabled for the Blob service.
	Cors *CorsRules `json:"cors,omitempty"`

	// DefaultServiceVersion indicates the default version to use for requests to the Blob service if an incoming request’s version is not specified. Possible
	// values include version 2008-10-27 and all more
	// recent versions.
	DefaultServiceVersion *string `json:"defaultServiceVersion,omitempty"`

	// The blob service properties for blob soft delete.
	DeleteRetentionPolicy *DeleteRetentionPolicy `json:"deleteRetentionPolicy,omitempty"`

	// Versioning is enabled if set to true.
	IsVersioningEnabled *bool `json:"isVersioningEnabled,omitempty"`

	// The blob service properties for blob restore policy.
	RestorePolicy *RestorePolicyProperties `json:"restorePolicy,omitempty"`
}

// BlobServicePropertiesResponse is the response envelope for operations that return a BlobServiceProperties type.
type BlobServicePropertiesResponse struct {
	// The properties of a storage account’s Blob service.
	BlobServiceProperties *BlobServiceProperties

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BlobServicesGetServicePropertiesOptions contains the optional parameters for the BlobServices.GetServiceProperties method.
type BlobServicesGetServicePropertiesOptions struct {
	// placeholder for future optional parameters
}

// BlobServicesListOptions contains the optional parameters for the BlobServices.List method.
type BlobServicesListOptions struct {
	// placeholder for future optional parameters
}

// BlobServicesSetServicePropertiesOptions contains the optional parameters for the BlobServices.SetServiceProperties method.
type BlobServicesSetServicePropertiesOptions struct {
	// placeholder for future optional parameters
}

// The blob service properties for change feed events.
type ChangeFeed struct {
	// Indicates whether change feed event logging is enabled for the Blob service.
	Enabled *bool `json:"enabled,omitempty"`
}

// The CheckNameAvailability operation response.
type CheckNameAvailabilityResult struct {
	// READ-ONLY; Gets an error message explaining the Reason value in more detail.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Gets a boolean value that indicates whether the name is available for you to use. If true, the name is available. If false, the name has already
	// been taken or is invalid and cannot be used.
	NameAvailable *bool `json:"nameAvailable,omitempty" azure:"ro"`

	// READ-ONLY; Gets the reason that a storage account name could not be used. The Reason element is only returned if NameAvailable is false.
	Reason *Reason `json:"reason,omitempty" azure:"ro"`
}

// CheckNameAvailabilityResultResponse is the response envelope for operations that return a CheckNameAvailabilityResult type.
type CheckNameAvailabilityResultResponse struct {
	// The CheckNameAvailability operation response.
	CheckNameAvailabilityResult *CheckNameAvailabilityResult

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// An error response from the Storage service.
type CloudError struct {
	// An error response from the Storage service.
	InnerError *CloudErrorBody `json:"error,omitempty"`
}

// Error implements the error interface for type CloudError.
func (e CloudError) Error() string {
	msg := ""
	if e.InnerError != nil {
		msg += "InnerError: \n"
		if e.InnerError.Code != nil {
			msg += fmt.Sprintf("\tCode: %v\n", *e.InnerError.Code)
		}
		if e.InnerError.Message != nil {
			msg += fmt.Sprintf("\tMessage: %v\n", *e.InnerError.Message)
		}
		if e.InnerError.Target != nil {
			msg += fmt.Sprintf("\tTarget: %v\n", *e.InnerError.Target)
		}
		if e.InnerError.Details != nil {
			msg += fmt.Sprintf("\tDetails: %v\n", *e.InnerError.Details)
		}
	}
	if msg == "" {
		msg = "missing error info"
	}
	return msg
}

// An error response from the Storage service.
type CloudErrorBody struct {
	// An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// A list of additional details about the error.
	Details *[]CloudErrorBody `json:"details,omitempty"`

	// A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`

	// The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
}

// The properties of a container.
type ContainerProperties struct {
	// Default the container to use specified encryption scope for all writes.
	DefaultEncryptionScope *string `json:"defaultEncryptionScope,omitempty"`

	// READ-ONLY; Indicates whether the blob container was deleted.
	Deleted *bool `json:"deleted,omitempty" azure:"ro"`

	// READ-ONLY; Blob container deletion time.
	DeletedTime *time.Time `json:"deletedTime,omitempty" azure:"ro"`

	// Block override of encryption scope from the container default.
	DenyEncryptionScopeOverride *bool `json:"denyEncryptionScopeOverride,omitempty"`

	// READ-ONLY; The hasImmutabilityPolicy public property is set to true by SRP if ImmutabilityPolicy has been created for this container. The hasImmutabilityPolicy
	// public property is set to false by SRP if
	// ImmutabilityPolicy has not been created for this container.
	HasImmutabilityPolicy *bool `json:"hasImmutabilityPolicy,omitempty" azure:"ro"`

	// READ-ONLY; The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to
	// false by SRP if all existing legal hold tags are cleared out.
	// There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account.
	HasLegalHold *bool `json:"hasLegalHold,omitempty" azure:"ro"`

	// READ-ONLY; The ImmutabilityPolicy property of the container.
	ImmutabilityPolicy *ImmutabilityPolicyProperties `json:"immutabilityPolicy,omitempty" azure:"ro"`

	// READ-ONLY; Returns the date and time the container was last modified.
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; Specifies whether the lease on a container is of infinite or fixed duration, only when the container is leased.
	LeaseDuration *LeaseDuration `json:"leaseDuration,omitempty" azure:"ro"`

	// READ-ONLY; Lease state of the container.
	LeaseState *LeaseState `json:"leaseState,omitempty" azure:"ro"`

	// READ-ONLY; The lease status of the container.
	LeaseStatus *LeaseStatus `json:"leaseStatus,omitempty" azure:"ro"`

	// READ-ONLY; The LegalHold property of the container.
	LegalHold *LegalHoldProperties `json:"legalHold,omitempty" azure:"ro"`

	// A name-value pair to associate with the container as metadata.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// Specifies whether data in the container may be accessed publicly and the level of access.
	PublicAccess *PublicAccess `json:"publicAccess,omitempty"`

	// READ-ONLY; Remaining retention days for soft deleted blob container.
	RemainingRetentionDays *int32 `json:"remainingRetentionDays,omitempty" azure:"ro"`

	// READ-ONLY; The version of the deleted blob container.
	Version *string `json:"version,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ContainerProperties.
func (c ContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if c.DefaultEncryptionScope != nil {
		objectMap["defaultEncryptionScope"] = c.DefaultEncryptionScope
	}
	if c.Deleted != nil {
		objectMap["deleted"] = c.Deleted
	}
	if c.DeletedTime != nil {
		objectMap["deletedTime"] = (*timeRFC3339)(c.DeletedTime)
	}
	if c.DenyEncryptionScopeOverride != nil {
		objectMap["denyEncryptionScopeOverride"] = c.DenyEncryptionScopeOverride
	}
	if c.HasImmutabilityPolicy != nil {
		objectMap["hasImmutabilityPolicy"] = c.HasImmutabilityPolicy
	}
	if c.HasLegalHold != nil {
		objectMap["hasLegalHold"] = c.HasLegalHold
	}
	if c.ImmutabilityPolicy != nil {
		objectMap["immutabilityPolicy"] = c.ImmutabilityPolicy
	}
	if c.LastModifiedTime != nil {
		objectMap["lastModifiedTime"] = (*timeRFC3339)(c.LastModifiedTime)
	}
	if c.LeaseDuration != nil {
		objectMap["leaseDuration"] = c.LeaseDuration
	}
	if c.LeaseState != nil {
		objectMap["leaseState"] = c.LeaseState
	}
	if c.LeaseStatus != nil {
		objectMap["leaseStatus"] = c.LeaseStatus
	}
	if c.LegalHold != nil {
		objectMap["legalHold"] = c.LegalHold
	}
	if c.Metadata != nil {
		objectMap["metadata"] = c.Metadata
	}
	if c.PublicAccess != nil {
		objectMap["publicAccess"] = c.PublicAccess
	}
	if c.RemainingRetentionDays != nil {
		objectMap["remainingRetentionDays"] = c.RemainingRetentionDays
	}
	if c.Version != nil {
		objectMap["version"] = c.Version
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerProperties.
func (c *ContainerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "defaultEncryptionScope":
			if val != nil {
				err = json.Unmarshal(*val, &c.DefaultEncryptionScope)
			}
			delete(rawMsg, key)
		case "deleted":
			if val != nil {
				err = json.Unmarshal(*val, &c.Deleted)
			}
			delete(rawMsg, key)
		case "deletedTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				c.DeletedTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "denyEncryptionScopeOverride":
			if val != nil {
				err = json.Unmarshal(*val, &c.DenyEncryptionScopeOverride)
			}
			delete(rawMsg, key)
		case "hasImmutabilityPolicy":
			if val != nil {
				err = json.Unmarshal(*val, &c.HasImmutabilityPolicy)
			}
			delete(rawMsg, key)
		case "hasLegalHold":
			if val != nil {
				err = json.Unmarshal(*val, &c.HasLegalHold)
			}
			delete(rawMsg, key)
		case "immutabilityPolicy":
			if val != nil {
				err = json.Unmarshal(*val, &c.ImmutabilityPolicy)
			}
			delete(rawMsg, key)
		case "lastModifiedTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				c.LastModifiedTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "leaseDuration":
			if val != nil {
				err = json.Unmarshal(*val, &c.LeaseDuration)
			}
			delete(rawMsg, key)
		case "leaseState":
			if val != nil {
				err = json.Unmarshal(*val, &c.LeaseState)
			}
			delete(rawMsg, key)
		case "leaseStatus":
			if val != nil {
				err = json.Unmarshal(*val, &c.LeaseStatus)
			}
			delete(rawMsg, key)
		case "legalHold":
			if val != nil {
				err = json.Unmarshal(*val, &c.LegalHold)
			}
			delete(rawMsg, key)
		case "metadata":
			if val != nil {
				err = json.Unmarshal(*val, &c.Metadata)
			}
			delete(rawMsg, key)
		case "publicAccess":
			if val != nil {
				err = json.Unmarshal(*val, &c.PublicAccess)
			}
			delete(rawMsg, key)
		case "remainingRetentionDays":
			if val != nil {
				err = json.Unmarshal(*val, &c.RemainingRetentionDays)
			}
			delete(rawMsg, key)
		case "version":
			if val != nil {
				err = json.Unmarshal(*val, &c.Version)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Specifies a CORS rule for the Blob service.
type CorsRule struct {
	// Required if CorsRule element is present. A list of headers allowed to be part of the cross-origin request.
	AllowedHeaders *[]string `json:"allowedHeaders,omitempty"`

	// Required if CorsRule element is present. A list of HTTP methods that are allowed to be executed by the origin.
	AllowedMethods *[]CorsRuleAllowedMethodsItem `json:"allowedMethods,omitempty"`

	// Required if CorsRule element is present. A list of origin domains that will be allowed via CORS, or "*" to allow all domains
	AllowedOrigins *[]string `json:"allowedOrigins,omitempty"`

	// Required if CorsRule element is present. A list of response headers to expose to CORS clients.
	ExposedHeaders *[]string `json:"exposedHeaders,omitempty"`

	// Required if CorsRule element is present. The number of seconds that the client/browser should cache a preflight response.
	MaxAgeInSeconds *int32 `json:"maxAgeInSeconds,omitempty"`
}

// Sets the CORS rules. You can include up to five CorsRule elements in the request.
type CorsRules struct {
	// The List of CORS rules. You can include up to five CorsRule elements in the request.
	CorsRules *[]CorsRule `json:"corsRules,omitempty"`
}

// The custom domain assigned to this storage account. This can be set via Update.
type CustomDomain struct {
	// Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source.
	Name *string `json:"name,omitempty"`

	// Indicates whether indirect CName validation is enabled. Default value is false. This should only be set on updates.
	UseSubDomainName *bool `json:"useSubDomainName,omitempty"`
}

// Object to define the number of days after creation.
type DateAfterCreation struct {
	// Value indicating the age in days after creation
	DaysAfterCreationGreaterThan *float32 `json:"daysAfterCreationGreaterThan,omitempty"`
}

// Object to define the number of days after last modification.
type DateAfterModification struct {
	// Value indicating the age in days after last modification
	DaysAfterModificationGreaterThan *float32 `json:"daysAfterModificationGreaterThan,omitempty"`
}

// The service properties for soft delete.
type DeleteRetentionPolicy struct {
	// Indicates the number of days that the deleted item should be retained. The minimum specified value can be 1 and the maximum value can be 365.
	Days *int32 `json:"days,omitempty"`

	// Indicates whether DeleteRetentionPolicy is enabled.
	Enabled *bool `json:"enabled,omitempty"`
}

// The deleted share to be restored.
type DeletedShare struct {
	// Required. Identify the name of the deleted share that will be restored.
	DeletedShareName *string `json:"deletedShareName,omitempty"`

	// Required. Identify the version of the deleted share that will be restored.
	DeletedShareVersion *string `json:"deletedShareVersion,omitempty"`
}

// Dimension of blobs, possibly be blob type or access tier.
type Dimension struct {
	// Display name of dimension.
	DisplayName *string `json:"displayName,omitempty"`

	// Display name of dimension.
	Name *string `json:"name,omitempty"`
}

// The encryption settings on the storage account.
type Encryption struct {
	// The encryption keySource (provider). Possible values (case-insensitive): Microsoft.Storage, Microsoft.Keyvault
	KeySource *KeySource `json:"keySource,omitempty"`

	// Properties provided by key vault.
	KeyVaultProperties *KeyVaultProperties `json:"keyvaultproperties,omitempty"`

	// A boolean indicating whether or not the service applies a secondary layer of encryption with platform managed keys for data at rest.
	RequireInfrastructureEncryption *bool `json:"requireInfrastructureEncryption,omitempty"`

	// List of services which support encryption.
	Services *EncryptionServices `json:"services,omitempty"`
}

// The Encryption Scope resource.
type EncryptionScope struct {
	Resource
	// Properties of the encryption scope.
	EncryptionScopeProperties *EncryptionScopeProperties `json:"properties,omitempty"`
}

// The key vault properties for the encryption scope. This is a required field if encryption scope 'source' attribute is set to 'Microsoft.KeyVault'.
type EncryptionScopeKeyVaultProperties struct {
	// The object identifier for a key vault key object. When applied, the encryption scope will use the key referenced by the identifier to enable customer-managed
	// key support on this encryption scope.
	KeyURI *string `json:"keyUri,omitempty"`
}

// List of encryption scopes requested, and if paging is required, a URL to the next page of encryption scopes.
type EncryptionScopeListResult struct {
	// READ-ONLY; Request URL that can be used to query next page of encryption scopes. Returned when total number of requested encryption scopes exceeds the
	// maximum page size.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of encryption scopes requested.
	Value *[]EncryptionScope `json:"value,omitempty" azure:"ro"`
}

// EncryptionScopeListResultResponse is the response envelope for operations that return a EncryptionScopeListResult type.
type EncryptionScopeListResultResponse struct {
	// List of encryption scopes requested, and if paging is required, a URL to the next page of encryption scopes.
	EncryptionScopeListResult *EncryptionScopeListResult

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Properties of the encryption scope.
type EncryptionScopeProperties struct {
	// READ-ONLY; Gets the creation date and time of the encryption scope in UTC.
	CreationTime *time.Time `json:"creationTime,omitempty" azure:"ro"`

	// The key vault properties for the encryption scope. This is a required field if encryption scope 'source' attribute is set to 'Microsoft.KeyVault'.
	KeyVaultProperties *EncryptionScopeKeyVaultProperties `json:"keyVaultProperties,omitempty"`

	// READ-ONLY; Gets the last modification date and time of the encryption scope in UTC.
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// The provider for the encryption scope. Possible values (case-insensitive): Microsoft.Storage, Microsoft.KeyVault.
	Source *EncryptionScopeSource `json:"source,omitempty"`

	// The state of the encryption scope. Possible values (case-insensitive): Enabled, Disabled.
	State *EncryptionScopeState `json:"state,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionScopeProperties.
func (e EncryptionScopeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if e.CreationTime != nil {
		objectMap["creationTime"] = (*timeRFC3339)(e.CreationTime)
	}
	if e.KeyVaultProperties != nil {
		objectMap["keyVaultProperties"] = e.KeyVaultProperties
	}
	if e.LastModifiedTime != nil {
		objectMap["lastModifiedTime"] = (*timeRFC3339)(e.LastModifiedTime)
	}
	if e.Source != nil {
		objectMap["source"] = e.Source
	}
	if e.State != nil {
		objectMap["state"] = e.State
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionScopeProperties.
func (e *EncryptionScopeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				e.CreationTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "keyVaultProperties":
			if val != nil {
				err = json.Unmarshal(*val, &e.KeyVaultProperties)
			}
			delete(rawMsg, key)
		case "lastModifiedTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				e.LastModifiedTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "source":
			if val != nil {
				err = json.Unmarshal(*val, &e.Source)
			}
			delete(rawMsg, key)
		case "state":
			if val != nil {
				err = json.Unmarshal(*val, &e.State)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EncryptionScopeResponse is the response envelope for operations that return a EncryptionScope type.
type EncryptionScopeResponse struct {
	// The Encryption Scope resource.
	EncryptionScope *EncryptionScope

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EncryptionScopesGetOptions contains the optional parameters for the EncryptionScopes.Get method.
type EncryptionScopesGetOptions struct {
	// placeholder for future optional parameters
}

// EncryptionScopesListOptions contains the optional parameters for the EncryptionScopes.List method.
type EncryptionScopesListOptions struct {
	// placeholder for future optional parameters
}

// EncryptionScopesPatchOptions contains the optional parameters for the EncryptionScopes.Patch method.
type EncryptionScopesPatchOptions struct {
	// placeholder for future optional parameters
}

// EncryptionScopesPutOptions contains the optional parameters for the EncryptionScopes.Put method.
type EncryptionScopesPutOptions struct {
	// placeholder for future optional parameters
}

// A service that allows server-side encryption to be used.
type EncryptionService struct {
	// A boolean indicating whether or not the service encrypts the data as it is stored.
	Enabled *bool `json:"enabled,omitempty"`

	// Encryption key type to be used for the encryption service. 'Account' key type implies that an account-scoped encryption key will be used. 'Service' key
	// type implies that a default service key is used.
	KeyType *KeyType `json:"keyType,omitempty"`

	// READ-ONLY; Gets a rough estimate of the date/time when the encryption was last enabled by the user. Only returned when encryption is enabled. There might
	// be some unencrypted blobs which were written after this
	// time, as it is just a rough estimate.
	LastEnabledTime *time.Time `json:"lastEnabledTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionService.
func (e EncryptionService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if e.Enabled != nil {
		objectMap["enabled"] = e.Enabled
	}
	if e.KeyType != nil {
		objectMap["keyType"] = e.KeyType
	}
	if e.LastEnabledTime != nil {
		objectMap["lastEnabledTime"] = (*timeRFC3339)(e.LastEnabledTime)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionService.
func (e *EncryptionService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enabled":
			if val != nil {
				err = json.Unmarshal(*val, &e.Enabled)
			}
			delete(rawMsg, key)
		case "keyType":
			if val != nil {
				err = json.Unmarshal(*val, &e.KeyType)
			}
			delete(rawMsg, key)
		case "lastEnabledTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				e.LastEnabledTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A list of services that support encryption.
type EncryptionServices struct {
	// The encryption function of the blob storage service.
	Blob *EncryptionService `json:"blob,omitempty"`

	// The encryption function of the file storage service.
	File *EncryptionService `json:"file,omitempty"`

	// The encryption function of the queue storage service.
	Queue *EncryptionService `json:"queue,omitempty"`

	// The encryption function of the table storage service.
	Table *EncryptionService `json:"table,omitempty"`
}

// The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object.
type Endpoints struct {
	// READ-ONLY; Gets the blob endpoint.
	Blob *string `json:"blob,omitempty" azure:"ro"`

	// READ-ONLY; Gets the dfs endpoint.
	Dfs *string `json:"dfs,omitempty" azure:"ro"`

	// READ-ONLY; Gets the file endpoint.
	File *string `json:"file,omitempty" azure:"ro"`

	// Gets the internet routing storage endpoints
	InternetEndpoints *StorageAccountInternetEndpoints `json:"internetEndpoints,omitempty"`

	// Gets the microsoft routing storage endpoints.
	MicrosoftEndpoints *StorageAccountMicrosoftEndpoints `json:"microsoftEndpoints,omitempty"`

	// READ-ONLY; Gets the queue endpoint.
	Queue *string `json:"queue,omitempty" azure:"ro"`

	// READ-ONLY; Gets the table endpoint.
	Table *string `json:"table,omitempty" azure:"ro"`

	// READ-ONLY; Gets the web endpoint.
	Web *string `json:"web,omitempty" azure:"ro"`
}

// An error response from the storage resource provider.
type ErrorResponse struct {
	// An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
func (e ErrorResponse) Error() string {
	msg := ""
	if e.Code != nil {
		msg += fmt.Sprintf("Code: %v\n", *e.Code)
	}
	if e.Message != nil {
		msg += fmt.Sprintf("Message: %v\n", *e.Message)
	}
	if msg == "" {
		msg = "missing error info"
	}
	return msg
}

type FileServiceItems struct {
	// READ-ONLY; List of file services returned.
	Value *[]FileServiceProperties `json:"value,omitempty" azure:"ro"`
}

// FileServiceItemsResponse is the response envelope for operations that return a FileServiceItems type.
type FileServiceItemsResponse struct {
	FileServiceItems *FileServiceItems

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The properties of File services in storage account.
type FileServiceProperties struct {
	Resource
	// The properties of File services in storage account.
	FileServiceProperties *FileServicePropertiesAutoGenerated `json:"properties,omitempty"`

	// READ-ONLY; Sku name and tier.
	SKU *SKU `json:"sku,omitempty" azure:"ro"`
}

// The properties of File services in storage account.
type FileServicePropertiesAutoGenerated struct {
	// Specifies CORS rules for the File service. You can include up to five CorsRule elements in the request. If no CorsRule elements are included in the request
	// body, all CORS rules will be deleted, and
	// CORS will be disabled for the File service.
	Cors *CorsRules `json:"cors,omitempty"`

	// The file service properties for share soft delete.
	ShareDeleteRetentionPolicy *DeleteRetentionPolicy `json:"shareDeleteRetentionPolicy,omitempty"`
}

// FileServicePropertiesResponse is the response envelope for operations that return a FileServiceProperties type.
type FileServicePropertiesResponse struct {
	// The properties of File services in storage account.
	FileServiceProperties *FileServiceProperties

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FileServicesGetServicePropertiesOptions contains the optional parameters for the FileServices.GetServiceProperties method.
type FileServicesGetServicePropertiesOptions struct {
	// placeholder for future optional parameters
}

// FileServicesListOptions contains the optional parameters for the FileServices.List method.
type FileServicesListOptions struct {
	// placeholder for future optional parameters
}

// FileServicesSetServicePropertiesOptions contains the optional parameters for the FileServices.SetServiceProperties method.
type FileServicesSetServicePropertiesOptions struct {
	// placeholder for future optional parameters
}

// Properties of the file share, including Id, resource name, resource type, Etag.
type FileShare struct {
	AzureEntityResource
	// Properties of the file share.
	FileShareProperties *FileShareProperties `json:"properties,omitempty"`
}

// The file share properties be listed out.
type FileShareItem struct {
	AzureEntityResource
	// The file share properties be listed out.
	Properties *FileShareProperties `json:"properties,omitempty"`
}

// Response schema. Contains list of shares returned, and if paging is requested or required, a URL to next page of shares.
type FileShareItems struct {
	// READ-ONLY; Request URL that can be used to query next page of shares. Returned when total number of requested shares exceed maximum page size.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of file shares returned.
	Value *[]FileShareItem `json:"value,omitempty" azure:"ro"`
}

// FileShareItemsResponse is the response envelope for operations that return a FileShareItems type.
type FileShareItemsResponse struct {
	// Response schema. Contains list of shares returned, and if paging is requested or required, a URL to next page of shares.
	FileShareItems *FileShareItems

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The properties of the file share.
type FileShareProperties struct {
	// Access tier for specific share. GpV2 account can choose between TransactionOptimized (default), Hot, and Cool. FileStorage account can choose Premium.
	AccessTier *ShareAccessTier `json:"accessTier,omitempty"`

	// READ-ONLY; Indicates the last modification time for share access tier.
	AccessTierChangeTime *time.Time `json:"accessTierChangeTime,omitempty" azure:"ro"`

	// READ-ONLY; Indicates if there is a pending transition for access tier.
	AccessTierStatus *string `json:"accessTierStatus,omitempty" azure:"ro"`

	// READ-ONLY; Indicates whether the share was deleted.
	Deleted *bool `json:"deleted,omitempty" azure:"ro"`

	// READ-ONLY; The deleted time if the share was deleted.
	DeletedTime *time.Time `json:"deletedTime,omitempty" azure:"ro"`

	// The authentication protocol that is used for the file share. Can only be specified when creating a share.
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`

	// READ-ONLY; Returns the date and time the share was last modified.
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// A name-value pair to associate with the share as metadata.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// READ-ONLY; Remaining retention days for share that was soft deleted.
	RemainingRetentionDays *int32 `json:"remainingRetentionDays,omitempty" azure:"ro"`

	// The property is for NFS share only. The default is NoRootSquash.
	RootSquash *RootSquashType `json:"rootSquash,omitempty"`

	// The maximum size of the share, in gigabytes. Must be greater than 0, and less than or equal to 5TB (5120). For Large File Shares, the maximum size is
	// 102400.
	ShareQuota *int32 `json:"shareQuota,omitempty"`

	// READ-ONLY; The approximate size of the data stored on the share. Note that this value may not include all recently created or recently resized files.
	ShareUsageBytes *int64 `json:"shareUsageBytes,omitempty" azure:"ro"`

	// READ-ONLY; The version of the share.
	Version *string `json:"version,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type FileShareProperties.
func (f FileShareProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if f.AccessTier != nil {
		objectMap["accessTier"] = f.AccessTier
	}
	if f.AccessTierChangeTime != nil {
		objectMap["accessTierChangeTime"] = (*timeRFC3339)(f.AccessTierChangeTime)
	}
	if f.AccessTierStatus != nil {
		objectMap["accessTierStatus"] = f.AccessTierStatus
	}
	if f.Deleted != nil {
		objectMap["deleted"] = f.Deleted
	}
	if f.DeletedTime != nil {
		objectMap["deletedTime"] = (*timeRFC3339)(f.DeletedTime)
	}
	if f.EnabledProtocols != nil {
		objectMap["enabledProtocols"] = f.EnabledProtocols
	}
	if f.LastModifiedTime != nil {
		objectMap["lastModifiedTime"] = (*timeRFC3339)(f.LastModifiedTime)
	}
	if f.Metadata != nil {
		objectMap["metadata"] = f.Metadata
	}
	if f.RemainingRetentionDays != nil {
		objectMap["remainingRetentionDays"] = f.RemainingRetentionDays
	}
	if f.RootSquash != nil {
		objectMap["rootSquash"] = f.RootSquash
	}
	if f.ShareQuota != nil {
		objectMap["shareQuota"] = f.ShareQuota
	}
	if f.ShareUsageBytes != nil {
		objectMap["shareUsageBytes"] = f.ShareUsageBytes
	}
	if f.Version != nil {
		objectMap["version"] = f.Version
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileShareProperties.
func (f *FileShareProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessTier":
			if val != nil {
				err = json.Unmarshal(*val, &f.AccessTier)
			}
			delete(rawMsg, key)
		case "accessTierChangeTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				f.AccessTierChangeTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "accessTierStatus":
			if val != nil {
				err = json.Unmarshal(*val, &f.AccessTierStatus)
			}
			delete(rawMsg, key)
		case "deleted":
			if val != nil {
				err = json.Unmarshal(*val, &f.Deleted)
			}
			delete(rawMsg, key)
		case "deletedTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				f.DeletedTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "enabledProtocols":
			if val != nil {
				err = json.Unmarshal(*val, &f.EnabledProtocols)
			}
			delete(rawMsg, key)
		case "lastModifiedTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				f.LastModifiedTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "metadata":
			if val != nil {
				err = json.Unmarshal(*val, &f.Metadata)
			}
			delete(rawMsg, key)
		case "remainingRetentionDays":
			if val != nil {
				err = json.Unmarshal(*val, &f.RemainingRetentionDays)
			}
			delete(rawMsg, key)
		case "rootSquash":
			if val != nil {
				err = json.Unmarshal(*val, &f.RootSquash)
			}
			delete(rawMsg, key)
		case "shareQuota":
			if val != nil {
				err = json.Unmarshal(*val, &f.ShareQuota)
			}
			delete(rawMsg, key)
		case "shareUsageBytes":
			if val != nil {
				err = json.Unmarshal(*val, &f.ShareUsageBytes)
			}
			delete(rawMsg, key)
		case "version":
			if val != nil {
				err = json.Unmarshal(*val, &f.Version)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FileShareResponse is the response envelope for operations that return a FileShare type.
type FileShareResponse struct {
	// Properties of the file share, including Id, resource name, resource type, Etag.
	FileShare *FileShare

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FileSharesCreateOptions contains the optional parameters for the FileShares.Create method.
type FileSharesCreateOptions struct {
	// placeholder for future optional parameters
}

// FileSharesDeleteOptions contains the optional parameters for the FileShares.Delete method.
type FileSharesDeleteOptions struct {
	// placeholder for future optional parameters
}

// FileSharesGetOptions contains the optional parameters for the FileShares.Get method.
type FileSharesGetOptions struct {
	// Optional, used to expand the properties within share's properties.
	Expand *string
}

// FileSharesListOptions contains the optional parameters for the FileShares.List method.
type FileSharesListOptions struct {
	// Optional, used to expand the properties within share's properties.
	Expand *string
	// Optional. When specified, only share names starting with the filter will be listed.
	Filter *string
	// Optional. Specified maximum number of shares that can be included in the list.
	Maxpagesize *string
}

// FileSharesRestoreOptions contains the optional parameters for the FileShares.Restore method.
type FileSharesRestoreOptions struct {
	// placeholder for future optional parameters
}

// FileSharesUpdateOptions contains the optional parameters for the FileShares.Update method.
type FileSharesUpdateOptions struct {
	// placeholder for future optional parameters
}

// Statistics related to replication for storage account's Blob, Table, Queue and File services. It is only available when geo-redundant replication is
// enabled for the storage account.
type GeoReplicationStats struct {
	// READ-ONLY; A boolean flag which indicates whether or not account failover is supported for the account.
	CanFailover *bool `json:"canFailover,omitempty" azure:"ro"`

	// READ-ONLY; All primary writes preceding this UTC date/time value are guaranteed to be available for read operations. Primary writes following this point
	// in time may or may not be available for reads. Element may
	// be default value if value of LastSyncTime is not available, this can happen if secondary is offline or we are in bootstrap.
	LastSyncTime *time.Time `json:"lastSyncTime,omitempty" azure:"ro"`

	// READ-ONLY; The status of the secondary location. Possible values are: - Live: Indicates that the secondary location is active and operational. - Bootstrap:
	// Indicates initial synchronization from the primary
	// location to the secondary location is in progress.This typically occurs when replication is first enabled. - Unavailable: Indicates that the secondary
	// location is temporarily unavailable.
	Status *GeoReplicationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoReplicationStats.
func (g GeoReplicationStats) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if g.CanFailover != nil {
		objectMap["canFailover"] = g.CanFailover
	}
	if g.LastSyncTime != nil {
		objectMap["lastSyncTime"] = (*timeRFC3339)(g.LastSyncTime)
	}
	if g.Status != nil {
		objectMap["status"] = g.Status
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoReplicationStats.
func (g *GeoReplicationStats) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "canFailover":
			if val != nil {
				err = json.Unmarshal(*val, &g.CanFailover)
			}
			delete(rawMsg, key)
		case "lastSyncTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				g.LastSyncTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "status":
			if val != nil {
				err = json.Unmarshal(*val, &g.Status)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HTTPPollerResponse contains the asynchronous HTTP response from the call to the service endpoint.
type HTTPPollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*http.Response, error)

	// Poller contains an initialized poller.
	Poller HTTPPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Identity for the resource.
type IDentity struct {
	// READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`

	// The identity type.
	Type *string `json:"type,omitempty"`
}

// IP rule with specific IP or IP range in CIDR format.
type IPRule struct {
	// The action of IP ACL rule.
	Action *string `json:"action,omitempty"`

	// Specifies the IP or IP range in CIDR format. Only IPV4 address is allowed.
	IPAddressOrRange *string `json:"value,omitempty"`
}

// The ImmutabilityPolicy property of a blob container, including Id, resource name, resource type, Etag.
type ImmutabilityPolicy struct {
	AzureEntityResource
	// The properties of an ImmutabilityPolicy of a blob container.
	Properties *ImmutabilityPolicyProperty `json:"properties,omitempty"`
}

// The properties of an ImmutabilityPolicy of a blob container.
type ImmutabilityPolicyProperties struct {
	// READ-ONLY; ImmutabilityPolicy Etag.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// The properties of an ImmutabilityPolicy of a blob container.
	Properties *ImmutabilityPolicyProperty `json:"properties,omitempty"`

	// READ-ONLY; The ImmutabilityPolicy update history of the blob container.
	UpdateHistory *[]UpdateHistoryProperty `json:"updateHistory,omitempty" azure:"ro"`
}

// The properties of an ImmutabilityPolicy of a blob container.
type ImmutabilityPolicyProperty struct {
	// This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written to an append blob while maintaining
	// immutability protection and compliance. Only
	// new blocks can be added and any existing blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API
	AllowProtectedAppendWrites *bool `json:"allowProtectedAppendWrites,omitempty"`

	// The immutability period for the blobs in the container since the policy creation, in days.
	ImmutabilityPeriodSinceCreationInDays *int32 `json:"immutabilityPeriodSinceCreationInDays,omitempty"`

	// READ-ONLY; The ImmutabilityPolicy state of a blob container, possible values include: Locked and Unlocked.
	State *ImmutabilityPolicyState `json:"state,omitempty" azure:"ro"`
}

// ImmutabilityPolicyResponse is the response envelope for operations that return a ImmutabilityPolicy type.
type ImmutabilityPolicyResponse struct {
	// ETag contains the information returned from the ETag header response.
	ETag *string

	// The ImmutabilityPolicy property of a blob container, including Id, resource name, resource type, Etag.
	ImmutabilityPolicy *ImmutabilityPolicy

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Properties of key vault.
type KeyVaultProperties struct {
	// READ-ONLY; The object identifier of the current versioned Key Vault Key in use.
	CurrentVersionedKeyIDentifier *string `json:"currentVersionedKeyIdentifier,omitempty" azure:"ro"`

	// The name of KeyVault key.
	KeyName *string `json:"keyname,omitempty"`

	// The Uri of KeyVault.
	KeyVaultURI *string `json:"keyvaulturi,omitempty"`

	// The version of KeyVault key.
	KeyVersion *string `json:"keyversion,omitempty"`

	// READ-ONLY; Timestamp of last rotation of the Key Vault Key.
	LastKeyRotationTimestamp *time.Time `json:"lastKeyRotationTimestamp,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyVaultProperties.
func (k KeyVaultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if k.CurrentVersionedKeyIDentifier != nil {
		objectMap["currentVersionedKeyIdentifier"] = k.CurrentVersionedKeyIDentifier
	}
	if k.KeyName != nil {
		objectMap["keyname"] = k.KeyName
	}
	if k.KeyVaultURI != nil {
		objectMap["keyvaulturi"] = k.KeyVaultURI
	}
	if k.KeyVersion != nil {
		objectMap["keyversion"] = k.KeyVersion
	}
	if k.LastKeyRotationTimestamp != nil {
		objectMap["lastKeyRotationTimestamp"] = (*timeRFC3339)(k.LastKeyRotationTimestamp)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyVaultProperties.
func (k *KeyVaultProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentVersionedKeyIdentifier":
			if val != nil {
				err = json.Unmarshal(*val, &k.CurrentVersionedKeyIDentifier)
			}
			delete(rawMsg, key)
		case "keyname":
			if val != nil {
				err = json.Unmarshal(*val, &k.KeyName)
			}
			delete(rawMsg, key)
		case "keyvaulturi":
			if val != nil {
				err = json.Unmarshal(*val, &k.KeyVaultURI)
			}
			delete(rawMsg, key)
		case "keyversion":
			if val != nil {
				err = json.Unmarshal(*val, &k.KeyVersion)
			}
			delete(rawMsg, key)
		case "lastKeyRotationTimestamp":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				k.LastKeyRotationTimestamp = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Lease Container request schema.
type LeaseContainerRequest struct {
	// Specifies the lease action. Can be one of the available actions.
	Action *LeaseContainerRequestAction `json:"action,omitempty"`

	// Optional. For a break action, proposed duration the lease should continue before it is broken, in seconds, between 0 and 60.
	BreakPeriod *int32 `json:"breakPeriod,omitempty"`

	// Required for acquire. Specifies the duration of the lease, in seconds, or negative one (-1) for a lease that never expires.
	LeaseDuration *int32 `json:"leaseDuration,omitempty"`

	// Identifies the lease. Can be specified in any valid GUID string format.
	LeaseID *string `json:"leaseId,omitempty"`

	// Optional for acquire, required for change. Proposed lease ID, in a GUID string format.
	ProposedLeaseID *string `json:"proposedLeaseId,omitempty"`
}

// Lease Container response schema.
type LeaseContainerResponse struct {
	// Returned unique lease ID that must be included with any request to delete the container, or to renew, change, or release the lease.
	LeaseID *string `json:"leaseId,omitempty"`

	// Approximate time remaining in the lease period, in seconds.
	LeaseTimeSeconds *string `json:"leaseTimeSeconds,omitempty"`
}

// LeaseContainerResponseResponse is the response envelope for operations that return a LeaseContainerResponse type.
type LeaseContainerResponseResponse struct {
	// Lease Container response schema.
	LeaseContainerResponse *LeaseContainerResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The LegalHold property of a blob container.
type LegalHold struct {
	// READ-ONLY; The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to
	// false by SRP if all existing legal hold tags are cleared out.
	// There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account.
	HasLegalHold *bool `json:"hasLegalHold,omitempty" azure:"ro"`

	// Each tag should be 3 to 23 alphanumeric characters and is normalized to lower case at SRP.
	Tags *[]string `json:"tags,omitempty"`
}

// The LegalHold property of a blob container.
type LegalHoldProperties struct {
	// READ-ONLY; The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to
	// false by SRP if all existing legal hold tags are cleared out.
	// There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account.
	HasLegalHold *bool `json:"hasLegalHold,omitempty" azure:"ro"`

	// The list of LegalHold tags of a blob container.
	Tags *[]TagProperty `json:"tags,omitempty"`
}

// LegalHoldResponse is the response envelope for operations that return a LegalHold type.
type LegalHoldResponse struct {
	// The LegalHold property of a blob container.
	LegalHold *LegalHold

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The List SAS credentials operation response.
type ListAccountSasResponse struct {
	// READ-ONLY; List SAS credentials of storage account.
	AccountSasToken *string `json:"accountSasToken,omitempty" azure:"ro"`
}

// ListAccountSasResponseResponse is the response envelope for operations that return a ListAccountSasResponse type.
type ListAccountSasResponseResponse struct {
	// The List SAS credentials operation response.
	ListAccountSasResponse *ListAccountSasResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The blob container properties be listed out.
type ListContainerItem struct {
	AzureEntityResource
	// The blob container properties be listed out.
	Properties *ContainerProperties `json:"properties,omitempty"`
}

// Response schema. Contains list of blobs returned, and if paging is requested or required, a URL to next page of containers.
type ListContainerItems struct {
	// READ-ONLY; Request URL that can be used to query next page of containers. Returned when total number of requested containers exceed maximum page size.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of blobs containers returned.
	Value *[]ListContainerItem `json:"value,omitempty" azure:"ro"`
}

// ListContainerItemsResponse is the response envelope for operations that return a ListContainerItems type.
type ListContainerItemsResponse struct {
	// Response schema. Contains list of blobs returned, and if paging is requested or required, a URL to next page of containers.
	ListContainerItems *ListContainerItems

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type ListQueue struct {
	Resource
	// List Queue resource properties.
	QueueProperties *ListQueueProperties `json:"properties,omitempty"`
}

type ListQueueProperties struct {
	// A name-value pair that represents queue metadata.
	Metadata *map[string]string `json:"metadata,omitempty"`
}

// Response schema. Contains list of queues returned
type ListQueueResource struct {
	// READ-ONLY; Request URL that can be used to list next page of queues
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of queues returned.
	Value *[]ListQueue `json:"value,omitempty" azure:"ro"`
}

// ListQueueResourceResponse is the response envelope for operations that return a ListQueueResource type.
type ListQueueResourceResponse struct {
	// Response schema. Contains list of queues returned
	ListQueueResource *ListQueueResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type ListQueueServices struct {
	// READ-ONLY; List of queue services returned.
	Value *[]QueueServiceProperties `json:"value,omitempty" azure:"ro"`
}

// ListQueueServicesResponse is the response envelope for operations that return a ListQueueServices type.
type ListQueueServicesResponse struct {
	ListQueueServices *ListQueueServices

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The List service SAS credentials operation response.
type ListServiceSasResponse struct {
	// READ-ONLY; List service SAS credentials of specific resource.
	ServiceSasToken *string `json:"serviceSasToken,omitempty" azure:"ro"`
}

// ListServiceSasResponseResponse is the response envelope for operations that return a ListServiceSasResponse type.
type ListServiceSasResponseResponse struct {
	// The List service SAS credentials operation response.
	ListServiceSasResponse *ListServiceSasResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Response schema. Contains list of tables returned
type ListTableResource struct {
	// READ-ONLY; Request URL that can be used to query next page of tables
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of tables returned.
	Value *[]Table `json:"value,omitempty" azure:"ro"`
}

// ListTableResourceResponse is the response envelope for operations that return a ListTableResource type.
type ListTableResourceResponse struct {
	// Response schema. Contains list of tables returned
	ListTableResource *ListTableResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type ListTableServices struct {
	// READ-ONLY; List of table services returned.
	Value *[]TableServiceProperties `json:"value,omitempty" azure:"ro"`
}

// ListTableServicesResponse is the response envelope for operations that return a ListTableServices type.
type ListTableServicesResponse struct {
	ListTableServices *ListTableServices

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementPoliciesCreateOrUpdateOptions contains the optional parameters for the ManagementPolicies.CreateOrUpdate method.
type ManagementPoliciesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ManagementPoliciesDeleteOptions contains the optional parameters for the ManagementPolicies.Delete method.
type ManagementPoliciesDeleteOptions struct {
	// placeholder for future optional parameters
}

// ManagementPoliciesGetOptions contains the optional parameters for the ManagementPolicies.Get method.
type ManagementPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// The Get Storage Account ManagementPolicies operation response.
type ManagementPolicy struct {
	Resource
	// Returns the Storage Account Data Policies Rules.
	Properties *ManagementPolicyProperties `json:"properties,omitempty"`
}

// Actions are applied to the filtered blobs when the execution condition is met.
type ManagementPolicyAction struct {
	// The management policy action for base blob
	BaseBlob *ManagementPolicyBaseBlob `json:"baseBlob,omitempty"`

	// The management policy action for snapshot
	Snapshot *ManagementPolicySnapShot `json:"snapshot,omitempty"`
}

// Management policy action for base blob.
type ManagementPolicyBaseBlob struct {
	// The function to delete the blob
	Delete *DateAfterModification `json:"delete,omitempty"`

	// The function to tier blobs to archive storage. Support blobs currently at Hot or Cool tier
	TierToArchive *DateAfterModification `json:"tierToArchive,omitempty"`

	// The function to tier blobs to cool storage. Support blobs currently at Hot tier
	TierToCool *DateAfterModification `json:"tierToCool,omitempty"`
}

// An object that defines the Lifecycle rule. Each definition is made up with a filters set and an actions set.
type ManagementPolicyDefinition struct {
	// An object that defines the action set.
	Actions *ManagementPolicyAction `json:"actions,omitempty"`

	// An object that defines the filter set.
	Filters *ManagementPolicyFilter `json:"filters,omitempty"`
}

// Filters limit rule actions to a subset of blobs within the storage account. If multiple filters are defined, a logical AND is performed on all filters.
type ManagementPolicyFilter struct {
	// An array of blob index tag based filters, there can be at most 10 tag filters
	BlobIndexMatch *[]TagFilter `json:"blobIndexMatch,omitempty"`

	// An array of predefined enum values. Only blockBlob is supported.
	BlobTypes *[]string `json:"blobTypes,omitempty"`

	// An array of strings for prefixes to be match.
	PrefixMatch *[]string `json:"prefixMatch,omitempty"`
}

// The Storage Account ManagementPolicy properties.
type ManagementPolicyProperties struct {
	// READ-ONLY; Returns the date and time the ManagementPolicies was last modified.
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// The Storage Account ManagementPolicy, in JSON format. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
	Policy *ManagementPolicySchema `json:"policy,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagementPolicyProperties.
func (m ManagementPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if m.LastModifiedTime != nil {
		objectMap["lastModifiedTime"] = (*timeRFC3339)(m.LastModifiedTime)
	}
	if m.Policy != nil {
		objectMap["policy"] = m.Policy
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagementPolicyProperties.
func (m *ManagementPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastModifiedTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				m.LastModifiedTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "policy":
			if val != nil {
				err = json.Unmarshal(*val, &m.Policy)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagementPolicyResponse is the response envelope for operations that return a ManagementPolicy type.
type ManagementPolicyResponse struct {
	// The Get Storage Account ManagementPolicies operation response.
	ManagementPolicy *ManagementPolicy

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// An object that wraps the Lifecycle rule. Each rule is uniquely defined by name.
type ManagementPolicyRule struct {
	// An object that defines the Lifecycle rule.
	Definition *ManagementPolicyDefinition `json:"definition,omitempty"`

	// Rule is enabled if set to true.
	Enabled *bool `json:"enabled,omitempty"`

	// A rule name can contain any combination of alpha numeric characters. Rule name is case-sensitive. It must be unique within a policy.
	Name *string `json:"name,omitempty"`

	// The valid value is Lifecycle
	Type *RuleType `json:"type,omitempty"`
}

// The Storage Account ManagementPolicies Rules. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
type ManagementPolicySchema struct {
	// The Storage Account ManagementPolicies Rules. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
	Rules *[]ManagementPolicyRule `json:"rules,omitempty"`
}

// Management policy action for snapshot.
type ManagementPolicySnapShot struct {
	// The function to delete the blob snapshot
	Delete *DateAfterCreation `json:"delete,omitempty"`
}

// Metric specification of operation.
type MetricSpecification struct {
	// Aggregation type could be Average.
	AggregationType *string `json:"aggregationType,omitempty"`

	// The category this metric specification belong to, could be Capacity.
	Category *string `json:"category,omitempty"`

	// Dimensions of blobs, including blob type and access tier.
	Dimensions *[]Dimension `json:"dimensions,omitempty"`

	// Display description of metric specification.
	DisplayDescription *string `json:"displayDescription,omitempty"`

	// Display name of metric specification.
	DisplayName *string `json:"displayName,omitempty"`

	// The property to decide fill gap with zero or not.
	FillGapWithZero *bool `json:"fillGapWithZero,omitempty"`

	// Name of metric specification.
	Name *string `json:"name,omitempty"`

	// Account Resource Id.
	ResourceIDDimensionNameOverride *string `json:"resourceIdDimensionNameOverride,omitempty"`

	// Unit could be Bytes or Count.
	Unit *string `json:"unit,omitempty"`
}

// Network rule set
type NetworkRuleSet struct {
	// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example,
	// "Logging, Metrics"), or None to bypass none
	// of those traffics.
	Bypass *Bypass `json:"bypass,omitempty"`

	// Specifies the default action of allow or deny when no other rules match.
	DefaultAction *DefaultAction `json:"defaultAction,omitempty"`

	// Sets the IP ACL rules
	IPRules *[]IPRule `json:"ipRules,omitempty"`

	// Sets the virtual network rules
	VirtualNetworkRules *[]VirtualNetworkRule `json:"virtualNetworkRules,omitempty"`
}

// List storage account object replication policies.
type ObjectReplicationPolicies struct {
	// The replication policy between two storage accounts.
	Value *[]ObjectReplicationPolicy `json:"value,omitempty"`
}

// ObjectReplicationPoliciesCreateOrUpdateOptions contains the optional parameters for the ObjectReplicationPolicies.CreateOrUpdate method.
type ObjectReplicationPoliciesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ObjectReplicationPoliciesDeleteOptions contains the optional parameters for the ObjectReplicationPolicies.Delete method.
type ObjectReplicationPoliciesDeleteOptions struct {
	// placeholder for future optional parameters
}

// ObjectReplicationPoliciesGetOptions contains the optional parameters for the ObjectReplicationPolicies.Get method.
type ObjectReplicationPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// ObjectReplicationPoliciesListOptions contains the optional parameters for the ObjectReplicationPolicies.List method.
type ObjectReplicationPoliciesListOptions struct {
	// placeholder for future optional parameters
}

// ObjectReplicationPoliciesResponse is the response envelope for operations that return a ObjectReplicationPolicies type.
type ObjectReplicationPoliciesResponse struct {
	// List storage account object replication policies.
	ObjectReplicationPolicies *ObjectReplicationPolicies

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The replication policy between two storage accounts. Multiple rules can be defined in one policy.
type ObjectReplicationPolicy struct {
	Resource
	// Returns the Storage Account Object Replication Policy.
	Properties *ObjectReplicationPolicyProperties `json:"properties,omitempty"`
}

// Filters limit replication to a subset of blobs within the storage account. A logical OR is performed on values in the filter. If multiple filters are
// defined, a logical AND is performed on all
// filters.
type ObjectReplicationPolicyFilter struct {
	// Blobs created after the time will be replicated to the destination. It must be in datetime format 'yyyy-MM-ddTHH:mm:ssZ'. Example: 2020-02-19T16:05:00Z
	MinCreationTime *string `json:"minCreationTime,omitempty"`

	// Optional. Filters the results to replicate only blobs whose names begin with the specified prefix.
	PrefixMatch *[]string `json:"prefixMatch,omitempty"`
}

// The Storage Account ObjectReplicationPolicy properties.
type ObjectReplicationPolicyProperties struct {
	// Required. Destination account name.
	DestinationAccount *string `json:"destinationAccount,omitempty"`

	// READ-ONLY; Indicates when the policy is enabled on the source account.
	EnabledTime *time.Time `json:"enabledTime,omitempty" azure:"ro"`

	// READ-ONLY; A unique id for object replication policy.
	PolicyID *string `json:"policyId,omitempty" azure:"ro"`

	// The storage account object replication rules.
	Rules *[]ObjectReplicationPolicyRule `json:"rules,omitempty"`

	// Required. Source account name.
	SourceAccount *string `json:"sourceAccount,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ObjectReplicationPolicyProperties.
func (o ObjectReplicationPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.DestinationAccount != nil {
		objectMap["destinationAccount"] = o.DestinationAccount
	}
	if o.EnabledTime != nil {
		objectMap["enabledTime"] = (*timeRFC3339)(o.EnabledTime)
	}
	if o.PolicyID != nil {
		objectMap["policyId"] = o.PolicyID
	}
	if o.Rules != nil {
		objectMap["rules"] = o.Rules
	}
	if o.SourceAccount != nil {
		objectMap["sourceAccount"] = o.SourceAccount
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ObjectReplicationPolicyProperties.
func (o *ObjectReplicationPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destinationAccount":
			if val != nil {
				err = json.Unmarshal(*val, &o.DestinationAccount)
			}
			delete(rawMsg, key)
		case "enabledTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				o.EnabledTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "policyId":
			if val != nil {
				err = json.Unmarshal(*val, &o.PolicyID)
			}
			delete(rawMsg, key)
		case "rules":
			if val != nil {
				err = json.Unmarshal(*val, &o.Rules)
			}
			delete(rawMsg, key)
		case "sourceAccount":
			if val != nil {
				err = json.Unmarshal(*val, &o.SourceAccount)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ObjectReplicationPolicyResponse is the response envelope for operations that return a ObjectReplicationPolicy type.
type ObjectReplicationPolicyResponse struct {
	// The replication policy between two storage accounts. Multiple rules can be defined in one policy.
	ObjectReplicationPolicy *ObjectReplicationPolicy

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The replication policy rule between two containers.
type ObjectReplicationPolicyRule struct {
	// Required. Destination container name.
	DestinationContainer *string `json:"destinationContainer,omitempty"`

	// Optional. An object that defines the filter set.
	Filters *ObjectReplicationPolicyFilter `json:"filters,omitempty"`

	// Rule Id is auto-generated for each new rule on destination account. It is required for put policy on source account.
	RuleID *string `json:"ruleId,omitempty"`

	// Required. Source container name.
	SourceContainer *string `json:"sourceContainer,omitempty"`
}

// Storage REST API operation definition.
type Operation struct {
	// Display metadata associated with the operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty"`

	// Properties of operation, include metric specifications.
	OperationProperties *OperationProperties `json:"properties,omitempty"`

	// The origin of operations.
	Origin *string `json:"origin,omitempty"`
}

// Display metadata associated with the operation.
type OperationDisplay struct {
	// Description of the operation.
	Description *string `json:"description,omitempty"`

	// Type of operation: get, read, delete, etc.
	Operation *string `json:"operation,omitempty"`

	// Service provider: Microsoft Storage.
	Provider *string `json:"provider,omitempty"`

	// Resource on which the operation is performed etc.
	Resource *string `json:"resource,omitempty"`
}

// Result of the request to list Storage operations. It contains a list of operations and a URL link to get the next set of results.
type OperationListResult struct {
	// List of Storage operations supported by the Storage resource provider.
	Value *[]Operation `json:"value,omitempty"`
}

// OperationListResultResponse is the response envelope for operations that return a OperationListResult type.
type OperationListResultResponse struct {
	// Result of the request to list Storage operations. It contains a list of operations and a URL link to get the next set of results.
	OperationListResult *OperationListResult

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Properties of operation, include metric specifications.
type OperationProperties struct {
	// One property of operation, include metric specifications.
	ServiceSpecification *ServiceSpecification `json:"serviceSpecification,omitempty"`
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// The Private Endpoint resource.
type PrivateEndpoint struct {
	// READ-ONLY; The ARM identifier for Private Endpoint
	ID *string `json:"id,omitempty" azure:"ro"`
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnection struct {
	Resource
	// Resource properties.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`
}

// List of private endpoint connection associated with the specified storage account
type PrivateEndpointConnectionListResult struct {
	// Array of private endpoint connections
	Value *[]PrivateEndpointConnection `json:"value,omitempty"`
}

// PrivateEndpointConnectionListResultResponse is the response envelope for operations that return a PrivateEndpointConnectionListResult type.
type PrivateEndpointConnectionListResultResponse struct {
	// List of private endpoint connection associated with the specified storage account
	PrivateEndpointConnectionListResult *PrivateEndpointConnectionListResult

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Properties of the PrivateEndpointConnectProperties.
type PrivateEndpointConnectionProperties struct {
	// The resource of private end point.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// READ-ONLY; The provisioning state of the private endpoint connection resource.
	ProvisioningState *PrivateEndpointConnectionProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// PrivateEndpointConnectionResponse is the response envelope for operations that return a PrivateEndpointConnection type.
type PrivateEndpointConnectionResponse struct {
	// The Private Endpoint Connection resource.
	PrivateEndpointConnection *PrivateEndpointConnection

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsDeleteOptions contains the optional parameters for the PrivateEndpointConnections.Delete method.
type PrivateEndpointConnectionsDeleteOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsGetOptions contains the optional parameters for the PrivateEndpointConnections.Get method.
type PrivateEndpointConnectionsGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsListOptions contains the optional parameters for the PrivateEndpointConnections.List method.
type PrivateEndpointConnectionsListOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsPutOptions contains the optional parameters for the PrivateEndpointConnections.Put method.
type PrivateEndpointConnectionsPutOptions struct {
	// placeholder for future optional parameters
}

// A private link resource
type PrivateLinkResource struct {
	Resource
	// Resource properties.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`
}

// A list of private link resources
type PrivateLinkResourceListResult struct {
	// Array of private link resources
	Value *[]PrivateLinkResource `json:"value,omitempty"`
}

// PrivateLinkResourceListResultResponse is the response envelope for operations that return a PrivateLinkResourceListResult type.
type PrivateLinkResourceListResultResponse struct {
	// A list of private link resources
	PrivateLinkResourceListResult *PrivateLinkResourceListResult

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Properties of a private link resource.
type PrivateLinkResourceProperties struct {
	// READ-ONLY; The private link resource group id.
	GroupID *string `json:"groupId,omitempty" azure:"ro"`

	// READ-ONLY; The private link resource required member names.
	RequiredMembers *[]string `json:"requiredMembers,omitempty" azure:"ro"`

	// The private link resource Private link DNS zone name.
	RequiredZoneNames *[]string `json:"requiredZoneNames,omitempty"`
}

// PrivateLinkResourcesListByStorageAccountOptions contains the optional parameters for the PrivateLinkResources.ListByStorageAccount method.
type PrivateLinkResourcesListByStorageAccountOptions struct {
	// placeholder for future optional parameters
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionState struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionRequired *string `json:"actionRequired,omitempty"`

	// The reason for approval/rejection of the connection.
	Description *string `json:"description,omitempty"`

	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *PrivateEndpointServiceConnectionStatus `json:"status,omitempty"`
}

// QueueCreateOptions contains the optional parameters for the Queue.Create method.
type QueueCreateOptions struct {
	// placeholder for future optional parameters
}

// QueueDeleteOptions contains the optional parameters for the Queue.Delete method.
type QueueDeleteOptions struct {
	// placeholder for future optional parameters
}

// QueueGetOptions contains the optional parameters for the Queue.Get method.
type QueueGetOptions struct {
	// placeholder for future optional parameters
}

// QueueListOptions contains the optional parameters for the Queue.List method.
type QueueListOptions struct {
	// Optional, When specified, only the queues with a name starting with the given filter will be listed.
	Filter *string
	// Optional, a maximum number of queues that should be included in a list queue response
	Maxpagesize *string
}

type QueueProperties struct {
	// READ-ONLY; Integer indicating an approximate number of messages in the queue. This number is not lower than the actual number of messages in the queue,
	// but could be higher.
	ApproximateMessageCount *int32 `json:"approximateMessageCount,omitempty" azure:"ro"`

	// A name-value pair that represents queue metadata.
	Metadata *map[string]string `json:"metadata,omitempty"`
}

// The properties of a storage account’s Queue service.
type QueueServiceProperties struct {
	Resource
	// The properties of a storage account’s Queue service.
	QueueServiceProperties *QueueServicePropertiesAutoGenerated `json:"properties,omitempty"`
}

// The properties of a storage account’s Queue service.
type QueueServicePropertiesAutoGenerated struct {
	// Specifies CORS rules for the Queue service. You can include up to five CorsRule elements in the request. If no CorsRule elements are included in the
	// request body, all CORS rules will be deleted, and
	// CORS will be disabled for the Queue service.
	Cors *CorsRules `json:"cors,omitempty"`
}

// QueueServicePropertiesResponse is the response envelope for operations that return a QueueServiceProperties type.
type QueueServicePropertiesResponse struct {
	// The properties of a storage account’s Queue service.
	QueueServiceProperties *QueueServiceProperties

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// QueueServicesGetServicePropertiesOptions contains the optional parameters for the QueueServices.GetServiceProperties method.
type QueueServicesGetServicePropertiesOptions struct {
	// placeholder for future optional parameters
}

// QueueServicesListOptions contains the optional parameters for the QueueServices.List method.
type QueueServicesListOptions struct {
	// placeholder for future optional parameters
}

// QueueServicesSetServicePropertiesOptions contains the optional parameters for the QueueServices.SetServiceProperties method.
type QueueServicesSetServicePropertiesOptions struct {
	// placeholder for future optional parameters
}

// QueueUpdateOptions contains the optional parameters for the Queue.Update method.
type QueueUpdateOptions struct {
	// placeholder for future optional parameters
}

// Common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// The blob service properties for blob restore policy
type RestorePolicyProperties struct {
	// how long this blob can be restored. It should be great than zero and less than DeleteRetentionPolicy.days.
	Days *int32 `json:"days,omitempty"`

	// Blob restore is enabled if set to true.
	Enabled *bool `json:"enabled,omitempty"`

	// READ-ONLY; Deprecated in favor of minRestoreTime property.
	LastEnabledTime *time.Time `json:"lastEnabledTime,omitempty" azure:"ro"`

	// READ-ONLY; Returns the minimum date and time that the restore can be started.
	MinRestoreTime *time.Time `json:"minRestoreTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RestorePolicyProperties.
func (r RestorePolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.Days != nil {
		objectMap["days"] = r.Days
	}
	if r.Enabled != nil {
		objectMap["enabled"] = r.Enabled
	}
	if r.LastEnabledTime != nil {
		objectMap["lastEnabledTime"] = (*timeRFC3339)(r.LastEnabledTime)
	}
	if r.MinRestoreTime != nil {
		objectMap["minRestoreTime"] = (*timeRFC3339)(r.MinRestoreTime)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestorePolicyProperties.
func (r *RestorePolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "days":
			if val != nil {
				err = json.Unmarshal(*val, &r.Days)
			}
			delete(rawMsg, key)
		case "enabled":
			if val != nil {
				err = json.Unmarshal(*val, &r.Enabled)
			}
			delete(rawMsg, key)
		case "lastEnabledTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				r.LastEnabledTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "minRestoreTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				r.MinRestoreTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The restriction because of which SKU cannot be used.
type Restriction struct {
	// The reason for the restriction. As of now this can be "QuotaId" or "NotAvailableForSubscription". Quota Id is set when the SKU has requiredQuotas parameter
	// as the subscription does not belong to that
	// quota. The "NotAvailableForSubscription" is related to capacity at DC.
	ReasonCode *ReasonCode `json:"reasonCode,omitempty"`

	// READ-ONLY; The type of restrictions. As of now only possible value for this is location.
	Type *string `json:"type,omitempty" azure:"ro"`

	// READ-ONLY; The value of restrictions. If the restriction type is set to location. This would be different locations where the SKU is restricted.
	Values *[]string `json:"values,omitempty" azure:"ro"`
}

// Routing preference defines the type of network, either microsoft or internet routing to be used to deliver the user data, the default option is microsoft
// routing
type RoutingPreference struct {
	// A boolean flag which indicates whether internet routing storage endpoints are to be published
	PublishInternetEndpoints *bool `json:"publishInternetEndpoints,omitempty"`

	// A boolean flag which indicates whether microsoft routing storage endpoints are to be published
	PublishMicrosoftEndpoints *bool `json:"publishMicrosoftEndpoints,omitempty"`

	// Routing Choice defines the kind of network routing opted by the user.
	RoutingChoice *RoutingChoice `json:"routingChoice,omitempty"`
}

// The SKU of the storage account.
type SKU struct {
	// The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.
	Name *SKUName `json:"name,omitempty"`

	// READ-ONLY; The SKU tier. This is based on the SKU name.
	Tier *SKUTier `json:"tier,omitempty" azure:"ro"`
}

// The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc.
type SKUCapability struct {
	// READ-ONLY; The name of capability, The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; A string value to indicate states of given capability. Possibly 'true' or 'false'.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// Storage SKU and its properties
type SKUInformation struct {
	// READ-ONLY; The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc.
	Capabilities *[]SKUCapability `json:"capabilities,omitempty" azure:"ro"`

	// READ-ONLY; Indicates the type of storage account.
	Kind *Kind `json:"kind,omitempty" azure:"ro"`

	// READ-ONLY; The set of locations that the SKU is available. This will be supported and registered Azure Geo Regions (e.g. West US, East US, Southeast
	// Asia, etc.).
	Locations *[]string `json:"locations,omitempty" azure:"ro"`

	// The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.
	Name *SKUName `json:"name,omitempty"`

	// READ-ONLY; The type of the resource, usually it is 'storageAccounts'.
	ResourceType *string `json:"resourceType,omitempty" azure:"ro"`

	// The restrictions because of which SKU cannot be used. This is empty if there are no restrictions.
	Restrictions *[]Restriction `json:"restrictions,omitempty"`

	// READ-ONLY; The SKU tier. This is based on the SKU name.
	Tier *SKUTier `json:"tier,omitempty" azure:"ro"`
}

// SKUsListOptions contains the optional parameters for the SKUs.List method.
type SKUsListOptions struct {
	// placeholder for future optional parameters
}

// The parameters to list service SAS credentials of a specific resource.
type ServiceSasParameters struct {
	// The response header override for cache control.
	CacheControl *string `json:"rscc,omitempty"`

	// The canonical path to the signed resource.
	CanonicalizedResource *string `json:"canonicalizedResource,omitempty"`

	// The response header override for content disposition.
	ContentDisposition *string `json:"rscd,omitempty"`

	// The response header override for content encoding.
	ContentEncoding *string `json:"rsce,omitempty"`

	// The response header override for content language.
	ContentLanguage *string `json:"rscl,omitempty"`

	// The response header override for content type.
	ContentType *string `json:"rsct,omitempty"`

	// A unique value up to 64 characters in length that correlates to an access policy specified for the container, queue, or table.
	IDentifier *string `json:"signedIdentifier,omitempty"`

	// An IP address or a range of IP addresses from which to accept requests.
	IPAddressOrRange *string `json:"signedIp,omitempty"`

	// The key to sign the account SAS token with.
	KeyToSign *string `json:"keyToSign,omitempty"`

	// The end of partition key.
	PartitionKeyEnd *string `json:"endPk,omitempty"`

	// The start of partition key.
	PartitionKeyStart *string `json:"startPk,omitempty"`

	// The signed permissions for the service SAS. Possible values include: Read (r), Write (w), Delete (d), List (l), Add (a), Create (c), Update (u) and Process
	// (p).
	Permissions *Permissions `json:"signedPermission,omitempty"`

	// The protocol permitted for a request made with the account SAS.
	Protocols *HTTPProtocol `json:"signedProtocol,omitempty"`

	// The signed services accessible with the service SAS. Possible values include: Blob (b), Container (c), File (f), Share (s).
	Resource *SignedResource `json:"signedResource,omitempty"`

	// The end of row key.
	RowKeyEnd *string `json:"endRk,omitempty"`

	// The start of row key.
	RowKeyStart *string `json:"startRk,omitempty"`

	// The time at which the shared access signature becomes invalid.
	SharedAccessExpiryTime *time.Time `json:"signedExpiry,omitempty"`

	// The time at which the SAS becomes valid.
	SharedAccessStartTime *time.Time `json:"signedStart,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceSasParameters.
func (s ServiceSasParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.CacheControl != nil {
		objectMap["rscc"] = s.CacheControl
	}
	if s.CanonicalizedResource != nil {
		objectMap["canonicalizedResource"] = s.CanonicalizedResource
	}
	if s.ContentDisposition != nil {
		objectMap["rscd"] = s.ContentDisposition
	}
	if s.ContentEncoding != nil {
		objectMap["rsce"] = s.ContentEncoding
	}
	if s.ContentLanguage != nil {
		objectMap["rscl"] = s.ContentLanguage
	}
	if s.ContentType != nil {
		objectMap["rsct"] = s.ContentType
	}
	if s.IDentifier != nil {
		objectMap["signedIdentifier"] = s.IDentifier
	}
	if s.IPAddressOrRange != nil {
		objectMap["signedIp"] = s.IPAddressOrRange
	}
	if s.KeyToSign != nil {
		objectMap["keyToSign"] = s.KeyToSign
	}
	if s.PartitionKeyEnd != nil {
		objectMap["endPk"] = s.PartitionKeyEnd
	}
	if s.PartitionKeyStart != nil {
		objectMap["startPk"] = s.PartitionKeyStart
	}
	if s.Permissions != nil {
		objectMap["signedPermission"] = s.Permissions
	}
	if s.Protocols != nil {
		objectMap["signedProtocol"] = s.Protocols
	}
	if s.Resource != nil {
		objectMap["signedResource"] = s.Resource
	}
	if s.RowKeyEnd != nil {
		objectMap["endRk"] = s.RowKeyEnd
	}
	if s.RowKeyStart != nil {
		objectMap["startRk"] = s.RowKeyStart
	}
	if s.SharedAccessExpiryTime != nil {
		objectMap["signedExpiry"] = (*timeRFC3339)(s.SharedAccessExpiryTime)
	}
	if s.SharedAccessStartTime != nil {
		objectMap["signedStart"] = (*timeRFC3339)(s.SharedAccessStartTime)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceSasParameters.
func (s *ServiceSasParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rscc":
			if val != nil {
				err = json.Unmarshal(*val, &s.CacheControl)
			}
			delete(rawMsg, key)
		case "canonicalizedResource":
			if val != nil {
				err = json.Unmarshal(*val, &s.CanonicalizedResource)
			}
			delete(rawMsg, key)
		case "rscd":
			if val != nil {
				err = json.Unmarshal(*val, &s.ContentDisposition)
			}
			delete(rawMsg, key)
		case "rsce":
			if val != nil {
				err = json.Unmarshal(*val, &s.ContentEncoding)
			}
			delete(rawMsg, key)
		case "rscl":
			if val != nil {
				err = json.Unmarshal(*val, &s.ContentLanguage)
			}
			delete(rawMsg, key)
		case "rsct":
			if val != nil {
				err = json.Unmarshal(*val, &s.ContentType)
			}
			delete(rawMsg, key)
		case "signedIdentifier":
			if val != nil {
				err = json.Unmarshal(*val, &s.IDentifier)
			}
			delete(rawMsg, key)
		case "signedIp":
			if val != nil {
				err = json.Unmarshal(*val, &s.IPAddressOrRange)
			}
			delete(rawMsg, key)
		case "keyToSign":
			if val != nil {
				err = json.Unmarshal(*val, &s.KeyToSign)
			}
			delete(rawMsg, key)
		case "endPk":
			if val != nil {
				err = json.Unmarshal(*val, &s.PartitionKeyEnd)
			}
			delete(rawMsg, key)
		case "startPk":
			if val != nil {
				err = json.Unmarshal(*val, &s.PartitionKeyStart)
			}
			delete(rawMsg, key)
		case "signedPermission":
			if val != nil {
				err = json.Unmarshal(*val, &s.Permissions)
			}
			delete(rawMsg, key)
		case "signedProtocol":
			if val != nil {
				err = json.Unmarshal(*val, &s.Protocols)
			}
			delete(rawMsg, key)
		case "signedResource":
			if val != nil {
				err = json.Unmarshal(*val, &s.Resource)
			}
			delete(rawMsg, key)
		case "endRk":
			if val != nil {
				err = json.Unmarshal(*val, &s.RowKeyEnd)
			}
			delete(rawMsg, key)
		case "startRk":
			if val != nil {
				err = json.Unmarshal(*val, &s.RowKeyStart)
			}
			delete(rawMsg, key)
		case "signedExpiry":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.SharedAccessExpiryTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "signedStart":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.SharedAccessStartTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// One property of operation, include metric specifications.
type ServiceSpecification struct {
	// Metric specifications of operation.
	MetricSpecifications *[]MetricSpecification `json:"metricSpecifications,omitempty"`
}

// The storage account.
type StorageAccount struct {
	TrackedResource
	// The identity of the resource.
	IDentity *IDentity `json:"identity,omitempty"`

	// READ-ONLY; Gets the Kind.
	Kind *Kind `json:"kind,omitempty" azure:"ro"`

	// Properties of the storage account.
	Properties *StorageAccountProperties `json:"properties,omitempty"`

	// READ-ONLY; Gets the SKU.
	SKU *SKU `json:"sku,omitempty" azure:"ro"`
}

// The parameters used to check the availability of the storage account name.
type StorageAccountCheckNameAvailabilityParameters struct {
	// The storage account name.
	Name *string `json:"name,omitempty"`

	// The type of resource, Microsoft.Storage/storageAccounts
	Type *string `json:"type,omitempty"`
}

// The parameters used when creating a storage account.
type StorageAccountCreateParameters struct {
	// The identity of the resource.
	IDentity *IDentity `json:"identity,omitempty"`

	// Required. Indicates the type of storage account.
	Kind *Kind `json:"kind,omitempty"`

	// Required. Gets or sets the location of the resource. This will be one of the supported and registered Azure Geo Regions (e.g. West US, East US, Southeast
	// Asia, etc.). The geo region of a resource
	// cannot be changed once it is created, but if an identical geo region is specified on update, the request will succeed.
	Location *string `json:"location,omitempty"`

	// The parameters used to create the storage account.
	Properties *StorageAccountPropertiesCreateParameters `json:"properties,omitempty"`

	// Required. Gets or sets the SKU name.
	SKU *SKU `json:"sku,omitempty"`

	// Gets or sets a list of key value pairs that describe the resource. These tags can be used for viewing and grouping this resource (across resource groups).
	// A maximum of 15 tags can be provided for a
	// resource. Each tag must have a key with a length no greater than 128 characters and a value with a length no greater than 256 characters.
	Tags *map[string]string `json:"tags,omitempty"`
}

// The URIs that are used to perform a retrieval of a public blob, file, web or dfs object via a internet routing endpoint.
type StorageAccountInternetEndpoints struct {
	// READ-ONLY; Gets the blob endpoint.
	Blob *string `json:"blob,omitempty" azure:"ro"`

	// READ-ONLY; Gets the dfs endpoint.
	Dfs *string `json:"dfs,omitempty" azure:"ro"`

	// READ-ONLY; Gets the file endpoint.
	File *string `json:"file,omitempty" azure:"ro"`

	// READ-ONLY; Gets the web endpoint.
	Web *string `json:"web,omitempty" azure:"ro"`
}

// An access key for the storage account.
type StorageAccountKey struct {
	// READ-ONLY; Name of the key.
	KeyName *string `json:"keyName,omitempty" azure:"ro"`

	// READ-ONLY; Permissions for the key -- read-only or full permissions.
	Permissions *KeyPermission `json:"permissions,omitempty" azure:"ro"`

	// READ-ONLY; Base 64-encoded value of the key.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// The response from the ListKeys operation.
type StorageAccountListKeysResult struct {
	// READ-ONLY; Gets the list of storage account keys and their properties for the specified storage account.
	Keys *[]StorageAccountKey `json:"keys,omitempty" azure:"ro"`
}

// StorageAccountListKeysResultResponse is the response envelope for operations that return a StorageAccountListKeysResult type.
type StorageAccountListKeysResultResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// The response from the ListKeys operation.
	StorageAccountListKeysResult *StorageAccountListKeysResult
}

// The response from the List Storage Accounts operation.
type StorageAccountListResult struct {
	// READ-ONLY; Request URL that can be used to query next page of storage accounts. Returned when total number of requested storage accounts exceed maximum
	// page size.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Gets the list of storage accounts and their properties.
	Value *[]StorageAccount `json:"value,omitempty" azure:"ro"`
}

// StorageAccountListResultResponse is the response envelope for operations that return a StorageAccountListResult type.
type StorageAccountListResultResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// The response from the List Storage Accounts operation.
	StorageAccountListResult *StorageAccountListResult
}

// The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object via a microsoft routing endpoint.
type StorageAccountMicrosoftEndpoints struct {
	// READ-ONLY; Gets the blob endpoint.
	Blob *string `json:"blob,omitempty" azure:"ro"`

	// READ-ONLY; Gets the dfs endpoint.
	Dfs *string `json:"dfs,omitempty" azure:"ro"`

	// READ-ONLY; Gets the file endpoint.
	File *string `json:"file,omitempty" azure:"ro"`

	// READ-ONLY; Gets the queue endpoint.
	Queue *string `json:"queue,omitempty" azure:"ro"`

	// READ-ONLY; Gets the table endpoint.
	Table *string `json:"table,omitempty" azure:"ro"`

	// READ-ONLY; Gets the web endpoint.
	Web *string `json:"web,omitempty" azure:"ro"`
}

// StorageAccountPollerResponse is the response envelope for operations that asynchronously return a StorageAccount type.
type StorageAccountPollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (StorageAccountResponse, error)

	// Poller contains an initialized poller.
	Poller StorageAccountPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Properties of the storage account.
type StorageAccountProperties struct {
	// READ-ONLY; Required for storage accounts where kind = BlobStorage. The access tier used for billing.
	AccessTier *AccessTier `json:"accessTier,omitempty" azure:"ro"`

	// Allow or disallow public access to all blobs or containers in the storage account. The default interpretation is true for this property.
	AllowBlobPublicAccess *bool `json:"allowBlobPublicAccess,omitempty"`

	// Provides the identity based authentication settings for Azure Files.
	AzureFilesIDentityBasedAuthentication *AzureFilesIDentityBasedAuthentication `json:"azureFilesIdentityBasedAuthentication,omitempty"`

	// READ-ONLY; Blob restore status
	BlobRestoreStatus *BlobRestoreStatus `json:"blobRestoreStatus,omitempty" azure:"ro"`

	// READ-ONLY; Gets the creation date and time of the storage account in UTC.
	CreationTime *time.Time `json:"creationTime,omitempty" azure:"ro"`

	// READ-ONLY; Gets the custom domain the user assigned to this storage account.
	CustomDomain *CustomDomain `json:"customDomain,omitempty" azure:"ro"`

	// Allows https traffic only to storage service if sets to true.
	EnableHTTPsTrafficOnly *bool `json:"supportsHttpsTrafficOnly,omitempty"`

	// READ-ONLY; Gets the encryption settings on the account. If unspecified, the account is unencrypted.
	Encryption *Encryption `json:"encryption,omitempty" azure:"ro"`

	// READ-ONLY; If the failover is in progress, the value will be true, otherwise, it will be null.
	FailoverInProgress *bool `json:"failoverInProgress,omitempty" azure:"ro"`

	// READ-ONLY; Geo Replication Stats
	GeoReplicationStats *GeoReplicationStats `json:"geoReplicationStats,omitempty" azure:"ro"`

	// Account HierarchicalNamespace enabled if sets to true.
	IsHnsEnabled *bool `json:"isHnsEnabled,omitempty"`

	// Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.
	LargeFileSharesState *LargeFileSharesState `json:"largeFileSharesState,omitempty"`

	// READ-ONLY; Gets the timestamp of the most recent instance of a failover to the secondary location. Only the most recent timestamp is retained. This element
	// is not returned if there has never been a failover
	// instance. Only available if the accountType is StandardGRS or StandardRAGRS.
	LastGeoFailoverTime *time.Time `json:"lastGeoFailoverTime,omitempty" azure:"ro"`

	// Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS 1.0 for this property.
	MinimumTLSVersion *MinimumTLSVersion `json:"minimumTlsVersion,omitempty"`

	// READ-ONLY; Network rule set
	NetworkRuleSet *NetworkRuleSet `json:"networkAcls,omitempty" azure:"ro"`

	// READ-ONLY; Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object. Note that StandardZRS and PremiumLRS accounts
	// only return the blob endpoint.
	PrimaryEndpoints *Endpoints `json:"primaryEndpoints,omitempty" azure:"ro"`

	// READ-ONLY; Gets the location of the primary data center for the storage account.
	PrimaryLocation *string `json:"primaryLocation,omitempty" azure:"ro"`

	// READ-ONLY; List of private endpoint connection associated with the specified storage account
	PrivateEndpointConnections *[]PrivateEndpointConnection `json:"privateEndpointConnections,omitempty" azure:"ro"`

	// READ-ONLY; Gets the status of the storage account at the time the operation was called.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// Maintains information about the network routing choice opted by the user for data transfer
	RoutingPreference *RoutingPreference `json:"routingPreference,omitempty"`

	// READ-ONLY; Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object from the secondary location of the storage account.
	// Only available if the SKU name is Standard_RAGRS.
	SecondaryEndpoints *Endpoints `json:"secondaryEndpoints,omitempty" azure:"ro"`

	// READ-ONLY; Gets the location of the geo-replicated secondary for the storage account. Only available if the accountType is StandardGRS or StandardRAGRS.
	SecondaryLocation *string `json:"secondaryLocation,omitempty" azure:"ro"`

	// READ-ONLY; Gets the status indicating whether the primary location of the storage account is available or unavailable.
	StatusOfPrimary *AccountStatus `json:"statusOfPrimary,omitempty" azure:"ro"`

	// READ-ONLY; Gets the status indicating whether the secondary location of the storage account is available or unavailable. Only available if the SKU name
	// is StandardGRS or StandardRAGRS.
	StatusOfSecondary *AccountStatus `json:"statusOfSecondary,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccountProperties.
func (s StorageAccountProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.AccessTier != nil {
		objectMap["accessTier"] = s.AccessTier
	}
	if s.AllowBlobPublicAccess != nil {
		objectMap["allowBlobPublicAccess"] = s.AllowBlobPublicAccess
	}
	if s.AzureFilesIDentityBasedAuthentication != nil {
		objectMap["azureFilesIdentityBasedAuthentication"] = s.AzureFilesIDentityBasedAuthentication
	}
	if s.BlobRestoreStatus != nil {
		objectMap["blobRestoreStatus"] = s.BlobRestoreStatus
	}
	if s.CreationTime != nil {
		objectMap["creationTime"] = (*timeRFC3339)(s.CreationTime)
	}
	if s.CustomDomain != nil {
		objectMap["customDomain"] = s.CustomDomain
	}
	if s.EnableHTTPsTrafficOnly != nil {
		objectMap["supportsHttpsTrafficOnly"] = s.EnableHTTPsTrafficOnly
	}
	if s.Encryption != nil {
		objectMap["encryption"] = s.Encryption
	}
	if s.FailoverInProgress != nil {
		objectMap["failoverInProgress"] = s.FailoverInProgress
	}
	if s.GeoReplicationStats != nil {
		objectMap["geoReplicationStats"] = s.GeoReplicationStats
	}
	if s.IsHnsEnabled != nil {
		objectMap["isHnsEnabled"] = s.IsHnsEnabled
	}
	if s.LargeFileSharesState != nil {
		objectMap["largeFileSharesState"] = s.LargeFileSharesState
	}
	if s.LastGeoFailoverTime != nil {
		objectMap["lastGeoFailoverTime"] = (*timeRFC3339)(s.LastGeoFailoverTime)
	}
	if s.MinimumTLSVersion != nil {
		objectMap["minimumTlsVersion"] = s.MinimumTLSVersion
	}
	if s.NetworkRuleSet != nil {
		objectMap["networkAcls"] = s.NetworkRuleSet
	}
	if s.PrimaryEndpoints != nil {
		objectMap["primaryEndpoints"] = s.PrimaryEndpoints
	}
	if s.PrimaryLocation != nil {
		objectMap["primaryLocation"] = s.PrimaryLocation
	}
	if s.PrivateEndpointConnections != nil {
		objectMap["privateEndpointConnections"] = s.PrivateEndpointConnections
	}
	if s.ProvisioningState != nil {
		objectMap["provisioningState"] = s.ProvisioningState
	}
	if s.RoutingPreference != nil {
		objectMap["routingPreference"] = s.RoutingPreference
	}
	if s.SecondaryEndpoints != nil {
		objectMap["secondaryEndpoints"] = s.SecondaryEndpoints
	}
	if s.SecondaryLocation != nil {
		objectMap["secondaryLocation"] = s.SecondaryLocation
	}
	if s.StatusOfPrimary != nil {
		objectMap["statusOfPrimary"] = s.StatusOfPrimary
	}
	if s.StatusOfSecondary != nil {
		objectMap["statusOfSecondary"] = s.StatusOfSecondary
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageAccountProperties.
func (s *StorageAccountProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessTier":
			if val != nil {
				err = json.Unmarshal(*val, &s.AccessTier)
			}
			delete(rawMsg, key)
		case "allowBlobPublicAccess":
			if val != nil {
				err = json.Unmarshal(*val, &s.AllowBlobPublicAccess)
			}
			delete(rawMsg, key)
		case "azureFilesIdentityBasedAuthentication":
			if val != nil {
				err = json.Unmarshal(*val, &s.AzureFilesIDentityBasedAuthentication)
			}
			delete(rawMsg, key)
		case "blobRestoreStatus":
			if val != nil {
				err = json.Unmarshal(*val, &s.BlobRestoreStatus)
			}
			delete(rawMsg, key)
		case "creationTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.CreationTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "customDomain":
			if val != nil {
				err = json.Unmarshal(*val, &s.CustomDomain)
			}
			delete(rawMsg, key)
		case "supportsHttpsTrafficOnly":
			if val != nil {
				err = json.Unmarshal(*val, &s.EnableHTTPsTrafficOnly)
			}
			delete(rawMsg, key)
		case "encryption":
			if val != nil {
				err = json.Unmarshal(*val, &s.Encryption)
			}
			delete(rawMsg, key)
		case "failoverInProgress":
			if val != nil {
				err = json.Unmarshal(*val, &s.FailoverInProgress)
			}
			delete(rawMsg, key)
		case "geoReplicationStats":
			if val != nil {
				err = json.Unmarshal(*val, &s.GeoReplicationStats)
			}
			delete(rawMsg, key)
		case "isHnsEnabled":
			if val != nil {
				err = json.Unmarshal(*val, &s.IsHnsEnabled)
			}
			delete(rawMsg, key)
		case "largeFileSharesState":
			if val != nil {
				err = json.Unmarshal(*val, &s.LargeFileSharesState)
			}
			delete(rawMsg, key)
		case "lastGeoFailoverTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.LastGeoFailoverTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "minimumTlsVersion":
			if val != nil {
				err = json.Unmarshal(*val, &s.MinimumTLSVersion)
			}
			delete(rawMsg, key)
		case "networkAcls":
			if val != nil {
				err = json.Unmarshal(*val, &s.NetworkRuleSet)
			}
			delete(rawMsg, key)
		case "primaryEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &s.PrimaryEndpoints)
			}
			delete(rawMsg, key)
		case "primaryLocation":
			if val != nil {
				err = json.Unmarshal(*val, &s.PrimaryLocation)
			}
			delete(rawMsg, key)
		case "privateEndpointConnections":
			if val != nil {
				err = json.Unmarshal(*val, &s.PrivateEndpointConnections)
			}
			delete(rawMsg, key)
		case "provisioningState":
			if val != nil {
				err = json.Unmarshal(*val, &s.ProvisioningState)
			}
			delete(rawMsg, key)
		case "routingPreference":
			if val != nil {
				err = json.Unmarshal(*val, &s.RoutingPreference)
			}
			delete(rawMsg, key)
		case "secondaryEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &s.SecondaryEndpoints)
			}
			delete(rawMsg, key)
		case "secondaryLocation":
			if val != nil {
				err = json.Unmarshal(*val, &s.SecondaryLocation)
			}
			delete(rawMsg, key)
		case "statusOfPrimary":
			if val != nil {
				err = json.Unmarshal(*val, &s.StatusOfPrimary)
			}
			delete(rawMsg, key)
		case "statusOfSecondary":
			if val != nil {
				err = json.Unmarshal(*val, &s.StatusOfSecondary)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The parameters used to create the storage account.
type StorageAccountPropertiesCreateParameters struct {
	// Required for storage accounts where kind = BlobStorage. The access tier used for billing.
	AccessTier *AccessTier `json:"accessTier,omitempty"`

	// Allow or disallow public access to all blobs or containers in the storage account. The default interpretation is true for this property.
	AllowBlobPublicAccess *bool `json:"allowBlobPublicAccess,omitempty"`

	// Provides the identity based authentication settings for Azure Files.
	AzureFilesIDentityBasedAuthentication *AzureFilesIDentityBasedAuthentication `json:"azureFilesIdentityBasedAuthentication,omitempty"`

	// User domain assigned to the storage account. Name is the CNAME source. Only one custom domain is supported per storage account at this time. To clear
	// the existing custom domain, use an empty string
	// for the custom domain name property.
	CustomDomain *CustomDomain `json:"customDomain,omitempty"`

	// Allows https traffic only to storage service if sets to true. The default value is true since API version 2019-04-01.
	EnableHTTPsTrafficOnly *bool `json:"supportsHttpsTrafficOnly,omitempty"`

	// Not applicable. Azure Storage encryption is enabled for all storage accounts and cannot be disabled.
	Encryption *Encryption `json:"encryption,omitempty"`

	// Account HierarchicalNamespace enabled if sets to true.
	IsHnsEnabled *bool `json:"isHnsEnabled,omitempty"`

	// Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.
	LargeFileSharesState *LargeFileSharesState `json:"largeFileSharesState,omitempty"`

	// Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS 1.0 for this property.
	MinimumTLSVersion *MinimumTLSVersion `json:"minimumTlsVersion,omitempty"`

	// Network rule set
	NetworkRuleSet *NetworkRuleSet `json:"networkAcls,omitempty"`

	// Maintains information about the network routing choice opted by the user for data transfer
	RoutingPreference *RoutingPreference `json:"routingPreference,omitempty"`
}

// The parameters used when updating a storage account.
type StorageAccountPropertiesUpdateParameters struct {
	// Required for storage accounts where kind = BlobStorage. The access tier used for billing.
	AccessTier *AccessTier `json:"accessTier,omitempty"`

	// Allow or disallow public access to all blobs or containers in the storage account. The default interpretation is true for this property.
	AllowBlobPublicAccess *bool `json:"allowBlobPublicAccess,omitempty"`

	// Provides the identity based authentication settings for Azure Files.
	AzureFilesIDentityBasedAuthentication *AzureFilesIDentityBasedAuthentication `json:"azureFilesIdentityBasedAuthentication,omitempty"`

	// Custom domain assigned to the storage account by the user. Name is the CNAME source. Only one custom domain is supported per storage account at this
	// time. To clear the existing custom domain, use an
	// empty string for the custom domain name property.
	CustomDomain *CustomDomain `json:"customDomain,omitempty"`

	// Allows https traffic only to storage service if sets to true.
	EnableHTTPsTrafficOnly *bool `json:"supportsHttpsTrafficOnly,omitempty"`

	// Provides the encryption settings on the account. The default setting is unencrypted.
	Encryption *Encryption `json:"encryption,omitempty"`

	// Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.
	LargeFileSharesState *LargeFileSharesState `json:"largeFileSharesState,omitempty"`

	// Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS 1.0 for this property.
	MinimumTLSVersion *MinimumTLSVersion `json:"minimumTlsVersion,omitempty"`

	// Network rule set
	NetworkRuleSet *NetworkRuleSet `json:"networkAcls,omitempty"`

	// Maintains information about the network routing choice opted by the user for data transfer
	RoutingPreference *RoutingPreference `json:"routingPreference,omitempty"`
}

// The parameters used to regenerate the storage account key.
type StorageAccountRegenerateKeyParameters struct {
	// The name of storage keys that want to be regenerated, possible values are key1, key2, kerb1, kerb2.
	KeyName *string `json:"keyName,omitempty"`
}

// StorageAccountResponse is the response envelope for operations that return a StorageAccount type.
type StorageAccountResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// The storage account.
	StorageAccount *StorageAccount
}

// The parameters that can be provided when updating the storage account properties.
type StorageAccountUpdateParameters struct {
	// The identity of the resource.
	IDentity *IDentity `json:"identity,omitempty"`

	// Optional. Indicates the type of storage account. Currently only StorageV2 value supported by server.
	Kind *Kind `json:"kind,omitempty"`

	// The parameters used when updating a storage account.
	Properties *StorageAccountPropertiesUpdateParameters `json:"properties,omitempty"`

	// Gets or sets the SKU name. Note that the SKU name cannot be updated to StandardZRS, PremiumLRS or Premium_ZRS, nor can accounts of those SKU names be
	// updated to any other value.
	SKU *SKU `json:"sku,omitempty"`

	// Gets or sets a list of key value pairs that describe the resource. These tags can be used in viewing and grouping this resource (across resource groups).
	// A maximum of 15 tags can be provided for a
	// resource. Each tag must have a key no greater in length than 128 characters and a value no greater in length than 256 characters.
	Tags *map[string]string `json:"tags,omitempty"`
}

// StorageAccountsBeginCreateOptions contains the optional parameters for the StorageAccounts.BeginCreate method.
type StorageAccountsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsBeginFailoverOptions contains the optional parameters for the StorageAccounts.BeginFailover method.
type StorageAccountsBeginFailoverOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsBeginRestoreBlobRangesOptions contains the optional parameters for the StorageAccounts.BeginRestoreBlobRanges method.
type StorageAccountsBeginRestoreBlobRangesOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsCheckNameAvailabilityOptions contains the optional parameters for the StorageAccounts.CheckNameAvailability method.
type StorageAccountsCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsDeleteOptions contains the optional parameters for the StorageAccounts.Delete method.
type StorageAccountsDeleteOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsGetPropertiesOptions contains the optional parameters for the StorageAccounts.GetProperties method.
type StorageAccountsGetPropertiesOptions struct {
	// May be used to expand the properties within account's properties. By default, data is not included when fetching properties. Currently we only support
	// geoReplicationStats and blobRestoreStatus.
	Expand *StorageAccountExpand
}

// StorageAccountsListAccountSasOptions contains the optional parameters for the StorageAccounts.ListAccountSas method.
type StorageAccountsListAccountSasOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsListByResourceGroupOptions contains the optional parameters for the StorageAccounts.ListByResourceGroup method.
type StorageAccountsListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsListKeysOptions contains the optional parameters for the StorageAccounts.ListKeys method.
type StorageAccountsListKeysOptions struct {
	// Specifies type of the key to be listed. Possible value is kerb.
	Expand *string
}

// StorageAccountsListOptions contains the optional parameters for the StorageAccounts.List method.
type StorageAccountsListOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsListServiceSasOptions contains the optional parameters for the StorageAccounts.ListServiceSas method.
type StorageAccountsListServiceSasOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsRegenerateKeyOptions contains the optional parameters for the StorageAccounts.RegenerateKey method.
type StorageAccountsRegenerateKeyOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsRevokeUserDelegationKeysOptions contains the optional parameters for the StorageAccounts.RevokeUserDelegationKeys method.
type StorageAccountsRevokeUserDelegationKeysOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountsUpdateOptions contains the optional parameters for the StorageAccounts.Update method.
type StorageAccountsUpdateOptions struct {
	// placeholder for future optional parameters
}

type StorageQueue struct {
	Resource
	// Queue resource properties.
	QueueProperties *QueueProperties `json:"properties,omitempty"`
}

// StorageQueueResponse is the response envelope for operations that return a StorageQueue type.
type StorageQueueResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse  *http.Response
	StorageQueue *StorageQueue
}

// The response from the List Storage SKUs operation.
type StorageSKUListResult struct {
	// READ-ONLY; Get the list result of storage SKUs and their properties.
	Value *[]SKUInformation `json:"value,omitempty" azure:"ro"`
}

// StorageSKUListResultResponse is the response envelope for operations that return a StorageSKUListResult type.
type StorageSKUListResultResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// The response from the List Storage SKUs operation.
	StorageSKUListResult *StorageSKUListResult
}

// Properties of the table, including Id, resource name, resource type.
type Table struct {
	Resource
	// Table resource properties.
	TableProperties *TableProperties `json:"properties,omitempty"`
}

// TableCreateOptions contains the optional parameters for the Table.Create method.
type TableCreateOptions struct {
	// placeholder for future optional parameters
}

// TableDeleteOptions contains the optional parameters for the Table.Delete method.
type TableDeleteOptions struct {
	// placeholder for future optional parameters
}

// TableGetOptions contains the optional parameters for the Table.Get method.
type TableGetOptions struct {
	// placeholder for future optional parameters
}

// TableListOptions contains the optional parameters for the Table.List method.
type TableListOptions struct {
	// placeholder for future optional parameters
}

type TableProperties struct {
	// READ-ONLY; Table name under the specified account
	TableName *string `json:"tableName,omitempty" azure:"ro"`
}

// TableResponse is the response envelope for operations that return a Table type.
type TableResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// Properties of the table, including Id, resource name, resource type.
	Table *Table
}

// The properties of a storage account’s Table service.
type TableServiceProperties struct {
	Resource
	// The properties of a storage account’s Table service.
	TableServiceProperties *TableServicePropertiesAutoGenerated `json:"properties,omitempty"`
}

// The properties of a storage account’s Table service.
type TableServicePropertiesAutoGenerated struct {
	// Specifies CORS rules for the Table service. You can include up to five CorsRule elements in the request. If no CorsRule elements are included in the
	// request body, all CORS rules will be deleted, and
	// CORS will be disabled for the Table service.
	Cors *CorsRules `json:"cors,omitempty"`
}

// TableServicePropertiesResponse is the response envelope for operations that return a TableServiceProperties type.
type TableServicePropertiesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// The properties of a storage account’s Table service.
	TableServiceProperties *TableServiceProperties
}

// TableServicesGetServicePropertiesOptions contains the optional parameters for the TableServices.GetServiceProperties method.
type TableServicesGetServicePropertiesOptions struct {
	// placeholder for future optional parameters
}

// TableServicesListOptions contains the optional parameters for the TableServices.List method.
type TableServicesListOptions struct {
	// placeholder for future optional parameters
}

// TableServicesSetServicePropertiesOptions contains the optional parameters for the TableServices.SetServiceProperties method.
type TableServicesSetServicePropertiesOptions struct {
	// placeholder for future optional parameters
}

// TableUpdateOptions contains the optional parameters for the Table.Update method.
type TableUpdateOptions struct {
	// placeholder for future optional parameters
}

// Blob index tag based filtering for blob objects
type TagFilter struct {
	// This is the filter tag name, it can have 1 - 128 characters
	Name *string `json:"name,omitempty"`

	// This is the comparison operator which is used for object comparison and filtering. Only == (equality operator) is currently supported
	Op *string `json:"op,omitempty"`

	// This is the filter tag value field used for tag based filtering, it can have 0 - 256 characters
	Value *string `json:"value,omitempty"`
}

// A tag of the LegalHold of a blob container.
type TagProperty struct {
	// READ-ONLY; Returns the Object ID of the user who added the tag.
	ObjectIDentifier *string `json:"objectIdentifier,omitempty" azure:"ro"`

	// READ-ONLY; The tag value.
	Tag *string `json:"tag,omitempty" azure:"ro"`

	// READ-ONLY; Returns the Tenant ID that issued the token for the user who added the tag.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`

	// READ-ONLY; Returns the date and time the tag was added.
	Timestamp *time.Time `json:"timestamp,omitempty" azure:"ro"`

	// READ-ONLY; Returns the User Principal Name of the user who added the tag.
	Upn *string `json:"upn,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TagProperty.
func (t TagProperty) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if t.ObjectIDentifier != nil {
		objectMap["objectIdentifier"] = t.ObjectIDentifier
	}
	if t.Tag != nil {
		objectMap["tag"] = t.Tag
	}
	if t.TenantID != nil {
		objectMap["tenantId"] = t.TenantID
	}
	if t.Timestamp != nil {
		objectMap["timestamp"] = (*timeRFC3339)(t.Timestamp)
	}
	if t.Upn != nil {
		objectMap["upn"] = t.Upn
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TagProperty.
func (t *TagProperty) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectIdentifier":
			if val != nil {
				err = json.Unmarshal(*val, &t.ObjectIDentifier)
			}
			delete(rawMsg, key)
		case "tag":
			if val != nil {
				err = json.Unmarshal(*val, &t.Tag)
			}
			delete(rawMsg, key)
		case "tenantId":
			if val != nil {
				err = json.Unmarshal(*val, &t.TenantID)
			}
			delete(rawMsg, key)
		case "timestamp":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				t.Timestamp = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "upn":
			if val != nil {
				err = json.Unmarshal(*val, &t.Upn)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The resource model definition for an Azure Resource Manager tracked top level resource which has 'tags' and a 'location'
type TrackedResource struct {
	Resource
	// The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Resource tags.
	Tags *map[string]string `json:"tags,omitempty"`
}

// An update history of the ImmutabilityPolicy of a blob container.
type UpdateHistoryProperty struct {
	// READ-ONLY; The immutability period for the blobs in the container since the policy creation, in days.
	ImmutabilityPeriodSinceCreationInDays *int32 `json:"immutabilityPeriodSinceCreationInDays,omitempty" azure:"ro"`

	// READ-ONLY; Returns the Object ID of the user who updated the ImmutabilityPolicy.
	ObjectIDentifier *string `json:"objectIdentifier,omitempty" azure:"ro"`

	// READ-ONLY; Returns the Tenant ID that issued the token for the user who updated the ImmutabilityPolicy.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`

	// READ-ONLY; Returns the date and time the ImmutabilityPolicy was updated.
	Timestamp *time.Time `json:"timestamp,omitempty" azure:"ro"`

	// READ-ONLY; The ImmutabilityPolicy update type of a blob container, possible values include: put, lock and extend.
	Update *ImmutabilityPolicyUpdateType `json:"update,omitempty" azure:"ro"`

	// READ-ONLY; Returns the User Principal Name of the user who updated the ImmutabilityPolicy.
	Upn *string `json:"upn,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateHistoryProperty.
func (u UpdateHistoryProperty) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if u.ImmutabilityPeriodSinceCreationInDays != nil {
		objectMap["immutabilityPeriodSinceCreationInDays"] = u.ImmutabilityPeriodSinceCreationInDays
	}
	if u.ObjectIDentifier != nil {
		objectMap["objectIdentifier"] = u.ObjectIDentifier
	}
	if u.TenantID != nil {
		objectMap["tenantId"] = u.TenantID
	}
	if u.Timestamp != nil {
		objectMap["timestamp"] = (*timeRFC3339)(u.Timestamp)
	}
	if u.Update != nil {
		objectMap["update"] = u.Update
	}
	if u.Upn != nil {
		objectMap["upn"] = u.Upn
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateHistoryProperty.
func (u *UpdateHistoryProperty) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "immutabilityPeriodSinceCreationInDays":
			if val != nil {
				err = json.Unmarshal(*val, &u.ImmutabilityPeriodSinceCreationInDays)
			}
			delete(rawMsg, key)
		case "objectIdentifier":
			if val != nil {
				err = json.Unmarshal(*val, &u.ObjectIDentifier)
			}
			delete(rawMsg, key)
		case "tenantId":
			if val != nil {
				err = json.Unmarshal(*val, &u.TenantID)
			}
			delete(rawMsg, key)
		case "timestamp":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				u.Timestamp = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "update":
			if val != nil {
				err = json.Unmarshal(*val, &u.Update)
			}
			delete(rawMsg, key)
		case "upn":
			if val != nil {
				err = json.Unmarshal(*val, &u.Upn)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Describes Storage Resource Usage.
type Usage struct {
	// READ-ONLY; Gets the current count of the allocated resources in the subscription.
	CurrentValue *int32 `json:"currentValue,omitempty" azure:"ro"`

	// READ-ONLY; Gets the maximum count of the resources that can be allocated in the subscription.
	Limit *int32 `json:"limit,omitempty" azure:"ro"`

	// READ-ONLY; Gets the name of the type of usage.
	Name *UsageName `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Gets the unit of measurement.
	Unit *UsageUnit `json:"unit,omitempty" azure:"ro"`
}

// The response from the List Usages operation.
type UsageListResult struct {
	// Gets or sets the list of Storage Resource Usages.
	Value *[]Usage `json:"value,omitempty"`
}

// UsageListResultResponse is the response envelope for operations that return a UsageListResult type.
type UsageListResultResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// The response from the List Usages operation.
	UsageListResult *UsageListResult
}

// The usage names that can be used; currently limited to StorageAccount.
type UsageName struct {
	// READ-ONLY; Gets a localized string describing the resource name.
	LocalizedValue *string `json:"localizedValue,omitempty" azure:"ro"`

	// READ-ONLY; Gets a string describing the resource name.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// UsagesListByLocationOptions contains the optional parameters for the Usages.ListByLocation method.
type UsagesListByLocationOptions struct {
	// placeholder for future optional parameters
}

// Virtual Network rule.
type VirtualNetworkRule struct {
	// The action of virtual network rule.
	Action *string `json:"action,omitempty"`

	// Gets the state of virtual network rule.
	State *State `json:"state,omitempty"`

	// Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
	VirtualNetworkResourceID *string `json:"id,omitempty"`
}
