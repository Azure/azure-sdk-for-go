// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorage

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// StorageAccountsOperations contains the methods for the StorageAccounts group.
type StorageAccountsOperations interface {
	// CheckNameAvailability - Checks that the storage account name is valid and is not already in use.
	CheckNameAvailability(ctx context.Context, accountName StorageAccountCheckNameAvailabilityParameters, options *StorageAccountsCheckNameAvailabilityOptions) (*CheckNameAvailabilityResultResponse, error)
	// BeginCreate - Asynchronously creates a new storage account with the specified parameters. If an account is already created and a subsequent create request
	// is issued with different properties, the account properties
	// will be updated. If an account is already created and a subsequent create or update request is issued with the exact same set of properties, the request
	// will succeed.
	BeginCreate(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountCreateParameters, options *StorageAccountsCreateOptions) (*StorageAccountPollerResponse, error)
	// ResumeCreate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreate(token string) (StorageAccountPoller, error)
	// Delete - Deletes a storage account in Microsoft Azure.
	Delete(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsDeleteOptions) (*http.Response, error)
	// BeginFailover - Failover request can be triggered for a storage account in case of availability issues. The failover occurs from the storage account's
	// primary cluster to secondary cluster for RA-GRS accounts. The
	// secondary cluster will become primary after failover.
	BeginFailover(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsFailoverOptions) (*HTTPPollerResponse, error)
	// ResumeFailover - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeFailover(token string) (HTTPPoller, error)
	// GetProperties - Returns the properties for the specified storage account including but not limited to name, SKU name, location, and account status. The
	// ListKeys operation should be used to retrieve storage keys.
	GetProperties(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsGetPropertiesOptions) (*StorageAccountResponse, error)
	// List - Lists all the storage accounts available under the subscription. Note that storage keys are not returned; use the ListKeys operation for this.
	List(options *StorageAccountsListOptions) StorageAccountListResultPager
	// ListAccountSas - List SAS credentials of a storage account.
	ListAccountSas(ctx context.Context, resourceGroupName string, accountName string, parameters AccountSasParameters, options *StorageAccountsListAccountSasOptions) (*ListAccountSasResponseResponse, error)
	// ListByResourceGroup - Lists all the storage accounts available under the given resource group. Note that storage keys are not returned; use the ListKeys
	// operation for this.
	ListByResourceGroup(ctx context.Context, resourceGroupName string, options *StorageAccountsListByResourceGroupOptions) (*StorageAccountListResultResponse, error)
	// ListKeys - Lists the access keys or Kerberos keys (if active directory enabled) for the specified storage account.
	ListKeys(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsListKeysOptions) (*StorageAccountListKeysResultResponse, error)
	// ListServiceSas - List service SAS credentials of a specific resource.
	ListServiceSas(ctx context.Context, resourceGroupName string, accountName string, parameters ServiceSasParameters, options *StorageAccountsListServiceSasOptions) (*ListServiceSasResponseResponse, error)
	// RegenerateKey - Regenerates one of the access keys or Kerberos keys for the specified storage account.
	RegenerateKey(ctx context.Context, resourceGroupName string, accountName string, regenerateKey StorageAccountRegenerateKeyParameters, options *StorageAccountsRegenerateKeyOptions) (*StorageAccountListKeysResultResponse, error)
	// BeginRestoreBlobRanges - Restore blobs in the specified blob ranges
	BeginRestoreBlobRanges(ctx context.Context, resourceGroupName string, accountName string, parameters BlobRestoreParameters, options *StorageAccountsRestoreBlobRangesOptions) (*BlobRestoreStatusPollerResponse, error)
	// ResumeRestoreBlobRanges - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeRestoreBlobRanges(token string) (BlobRestoreStatusPoller, error)
	// RevokeUserDelegationKeys - Revoke user delegation keys.
	RevokeUserDelegationKeys(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsRevokeUserDelegationKeysOptions) (*http.Response, error)
	// Update - The update operation can be used to update the SKU, encryption, access tier, or tags for a storage account. It can also be used to map the account
	// to a custom domain. Only one custom domain is
	// supported per storage account; the replacement/change of custom domain is not supported. In order to replace an old custom domain, the old value must
	// be cleared/unregistered before a new value can be
	// set. The update of multiple properties is supported. This call does not change the storage keys for the account. If you want to change the storage account
	// keys, use the regenerate keys operation. The
	// location and name of the storage account cannot be changed after creation.
	Update(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountUpdateParameters, options *StorageAccountsUpdateOptions) (*StorageAccountResponse, error)
}

// StorageAccountsClient implements the StorageAccountsOperations interface.
// Don't use this type directly, use NewStorageAccountsClient() instead.
type StorageAccountsClient struct {
	con            *armcore.Connection
	subscriptionID string
}

// NewStorageAccountsClient creates a new instance of StorageAccountsClient with the specified values.
func NewStorageAccountsClient(con *armcore.Connection, subscriptionID string) StorageAccountsOperations {
	return &StorageAccountsClient{con: con, subscriptionID: subscriptionID}
}

// Pipeline returns the pipeline associated with this client.
func (client *StorageAccountsClient) Pipeline() azcore.Pipeline {
	return client.con.Pipeline()
}

// CheckNameAvailability - Checks that the storage account name is valid and is not already in use.
func (client *StorageAccountsClient) CheckNameAvailability(ctx context.Context, accountName StorageAccountCheckNameAvailabilityParameters, options *StorageAccountsCheckNameAvailabilityOptions) (*CheckNameAvailabilityResultResponse, error) {
	req, err := client.CheckNameAvailabilityCreateRequest(ctx, accountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.CheckNameAvailabilityHandleError(resp)
	}
	result, err := client.CheckNameAvailabilityHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// CheckNameAvailabilityCreateRequest creates the CheckNameAvailability request.
func (client *StorageAccountsClient) CheckNameAvailabilityCreateRequest(ctx context.Context, accountName StorageAccountCheckNameAvailabilityParameters, options *StorageAccountsCheckNameAvailabilityOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/checkNameAvailability"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(accountName)
}

// CheckNameAvailabilityHandleResponse handles the CheckNameAvailability response.
func (client *StorageAccountsClient) CheckNameAvailabilityHandleResponse(resp *azcore.Response) (*CheckNameAvailabilityResultResponse, error) {
	result := CheckNameAvailabilityResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.CheckNameAvailabilityResult)
}

// CheckNameAvailabilityHandleError handles the CheckNameAvailability error response.
func (client *StorageAccountsClient) CheckNameAvailabilityHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *StorageAccountsClient) BeginCreate(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountCreateParameters, options *StorageAccountsCreateOptions) (*StorageAccountPollerResponse, error) {
	resp, err := client.Create(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &StorageAccountPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("StorageAccountsClient.Create", "", resp, client.CreateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &storageAccountPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*StorageAccountResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *StorageAccountsClient) ResumeCreate(token string) (StorageAccountPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("StorageAccountsClient.Create", token, client.CreateHandleError)
	if err != nil {
		return nil, err
	}
	return &storageAccountPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// Create - Asynchronously creates a new storage account with the specified parameters. If an account is already created and a subsequent create request
// is issued with different properties, the account properties
// will be updated. If an account is already created and a subsequent create or update request is issued with the exact same set of properties, the request
// will succeed.
func (client *StorageAccountsClient) Create(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountCreateParameters, options *StorageAccountsCreateOptions) (*azcore.Response, error) {
	req, err := client.CreateCreateRequest(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.CreateHandleError(resp)
	}
	return resp, nil
}

// CreateCreateRequest creates the Create request.
func (client *StorageAccountsClient) CreateCreateRequest(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountCreateParameters, options *StorageAccountsCreateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// CreateHandleResponse handles the Create response.
func (client *StorageAccountsClient) CreateHandleResponse(resp *azcore.Response) (*StorageAccountResponse, error) {
	result := StorageAccountResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccount)
}

// CreateHandleError handles the Create error response.
func (client *StorageAccountsClient) CreateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// Delete - Deletes a storage account in Microsoft Azure.
func (client *StorageAccountsClient) Delete(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsDeleteOptions) (*http.Response, error) {
	req, err := client.DeleteCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.DeleteHandleError(resp)
	}
	return resp.Response, nil
}

// DeleteCreateRequest creates the Delete request.
func (client *StorageAccountsClient) DeleteCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsDeleteOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// DeleteHandleError handles the Delete error response.
func (client *StorageAccountsClient) DeleteHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *StorageAccountsClient) BeginFailover(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsFailoverOptions) (*HTTPPollerResponse, error) {
	resp, err := client.Failover(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("StorageAccountsClient.Failover", "location", resp, client.FailoverHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *StorageAccountsClient) ResumeFailover(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("StorageAccountsClient.Failover", token, client.FailoverHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// Failover - Failover request can be triggered for a storage account in case of availability issues. The failover occurs from the storage account's primary
// cluster to secondary cluster for RA-GRS accounts. The
// secondary cluster will become primary after failover.
func (client *StorageAccountsClient) Failover(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsFailoverOptions) (*azcore.Response, error) {
	req, err := client.FailoverCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.FailoverHandleError(resp)
	}
	return resp, nil
}

// FailoverCreateRequest creates the Failover request.
func (client *StorageAccountsClient) FailoverCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsFailoverOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/failover"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// FailoverHandleError handles the Failover error response.
func (client *StorageAccountsClient) FailoverHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetProperties - Returns the properties for the specified storage account including but not limited to name, SKU name, location, and account status. The
// ListKeys operation should be used to retrieve storage keys.
func (client *StorageAccountsClient) GetProperties(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsGetPropertiesOptions) (*StorageAccountResponse, error) {
	req, err := client.GetPropertiesCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetPropertiesHandleError(resp)
	}
	result, err := client.GetPropertiesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetPropertiesCreateRequest creates the GetProperties request.
func (client *StorageAccountsClient) GetPropertiesCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsGetPropertiesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	if options != nil && options.Expand != nil {
		query.Set("$expand", string(*options.Expand))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetPropertiesHandleResponse handles the GetProperties response.
func (client *StorageAccountsClient) GetPropertiesHandleResponse(resp *azcore.Response) (*StorageAccountResponse, error) {
	result := StorageAccountResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccount)
}

// GetPropertiesHandleError handles the GetProperties error response.
func (client *StorageAccountsClient) GetPropertiesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// List - Lists all the storage accounts available under the subscription. Note that storage keys are not returned; use the ListKeys operation for this.
func (client *StorageAccountsClient) List(options *StorageAccountsListOptions) StorageAccountListResultPager {
	return &storageAccountListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.ListCreateRequest(ctx, options)
		},
		responder: client.ListHandleResponse,
		errorer:   client.ListHandleError,
		advancer: func(ctx context.Context, resp *StorageAccountListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.StorageAccountListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// ListCreateRequest creates the List request.
func (client *StorageAccountsClient) ListCreateRequest(ctx context.Context, options *StorageAccountsListOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/storageAccounts"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListHandleResponse handles the List response.
func (client *StorageAccountsClient) ListHandleResponse(resp *azcore.Response) (*StorageAccountListResultResponse, error) {
	result := StorageAccountListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccountListResult)
}

// ListHandleError handles the List error response.
func (client *StorageAccountsClient) ListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListAccountSas - List SAS credentials of a storage account.
func (client *StorageAccountsClient) ListAccountSas(ctx context.Context, resourceGroupName string, accountName string, parameters AccountSasParameters, options *StorageAccountsListAccountSasOptions) (*ListAccountSasResponseResponse, error) {
	req, err := client.ListAccountSasCreateRequest(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ListAccountSasHandleError(resp)
	}
	result, err := client.ListAccountSasHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ListAccountSasCreateRequest creates the ListAccountSas request.
func (client *StorageAccountsClient) ListAccountSasCreateRequest(ctx context.Context, resourceGroupName string, accountName string, parameters AccountSasParameters, options *StorageAccountsListAccountSasOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/ListAccountSas"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// ListAccountSasHandleResponse handles the ListAccountSas response.
func (client *StorageAccountsClient) ListAccountSasHandleResponse(resp *azcore.Response) (*ListAccountSasResponseResponse, error) {
	result := ListAccountSasResponseResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ListAccountSasResponse)
}

// ListAccountSasHandleError handles the ListAccountSas error response.
func (client *StorageAccountsClient) ListAccountSasHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListByResourceGroup - Lists all the storage accounts available under the given resource group. Note that storage keys are not returned; use the ListKeys
// operation for this.
func (client *StorageAccountsClient) ListByResourceGroup(ctx context.Context, resourceGroupName string, options *StorageAccountsListByResourceGroupOptions) (*StorageAccountListResultResponse, error) {
	req, err := client.ListByResourceGroupCreateRequest(ctx, resourceGroupName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ListByResourceGroupHandleError(resp)
	}
	result, err := client.ListByResourceGroupHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ListByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *StorageAccountsClient) ListByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *StorageAccountsListByResourceGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *StorageAccountsClient) ListByResourceGroupHandleResponse(resp *azcore.Response) (*StorageAccountListResultResponse, error) {
	result := StorageAccountListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccountListResult)
}

// ListByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *StorageAccountsClient) ListByResourceGroupHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListKeys - Lists the access keys or Kerberos keys (if active directory enabled) for the specified storage account.
func (client *StorageAccountsClient) ListKeys(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsListKeysOptions) (*StorageAccountListKeysResultResponse, error) {
	req, err := client.ListKeysCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ListKeysHandleError(resp)
	}
	result, err := client.ListKeysHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ListKeysCreateRequest creates the ListKeys request.
func (client *StorageAccountsClient) ListKeysCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsListKeysOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/listKeys"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	if options != nil && options.Expand != nil {
		query.Set("$expand", "kerb")
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListKeysHandleResponse handles the ListKeys response.
func (client *StorageAccountsClient) ListKeysHandleResponse(resp *azcore.Response) (*StorageAccountListKeysResultResponse, error) {
	result := StorageAccountListKeysResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccountListKeysResult)
}

// ListKeysHandleError handles the ListKeys error response.
func (client *StorageAccountsClient) ListKeysHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListServiceSas - List service SAS credentials of a specific resource.
func (client *StorageAccountsClient) ListServiceSas(ctx context.Context, resourceGroupName string, accountName string, parameters ServiceSasParameters, options *StorageAccountsListServiceSasOptions) (*ListServiceSasResponseResponse, error) {
	req, err := client.ListServiceSasCreateRequest(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ListServiceSasHandleError(resp)
	}
	result, err := client.ListServiceSasHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ListServiceSasCreateRequest creates the ListServiceSas request.
func (client *StorageAccountsClient) ListServiceSasCreateRequest(ctx context.Context, resourceGroupName string, accountName string, parameters ServiceSasParameters, options *StorageAccountsListServiceSasOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/ListServiceSas"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// ListServiceSasHandleResponse handles the ListServiceSas response.
func (client *StorageAccountsClient) ListServiceSasHandleResponse(resp *azcore.Response) (*ListServiceSasResponseResponse, error) {
	result := ListServiceSasResponseResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ListServiceSasResponse)
}

// ListServiceSasHandleError handles the ListServiceSas error response.
func (client *StorageAccountsClient) ListServiceSasHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// RegenerateKey - Regenerates one of the access keys or Kerberos keys for the specified storage account.
func (client *StorageAccountsClient) RegenerateKey(ctx context.Context, resourceGroupName string, accountName string, regenerateKey StorageAccountRegenerateKeyParameters, options *StorageAccountsRegenerateKeyOptions) (*StorageAccountListKeysResultResponse, error) {
	req, err := client.RegenerateKeyCreateRequest(ctx, resourceGroupName, accountName, regenerateKey, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.RegenerateKeyHandleError(resp)
	}
	result, err := client.RegenerateKeyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// RegenerateKeyCreateRequest creates the RegenerateKey request.
func (client *StorageAccountsClient) RegenerateKeyCreateRequest(ctx context.Context, resourceGroupName string, accountName string, regenerateKey StorageAccountRegenerateKeyParameters, options *StorageAccountsRegenerateKeyOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/regenerateKey"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(regenerateKey)
}

// RegenerateKeyHandleResponse handles the RegenerateKey response.
func (client *StorageAccountsClient) RegenerateKeyHandleResponse(resp *azcore.Response) (*StorageAccountListKeysResultResponse, error) {
	result := StorageAccountListKeysResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccountListKeysResult)
}

// RegenerateKeyHandleError handles the RegenerateKey error response.
func (client *StorageAccountsClient) RegenerateKeyHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *StorageAccountsClient) BeginRestoreBlobRanges(ctx context.Context, resourceGroupName string, accountName string, parameters BlobRestoreParameters, options *StorageAccountsRestoreBlobRangesOptions) (*BlobRestoreStatusPollerResponse, error) {
	resp, err := client.RestoreBlobRanges(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &BlobRestoreStatusPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("StorageAccountsClient.RestoreBlobRanges", "location", resp, client.RestoreBlobRangesHandleError)
	if err != nil {
		return nil, err
	}
	poller := &blobRestoreStatusPoller{
		pt:       pt,
		pipeline: client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*BlobRestoreStatusResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *StorageAccountsClient) ResumeRestoreBlobRanges(token string) (BlobRestoreStatusPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("StorageAccountsClient.RestoreBlobRanges", token, client.RestoreBlobRangesHandleError)
	if err != nil {
		return nil, err
	}
	return &blobRestoreStatusPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// RestoreBlobRanges - Restore blobs in the specified blob ranges
func (client *StorageAccountsClient) RestoreBlobRanges(ctx context.Context, resourceGroupName string, accountName string, parameters BlobRestoreParameters, options *StorageAccountsRestoreBlobRangesOptions) (*azcore.Response, error) {
	req, err := client.RestoreBlobRangesCreateRequest(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.RestoreBlobRangesHandleError(resp)
	}
	return resp, nil
}

// RestoreBlobRangesCreateRequest creates the RestoreBlobRanges request.
func (client *StorageAccountsClient) RestoreBlobRangesCreateRequest(ctx context.Context, resourceGroupName string, accountName string, parameters BlobRestoreParameters, options *StorageAccountsRestoreBlobRangesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/restoreBlobRanges"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// RestoreBlobRangesHandleResponse handles the RestoreBlobRanges response.
func (client *StorageAccountsClient) RestoreBlobRangesHandleResponse(resp *azcore.Response) (*BlobRestoreStatusResponse, error) {
	result := BlobRestoreStatusResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.BlobRestoreStatus)
}

// RestoreBlobRangesHandleError handles the RestoreBlobRanges error response.
func (client *StorageAccountsClient) RestoreBlobRangesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// RevokeUserDelegationKeys - Revoke user delegation keys.
func (client *StorageAccountsClient) RevokeUserDelegationKeys(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsRevokeUserDelegationKeysOptions) (*http.Response, error) {
	req, err := client.RevokeUserDelegationKeysCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.RevokeUserDelegationKeysHandleError(resp)
	}
	return resp.Response, nil
}

// RevokeUserDelegationKeysCreateRequest creates the RevokeUserDelegationKeys request.
func (client *StorageAccountsClient) RevokeUserDelegationKeysCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsRevokeUserDelegationKeysOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/revokeUserDelegationKeys"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// RevokeUserDelegationKeysHandleError handles the RevokeUserDelegationKeys error response.
func (client *StorageAccountsClient) RevokeUserDelegationKeysHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// Update - The update operation can be used to update the SKU, encryption, access tier, or tags for a storage account. It can also be used to map the account
// to a custom domain. Only one custom domain is
// supported per storage account; the replacement/change of custom domain is not supported. In order to replace an old custom domain, the old value must
// be cleared/unregistered before a new value can be
// set. The update of multiple properties is supported. This call does not change the storage keys for the account. If you want to change the storage account
// keys, use the regenerate keys operation. The
// location and name of the storage account cannot be changed after creation.
func (client *StorageAccountsClient) Update(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountUpdateParameters, options *StorageAccountsUpdateOptions) (*StorageAccountResponse, error) {
	req, err := client.UpdateCreateRequest(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.UpdateHandleError(resp)
	}
	result, err := client.UpdateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateCreateRequest creates the Update request.
func (client *StorageAccountsClient) UpdateCreateRequest(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountUpdateParameters, options *StorageAccountsUpdateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// UpdateHandleResponse handles the Update response.
func (client *StorageAccountsClient) UpdateHandleResponse(resp *azcore.Response) (*StorageAccountResponse, error) {
	result := StorageAccountResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccount)
}

// UpdateHandleError handles the Update error response.
func (client *StorageAccountsClient) UpdateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}
