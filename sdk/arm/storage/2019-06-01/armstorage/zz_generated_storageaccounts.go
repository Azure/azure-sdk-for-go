// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorage

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// StorageAccountsOperations contains the methods for the StorageAccounts group.
type StorageAccountsOperations interface {
	// CheckNameAvailability - Checks that the storage account name is valid and is not already in use.
	CheckNameAvailability(ctx context.Context, accountName StorageAccountCheckNameAvailabilityParameters, options *StorageAccountsCheckNameAvailabilityOptions) (*CheckNameAvailabilityResultResponse, error)
	// BeginCreate - Asynchronously creates a new storage account with the specified parameters. If an account is already created and a subsequent create request is issued with different properties, the account properties will be updated. If an account is already created and a subsequent create or update request is issued with the exact same set of properties, the request will succeed.
	BeginCreate(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountCreateParameters, options *StorageAccountsCreateOptions) (*StorageAccountPollerResponse, error)
	// ResumeCreate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreate(token string) (StorageAccountPoller, error)
	// Delete - Deletes a storage account in Microsoft Azure.
	Delete(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsDeleteOptions) (*http.Response, error)
	// BeginFailover - Failover request can be triggered for a storage account in case of availability issues. The failover occurs from the storage account's primary cluster to secondary cluster for RA-GRS accounts. The secondary cluster will become primary after failover.
	BeginFailover(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsFailoverOptions) (*HTTPPollerResponse, error)
	// ResumeFailover - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeFailover(token string) (HTTPPoller, error)
	// GetProperties - Returns the properties for the specified storage account including but not limited to name, SKU name, location, and account status. The ListKeys operation should be used to retrieve storage keys.
	GetProperties(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsGetPropertiesOptions) (*StorageAccountResponse, error)
	// List - Lists all the storage accounts available under the subscription. Note that storage keys are not returned; use the ListKeys operation for this.
	List(options *StorageAccountsListOptions) StorageAccountListResultPager
	// ListAccountSas - List SAS credentials of a storage account.
	ListAccountSas(ctx context.Context, resourceGroupName string, accountName string, parameters AccountSasParameters, options *StorageAccountsListAccountSasOptions) (*ListAccountSasResponseResponse, error)
	// ListByResourceGroup - Lists all the storage accounts available under the given resource group. Note that storage keys are not returned; use the ListKeys operation for this.
	ListByResourceGroup(ctx context.Context, resourceGroupName string, options *StorageAccountsListByResourceGroupOptions) (*StorageAccountListResultResponse, error)
	// ListKeys - Lists the access keys or Kerberos keys (if active directory enabled) for the specified storage account.
	ListKeys(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsListKeysOptions) (*StorageAccountListKeysResultResponse, error)
	// ListServiceSas - List service SAS credentials of a specific resource.
	ListServiceSas(ctx context.Context, resourceGroupName string, accountName string, parameters ServiceSasParameters, options *StorageAccountsListServiceSasOptions) (*ListServiceSasResponseResponse, error)
	// RegenerateKey - Regenerates one of the access keys or Kerberos keys for the specified storage account.
	RegenerateKey(ctx context.Context, resourceGroupName string, accountName string, regenerateKey StorageAccountRegenerateKeyParameters, options *StorageAccountsRegenerateKeyOptions) (*StorageAccountListKeysResultResponse, error)
	// BeginRestoreBlobRanges - Restore blobs in the specified blob ranges
	BeginRestoreBlobRanges(ctx context.Context, resourceGroupName string, accountName string, parameters BlobRestoreParameters, options *StorageAccountsRestoreBlobRangesOptions) (*BlobRestoreStatusPollerResponse, error)
	// ResumeRestoreBlobRanges - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeRestoreBlobRanges(token string) (BlobRestoreStatusPoller, error)
	// RevokeUserDelegationKeys - Revoke user delegation keys.
	RevokeUserDelegationKeys(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsRevokeUserDelegationKeysOptions) (*http.Response, error)
	// Update - The update operation can be used to update the SKU, encryption, access tier, or tags for a storage account. It can also be used to map the account to a custom domain. Only one custom domain is supported per storage account; the replacement/change of custom domain is not supported. In order to replace an old custom domain, the old value must be cleared/unregistered before a new value can be set. The update of multiple properties is supported. This call does not change the storage keys for the account. If you want to change the storage account keys, use the regenerate keys operation. The location and name of the storage account cannot be changed after creation.
	Update(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountUpdateParameters, options *StorageAccountsUpdateOptions) (*StorageAccountResponse, error)
}

// StorageAccountsClient implements the StorageAccountsOperations interface.
// Don't use this type directly, use NewStorageAccountsClient() instead.
type StorageAccountsClient struct {
	*Client
	subscriptionID string
}

// NewStorageAccountsClient creates a new instance of StorageAccountsClient with the specified values.
func NewStorageAccountsClient(c *Client, subscriptionID string) StorageAccountsOperations {
	return &StorageAccountsClient{Client: c, subscriptionID: subscriptionID}
}

// Do invokes the Do() method on the pipeline associated with this client.
func (client *StorageAccountsClient) Do(req *azcore.Request) (*azcore.Response, error) {
	return client.p.Do(req)
}

// CheckNameAvailability - Checks that the storage account name is valid and is not already in use.
func (client *StorageAccountsClient) CheckNameAvailability(ctx context.Context, accountName StorageAccountCheckNameAvailabilityParameters, options *StorageAccountsCheckNameAvailabilityOptions) (*CheckNameAvailabilityResultResponse, error) {
	req, err := client.CheckNameAvailabilityCreateRequest(ctx, accountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.CheckNameAvailabilityHandleError(resp)
	}
	result, err := client.CheckNameAvailabilityHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// CheckNameAvailabilityCreateRequest creates the CheckNameAvailability request.
func (client *StorageAccountsClient) CheckNameAvailabilityCreateRequest(ctx context.Context, accountName StorageAccountCheckNameAvailabilityParameters, options *StorageAccountsCheckNameAvailabilityOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/checkNameAvailability"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(accountName)
}

// CheckNameAvailabilityHandleResponse handles the CheckNameAvailability response.
func (client *StorageAccountsClient) CheckNameAvailabilityHandleResponse(resp *azcore.Response) (*CheckNameAvailabilityResultResponse, error) {
	result := CheckNameAvailabilityResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.CheckNameAvailabilityResult)
}

// CheckNameAvailabilityHandleError handles the CheckNameAvailability error response.
func (client *StorageAccountsClient) CheckNameAvailabilityHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *StorageAccountsClient) BeginCreate(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountCreateParameters, options *StorageAccountsCreateOptions) (*StorageAccountPollerResponse, error) {
	resp, err := client.Create(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &StorageAccountPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("StorageAccountsClient.Create", "", resp, client.CreateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &storageAccountPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*StorageAccountResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *StorageAccountsClient) ResumeCreate(token string) (StorageAccountPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("StorageAccountsClient.Create", token, client.CreateHandleError)
	if err != nil {
		return nil, err
	}
	return &storageAccountPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Create - Asynchronously creates a new storage account with the specified parameters. If an account is already created and a subsequent create request is issued with different properties, the account properties will be updated. If an account is already created and a subsequent create or update request is issued with the exact same set of properties, the request will succeed.
func (client *StorageAccountsClient) Create(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountCreateParameters, options *StorageAccountsCreateOptions) (*azcore.Response, error) {
	req, err := client.CreateCreateRequest(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.CreateHandleError(resp)
	}
	return resp, nil
}

// CreateCreateRequest creates the Create request.
func (client *StorageAccountsClient) CreateCreateRequest(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountCreateParameters, options *StorageAccountsCreateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// CreateHandleResponse handles the Create response.
func (client *StorageAccountsClient) CreateHandleResponse(resp *azcore.Response) (*StorageAccountResponse, error) {
	result := StorageAccountResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccount)
}

// CreateHandleError handles the Create error response.
func (client *StorageAccountsClient) CreateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// Delete - Deletes a storage account in Microsoft Azure.
func (client *StorageAccountsClient) Delete(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsDeleteOptions) (*http.Response, error) {
	req, err := client.DeleteCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.DeleteHandleError(resp)
	}
	return resp.Response, nil
}

// DeleteCreateRequest creates the Delete request.
func (client *StorageAccountsClient) DeleteCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsDeleteOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// DeleteHandleError handles the Delete error response.
func (client *StorageAccountsClient) DeleteHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *StorageAccountsClient) BeginFailover(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsFailoverOptions) (*HTTPPollerResponse, error) {
	resp, err := client.Failover(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return nil, err
	}
	result := &HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("StorageAccountsClient.Failover", "location", resp, client.FailoverHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *StorageAccountsClient) ResumeFailover(token string) (HTTPPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("StorageAccountsClient.Failover", token, client.FailoverHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// Failover - Failover request can be triggered for a storage account in case of availability issues. The failover occurs from the storage account's primary cluster to secondary cluster for RA-GRS accounts. The secondary cluster will become primary after failover.
func (client *StorageAccountsClient) Failover(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsFailoverOptions) (*azcore.Response, error) {
	req, err := client.FailoverCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.FailoverHandleError(resp)
	}
	return resp, nil
}

// FailoverCreateRequest creates the Failover request.
func (client *StorageAccountsClient) FailoverCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsFailoverOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/failover"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// FailoverHandleError handles the Failover error response.
func (client *StorageAccountsClient) FailoverHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetProperties - Returns the properties for the specified storage account including but not limited to name, SKU name, location, and account status. The ListKeys operation should be used to retrieve storage keys.
func (client *StorageAccountsClient) GetProperties(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsGetPropertiesOptions) (*StorageAccountResponse, error) {
	req, err := client.GetPropertiesCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetPropertiesHandleError(resp)
	}
	result, err := client.GetPropertiesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetPropertiesCreateRequest creates the GetProperties request.
func (client *StorageAccountsClient) GetPropertiesCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsGetPropertiesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	if options != nil && options.Expand != nil {
		query.Set("$expand", string(*options.Expand))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetPropertiesHandleResponse handles the GetProperties response.
func (client *StorageAccountsClient) GetPropertiesHandleResponse(resp *azcore.Response) (*StorageAccountResponse, error) {
	result := StorageAccountResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccount)
}

// GetPropertiesHandleError handles the GetProperties error response.
func (client *StorageAccountsClient) GetPropertiesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// List - Lists all the storage accounts available under the subscription. Note that storage keys are not returned; use the ListKeys operation for this.
func (client *StorageAccountsClient) List(options *StorageAccountsListOptions) StorageAccountListResultPager {
	return &storageAccountListResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.ListCreateRequest(ctx, options)
		},
		responder: client.ListHandleResponse,
		errorer:   client.ListHandleError,
		advancer: func(ctx context.Context, resp *StorageAccountListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.StorageAccountListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// ListCreateRequest creates the List request.
func (client *StorageAccountsClient) ListCreateRequest(ctx context.Context, options *StorageAccountsListOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/storageAccounts"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListHandleResponse handles the List response.
func (client *StorageAccountsClient) ListHandleResponse(resp *azcore.Response) (*StorageAccountListResultResponse, error) {
	result := StorageAccountListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccountListResult)
}

// ListHandleError handles the List error response.
func (client *StorageAccountsClient) ListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListAccountSas - List SAS credentials of a storage account.
func (client *StorageAccountsClient) ListAccountSas(ctx context.Context, resourceGroupName string, accountName string, parameters AccountSasParameters, options *StorageAccountsListAccountSasOptions) (*ListAccountSasResponseResponse, error) {
	req, err := client.ListAccountSasCreateRequest(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ListAccountSasHandleError(resp)
	}
	result, err := client.ListAccountSasHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ListAccountSasCreateRequest creates the ListAccountSas request.
func (client *StorageAccountsClient) ListAccountSasCreateRequest(ctx context.Context, resourceGroupName string, accountName string, parameters AccountSasParameters, options *StorageAccountsListAccountSasOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/ListAccountSas"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// ListAccountSasHandleResponse handles the ListAccountSas response.
func (client *StorageAccountsClient) ListAccountSasHandleResponse(resp *azcore.Response) (*ListAccountSasResponseResponse, error) {
	result := ListAccountSasResponseResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ListAccountSasResponse)
}

// ListAccountSasHandleError handles the ListAccountSas error response.
func (client *StorageAccountsClient) ListAccountSasHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListByResourceGroup - Lists all the storage accounts available under the given resource group. Note that storage keys are not returned; use the ListKeys operation for this.
func (client *StorageAccountsClient) ListByResourceGroup(ctx context.Context, resourceGroupName string, options *StorageAccountsListByResourceGroupOptions) (*StorageAccountListResultResponse, error) {
	req, err := client.ListByResourceGroupCreateRequest(ctx, resourceGroupName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ListByResourceGroupHandleError(resp)
	}
	result, err := client.ListByResourceGroupHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ListByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *StorageAccountsClient) ListByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *StorageAccountsListByResourceGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *StorageAccountsClient) ListByResourceGroupHandleResponse(resp *azcore.Response) (*StorageAccountListResultResponse, error) {
	result := StorageAccountListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccountListResult)
}

// ListByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *StorageAccountsClient) ListByResourceGroupHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListKeys - Lists the access keys or Kerberos keys (if active directory enabled) for the specified storage account.
func (client *StorageAccountsClient) ListKeys(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsListKeysOptions) (*StorageAccountListKeysResultResponse, error) {
	req, err := client.ListKeysCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ListKeysHandleError(resp)
	}
	result, err := client.ListKeysHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ListKeysCreateRequest creates the ListKeys request.
func (client *StorageAccountsClient) ListKeysCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsListKeysOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/listKeys"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	if options != nil && options.Expand != nil {
		query.Set("$expand", "kerb")
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ListKeysHandleResponse handles the ListKeys response.
func (client *StorageAccountsClient) ListKeysHandleResponse(resp *azcore.Response) (*StorageAccountListKeysResultResponse, error) {
	result := StorageAccountListKeysResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccountListKeysResult)
}

// ListKeysHandleError handles the ListKeys error response.
func (client *StorageAccountsClient) ListKeysHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListServiceSas - List service SAS credentials of a specific resource.
func (client *StorageAccountsClient) ListServiceSas(ctx context.Context, resourceGroupName string, accountName string, parameters ServiceSasParameters, options *StorageAccountsListServiceSasOptions) (*ListServiceSasResponseResponse, error) {
	req, err := client.ListServiceSasCreateRequest(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ListServiceSasHandleError(resp)
	}
	result, err := client.ListServiceSasHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ListServiceSasCreateRequest creates the ListServiceSas request.
func (client *StorageAccountsClient) ListServiceSasCreateRequest(ctx context.Context, resourceGroupName string, accountName string, parameters ServiceSasParameters, options *StorageAccountsListServiceSasOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/ListServiceSas"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// ListServiceSasHandleResponse handles the ListServiceSas response.
func (client *StorageAccountsClient) ListServiceSasHandleResponse(resp *azcore.Response) (*ListServiceSasResponseResponse, error) {
	result := ListServiceSasResponseResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ListServiceSasResponse)
}

// ListServiceSasHandleError handles the ListServiceSas error response.
func (client *StorageAccountsClient) ListServiceSasHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// RegenerateKey - Regenerates one of the access keys or Kerberos keys for the specified storage account.
func (client *StorageAccountsClient) RegenerateKey(ctx context.Context, resourceGroupName string, accountName string, regenerateKey StorageAccountRegenerateKeyParameters, options *StorageAccountsRegenerateKeyOptions) (*StorageAccountListKeysResultResponse, error) {
	req, err := client.RegenerateKeyCreateRequest(ctx, resourceGroupName, accountName, regenerateKey, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.RegenerateKeyHandleError(resp)
	}
	result, err := client.RegenerateKeyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// RegenerateKeyCreateRequest creates the RegenerateKey request.
func (client *StorageAccountsClient) RegenerateKeyCreateRequest(ctx context.Context, resourceGroupName string, accountName string, regenerateKey StorageAccountRegenerateKeyParameters, options *StorageAccountsRegenerateKeyOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/regenerateKey"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(regenerateKey)
}

// RegenerateKeyHandleResponse handles the RegenerateKey response.
func (client *StorageAccountsClient) RegenerateKeyHandleResponse(resp *azcore.Response) (*StorageAccountListKeysResultResponse, error) {
	result := StorageAccountListKeysResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccountListKeysResult)
}

// RegenerateKeyHandleError handles the RegenerateKey error response.
func (client *StorageAccountsClient) RegenerateKeyHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *StorageAccountsClient) BeginRestoreBlobRanges(ctx context.Context, resourceGroupName string, accountName string, parameters BlobRestoreParameters, options *StorageAccountsRestoreBlobRangesOptions) (*BlobRestoreStatusPollerResponse, error) {
	resp, err := client.RestoreBlobRanges(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	result := &BlobRestoreStatusPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("StorageAccountsClient.RestoreBlobRanges", "location", resp, client.RestoreBlobRangesHandleError)
	if err != nil {
		return nil, err
	}
	poller := &blobRestoreStatusPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*BlobRestoreStatusResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *StorageAccountsClient) ResumeRestoreBlobRanges(token string) (BlobRestoreStatusPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("StorageAccountsClient.RestoreBlobRanges", token, client.RestoreBlobRangesHandleError)
	if err != nil {
		return nil, err
	}
	return &blobRestoreStatusPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// RestoreBlobRanges - Restore blobs in the specified blob ranges
func (client *StorageAccountsClient) RestoreBlobRanges(ctx context.Context, resourceGroupName string, accountName string, parameters BlobRestoreParameters, options *StorageAccountsRestoreBlobRangesOptions) (*azcore.Response, error) {
	req, err := client.RestoreBlobRangesCreateRequest(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.RestoreBlobRangesHandleError(resp)
	}
	return resp, nil
}

// RestoreBlobRangesCreateRequest creates the RestoreBlobRanges request.
func (client *StorageAccountsClient) RestoreBlobRangesCreateRequest(ctx context.Context, resourceGroupName string, accountName string, parameters BlobRestoreParameters, options *StorageAccountsRestoreBlobRangesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/restoreBlobRanges"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// RestoreBlobRangesHandleResponse handles the RestoreBlobRanges response.
func (client *StorageAccountsClient) RestoreBlobRangesHandleResponse(resp *azcore.Response) (*BlobRestoreStatusResponse, error) {
	result := BlobRestoreStatusResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.BlobRestoreStatus)
}

// RestoreBlobRangesHandleError handles the RestoreBlobRanges error response.
func (client *StorageAccountsClient) RestoreBlobRangesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// RevokeUserDelegationKeys - Revoke user delegation keys.
func (client *StorageAccountsClient) RevokeUserDelegationKeys(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsRevokeUserDelegationKeysOptions) (*http.Response, error) {
	req, err := client.RevokeUserDelegationKeysCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.RevokeUserDelegationKeysHandleError(resp)
	}
	return resp.Response, nil
}

// RevokeUserDelegationKeysCreateRequest creates the RevokeUserDelegationKeys request.
func (client *StorageAccountsClient) RevokeUserDelegationKeysCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *StorageAccountsRevokeUserDelegationKeysOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/revokeUserDelegationKeys"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// RevokeUserDelegationKeysHandleError handles the RevokeUserDelegationKeys error response.
func (client *StorageAccountsClient) RevokeUserDelegationKeysHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// Update - The update operation can be used to update the SKU, encryption, access tier, or tags for a storage account. It can also be used to map the account to a custom domain. Only one custom domain is supported per storage account; the replacement/change of custom domain is not supported. In order to replace an old custom domain, the old value must be cleared/unregistered before a new value can be set. The update of multiple properties is supported. This call does not change the storage keys for the account. If you want to change the storage account keys, use the regenerate keys operation. The location and name of the storage account cannot be changed after creation.
func (client *StorageAccountsClient) Update(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountUpdateParameters, options *StorageAccountsUpdateOptions) (*StorageAccountResponse, error) {
	req, err := client.UpdateCreateRequest(ctx, resourceGroupName, accountName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.UpdateHandleError(resp)
	}
	result, err := client.UpdateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateCreateRequest creates the Update request.
func (client *StorageAccountsClient) UpdateCreateRequest(ctx context.Context, resourceGroupName string, accountName string, parameters StorageAccountUpdateParameters, options *StorageAccountsUpdateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api-version", "2019-06-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// UpdateHandleResponse handles the Update response.
func (client *StorageAccountsClient) UpdateHandleResponse(resp *azcore.Response) (*StorageAccountResponse, error) {
	result := StorageAccountResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.StorageAccount)
}

// UpdateHandleError handles the Update error response.
func (client *StorageAccountsClient) UpdateHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}
