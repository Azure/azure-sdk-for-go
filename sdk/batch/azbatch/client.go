// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package azbatch

import (
	"context"
	"errors"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// Client contains the methods for the group.
// Don't use this type directly, use a constructor function instead.
type Client struct {
	internal *azcore.Client
	endpoint string
}

// CreateJob - Creates a Job to the specified Account.
//
// The Batch service supports two ways to control the work done as part of a Job.
// In the first approach, the user specifies a Job Manager Task. The Batch service
// launches this Task when it is ready to start the Job. The Job Manager Task
// controls all other Tasks that run under this Job, by using the Task APIs. In
// the second approach, the user directly controls the execution of Tasks under an
// active Job, by using the Task APIs. Also note: when naming Jobs, avoid
// including sensitive information such as user names or secret project names.
// This information may appear in telemetry logs accessible to Microsoft Support
// engineers.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - job - The Job to be created.
//   - options - CreateJobOptions contains the optional parameters for the Client.CreateJob method.
func (client *Client) CreateJob(ctx context.Context, job CreateJobContent, options *CreateJobOptions) (CreateJobResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.CreateJob", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createJobCreateRequest(ctx, job, options)
	if err != nil {
		return CreateJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return CreateJobResponse{}, err
	}
	resp, err := client.createJobHandleResponse(httpResp)
	return resp, err
}

// createJobCreateRequest creates the CreateJob request.
func (client *Client) createJobCreateRequest(ctx context.Context, job CreateJobContent, options *CreateJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, job); err != nil {
		return nil, err
	}
	return req, nil
}

// createJobHandleResponse handles the CreateJob response.
func (client *Client) createJobHandleResponse(resp *http.Response) (CreateJobResponse, error) {
	result := CreateJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return CreateJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// CreateJobSchedule - Creates a Job Schedule to the specified Account.
//
// Creates a Job Schedule to the specified Account.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobSchedule - The Job Schedule to be created.
//   - options - CreateJobScheduleOptions contains the optional parameters for the Client.CreateJobSchedule method.
func (client *Client) CreateJobSchedule(ctx context.Context, jobSchedule CreateJobScheduleContent, options *CreateJobScheduleOptions) (CreateJobScheduleResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.CreateJobSchedule", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createJobScheduleCreateRequest(ctx, jobSchedule, options)
	if err != nil {
		return CreateJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return CreateJobScheduleResponse{}, err
	}
	resp, err := client.createJobScheduleHandleResponse(httpResp)
	return resp, err
}

// createJobScheduleCreateRequest creates the CreateJobSchedule request.
func (client *Client) createJobScheduleCreateRequest(ctx context.Context, jobSchedule CreateJobScheduleContent, options *CreateJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, jobSchedule); err != nil {
		return nil, err
	}
	return req, nil
}

// createJobScheduleHandleResponse handles the CreateJobSchedule response.
func (client *Client) createJobScheduleHandleResponse(resp *http.Response) (CreateJobScheduleResponse, error) {
	result := CreateJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return CreateJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// CreateNodeUser - Adds a user Account to the specified Compute Node.
//
// You can add a user Account to a Compute Node only when it is in the idle or
// running state.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the machine on which you want to create a user Account.
//   - userParam - The options to use for creating the user.
//   - options - CreateNodeUserOptions contains the optional parameters for the Client.CreateNodeUser method.
func (client *Client) CreateNodeUser(ctx context.Context, poolID string, nodeID string, userParam CreateNodeUserContent, options *CreateNodeUserOptions) (CreateNodeUserResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.CreateNodeUser", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createNodeUserCreateRequest(ctx, poolID, nodeID, userParam, options)
	if err != nil {
		return CreateNodeUserResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateNodeUserResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return CreateNodeUserResponse{}, err
	}
	resp, err := client.createNodeUserHandleResponse(httpResp)
	return resp, err
}

// createNodeUserCreateRequest creates the CreateNodeUser request.
func (client *Client) createNodeUserCreateRequest(ctx context.Context, poolID string, nodeID string, userParam CreateNodeUserContent, options *CreateNodeUserOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/users"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, userParam); err != nil {
		return nil, err
	}
	return req, nil
}

// createNodeUserHandleResponse handles the CreateNodeUser response.
func (client *Client) createNodeUserHandleResponse(resp *http.Response) (CreateNodeUserResponse, error) {
	result := CreateNodeUserResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return CreateNodeUserResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// CreatePool - Creates a Pool to the specified Account.
//
// When naming Pools, avoid including sensitive information such as user names or
// secret project names. This information may appear in telemetry logs accessible
// to Microsoft Support engineers.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - pool - The Pool to be created.
//   - options - CreatePoolOptions contains the optional parameters for the Client.CreatePool method.
func (client *Client) CreatePool(ctx context.Context, pool CreatePoolContent, options *CreatePoolOptions) (CreatePoolResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.CreatePool", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createPoolCreateRequest(ctx, pool, options)
	if err != nil {
		return CreatePoolResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreatePoolResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return CreatePoolResponse{}, err
	}
	resp, err := client.createPoolHandleResponse(httpResp)
	return resp, err
}

// createPoolCreateRequest creates the CreatePool request.
func (client *Client) createPoolCreateRequest(ctx context.Context, pool CreatePoolContent, options *CreatePoolOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, pool); err != nil {
		return nil, err
	}
	return req, nil
}

// createPoolHandleResponse handles the CreatePool response.
func (client *Client) createPoolHandleResponse(resp *http.Response) (CreatePoolResponse, error) {
	result := CreatePoolResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return CreatePoolResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// CreateTask - Creates a Task to the specified Job.
//
// The maximum lifetime of a Task from addition to completion is 180 days. If a
// Task has not completed within 180 days of being added it will be terminated by
// the Batch service and left in whatever state it was in at that time.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job to which the Task is to be created.
//   - task - The Task to be created.
//   - options - CreateTaskOptions contains the optional parameters for the Client.CreateTask method.
func (client *Client) CreateTask(ctx context.Context, jobID string, task CreateTaskContent, options *CreateTaskOptions) (CreateTaskResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.CreateTask", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createTaskCreateRequest(ctx, jobID, task, options)
	if err != nil {
		return CreateTaskResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateTaskResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return CreateTaskResponse{}, err
	}
	resp, err := client.createTaskHandleResponse(httpResp)
	return resp, err
}

// createTaskCreateRequest creates the CreateTask request.
func (client *Client) createTaskCreateRequest(ctx context.Context, jobID string, task CreateTaskContent, options *CreateTaskOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, task); err != nil {
		return nil, err
	}
	return req, nil
}

// createTaskHandleResponse handles the CreateTask response.
func (client *Client) createTaskHandleResponse(resp *http.Response) (CreateTaskResponse, error) {
	result := CreateTaskResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return CreateTaskResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// CreateTaskCollection - Adds a collection of Tasks to the specified Job.
//
// Note that each Task must have a unique ID. The Batch service may not return the
// results for each Task in the same order the Tasks were submitted in this
// request. If the server times out or the connection is closed during the
// request, the request may have been partially or fully processed, or not at all.
// In such cases, the user should re-issue the request. Note that it is up to the
// user to correctly handle failures when re-issuing a request. For example, you
// should use the same Task IDs during a retry so that if the prior operation
// succeeded, the retry will not create extra Tasks unexpectedly. If the response
// contains any Tasks which failed to add, a client can retry the request. In a
// retry, it is most efficient to resubmit only Tasks that failed to add, and to
// omit Tasks that were successfully added on the first attempt. The maximum
// lifetime of a Task from addition to completion is 180 days. If a Task has not
// completed within 180 days of being added it will be terminated by the Batch
// service and left in whatever state it was in at that time.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job to which the Task collection is to be added.
//   - taskCollection - The Tasks to be added.
//   - options - CreateTaskCollectionOptions contains the optional parameters for the Client.CreateTaskCollection method.
func (client *Client) CreateTaskCollection(ctx context.Context, jobID string, taskCollection TaskGroup, options *CreateTaskCollectionOptions) (CreateTaskCollectionResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.CreateTaskCollection", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createTaskCollectionCreateRequest(ctx, jobID, taskCollection, options)
	if err != nil {
		return CreateTaskCollectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateTaskCollectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return CreateTaskCollectionResponse{}, err
	}
	resp, err := client.createTaskCollectionHandleResponse(httpResp)
	return resp, err
}

// createTaskCollectionCreateRequest creates the CreateTaskCollection request.
func (client *Client) createTaskCollectionCreateRequest(ctx context.Context, jobID string, taskCollection TaskGroup, options *CreateTaskCollectionOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/addtaskcollection"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, taskCollection); err != nil {
		return nil, err
	}
	return req, nil
}

// createTaskCollectionHandleResponse handles the CreateTaskCollection response.
func (client *Client) createTaskCollectionHandleResponse(resp *http.Response) (CreateTaskCollectionResponse, error) {
	result := CreateTaskCollectionResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return CreateTaskCollectionResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.AddTaskCollectionResult); err != nil {
		return CreateTaskCollectionResponse{}, err
	}
	return result, nil
}

// DeallocateNode - Deallocates the specified Compute Node.
//
// You can deallocate a Compute Node only if it is in an idle or running state.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node that you want to restart.
//   - options - DeallocateNodeOptions contains the optional parameters for the Client.DeallocateNode method.
func (client *Client) DeallocateNode(ctx context.Context, poolID string, nodeID string, options *DeallocateNodeOptions) (DeallocateNodeResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.DeallocateNode", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deallocateNodeCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return DeallocateNodeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeallocateNodeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return DeallocateNodeResponse{}, err
	}
	resp, err := client.deallocateNodeHandleResponse(httpResp)
	return resp, err
}

// deallocateNodeCreateRequest creates the DeallocateNode request.
func (client *Client) deallocateNodeCreateRequest(ctx context.Context, poolID string, nodeID string, options *DeallocateNodeOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/deallocate"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if options != nil && options.Parameters != nil {
		req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
		if err := runtime.MarshalAsJSON(req, *options.Parameters); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// deallocateNodeHandleResponse handles the DeallocateNode response.
func (client *Client) deallocateNodeHandleResponse(resp *http.Response) (DeallocateNodeResponse, error) {
	result := DeallocateNodeResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DeallocateNodeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeleteJob - Deletes a Job.
//
// Deleting a Job also deletes all Tasks that are part of that Job, and all Job
// statistics. This also overrides the retention period for Task data; that is, if
// the Job contains Tasks which are still retained on Compute Nodes, the Batch
// services deletes those Tasks' working directories and all their contents. When
// a Delete Job request is received, the Batch service sets the Job to the
// deleting state. All update operations on a Job that is in deleting state will
// fail with status code 409 (Conflict), with additional information indicating
// that the Job is being deleted.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job to delete.
//   - options - DeleteJobOptions contains the optional parameters for the Client.DeleteJob method.
func (client *Client) DeleteJob(ctx context.Context, jobID string, options *DeleteJobOptions) (DeleteJobResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.DeleteJob", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteJobCreateRequest(ctx, jobID, options)
	if err != nil {
		return DeleteJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return DeleteJobResponse{}, err
	}
	resp, err := client.deleteJobHandleResponse(httpResp)
	return resp, err
}

// deleteJobCreateRequest creates the DeleteJob request.
func (client *Client) deleteJobCreateRequest(ctx context.Context, jobID string, options *DeleteJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Force != nil {
		reqQP.Set("force", strconv.FormatBool(*options.Force))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteJobHandleResponse handles the DeleteJob response.
func (client *Client) deleteJobHandleResponse(resp *http.Response) (DeleteJobResponse, error) {
	result := DeleteJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeleteJobSchedule - Deletes a Job Schedule from the specified Account.
//
// When you delete a Job Schedule, this also deletes all Jobs and Tasks under that
// schedule. When Tasks are deleted, all the files in their working directories on
// the Compute Nodes are also deleted (the retention period is ignored). The Job
// Schedule statistics are no longer accessible once the Job Schedule is deleted,
// though they are still counted towards Account lifetime statistics.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobScheduleID - The ID of the Job Schedule to delete.
//   - options - DeleteJobScheduleOptions contains the optional parameters for the Client.DeleteJobSchedule method.
func (client *Client) DeleteJobSchedule(ctx context.Context, jobScheduleID string, options *DeleteJobScheduleOptions) (DeleteJobScheduleResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.DeleteJobSchedule", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteJobScheduleCreateRequest(ctx, jobScheduleID, options)
	if err != nil {
		return DeleteJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return DeleteJobScheduleResponse{}, err
	}
	resp, err := client.deleteJobScheduleHandleResponse(httpResp)
	return resp, err
}

// deleteJobScheduleCreateRequest creates the DeleteJobSchedule request.
func (client *Client) deleteJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, options *DeleteJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Force != nil {
		reqQP.Set("force", strconv.FormatBool(*options.Force))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteJobScheduleHandleResponse handles the DeleteJobSchedule response.
func (client *Client) deleteJobScheduleHandleResponse(resp *http.Response) (DeleteJobScheduleResponse, error) {
	result := DeleteJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeleteNodeFile - Deletes the specified file from the Compute Node.
//
// Deletes the specified file from the Compute Node.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node.
//   - filePath - The path to the file or directory.
//   - options - DeleteNodeFileOptions contains the optional parameters for the Client.DeleteNodeFile method.
func (client *Client) DeleteNodeFile(ctx context.Context, poolID string, nodeID string, filePath string, options *DeleteNodeFileOptions) (DeleteNodeFileResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.DeleteNodeFile", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteNodeFileCreateRequest(ctx, poolID, nodeID, filePath, options)
	if err != nil {
		return DeleteNodeFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteNodeFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeleteNodeFileResponse{}, err
	}
	resp, err := client.deleteNodeFileHandleResponse(httpResp)
	return resp, err
}

// deleteNodeFileCreateRequest creates the DeleteNodeFile request.
func (client *Client) deleteNodeFileCreateRequest(ctx context.Context, poolID string, nodeID string, filePath string, options *DeleteNodeFileOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/files/{filePath}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	if filePath == "" {
		return nil, errors.New("parameter filePath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{filePath}", url.PathEscape(filePath))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Recursive != nil {
		reqQP.Set("recursive", strconv.FormatBool(*options.Recursive))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteNodeFileHandleResponse handles the DeleteNodeFile response.
func (client *Client) deleteNodeFileHandleResponse(resp *http.Response) (DeleteNodeFileResponse, error) {
	result := DeleteNodeFileResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeleteNodeUser - Deletes a user Account from the specified Compute Node.
//
// You can delete a user Account to a Compute Node only when it is in the idle or
// running state.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the machine on which you want to delete a user Account.
//   - userName - The name of the user Account to delete.
//   - options - DeleteNodeUserOptions contains the optional parameters for the Client.DeleteNodeUser method.
func (client *Client) DeleteNodeUser(ctx context.Context, poolID string, nodeID string, userName string, options *DeleteNodeUserOptions) (DeleteNodeUserResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.DeleteNodeUser", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteNodeUserCreateRequest(ctx, poolID, nodeID, userName, options)
	if err != nil {
		return DeleteNodeUserResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteNodeUserResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeleteNodeUserResponse{}, err
	}
	resp, err := client.deleteNodeUserHandleResponse(httpResp)
	return resp, err
}

// deleteNodeUserCreateRequest creates the DeleteNodeUser request.
func (client *Client) deleteNodeUserCreateRequest(ctx context.Context, poolID string, nodeID string, userName string, options *DeleteNodeUserOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/users/{userName}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	if userName == "" {
		return nil, errors.New("parameter userName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userName}", url.PathEscape(userName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteNodeUserHandleResponse handles the DeleteNodeUser response.
func (client *Client) deleteNodeUserHandleResponse(resp *http.Response) (DeleteNodeUserResponse, error) {
	result := DeleteNodeUserResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeletePool - Deletes a Pool from the specified Account.
//
// When you request that a Pool be deleted, the following actions occur: the Pool
// state is set to deleting; any ongoing resize operation on the Pool are stopped;
// the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks
// running on existing Compute Nodes are terminated and requeued (as if a resize
// Pool operation had been requested with the default requeue option); finally,
// the Pool is removed from the system. Because running Tasks are requeued, the
// user can rerun these Tasks by updating their Job to target a different Pool.
// The Tasks can then run on the new Pool. If you want to override the requeue
// behavior, then you should call resize Pool explicitly to shrink the Pool to
// zero size before deleting the Pool. If you call an Update, Patch or Delete API
// on a Pool in the deleting state, it will fail with HTTP status code 409 with
// error code PoolBeingDeleted.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool to get.
//   - options - DeletePoolOptions contains the optional parameters for the Client.DeletePool method.
func (client *Client) DeletePool(ctx context.Context, poolID string, options *DeletePoolOptions) (DeletePoolResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.DeletePool", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deletePoolCreateRequest(ctx, poolID, options)
	if err != nil {
		return DeletePoolResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeletePoolResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return DeletePoolResponse{}, err
	}
	resp, err := client.deletePoolHandleResponse(httpResp)
	return resp, err
}

// deletePoolCreateRequest creates the DeletePool request.
func (client *Client) deletePoolCreateRequest(ctx context.Context, poolID string, options *DeletePoolOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deletePoolHandleResponse handles the DeletePool response.
func (client *Client) deletePoolHandleResponse(resp *http.Response) (DeletePoolResponse, error) {
	result := DeletePoolResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeleteTask - Deletes a Task from the specified Job.
//
// When a Task is deleted, all of the files in its directory on the Compute Node
// where it ran are also deleted (regardless of the retention time). For
// multi-instance Tasks, the delete Task operation applies synchronously to the
// primary task; subtasks and their files are then deleted asynchronously in the
// background.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job from which to delete the Task.
//   - taskID - The ID of the Task to delete.
//   - options - DeleteTaskOptions contains the optional parameters for the Client.DeleteTask method.
func (client *Client) DeleteTask(ctx context.Context, jobID string, taskID string, options *DeleteTaskOptions) (DeleteTaskResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.DeleteTask", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteTaskCreateRequest(ctx, jobID, taskID, options)
	if err != nil {
		return DeleteTaskResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteTaskResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeleteTaskResponse{}, err
	}
	resp, err := client.deleteTaskHandleResponse(httpResp)
	return resp, err
}

// deleteTaskCreateRequest creates the DeleteTask request.
func (client *Client) deleteTaskCreateRequest(ctx context.Context, jobID string, taskID string, options *DeleteTaskOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteTaskHandleResponse handles the DeleteTask response.
func (client *Client) deleteTaskHandleResponse(resp *http.Response) (DeleteTaskResponse, error) {
	result := DeleteTaskResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeleteTaskFile - Deletes the specified Task file from the Compute Node where the Task ran.
//
// Deletes the specified Task file from the Compute Node where the Task ran.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job that contains the Task.
//   - taskID - The ID of the Task whose file you want to retrieve.
//   - filePath - The path to the Task file that you want to get the content of.
//   - options - DeleteTaskFileOptions contains the optional parameters for the Client.DeleteTaskFile method.
func (client *Client) DeleteTaskFile(ctx context.Context, jobID string, taskID string, filePath string, options *DeleteTaskFileOptions) (DeleteTaskFileResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.DeleteTaskFile", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteTaskFileCreateRequest(ctx, jobID, taskID, filePath, options)
	if err != nil {
		return DeleteTaskFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteTaskFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeleteTaskFileResponse{}, err
	}
	resp, err := client.deleteTaskFileHandleResponse(httpResp)
	return resp, err
}

// deleteTaskFileCreateRequest creates the DeleteTaskFile request.
func (client *Client) deleteTaskFileCreateRequest(ctx context.Context, jobID string, taskID string, filePath string, options *DeleteTaskFileOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/files/{filePath}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	if filePath == "" {
		return nil, errors.New("parameter filePath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{filePath}", url.PathEscape(filePath))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Recursive != nil {
		reqQP.Set("recursive", strconv.FormatBool(*options.Recursive))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteTaskFileHandleResponse handles the DeleteTaskFile response.
func (client *Client) deleteTaskFileHandleResponse(resp *http.Response) (DeleteTaskFileResponse, error) {
	result := DeleteTaskFileResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DisableJob - Disables the specified Job, preventing new Tasks from running.
//
// The Batch Service immediately moves the Job to the disabling state. Batch then
// uses the disableTasks parameter to determine what to do with the currently
// running Tasks of the Job. The Job remains in the disabling state until the
// disable operation is completed and all Tasks have been dealt with according to
// the disableTasks option; the Job then moves to the disabled state. No new Tasks
// are started under the Job until it moves back to active state. If you try to
// disable a Job that is in any state other than active, disabling, or disabled,
// the request fails with status code 409.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job to disable.
//   - content - The options to use for disabling the Job.
//   - options - DisableJobOptions contains the optional parameters for the Client.DisableJob method.
func (client *Client) DisableJob(ctx context.Context, jobID string, content DisableJobContent, options *DisableJobOptions) (DisableJobResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.DisableJob", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.disableJobCreateRequest(ctx, jobID, content, options)
	if err != nil {
		return DisableJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DisableJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return DisableJobResponse{}, err
	}
	resp, err := client.disableJobHandleResponse(httpResp)
	return resp, err
}

// disableJobCreateRequest creates the DisableJob request.
func (client *Client) disableJobCreateRequest(ctx context.Context, jobID string, content DisableJobContent, options *DisableJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/disable"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
		return nil, err
	}
	return req, nil
}

// disableJobHandleResponse handles the DisableJob response.
func (client *Client) disableJobHandleResponse(resp *http.Response) (DisableJobResponse, error) {
	result := DisableJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DisableJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DisableJobSchedule - Disables a Job Schedule.
//
// No new Jobs will be created until the Job Schedule is enabled again.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobScheduleID - The ID of the Job Schedule to disable.
//   - options - DisableJobScheduleOptions contains the optional parameters for the Client.DisableJobSchedule method.
func (client *Client) DisableJobSchedule(ctx context.Context, jobScheduleID string, options *DisableJobScheduleOptions) (DisableJobScheduleResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.DisableJobSchedule", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.disableJobScheduleCreateRequest(ctx, jobScheduleID, options)
	if err != nil {
		return DisableJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DisableJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return DisableJobScheduleResponse{}, err
	}
	resp, err := client.disableJobScheduleHandleResponse(httpResp)
	return resp, err
}

// disableJobScheduleCreateRequest creates the DisableJobSchedule request.
func (client *Client) disableJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, options *DisableJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}/disable"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// disableJobScheduleHandleResponse handles the DisableJobSchedule response.
func (client *Client) disableJobScheduleHandleResponse(resp *http.Response) (DisableJobScheduleResponse, error) {
	result := DisableJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DisableJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DisableNodeScheduling - Disables Task scheduling on the specified Compute Node.
//
// You can disable Task scheduling on a Compute Node only if its current
// scheduling state is enabled.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node on which you want to disable Task scheduling.
//   - options - DisableNodeSchedulingOptions contains the optional parameters for the Client.DisableNodeScheduling method.
func (client *Client) DisableNodeScheduling(ctx context.Context, poolID string, nodeID string, options *DisableNodeSchedulingOptions) (DisableNodeSchedulingResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.DisableNodeScheduling", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.disableNodeSchedulingCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return DisableNodeSchedulingResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DisableNodeSchedulingResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DisableNodeSchedulingResponse{}, err
	}
	resp, err := client.disableNodeSchedulingHandleResponse(httpResp)
	return resp, err
}

// disableNodeSchedulingCreateRequest creates the DisableNodeScheduling request.
func (client *Client) disableNodeSchedulingCreateRequest(ctx context.Context, poolID string, nodeID string, options *DisableNodeSchedulingOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/disablescheduling"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if options != nil && options.Parameters != nil {
		req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
		if err := runtime.MarshalAsJSON(req, *options.Parameters); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// disableNodeSchedulingHandleResponse handles the DisableNodeScheduling response.
func (client *Client) disableNodeSchedulingHandleResponse(resp *http.Response) (DisableNodeSchedulingResponse, error) {
	result := DisableNodeSchedulingResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DisableNodeSchedulingResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DisablePoolAutoScale - Disables automatic scaling for a Pool.
//
// Disables automatic scaling for a Pool.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool on which to disable automatic scaling.
//   - options - DisablePoolAutoScaleOptions contains the optional parameters for the Client.DisablePoolAutoScale method.
func (client *Client) DisablePoolAutoScale(ctx context.Context, poolID string, options *DisablePoolAutoScaleOptions) (DisablePoolAutoScaleResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.DisablePoolAutoScale", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.disablePoolAutoScaleCreateRequest(ctx, poolID, options)
	if err != nil {
		return DisablePoolAutoScaleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DisablePoolAutoScaleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DisablePoolAutoScaleResponse{}, err
	}
	resp, err := client.disablePoolAutoScaleHandleResponse(httpResp)
	return resp, err
}

// disablePoolAutoScaleCreateRequest creates the DisablePoolAutoScale request.
func (client *Client) disablePoolAutoScaleCreateRequest(ctx context.Context, poolID string, options *DisablePoolAutoScaleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/disableautoscale"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// disablePoolAutoScaleHandleResponse handles the DisablePoolAutoScale response.
func (client *Client) disablePoolAutoScaleHandleResponse(resp *http.Response) (DisablePoolAutoScaleResponse, error) {
	result := DisablePoolAutoScaleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DisablePoolAutoScaleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// EnableJob - Enables the specified Job, allowing new Tasks to run.
//
// When you call this API, the Batch service sets a disabled Job to the enabling
// state. After the this operation is completed, the Job moves to the active
// state, and scheduling of new Tasks under the Job resumes. The Batch service
// does not allow a Task to remain in the active state for more than 180 days.
// Therefore, if you enable a Job containing active Tasks which were added more
// than 180 days ago, those Tasks will not run.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job to enable.
//   - options - EnableJobOptions contains the optional parameters for the Client.EnableJob method.
func (client *Client) EnableJob(ctx context.Context, jobID string, options *EnableJobOptions) (EnableJobResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.EnableJob", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.enableJobCreateRequest(ctx, jobID, options)
	if err != nil {
		return EnableJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return EnableJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return EnableJobResponse{}, err
	}
	resp, err := client.enableJobHandleResponse(httpResp)
	return resp, err
}

// enableJobCreateRequest creates the EnableJob request.
func (client *Client) enableJobCreateRequest(ctx context.Context, jobID string, options *EnableJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/enable"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// enableJobHandleResponse handles the EnableJob response.
func (client *Client) enableJobHandleResponse(resp *http.Response) (EnableJobResponse, error) {
	result := EnableJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return EnableJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// EnableJobSchedule - Enables a Job Schedule.
//
// Enables a Job Schedule.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobScheduleID - The ID of the Job Schedule to enable.
//   - options - EnableJobScheduleOptions contains the optional parameters for the Client.EnableJobSchedule method.
func (client *Client) EnableJobSchedule(ctx context.Context, jobScheduleID string, options *EnableJobScheduleOptions) (EnableJobScheduleResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.EnableJobSchedule", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.enableJobScheduleCreateRequest(ctx, jobScheduleID, options)
	if err != nil {
		return EnableJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return EnableJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return EnableJobScheduleResponse{}, err
	}
	resp, err := client.enableJobScheduleHandleResponse(httpResp)
	return resp, err
}

// enableJobScheduleCreateRequest creates the EnableJobSchedule request.
func (client *Client) enableJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, options *EnableJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}/enable"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// enableJobScheduleHandleResponse handles the EnableJobSchedule response.
func (client *Client) enableJobScheduleHandleResponse(resp *http.Response) (EnableJobScheduleResponse, error) {
	result := EnableJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return EnableJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// EnableNodeScheduling - Enables Task scheduling on the specified Compute Node.
//
// You can enable Task scheduling on a Compute Node only if its current scheduling
// state is disabled
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node on which you want to enable Task scheduling.
//   - options - EnableNodeSchedulingOptions contains the optional parameters for the Client.EnableNodeScheduling method.
func (client *Client) EnableNodeScheduling(ctx context.Context, poolID string, nodeID string, options *EnableNodeSchedulingOptions) (EnableNodeSchedulingResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.EnableNodeScheduling", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.enableNodeSchedulingCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return EnableNodeSchedulingResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return EnableNodeSchedulingResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return EnableNodeSchedulingResponse{}, err
	}
	resp, err := client.enableNodeSchedulingHandleResponse(httpResp)
	return resp, err
}

// enableNodeSchedulingCreateRequest creates the EnableNodeScheduling request.
func (client *Client) enableNodeSchedulingCreateRequest(ctx context.Context, poolID string, nodeID string, options *EnableNodeSchedulingOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/enablescheduling"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// enableNodeSchedulingHandleResponse handles the EnableNodeScheduling response.
func (client *Client) enableNodeSchedulingHandleResponse(resp *http.Response) (EnableNodeSchedulingResponse, error) {
	result := EnableNodeSchedulingResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return EnableNodeSchedulingResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// EnablePoolAutoScale - Enables automatic scaling for a Pool.
//
// You cannot enable automatic scaling on a Pool if a resize operation is in
// progress on the Pool. If automatic scaling of the Pool is currently disabled,
// you must specify a valid autoscale formula as part of the request. If automatic
// scaling of the Pool is already enabled, you may specify a new autoscale formula
// and/or a new evaluation interval. You cannot call this API for the same Pool
// more than once every 30 seconds.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool to get.
//   - content - The options to use for enabling automatic scaling.
//   - options - EnablePoolAutoScaleOptions contains the optional parameters for the Client.EnablePoolAutoScale method.
func (client *Client) EnablePoolAutoScale(ctx context.Context, poolID string, content EnablePoolAutoScaleContent, options *EnablePoolAutoScaleOptions) (EnablePoolAutoScaleResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.EnablePoolAutoScale", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.enablePoolAutoScaleCreateRequest(ctx, poolID, content, options)
	if err != nil {
		return EnablePoolAutoScaleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return EnablePoolAutoScaleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return EnablePoolAutoScaleResponse{}, err
	}
	resp, err := client.enablePoolAutoScaleHandleResponse(httpResp)
	return resp, err
}

// enablePoolAutoScaleCreateRequest creates the EnablePoolAutoScale request.
func (client *Client) enablePoolAutoScaleCreateRequest(ctx context.Context, poolID string, content EnablePoolAutoScaleContent, options *EnablePoolAutoScaleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/enableautoscale"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
		return nil, err
	}
	return req, nil
}

// enablePoolAutoScaleHandleResponse handles the EnablePoolAutoScale response.
func (client *Client) enablePoolAutoScaleHandleResponse(resp *http.Response) (EnablePoolAutoScaleResponse, error) {
	result := EnablePoolAutoScaleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return EnablePoolAutoScaleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// EvaluatePoolAutoScale - Gets the result of evaluating an automatic scaling formula on the Pool.
//
// This API is primarily for validating an autoscale formula, as it simply returns
// the result without applying the formula to the Pool. The Pool must have auto
// scaling enabled in order to evaluate a formula.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool on which to evaluate the automatic scaling formula.
//   - content - The options to use for evaluating the automatic scaling formula.
//   - options - EvaluatePoolAutoScaleOptions contains the optional parameters for the Client.EvaluatePoolAutoScale method.
func (client *Client) EvaluatePoolAutoScale(ctx context.Context, poolID string, content EvaluatePoolAutoScaleContent, options *EvaluatePoolAutoScaleOptions) (EvaluatePoolAutoScaleResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.EvaluatePoolAutoScale", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.evaluatePoolAutoScaleCreateRequest(ctx, poolID, content, options)
	if err != nil {
		return EvaluatePoolAutoScaleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return EvaluatePoolAutoScaleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return EvaluatePoolAutoScaleResponse{}, err
	}
	resp, err := client.evaluatePoolAutoScaleHandleResponse(httpResp)
	return resp, err
}

// evaluatePoolAutoScaleCreateRequest creates the EvaluatePoolAutoScale request.
func (client *Client) evaluatePoolAutoScaleCreateRequest(ctx context.Context, poolID string, content EvaluatePoolAutoScaleContent, options *EvaluatePoolAutoScaleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/evaluateautoscale"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
		return nil, err
	}
	return req, nil
}

// evaluatePoolAutoScaleHandleResponse handles the EvaluatePoolAutoScale response.
func (client *Client) evaluatePoolAutoScaleHandleResponse(resp *http.Response) (EvaluatePoolAutoScaleResponse, error) {
	result := EvaluatePoolAutoScaleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return EvaluatePoolAutoScaleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.AutoScaleRun); err != nil {
		return EvaluatePoolAutoScaleResponse{}, err
	}
	return result, nil
}

// GetApplication - Gets information about the specified Application.
//
// This operation returns only Applications and versions that are available for
// use on Compute Nodes; that is, that can be used in an Package reference. For
// administrator information about Applications and versions that are not yet
// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
// API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - applicationID - The ID of the Application
//   - options - GetApplicationOptions contains the optional parameters for the Client.GetApplication method.
func (client *Client) GetApplication(ctx context.Context, applicationID string, options *GetApplicationOptions) (GetApplicationResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetApplication", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getApplicationCreateRequest(ctx, applicationID, options)
	if err != nil {
		return GetApplicationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetApplicationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetApplicationResponse{}, err
	}
	resp, err := client.getApplicationHandleResponse(httpResp)
	return resp, err
}

// getApplicationCreateRequest creates the GetApplication request.
func (client *Client) getApplicationCreateRequest(ctx context.Context, applicationID string, options *GetApplicationOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/applications/{applicationId}"
	if applicationID == "" {
		return nil, errors.New("parameter applicationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{applicationId}", url.PathEscape(applicationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getApplicationHandleResponse handles the GetApplication response.
func (client *Client) getApplicationHandleResponse(resp *http.Response) (GetApplicationResponse, error) {
	result := GetApplicationResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetApplicationResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Application); err != nil {
		return GetApplicationResponse{}, err
	}
	return result, nil
}

// GetJob - Gets information about the specified Job.
//
// Gets information about the specified Job.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job.
//   - options - GetJobOptions contains the optional parameters for the Client.GetJob method.
func (client *Client) GetJob(ctx context.Context, jobID string, options *GetJobOptions) (GetJobResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetJob", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getJobCreateRequest(ctx, jobID, options)
	if err != nil {
		return GetJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetJobResponse{}, err
	}
	resp, err := client.getJobHandleResponse(httpResp)
	return resp, err
}

// getJobCreateRequest creates the GetJob request.
func (client *Client) getJobCreateRequest(ctx context.Context, jobID string, options *GetJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getJobHandleResponse handles the GetJob response.
func (client *Client) getJobHandleResponse(resp *http.Response) (GetJobResponse, error) {
	result := GetJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Job); err != nil {
		return GetJobResponse{}, err
	}
	return result, nil
}

// GetJobSchedule - Gets information about the specified Job Schedule.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobScheduleID - The ID of the Job Schedule to get.
//   - options - GetJobScheduleOptions contains the optional parameters for the Client.GetJobSchedule method.
func (client *Client) GetJobSchedule(ctx context.Context, jobScheduleID string, options *GetJobScheduleOptions) (GetJobScheduleResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetJobSchedule", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getJobScheduleCreateRequest(ctx, jobScheduleID, options)
	if err != nil {
		return GetJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetJobScheduleResponse{}, err
	}
	resp, err := client.getJobScheduleHandleResponse(httpResp)
	return resp, err
}

// getJobScheduleCreateRequest creates the GetJobSchedule request.
func (client *Client) getJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, options *GetJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getJobScheduleHandleResponse handles the GetJobSchedule response.
func (client *Client) getJobScheduleHandleResponse(resp *http.Response) (GetJobScheduleResponse, error) {
	result := GetJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.JobSchedule); err != nil {
		return GetJobScheduleResponse{}, err
	}
	return result, nil
}

// GetJobTaskCounts - Gets the Task counts for the specified Job.
//
// Task counts provide a count of the Tasks by active, running or completed Task
// state, and a count of Tasks which succeeded or failed. Tasks in the preparing
// state are counted as running. Note that the numbers returned may not always be
// up to date. If you need exact task counts, use a list query.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job.
//   - options - GetJobTaskCountsOptions contains the optional parameters for the Client.GetJobTaskCounts method.
func (client *Client) GetJobTaskCounts(ctx context.Context, jobID string, options *GetJobTaskCountsOptions) (GetJobTaskCountsResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetJobTaskCounts", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getJobTaskCountsCreateRequest(ctx, jobID, options)
	if err != nil {
		return GetJobTaskCountsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetJobTaskCountsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetJobTaskCountsResponse{}, err
	}
	resp, err := client.getJobTaskCountsHandleResponse(httpResp)
	return resp, err
}

// getJobTaskCountsCreateRequest creates the GetJobTaskCounts request.
func (client *Client) getJobTaskCountsCreateRequest(ctx context.Context, jobID string, options *GetJobTaskCountsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/taskcounts"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getJobTaskCountsHandleResponse handles the GetJobTaskCounts response.
func (client *Client) getJobTaskCountsHandleResponse(resp *http.Response) (GetJobTaskCountsResponse, error) {
	result := GetJobTaskCountsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetJobTaskCountsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TaskCountsResult); err != nil {
		return GetJobTaskCountsResponse{}, err
	}
	return result, nil
}

// GetNode - Gets information about the specified Compute Node.
//
// Gets information about the specified Compute Node.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node that you want to get information about.
//   - options - GetNodeOptions contains the optional parameters for the Client.GetNode method.
func (client *Client) GetNode(ctx context.Context, poolID string, nodeID string, options *GetNodeOptions) (GetNodeResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetNode", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNodeCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return GetNodeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetNodeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetNodeResponse{}, err
	}
	resp, err := client.getNodeHandleResponse(httpResp)
	return resp, err
}

// getNodeCreateRequest creates the GetNode request.
func (client *Client) getNodeCreateRequest(ctx context.Context, poolID string, nodeID string, options *GetNodeOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getNodeHandleResponse handles the GetNode response.
func (client *Client) getNodeHandleResponse(resp *http.Response) (GetNodeResponse, error) {
	result := GetNodeResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetNodeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Node); err != nil {
		return GetNodeResponse{}, err
	}
	return result, nil
}

// GetNodeExtension - Gets information about the specified Compute Node Extension.
//
// Gets information about the specified Compute Node Extension.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node that contains the extensions.
//   - extensionName - The name of the Compute Node Extension that you want to get information about.
//   - options - GetNodeExtensionOptions contains the optional parameters for the Client.GetNodeExtension method.
func (client *Client) GetNodeExtension(ctx context.Context, poolID string, nodeID string, extensionName string, options *GetNodeExtensionOptions) (GetNodeExtensionResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetNodeExtension", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNodeExtensionCreateRequest(ctx, poolID, nodeID, extensionName, options)
	if err != nil {
		return GetNodeExtensionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetNodeExtensionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetNodeExtensionResponse{}, err
	}
	resp, err := client.getNodeExtensionHandleResponse(httpResp)
	return resp, err
}

// getNodeExtensionCreateRequest creates the GetNodeExtension request.
func (client *Client) getNodeExtensionCreateRequest(ctx context.Context, poolID string, nodeID string, extensionName string, options *GetNodeExtensionOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/extensions/{extensionName}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	if extensionName == "" {
		return nil, errors.New("parameter extensionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{extensionName}", url.PathEscape(extensionName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getNodeExtensionHandleResponse handles the GetNodeExtension response.
func (client *Client) getNodeExtensionHandleResponse(resp *http.Response) (GetNodeExtensionResponse, error) {
	result := GetNodeExtensionResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetNodeExtensionResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.NodeVMExtension); err != nil {
		return GetNodeExtensionResponse{}, err
	}
	return result, nil
}

// GetNodeFile - Returns the content of the specified Compute Node file.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node.
//   - filePath - The path to the file or directory.
//   - options - GetNodeFileOptions contains the optional parameters for the Client.GetNodeFile method.
func (client *Client) GetNodeFile(ctx context.Context, poolID string, nodeID string, filePath string, options *GetNodeFileOptions) (GetNodeFileResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetNodeFile", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNodeFileCreateRequest(ctx, poolID, nodeID, filePath, options)
	if err != nil {
		return GetNodeFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetNodeFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetNodeFileResponse{}, err
	}
	resp, err := client.getNodeFileHandleResponse(httpResp)
	return resp, err
}

// getNodeFileCreateRequest creates the GetNodeFile request.
func (client *Client) getNodeFileCreateRequest(ctx context.Context, poolID string, nodeID string, filePath string, options *GetNodeFileOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/files/{filePath}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	if filePath == "" {
		return nil, errors.New("parameter filePath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{filePath}", url.PathEscape(filePath))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/octet-stream"}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.OCPRange != nil {
		req.Raw().Header["ocp-range"] = []string{*options.OCPRange}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getNodeFileHandleResponse handles the GetNodeFile response.
func (client *Client) getNodeFileHandleResponse(resp *http.Response) (GetNodeFileResponse, error) {
	result := GetNodeFileResponse{Body: resp.Body}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return GetNodeFileResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("content-type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetNodeFileResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("ocp-batch-file-isdirectory"); val != "" {
		ocpBatchFileIsdirectory, err := strconv.ParseBool(val)
		if err != nil {
			return GetNodeFileResponse{}, err
		}
		result.OCPBatchFileIsDirectory = &ocpBatchFileIsdirectory
	}
	if val := resp.Header.Get("ocp-batch-file-mode"); val != "" {
		result.OCPBatchFileMode = &val
	}
	if val := resp.Header.Get("ocp-batch-file-url"); val != "" {
		result.OCPBatchFileURL = &val
	}
	if val := resp.Header.Get("ocp-creation-time"); val != "" {
		ocpCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetNodeFileResponse{}, err
		}
		result.OCPCreationTime = &ocpCreationTime
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// GetNodeFileProperties - Gets the properties of the specified Compute Node file.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node.
//   - filePath - The path to the file or directory.
//   - options - GetNodeFilePropertiesOptions contains the optional parameters for the Client.GetNodeFileProperties method.
func (client *Client) GetNodeFileProperties(ctx context.Context, poolID string, nodeID string, filePath string, options *GetNodeFilePropertiesOptions) (GetNodeFilePropertiesResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetNodeFileProperties", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNodeFilePropertiesCreateRequest(ctx, poolID, nodeID, filePath, options)
	if err != nil {
		return GetNodeFilePropertiesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetNodeFilePropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetNodeFilePropertiesResponse{}, err
	}
	resp, err := client.getNodeFilePropertiesHandleResponse(httpResp)
	return resp, err
}

// getNodeFilePropertiesCreateRequest creates the GetNodeFileProperties request.
func (client *Client) getNodeFilePropertiesCreateRequest(ctx context.Context, poolID string, nodeID string, filePath string, options *GetNodeFilePropertiesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/files/{filePath}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	if filePath == "" {
		return nil, errors.New("parameter filePath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{filePath}", url.PathEscape(filePath))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getNodeFilePropertiesHandleResponse handles the GetNodeFileProperties response.
func (client *Client) getNodeFilePropertiesHandleResponse(resp *http.Response) (GetNodeFilePropertiesResponse, error) {
	result := GetNodeFilePropertiesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return GetNodeFilePropertiesResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetNodeFilePropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("ocp-batch-file-isdirectory"); val != "" {
		ocpBatchFileIsdirectory, err := strconv.ParseBool(val)
		if err != nil {
			return GetNodeFilePropertiesResponse{}, err
		}
		result.OCPBatchFileIsDirectory = &ocpBatchFileIsdirectory
	}
	if val := resp.Header.Get("ocp-batch-file-mode"); val != "" {
		result.OCPBatchFileMode = &val
	}
	if val := resp.Header.Get("ocp-batch-file-url"); val != "" {
		result.OCPBatchFileURL = &val
	}
	if val := resp.Header.Get("ocp-creation-time"); val != "" {
		ocpCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetNodeFilePropertiesResponse{}, err
		}
		result.OCPCreationTime = &ocpCreationTime
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// GetNodeRemoteLoginSettings - Gets the settings required for remote login to a Compute Node.
//
// Before you can remotely login to a Compute Node using the remote login settings,
// you must create a user Account on the Compute Node.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node for which to obtain the remote login settings.
//   - options - GetNodeRemoteLoginSettingsOptions contains the optional parameters for the Client.GetNodeRemoteLoginSettings
//     method.
func (client *Client) GetNodeRemoteLoginSettings(ctx context.Context, poolID string, nodeID string, options *GetNodeRemoteLoginSettingsOptions) (GetNodeRemoteLoginSettingsResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetNodeRemoteLoginSettings", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNodeRemoteLoginSettingsCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return GetNodeRemoteLoginSettingsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetNodeRemoteLoginSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetNodeRemoteLoginSettingsResponse{}, err
	}
	resp, err := client.getNodeRemoteLoginSettingsHandleResponse(httpResp)
	return resp, err
}

// getNodeRemoteLoginSettingsCreateRequest creates the GetNodeRemoteLoginSettings request.
func (client *Client) getNodeRemoteLoginSettingsCreateRequest(ctx context.Context, poolID string, nodeID string, options *GetNodeRemoteLoginSettingsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/remoteloginsettings"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getNodeRemoteLoginSettingsHandleResponse handles the GetNodeRemoteLoginSettings response.
func (client *Client) getNodeRemoteLoginSettingsHandleResponse(resp *http.Response) (GetNodeRemoteLoginSettingsResponse, error) {
	result := GetNodeRemoteLoginSettingsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetNodeRemoteLoginSettingsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.NodeRemoteLoginSettings); err != nil {
		return GetNodeRemoteLoginSettingsResponse{}, err
	}
	return result, nil
}

// GetPool - Gets information about the specified Pool.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool to get.
//   - options - GetPoolOptions contains the optional parameters for the Client.GetPool method.
func (client *Client) GetPool(ctx context.Context, poolID string, options *GetPoolOptions) (GetPoolResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetPool", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getPoolCreateRequest(ctx, poolID, options)
	if err != nil {
		return GetPoolResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetPoolResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetPoolResponse{}, err
	}
	resp, err := client.getPoolHandleResponse(httpResp)
	return resp, err
}

// getPoolCreateRequest creates the GetPool request.
func (client *Client) getPoolCreateRequest(ctx context.Context, poolID string, options *GetPoolOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getPoolHandleResponse handles the GetPool response.
func (client *Client) getPoolHandleResponse(resp *http.Response) (GetPoolResponse, error) {
	result := GetPoolResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetPoolResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Pool); err != nil {
		return GetPoolResponse{}, err
	}
	return result, nil
}

// GetTask - Gets information about the specified Task.
//
// For multi-instance Tasks, information such as affinityId, executionInfo and
// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
// information about subtasks.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job that contains the Task.
//   - taskID - The ID of the Task to get information about.
//   - options - GetTaskOptions contains the optional parameters for the Client.GetTask method.
func (client *Client) GetTask(ctx context.Context, jobID string, taskID string, options *GetTaskOptions) (GetTaskResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetTask", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getTaskCreateRequest(ctx, jobID, taskID, options)
	if err != nil {
		return GetTaskResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetTaskResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetTaskResponse{}, err
	}
	resp, err := client.getTaskHandleResponse(httpResp)
	return resp, err
}

// getTaskCreateRequest creates the GetTask request.
func (client *Client) getTaskCreateRequest(ctx context.Context, jobID string, taskID string, options *GetTaskOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getTaskHandleResponse handles the GetTask response.
func (client *Client) getTaskHandleResponse(resp *http.Response) (GetTaskResponse, error) {
	result := GetTaskResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetTaskResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Task); err != nil {
		return GetTaskResponse{}, err
	}
	return result, nil
}

// GetTaskFile - Returns the content of the specified Task file.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job that contains the Task.
//   - taskID - The ID of the Task whose file you want to retrieve.
//   - filePath - The path to the Task file that you want to get the content of.
//   - options - GetTaskFileOptions contains the optional parameters for the Client.GetTaskFile method.
func (client *Client) GetTaskFile(ctx context.Context, jobID string, taskID string, filePath string, options *GetTaskFileOptions) (GetTaskFileResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetTaskFile", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getTaskFileCreateRequest(ctx, jobID, taskID, filePath, options)
	if err != nil {
		return GetTaskFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetTaskFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetTaskFileResponse{}, err
	}
	resp, err := client.getTaskFileHandleResponse(httpResp)
	return resp, err
}

// getTaskFileCreateRequest creates the GetTaskFile request.
func (client *Client) getTaskFileCreateRequest(ctx context.Context, jobID string, taskID string, filePath string, options *GetTaskFileOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/files/{filePath}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	if filePath == "" {
		return nil, errors.New("parameter filePath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{filePath}", url.PathEscape(filePath))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/octet-stream"}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.OCPRange != nil {
		req.Raw().Header["ocp-range"] = []string{*options.OCPRange}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getTaskFileHandleResponse handles the GetTaskFile response.
func (client *Client) getTaskFileHandleResponse(resp *http.Response) (GetTaskFileResponse, error) {
	result := GetTaskFileResponse{Body: resp.Body}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return GetTaskFileResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("content-type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetTaskFileResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("ocp-batch-file-isdirectory"); val != "" {
		ocpBatchFileIsdirectory, err := strconv.ParseBool(val)
		if err != nil {
			return GetTaskFileResponse{}, err
		}
		result.OCPBatchFileIsDirectory = &ocpBatchFileIsdirectory
	}
	if val := resp.Header.Get("ocp-batch-file-mode"); val != "" {
		result.OCPBatchFileMode = &val
	}
	if val := resp.Header.Get("ocp-batch-file-url"); val != "" {
		result.OCPBatchFileURL = &val
	}
	if val := resp.Header.Get("ocp-creation-time"); val != "" {
		ocpCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetTaskFileResponse{}, err
		}
		result.OCPCreationTime = &ocpCreationTime
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// GetTaskFileProperties - Gets the properties of the specified Task file.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job that contains the Task.
//   - taskID - The ID of the Task whose file you want to retrieve.
//   - filePath - The path to the Task file that you want to get the content of.
//   - options - GetTaskFilePropertiesOptions contains the optional parameters for the Client.GetTaskFileProperties method.
func (client *Client) GetTaskFileProperties(ctx context.Context, jobID string, taskID string, filePath string, options *GetTaskFilePropertiesOptions) (GetTaskFilePropertiesResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.GetTaskFileProperties", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getTaskFilePropertiesCreateRequest(ctx, jobID, taskID, filePath, options)
	if err != nil {
		return GetTaskFilePropertiesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetTaskFilePropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetTaskFilePropertiesResponse{}, err
	}
	resp, err := client.getTaskFilePropertiesHandleResponse(httpResp)
	return resp, err
}

// getTaskFilePropertiesCreateRequest creates the GetTaskFileProperties request.
func (client *Client) getTaskFilePropertiesCreateRequest(ctx context.Context, jobID string, taskID string, filePath string, options *GetTaskFilePropertiesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/files/{filePath}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	if filePath == "" {
		return nil, errors.New("parameter filePath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{filePath}", url.PathEscape(filePath))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getTaskFilePropertiesHandleResponse handles the GetTaskFileProperties response.
func (client *Client) getTaskFilePropertiesHandleResponse(resp *http.Response) (GetTaskFilePropertiesResponse, error) {
	result := GetTaskFilePropertiesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return GetTaskFilePropertiesResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetTaskFilePropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("ocp-batch-file-isdirectory"); val != "" {
		ocpBatchFileIsdirectory, err := strconv.ParseBool(val)
		if err != nil {
			return GetTaskFilePropertiesResponse{}, err
		}
		result.OCPBatchFileIsDirectory = &ocpBatchFileIsdirectory
	}
	if val := resp.Header.Get("ocp-batch-file-mode"); val != "" {
		result.OCPBatchFileMode = &val
	}
	if val := resp.Header.Get("ocp-batch-file-url"); val != "" {
		result.OCPBatchFileURL = &val
	}
	if val := resp.Header.Get("ocp-creation-time"); val != "" {
		ocpCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return GetTaskFilePropertiesResponse{}, err
		}
		result.OCPCreationTime = &ocpCreationTime
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// JobScheduleExists - Checks the specified Job Schedule exists.
//
// Checks the specified Job Schedule exists.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobScheduleID - The ID of the Job Schedule which you want to check.
//   - options - JobScheduleExistsOptions contains the optional parameters for the Client.JobScheduleExists method.
func (client *Client) JobScheduleExists(ctx context.Context, jobScheduleID string, options *JobScheduleExistsOptions) (JobScheduleExistsResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.JobScheduleExists", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.jobScheduleExistsCreateRequest(ctx, jobScheduleID, options)
	if err != nil {
		return JobScheduleExistsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobScheduleExistsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return JobScheduleExistsResponse{}, err
	}
	resp, err := client.jobScheduleExistsHandleResponse(httpResp)
	return resp, err
}

// jobScheduleExistsCreateRequest creates the JobScheduleExists request.
func (client *Client) jobScheduleExistsCreateRequest(ctx context.Context, jobScheduleID string, options *JobScheduleExistsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// jobScheduleExistsHandleResponse handles the JobScheduleExists response.
func (client *Client) jobScheduleExistsHandleResponse(resp *http.Response) (JobScheduleExistsResponse, error) {
	result := JobScheduleExistsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobScheduleExistsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// NewListApplicationsPager - Lists all of the applications available in the specified Account.
//
// This operation returns only Applications and versions that are available for
// use on Compute Nodes; that is, that can be used in an Package reference. For
// administrator information about applications and versions that are not yet
// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
// API.
//
// Generated from API version 2024-07-01.20.0
//   - options - ListApplicationsOptions contains the optional parameters for the Client.NewListApplicationsPager method.
func (client *Client) NewListApplicationsPager(options *ListApplicationsOptions) *runtime.Pager[ListApplicationsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListApplicationsResponse]{
		More: func(page ListApplicationsResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListApplicationsResponse) (ListApplicationsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listApplicationsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ListApplicationsResponse{}, err
			}
			return client.listApplicationsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listApplicationsCreateRequest creates the ListApplications request.
func (client *Client) listApplicationsCreateRequest(ctx context.Context, options *ListApplicationsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/applications"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listApplicationsHandleResponse handles the ListApplications response.
func (client *Client) listApplicationsHandleResponse(resp *http.Response) (ListApplicationsResponse, error) {
	result := ListApplicationsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListApplicationsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ApplicationListResult); err != nil {
		return ListApplicationsResponse{}, err
	}
	return result, nil
}

// NewListJobPreparationAndReleaseTaskStatusPager - Lists the execution status of the Job Preparation and Job Release Task
// for the
// specified Job across the Compute Nodes where the Job has run.
//
// This API returns the Job Preparation and Job Release Task status on all Compute
// Nodes that have run the Job Preparation or Job Release Task. This includes
// Compute Nodes which have since been removed from the Pool. If this API is
// invoked on a Job which has no Job Preparation or Job Release Task, the Batch
// service returns HTTP status code 409 (Conflict) with an error code of
// JobPreparationTaskNotSpecified.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job.
//   - options - ListJobPreparationAndReleaseTaskStatusOptions contains the optional parameters for the Client.NewListJobPreparationAndReleaseTaskStatusPager
//     method.
func (client *Client) NewListJobPreparationAndReleaseTaskStatusPager(jobID string, options *ListJobPreparationAndReleaseTaskStatusOptions) *runtime.Pager[ListJobPreparationAndReleaseTaskStatusResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListJobPreparationAndReleaseTaskStatusResponse]{
		More: func(page ListJobPreparationAndReleaseTaskStatusResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListJobPreparationAndReleaseTaskStatusResponse) (ListJobPreparationAndReleaseTaskStatusResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listJobPreparationAndReleaseTaskStatusCreateRequest(ctx, jobID, options)
			}, nil)
			if err != nil {
				return ListJobPreparationAndReleaseTaskStatusResponse{}, err
			}
			return client.listJobPreparationAndReleaseTaskStatusHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listJobPreparationAndReleaseTaskStatusCreateRequest creates the ListJobPreparationAndReleaseTaskStatus request.
func (client *Client) listJobPreparationAndReleaseTaskStatusCreateRequest(ctx context.Context, jobID string, options *ListJobPreparationAndReleaseTaskStatusOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/jobpreparationandreleasetaskstatus"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listJobPreparationAndReleaseTaskStatusHandleResponse handles the ListJobPreparationAndReleaseTaskStatus response.
func (client *Client) listJobPreparationAndReleaseTaskStatusHandleResponse(resp *http.Response) (ListJobPreparationAndReleaseTaskStatusResponse, error) {
	result := ListJobPreparationAndReleaseTaskStatusResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListJobPreparationAndReleaseTaskStatusResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.JobPreparationAndReleaseTaskStatusListResult); err != nil {
		return ListJobPreparationAndReleaseTaskStatusResponse{}, err
	}
	return result, nil
}

// NewListJobSchedulesPager - Lists all of the Job Schedules in the specified Account.
//
// Lists all of the Job Schedules in the specified Account.
//
// Generated from API version 2024-07-01.20.0
//   - options - ListJobSchedulesOptions contains the optional parameters for the Client.NewListJobSchedulesPager method.
func (client *Client) NewListJobSchedulesPager(options *ListJobSchedulesOptions) *runtime.Pager[ListJobSchedulesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListJobSchedulesResponse]{
		More: func(page ListJobSchedulesResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListJobSchedulesResponse) (ListJobSchedulesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listJobSchedulesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ListJobSchedulesResponse{}, err
			}
			return client.listJobSchedulesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listJobSchedulesCreateRequest creates the ListJobSchedules request.
func (client *Client) listJobSchedulesCreateRequest(ctx context.Context, options *ListJobSchedulesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listJobSchedulesHandleResponse handles the ListJobSchedules response.
func (client *Client) listJobSchedulesHandleResponse(resp *http.Response) (ListJobSchedulesResponse, error) {
	result := ListJobSchedulesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListJobSchedulesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.JobScheduleListResult); err != nil {
		return ListJobSchedulesResponse{}, err
	}
	return result, nil
}

// NewListJobsPager - Lists all of the Jobs in the specified Account.
//
// Lists all of the Jobs in the specified Account.
//
// Generated from API version 2024-07-01.20.0
//   - options - ListJobsOptions contains the optional parameters for the Client.NewListJobsPager method.
func (client *Client) NewListJobsPager(options *ListJobsOptions) *runtime.Pager[ListJobsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListJobsResponse]{
		More: func(page ListJobsResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListJobsResponse) (ListJobsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listJobsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ListJobsResponse{}, err
			}
			return client.listJobsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listJobsCreateRequest creates the ListJobs request.
func (client *Client) listJobsCreateRequest(ctx context.Context, options *ListJobsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listJobsHandleResponse handles the ListJobs response.
func (client *Client) listJobsHandleResponse(resp *http.Response) (ListJobsResponse, error) {
	result := ListJobsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListJobsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.JobListResult); err != nil {
		return ListJobsResponse{}, err
	}
	return result, nil
}

// NewListJobsFromSchedulePager - Lists the Jobs that have been created under the specified Job Schedule.
//
// Lists the Jobs that have been created under the specified Job Schedule.
//
// Generated from API version 2024-07-01.20.0
//   - jobScheduleID - The ID of the Job Schedule from which you want to get a list of Jobs.
//   - options - ListJobsFromScheduleOptions contains the optional parameters for the Client.NewListJobsFromSchedulePager method.
func (client *Client) NewListJobsFromSchedulePager(jobScheduleID string, options *ListJobsFromScheduleOptions) *runtime.Pager[ListJobsFromScheduleResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListJobsFromScheduleResponse]{
		More: func(page ListJobsFromScheduleResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListJobsFromScheduleResponse) (ListJobsFromScheduleResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listJobsFromScheduleCreateRequest(ctx, jobScheduleID, options)
			}, nil)
			if err != nil {
				return ListJobsFromScheduleResponse{}, err
			}
			return client.listJobsFromScheduleHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listJobsFromScheduleCreateRequest creates the ListJobsFromSchedule request.
func (client *Client) listJobsFromScheduleCreateRequest(ctx context.Context, jobScheduleID string, options *ListJobsFromScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}/jobs"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listJobsFromScheduleHandleResponse handles the ListJobsFromSchedule response.
func (client *Client) listJobsFromScheduleHandleResponse(resp *http.Response) (ListJobsFromScheduleResponse, error) {
	result := ListJobsFromScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListJobsFromScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.JobListResult); err != nil {
		return ListJobsFromScheduleResponse{}, err
	}
	return result, nil
}

// NewListNodeExtensionsPager - Lists the Compute Nodes Extensions in the specified Pool.
//
// Lists the Compute Nodes Extensions in the specified Pool.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains Compute Node.
//   - nodeID - The ID of the Compute Node that you want to list extensions.
//   - options - ListNodeExtensionsOptions contains the optional parameters for the Client.NewListNodeExtensionsPager method.
func (client *Client) NewListNodeExtensionsPager(poolID string, nodeID string, options *ListNodeExtensionsOptions) *runtime.Pager[ListNodeExtensionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListNodeExtensionsResponse]{
		More: func(page ListNodeExtensionsResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListNodeExtensionsResponse) (ListNodeExtensionsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listNodeExtensionsCreateRequest(ctx, poolID, nodeID, options)
			}, nil)
			if err != nil {
				return ListNodeExtensionsResponse{}, err
			}
			return client.listNodeExtensionsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listNodeExtensionsCreateRequest creates the ListNodeExtensions request.
func (client *Client) listNodeExtensionsCreateRequest(ctx context.Context, poolID string, nodeID string, options *ListNodeExtensionsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/extensions"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listNodeExtensionsHandleResponse handles the ListNodeExtensions response.
func (client *Client) listNodeExtensionsHandleResponse(resp *http.Response) (ListNodeExtensionsResponse, error) {
	result := ListNodeExtensionsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListNodeExtensionsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.NodeVMExtensionListResult); err != nil {
		return ListNodeExtensionsResponse{}, err
	}
	return result, nil
}

// NewListNodeFilesPager - Lists all of the files in Task directories on the specified Compute Node.
//
// Lists all of the files in Task directories on the specified Compute Node.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node whose files you want to list.
//   - options - ListNodeFilesOptions contains the optional parameters for the Client.NewListNodeFilesPager method.
func (client *Client) NewListNodeFilesPager(poolID string, nodeID string, options *ListNodeFilesOptions) *runtime.Pager[ListNodeFilesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListNodeFilesResponse]{
		More: func(page ListNodeFilesResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListNodeFilesResponse) (ListNodeFilesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listNodeFilesCreateRequest(ctx, poolID, nodeID, options)
			}, nil)
			if err != nil {
				return ListNodeFilesResponse{}, err
			}
			return client.listNodeFilesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listNodeFilesCreateRequest creates the ListNodeFiles request.
func (client *Client) listNodeFilesCreateRequest(ctx context.Context, poolID string, nodeID string, options *ListNodeFilesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/files"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Recursive != nil {
		reqQP.Set("recursive", strconv.FormatBool(*options.Recursive))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listNodeFilesHandleResponse handles the ListNodeFiles response.
func (client *Client) listNodeFilesHandleResponse(resp *http.Response) (ListNodeFilesResponse, error) {
	result := ListNodeFilesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListNodeFilesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.NodeFileListResult); err != nil {
		return ListNodeFilesResponse{}, err
	}
	return result, nil
}

// NewListNodesPager - Lists the Compute Nodes in the specified Pool.
//
// Lists the Compute Nodes in the specified Pool.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool from which you want to list Compute Nodes.
//   - options - ListNodesOptions contains the optional parameters for the Client.NewListNodesPager method.
func (client *Client) NewListNodesPager(poolID string, options *ListNodesOptions) *runtime.Pager[ListNodesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListNodesResponse]{
		More: func(page ListNodesResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListNodesResponse) (ListNodesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listNodesCreateRequest(ctx, poolID, options)
			}, nil)
			if err != nil {
				return ListNodesResponse{}, err
			}
			return client.listNodesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listNodesCreateRequest creates the ListNodes request.
func (client *Client) listNodesCreateRequest(ctx context.Context, poolID string, options *ListNodesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listNodesHandleResponse handles the ListNodes response.
func (client *Client) listNodesHandleResponse(resp *http.Response) (ListNodesResponse, error) {
	result := ListNodesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListNodesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.NodeListResult); err != nil {
		return ListNodesResponse{}, err
	}
	return result, nil
}

// NewListPoolNodeCountsPager - Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
// numbers returned may not always be up to date. If you need exact node counts,
// use a list query.
//
// Generated from API version 2024-07-01.20.0
//   - options - ListPoolNodeCountsOptions contains the optional parameters for the Client.NewListPoolNodeCountsPager method.
func (client *Client) NewListPoolNodeCountsPager(options *ListPoolNodeCountsOptions) *runtime.Pager[ListPoolNodeCountsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListPoolNodeCountsResponse]{
		More: func(page ListPoolNodeCountsResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListPoolNodeCountsResponse) (ListPoolNodeCountsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listPoolNodeCountsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ListPoolNodeCountsResponse{}, err
			}
			return client.listPoolNodeCountsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listPoolNodeCountsCreateRequest creates the ListPoolNodeCounts request.
func (client *Client) listPoolNodeCountsCreateRequest(ctx context.Context, options *ListPoolNodeCountsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/nodecounts"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listPoolNodeCountsHandleResponse handles the ListPoolNodeCounts response.
func (client *Client) listPoolNodeCountsHandleResponse(resp *http.Response) (ListPoolNodeCountsResponse, error) {
	result := ListPoolNodeCountsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListPoolNodeCountsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ListPoolNodeCountsResult); err != nil {
		return ListPoolNodeCountsResponse{}, err
	}
	return result, nil
}

// NewListPoolsPager - Lists all of the Pools which be mounted.
//
// Lists all of the Pools which be mounted.
//
// Generated from API version 2024-07-01.20.0
//   - options - ListPoolsOptions contains the optional parameters for the Client.NewListPoolsPager method.
func (client *Client) NewListPoolsPager(options *ListPoolsOptions) *runtime.Pager[ListPoolsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListPoolsResponse]{
		More: func(page ListPoolsResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListPoolsResponse) (ListPoolsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listPoolsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ListPoolsResponse{}, err
			}
			return client.listPoolsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listPoolsCreateRequest creates the ListPools request.
func (client *Client) listPoolsCreateRequest(ctx context.Context, options *ListPoolsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listPoolsHandleResponse handles the ListPools response.
func (client *Client) listPoolsHandleResponse(resp *http.Response) (ListPoolsResponse, error) {
	result := ListPoolsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListPoolsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PoolListResult); err != nil {
		return ListPoolsResponse{}, err
	}
	return result, nil
}

// NewListSubTasksPager - Lists all of the subtasks that are associated with the specified multi-instance
// Task.
//
// If the Task is not a multi-instance Task then this returns an empty collection.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job.
//   - taskID - The ID of the Task.
//   - options - ListSubTasksOptions contains the optional parameters for the Client.NewListSubTasksPager method.
func (client *Client) NewListSubTasksPager(jobID string, taskID string, options *ListSubTasksOptions) *runtime.Pager[ListSubTasksResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListSubTasksResponse]{
		More: func(page ListSubTasksResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListSubTasksResponse) (ListSubTasksResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSubTasksCreateRequest(ctx, jobID, taskID, options)
			}, nil)
			if err != nil {
				return ListSubTasksResponse{}, err
			}
			return client.listSubTasksHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSubTasksCreateRequest creates the ListSubTasks request.
func (client *Client) listSubTasksCreateRequest(ctx context.Context, jobID string, taskID string, options *ListSubTasksOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/subtasksinfo"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listSubTasksHandleResponse handles the ListSubTasks response.
func (client *Client) listSubTasksHandleResponse(resp *http.Response) (ListSubTasksResponse, error) {
	result := ListSubTasksResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListSubTasksResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TaskListSubtasksResult); err != nil {
		return ListSubTasksResponse{}, err
	}
	return result, nil
}

// NewListSupportedImagesPager - Lists all Virtual Machine Images supported by the Azure Batch service.
//
// Lists all Virtual Machine Images supported by the Azure Batch service.
//
// Generated from API version 2024-07-01.20.0
//   - options - ListSupportedImagesOptions contains the optional parameters for the Client.NewListSupportedImagesPager method.
func (client *Client) NewListSupportedImagesPager(options *ListSupportedImagesOptions) *runtime.Pager[ListSupportedImagesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListSupportedImagesResponse]{
		More: func(page ListSupportedImagesResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListSupportedImagesResponse) (ListSupportedImagesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSupportedImagesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ListSupportedImagesResponse{}, err
			}
			return client.listSupportedImagesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSupportedImagesCreateRequest creates the ListSupportedImages request.
func (client *Client) listSupportedImagesCreateRequest(ctx context.Context, options *ListSupportedImagesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/supportedimages"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listSupportedImagesHandleResponse handles the ListSupportedImages response.
func (client *Client) listSupportedImagesHandleResponse(resp *http.Response) (ListSupportedImagesResponse, error) {
	result := ListSupportedImagesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListSupportedImagesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.AccountListSupportedImagesResult); err != nil {
		return ListSupportedImagesResponse{}, err
	}
	return result, nil
}

// NewListTaskFilesPager - Lists the files in a Task's directory on its Compute Node.
//
// Lists the files in a Task's directory on its Compute Node.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job that contains the Task.
//   - taskID - The ID of the Task whose files you want to list.
//   - options - ListTaskFilesOptions contains the optional parameters for the Client.NewListTaskFilesPager method.
func (client *Client) NewListTaskFilesPager(jobID string, taskID string, options *ListTaskFilesOptions) *runtime.Pager[ListTaskFilesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListTaskFilesResponse]{
		More: func(page ListTaskFilesResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListTaskFilesResponse) (ListTaskFilesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listTaskFilesCreateRequest(ctx, jobID, taskID, options)
			}, nil)
			if err != nil {
				return ListTaskFilesResponse{}, err
			}
			return client.listTaskFilesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listTaskFilesCreateRequest creates the ListTaskFiles request.
func (client *Client) listTaskFilesCreateRequest(ctx context.Context, jobID string, taskID string, options *ListTaskFilesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/files"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Recursive != nil {
		reqQP.Set("recursive", strconv.FormatBool(*options.Recursive))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listTaskFilesHandleResponse handles the ListTaskFiles response.
func (client *Client) listTaskFilesHandleResponse(resp *http.Response) (ListTaskFilesResponse, error) {
	result := ListTaskFilesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListTaskFilesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.NodeFileListResult); err != nil {
		return ListTaskFilesResponse{}, err
	}
	return result, nil
}

// NewListTasksPager - Lists all of the Tasks that are associated with the specified Job.
//
// For multi-instance Tasks, information such as affinityId, executionInfo and
// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
// information about subtasks.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job.
//   - options - ListTasksOptions contains the optional parameters for the Client.NewListTasksPager method.
func (client *Client) NewListTasksPager(jobID string, options *ListTasksOptions) *runtime.Pager[ListTasksResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListTasksResponse]{
		More: func(page ListTasksResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListTasksResponse) (ListTasksResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listTasksCreateRequest(ctx, jobID, options)
			}, nil)
			if err != nil {
				return ListTasksResponse{}, err
			}
			return client.listTasksHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listTasksCreateRequest creates the ListTasks request.
func (client *Client) listTasksCreateRequest(ctx context.Context, jobID string, options *ListTasksOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listTasksHandleResponse handles the ListTasks response.
func (client *Client) listTasksHandleResponse(resp *http.Response) (ListTasksResponse, error) {
	result := ListTasksResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ListTasksResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TaskListResult); err != nil {
		return ListTasksResponse{}, err
	}
	return result, nil
}

// PoolExists - Gets basic properties of a Pool.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool to get.
//   - options - PoolExistsOptions contains the optional parameters for the Client.PoolExists method.
func (client *Client) PoolExists(ctx context.Context, poolID string, options *PoolExistsOptions) (PoolExistsResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.PoolExists", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.poolExistsCreateRequest(ctx, poolID, options)
	if err != nil {
		return PoolExistsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PoolExistsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return PoolExistsResponse{}, err
	}
	resp, err := client.poolExistsHandleResponse(httpResp)
	return resp, err
}

// poolExistsCreateRequest creates the PoolExists request.
func (client *Client) poolExistsCreateRequest(ctx context.Context, poolID string, options *PoolExistsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// poolExistsHandleResponse handles the PoolExists response.
func (client *Client) poolExistsHandleResponse(resp *http.Response) (PoolExistsResponse, error) {
	result := PoolExistsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PoolExistsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReactivateTask - Reactivates a Task, allowing it to run again even if its retry count has been
// exhausted.
//
// Reactivation makes a Task eligible to be retried again up to its maximum retry
// count. The Task's state is changed to active. As the Task is no longer in the
// completed state, any previous exit code or failure information is no longer
// available after reactivation. Each time a Task is reactivated, its retry count
// is reset to 0. Reactivation will fail for Tasks that are not completed or that
// previously completed successfully (with an exit code of 0). Additionally, it
// will fail if the Job has completed (or is terminating or deleting).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job containing the Task.
//   - taskID - The ID of the Task to reactivate.
//   - options - ReactivateTaskOptions contains the optional parameters for the Client.ReactivateTask method.
func (client *Client) ReactivateTask(ctx context.Context, jobID string, taskID string, options *ReactivateTaskOptions) (ReactivateTaskResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.ReactivateTask", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.reactivateTaskCreateRequest(ctx, jobID, taskID, options)
	if err != nil {
		return ReactivateTaskResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ReactivateTaskResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ReactivateTaskResponse{}, err
	}
	resp, err := client.reactivateTaskHandleResponse(httpResp)
	return resp, err
}

// reactivateTaskCreateRequest creates the ReactivateTask request.
func (client *Client) reactivateTaskCreateRequest(ctx context.Context, jobID string, taskID string, options *ReactivateTaskOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/reactivate"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// reactivateTaskHandleResponse handles the ReactivateTask response.
func (client *Client) reactivateTaskHandleResponse(resp *http.Response) (ReactivateTaskResponse, error) {
	result := ReactivateTaskResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ReactivateTaskResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// RebootNode - Restarts the specified Compute Node.
//
// You can restart a Compute Node only if it is in an idle or running state.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node that you want to restart.
//   - options - RebootNodeOptions contains the optional parameters for the Client.RebootNode method.
func (client *Client) RebootNode(ctx context.Context, poolID string, nodeID string, options *RebootNodeOptions) (RebootNodeResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.RebootNode", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.rebootNodeCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return RebootNodeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return RebootNodeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return RebootNodeResponse{}, err
	}
	resp, err := client.rebootNodeHandleResponse(httpResp)
	return resp, err
}

// rebootNodeCreateRequest creates the RebootNode request.
func (client *Client) rebootNodeCreateRequest(ctx context.Context, poolID string, nodeID string, options *RebootNodeOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/reboot"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if options != nil && options.Parameters != nil {
		req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
		if err := runtime.MarshalAsJSON(req, *options.Parameters); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// rebootNodeHandleResponse handles the RebootNode response.
func (client *Client) rebootNodeHandleResponse(resp *http.Response) (RebootNodeResponse, error) {
	result := RebootNodeResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return RebootNodeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReimageNode - Reinstalls the operating system on the specified Compute Node.
//
// You can reinstall the operating system on a Compute Node only if it is in an
// idle or running state. This API can be invoked only on Pools created with the
// cloud service configuration property.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node that you want to restart.
//   - options - ReimageNodeOptions contains the optional parameters for the Client.ReimageNode method.
func (client *Client) ReimageNode(ctx context.Context, poolID string, nodeID string, options *ReimageNodeOptions) (ReimageNodeResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.ReimageNode", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.reimageNodeCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return ReimageNodeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ReimageNodeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return ReimageNodeResponse{}, err
	}
	resp, err := client.reimageNodeHandleResponse(httpResp)
	return resp, err
}

// reimageNodeCreateRequest creates the ReimageNode request.
func (client *Client) reimageNodeCreateRequest(ctx context.Context, poolID string, nodeID string, options *ReimageNodeOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/reimage"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if options != nil && options.Parameters != nil {
		req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
		if err := runtime.MarshalAsJSON(req, *options.Parameters); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// reimageNodeHandleResponse handles the ReimageNode response.
func (client *Client) reimageNodeHandleResponse(resp *http.Response) (ReimageNodeResponse, error) {
	result := ReimageNodeResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ReimageNodeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// RemoveNodes - Removes Compute Nodes from the specified Pool.
//
// This operation can only run when the allocation state of the Pool is steady.
// When this operation runs, the allocation state changes from steady to resizing.
// Each request may remove up to 100 nodes.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool to get.
//   - content - The options to use for removing the node.
//   - options - RemoveNodesOptions contains the optional parameters for the Client.RemoveNodes method.
func (client *Client) RemoveNodes(ctx context.Context, poolID string, content RemoveNodeContent, options *RemoveNodesOptions) (RemoveNodesResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.RemoveNodes", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.removeNodesCreateRequest(ctx, poolID, content, options)
	if err != nil {
		return RemoveNodesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return RemoveNodesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return RemoveNodesResponse{}, err
	}
	resp, err := client.removeNodesHandleResponse(httpResp)
	return resp, err
}

// removeNodesCreateRequest creates the RemoveNodes request.
func (client *Client) removeNodesCreateRequest(ctx context.Context, poolID string, content RemoveNodeContent, options *RemoveNodesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/removenodes"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
		return nil, err
	}
	return req, nil
}

// removeNodesHandleResponse handles the RemoveNodes response.
func (client *Client) removeNodesHandleResponse(resp *http.Response) (RemoveNodesResponse, error) {
	result := RemoveNodesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return RemoveNodesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReplaceJob - Updates the properties of the specified Job.
//
// This fully replaces all the updatable properties of the Job. For example, if
// the Job has constraints associated with it and if constraints is not specified
// with this request, then the Batch service will remove the existing constraints.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job whose properties you want to update.
//   - job - A job with updated properties
//   - options - ReplaceJobOptions contains the optional parameters for the Client.ReplaceJob method.
func (client *Client) ReplaceJob(ctx context.Context, jobID string, job Job, options *ReplaceJobOptions) (ReplaceJobResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.ReplaceJob", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.replaceJobCreateRequest(ctx, jobID, job, options)
	if err != nil {
		return ReplaceJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ReplaceJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ReplaceJobResponse{}, err
	}
	resp, err := client.replaceJobHandleResponse(httpResp)
	return resp, err
}

// replaceJobCreateRequest creates the ReplaceJob request.
func (client *Client) replaceJobCreateRequest(ctx context.Context, jobID string, job Job, options *ReplaceJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, job); err != nil {
		return nil, err
	}
	return req, nil
}

// replaceJobHandleResponse handles the ReplaceJob response.
func (client *Client) replaceJobHandleResponse(resp *http.Response) (ReplaceJobResponse, error) {
	result := ReplaceJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ReplaceJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReplaceJobSchedule - Updates the properties of the specified Job Schedule.
//
// This fully replaces all the updatable properties of the Job Schedule. For
// example, if the schedule property is not specified with this request, then the
// Batch service will remove the existing schedule. Changes to a Job Schedule only
// impact Jobs created by the schedule after the update has taken place; currently
// running Jobs are unaffected.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobScheduleID - The ID of the Job Schedule to update.
//   - jobSchedule - A Job Schedule with updated properties
//   - options - ReplaceJobScheduleOptions contains the optional parameters for the Client.ReplaceJobSchedule method.
func (client *Client) ReplaceJobSchedule(ctx context.Context, jobScheduleID string, jobSchedule JobSchedule, options *ReplaceJobScheduleOptions) (ReplaceJobScheduleResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.ReplaceJobSchedule", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.replaceJobScheduleCreateRequest(ctx, jobScheduleID, jobSchedule, options)
	if err != nil {
		return ReplaceJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ReplaceJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ReplaceJobScheduleResponse{}, err
	}
	resp, err := client.replaceJobScheduleHandleResponse(httpResp)
	return resp, err
}

// replaceJobScheduleCreateRequest creates the ReplaceJobSchedule request.
func (client *Client) replaceJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, jobSchedule JobSchedule, options *ReplaceJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, jobSchedule); err != nil {
		return nil, err
	}
	return req, nil
}

// replaceJobScheduleHandleResponse handles the ReplaceJobSchedule response.
func (client *Client) replaceJobScheduleHandleResponse(resp *http.Response) (ReplaceJobScheduleResponse, error) {
	result := ReplaceJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ReplaceJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReplaceNodeUser - Updates the password and expiration time of a user Account on the specified Compute Node.
//
// This operation replaces of all the updatable properties of the Account. For
// example, if the expiryTime element is not specified, the current value is
// replaced with the default value, not left unmodified. You can update a user
// Account on a Compute Node only when it is in the idle or running state.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the machine on which you want to update a user Account.
//   - userName - The name of the user Account to update.
//   - content - The options to use for updating the user.
//   - options - ReplaceNodeUserOptions contains the optional parameters for the Client.ReplaceNodeUser method.
func (client *Client) ReplaceNodeUser(ctx context.Context, poolID string, nodeID string, userName string, content UpdateNodeUserContent, options *ReplaceNodeUserOptions) (ReplaceNodeUserResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.ReplaceNodeUser", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.replaceNodeUserCreateRequest(ctx, poolID, nodeID, userName, content, options)
	if err != nil {
		return ReplaceNodeUserResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ReplaceNodeUserResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ReplaceNodeUserResponse{}, err
	}
	resp, err := client.replaceNodeUserHandleResponse(httpResp)
	return resp, err
}

// replaceNodeUserCreateRequest creates the ReplaceNodeUser request.
func (client *Client) replaceNodeUserCreateRequest(ctx context.Context, poolID string, nodeID string, userName string, content UpdateNodeUserContent, options *ReplaceNodeUserOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/users/{userName}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	if userName == "" {
		return nil, errors.New("parameter userName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userName}", url.PathEscape(userName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
		return nil, err
	}
	return req, nil
}

// replaceNodeUserHandleResponse handles the ReplaceNodeUser response.
func (client *Client) replaceNodeUserHandleResponse(resp *http.Response) (ReplaceNodeUserResponse, error) {
	result := ReplaceNodeUserResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ReplaceNodeUserResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReplacePoolProperties - Updates the properties of the specified Pool.
//
// This fully replaces all the updatable properties of the Pool. For example, if
// the Pool has a StartTask associated with it and if StartTask is not specified
// with this request, then the Batch service will remove the existing StartTask.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool to update.
//   - pool - The options to use for replacing properties on the pool.
//   - options - ReplacePoolPropertiesOptions contains the optional parameters for the Client.ReplacePoolProperties method.
func (client *Client) ReplacePoolProperties(ctx context.Context, poolID string, pool ReplacePoolContent, options *ReplacePoolPropertiesOptions) (ReplacePoolPropertiesResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.ReplacePoolProperties", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.replacePoolPropertiesCreateRequest(ctx, poolID, pool, options)
	if err != nil {
		return ReplacePoolPropertiesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ReplacePoolPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ReplacePoolPropertiesResponse{}, err
	}
	resp, err := client.replacePoolPropertiesHandleResponse(httpResp)
	return resp, err
}

// replacePoolPropertiesCreateRequest creates the ReplacePoolProperties request.
func (client *Client) replacePoolPropertiesCreateRequest(ctx context.Context, poolID string, pool ReplacePoolContent, options *ReplacePoolPropertiesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/updateproperties"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, pool); err != nil {
		return nil, err
	}
	return req, nil
}

// replacePoolPropertiesHandleResponse handles the ReplacePoolProperties response.
func (client *Client) replacePoolPropertiesHandleResponse(resp *http.Response) (ReplacePoolPropertiesResponse, error) {
	result := ReplacePoolPropertiesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ReplacePoolPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReplaceTask - Updates the properties of the specified Task.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job containing the Task.
//   - taskID - The ID of the Task to update.
//   - task - The Task to update.
//   - options - ReplaceTaskOptions contains the optional parameters for the Client.ReplaceTask method.
func (client *Client) ReplaceTask(ctx context.Context, jobID string, taskID string, task Task, options *ReplaceTaskOptions) (ReplaceTaskResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.ReplaceTask", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.replaceTaskCreateRequest(ctx, jobID, taskID, task, options)
	if err != nil {
		return ReplaceTaskResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ReplaceTaskResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ReplaceTaskResponse{}, err
	}
	resp, err := client.replaceTaskHandleResponse(httpResp)
	return resp, err
}

// replaceTaskCreateRequest creates the ReplaceTask request.
func (client *Client) replaceTaskCreateRequest(ctx context.Context, jobID string, taskID string, task Task, options *ReplaceTaskOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, task); err != nil {
		return nil, err
	}
	return req, nil
}

// replaceTaskHandleResponse handles the ReplaceTask response.
func (client *Client) replaceTaskHandleResponse(resp *http.Response) (ReplaceTaskResponse, error) {
	result := ReplaceTaskResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ReplaceTaskResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ResizePool - Changes the number of Compute Nodes that are assigned to a Pool.
//
// You can only resize a Pool when its allocation state is steady. If the Pool is
// already resizing, the request fails with status code 409. When you resize a
// Pool, the Pool's allocation state changes from steady to resizing. You cannot
// resize Pools which are configured for automatic scaling. If you try to do this,
// the Batch service returns an error 409. If you resize a Pool downwards, the
// Batch service chooses which Compute Nodes to remove. To remove specific Compute
// Nodes, use the Pool remove Compute Nodes API instead.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool to get.
//   - content - The options to use for resizing the pool.
//   - options - ResizePoolOptions contains the optional parameters for the Client.ResizePool method.
func (client *Client) ResizePool(ctx context.Context, poolID string, content ResizePoolContent, options *ResizePoolOptions) (ResizePoolResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.ResizePool", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.resizePoolCreateRequest(ctx, poolID, content, options)
	if err != nil {
		return ResizePoolResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ResizePoolResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return ResizePoolResponse{}, err
	}
	resp, err := client.resizePoolHandleResponse(httpResp)
	return resp, err
}

// resizePoolCreateRequest creates the ResizePool request.
func (client *Client) resizePoolCreateRequest(ctx context.Context, poolID string, content ResizePoolContent, options *ResizePoolOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/resize"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
		return nil, err
	}
	return req, nil
}

// resizePoolHandleResponse handles the ResizePool response.
func (client *Client) resizePoolHandleResponse(resp *http.Response) (ResizePoolResponse, error) {
	result := ResizePoolResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ResizePoolResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// StartNode - Starts the specified Compute Node.
//
// You can start a Compute Node only if it has been deallocated.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node that you want to restart.
//   - options - StartNodeOptions contains the optional parameters for the Client.StartNode method.
func (client *Client) StartNode(ctx context.Context, poolID string, nodeID string, options *StartNodeOptions) (StartNodeResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.StartNode", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.startNodeCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return StartNodeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return StartNodeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return StartNodeResponse{}, err
	}
	resp, err := client.startNodeHandleResponse(httpResp)
	return resp, err
}

// startNodeCreateRequest creates the StartNode request.
func (client *Client) startNodeCreateRequest(ctx context.Context, poolID string, nodeID string, options *StartNodeOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/start"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// startNodeHandleResponse handles the StartNode response.
func (client *Client) startNodeHandleResponse(resp *http.Response) (StartNodeResponse, error) {
	result := StartNodeResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return StartNodeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// StopPoolResize - Stops an ongoing resize operation on the Pool.
//
// This does not restore the Pool to its previous state before the resize
// operation: it only stops any further changes being made, and the Pool maintains
// its current state. After stopping, the Pool stabilizes at the number of Compute
// Nodes it was at when the stop operation was done. During the stop operation,
// the Pool allocation state changes first to stopping and then to steady. A
// resize operation need not be an explicit resize Pool request; this API can also
// be used to halt the initial sizing of the Pool when it is created.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool to get.
//   - options - StopPoolResizeOptions contains the optional parameters for the Client.StopPoolResize method.
func (client *Client) StopPoolResize(ctx context.Context, poolID string, options *StopPoolResizeOptions) (StopPoolResizeResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.StopPoolResize", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.stopPoolResizeCreateRequest(ctx, poolID, options)
	if err != nil {
		return StopPoolResizeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return StopPoolResizeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return StopPoolResizeResponse{}, err
	}
	resp, err := client.stopPoolResizeHandleResponse(httpResp)
	return resp, err
}

// stopPoolResizeCreateRequest creates the StopPoolResize request.
func (client *Client) stopPoolResizeCreateRequest(ctx context.Context, poolID string, options *StopPoolResizeOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/stopresize"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// stopPoolResizeHandleResponse handles the StopPoolResize response.
func (client *Client) stopPoolResizeHandleResponse(resp *http.Response) (StopPoolResizeResponse, error) {
	result := StopPoolResizeResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return StopPoolResizeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// TerminateJob - Terminates the specified Job, marking it as completed.
//
// When a Terminate Job request is received, the Batch service sets the Job to the
// terminating state. The Batch service then terminates any running Tasks
// associated with the Job and runs any required Job release Tasks. Then the Job
// moves into the completed state. If there are any Tasks in the Job in the active
// state, they will remain in the active state. Once a Job is terminated, new
// Tasks cannot be added and any remaining active Tasks will not be scheduled.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job to terminate.
//   - options - TerminateJobOptions contains the optional parameters for the Client.TerminateJob method.
func (client *Client) TerminateJob(ctx context.Context, jobID string, options *TerminateJobOptions) (TerminateJobResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.TerminateJob", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.terminateJobCreateRequest(ctx, jobID, options)
	if err != nil {
		return TerminateJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TerminateJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return TerminateJobResponse{}, err
	}
	resp, err := client.terminateJobHandleResponse(httpResp)
	return resp, err
}

// terminateJobCreateRequest creates the TerminateJob request.
func (client *Client) terminateJobCreateRequest(ctx context.Context, jobID string, options *TerminateJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/terminate"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Force != nil {
		reqQP.Set("force", strconv.FormatBool(*options.Force))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if options != nil && options.Parameters != nil {
		req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
		if err := runtime.MarshalAsJSON(req, *options.Parameters); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// terminateJobHandleResponse handles the TerminateJob response.
func (client *Client) terminateJobHandleResponse(resp *http.Response) (TerminateJobResponse, error) {
	result := TerminateJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return TerminateJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// TerminateJobSchedule - Terminates a Job Schedule.
//
// Terminates a Job Schedule.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobScheduleID - The ID of the Job Schedule to terminates.
//   - options - TerminateJobScheduleOptions contains the optional parameters for the Client.TerminateJobSchedule method.
func (client *Client) TerminateJobSchedule(ctx context.Context, jobScheduleID string, options *TerminateJobScheduleOptions) (TerminateJobScheduleResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.TerminateJobSchedule", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.terminateJobScheduleCreateRequest(ctx, jobScheduleID, options)
	if err != nil {
		return TerminateJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TerminateJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return TerminateJobScheduleResponse{}, err
	}
	resp, err := client.terminateJobScheduleHandleResponse(httpResp)
	return resp, err
}

// terminateJobScheduleCreateRequest creates the TerminateJobSchedule request.
func (client *Client) terminateJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, options *TerminateJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}/terminate"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Force != nil {
		reqQP.Set("force", strconv.FormatBool(*options.Force))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// terminateJobScheduleHandleResponse handles the TerminateJobSchedule response.
func (client *Client) terminateJobScheduleHandleResponse(resp *http.Response) (TerminateJobScheduleResponse, error) {
	result := TerminateJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return TerminateJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// TerminateTask - Terminates the specified Task.
//
// When the Task has been terminated, it moves to the completed state. For
// multi-instance Tasks, the terminate Task operation applies synchronously to the
// primary task; subtasks are then terminated asynchronously in the background.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job containing the Task.
//   - taskID - The ID of the Task to terminate.
//   - options - TerminateTaskOptions contains the optional parameters for the Client.TerminateTask method.
func (client *Client) TerminateTask(ctx context.Context, jobID string, taskID string, options *TerminateTaskOptions) (TerminateTaskResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.TerminateTask", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.terminateTaskCreateRequest(ctx, jobID, taskID, options)
	if err != nil {
		return TerminateTaskResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TerminateTaskResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return TerminateTaskResponse{}, err
	}
	resp, err := client.terminateTaskHandleResponse(httpResp)
	return resp, err
}

// terminateTaskCreateRequest creates the TerminateTask request.
func (client *Client) terminateTaskCreateRequest(ctx context.Context, jobID string, taskID string, options *TerminateTaskOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/terminate"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// terminateTaskHandleResponse handles the TerminateTask response.
func (client *Client) terminateTaskHandleResponse(resp *http.Response) (TerminateTaskResponse, error) {
	result := TerminateTaskResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return TerminateTaskResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// UpdateJob - Updates the properties of the specified Job.
//
// This replaces only the Job properties specified in the request. For example, if
// the Job has constraints, and a request does not specify the constraints
// element, then the Job keeps the existing constraints.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobID - The ID of the Job whose properties you want to update.
//   - job - The options to use for updating the Job.
//   - options - UpdateJobOptions contains the optional parameters for the Client.UpdateJob method.
func (client *Client) UpdateJob(ctx context.Context, jobID string, job UpdateJobContent, options *UpdateJobOptions) (UpdateJobResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.UpdateJob", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateJobCreateRequest(ctx, jobID, job, options)
	if err != nil {
		return UpdateJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return UpdateJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return UpdateJobResponse{}, err
	}
	resp, err := client.updateJobHandleResponse(httpResp)
	return resp, err
}

// updateJobCreateRequest creates the UpdateJob request.
func (client *Client) updateJobCreateRequest(ctx context.Context, jobID string, job UpdateJobContent, options *UpdateJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, job); err != nil {
		return nil, err
	}
	return req, nil
}

// updateJobHandleResponse handles the UpdateJob response.
func (client *Client) updateJobHandleResponse(resp *http.Response) (UpdateJobResponse, error) {
	result := UpdateJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return UpdateJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// UpdateJobSchedule - Updates the properties of the specified Job Schedule.
//
// This replaces only the Job Schedule properties specified in the request. For
// example, if the schedule property is not specified with this request, then the
// Batch service will keep the existing schedule. Changes to a Job Schedule only
// impact Jobs created by the schedule after the update has taken place; currently
// running Jobs are unaffected.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - jobScheduleID - The ID of the Job Schedule to update.
//   - jobSchedule - The options to use for updating the Job Schedule.
//   - options - UpdateJobScheduleOptions contains the optional parameters for the Client.UpdateJobSchedule method.
func (client *Client) UpdateJobSchedule(ctx context.Context, jobScheduleID string, jobSchedule UpdateJobScheduleContent, options *UpdateJobScheduleOptions) (UpdateJobScheduleResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.UpdateJobSchedule", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateJobScheduleCreateRequest(ctx, jobScheduleID, jobSchedule, options)
	if err != nil {
		return UpdateJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return UpdateJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return UpdateJobScheduleResponse{}, err
	}
	resp, err := client.updateJobScheduleHandleResponse(httpResp)
	return resp, err
}

// updateJobScheduleCreateRequest creates the UpdateJobSchedule request.
func (client *Client) updateJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, jobSchedule UpdateJobScheduleContent, options *UpdateJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, jobSchedule); err != nil {
		return nil, err
	}
	return req, nil
}

// updateJobScheduleHandleResponse handles the UpdateJobSchedule response.
func (client *Client) updateJobScheduleHandleResponse(resp *http.Response) (UpdateJobScheduleResponse, error) {
	result := UpdateJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return UpdateJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// UpdatePool - Updates the properties of the specified Pool.
//
// This only replaces the Pool properties specified in the request. For example,
// if the Pool has a StartTask associated with it, and a request does not specify
// a StartTask element, then the Pool keeps the existing StartTask.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool to get.
//   - pool - The pool properties to update.
//   - options - UpdatePoolOptions contains the optional parameters for the Client.UpdatePool method.
func (client *Client) UpdatePool(ctx context.Context, poolID string, pool UpdatePoolContent, options *UpdatePoolOptions) (UpdatePoolResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.UpdatePool", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updatePoolCreateRequest(ctx, poolID, pool, options)
	if err != nil {
		return UpdatePoolResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return UpdatePoolResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return UpdatePoolResponse{}, err
	}
	resp, err := client.updatePoolHandleResponse(httpResp)
	return resp, err
}

// updatePoolCreateRequest creates the UpdatePool request.
func (client *Client) updatePoolCreateRequest(ctx context.Context, poolID string, pool UpdatePoolContent, options *UpdatePoolOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, pool); err != nil {
		return nil, err
	}
	return req, nil
}

// updatePoolHandleResponse handles the UpdatePool response.
func (client *Client) updatePoolHandleResponse(resp *http.Response) (UpdatePoolResponse, error) {
	result := UpdatePoolResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return UpdatePoolResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// UploadNodeLogs - Upload Azure Batch service log files from the specified Compute Node to Azure
// Blob Storage.
//
// This is for gathering Azure Batch service log files in an automated fashion
// from Compute Nodes if you are experiencing an error and wish to escalate to
// Azure support. The Azure Batch service log files should be shared with Azure
// support to aid in debugging issues with the Batch service.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01.20.0
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node for which you want to get the Remote Desktop
//     Protocol file.
//   - content - The Azure Batch service log files upload options.
//   - options - UploadNodeLogsOptions contains the optional parameters for the Client.UploadNodeLogs method.
func (client *Client) UploadNodeLogs(ctx context.Context, poolID string, nodeID string, content UploadNodeLogsContent, options *UploadNodeLogsOptions) (UploadNodeLogsResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "Client.UploadNodeLogs", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.uploadNodeLogsCreateRequest(ctx, poolID, nodeID, content, options)
	if err != nil {
		return UploadNodeLogsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return UploadNodeLogsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return UploadNodeLogsResponse{}, err
	}
	resp, err := client.uploadNodeLogsHandleResponse(httpResp)
	return resp, err
}

// uploadNodeLogsCreateRequest creates the UploadNodeLogs request.
func (client *Client) uploadNodeLogsCreateRequest(ctx context.Context, poolID string, nodeID string, content UploadNodeLogsContent, options *UploadNodeLogsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/uploadbatchservicelogs"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
		return nil, err
	}
	return req, nil
}

// uploadNodeLogsHandleResponse handles the UploadNodeLogs response.
func (client *Client) uploadNodeLogsHandleResponse(resp *http.Response) (UploadNodeLogsResponse, error) {
	result := UploadNodeLogsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return UploadNodeLogsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.UploadNodeLogsResult); err != nil {
		return UploadNodeLogsResponse{}, err
	}
	return result, nil
}

// NewlistPoolUsageMetricsPager - Lists the usage metrics, aggregated by Pool across individual time intervals,
// for the specified Account.
//
// If you do not specify a $filter clause including a poolId, the response
// includes all Pools that existed in the Account in the time range of the
// returned aggregation intervals. If you do not specify a $filter clause
// including a startTime or endTime these filters default to the start and end
// times of the last aggregation interval currently available; that is, only the
// last aggregation interval is returned.
//
// Generated from API version 2024-07-01.20.0
//   - options - listPoolUsageMetricsOptions contains the optional parameters for the Client.NewlistPoolUsageMetricsPager method.
func (client *Client) NewlistPoolUsageMetricsPager(options *listPoolUsageMetricsOptions) *runtime.Pager[listPoolUsageMetricsResponse] {
	return runtime.NewPager(runtime.PagingHandler[listPoolUsageMetricsResponse]{
		More: func(page listPoolUsageMetricsResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *listPoolUsageMetricsResponse) (listPoolUsageMetricsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listPoolUsageMetricsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return listPoolUsageMetricsResponse{}, err
			}
			return client.listPoolUsageMetricsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listPoolUsageMetricsCreateRequest creates the listPoolUsageMetrics request.
func (client *Client) listPoolUsageMetricsCreateRequest(ctx context.Context, options *listPoolUsageMetricsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/poolusagemetrics"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2024-07-01.20.0")
	if options != nil && options.Endtime != nil {
		reqQP.Set("endtime", options.Endtime.Format(time.RFC3339Nano))
	}
	if options != nil && options.MaxResults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.MaxResults), 10))
	}
	if options != nil && options.Starttime != nil {
		reqQP.Set("startTime", options.Starttime.Format(time.RFC3339Nano))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.OCPDate != nil {
		req.Raw().Header["ocp-date"] = []string{options.OCPDate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listPoolUsageMetricsHandleResponse handles the listPoolUsageMetrics response.
func (client *Client) listPoolUsageMetricsHandleResponse(resp *http.Response) (listPoolUsageMetricsResponse, error) {
	result := listPoolUsageMetricsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return listPoolUsageMetricsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.listPoolUsageMetricsResult); err != nil {
		return listPoolUsageMetricsResponse{}, err
	}
	return result, nil
}
