// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package azbatch

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strconv"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
)

// MarshalJSON implements the json.Marshaller interface for type AccountListSupportedImagesResult.
func (a AccountListSupportedImagesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountListSupportedImagesResult.
func (a *AccountListSupportedImagesResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddTaskCollectionResult.
func (a AddTaskCollectionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddTaskCollectionResult.
func (a *AddTaskCollectionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AffinityInfo.
func (a AffinityInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityId", a.AffinityID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AffinityInfo.
func (a *AffinityInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityId":
			err = unpopulate(val, "AffinityID", &a.AffinityID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Application.
func (a Application) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "versions", a.Versions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Application.
func (a *Application) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "versions":
			err = unpopulate(val, "Versions", &a.Versions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationListResult.
func (a ApplicationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationListResult.
func (a *ApplicationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationPackageReference.
func (a ApplicationPackageReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationId", a.ApplicationID)
	populate(objectMap, "version", a.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationPackageReference.
func (a *ApplicationPackageReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationId":
			err = unpopulate(val, "ApplicationID", &a.ApplicationID)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &a.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AuthenticationTokenSettings.
func (a AuthenticationTokenSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "access", a.Access)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AuthenticationTokenSettings.
func (a *AuthenticationTokenSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "access":
			err = unpopulate(val, "Access", &a.Access)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutoPoolSpecification.
func (a AutoPoolSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoPoolIdPrefix", a.AutoPoolIDPrefix)
	populate(objectMap, "keepAlive", a.KeepAlive)
	populate(objectMap, "pool", a.Pool)
	populate(objectMap, "poolLifetimeOption", a.PoolLifetimeOption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutoPoolSpecification.
func (a *AutoPoolSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoPoolIdPrefix":
			err = unpopulate(val, "AutoPoolIDPrefix", &a.AutoPoolIDPrefix)
			delete(rawMsg, key)
		case "keepAlive":
			err = unpopulate(val, "KeepAlive", &a.KeepAlive)
			delete(rawMsg, key)
		case "pool":
			err = unpopulate(val, "Pool", &a.Pool)
			delete(rawMsg, key)
		case "poolLifetimeOption":
			err = unpopulate(val, "PoolLifetimeOption", &a.PoolLifetimeOption)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutoScaleRun.
func (a AutoScaleRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", a.Error)
	populate(objectMap, "results", a.Results)
	populateDateTimeRFC3339(objectMap, "timestamp", a.Timestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutoScaleRun.
func (a *AutoScaleRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, "Error", &a.Error)
			delete(rawMsg, key)
		case "results":
			err = unpopulate(val, "Results", &a.Results)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateDateTimeRFC3339(val, "Timestamp", &a.Timestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutoScaleRunError.
func (a AutoScaleRunError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", a.Code)
	populate(objectMap, "message", a.Message)
	populate(objectMap, "values", a.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutoScaleRunError.
func (a *AutoScaleRunError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &a.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &a.Message)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &a.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutoUserSpecification.
func (a AutoUserSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "elevationLevel", a.ElevationLevel)
	populate(objectMap, "scope", a.Scope)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutoUserSpecification.
func (a *AutoUserSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "elevationLevel":
			err = unpopulate(val, "ElevationLevel", &a.ElevationLevel)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, "Scope", &a.Scope)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutomaticOSUpgradePolicy.
func (a AutomaticOSUpgradePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "disableAutomaticRollback", a.DisableAutomaticRollback)
	populate(objectMap, "enableAutomaticOSUpgrade", a.EnableAutomaticOsUpgrade)
	populate(objectMap, "osRollingUpgradeDeferral", a.OSRollingUpgradeDeferral)
	populate(objectMap, "useRollingUpgradePolicy", a.UseRollingUpgradePolicy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutomaticOSUpgradePolicy.
func (a *AutomaticOSUpgradePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableAutomaticRollback":
			err = unpopulate(val, "DisableAutomaticRollback", &a.DisableAutomaticRollback)
			delete(rawMsg, key)
		case "enableAutomaticOSUpgrade":
			err = unpopulate(val, "EnableAutomaticOsUpgrade", &a.EnableAutomaticOsUpgrade)
			delete(rawMsg, key)
		case "osRollingUpgradeDeferral":
			err = unpopulate(val, "OSRollingUpgradeDeferral", &a.OSRollingUpgradeDeferral)
			delete(rawMsg, key)
		case "useRollingUpgradePolicy":
			err = unpopulate(val, "UseRollingUpgradePolicy", &a.UseRollingUpgradePolicy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFileSystemConfiguration.
func (a AzureBlobFileSystemConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accountKey", a.AccountKey)
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "blobfuseOptions", a.BlobfuseOptions)
	populate(objectMap, "containerName", a.ContainerName)
	populate(objectMap, "identityReference", a.IdentityReference)
	populate(objectMap, "relativeMountPath", a.RelativeMountPath)
	populate(objectMap, "sasKey", a.SASKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFileSystemConfiguration.
func (a *AzureBlobFileSystemConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			err = unpopulate(val, "AccountKey", &a.AccountKey)
			delete(rawMsg, key)
		case "accountName":
			err = unpopulate(val, "AccountName", &a.AccountName)
			delete(rawMsg, key)
		case "blobfuseOptions":
			err = unpopulate(val, "BlobfuseOptions", &a.BlobfuseOptions)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "identityReference":
			err = unpopulate(val, "IdentityReference", &a.IdentityReference)
			delete(rawMsg, key)
		case "relativeMountPath":
			err = unpopulate(val, "RelativeMountPath", &a.RelativeMountPath)
			delete(rawMsg, key)
		case "sasKey":
			err = unpopulate(val, "SASKey", &a.SASKey)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileShareConfiguration.
func (a AzureFileShareConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accountKey", a.AccountKey)
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "azureFileUrl", a.AzureFileURL)
	populate(objectMap, "mountOptions", a.MountOptions)
	populate(objectMap, "relativeMountPath", a.RelativeMountPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileShareConfiguration.
func (a *AzureFileShareConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			err = unpopulate(val, "AccountKey", &a.AccountKey)
			delete(rawMsg, key)
		case "accountName":
			err = unpopulate(val, "AccountName", &a.AccountName)
			delete(rawMsg, key)
		case "azureFileUrl":
			err = unpopulate(val, "AzureFileURL", &a.AzureFileURL)
			delete(rawMsg, key)
		case "mountOptions":
			err = unpopulate(val, "MountOptions", &a.MountOptions)
			delete(rawMsg, key)
		case "relativeMountPath":
			err = unpopulate(val, "RelativeMountPath", &a.RelativeMountPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CIFSMountConfiguration.
func (c CIFSMountConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "mountOptions", c.MountOptions)
	populate(objectMap, "password", c.Password)
	populate(objectMap, "relativeMountPath", c.RelativeMountPath)
	populate(objectMap, "source", c.Source)
	populate(objectMap, "username", c.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CIFSMountConfiguration.
func (c *CIFSMountConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mountOptions":
			err = unpopulate(val, "MountOptions", &c.MountOptions)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &c.Password)
			delete(rawMsg, key)
		case "relativeMountPath":
			err = unpopulate(val, "RelativeMountPath", &c.RelativeMountPath)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &c.Source)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &c.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Certificate.
func (c Certificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "data", c.Data)
	populate(objectMap, "deleteCertificateError", c.DeleteCertificateError)
	populate(objectMap, "certificateFormat", c.Format)
	populate(objectMap, "password", c.Password)
	populate(objectMap, "previousState", c.PreviousState)
	populateDateTimeRFC3339(objectMap, "previousStateTransitionTime", c.PreviousStateTransitionTime)
	populate(objectMap, "publicData", c.PublicData)
	populate(objectMap, "state", c.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", c.StateTransitionTime)
	populate(objectMap, "thumbprint", c.Thumbprint)
	populate(objectMap, "thumbprintAlgorithm", c.ThumbprintAlgorithm)
	populate(objectMap, "url", c.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Certificate.
func (c *Certificate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "data":
			err = unpopulate(val, "Data", &c.Data)
			delete(rawMsg, key)
		case "deleteCertificateError":
			err = unpopulate(val, "DeleteCertificateError", &c.DeleteCertificateError)
			delete(rawMsg, key)
		case "certificateFormat":
			err = unpopulate(val, "Format", &c.Format)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &c.Password)
			delete(rawMsg, key)
		case "previousState":
			err = unpopulate(val, "PreviousState", &c.PreviousState)
			delete(rawMsg, key)
		case "previousStateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "PreviousStateTransitionTime", &c.PreviousStateTransitionTime)
			delete(rawMsg, key)
		case "publicData":
			err = unpopulate(val, "PublicData", &c.PublicData)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &c.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &c.StateTransitionTime)
			delete(rawMsg, key)
		case "thumbprint":
			err = unpopulate(val, "Thumbprint", &c.Thumbprint)
			delete(rawMsg, key)
		case "thumbprintAlgorithm":
			err = unpopulate(val, "ThumbprintAlgorithm", &c.ThumbprintAlgorithm)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &c.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CertificateListResult.
func (c CertificateListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateListResult.
func (c *CertificateListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CertificateReference.
func (c CertificateReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "storeLocation", c.StoreLocation)
	populate(objectMap, "storeName", c.StoreName)
	populate(objectMap, "thumbprint", c.Thumbprint)
	populate(objectMap, "thumbprintAlgorithm", c.ThumbprintAlgorithm)
	populate(objectMap, "visibility", c.Visibility)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateReference.
func (c *CertificateReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storeLocation":
			err = unpopulate(val, "StoreLocation", &c.StoreLocation)
			delete(rawMsg, key)
		case "storeName":
			err = unpopulate(val, "StoreName", &c.StoreName)
			delete(rawMsg, key)
		case "thumbprint":
			err = unpopulate(val, "Thumbprint", &c.Thumbprint)
			delete(rawMsg, key)
		case "thumbprintAlgorithm":
			err = unpopulate(val, "ThumbprintAlgorithm", &c.ThumbprintAlgorithm)
			delete(rawMsg, key)
		case "visibility":
			err = unpopulate(val, "Visibility", &c.Visibility)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerConfiguration.
func (c ContainerConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerImageNames", c.ContainerImageNames)
	populate(objectMap, "containerRegistries", c.ContainerRegistries)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerConfiguration.
func (c *ContainerConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerImageNames":
			err = unpopulate(val, "ContainerImageNames", &c.ContainerImageNames)
			delete(rawMsg, key)
		case "containerRegistries":
			err = unpopulate(val, "ContainerRegistries", &c.ContainerRegistries)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerHostBindMountEntry.
func (c ContainerHostBindMountEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isReadOnly", c.IsReadOnly)
	populate(objectMap, "source", c.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerHostBindMountEntry.
func (c *ContainerHostBindMountEntry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isReadOnly":
			err = unpopulate(val, "IsReadOnly", &c.IsReadOnly)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &c.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerRegistryReference.
func (c ContainerRegistryReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identityReference", c.IdentityReference)
	populate(objectMap, "password", c.Password)
	populate(objectMap, "registryServer", c.RegistryServer)
	populate(objectMap, "username", c.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerRegistryReference.
func (c *ContainerRegistryReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identityReference":
			err = unpopulate(val, "IdentityReference", &c.IdentityReference)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &c.Password)
			delete(rawMsg, key)
		case "registryServer":
			err = unpopulate(val, "RegistryServer", &c.RegistryServer)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &c.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateJobContent.
func (c CreateJobContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowTaskPreemption", c.AllowTaskPreemption)
	populate(objectMap, "commonEnvironmentSettings", c.CommonEnvironmentSettings)
	populate(objectMap, "constraints", c.Constraints)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "jobManagerTask", c.JobManagerTask)
	populate(objectMap, "jobPreparationTask", c.JobPreparationTask)
	populate(objectMap, "jobReleaseTask", c.JobReleaseTask)
	populate(objectMap, "maxParallelTasks", c.MaxParallelTasks)
	populate(objectMap, "metadata", c.Metadata)
	populate(objectMap, "networkConfiguration", c.NetworkConfiguration)
	populate(objectMap, "onAllTasksComplete", c.OnAllTasksComplete)
	populate(objectMap, "onTaskFailure", c.OnTaskFailure)
	populate(objectMap, "poolInfo", c.PoolInfo)
	populate(objectMap, "priority", c.Priority)
	populate(objectMap, "usesTaskDependencies", c.UsesTaskDependencies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateJobContent.
func (c *CreateJobContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowTaskPreemption":
			err = unpopulate(val, "AllowTaskPreemption", &c.AllowTaskPreemption)
			delete(rawMsg, key)
		case "commonEnvironmentSettings":
			err = unpopulate(val, "CommonEnvironmentSettings", &c.CommonEnvironmentSettings)
			delete(rawMsg, key)
		case "constraints":
			err = unpopulate(val, "Constraints", &c.Constraints)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "jobManagerTask":
			err = unpopulate(val, "JobManagerTask", &c.JobManagerTask)
			delete(rawMsg, key)
		case "jobPreparationTask":
			err = unpopulate(val, "JobPreparationTask", &c.JobPreparationTask)
			delete(rawMsg, key)
		case "jobReleaseTask":
			err = unpopulate(val, "JobReleaseTask", &c.JobReleaseTask)
			delete(rawMsg, key)
		case "maxParallelTasks":
			err = unpopulate(val, "MaxParallelTasks", &c.MaxParallelTasks)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &c.Metadata)
			delete(rawMsg, key)
		case "networkConfiguration":
			err = unpopulate(val, "NetworkConfiguration", &c.NetworkConfiguration)
			delete(rawMsg, key)
		case "onAllTasksComplete":
			err = unpopulate(val, "OnAllTasksComplete", &c.OnAllTasksComplete)
			delete(rawMsg, key)
		case "onTaskFailure":
			err = unpopulate(val, "OnTaskFailure", &c.OnTaskFailure)
			delete(rawMsg, key)
		case "poolInfo":
			err = unpopulate(val, "PoolInfo", &c.PoolInfo)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, "Priority", &c.Priority)
			delete(rawMsg, key)
		case "usesTaskDependencies":
			err = unpopulate(val, "UsesTaskDependencies", &c.UsesTaskDependencies)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateJobScheduleContent.
func (c CreateJobScheduleContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "jobSpecification", c.JobSpecification)
	populate(objectMap, "metadata", c.Metadata)
	populate(objectMap, "schedule", c.Schedule)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateJobScheduleContent.
func (c *CreateJobScheduleContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "jobSpecification":
			err = unpopulate(val, "JobSpecification", &c.JobSpecification)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &c.Metadata)
			delete(rawMsg, key)
		case "schedule":
			err = unpopulate(val, "Schedule", &c.Schedule)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateNodeUserContent.
func (c CreateNodeUserContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "expiryTime", c.ExpiryTime)
	populate(objectMap, "isAdmin", c.IsAdmin)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "password", c.Password)
	populate(objectMap, "sshPublicKey", c.SSHPublicKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateNodeUserContent.
func (c *CreateNodeUserContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiryTime":
			err = unpopulateDateTimeRFC3339(val, "ExpiryTime", &c.ExpiryTime)
			delete(rawMsg, key)
		case "isAdmin":
			err = unpopulate(val, "IsAdmin", &c.IsAdmin)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &c.Password)
			delete(rawMsg, key)
		case "sshPublicKey":
			err = unpopulate(val, "SSHPublicKey", &c.SSHPublicKey)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreatePoolContent.
func (c CreatePoolContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationPackageReferences", c.ApplicationPackageReferences)
	populate(objectMap, "autoScaleEvaluationInterval", c.AutoScaleEvaluationInterval)
	populate(objectMap, "autoScaleFormula", c.AutoScaleFormula)
	populate(objectMap, "certificateReferences", c.CertificateReferences)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "enableAutoScale", c.EnableAutoScale)
	populate(objectMap, "enableInterNodeCommunication", c.EnableInterNodeCommunication)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "metadata", c.Metadata)
	populate(objectMap, "mountConfiguration", c.MountConfiguration)
	populate(objectMap, "networkConfiguration", c.NetworkConfiguration)
	populate(objectMap, "resizeTimeout", c.ResizeTimeout)
	populate(objectMap, "resourceTags", c.ResourceTags)
	populate(objectMap, "startTask", c.StartTask)
	populate(objectMap, "targetDedicatedNodes", c.TargetDedicatedNodes)
	populate(objectMap, "targetLowPriorityNodes", c.TargetLowPriorityNodes)
	populate(objectMap, "targetNodeCommunicationMode", c.TargetNodeCommunicationMode)
	populate(objectMap, "taskSchedulingPolicy", c.TaskSchedulingPolicy)
	populate(objectMap, "taskSlotsPerNode", c.TaskSlotsPerNode)
	populate(objectMap, "upgradePolicy", c.UpgradePolicy)
	populate(objectMap, "userAccounts", c.UserAccounts)
	populate(objectMap, "vmSize", c.VMSize)
	populate(objectMap, "virtualMachineConfiguration", c.VirtualMachineConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreatePoolContent.
func (c *CreatePoolContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationPackageReferences":
			err = unpopulate(val, "ApplicationPackageReferences", &c.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "autoScaleEvaluationInterval":
			err = unpopulate(val, "AutoScaleEvaluationInterval", &c.AutoScaleEvaluationInterval)
			delete(rawMsg, key)
		case "autoScaleFormula":
			err = unpopulate(val, "AutoScaleFormula", &c.AutoScaleFormula)
			delete(rawMsg, key)
		case "certificateReferences":
			err = unpopulate(val, "CertificateReferences", &c.CertificateReferences)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "enableAutoScale":
			err = unpopulate(val, "EnableAutoScale", &c.EnableAutoScale)
			delete(rawMsg, key)
		case "enableInterNodeCommunication":
			err = unpopulate(val, "EnableInterNodeCommunication", &c.EnableInterNodeCommunication)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &c.Metadata)
			delete(rawMsg, key)
		case "mountConfiguration":
			err = unpopulate(val, "MountConfiguration", &c.MountConfiguration)
			delete(rawMsg, key)
		case "networkConfiguration":
			err = unpopulate(val, "NetworkConfiguration", &c.NetworkConfiguration)
			delete(rawMsg, key)
		case "resizeTimeout":
			err = unpopulate(val, "ResizeTimeout", &c.ResizeTimeout)
			delete(rawMsg, key)
		case "resourceTags":
			err = unpopulate(val, "ResourceTags", &c.ResourceTags)
			delete(rawMsg, key)
		case "startTask":
			err = unpopulate(val, "StartTask", &c.StartTask)
			delete(rawMsg, key)
		case "targetDedicatedNodes":
			err = unpopulate(val, "TargetDedicatedNodes", &c.TargetDedicatedNodes)
			delete(rawMsg, key)
		case "targetLowPriorityNodes":
			err = unpopulate(val, "TargetLowPriorityNodes", &c.TargetLowPriorityNodes)
			delete(rawMsg, key)
		case "targetNodeCommunicationMode":
			err = unpopulate(val, "TargetNodeCommunicationMode", &c.TargetNodeCommunicationMode)
			delete(rawMsg, key)
		case "taskSchedulingPolicy":
			err = unpopulate(val, "TaskSchedulingPolicy", &c.TaskSchedulingPolicy)
			delete(rawMsg, key)
		case "taskSlotsPerNode":
			err = unpopulate(val, "TaskSlotsPerNode", &c.TaskSlotsPerNode)
			delete(rawMsg, key)
		case "upgradePolicy":
			err = unpopulate(val, "UpgradePolicy", &c.UpgradePolicy)
			delete(rawMsg, key)
		case "userAccounts":
			err = unpopulate(val, "UserAccounts", &c.UserAccounts)
			delete(rawMsg, key)
		case "vmSize":
			err = unpopulate(val, "VMSize", &c.VMSize)
			delete(rawMsg, key)
		case "virtualMachineConfiguration":
			err = unpopulate(val, "VirtualMachineConfiguration", &c.VirtualMachineConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateTaskContent.
func (c CreateTaskContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityInfo", c.AffinityInfo)
	populate(objectMap, "applicationPackageReferences", c.ApplicationPackageReferences)
	populate(objectMap, "authenticationTokenSettings", c.AuthenticationTokenSettings)
	populate(objectMap, "commandLine", c.CommandLine)
	populate(objectMap, "constraints", c.Constraints)
	populate(objectMap, "containerSettings", c.ContainerSettings)
	populate(objectMap, "dependsOn", c.DependsOn)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "environmentSettings", c.EnvironmentSettings)
	populate(objectMap, "exitConditions", c.ExitConditions)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "multiInstanceSettings", c.MultiInstanceSettings)
	populate(objectMap, "outputFiles", c.OutputFiles)
	populate(objectMap, "requiredSlots", c.RequiredSlots)
	populate(objectMap, "resourceFiles", c.ResourceFiles)
	populate(objectMap, "userIdentity", c.UserIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateTaskContent.
func (c *CreateTaskContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityInfo":
			err = unpopulate(val, "AffinityInfo", &c.AffinityInfo)
			delete(rawMsg, key)
		case "applicationPackageReferences":
			err = unpopulate(val, "ApplicationPackageReferences", &c.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "authenticationTokenSettings":
			err = unpopulate(val, "AuthenticationTokenSettings", &c.AuthenticationTokenSettings)
			delete(rawMsg, key)
		case "commandLine":
			err = unpopulate(val, "CommandLine", &c.CommandLine)
			delete(rawMsg, key)
		case "constraints":
			err = unpopulate(val, "Constraints", &c.Constraints)
			delete(rawMsg, key)
		case "containerSettings":
			err = unpopulate(val, "ContainerSettings", &c.ContainerSettings)
			delete(rawMsg, key)
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &c.DependsOn)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "environmentSettings":
			err = unpopulate(val, "EnvironmentSettings", &c.EnvironmentSettings)
			delete(rawMsg, key)
		case "exitConditions":
			err = unpopulate(val, "ExitConditions", &c.ExitConditions)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "multiInstanceSettings":
			err = unpopulate(val, "MultiInstanceSettings", &c.MultiInstanceSettings)
			delete(rawMsg, key)
		case "outputFiles":
			err = unpopulate(val, "OutputFiles", &c.OutputFiles)
			delete(rawMsg, key)
		case "requiredSlots":
			err = unpopulate(val, "RequiredSlots", &c.RequiredSlots)
			delete(rawMsg, key)
		case "resourceFiles":
			err = unpopulate(val, "ResourceFiles", &c.ResourceFiles)
			delete(rawMsg, key)
		case "userIdentity":
			err = unpopulate(val, "UserIdentity", &c.UserIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataDisk.
func (d DataDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "caching", d.Caching)
	populate(objectMap, "diskSizeGB", d.DiskSizeGB)
	populate(objectMap, "lun", d.LogicalUnitNumber)
	populate(objectMap, "storageAccountType", d.StorageAccountType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataDisk.
func (d *DataDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "caching":
			err = unpopulate(val, "Caching", &d.Caching)
			delete(rawMsg, key)
		case "diskSizeGB":
			err = unpopulate(val, "DiskSizeGB", &d.DiskSizeGB)
			delete(rawMsg, key)
		case "lun":
			err = unpopulate(val, "LogicalUnitNumber", &d.LogicalUnitNumber)
			delete(rawMsg, key)
		case "storageAccountType":
			err = unpopulate(val, "StorageAccountType", &d.StorageAccountType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeallocateNodeContent.
func (d DeallocateNodeContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeDeallocateOption", d.NodeDeallocateOption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeallocateNodeContent.
func (d *DeallocateNodeContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeDeallocateOption":
			err = unpopulate(val, "NodeDeallocateOption", &d.NodeDeallocateOption)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeleteCertificateError.
func (d DeleteCertificateError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", d.Code)
	populate(objectMap, "message", d.Message)
	populate(objectMap, "values", d.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeleteCertificateError.
func (d *DeleteCertificateError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &d.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &d.Message)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &d.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiffDiskSettings.
func (d DiffDiskSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "placement", d.Placement)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiffDiskSettings.
func (d *DiffDiskSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "placement":
			err = unpopulate(val, "Placement", &d.Placement)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DisableJobContent.
func (d DisableJobContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "disableTasks", d.DisableTasks)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DisableJobContent.
func (d *DisableJobContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableTasks":
			err = unpopulate(val, "DisableTasks", &d.DisableTasks)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DisableNodeSchedulingContent.
func (d DisableNodeSchedulingContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeDisableSchedulingOption", d.NodeDisableSchedulingOption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DisableNodeSchedulingContent.
func (d *DisableNodeSchedulingContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeDisableSchedulingOption":
			err = unpopulate(val, "NodeDisableSchedulingOption", &d.NodeDisableSchedulingOption)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiskEncryptionConfiguration.
func (d DiskEncryptionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "targets", d.Targets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskEncryptionConfiguration.
func (d *DiskEncryptionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "targets":
			err = unpopulate(val, "Targets", &d.Targets)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnablePoolAutoScaleContent.
func (e EnablePoolAutoScaleContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoScaleEvaluationInterval", e.AutoScaleEvaluationInterval)
	populate(objectMap, "autoScaleFormula", e.AutoScaleFormula)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnablePoolAutoScaleContent.
func (e *EnablePoolAutoScaleContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoScaleEvaluationInterval":
			err = unpopulate(val, "AutoScaleEvaluationInterval", &e.AutoScaleEvaluationInterval)
			delete(rawMsg, key)
		case "autoScaleFormula":
			err = unpopulate(val, "AutoScaleFormula", &e.AutoScaleFormula)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentSetting.
func (e EnvironmentSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentSetting.
func (e *EnvironmentSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Error.
func (e Error) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "values", e.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Error.
func (e *Error) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &e.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", e.Key)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetail.
func (e *ErrorDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, "Key", &e.Key)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorMessage.
func (e ErrorMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "lang", e.Lang)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorMessage.
func (e *ErrorMessage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lang":
			err = unpopulate(val, "Lang", &e.Lang)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatePoolAutoScaleContent.
func (e EvaluatePoolAutoScaleContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoScaleFormula", e.AutoScaleFormula)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatePoolAutoScaleContent.
func (e *EvaluatePoolAutoScaleContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoScaleFormula":
			err = unpopulate(val, "AutoScaleFormula", &e.AutoScaleFormula)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExitCodeMapping.
func (e ExitCodeMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "exitOptions", e.ExitOptions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExitCodeMapping.
func (e *ExitCodeMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "exitOptions":
			err = unpopulate(val, "ExitOptions", &e.ExitOptions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExitCodeRangeMapping.
func (e ExitCodeRangeMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "end", e.End)
	populate(objectMap, "exitOptions", e.ExitOptions)
	populate(objectMap, "start", e.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExitCodeRangeMapping.
func (e *ExitCodeRangeMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "end":
			err = unpopulate(val, "End", &e.End)
			delete(rawMsg, key)
		case "exitOptions":
			err = unpopulate(val, "ExitOptions", &e.ExitOptions)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, "Start", &e.Start)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExitConditions.
func (e ExitConditions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "default", e.Default)
	populate(objectMap, "exitCodeRanges", e.ExitCodeRanges)
	populate(objectMap, "exitCodes", e.ExitCodes)
	populate(objectMap, "fileUploadError", e.FileUploadError)
	populate(objectMap, "preProcessingError", e.PreProcessingError)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExitConditions.
func (e *ExitConditions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "default":
			err = unpopulate(val, "Default", &e.Default)
			delete(rawMsg, key)
		case "exitCodeRanges":
			err = unpopulate(val, "ExitCodeRanges", &e.ExitCodeRanges)
			delete(rawMsg, key)
		case "exitCodes":
			err = unpopulate(val, "ExitCodes", &e.ExitCodes)
			delete(rawMsg, key)
		case "fileUploadError":
			err = unpopulate(val, "FileUploadError", &e.FileUploadError)
			delete(rawMsg, key)
		case "preProcessingError":
			err = unpopulate(val, "PreProcessingError", &e.PreProcessingError)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExitOptions.
func (e ExitOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependencyAction", e.DependencyAction)
	populate(objectMap, "jobAction", e.JobAction)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExitOptions.
func (e *ExitOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependencyAction":
			err = unpopulate(val, "DependencyAction", &e.DependencyAction)
			delete(rawMsg, key)
		case "jobAction":
			err = unpopulate(val, "JobAction", &e.JobAction)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileProperties.
func (f FileProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contentLength", to.Ptr(strconv.FormatInt(*f.ContentLength, 10)))
	populate(objectMap, "contentType", f.ContentType)
	populateDateTimeRFC3339(objectMap, "creationTime", f.CreationTime)
	populate(objectMap, "fileMode", f.FileMode)
	populateDateTimeRFC3339(objectMap, "lastModified", f.LastModified)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileProperties.
func (f *FileProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentLength":
			var aux string
			err = unpopulate(val, "ContentLength", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					f.ContentLength = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		case "contentType":
			err = unpopulate(val, "ContentType", &f.ContentType)
			delete(rawMsg, key)
		case "creationTime":
			err = unpopulateDateTimeRFC3339(val, "CreationTime", &f.CreationTime)
			delete(rawMsg, key)
		case "fileMode":
			err = unpopulate(val, "FileMode", &f.FileMode)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateDateTimeRFC3339(val, "LastModified", &f.LastModified)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPHeader.
func (h HTTPHeader) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPHeader.
func (h *HTTPHeader) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageReference.
func (i ImageReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "communityGalleryImageId", i.CommunityGalleryImageID)
	populate(objectMap, "exactVersion", i.ExactVersion)
	populate(objectMap, "offer", i.Offer)
	populate(objectMap, "publisher", i.Publisher)
	populate(objectMap, "sku", i.SKU)
	populate(objectMap, "sharedGalleryImageId", i.SharedGalleryImageID)
	populate(objectMap, "version", i.Version)
	populate(objectMap, "virtualMachineImageId", i.VirtualMachineImageID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageReference.
func (i *ImageReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "communityGalleryImageId":
			err = unpopulate(val, "CommunityGalleryImageID", &i.CommunityGalleryImageID)
			delete(rawMsg, key)
		case "exactVersion":
			err = unpopulate(val, "ExactVersion", &i.ExactVersion)
			delete(rawMsg, key)
		case "offer":
			err = unpopulate(val, "Offer", &i.Offer)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &i.Publisher)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, "SKU", &i.SKU)
			delete(rawMsg, key)
		case "sharedGalleryImageId":
			err = unpopulate(val, "SharedGalleryImageID", &i.SharedGalleryImageID)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &i.Version)
			delete(rawMsg, key)
		case "virtualMachineImageId":
			err = unpopulate(val, "VirtualMachineImageID", &i.VirtualMachineImageID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InboundEndpoint.
func (i InboundEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backendPort", i.BackendPort)
	populate(objectMap, "frontendPort", i.FrontendPort)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "protocol", i.Protocol)
	populate(objectMap, "publicFQDN", i.PublicFQDN)
	populate(objectMap, "publicIPAddress", i.PublicIPAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InboundEndpoint.
func (i *InboundEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backendPort":
			err = unpopulate(val, "BackendPort", &i.BackendPort)
			delete(rawMsg, key)
		case "frontendPort":
			err = unpopulate(val, "FrontendPort", &i.FrontendPort)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, "Protocol", &i.Protocol)
			delete(rawMsg, key)
		case "publicFQDN":
			err = unpopulate(val, "PublicFQDN", &i.PublicFQDN)
			delete(rawMsg, key)
		case "publicIPAddress":
			err = unpopulate(val, "PublicIPAddress", &i.PublicIPAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InboundNATPool.
func (i InboundNATPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backendPort", i.BackendPort)
	populate(objectMap, "frontendPortRangeEnd", i.FrontendPortRangeEnd)
	populate(objectMap, "frontendPortRangeStart", i.FrontendPortRangeStart)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "networkSecurityGroupRules", i.NetworkSecurityGroupRules)
	populate(objectMap, "protocol", i.Protocol)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InboundNATPool.
func (i *InboundNATPool) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backendPort":
			err = unpopulate(val, "BackendPort", &i.BackendPort)
			delete(rawMsg, key)
		case "frontendPortRangeEnd":
			err = unpopulate(val, "FrontendPortRangeEnd", &i.FrontendPortRangeEnd)
			delete(rawMsg, key)
		case "frontendPortRangeStart":
			err = unpopulate(val, "FrontendPortRangeStart", &i.FrontendPortRangeStart)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "networkSecurityGroupRules":
			err = unpopulate(val, "NetworkSecurityGroupRules", &i.NetworkSecurityGroupRules)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, "Protocol", &i.Protocol)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InstanceViewStatus.
func (i InstanceViewStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", i.Code)
	populate(objectMap, "displayStatus", i.DisplayStatus)
	populate(objectMap, "level", i.Level)
	populate(objectMap, "message", i.Message)
	populateDateTimeRFC3339(objectMap, "time", i.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InstanceViewStatus.
func (i *InstanceViewStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &i.Code)
			delete(rawMsg, key)
		case "displayStatus":
			err = unpopulate(val, "DisplayStatus", &i.DisplayStatus)
			delete(rawMsg, key)
		case "level":
			err = unpopulate(val, "Level", &i.Level)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &i.Message)
			delete(rawMsg, key)
		case "time":
			err = unpopulateDateTimeRFC3339(val, "Time", &i.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Job.
func (j Job) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowTaskPreemption", j.AllowTaskPreemption)
	populate(objectMap, "commonEnvironmentSettings", j.CommonEnvironmentSettings)
	populate(objectMap, "constraints", j.Constraints)
	populateDateTimeRFC3339(objectMap, "creationTime", j.CreationTime)
	populate(objectMap, "displayName", j.DisplayName)
	populate(objectMap, "eTag", j.ETag)
	populate(objectMap, "executionInfo", j.ExecutionInfo)
	populate(objectMap, "id", j.ID)
	populate(objectMap, "jobManagerTask", j.JobManagerTask)
	populate(objectMap, "jobPreparationTask", j.JobPreparationTask)
	populate(objectMap, "jobReleaseTask", j.JobReleaseTask)
	populateDateTimeRFC3339(objectMap, "lastModified", j.LastModified)
	populate(objectMap, "maxParallelTasks", j.MaxParallelTasks)
	populate(objectMap, "metadata", j.Metadata)
	populate(objectMap, "networkConfiguration", j.NetworkConfiguration)
	populate(objectMap, "onAllTasksComplete", j.OnAllTasksComplete)
	populate(objectMap, "onTaskFailure", j.OnTaskFailure)
	populate(objectMap, "poolInfo", j.PoolInfo)
	populate(objectMap, "previousState", j.PreviousState)
	populateDateTimeRFC3339(objectMap, "previousStateTransitionTime", j.PreviousStateTransitionTime)
	populate(objectMap, "priority", j.Priority)
	populate(objectMap, "state", j.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", j.StateTransitionTime)
	populate(objectMap, "stats", j.Stats)
	populate(objectMap, "url", j.URL)
	populate(objectMap, "usesTaskDependencies", j.UsesTaskDependencies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Job.
func (j *Job) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowTaskPreemption":
			err = unpopulate(val, "AllowTaskPreemption", &j.AllowTaskPreemption)
			delete(rawMsg, key)
		case "commonEnvironmentSettings":
			err = unpopulate(val, "CommonEnvironmentSettings", &j.CommonEnvironmentSettings)
			delete(rawMsg, key)
		case "constraints":
			err = unpopulate(val, "Constraints", &j.Constraints)
			delete(rawMsg, key)
		case "creationTime":
			err = unpopulateDateTimeRFC3339(val, "CreationTime", &j.CreationTime)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &j.DisplayName)
			delete(rawMsg, key)
		case "eTag":
			err = unpopulate(val, "ETag", &j.ETag)
			delete(rawMsg, key)
		case "executionInfo":
			err = unpopulate(val, "ExecutionInfo", &j.ExecutionInfo)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &j.ID)
			delete(rawMsg, key)
		case "jobManagerTask":
			err = unpopulate(val, "JobManagerTask", &j.JobManagerTask)
			delete(rawMsg, key)
		case "jobPreparationTask":
			err = unpopulate(val, "JobPreparationTask", &j.JobPreparationTask)
			delete(rawMsg, key)
		case "jobReleaseTask":
			err = unpopulate(val, "JobReleaseTask", &j.JobReleaseTask)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateDateTimeRFC3339(val, "LastModified", &j.LastModified)
			delete(rawMsg, key)
		case "maxParallelTasks":
			err = unpopulate(val, "MaxParallelTasks", &j.MaxParallelTasks)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &j.Metadata)
			delete(rawMsg, key)
		case "networkConfiguration":
			err = unpopulate(val, "NetworkConfiguration", &j.NetworkConfiguration)
			delete(rawMsg, key)
		case "onAllTasksComplete":
			err = unpopulate(val, "OnAllTasksComplete", &j.OnAllTasksComplete)
			delete(rawMsg, key)
		case "onTaskFailure":
			err = unpopulate(val, "OnTaskFailure", &j.OnTaskFailure)
			delete(rawMsg, key)
		case "poolInfo":
			err = unpopulate(val, "PoolInfo", &j.PoolInfo)
			delete(rawMsg, key)
		case "previousState":
			err = unpopulate(val, "PreviousState", &j.PreviousState)
			delete(rawMsg, key)
		case "previousStateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "PreviousStateTransitionTime", &j.PreviousStateTransitionTime)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, "Priority", &j.Priority)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &j.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &j.StateTransitionTime)
			delete(rawMsg, key)
		case "stats":
			err = unpopulate(val, "Stats", &j.Stats)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &j.URL)
			delete(rawMsg, key)
		case "usesTaskDependencies":
			err = unpopulate(val, "UsesTaskDependencies", &j.UsesTaskDependencies)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobConstraints.
func (j JobConstraints) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxTaskRetryCount", j.MaxTaskRetryCount)
	populate(objectMap, "maxWallClockTime", j.MaxWallClockTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobConstraints.
func (j *JobConstraints) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxTaskRetryCount":
			err = unpopulate(val, "MaxTaskRetryCount", &j.MaxTaskRetryCount)
			delete(rawMsg, key)
		case "maxWallClockTime":
			err = unpopulate(val, "MaxWallClockTime", &j.MaxWallClockTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobExecutionInfo.
func (j JobExecutionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "poolId", j.PoolID)
	populate(objectMap, "schedulingError", j.SchedulingError)
	populateDateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "terminateReason", j.TerminationReason)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobExecutionInfo.
func (j *JobExecutionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &j.EndTime)
			delete(rawMsg, key)
		case "poolId":
			err = unpopulate(val, "PoolID", &j.PoolID)
			delete(rawMsg, key)
		case "schedulingError":
			err = unpopulate(val, "SchedulingError", &j.SchedulingError)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &j.StartTime)
			delete(rawMsg, key)
		case "terminateReason":
			err = unpopulate(val, "TerminationReason", &j.TerminationReason)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobListResult.
func (j JobListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobListResult.
func (j *JobListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &j.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &j.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobManagerTask.
func (j JobManagerTask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowLowPriorityNode", j.AllowLowPriorityNode)
	populate(objectMap, "applicationPackageReferences", j.ApplicationPackageReferences)
	populate(objectMap, "authenticationTokenSettings", j.AuthenticationTokenSettings)
	populate(objectMap, "commandLine", j.CommandLine)
	populate(objectMap, "constraints", j.Constraints)
	populate(objectMap, "containerSettings", j.ContainerSettings)
	populate(objectMap, "displayName", j.DisplayName)
	populate(objectMap, "environmentSettings", j.EnvironmentSettings)
	populate(objectMap, "id", j.ID)
	populate(objectMap, "killJobOnCompletion", j.KillJobOnCompletion)
	populate(objectMap, "outputFiles", j.OutputFiles)
	populate(objectMap, "requiredSlots", j.RequiredSlots)
	populate(objectMap, "resourceFiles", j.ResourceFiles)
	populate(objectMap, "runExclusive", j.RunExclusive)
	populate(objectMap, "userIdentity", j.UserIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobManagerTask.
func (j *JobManagerTask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowLowPriorityNode":
			err = unpopulate(val, "AllowLowPriorityNode", &j.AllowLowPriorityNode)
			delete(rawMsg, key)
		case "applicationPackageReferences":
			err = unpopulate(val, "ApplicationPackageReferences", &j.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "authenticationTokenSettings":
			err = unpopulate(val, "AuthenticationTokenSettings", &j.AuthenticationTokenSettings)
			delete(rawMsg, key)
		case "commandLine":
			err = unpopulate(val, "CommandLine", &j.CommandLine)
			delete(rawMsg, key)
		case "constraints":
			err = unpopulate(val, "Constraints", &j.Constraints)
			delete(rawMsg, key)
		case "containerSettings":
			err = unpopulate(val, "ContainerSettings", &j.ContainerSettings)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &j.DisplayName)
			delete(rawMsg, key)
		case "environmentSettings":
			err = unpopulate(val, "EnvironmentSettings", &j.EnvironmentSettings)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &j.ID)
			delete(rawMsg, key)
		case "killJobOnCompletion":
			err = unpopulate(val, "KillJobOnCompletion", &j.KillJobOnCompletion)
			delete(rawMsg, key)
		case "outputFiles":
			err = unpopulate(val, "OutputFiles", &j.OutputFiles)
			delete(rawMsg, key)
		case "requiredSlots":
			err = unpopulate(val, "RequiredSlots", &j.RequiredSlots)
			delete(rawMsg, key)
		case "resourceFiles":
			err = unpopulate(val, "ResourceFiles", &j.ResourceFiles)
			delete(rawMsg, key)
		case "runExclusive":
			err = unpopulate(val, "RunExclusive", &j.RunExclusive)
			delete(rawMsg, key)
		case "userIdentity":
			err = unpopulate(val, "UserIdentity", &j.UserIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobNetworkConfiguration.
func (j JobNetworkConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "skipWithdrawFromVNet", j.SkipWithdrawFromVNet)
	populate(objectMap, "subnetId", j.SubnetID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobNetworkConfiguration.
func (j *JobNetworkConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "skipWithdrawFromVNet":
			err = unpopulate(val, "SkipWithdrawFromVNet", &j.SkipWithdrawFromVNet)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &j.SubnetID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobPreparationAndReleaseTaskStatus.
func (j JobPreparationAndReleaseTaskStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "jobPreparationTaskExecutionInfo", j.JobPreparationTaskExecutionInfo)
	populate(objectMap, "jobReleaseTaskExecutionInfo", j.JobReleaseTaskExecutionInfo)
	populate(objectMap, "nodeId", j.NodeID)
	populate(objectMap, "nodeUrl", j.NodeURL)
	populate(objectMap, "poolId", j.PoolID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobPreparationAndReleaseTaskStatus.
func (j *JobPreparationAndReleaseTaskStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobPreparationTaskExecutionInfo":
			err = unpopulate(val, "JobPreparationTaskExecutionInfo", &j.JobPreparationTaskExecutionInfo)
			delete(rawMsg, key)
		case "jobReleaseTaskExecutionInfo":
			err = unpopulate(val, "JobReleaseTaskExecutionInfo", &j.JobReleaseTaskExecutionInfo)
			delete(rawMsg, key)
		case "nodeId":
			err = unpopulate(val, "NodeID", &j.NodeID)
			delete(rawMsg, key)
		case "nodeUrl":
			err = unpopulate(val, "NodeURL", &j.NodeURL)
			delete(rawMsg, key)
		case "poolId":
			err = unpopulate(val, "PoolID", &j.PoolID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobPreparationAndReleaseTaskStatusListResult.
func (j JobPreparationAndReleaseTaskStatusListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobPreparationAndReleaseTaskStatusListResult.
func (j *JobPreparationAndReleaseTaskStatusListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &j.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &j.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobPreparationTask.
func (j JobPreparationTask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commandLine", j.CommandLine)
	populate(objectMap, "constraints", j.Constraints)
	populate(objectMap, "containerSettings", j.ContainerSettings)
	populate(objectMap, "environmentSettings", j.EnvironmentSettings)
	populate(objectMap, "id", j.ID)
	populate(objectMap, "rerunOnNodeRebootAfterSuccess", j.RerunOnNodeRebootAfterSuccess)
	populate(objectMap, "resourceFiles", j.ResourceFiles)
	populate(objectMap, "userIdentity", j.UserIdentity)
	populate(objectMap, "waitForSuccess", j.WaitForSuccess)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobPreparationTask.
func (j *JobPreparationTask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandLine":
			err = unpopulate(val, "CommandLine", &j.CommandLine)
			delete(rawMsg, key)
		case "constraints":
			err = unpopulate(val, "Constraints", &j.Constraints)
			delete(rawMsg, key)
		case "containerSettings":
			err = unpopulate(val, "ContainerSettings", &j.ContainerSettings)
			delete(rawMsg, key)
		case "environmentSettings":
			err = unpopulate(val, "EnvironmentSettings", &j.EnvironmentSettings)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &j.ID)
			delete(rawMsg, key)
		case "rerunOnNodeRebootAfterSuccess":
			err = unpopulate(val, "RerunOnNodeRebootAfterSuccess", &j.RerunOnNodeRebootAfterSuccess)
			delete(rawMsg, key)
		case "resourceFiles":
			err = unpopulate(val, "ResourceFiles", &j.ResourceFiles)
			delete(rawMsg, key)
		case "userIdentity":
			err = unpopulate(val, "UserIdentity", &j.UserIdentity)
			delete(rawMsg, key)
		case "waitForSuccess":
			err = unpopulate(val, "WaitForSuccess", &j.WaitForSuccess)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobPreparationTaskExecutionInfo.
func (j JobPreparationTaskExecutionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerInfo", j.ContainerInfo)
	populateDateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "exitCode", j.ExitCode)
	populate(objectMap, "failureInfo", j.FailureInfo)
	populateDateTimeRFC3339(objectMap, "lastRetryTime", j.LastRetryTime)
	populate(objectMap, "result", j.Result)
	populate(objectMap, "retryCount", j.RetryCount)
	populateDateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "state", j.State)
	populate(objectMap, "taskRootDirectory", j.TaskRootDirectory)
	populate(objectMap, "taskRootDirectoryUrl", j.TaskRootDirectoryURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobPreparationTaskExecutionInfo.
func (j *JobPreparationTaskExecutionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerInfo":
			err = unpopulate(val, "ContainerInfo", &j.ContainerInfo)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &j.EndTime)
			delete(rawMsg, key)
		case "exitCode":
			err = unpopulate(val, "ExitCode", &j.ExitCode)
			delete(rawMsg, key)
		case "failureInfo":
			err = unpopulate(val, "FailureInfo", &j.FailureInfo)
			delete(rawMsg, key)
		case "lastRetryTime":
			err = unpopulateDateTimeRFC3339(val, "LastRetryTime", &j.LastRetryTime)
			delete(rawMsg, key)
		case "result":
			err = unpopulate(val, "Result", &j.Result)
			delete(rawMsg, key)
		case "retryCount":
			err = unpopulate(val, "RetryCount", &j.RetryCount)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &j.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &j.State)
			delete(rawMsg, key)
		case "taskRootDirectory":
			err = unpopulate(val, "TaskRootDirectory", &j.TaskRootDirectory)
			delete(rawMsg, key)
		case "taskRootDirectoryUrl":
			err = unpopulate(val, "TaskRootDirectoryURL", &j.TaskRootDirectoryURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobReleaseTask.
func (j JobReleaseTask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commandLine", j.CommandLine)
	populate(objectMap, "containerSettings", j.ContainerSettings)
	populate(objectMap, "environmentSettings", j.EnvironmentSettings)
	populate(objectMap, "id", j.ID)
	populate(objectMap, "maxWallClockTime", j.MaxWallClockTime)
	populate(objectMap, "resourceFiles", j.ResourceFiles)
	populate(objectMap, "retentionTime", j.RetentionTime)
	populate(objectMap, "userIdentity", j.UserIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobReleaseTask.
func (j *JobReleaseTask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandLine":
			err = unpopulate(val, "CommandLine", &j.CommandLine)
			delete(rawMsg, key)
		case "containerSettings":
			err = unpopulate(val, "ContainerSettings", &j.ContainerSettings)
			delete(rawMsg, key)
		case "environmentSettings":
			err = unpopulate(val, "EnvironmentSettings", &j.EnvironmentSettings)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &j.ID)
			delete(rawMsg, key)
		case "maxWallClockTime":
			err = unpopulate(val, "MaxWallClockTime", &j.MaxWallClockTime)
			delete(rawMsg, key)
		case "resourceFiles":
			err = unpopulate(val, "ResourceFiles", &j.ResourceFiles)
			delete(rawMsg, key)
		case "retentionTime":
			err = unpopulate(val, "RetentionTime", &j.RetentionTime)
			delete(rawMsg, key)
		case "userIdentity":
			err = unpopulate(val, "UserIdentity", &j.UserIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobReleaseTaskExecutionInfo.
func (j JobReleaseTaskExecutionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerInfo", j.ContainerInfo)
	populateDateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "exitCode", j.ExitCode)
	populate(objectMap, "failureInfo", j.FailureInfo)
	populate(objectMap, "result", j.Result)
	populateDateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "state", j.State)
	populate(objectMap, "taskRootDirectory", j.TaskRootDirectory)
	populate(objectMap, "taskRootDirectoryUrl", j.TaskRootDirectoryURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobReleaseTaskExecutionInfo.
func (j *JobReleaseTaskExecutionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerInfo":
			err = unpopulate(val, "ContainerInfo", &j.ContainerInfo)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &j.EndTime)
			delete(rawMsg, key)
		case "exitCode":
			err = unpopulate(val, "ExitCode", &j.ExitCode)
			delete(rawMsg, key)
		case "failureInfo":
			err = unpopulate(val, "FailureInfo", &j.FailureInfo)
			delete(rawMsg, key)
		case "result":
			err = unpopulate(val, "Result", &j.Result)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &j.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &j.State)
			delete(rawMsg, key)
		case "taskRootDirectory":
			err = unpopulate(val, "TaskRootDirectory", &j.TaskRootDirectory)
			delete(rawMsg, key)
		case "taskRootDirectoryUrl":
			err = unpopulate(val, "TaskRootDirectoryURL", &j.TaskRootDirectoryURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobSchedule.
func (j JobSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "creationTime", j.CreationTime)
	populate(objectMap, "displayName", j.DisplayName)
	populate(objectMap, "eTag", j.ETag)
	populate(objectMap, "executionInfo", j.ExecutionInfo)
	populate(objectMap, "id", j.ID)
	populate(objectMap, "jobSpecification", j.JobSpecification)
	populateDateTimeRFC3339(objectMap, "lastModified", j.LastModified)
	populate(objectMap, "metadata", j.Metadata)
	populate(objectMap, "previousState", j.PreviousState)
	populateDateTimeRFC3339(objectMap, "previousStateTransitionTime", j.PreviousStateTransitionTime)
	populate(objectMap, "schedule", j.Schedule)
	populate(objectMap, "state", j.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", j.StateTransitionTime)
	populate(objectMap, "stats", j.Stats)
	populate(objectMap, "url", j.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobSchedule.
func (j *JobSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTime":
			err = unpopulateDateTimeRFC3339(val, "CreationTime", &j.CreationTime)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &j.DisplayName)
			delete(rawMsg, key)
		case "eTag":
			err = unpopulate(val, "ETag", &j.ETag)
			delete(rawMsg, key)
		case "executionInfo":
			err = unpopulate(val, "ExecutionInfo", &j.ExecutionInfo)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &j.ID)
			delete(rawMsg, key)
		case "jobSpecification":
			err = unpopulate(val, "JobSpecification", &j.JobSpecification)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateDateTimeRFC3339(val, "LastModified", &j.LastModified)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &j.Metadata)
			delete(rawMsg, key)
		case "previousState":
			err = unpopulate(val, "PreviousState", &j.PreviousState)
			delete(rawMsg, key)
		case "previousStateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "PreviousStateTransitionTime", &j.PreviousStateTransitionTime)
			delete(rawMsg, key)
		case "schedule":
			err = unpopulate(val, "Schedule", &j.Schedule)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &j.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &j.StateTransitionTime)
			delete(rawMsg, key)
		case "stats":
			err = unpopulate(val, "Stats", &j.Stats)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &j.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobScheduleConfiguration.
func (j JobScheduleConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "doNotRunAfter", j.DoNotRunAfter)
	populateDateTimeRFC3339(objectMap, "doNotRunUntil", j.DoNotRunUntil)
	populate(objectMap, "recurrenceInterval", j.RecurrenceInterval)
	populate(objectMap, "startWindow", j.StartWindow)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobScheduleConfiguration.
func (j *JobScheduleConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "doNotRunAfter":
			err = unpopulateDateTimeRFC3339(val, "DoNotRunAfter", &j.DoNotRunAfter)
			delete(rawMsg, key)
		case "doNotRunUntil":
			err = unpopulateDateTimeRFC3339(val, "DoNotRunUntil", &j.DoNotRunUntil)
			delete(rawMsg, key)
		case "recurrenceInterval":
			err = unpopulate(val, "RecurrenceInterval", &j.RecurrenceInterval)
			delete(rawMsg, key)
		case "startWindow":
			err = unpopulate(val, "StartWindow", &j.StartWindow)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobScheduleExecutionInfo.
func (j JobScheduleExecutionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populateDateTimeRFC3339(objectMap, "nextRunTime", j.NextRunTime)
	populate(objectMap, "recentJob", j.RecentJob)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobScheduleExecutionInfo.
func (j *JobScheduleExecutionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &j.EndTime)
			delete(rawMsg, key)
		case "nextRunTime":
			err = unpopulateDateTimeRFC3339(val, "NextRunTime", &j.NextRunTime)
			delete(rawMsg, key)
		case "recentJob":
			err = unpopulate(val, "RecentJob", &j.RecentJob)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobScheduleListResult.
func (j JobScheduleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobScheduleListResult.
func (j *JobScheduleListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &j.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &j.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobScheduleStatistics.
func (j JobScheduleStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kernelCPUTime", j.KernelCPUTime)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", j.LastUpdateTime)
	populate(objectMap, "numFailedTasks", to.Ptr(strconv.FormatInt(*j.NumFailedTasks, 10)))
	populate(objectMap, "numSucceededTasks", to.Ptr(strconv.FormatInt(*j.NumSucceededTasks, 10)))
	populate(objectMap, "numTaskRetries", to.Ptr(strconv.FormatInt(*j.NumTaskRetries, 10)))
	populate(objectMap, "readIOGiB", j.ReadIOGiB)
	populate(objectMap, "readIOps", to.Ptr(strconv.FormatInt(*j.ReadIOPS, 10)))
	populateDateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "url", j.URL)
	populate(objectMap, "userCPUTime", j.UserCPUTime)
	populate(objectMap, "waitTime", j.WaitTime)
	populate(objectMap, "wallClockTime", j.WallClockTime)
	populate(objectMap, "writeIOGiB", j.WriteIOGiB)
	populate(objectMap, "writeIOps", to.Ptr(strconv.FormatInt(*j.WriteIOPS, 10)))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobScheduleStatistics.
func (j *JobScheduleStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kernelCPUTime":
			err = unpopulate(val, "KernelCPUTime", &j.KernelCPUTime)
			delete(rawMsg, key)
		case "lastUpdateTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &j.LastUpdateTime)
			delete(rawMsg, key)
		case "numFailedTasks":
			var aux string
			err = unpopulate(val, "NumFailedTasks", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					j.NumFailedTasks = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		case "numSucceededTasks":
			var aux string
			err = unpopulate(val, "NumSucceededTasks", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					j.NumSucceededTasks = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		case "numTaskRetries":
			var aux string
			err = unpopulate(val, "NumTaskRetries", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					j.NumTaskRetries = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		case "readIOGiB":
			err = unpopulate(val, "ReadIOGiB", &j.ReadIOGiB)
			delete(rawMsg, key)
		case "readIOps":
			var aux string
			err = unpopulate(val, "ReadIOPS", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					j.ReadIOPS = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &j.StartTime)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &j.URL)
			delete(rawMsg, key)
		case "userCPUTime":
			err = unpopulate(val, "UserCPUTime", &j.UserCPUTime)
			delete(rawMsg, key)
		case "waitTime":
			err = unpopulate(val, "WaitTime", &j.WaitTime)
			delete(rawMsg, key)
		case "wallClockTime":
			err = unpopulate(val, "WallClockTime", &j.WallClockTime)
			delete(rawMsg, key)
		case "writeIOGiB":
			err = unpopulate(val, "WriteIOGiB", &j.WriteIOGiB)
			delete(rawMsg, key)
		case "writeIOps":
			var aux string
			err = unpopulate(val, "WriteIOPS", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					j.WriteIOPS = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobSchedulingError.
func (j JobSchedulingError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "category", j.Category)
	populate(objectMap, "code", j.Code)
	populate(objectMap, "details", j.Details)
	populate(objectMap, "message", j.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobSchedulingError.
func (j *JobSchedulingError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
			err = unpopulate(val, "Category", &j.Category)
			delete(rawMsg, key)
		case "code":
			err = unpopulate(val, "Code", &j.Code)
			delete(rawMsg, key)
		case "details":
			err = unpopulate(val, "Details", &j.Details)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &j.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobSpecification.
func (j JobSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowTaskPreemption", j.AllowTaskPreemption)
	populate(objectMap, "commonEnvironmentSettings", j.CommonEnvironmentSettings)
	populate(objectMap, "constraints", j.Constraints)
	populate(objectMap, "displayName", j.DisplayName)
	populate(objectMap, "jobManagerTask", j.JobManagerTask)
	populate(objectMap, "jobPreparationTask", j.JobPreparationTask)
	populate(objectMap, "jobReleaseTask", j.JobReleaseTask)
	populate(objectMap, "maxParallelTasks", j.MaxParallelTasks)
	populate(objectMap, "metadata", j.Metadata)
	populate(objectMap, "networkConfiguration", j.NetworkConfiguration)
	populate(objectMap, "onAllTasksComplete", j.OnAllTasksComplete)
	populate(objectMap, "onTaskFailure", j.OnTaskFailure)
	populate(objectMap, "poolInfo", j.PoolInfo)
	populate(objectMap, "priority", j.Priority)
	populate(objectMap, "usesTaskDependencies", j.UsesTaskDependencies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobSpecification.
func (j *JobSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowTaskPreemption":
			err = unpopulate(val, "AllowTaskPreemption", &j.AllowTaskPreemption)
			delete(rawMsg, key)
		case "commonEnvironmentSettings":
			err = unpopulate(val, "CommonEnvironmentSettings", &j.CommonEnvironmentSettings)
			delete(rawMsg, key)
		case "constraints":
			err = unpopulate(val, "Constraints", &j.Constraints)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &j.DisplayName)
			delete(rawMsg, key)
		case "jobManagerTask":
			err = unpopulate(val, "JobManagerTask", &j.JobManagerTask)
			delete(rawMsg, key)
		case "jobPreparationTask":
			err = unpopulate(val, "JobPreparationTask", &j.JobPreparationTask)
			delete(rawMsg, key)
		case "jobReleaseTask":
			err = unpopulate(val, "JobReleaseTask", &j.JobReleaseTask)
			delete(rawMsg, key)
		case "maxParallelTasks":
			err = unpopulate(val, "MaxParallelTasks", &j.MaxParallelTasks)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &j.Metadata)
			delete(rawMsg, key)
		case "networkConfiguration":
			err = unpopulate(val, "NetworkConfiguration", &j.NetworkConfiguration)
			delete(rawMsg, key)
		case "onAllTasksComplete":
			err = unpopulate(val, "OnAllTasksComplete", &j.OnAllTasksComplete)
			delete(rawMsg, key)
		case "onTaskFailure":
			err = unpopulate(val, "OnTaskFailure", &j.OnTaskFailure)
			delete(rawMsg, key)
		case "poolInfo":
			err = unpopulate(val, "PoolInfo", &j.PoolInfo)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, "Priority", &j.Priority)
			delete(rawMsg, key)
		case "usesTaskDependencies":
			err = unpopulate(val, "UsesTaskDependencies", &j.UsesTaskDependencies)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobStatistics.
func (j JobStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kernelCPUTime", j.KernelCPUTime)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", j.LastUpdateTime)
	populate(objectMap, "numFailedTasks", to.Ptr(strconv.FormatInt(*j.NumFailedTasks, 10)))
	populate(objectMap, "numSucceededTasks", to.Ptr(strconv.FormatInt(*j.NumSucceededTasks, 10)))
	populate(objectMap, "numTaskRetries", to.Ptr(strconv.FormatInt(*j.NumTaskRetries, 10)))
	populate(objectMap, "readIOGiB", j.ReadIOGiB)
	populate(objectMap, "readIOps", to.Ptr(strconv.FormatInt(*j.ReadIOps, 10)))
	populateDateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "url", j.URL)
	populate(objectMap, "userCPUTime", j.UserCPUTime)
	populate(objectMap, "waitTime", j.WaitTime)
	populate(objectMap, "wallClockTime", j.WallClockTime)
	populate(objectMap, "writeIOGiB", j.WriteIOGiB)
	populate(objectMap, "writeIOps", to.Ptr(strconv.FormatInt(*j.WriteIOps, 10)))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobStatistics.
func (j *JobStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kernelCPUTime":
			err = unpopulate(val, "KernelCPUTime", &j.KernelCPUTime)
			delete(rawMsg, key)
		case "lastUpdateTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &j.LastUpdateTime)
			delete(rawMsg, key)
		case "numFailedTasks":
			var aux string
			err = unpopulate(val, "NumFailedTasks", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					j.NumFailedTasks = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		case "numSucceededTasks":
			var aux string
			err = unpopulate(val, "NumSucceededTasks", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					j.NumSucceededTasks = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		case "numTaskRetries":
			var aux string
			err = unpopulate(val, "NumTaskRetries", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					j.NumTaskRetries = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		case "readIOGiB":
			err = unpopulate(val, "ReadIOGiB", &j.ReadIOGiB)
			delete(rawMsg, key)
		case "readIOps":
			var aux string
			err = unpopulate(val, "ReadIOps", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					j.ReadIOps = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &j.StartTime)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &j.URL)
			delete(rawMsg, key)
		case "userCPUTime":
			err = unpopulate(val, "UserCPUTime", &j.UserCPUTime)
			delete(rawMsg, key)
		case "waitTime":
			err = unpopulate(val, "WaitTime", &j.WaitTime)
			delete(rawMsg, key)
		case "wallClockTime":
			err = unpopulate(val, "WallClockTime", &j.WallClockTime)
			delete(rawMsg, key)
		case "writeIOGiB":
			err = unpopulate(val, "WriteIOGiB", &j.WriteIOGiB)
			delete(rawMsg, key)
		case "writeIOps":
			var aux string
			err = unpopulate(val, "WriteIOps", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					j.WriteIOps = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinuxUserConfiguration.
func (l LinuxUserConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "gid", l.GID)
	populate(objectMap, "sshPrivateKey", l.SSHPrivateKey)
	populate(objectMap, "uid", l.UID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinuxUserConfiguration.
func (l *LinuxUserConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "gid":
			err = unpopulate(val, "GID", &l.GID)
			delete(rawMsg, key)
		case "sshPrivateKey":
			err = unpopulate(val, "SSHPrivateKey", &l.SSHPrivateKey)
			delete(rawMsg, key)
		case "uid":
			err = unpopulate(val, "UID", &l.UID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListPoolNodeCountsResult.
func (l ListPoolNodeCountsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListPoolNodeCountsResult.
func (l *ListPoolNodeCountsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &l.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &l.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedDisk.
func (m ManagedDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "securityProfile", m.SecurityProfile)
	populate(objectMap, "storageAccountType", m.StorageAccountType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedDisk.
func (m *ManagedDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "securityProfile":
			err = unpopulate(val, "SecurityProfile", &m.SecurityProfile)
			delete(rawMsg, key)
		case "storageAccountType":
			err = unpopulate(val, "StorageAccountType", &m.StorageAccountType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MetadataItem.
func (m MetadataItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetadataItem.
func (m *MetadataItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MountConfiguration.
func (m MountConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureBlobFileSystemConfiguration", m.AzureBlobFileSystemConfiguration)
	populate(objectMap, "azureFileShareConfiguration", m.AzureFileShareConfiguration)
	populate(objectMap, "cifsMountConfiguration", m.CifsMountConfiguration)
	populate(objectMap, "nfsMountConfiguration", m.NfsMountConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MountConfiguration.
func (m *MountConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureBlobFileSystemConfiguration":
			err = unpopulate(val, "AzureBlobFileSystemConfiguration", &m.AzureBlobFileSystemConfiguration)
			delete(rawMsg, key)
		case "azureFileShareConfiguration":
			err = unpopulate(val, "AzureFileShareConfiguration", &m.AzureFileShareConfiguration)
			delete(rawMsg, key)
		case "cifsMountConfiguration":
			err = unpopulate(val, "CifsMountConfiguration", &m.CifsMountConfiguration)
			delete(rawMsg, key)
		case "nfsMountConfiguration":
			err = unpopulate(val, "NfsMountConfiguration", &m.NfsMountConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultiInstanceSettings.
func (m MultiInstanceSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commonResourceFiles", m.CommonResourceFiles)
	populate(objectMap, "coordinationCommandLine", m.CoordinationCommandLine)
	populate(objectMap, "numberOfInstances", m.NumberOfInstances)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultiInstanceSettings.
func (m *MultiInstanceSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commonResourceFiles":
			err = unpopulate(val, "CommonResourceFiles", &m.CommonResourceFiles)
			delete(rawMsg, key)
		case "coordinationCommandLine":
			err = unpopulate(val, "CoordinationCommandLine", &m.CoordinationCommandLine)
			delete(rawMsg, key)
		case "numberOfInstances":
			err = unpopulate(val, "NumberOfInstances", &m.NumberOfInstances)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NFSMountConfiguration.
func (n NFSMountConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "mountOptions", n.MountOptions)
	populate(objectMap, "relativeMountPath", n.RelativeMountPath)
	populate(objectMap, "source", n.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NFSMountConfiguration.
func (n *NFSMountConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mountOptions":
			err = unpopulate(val, "MountOptions", &n.MountOptions)
			delete(rawMsg, key)
		case "relativeMountPath":
			err = unpopulate(val, "RelativeMountPath", &n.RelativeMountPath)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &n.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NameValuePair.
func (n NameValuePair) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NameValuePair.
func (n *NameValuePair) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkConfiguration.
func (n NetworkConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dynamicVNetAssignmentScope", n.DynamicVNetAssignmentScope)
	populate(objectMap, "enableAcceleratedNetworking", n.EnableAcceleratedNetworking)
	populate(objectMap, "endpointConfiguration", n.EndpointConfiguration)
	populate(objectMap, "publicIPAddressConfiguration", n.PublicIPAddressConfiguration)
	populate(objectMap, "subnetId", n.SubnetID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkConfiguration.
func (n *NetworkConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dynamicVNetAssignmentScope":
			err = unpopulate(val, "DynamicVNetAssignmentScope", &n.DynamicVNetAssignmentScope)
			delete(rawMsg, key)
		case "enableAcceleratedNetworking":
			err = unpopulate(val, "EnableAcceleratedNetworking", &n.EnableAcceleratedNetworking)
			delete(rawMsg, key)
		case "endpointConfiguration":
			err = unpopulate(val, "EndpointConfiguration", &n.EndpointConfiguration)
			delete(rawMsg, key)
		case "publicIPAddressConfiguration":
			err = unpopulate(val, "PublicIPAddressConfiguration", &n.PublicIPAddressConfiguration)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &n.SubnetID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkSecurityGroupRule.
func (n NetworkSecurityGroupRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "access", n.Access)
	populate(objectMap, "priority", n.Priority)
	populate(objectMap, "sourceAddressPrefix", n.SourceAddressPrefix)
	populate(objectMap, "sourcePortRanges", n.SourcePortRanges)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkSecurityGroupRule.
func (n *NetworkSecurityGroupRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "access":
			err = unpopulate(val, "Access", &n.Access)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, "Priority", &n.Priority)
			delete(rawMsg, key)
		case "sourceAddressPrefix":
			err = unpopulate(val, "SourceAddressPrefix", &n.SourceAddressPrefix)
			delete(rawMsg, key)
		case "sourcePortRanges":
			err = unpopulate(val, "SourcePortRanges", &n.SourcePortRanges)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Node.
func (n Node) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityId", n.AffinityID)
	populateDateTimeRFC3339(objectMap, "allocationTime", n.AllocationTime)
	populate(objectMap, "certificateReferences", n.CertificateReferences)
	populate(objectMap, "endpointConfiguration", n.EndpointConfiguration)
	populate(objectMap, "errors", n.Errors)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "ipAddress", n.IPAddress)
	populate(objectMap, "isDedicated", n.IsDedicated)
	populateDateTimeRFC3339(objectMap, "lastBootTime", n.LastBootTime)
	populate(objectMap, "nodeAgentInfo", n.NodeAgentInfo)
	populate(objectMap, "recentTasks", n.RecentTasks)
	populate(objectMap, "runningTaskSlotsCount", n.RunningTaskSlotsCount)
	populate(objectMap, "runningTasksCount", n.RunningTasksCount)
	populate(objectMap, "schedulingState", n.SchedulingState)
	populate(objectMap, "startTask", n.StartTask)
	populate(objectMap, "startTaskInfo", n.StartTaskInfo)
	populate(objectMap, "state", n.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", n.StateTransitionTime)
	populate(objectMap, "totalTasksRun", n.TotalTasksRun)
	populate(objectMap, "totalTasksSucceeded", n.TotalTasksSucceeded)
	populate(objectMap, "url", n.URL)
	populate(objectMap, "vmSize", n.VMSize)
	populate(objectMap, "virtualMachineInfo", n.VirtualMachineInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Node.
func (n *Node) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityId":
			err = unpopulate(val, "AffinityID", &n.AffinityID)
			delete(rawMsg, key)
		case "allocationTime":
			err = unpopulateDateTimeRFC3339(val, "AllocationTime", &n.AllocationTime)
			delete(rawMsg, key)
		case "certificateReferences":
			err = unpopulate(val, "CertificateReferences", &n.CertificateReferences)
			delete(rawMsg, key)
		case "endpointConfiguration":
			err = unpopulate(val, "EndpointConfiguration", &n.EndpointConfiguration)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &n.Errors)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &n.IPAddress)
			delete(rawMsg, key)
		case "isDedicated":
			err = unpopulate(val, "IsDedicated", &n.IsDedicated)
			delete(rawMsg, key)
		case "lastBootTime":
			err = unpopulateDateTimeRFC3339(val, "LastBootTime", &n.LastBootTime)
			delete(rawMsg, key)
		case "nodeAgentInfo":
			err = unpopulate(val, "NodeAgentInfo", &n.NodeAgentInfo)
			delete(rawMsg, key)
		case "recentTasks":
			err = unpopulate(val, "RecentTasks", &n.RecentTasks)
			delete(rawMsg, key)
		case "runningTaskSlotsCount":
			err = unpopulate(val, "RunningTaskSlotsCount", &n.RunningTaskSlotsCount)
			delete(rawMsg, key)
		case "runningTasksCount":
			err = unpopulate(val, "RunningTasksCount", &n.RunningTasksCount)
			delete(rawMsg, key)
		case "schedulingState":
			err = unpopulate(val, "SchedulingState", &n.SchedulingState)
			delete(rawMsg, key)
		case "startTask":
			err = unpopulate(val, "StartTask", &n.StartTask)
			delete(rawMsg, key)
		case "startTaskInfo":
			err = unpopulate(val, "StartTaskInfo", &n.StartTaskInfo)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &n.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &n.StateTransitionTime)
			delete(rawMsg, key)
		case "totalTasksRun":
			err = unpopulate(val, "TotalTasksRun", &n.TotalTasksRun)
			delete(rawMsg, key)
		case "totalTasksSucceeded":
			err = unpopulate(val, "TotalTasksSucceeded", &n.TotalTasksSucceeded)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &n.URL)
			delete(rawMsg, key)
		case "vmSize":
			err = unpopulate(val, "VMSize", &n.VMSize)
			delete(rawMsg, key)
		case "virtualMachineInfo":
			err = unpopulate(val, "VirtualMachineInfo", &n.VirtualMachineInfo)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeAgentInfo.
func (n NodeAgentInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", n.LastUpdateTime)
	populate(objectMap, "version", n.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeAgentInfo.
func (n *NodeAgentInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastUpdateTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &n.LastUpdateTime)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &n.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeCounts.
func (n NodeCounts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "creating", n.Creating)
	populate(objectMap, "deallocated", n.Deallocated)
	populate(objectMap, "deallocating", n.Deallocating)
	populate(objectMap, "idle", n.Idle)
	populate(objectMap, "leavingPool", n.LeavingPool)
	populate(objectMap, "offline", n.Offline)
	populate(objectMap, "preempted", n.Preempted)
	populate(objectMap, "rebooting", n.Rebooting)
	populate(objectMap, "reimaging", n.Reimaging)
	populate(objectMap, "running", n.Running)
	populate(objectMap, "startTaskFailed", n.StartTaskFailed)
	populate(objectMap, "starting", n.Starting)
	populate(objectMap, "total", n.Total)
	populate(objectMap, "unknown", n.Unknown)
	populate(objectMap, "unusable", n.Unusable)
	populate(objectMap, "upgradingOS", n.UpgradingOS)
	populate(objectMap, "waitingForStartTask", n.WaitingForStartTask)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeCounts.
func (n *NodeCounts) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creating":
			err = unpopulate(val, "Creating", &n.Creating)
			delete(rawMsg, key)
		case "deallocated":
			err = unpopulate(val, "Deallocated", &n.Deallocated)
			delete(rawMsg, key)
		case "deallocating":
			err = unpopulate(val, "Deallocating", &n.Deallocating)
			delete(rawMsg, key)
		case "idle":
			err = unpopulate(val, "Idle", &n.Idle)
			delete(rawMsg, key)
		case "leavingPool":
			err = unpopulate(val, "LeavingPool", &n.LeavingPool)
			delete(rawMsg, key)
		case "offline":
			err = unpopulate(val, "Offline", &n.Offline)
			delete(rawMsg, key)
		case "preempted":
			err = unpopulate(val, "Preempted", &n.Preempted)
			delete(rawMsg, key)
		case "rebooting":
			err = unpopulate(val, "Rebooting", &n.Rebooting)
			delete(rawMsg, key)
		case "reimaging":
			err = unpopulate(val, "Reimaging", &n.Reimaging)
			delete(rawMsg, key)
		case "running":
			err = unpopulate(val, "Running", &n.Running)
			delete(rawMsg, key)
		case "startTaskFailed":
			err = unpopulate(val, "StartTaskFailed", &n.StartTaskFailed)
			delete(rawMsg, key)
		case "starting":
			err = unpopulate(val, "Starting", &n.Starting)
			delete(rawMsg, key)
		case "total":
			err = unpopulate(val, "Total", &n.Total)
			delete(rawMsg, key)
		case "unknown":
			err = unpopulate(val, "Unknown", &n.Unknown)
			delete(rawMsg, key)
		case "unusable":
			err = unpopulate(val, "Unusable", &n.Unusable)
			delete(rawMsg, key)
		case "upgradingOS":
			err = unpopulate(val, "UpgradingOS", &n.UpgradingOS)
			delete(rawMsg, key)
		case "waitingForStartTask":
			err = unpopulate(val, "WaitingForStartTask", &n.WaitingForStartTask)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeEndpointConfiguration.
func (n NodeEndpointConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "inboundEndpoints", n.InboundEndpoints)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeEndpointConfiguration.
func (n *NodeEndpointConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inboundEndpoints":
			err = unpopulate(val, "InboundEndpoints", &n.InboundEndpoints)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeError.
func (n NodeError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", n.Code)
	populate(objectMap, "errorDetails", n.ErrorDetails)
	populate(objectMap, "message", n.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeError.
func (n *NodeError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &n.Code)
			delete(rawMsg, key)
		case "errorDetails":
			err = unpopulate(val, "ErrorDetails", &n.ErrorDetails)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &n.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeFile.
func (n NodeFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isDirectory", n.IsDirectory)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "url", n.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeFile.
func (n *NodeFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isDirectory":
			err = unpopulate(val, "IsDirectory", &n.IsDirectory)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &n.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeFileListResult.
func (n NodeFileListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeFileListResult.
func (n *NodeFileListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeIdentityReference.
func (n NodeIdentityReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "resourceId", n.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeIdentityReference.
func (n *NodeIdentityReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceId":
			err = unpopulate(val, "ResourceID", &n.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeInfo.
func (n NodeInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityId", n.AffinityID)
	populate(objectMap, "nodeId", n.NodeID)
	populate(objectMap, "nodeUrl", n.NodeURL)
	populate(objectMap, "poolId", n.PoolID)
	populate(objectMap, "taskRootDirectory", n.TaskRootDirectory)
	populate(objectMap, "taskRootDirectoryUrl", n.TaskRootDirectoryURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeInfo.
func (n *NodeInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityId":
			err = unpopulate(val, "AffinityID", &n.AffinityID)
			delete(rawMsg, key)
		case "nodeId":
			err = unpopulate(val, "NodeID", &n.NodeID)
			delete(rawMsg, key)
		case "nodeUrl":
			err = unpopulate(val, "NodeURL", &n.NodeURL)
			delete(rawMsg, key)
		case "poolId":
			err = unpopulate(val, "PoolID", &n.PoolID)
			delete(rawMsg, key)
		case "taskRootDirectory":
			err = unpopulate(val, "TaskRootDirectory", &n.TaskRootDirectory)
			delete(rawMsg, key)
		case "taskRootDirectoryUrl":
			err = unpopulate(val, "TaskRootDirectoryURL", &n.TaskRootDirectoryURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeListResult.
func (n NodeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeListResult.
func (n *NodeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodePlacementConfiguration.
func (n NodePlacementConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "policy", n.Policy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodePlacementConfiguration.
func (n *NodePlacementConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "policy":
			err = unpopulate(val, "Policy", &n.Policy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeRemoteLoginSettings.
func (n NodeRemoteLoginSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "remoteLoginIPAddress", n.RemoteLoginIPAddress)
	populate(objectMap, "remoteLoginPort", n.RemoteLoginPort)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeRemoteLoginSettings.
func (n *NodeRemoteLoginSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "remoteLoginIPAddress":
			err = unpopulate(val, "RemoteLoginIPAddress", &n.RemoteLoginIPAddress)
			delete(rawMsg, key)
		case "remoteLoginPort":
			err = unpopulate(val, "RemoteLoginPort", &n.RemoteLoginPort)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeVMExtension.
func (n NodeVMExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceView", n.InstanceView)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "vmExtension", n.VMExtension)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeVMExtension.
func (n *NodeVMExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceView":
			err = unpopulate(val, "InstanceView", &n.InstanceView)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		case "vmExtension":
			err = unpopulate(val, "VMExtension", &n.VMExtension)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeVMExtensionListResult.
func (n NodeVMExtensionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeVMExtensionListResult.
func (n *NodeVMExtensionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OSDisk.
func (o OSDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "caching", o.Caching)
	populate(objectMap, "diskSizeGB", o.DiskSizeGB)
	populate(objectMap, "ephemeralOSDiskSettings", o.EphemeralOSDiskSettings)
	populate(objectMap, "managedDisk", o.ManagedDisk)
	populate(objectMap, "writeAcceleratorEnabled", o.WriteAcceleratorEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OSDisk.
func (o *OSDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "caching":
			err = unpopulate(val, "Caching", &o.Caching)
			delete(rawMsg, key)
		case "diskSizeGB":
			err = unpopulate(val, "DiskSizeGB", &o.DiskSizeGB)
			delete(rawMsg, key)
		case "ephemeralOSDiskSettings":
			err = unpopulate(val, "EphemeralOSDiskSettings", &o.EphemeralOSDiskSettings)
			delete(rawMsg, key)
		case "managedDisk":
			err = unpopulate(val, "ManagedDisk", &o.ManagedDisk)
			delete(rawMsg, key)
		case "writeAcceleratorEnabled":
			err = unpopulate(val, "WriteAcceleratorEnabled", &o.WriteAcceleratorEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OutputFile.
func (o OutputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "destination", o.Destination)
	populate(objectMap, "filePattern", o.FilePattern)
	populate(objectMap, "uploadOptions", o.UploadOptions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OutputFile.
func (o *OutputFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destination":
			err = unpopulate(val, "Destination", &o.Destination)
			delete(rawMsg, key)
		case "filePattern":
			err = unpopulate(val, "FilePattern", &o.FilePattern)
			delete(rawMsg, key)
		case "uploadOptions":
			err = unpopulate(val, "UploadOptions", &o.UploadOptions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OutputFileBlobContainerDestination.
func (o OutputFileBlobContainerDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerUrl", o.ContainerURL)
	populate(objectMap, "identityReference", o.IdentityReference)
	populate(objectMap, "path", o.Path)
	populate(objectMap, "uploadHeaders", o.UploadHeaders)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OutputFileBlobContainerDestination.
func (o *OutputFileBlobContainerDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerUrl":
			err = unpopulate(val, "ContainerURL", &o.ContainerURL)
			delete(rawMsg, key)
		case "identityReference":
			err = unpopulate(val, "IdentityReference", &o.IdentityReference)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &o.Path)
			delete(rawMsg, key)
		case "uploadHeaders":
			err = unpopulate(val, "UploadHeaders", &o.UploadHeaders)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OutputFileDestination.
func (o OutputFileDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "container", o.Container)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OutputFileDestination.
func (o *OutputFileDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "container":
			err = unpopulate(val, "Container", &o.Container)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OutputFileUploadConfig.
func (o OutputFileUploadConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "uploadCondition", o.UploadCondition)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OutputFileUploadConfig.
func (o *OutputFileUploadConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "uploadCondition":
			err = unpopulate(val, "UploadCondition", &o.UploadCondition)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Pool.
func (p Pool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allocationState", p.AllocationState)
	populateDateTimeRFC3339(objectMap, "allocationStateTransitionTime", p.AllocationStateTransitionTime)
	populate(objectMap, "applicationPackageReferences", p.ApplicationPackageReferences)
	populate(objectMap, "autoScaleEvaluationInterval", p.AutoScaleEvaluationInterval)
	populate(objectMap, "autoScaleFormula", p.AutoScaleFormula)
	populate(objectMap, "autoScaleRun", p.AutoScaleRun)
	populate(objectMap, "certificateReferences", p.CertificateReferences)
	populateDateTimeRFC3339(objectMap, "creationTime", p.CreationTime)
	populate(objectMap, "currentDedicatedNodes", p.CurrentDedicatedNodes)
	populate(objectMap, "currentLowPriorityNodes", p.CurrentLowPriorityNodes)
	populate(objectMap, "currentNodeCommunicationMode", p.CurrentNodeCommunicationMode)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "eTag", p.ETag)
	populate(objectMap, "enableAutoScale", p.EnableAutoScale)
	populate(objectMap, "enableInterNodeCommunication", p.EnableInterNodeCommunication)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "identity", p.Identity)
	populateDateTimeRFC3339(objectMap, "lastModified", p.LastModified)
	populate(objectMap, "metadata", p.Metadata)
	populate(objectMap, "mountConfiguration", p.MountConfiguration)
	populate(objectMap, "networkConfiguration", p.NetworkConfiguration)
	populate(objectMap, "resizeErrors", p.ResizeErrors)
	populate(objectMap, "resizeTimeout", p.ResizeTimeout)
	populate(objectMap, "resourceTags", p.ResourceTags)
	populate(objectMap, "startTask", p.StartTask)
	populate(objectMap, "state", p.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", p.StateTransitionTime)
	populate(objectMap, "stats", p.Stats)
	populate(objectMap, "targetDedicatedNodes", p.TargetDedicatedNodes)
	populate(objectMap, "targetLowPriorityNodes", p.TargetLowPriorityNodes)
	populate(objectMap, "targetNodeCommunicationMode", p.TargetNodeCommunicationMode)
	populate(objectMap, "taskSchedulingPolicy", p.TaskSchedulingPolicy)
	populate(objectMap, "taskSlotsPerNode", p.TaskSlotsPerNode)
	populate(objectMap, "url", p.URL)
	populate(objectMap, "upgradePolicy", p.UpgradePolicy)
	populate(objectMap, "userAccounts", p.UserAccounts)
	populate(objectMap, "vmSize", p.VMSize)
	populate(objectMap, "virtualMachineConfiguration", p.VirtualMachineConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Pool.
func (p *Pool) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allocationState":
			err = unpopulate(val, "AllocationState", &p.AllocationState)
			delete(rawMsg, key)
		case "allocationStateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "AllocationStateTransitionTime", &p.AllocationStateTransitionTime)
			delete(rawMsg, key)
		case "applicationPackageReferences":
			err = unpopulate(val, "ApplicationPackageReferences", &p.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "autoScaleEvaluationInterval":
			err = unpopulate(val, "AutoScaleEvaluationInterval", &p.AutoScaleEvaluationInterval)
			delete(rawMsg, key)
		case "autoScaleFormula":
			err = unpopulate(val, "AutoScaleFormula", &p.AutoScaleFormula)
			delete(rawMsg, key)
		case "autoScaleRun":
			err = unpopulate(val, "AutoScaleRun", &p.AutoScaleRun)
			delete(rawMsg, key)
		case "certificateReferences":
			err = unpopulate(val, "CertificateReferences", &p.CertificateReferences)
			delete(rawMsg, key)
		case "creationTime":
			err = unpopulateDateTimeRFC3339(val, "CreationTime", &p.CreationTime)
			delete(rawMsg, key)
		case "currentDedicatedNodes":
			err = unpopulate(val, "CurrentDedicatedNodes", &p.CurrentDedicatedNodes)
			delete(rawMsg, key)
		case "currentLowPriorityNodes":
			err = unpopulate(val, "CurrentLowPriorityNodes", &p.CurrentLowPriorityNodes)
			delete(rawMsg, key)
		case "currentNodeCommunicationMode":
			err = unpopulate(val, "CurrentNodeCommunicationMode", &p.CurrentNodeCommunicationMode)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "eTag":
			err = unpopulate(val, "ETag", &p.ETag)
			delete(rawMsg, key)
		case "enableAutoScale":
			err = unpopulate(val, "EnableAutoScale", &p.EnableAutoScale)
			delete(rawMsg, key)
		case "enableInterNodeCommunication":
			err = unpopulate(val, "EnableInterNodeCommunication", &p.EnableInterNodeCommunication)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &p.Identity)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateDateTimeRFC3339(val, "LastModified", &p.LastModified)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &p.Metadata)
			delete(rawMsg, key)
		case "mountConfiguration":
			err = unpopulate(val, "MountConfiguration", &p.MountConfiguration)
			delete(rawMsg, key)
		case "networkConfiguration":
			err = unpopulate(val, "NetworkConfiguration", &p.NetworkConfiguration)
			delete(rawMsg, key)
		case "resizeErrors":
			err = unpopulate(val, "ResizeErrors", &p.ResizeErrors)
			delete(rawMsg, key)
		case "resizeTimeout":
			err = unpopulate(val, "ResizeTimeout", &p.ResizeTimeout)
			delete(rawMsg, key)
		case "resourceTags":
			err = unpopulate(val, "ResourceTags", &p.ResourceTags)
			delete(rawMsg, key)
		case "startTask":
			err = unpopulate(val, "StartTask", &p.StartTask)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &p.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &p.StateTransitionTime)
			delete(rawMsg, key)
		case "stats":
			err = unpopulate(val, "Stats", &p.Stats)
			delete(rawMsg, key)
		case "targetDedicatedNodes":
			err = unpopulate(val, "TargetDedicatedNodes", &p.TargetDedicatedNodes)
			delete(rawMsg, key)
		case "targetLowPriorityNodes":
			err = unpopulate(val, "TargetLowPriorityNodes", &p.TargetLowPriorityNodes)
			delete(rawMsg, key)
		case "targetNodeCommunicationMode":
			err = unpopulate(val, "TargetNodeCommunicationMode", &p.TargetNodeCommunicationMode)
			delete(rawMsg, key)
		case "taskSchedulingPolicy":
			err = unpopulate(val, "TaskSchedulingPolicy", &p.TaskSchedulingPolicy)
			delete(rawMsg, key)
		case "taskSlotsPerNode":
			err = unpopulate(val, "TaskSlotsPerNode", &p.TaskSlotsPerNode)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &p.URL)
			delete(rawMsg, key)
		case "upgradePolicy":
			err = unpopulate(val, "UpgradePolicy", &p.UpgradePolicy)
			delete(rawMsg, key)
		case "userAccounts":
			err = unpopulate(val, "UserAccounts", &p.UserAccounts)
			delete(rawMsg, key)
		case "vmSize":
			err = unpopulate(val, "VMSize", &p.VMSize)
			delete(rawMsg, key)
		case "virtualMachineConfiguration":
			err = unpopulate(val, "VirtualMachineConfiguration", &p.VirtualMachineConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PoolEndpointConfiguration.
func (p PoolEndpointConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "inboundNATPools", p.InboundNATPools)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PoolEndpointConfiguration.
func (p *PoolEndpointConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inboundNATPools":
			err = unpopulate(val, "InboundNATPools", &p.InboundNATPools)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PoolIdentity.
func (p PoolIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "type", p.Type)
	populate(objectMap, "userAssignedIdentities", p.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PoolIdentity.
func (p *PoolIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "userAssignedIdentities":
			err = unpopulate(val, "UserAssignedIdentities", &p.UserAssignedIdentities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PoolInfo.
func (p PoolInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoPoolSpecification", p.AutoPoolSpecification)
	populate(objectMap, "poolId", p.PoolID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PoolInfo.
func (p *PoolInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoPoolSpecification":
			err = unpopulate(val, "AutoPoolSpecification", &p.AutoPoolSpecification)
			delete(rawMsg, key)
		case "poolId":
			err = unpopulate(val, "PoolID", &p.PoolID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PoolListResult.
func (p PoolListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PoolListResult.
func (p *PoolListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PoolNodeCounts.
func (p PoolNodeCounts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dedicated", p.Dedicated)
	populate(objectMap, "lowPriority", p.LowPriority)
	populate(objectMap, "poolId", p.PoolID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PoolNodeCounts.
func (p *PoolNodeCounts) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dedicated":
			err = unpopulate(val, "Dedicated", &p.Dedicated)
			delete(rawMsg, key)
		case "lowPriority":
			err = unpopulate(val, "LowPriority", &p.LowPriority)
			delete(rawMsg, key)
		case "poolId":
			err = unpopulate(val, "PoolID", &p.PoolID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PoolResourceStatistics.
func (p PoolResourceStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "avgCPUPercentage", p.AvgCPUPercentage)
	populate(objectMap, "avgDiskGiB", p.AvgDiskGiB)
	populate(objectMap, "avgMemoryGiB", p.AvgMemoryGiB)
	populate(objectMap, "diskReadGiB", p.DiskReadGiB)
	populate(objectMap, "diskReadIOps", to.Ptr(strconv.FormatInt(*p.DiskReadIOPS, 10)))
	populate(objectMap, "diskWriteGiB", p.DiskWriteGiB)
	populate(objectMap, "diskWriteIOps", to.Ptr(strconv.FormatInt(*p.DiskWriteIOPS, 10)))
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", p.LastUpdateTime)
	populate(objectMap, "networkReadGiB", p.NetworkReadGiB)
	populate(objectMap, "networkWriteGiB", p.NetworkWriteGiB)
	populate(objectMap, "peakDiskGiB", p.PeakDiskGiB)
	populate(objectMap, "peakMemoryGiB", p.PeakMemoryGiB)
	populateDateTimeRFC3339(objectMap, "startTime", p.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PoolResourceStatistics.
func (p *PoolResourceStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avgCPUPercentage":
			err = unpopulate(val, "AvgCPUPercentage", &p.AvgCPUPercentage)
			delete(rawMsg, key)
		case "avgDiskGiB":
			err = unpopulate(val, "AvgDiskGiB", &p.AvgDiskGiB)
			delete(rawMsg, key)
		case "avgMemoryGiB":
			err = unpopulate(val, "AvgMemoryGiB", &p.AvgMemoryGiB)
			delete(rawMsg, key)
		case "diskReadGiB":
			err = unpopulate(val, "DiskReadGiB", &p.DiskReadGiB)
			delete(rawMsg, key)
		case "diskReadIOps":
			var aux string
			err = unpopulate(val, "DiskReadIOPS", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					p.DiskReadIOPS = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		case "diskWriteGiB":
			err = unpopulate(val, "DiskWriteGiB", &p.DiskWriteGiB)
			delete(rawMsg, key)
		case "diskWriteIOps":
			var aux string
			err = unpopulate(val, "DiskWriteIOPS", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					p.DiskWriteIOPS = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		case "lastUpdateTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &p.LastUpdateTime)
			delete(rawMsg, key)
		case "networkReadGiB":
			err = unpopulate(val, "NetworkReadGiB", &p.NetworkReadGiB)
			delete(rawMsg, key)
		case "networkWriteGiB":
			err = unpopulate(val, "NetworkWriteGiB", &p.NetworkWriteGiB)
			delete(rawMsg, key)
		case "peakDiskGiB":
			err = unpopulate(val, "PeakDiskGiB", &p.PeakDiskGiB)
			delete(rawMsg, key)
		case "peakMemoryGiB":
			err = unpopulate(val, "PeakMemoryGiB", &p.PeakMemoryGiB)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &p.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PoolSpecification.
func (p PoolSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationPackageReferences", p.ApplicationPackageReferences)
	populate(objectMap, "autoScaleEvaluationInterval", p.AutoScaleEvaluationInterval)
	populate(objectMap, "autoScaleFormula", p.AutoScaleFormula)
	populate(objectMap, "certificateReferences", p.CertificateReferences)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "enableAutoScale", p.EnableAutoScale)
	populate(objectMap, "enableInterNodeCommunication", p.EnableInterNodeCommunication)
	populate(objectMap, "metadata", p.Metadata)
	populate(objectMap, "mountConfiguration", p.MountConfiguration)
	populate(objectMap, "networkConfiguration", p.NetworkConfiguration)
	populate(objectMap, "resizeTimeout", p.ResizeTimeout)
	populate(objectMap, "resourceTags", p.ResourceTags)
	populate(objectMap, "startTask", p.StartTask)
	populate(objectMap, "targetDedicatedNodes", p.TargetDedicatedNodes)
	populate(objectMap, "targetLowPriorityNodes", p.TargetLowPriorityNodes)
	populate(objectMap, "targetNodeCommunicationMode", p.TargetNodeCommunicationMode)
	populate(objectMap, "taskSchedulingPolicy", p.TaskSchedulingPolicy)
	populate(objectMap, "taskSlotsPerNode", p.TaskSlotsPerNode)
	populate(objectMap, "upgradePolicy", p.UpgradePolicy)
	populate(objectMap, "userAccounts", p.UserAccounts)
	populate(objectMap, "vmSize", p.VMSize)
	populate(objectMap, "virtualMachineConfiguration", p.VirtualMachineConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PoolSpecification.
func (p *PoolSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationPackageReferences":
			err = unpopulate(val, "ApplicationPackageReferences", &p.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "autoScaleEvaluationInterval":
			err = unpopulate(val, "AutoScaleEvaluationInterval", &p.AutoScaleEvaluationInterval)
			delete(rawMsg, key)
		case "autoScaleFormula":
			err = unpopulate(val, "AutoScaleFormula", &p.AutoScaleFormula)
			delete(rawMsg, key)
		case "certificateReferences":
			err = unpopulate(val, "CertificateReferences", &p.CertificateReferences)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "enableAutoScale":
			err = unpopulate(val, "EnableAutoScale", &p.EnableAutoScale)
			delete(rawMsg, key)
		case "enableInterNodeCommunication":
			err = unpopulate(val, "EnableInterNodeCommunication", &p.EnableInterNodeCommunication)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &p.Metadata)
			delete(rawMsg, key)
		case "mountConfiguration":
			err = unpopulate(val, "MountConfiguration", &p.MountConfiguration)
			delete(rawMsg, key)
		case "networkConfiguration":
			err = unpopulate(val, "NetworkConfiguration", &p.NetworkConfiguration)
			delete(rawMsg, key)
		case "resizeTimeout":
			err = unpopulate(val, "ResizeTimeout", &p.ResizeTimeout)
			delete(rawMsg, key)
		case "resourceTags":
			err = unpopulate(val, "ResourceTags", &p.ResourceTags)
			delete(rawMsg, key)
		case "startTask":
			err = unpopulate(val, "StartTask", &p.StartTask)
			delete(rawMsg, key)
		case "targetDedicatedNodes":
			err = unpopulate(val, "TargetDedicatedNodes", &p.TargetDedicatedNodes)
			delete(rawMsg, key)
		case "targetLowPriorityNodes":
			err = unpopulate(val, "TargetLowPriorityNodes", &p.TargetLowPriorityNodes)
			delete(rawMsg, key)
		case "targetNodeCommunicationMode":
			err = unpopulate(val, "TargetNodeCommunicationMode", &p.TargetNodeCommunicationMode)
			delete(rawMsg, key)
		case "taskSchedulingPolicy":
			err = unpopulate(val, "TaskSchedulingPolicy", &p.TaskSchedulingPolicy)
			delete(rawMsg, key)
		case "taskSlotsPerNode":
			err = unpopulate(val, "TaskSlotsPerNode", &p.TaskSlotsPerNode)
			delete(rawMsg, key)
		case "upgradePolicy":
			err = unpopulate(val, "UpgradePolicy", &p.UpgradePolicy)
			delete(rawMsg, key)
		case "userAccounts":
			err = unpopulate(val, "UserAccounts", &p.UserAccounts)
			delete(rawMsg, key)
		case "vmSize":
			err = unpopulate(val, "VMSize", &p.VMSize)
			delete(rawMsg, key)
		case "virtualMachineConfiguration":
			err = unpopulate(val, "VirtualMachineConfiguration", &p.VirtualMachineConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PoolStatistics.
func (p PoolStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", p.LastUpdateTime)
	populate(objectMap, "resourceStats", p.ResourceStats)
	populateDateTimeRFC3339(objectMap, "startTime", p.StartTime)
	populate(objectMap, "url", p.URL)
	populate(objectMap, "usageStats", p.UsageStats)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PoolStatistics.
func (p *PoolStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastUpdateTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &p.LastUpdateTime)
			delete(rawMsg, key)
		case "resourceStats":
			err = unpopulate(val, "ResourceStats", &p.ResourceStats)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &p.StartTime)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &p.URL)
			delete(rawMsg, key)
		case "usageStats":
			err = unpopulate(val, "UsageStats", &p.UsageStats)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PoolUsageStatistics.
func (p PoolUsageStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dedicatedCoreTime", p.DedicatedCoreTime)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", p.LastUpdateTime)
	populateDateTimeRFC3339(objectMap, "startTime", p.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PoolUsageStatistics.
func (p *PoolUsageStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dedicatedCoreTime":
			err = unpopulate(val, "DedicatedCoreTime", &p.DedicatedCoreTime)
			delete(rawMsg, key)
		case "lastUpdateTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &p.LastUpdateTime)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &p.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PublicIPAddressConfiguration.
func (p PublicIPAddressConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipAddressIds", p.IPAddressIDs)
	populate(objectMap, "provision", p.IPAddressProvisioningType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PublicIPAddressConfiguration.
func (p *PublicIPAddressConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipAddressIds":
			err = unpopulate(val, "IPAddressIDs", &p.IPAddressIDs)
			delete(rawMsg, key)
		case "provision":
			err = unpopulate(val, "IPAddressProvisioningType", &p.IPAddressProvisioningType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RebootNodeContent.
func (r RebootNodeContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeRebootOption", r.NodeRebootOption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RebootNodeContent.
func (r *RebootNodeContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeRebootOption":
			err = unpopulate(val, "NodeRebootOption", &r.NodeRebootOption)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecentJob.
func (r RecentJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "url", r.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecentJob.
func (r *RecentJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &r.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReimageNodeContent.
func (r ReimageNodeContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeReimageOption", r.NodeReimageOption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReimageNodeContent.
func (r *ReimageNodeContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeReimageOption":
			err = unpopulate(val, "NodeReimageOption", &r.NodeReimageOption)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemoveNodeContent.
func (r RemoveNodeContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeDeallocationOption", r.NodeDeallocationOption)
	populate(objectMap, "nodeList", r.NodeList)
	populate(objectMap, "resizeTimeout", r.ResizeTimeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemoveNodeContent.
func (r *RemoveNodeContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeDeallocationOption":
			err = unpopulate(val, "NodeDeallocationOption", &r.NodeDeallocationOption)
			delete(rawMsg, key)
		case "nodeList":
			err = unpopulate(val, "NodeList", &r.NodeList)
			delete(rawMsg, key)
		case "resizeTimeout":
			err = unpopulate(val, "ResizeTimeout", &r.ResizeTimeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReplacePoolContent.
func (r ReplacePoolContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationPackageReferences", r.ApplicationPackageReferences)
	populate(objectMap, "certificateReferences", r.CertificateReferences)
	populate(objectMap, "metadata", r.Metadata)
	populate(objectMap, "startTask", r.StartTask)
	populate(objectMap, "targetNodeCommunicationMode", r.TargetNodeCommunicationMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReplacePoolContent.
func (r *ReplacePoolContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationPackageReferences":
			err = unpopulate(val, "ApplicationPackageReferences", &r.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "certificateReferences":
			err = unpopulate(val, "CertificateReferences", &r.CertificateReferences)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &r.Metadata)
			delete(rawMsg, key)
		case "startTask":
			err = unpopulate(val, "StartTask", &r.StartTask)
			delete(rawMsg, key)
		case "targetNodeCommunicationMode":
			err = unpopulate(val, "TargetNodeCommunicationMode", &r.TargetNodeCommunicationMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResizeError.
func (r ResizeError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", r.Code)
	populate(objectMap, "message", r.Message)
	populate(objectMap, "values", r.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResizeError.
func (r *ResizeError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &r.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &r.Message)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &r.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResizePoolContent.
func (r ResizePoolContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeDeallocationOption", r.NodeDeallocationOption)
	populate(objectMap, "resizeTimeout", r.ResizeTimeout)
	populate(objectMap, "targetDedicatedNodes", r.TargetDedicatedNodes)
	populate(objectMap, "targetLowPriorityNodes", r.TargetLowPriorityNodes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResizePoolContent.
func (r *ResizePoolContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeDeallocationOption":
			err = unpopulate(val, "NodeDeallocationOption", &r.NodeDeallocationOption)
			delete(rawMsg, key)
		case "resizeTimeout":
			err = unpopulate(val, "ResizeTimeout", &r.ResizeTimeout)
			delete(rawMsg, key)
		case "targetDedicatedNodes":
			err = unpopulate(val, "TargetDedicatedNodes", &r.TargetDedicatedNodes)
			delete(rawMsg, key)
		case "targetLowPriorityNodes":
			err = unpopulate(val, "TargetLowPriorityNodes", &r.TargetLowPriorityNodes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceFile.
func (r ResourceFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoStorageContainerName", r.AutoStorageContainerName)
	populate(objectMap, "blobPrefix", r.BlobPrefix)
	populate(objectMap, "fileMode", r.FileMode)
	populate(objectMap, "filePath", r.FilePath)
	populate(objectMap, "httpUrl", r.HTTPURL)
	populate(objectMap, "identityReference", r.IdentityReference)
	populate(objectMap, "storageContainerUrl", r.StorageContainerURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceFile.
func (r *ResourceFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoStorageContainerName":
			err = unpopulate(val, "AutoStorageContainerName", &r.AutoStorageContainerName)
			delete(rawMsg, key)
		case "blobPrefix":
			err = unpopulate(val, "BlobPrefix", &r.BlobPrefix)
			delete(rawMsg, key)
		case "fileMode":
			err = unpopulate(val, "FileMode", &r.FileMode)
			delete(rawMsg, key)
		case "filePath":
			err = unpopulate(val, "FilePath", &r.FilePath)
			delete(rawMsg, key)
		case "httpUrl":
			err = unpopulate(val, "HTTPURL", &r.HTTPURL)
			delete(rawMsg, key)
		case "identityReference":
			err = unpopulate(val, "IdentityReference", &r.IdentityReference)
			delete(rawMsg, key)
		case "storageContainerUrl":
			err = unpopulate(val, "StorageContainerURL", &r.StorageContainerURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RollingUpgradePolicy.
func (r RollingUpgradePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enableCrossZoneUpgrade", r.EnableCrossZoneUpgrade)
	populate(objectMap, "maxBatchInstancePercent", r.MaxBatchInstancePercent)
	populate(objectMap, "maxUnhealthyInstancePercent", r.MaxUnhealthyInstancePercent)
	populate(objectMap, "maxUnhealthyUpgradedInstancePercent", r.MaxUnhealthyUpgradedInstancePercent)
	populate(objectMap, "pauseTimeBetweenBatches", r.PauseTimeBetweenBatches)
	populate(objectMap, "prioritizeUnhealthyInstances", r.PrioritizeUnhealthyInstances)
	populate(objectMap, "rollbackFailedInstancesOnPolicyBreach", r.RollbackFailedInstancesOnPolicyBreach)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RollingUpgradePolicy.
func (r *RollingUpgradePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableCrossZoneUpgrade":
			err = unpopulate(val, "EnableCrossZoneUpgrade", &r.EnableCrossZoneUpgrade)
			delete(rawMsg, key)
		case "maxBatchInstancePercent":
			err = unpopulate(val, "MaxBatchInstancePercent", &r.MaxBatchInstancePercent)
			delete(rawMsg, key)
		case "maxUnhealthyInstancePercent":
			err = unpopulate(val, "MaxUnhealthyInstancePercent", &r.MaxUnhealthyInstancePercent)
			delete(rawMsg, key)
		case "maxUnhealthyUpgradedInstancePercent":
			err = unpopulate(val, "MaxUnhealthyUpgradedInstancePercent", &r.MaxUnhealthyUpgradedInstancePercent)
			delete(rawMsg, key)
		case "pauseTimeBetweenBatches":
			err = unpopulate(val, "PauseTimeBetweenBatches", &r.PauseTimeBetweenBatches)
			delete(rawMsg, key)
		case "prioritizeUnhealthyInstances":
			err = unpopulate(val, "PrioritizeUnhealthyInstances", &r.PrioritizeUnhealthyInstances)
			delete(rawMsg, key)
		case "rollbackFailedInstancesOnPolicyBreach":
			err = unpopulate(val, "RollbackFailedInstancesOnPolicyBreach", &r.RollbackFailedInstancesOnPolicyBreach)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecurityProfile.
func (s SecurityProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptionAtHost", s.EncryptionAtHost)
	populate(objectMap, "securityType", s.SecurityType)
	populate(objectMap, "uefiSettings", s.UefiSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityProfile.
func (s *SecurityProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptionAtHost":
			err = unpopulate(val, "EncryptionAtHost", &s.EncryptionAtHost)
			delete(rawMsg, key)
		case "securityType":
			err = unpopulate(val, "SecurityType", &s.SecurityType)
			delete(rawMsg, key)
		case "uefiSettings":
			err = unpopulate(val, "UefiSettings", &s.UefiSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceArtifactReference.
func (s ServiceArtifactReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceArtifactReference.
func (s *ServiceArtifactReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StartTask.
func (s StartTask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commandLine", s.CommandLine)
	populate(objectMap, "containerSettings", s.ContainerSettings)
	populate(objectMap, "environmentSettings", s.EnvironmentSettings)
	populate(objectMap, "maxTaskRetryCount", s.MaxTaskRetryCount)
	populate(objectMap, "resourceFiles", s.ResourceFiles)
	populate(objectMap, "userIdentity", s.UserIdentity)
	populate(objectMap, "waitForSuccess", s.WaitForSuccess)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StartTask.
func (s *StartTask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandLine":
			err = unpopulate(val, "CommandLine", &s.CommandLine)
			delete(rawMsg, key)
		case "containerSettings":
			err = unpopulate(val, "ContainerSettings", &s.ContainerSettings)
			delete(rawMsg, key)
		case "environmentSettings":
			err = unpopulate(val, "EnvironmentSettings", &s.EnvironmentSettings)
			delete(rawMsg, key)
		case "maxTaskRetryCount":
			err = unpopulate(val, "MaxTaskRetryCount", &s.MaxTaskRetryCount)
			delete(rawMsg, key)
		case "resourceFiles":
			err = unpopulate(val, "ResourceFiles", &s.ResourceFiles)
			delete(rawMsg, key)
		case "userIdentity":
			err = unpopulate(val, "UserIdentity", &s.UserIdentity)
			delete(rawMsg, key)
		case "waitForSuccess":
			err = unpopulate(val, "WaitForSuccess", &s.WaitForSuccess)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StartTaskInfo.
func (s StartTaskInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerInfo", s.ContainerInfo)
	populateDateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populate(objectMap, "exitCode", s.ExitCode)
	populate(objectMap, "failureInfo", s.FailureInfo)
	populateDateTimeRFC3339(objectMap, "lastRetryTime", s.LastRetryTime)
	populate(objectMap, "result", s.Result)
	populate(objectMap, "retryCount", s.RetryCount)
	populateDateTimeRFC3339(objectMap, "startTime", s.StartTime)
	populate(objectMap, "state", s.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StartTaskInfo.
func (s *StartTaskInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerInfo":
			err = unpopulate(val, "ContainerInfo", &s.ContainerInfo)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &s.EndTime)
			delete(rawMsg, key)
		case "exitCode":
			err = unpopulate(val, "ExitCode", &s.ExitCode)
			delete(rawMsg, key)
		case "failureInfo":
			err = unpopulate(val, "FailureInfo", &s.FailureInfo)
			delete(rawMsg, key)
		case "lastRetryTime":
			err = unpopulateDateTimeRFC3339(val, "LastRetryTime", &s.LastRetryTime)
			delete(rawMsg, key)
		case "result":
			err = unpopulate(val, "Result", &s.Result)
			delete(rawMsg, key)
		case "retryCount":
			err = unpopulate(val, "RetryCount", &s.RetryCount)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &s.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &s.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Subtask.
func (s Subtask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerInfo", s.ContainerInfo)
	populateDateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populate(objectMap, "exitCode", s.ExitCode)
	populate(objectMap, "failureInfo", s.FailureInfo)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "nodeInfo", s.NodeInfo)
	populate(objectMap, "previousState", s.PreviousState)
	populateDateTimeRFC3339(objectMap, "previousStateTransitionTime", s.PreviousStateTransitionTime)
	populate(objectMap, "result", s.Result)
	populateDateTimeRFC3339(objectMap, "startTime", s.StartTime)
	populate(objectMap, "state", s.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", s.StateTransitionTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Subtask.
func (s *Subtask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerInfo":
			err = unpopulate(val, "ContainerInfo", &s.ContainerInfo)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &s.EndTime)
			delete(rawMsg, key)
		case "exitCode":
			err = unpopulate(val, "ExitCode", &s.ExitCode)
			delete(rawMsg, key)
		case "failureInfo":
			err = unpopulate(val, "FailureInfo", &s.FailureInfo)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "nodeInfo":
			err = unpopulate(val, "NodeInfo", &s.NodeInfo)
			delete(rawMsg, key)
		case "previousState":
			err = unpopulate(val, "PreviousState", &s.PreviousState)
			delete(rawMsg, key)
		case "previousStateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "PreviousStateTransitionTime", &s.PreviousStateTransitionTime)
			delete(rawMsg, key)
		case "result":
			err = unpopulate(val, "Result", &s.Result)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &s.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &s.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &s.StateTransitionTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SupportedImage.
func (s SupportedImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "batchSupportEndOfLife", s.BatchSupportEndOfLife)
	populate(objectMap, "capabilities", s.Capabilities)
	populate(objectMap, "imageReference", s.ImageReference)
	populate(objectMap, "nodeAgentSKUId", s.NodeAgentSKUID)
	populate(objectMap, "osType", s.OSType)
	populate(objectMap, "verificationType", s.VerificationType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SupportedImage.
func (s *SupportedImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "batchSupportEndOfLife":
			err = unpopulateDateTimeRFC3339(val, "BatchSupportEndOfLife", &s.BatchSupportEndOfLife)
			delete(rawMsg, key)
		case "capabilities":
			err = unpopulate(val, "Capabilities", &s.Capabilities)
			delete(rawMsg, key)
		case "imageReference":
			err = unpopulate(val, "ImageReference", &s.ImageReference)
			delete(rawMsg, key)
		case "nodeAgentSKUId":
			err = unpopulate(val, "NodeAgentSKUID", &s.NodeAgentSKUID)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &s.OSType)
			delete(rawMsg, key)
		case "verificationType":
			err = unpopulate(val, "VerificationType", &s.VerificationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Task.
func (t Task) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityInfo", t.AffinityInfo)
	populate(objectMap, "applicationPackageReferences", t.ApplicationPackageReferences)
	populate(objectMap, "authenticationTokenSettings", t.AuthenticationTokenSettings)
	populate(objectMap, "commandLine", t.CommandLine)
	populate(objectMap, "constraints", t.Constraints)
	populate(objectMap, "containerSettings", t.ContainerSettings)
	populateDateTimeRFC3339(objectMap, "creationTime", t.CreationTime)
	populate(objectMap, "dependsOn", t.DependsOn)
	populate(objectMap, "displayName", t.DisplayName)
	populate(objectMap, "eTag", t.ETag)
	populate(objectMap, "environmentSettings", t.EnvironmentSettings)
	populate(objectMap, "executionInfo", t.ExecutionInfo)
	populate(objectMap, "exitConditions", t.ExitConditions)
	populate(objectMap, "id", t.ID)
	populateDateTimeRFC3339(objectMap, "lastModified", t.LastModified)
	populate(objectMap, "multiInstanceSettings", t.MultiInstanceSettings)
	populate(objectMap, "nodeInfo", t.NodeInfo)
	populate(objectMap, "outputFiles", t.OutputFiles)
	populate(objectMap, "previousState", t.PreviousState)
	populateDateTimeRFC3339(objectMap, "previousStateTransitionTime", t.PreviousStateTransitionTime)
	populate(objectMap, "requiredSlots", t.RequiredSlots)
	populate(objectMap, "resourceFiles", t.ResourceFiles)
	populate(objectMap, "state", t.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", t.StateTransitionTime)
	populate(objectMap, "stats", t.Stats)
	populate(objectMap, "url", t.URL)
	populate(objectMap, "userIdentity", t.UserIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Task.
func (t *Task) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityInfo":
			err = unpopulate(val, "AffinityInfo", &t.AffinityInfo)
			delete(rawMsg, key)
		case "applicationPackageReferences":
			err = unpopulate(val, "ApplicationPackageReferences", &t.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "authenticationTokenSettings":
			err = unpopulate(val, "AuthenticationTokenSettings", &t.AuthenticationTokenSettings)
			delete(rawMsg, key)
		case "commandLine":
			err = unpopulate(val, "CommandLine", &t.CommandLine)
			delete(rawMsg, key)
		case "constraints":
			err = unpopulate(val, "Constraints", &t.Constraints)
			delete(rawMsg, key)
		case "containerSettings":
			err = unpopulate(val, "ContainerSettings", &t.ContainerSettings)
			delete(rawMsg, key)
		case "creationTime":
			err = unpopulateDateTimeRFC3339(val, "CreationTime", &t.CreationTime)
			delete(rawMsg, key)
		case "dependsOn":
			err = unpopulate(val, "DependsOn", &t.DependsOn)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &t.DisplayName)
			delete(rawMsg, key)
		case "eTag":
			err = unpopulate(val, "ETag", &t.ETag)
			delete(rawMsg, key)
		case "environmentSettings":
			err = unpopulate(val, "EnvironmentSettings", &t.EnvironmentSettings)
			delete(rawMsg, key)
		case "executionInfo":
			err = unpopulate(val, "ExecutionInfo", &t.ExecutionInfo)
			delete(rawMsg, key)
		case "exitConditions":
			err = unpopulate(val, "ExitConditions", &t.ExitConditions)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateDateTimeRFC3339(val, "LastModified", &t.LastModified)
			delete(rawMsg, key)
		case "multiInstanceSettings":
			err = unpopulate(val, "MultiInstanceSettings", &t.MultiInstanceSettings)
			delete(rawMsg, key)
		case "nodeInfo":
			err = unpopulate(val, "NodeInfo", &t.NodeInfo)
			delete(rawMsg, key)
		case "outputFiles":
			err = unpopulate(val, "OutputFiles", &t.OutputFiles)
			delete(rawMsg, key)
		case "previousState":
			err = unpopulate(val, "PreviousState", &t.PreviousState)
			delete(rawMsg, key)
		case "previousStateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "PreviousStateTransitionTime", &t.PreviousStateTransitionTime)
			delete(rawMsg, key)
		case "requiredSlots":
			err = unpopulate(val, "RequiredSlots", &t.RequiredSlots)
			delete(rawMsg, key)
		case "resourceFiles":
			err = unpopulate(val, "ResourceFiles", &t.ResourceFiles)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &t.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
			err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &t.StateTransitionTime)
			delete(rawMsg, key)
		case "stats":
			err = unpopulate(val, "Stats", &t.Stats)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &t.URL)
			delete(rawMsg, key)
		case "userIdentity":
			err = unpopulate(val, "UserIdentity", &t.UserIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskAddResult.
func (t TaskAddResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", t.ETag)
	populate(objectMap, "error", t.Error)
	populateDateTimeRFC3339(objectMap, "lastModified", t.LastModified)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "taskId", t.TaskID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskAddResult.
func (t *TaskAddResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &t.ETag)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &t.Error)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateDateTimeRFC3339(val, "LastModified", &t.LastModified)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &t.Location)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &t.Status)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, "TaskID", &t.TaskID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskConstraints.
func (t TaskConstraints) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxTaskRetryCount", t.MaxTaskRetryCount)
	populate(objectMap, "maxWallClockTime", t.MaxWallClockTime)
	populate(objectMap, "retentionTime", t.RetentionTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskConstraints.
func (t *TaskConstraints) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxTaskRetryCount":
			err = unpopulate(val, "MaxTaskRetryCount", &t.MaxTaskRetryCount)
			delete(rawMsg, key)
		case "maxWallClockTime":
			err = unpopulate(val, "MaxWallClockTime", &t.MaxWallClockTime)
			delete(rawMsg, key)
		case "retentionTime":
			err = unpopulate(val, "RetentionTime", &t.RetentionTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskContainerExecutionInfo.
func (t TaskContainerExecutionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerId", t.ContainerID)
	populate(objectMap, "error", t.Error)
	populate(objectMap, "state", t.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskContainerExecutionInfo.
func (t *TaskContainerExecutionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerId":
			err = unpopulate(val, "ContainerID", &t.ContainerID)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &t.Error)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &t.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskContainerSettings.
func (t TaskContainerSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerHostBatchBindMounts", t.ContainerHostBatchBindMounts)
	populate(objectMap, "containerRunOptions", t.ContainerRunOptions)
	populate(objectMap, "imageName", t.ImageName)
	populate(objectMap, "registry", t.Registry)
	populate(objectMap, "workingDirectory", t.WorkingDirectory)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskContainerSettings.
func (t *TaskContainerSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerHostBatchBindMounts":
			err = unpopulate(val, "ContainerHostBatchBindMounts", &t.ContainerHostBatchBindMounts)
			delete(rawMsg, key)
		case "containerRunOptions":
			err = unpopulate(val, "ContainerRunOptions", &t.ContainerRunOptions)
			delete(rawMsg, key)
		case "imageName":
			err = unpopulate(val, "ImageName", &t.ImageName)
			delete(rawMsg, key)
		case "registry":
			err = unpopulate(val, "Registry", &t.Registry)
			delete(rawMsg, key)
		case "workingDirectory":
			err = unpopulate(val, "WorkingDirectory", &t.WorkingDirectory)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskCounts.
func (t TaskCounts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "active", t.Active)
	populate(objectMap, "completed", t.Completed)
	populate(objectMap, "failed", t.Failed)
	populate(objectMap, "running", t.Running)
	populate(objectMap, "succeeded", t.Succeeded)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskCounts.
func (t *TaskCounts) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "active":
			err = unpopulate(val, "Active", &t.Active)
			delete(rawMsg, key)
		case "completed":
			err = unpopulate(val, "Completed", &t.Completed)
			delete(rawMsg, key)
		case "failed":
			err = unpopulate(val, "Failed", &t.Failed)
			delete(rawMsg, key)
		case "running":
			err = unpopulate(val, "Running", &t.Running)
			delete(rawMsg, key)
		case "succeeded":
			err = unpopulate(val, "Succeeded", &t.Succeeded)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskCountsResult.
func (t TaskCountsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "taskCounts", t.TaskCounts)
	populate(objectMap, "taskSlotCounts", t.TaskSlotCounts)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskCountsResult.
func (t *TaskCountsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "taskCounts":
			err = unpopulate(val, "TaskCounts", &t.TaskCounts)
			delete(rawMsg, key)
		case "taskSlotCounts":
			err = unpopulate(val, "TaskSlotCounts", &t.TaskSlotCounts)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskDependencies.
func (t TaskDependencies) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "taskIdRanges", t.TaskIDRanges)
	populate(objectMap, "taskIds", t.TaskIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskDependencies.
func (t *TaskDependencies) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "taskIdRanges":
			err = unpopulate(val, "TaskIDRanges", &t.TaskIDRanges)
			delete(rawMsg, key)
		case "taskIds":
			err = unpopulate(val, "TaskIDs", &t.TaskIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskExecutionInfo.
func (t TaskExecutionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerInfo", t.ContainerInfo)
	populateDateTimeRFC3339(objectMap, "endTime", t.EndTime)
	populate(objectMap, "exitCode", t.ExitCode)
	populate(objectMap, "failureInfo", t.FailureInfo)
	populateDateTimeRFC3339(objectMap, "lastRequeueTime", t.LastRequeueTime)
	populateDateTimeRFC3339(objectMap, "lastRetryTime", t.LastRetryTime)
	populate(objectMap, "requeueCount", t.RequeueCount)
	populate(objectMap, "result", t.Result)
	populate(objectMap, "retryCount", t.RetryCount)
	populateDateTimeRFC3339(objectMap, "startTime", t.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskExecutionInfo.
func (t *TaskExecutionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerInfo":
			err = unpopulate(val, "ContainerInfo", &t.ContainerInfo)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &t.EndTime)
			delete(rawMsg, key)
		case "exitCode":
			err = unpopulate(val, "ExitCode", &t.ExitCode)
			delete(rawMsg, key)
		case "failureInfo":
			err = unpopulate(val, "FailureInfo", &t.FailureInfo)
			delete(rawMsg, key)
		case "lastRequeueTime":
			err = unpopulateDateTimeRFC3339(val, "LastRequeueTime", &t.LastRequeueTime)
			delete(rawMsg, key)
		case "lastRetryTime":
			err = unpopulateDateTimeRFC3339(val, "LastRetryTime", &t.LastRetryTime)
			delete(rawMsg, key)
		case "requeueCount":
			err = unpopulate(val, "RequeueCount", &t.RequeueCount)
			delete(rawMsg, key)
		case "result":
			err = unpopulate(val, "Result", &t.Result)
			delete(rawMsg, key)
		case "retryCount":
			err = unpopulate(val, "RetryCount", &t.RetryCount)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &t.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskFailureInfo.
func (t TaskFailureInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "category", t.Category)
	populate(objectMap, "code", t.Code)
	populate(objectMap, "details", t.Details)
	populate(objectMap, "message", t.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskFailureInfo.
func (t *TaskFailureInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
			err = unpopulate(val, "Category", &t.Category)
			delete(rawMsg, key)
		case "code":
			err = unpopulate(val, "Code", &t.Code)
			delete(rawMsg, key)
		case "details":
			err = unpopulate(val, "Details", &t.Details)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &t.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskGroup.
func (t TaskGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskGroup.
func (t *TaskGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskIDRange.
func (t TaskIDRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "end", t.End)
	populate(objectMap, "start", t.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskIDRange.
func (t *TaskIDRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "end":
			err = unpopulate(val, "End", &t.End)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, "Start", &t.Start)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskInfo.
func (t TaskInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "executionInfo", t.ExecutionInfo)
	populate(objectMap, "jobId", t.JobID)
	populate(objectMap, "subtaskId", t.SubtaskID)
	populate(objectMap, "taskId", t.TaskID)
	populate(objectMap, "taskState", t.TaskState)
	populate(objectMap, "taskUrl", t.TaskURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskInfo.
func (t *TaskInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "executionInfo":
			err = unpopulate(val, "ExecutionInfo", &t.ExecutionInfo)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, "JobID", &t.JobID)
			delete(rawMsg, key)
		case "subtaskId":
			err = unpopulate(val, "SubtaskID", &t.SubtaskID)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, "TaskID", &t.TaskID)
			delete(rawMsg, key)
		case "taskState":
			err = unpopulate(val, "TaskState", &t.TaskState)
			delete(rawMsg, key)
		case "taskUrl":
			err = unpopulate(val, "TaskURL", &t.TaskURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskListResult.
func (t TaskListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskListResult.
func (t *TaskListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &t.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskListSubtasksResult.
func (t TaskListSubtasksResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskListSubtasksResult.
func (t *TaskListSubtasksResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &t.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskSchedulingPolicy.
func (t TaskSchedulingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeFillType", t.NodeFillType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskSchedulingPolicy.
func (t *TaskSchedulingPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeFillType":
			err = unpopulate(val, "NodeFillType", &t.NodeFillType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskSlotCounts.
func (t TaskSlotCounts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "active", t.Active)
	populate(objectMap, "completed", t.Completed)
	populate(objectMap, "failed", t.Failed)
	populate(objectMap, "running", t.Running)
	populate(objectMap, "succeeded", t.Succeeded)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskSlotCounts.
func (t *TaskSlotCounts) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "active":
			err = unpopulate(val, "Active", &t.Active)
			delete(rawMsg, key)
		case "completed":
			err = unpopulate(val, "Completed", &t.Completed)
			delete(rawMsg, key)
		case "failed":
			err = unpopulate(val, "Failed", &t.Failed)
			delete(rawMsg, key)
		case "running":
			err = unpopulate(val, "Running", &t.Running)
			delete(rawMsg, key)
		case "succeeded":
			err = unpopulate(val, "Succeeded", &t.Succeeded)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskStatistics.
func (t TaskStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kernelCPUTime", t.KernelCPUTime)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", t.LastUpdateTime)
	populate(objectMap, "readIOGiB", t.ReadIOGiB)
	populate(objectMap, "readIOps", to.Ptr(strconv.FormatInt(*t.ReadIOPS, 10)))
	populateDateTimeRFC3339(objectMap, "startTime", t.StartTime)
	populate(objectMap, "url", t.URL)
	populate(objectMap, "userCPUTime", t.UserCPUTime)
	populate(objectMap, "waitTime", t.WaitTime)
	populate(objectMap, "wallClockTime", t.WallClockTime)
	populate(objectMap, "writeIOGiB", t.WriteIOGiB)
	populate(objectMap, "writeIOps", to.Ptr(strconv.FormatInt(*t.WriteIOPS, 10)))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskStatistics.
func (t *TaskStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kernelCPUTime":
			err = unpopulate(val, "KernelCPUTime", &t.KernelCPUTime)
			delete(rawMsg, key)
		case "lastUpdateTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &t.LastUpdateTime)
			delete(rawMsg, key)
		case "readIOGiB":
			err = unpopulate(val, "ReadIOGiB", &t.ReadIOGiB)
			delete(rawMsg, key)
		case "readIOps":
			var aux string
			err = unpopulate(val, "ReadIOPS", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					t.ReadIOPS = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &t.StartTime)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &t.URL)
			delete(rawMsg, key)
		case "userCPUTime":
			err = unpopulate(val, "UserCPUTime", &t.UserCPUTime)
			delete(rawMsg, key)
		case "waitTime":
			err = unpopulate(val, "WaitTime", &t.WaitTime)
			delete(rawMsg, key)
		case "wallClockTime":
			err = unpopulate(val, "WallClockTime", &t.WallClockTime)
			delete(rawMsg, key)
		case "writeIOGiB":
			err = unpopulate(val, "WriteIOGiB", &t.WriteIOGiB)
			delete(rawMsg, key)
		case "writeIOps":
			var aux string
			err = unpopulate(val, "WriteIOPS", &aux)
			if err == nil {
				var v int64
				v, err = strconv.ParseInt(aux, 10, 0)
				if err == nil {
					t.WriteIOPS = to.Ptr(v)
				}
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TerminateJobContent.
func (t TerminateJobContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "terminateReason", t.TerminationReason)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TerminateJobContent.
func (t *TerminateJobContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "terminateReason":
			err = unpopulate(val, "TerminationReason", &t.TerminationReason)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UEFISettings.
func (u UEFISettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secureBootEnabled", u.SecureBootEnabled)
	populate(objectMap, "vTpmEnabled", u.VTPMEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UEFISettings.
func (u *UEFISettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secureBootEnabled":
			err = unpopulate(val, "SecureBootEnabled", &u.SecureBootEnabled)
			delete(rawMsg, key)
		case "vTpmEnabled":
			err = unpopulate(val, "VTPMEnabled", &u.VTPMEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateJobContent.
func (u UpdateJobContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowTaskPreemption", u.AllowTaskPreemption)
	populate(objectMap, "constraints", u.Constraints)
	populate(objectMap, "maxParallelTasks", u.MaxParallelTasks)
	populate(objectMap, "metadata", u.Metadata)
	populate(objectMap, "networkConfiguration", u.NetworkConfiguration)
	populate(objectMap, "onAllTasksComplete", u.OnAllTasksComplete)
	populate(objectMap, "poolInfo", u.PoolInfo)
	populate(objectMap, "priority", u.Priority)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateJobContent.
func (u *UpdateJobContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowTaskPreemption":
			err = unpopulate(val, "AllowTaskPreemption", &u.AllowTaskPreemption)
			delete(rawMsg, key)
		case "constraints":
			err = unpopulate(val, "Constraints", &u.Constraints)
			delete(rawMsg, key)
		case "maxParallelTasks":
			err = unpopulate(val, "MaxParallelTasks", &u.MaxParallelTasks)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &u.Metadata)
			delete(rawMsg, key)
		case "networkConfiguration":
			err = unpopulate(val, "NetworkConfiguration", &u.NetworkConfiguration)
			delete(rawMsg, key)
		case "onAllTasksComplete":
			err = unpopulate(val, "OnAllTasksComplete", &u.OnAllTasksComplete)
			delete(rawMsg, key)
		case "poolInfo":
			err = unpopulate(val, "PoolInfo", &u.PoolInfo)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, "Priority", &u.Priority)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateJobScheduleContent.
func (u UpdateJobScheduleContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "jobSpecification", u.JobSpecification)
	populate(objectMap, "metadata", u.Metadata)
	populate(objectMap, "schedule", u.Schedule)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateJobScheduleContent.
func (u *UpdateJobScheduleContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobSpecification":
			err = unpopulate(val, "JobSpecification", &u.JobSpecification)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &u.Metadata)
			delete(rawMsg, key)
		case "schedule":
			err = unpopulate(val, "Schedule", &u.Schedule)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateNodeUserContent.
func (u UpdateNodeUserContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "expiryTime", u.ExpiryTime)
	populate(objectMap, "password", u.Password)
	populate(objectMap, "sshPublicKey", u.SSHPublicKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateNodeUserContent.
func (u *UpdateNodeUserContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiryTime":
			err = unpopulateDateTimeRFC3339(val, "ExpiryTime", &u.ExpiryTime)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &u.Password)
			delete(rawMsg, key)
		case "sshPublicKey":
			err = unpopulate(val, "SSHPublicKey", &u.SSHPublicKey)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdatePoolContent.
func (u UpdatePoolContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationPackageReferences", u.ApplicationPackageReferences)
	populate(objectMap, "certificateReferences", u.CertificateReferences)
	populate(objectMap, "displayName", u.DisplayName)
	populate(objectMap, "enableInterNodeCommunication", u.EnableInterNodeCommunication)
	populate(objectMap, "metadata", u.Metadata)
	populate(objectMap, "mountConfiguration", u.MountConfiguration)
	populate(objectMap, "networkConfiguration", u.NetworkConfiguration)
	populate(objectMap, "resourceTags", u.ResourceTags)
	populate(objectMap, "startTask", u.StartTask)
	populate(objectMap, "targetNodeCommunicationMode", u.TargetNodeCommunicationMode)
	populate(objectMap, "taskSchedulingPolicy", u.TaskSchedulingPolicy)
	populate(objectMap, "taskSlotsPerNode", u.TaskSlotsPerNode)
	populate(objectMap, "upgradePolicy", u.UpgradePolicy)
	populate(objectMap, "userAccounts", u.UserAccounts)
	populate(objectMap, "vmSize", u.VMSize)
	populate(objectMap, "virtualMachineConfiguration", u.VirtualMachineConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdatePoolContent.
func (u *UpdatePoolContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationPackageReferences":
			err = unpopulate(val, "ApplicationPackageReferences", &u.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "certificateReferences":
			err = unpopulate(val, "CertificateReferences", &u.CertificateReferences)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		case "enableInterNodeCommunication":
			err = unpopulate(val, "EnableInterNodeCommunication", &u.EnableInterNodeCommunication)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &u.Metadata)
			delete(rawMsg, key)
		case "mountConfiguration":
			err = unpopulate(val, "MountConfiguration", &u.MountConfiguration)
			delete(rawMsg, key)
		case "networkConfiguration":
			err = unpopulate(val, "NetworkConfiguration", &u.NetworkConfiguration)
			delete(rawMsg, key)
		case "resourceTags":
			err = unpopulate(val, "ResourceTags", &u.ResourceTags)
			delete(rawMsg, key)
		case "startTask":
			err = unpopulate(val, "StartTask", &u.StartTask)
			delete(rawMsg, key)
		case "targetNodeCommunicationMode":
			err = unpopulate(val, "TargetNodeCommunicationMode", &u.TargetNodeCommunicationMode)
			delete(rawMsg, key)
		case "taskSchedulingPolicy":
			err = unpopulate(val, "TaskSchedulingPolicy", &u.TaskSchedulingPolicy)
			delete(rawMsg, key)
		case "taskSlotsPerNode":
			err = unpopulate(val, "TaskSlotsPerNode", &u.TaskSlotsPerNode)
			delete(rawMsg, key)
		case "upgradePolicy":
			err = unpopulate(val, "UpgradePolicy", &u.UpgradePolicy)
			delete(rawMsg, key)
		case "userAccounts":
			err = unpopulate(val, "UserAccounts", &u.UserAccounts)
			delete(rawMsg, key)
		case "vmSize":
			err = unpopulate(val, "VMSize", &u.VMSize)
			delete(rawMsg, key)
		case "virtualMachineConfiguration":
			err = unpopulate(val, "VirtualMachineConfiguration", &u.VirtualMachineConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpgradePolicy.
func (u UpgradePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "automaticOSUpgradePolicy", u.AutomaticOsUpgradePolicy)
	populate(objectMap, "mode", u.Mode)
	populate(objectMap, "rollingUpgradePolicy", u.RollingUpgradePolicy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpgradePolicy.
func (u *UpgradePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "automaticOSUpgradePolicy":
			err = unpopulate(val, "AutomaticOsUpgradePolicy", &u.AutomaticOsUpgradePolicy)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &u.Mode)
			delete(rawMsg, key)
		case "rollingUpgradePolicy":
			err = unpopulate(val, "RollingUpgradePolicy", &u.RollingUpgradePolicy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UploadNodeLogsContent.
func (u UploadNodeLogsContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerUrl", u.ContainerURL)
	populateDateTimeRFC3339(objectMap, "endTime", u.EndTime)
	populate(objectMap, "identityReference", u.IdentityReference)
	populateDateTimeRFC3339(objectMap, "startTime", u.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UploadNodeLogsContent.
func (u *UploadNodeLogsContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerUrl":
			err = unpopulate(val, "ContainerURL", &u.ContainerURL)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &u.EndTime)
			delete(rawMsg, key)
		case "identityReference":
			err = unpopulate(val, "IdentityReference", &u.IdentityReference)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &u.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UploadNodeLogsResult.
func (u UploadNodeLogsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "numberOfFilesUploaded", u.NumberOfFilesUploaded)
	populate(objectMap, "virtualDirectoryName", u.VirtualDirectoryName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UploadNodeLogsResult.
func (u *UploadNodeLogsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "numberOfFilesUploaded":
			err = unpopulate(val, "NumberOfFilesUploaded", &u.NumberOfFilesUploaded)
			delete(rawMsg, key)
		case "virtualDirectoryName":
			err = unpopulate(val, "VirtualDirectoryName", &u.VirtualDirectoryName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAccount.
func (u UserAccount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "elevationLevel", u.ElevationLevel)
	populate(objectMap, "linuxUserConfiguration", u.LinuxUserConfiguration)
	populate(objectMap, "name", u.Name)
	populate(objectMap, "password", u.Password)
	populate(objectMap, "windowsUserConfiguration", u.WindowsUserConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAccount.
func (u *UserAccount) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "elevationLevel":
			err = unpopulate(val, "ElevationLevel", &u.ElevationLevel)
			delete(rawMsg, key)
		case "linuxUserConfiguration":
			err = unpopulate(val, "LinuxUserConfiguration", &u.LinuxUserConfiguration)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &u.Name)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &u.Password)
			delete(rawMsg, key)
		case "windowsUserConfiguration":
			err = unpopulate(val, "WindowsUserConfiguration", &u.WindowsUserConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAssignedIdentity.
func (u UserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", u.ClientID)
	populate(objectMap, "principalId", u.PrincipalID)
	populate(objectMap, "resourceId", u.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAssignedIdentity.
func (u *UserAssignedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &u.ClientID)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, "PrincipalID", &u.PrincipalID)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &u.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserIdentity.
func (u UserIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoUser", u.AutoUser)
	populate(objectMap, "username", u.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserIdentity.
func (u *UserIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUser":
			err = unpopulate(val, "AutoUser", &u.AutoUser)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &u.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMDiskSecurityProfile.
func (v VMDiskSecurityProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "securityEncryptionType", v.SecurityEncryptionType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMDiskSecurityProfile.
func (v *VMDiskSecurityProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "securityEncryptionType":
			err = unpopulate(val, "SecurityEncryptionType", &v.SecurityEncryptionType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMExtension.
func (v VMExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoUpgradeMinorVersion", v.AutoUpgradeMinorVersion)
	populate(objectMap, "enableAutomaticUpgrade", v.EnableAutomaticUpgrade)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "protectedSettings", v.ProtectedSettings)
	populate(objectMap, "provisionAfterExtensions", v.ProvisionAfterExtensions)
	populate(objectMap, "publisher", v.Publisher)
	populate(objectMap, "settings", v.Settings)
	populate(objectMap, "type", v.Type)
	populate(objectMap, "typeHandlerVersion", v.TypeHandlerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMExtension.
func (v *VMExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUpgradeMinorVersion":
			err = unpopulate(val, "AutoUpgradeMinorVersion", &v.AutoUpgradeMinorVersion)
			delete(rawMsg, key)
		case "enableAutomaticUpgrade":
			err = unpopulate(val, "EnableAutomaticUpgrade", &v.EnableAutomaticUpgrade)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "protectedSettings":
			err = unpopulate(val, "ProtectedSettings", &v.ProtectedSettings)
			delete(rawMsg, key)
		case "provisionAfterExtensions":
			err = unpopulate(val, "ProvisionAfterExtensions", &v.ProvisionAfterExtensions)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &v.Publisher)
			delete(rawMsg, key)
		case "settings":
			err = unpopulate(val, "Settings", &v.Settings)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		case "typeHandlerVersion":
			err = unpopulate(val, "TypeHandlerVersion", &v.TypeHandlerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMExtensionInstanceView.
func (v VMExtensionInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "statuses", v.Statuses)
	populate(objectMap, "subStatuses", v.SubStatuses)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMExtensionInstanceView.
func (v *VMExtensionInstanceView) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "statuses":
			err = unpopulate(val, "Statuses", &v.Statuses)
			delete(rawMsg, key)
		case "subStatuses":
			err = unpopulate(val, "SubStatuses", &v.SubStatuses)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineConfiguration.
func (v VirtualMachineConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerConfiguration", v.ContainerConfiguration)
	populate(objectMap, "dataDisks", v.DataDisks)
	populate(objectMap, "diskEncryptionConfiguration", v.DiskEncryptionConfiguration)
	populate(objectMap, "extensions", v.Extensions)
	populate(objectMap, "imageReference", v.ImageReference)
	populate(objectMap, "licenseType", v.LicenseType)
	populate(objectMap, "nodeAgentSKUId", v.NodeAgentSKUID)
	populate(objectMap, "nodePlacementConfiguration", v.NodePlacementConfiguration)
	populate(objectMap, "osDisk", v.OSDisk)
	populate(objectMap, "securityProfile", v.SecurityProfile)
	populate(objectMap, "serviceArtifactReference", v.ServiceArtifactReference)
	populate(objectMap, "windowsConfiguration", v.WindowsConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineConfiguration.
func (v *VirtualMachineConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerConfiguration":
			err = unpopulate(val, "ContainerConfiguration", &v.ContainerConfiguration)
			delete(rawMsg, key)
		case "dataDisks":
			err = unpopulate(val, "DataDisks", &v.DataDisks)
			delete(rawMsg, key)
		case "diskEncryptionConfiguration":
			err = unpopulate(val, "DiskEncryptionConfiguration", &v.DiskEncryptionConfiguration)
			delete(rawMsg, key)
		case "extensions":
			err = unpopulate(val, "Extensions", &v.Extensions)
			delete(rawMsg, key)
		case "imageReference":
			err = unpopulate(val, "ImageReference", &v.ImageReference)
			delete(rawMsg, key)
		case "licenseType":
			err = unpopulate(val, "LicenseType", &v.LicenseType)
			delete(rawMsg, key)
		case "nodeAgentSKUId":
			err = unpopulate(val, "NodeAgentSKUID", &v.NodeAgentSKUID)
			delete(rawMsg, key)
		case "nodePlacementConfiguration":
			err = unpopulate(val, "NodePlacementConfiguration", &v.NodePlacementConfiguration)
			delete(rawMsg, key)
		case "osDisk":
			err = unpopulate(val, "OSDisk", &v.OSDisk)
			delete(rawMsg, key)
		case "securityProfile":
			err = unpopulate(val, "SecurityProfile", &v.SecurityProfile)
			delete(rawMsg, key)
		case "serviceArtifactReference":
			err = unpopulate(val, "ServiceArtifactReference", &v.ServiceArtifactReference)
			delete(rawMsg, key)
		case "windowsConfiguration":
			err = unpopulate(val, "WindowsConfiguration", &v.WindowsConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineInfo.
func (v VirtualMachineInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "imageReference", v.ImageReference)
	populate(objectMap, "scaleSetVmResourceId", v.ScaleSetVMResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineInfo.
func (v *VirtualMachineInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "imageReference":
			err = unpopulate(val, "ImageReference", &v.ImageReference)
			delete(rawMsg, key)
		case "scaleSetVmResourceId":
			err = unpopulate(val, "ScaleSetVMResourceID", &v.ScaleSetVMResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WindowsConfiguration.
func (w WindowsConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enableAutomaticUpdates", w.EnableAutomaticUpdates)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WindowsConfiguration.
func (w *WindowsConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableAutomaticUpdates":
			err = unpopulate(val, "EnableAutomaticUpdates", &w.EnableAutomaticUpdates)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WindowsUserConfiguration.
func (w WindowsUserConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "loginMode", w.LoginMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WindowsUserConfiguration.
func (w *WindowsUserConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "loginMode":
			err = unpopulate(val, "LoginMode", &w.LoginMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type listPoolUsageMetricsResult.
func (l listPoolUsageMetricsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type listPoolUsageMetricsResult.
func (l *listPoolUsageMetricsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
			err = unpopulate(val, "NextLink", &l.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &l.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type poolUsageMetrics.
func (p poolUsageMetrics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endTime", p.EndTime)
	populate(objectMap, "poolId", p.PoolID)
	populateDateTimeRFC3339(objectMap, "startTime", p.StartTime)
	populate(objectMap, "totalCoreHours", p.TotalCoreHours)
	populate(objectMap, "vmSize", p.VMSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type poolUsageMetrics.
func (p *poolUsageMetrics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &p.EndTime)
			delete(rawMsg, key)
		case "poolId":
			err = unpopulate(val, "PoolID", &p.PoolID)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &p.StartTime)
			delete(rawMsg, key)
		case "totalCoreHours":
			err = unpopulate(val, "TotalCoreHours", &p.TotalCoreHours)
			delete(rawMsg, key)
		case "vmSize":
			err = unpopulate(val, "VMSize", &p.VMSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
