//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package azanomalydetector

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type MultivariateAlignPolicy.
func (m MultivariateAlignPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alignMode", m.AlignMode)
	populate(objectMap, "fillNAMethod", m.FillNAMethod)
	populate(objectMap, "paddingValue", m.PaddingValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateAlignPolicy.
func (m *MultivariateAlignPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alignMode":
			err = unpopulate(val, "AlignMode", &m.AlignMode)
			delete(rawMsg, key)
		case "fillNAMethod":
			err = unpopulate(val, "FillNAMethod", &m.FillNAMethod)
			delete(rawMsg, key)
		case "paddingValue":
			err = unpopulate(val, "PaddingValue", &m.PaddingValue)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateAnomalyDetectionModel.
func (m MultivariateAnomalyDetectionModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "createdTime", m.CreatedTime)
	populateTimeRFC3339(objectMap, "lastUpdatedTime", m.LastUpdatedTime)
	populate(objectMap, "modelId", m.ModelID)
	populate(objectMap, "modelInfo", m.ModelInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateAnomalyDetectionModel.
func (m *MultivariateAnomalyDetectionModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdTime":
			err = unpopulateTimeRFC3339(val, "CreatedTime", &m.CreatedTime)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateTimeRFC3339(val, "LastUpdatedTime", &m.LastUpdatedTime)
			delete(rawMsg, key)
		case "modelId":
			err = unpopulate(val, "ModelID", &m.ModelID)
			delete(rawMsg, key)
		case "modelInfo":
			err = unpopulate(val, "ModelInfo", &m.ModelInfo)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateAnomalyInterpretation.
func (m MultivariateAnomalyInterpretation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contributionScore", m.ContributionScore)
	populate(objectMap, "correlationChanges", m.CorrelationChanges)
	populate(objectMap, "variable", m.Variable)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateAnomalyInterpretation.
func (m *MultivariateAnomalyInterpretation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contributionScore":
			err = unpopulate(val, "ContributionScore", &m.ContributionScore)
			delete(rawMsg, key)
		case "correlationChanges":
			err = unpopulate(val, "CorrelationChanges", &m.CorrelationChanges)
			delete(rawMsg, key)
		case "variable":
			err = unpopulate(val, "Variable", &m.Variable)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateAnomalyState.
func (m MultivariateAnomalyState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errors", m.Errors)
	populateTimeRFC3339(objectMap, "timestamp", m.Timestamp)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateAnomalyState.
func (m *MultivariateAnomalyState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
			err = unpopulate(val, "Errors", &m.Errors)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateTimeRFC3339(val, "Timestamp", &m.Timestamp)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateAnomalyValue.
func (m MultivariateAnomalyValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "interpretation", m.Interpretation)
	populate(objectMap, "isAnomaly", m.IsAnomaly)
	populate(objectMap, "score", m.Score)
	populate(objectMap, "severity", m.Severity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateAnomalyValue.
func (m *MultivariateAnomalyValue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "interpretation":
			err = unpopulate(val, "Interpretation", &m.Interpretation)
			delete(rawMsg, key)
		case "isAnomaly":
			err = unpopulate(val, "IsAnomaly", &m.IsAnomaly)
			delete(rawMsg, key)
		case "score":
			err = unpopulate(val, "Score", &m.Score)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &m.Severity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateBatchDetectionOptions.
func (m MultivariateBatchDetectionOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataSource", m.DataSource)
	populateTimeRFC3339(objectMap, "endTime", m.EndTime)
	populateTimeRFC3339(objectMap, "startTime", m.StartTime)
	populate(objectMap, "topContributorCount", m.TopContributorCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateBatchDetectionOptions.
func (m *MultivariateBatchDetectionOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataSource":
			err = unpopulate(val, "DataSource", &m.DataSource)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, "EndTime", &m.EndTime)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &m.StartTime)
			delete(rawMsg, key)
		case "topContributorCount":
			err = unpopulate(val, "TopContributorCount", &m.TopContributorCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateBatchDetectionResultSummary.
func (m MultivariateBatchDetectionResultSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "setupInfo", m.SetupInfo)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "variableStates", m.VariableStates)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateBatchDetectionResultSummary.
func (m *MultivariateBatchDetectionResultSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
			err = unpopulate(val, "Errors", &m.Errors)
			delete(rawMsg, key)
		case "setupInfo":
			err = unpopulate(val, "SetupInfo", &m.SetupInfo)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &m.Status)
			delete(rawMsg, key)
		case "variableStates":
			err = unpopulate(val, "VariableStates", &m.VariableStates)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateCorrelationChanges.
func (m MultivariateCorrelationChanges) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "changedVariables", m.ChangedVariables)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateCorrelationChanges.
func (m *MultivariateCorrelationChanges) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "changedVariables":
			err = unpopulate(val, "ChangedVariables", &m.ChangedVariables)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateDetectionResult.
func (m MultivariateDetectionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "resultId", m.ResultID)
	populate(objectMap, "results", m.Results)
	populate(objectMap, "summary", m.Summary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateDetectionResult.
func (m *MultivariateDetectionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resultId":
			err = unpopulate(val, "ResultID", &m.ResultID)
			delete(rawMsg, key)
		case "results":
			err = unpopulate(val, "Results", &m.Results)
			delete(rawMsg, key)
		case "summary":
			err = unpopulate(val, "Summary", &m.Summary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateDiagnosticsInfo.
func (m MultivariateDiagnosticsInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "modelState", m.ModelState)
	populate(objectMap, "variableStates", m.VariableStates)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateDiagnosticsInfo.
func (m *MultivariateDiagnosticsInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "modelState":
			err = unpopulate(val, "ModelState", &m.ModelState)
			delete(rawMsg, key)
		case "variableStates":
			err = unpopulate(val, "VariableStates", &m.VariableStates)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateErrorResponse.
func (m MultivariateErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", m.Code)
	populate(objectMap, "message", m.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateErrorResponse.
func (m *MultivariateErrorResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &m.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &m.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateLastDetectionOptions.
func (m MultivariateLastDetectionOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "topContributorCount", m.TopContributorCount)
	populate(objectMap, "variables", m.Variables)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateLastDetectionOptions.
func (m *MultivariateLastDetectionOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "topContributorCount":
			err = unpopulate(val, "TopContributorCount", &m.TopContributorCount)
			delete(rawMsg, key)
		case "variables":
			err = unpopulate(val, "Variables", &m.Variables)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateLastDetectionResult.
func (m MultivariateLastDetectionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "results", m.Results)
	populate(objectMap, "variableStates", m.VariableStates)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateLastDetectionResult.
func (m *MultivariateLastDetectionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "results":
			err = unpopulate(val, "Results", &m.Results)
			delete(rawMsg, key)
		case "variableStates":
			err = unpopulate(val, "VariableStates", &m.VariableStates)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateModelInfo.
func (m MultivariateModelInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alignPolicy", m.AlignPolicy)
	populate(objectMap, "dataSchema", m.DataSchema)
	populate(objectMap, "dataSource", m.DataSource)
	populate(objectMap, "diagnosticsInfo", m.DiagnosticsInfo)
	populate(objectMap, "displayName", m.DisplayName)
	populateTimeRFC3339(objectMap, "endTime", m.EndTime)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "slidingWindow", m.SlidingWindow)
	populateTimeRFC3339(objectMap, "startTime", m.StartTime)
	populate(objectMap, "status", m.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateModelInfo.
func (m *MultivariateModelInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alignPolicy":
			err = unpopulate(val, "AlignPolicy", &m.AlignPolicy)
			delete(rawMsg, key)
		case "dataSchema":
			err = unpopulate(val, "DataSchema", &m.DataSchema)
			delete(rawMsg, key)
		case "dataSource":
			err = unpopulate(val, "DataSource", &m.DataSource)
			delete(rawMsg, key)
		case "diagnosticsInfo":
			err = unpopulate(val, "DiagnosticsInfo", &m.DiagnosticsInfo)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &m.DisplayName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, "EndTime", &m.EndTime)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &m.Errors)
			delete(rawMsg, key)
		case "slidingWindow":
			err = unpopulate(val, "SlidingWindow", &m.SlidingWindow)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &m.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &m.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateModelList.
func (m MultivariateModelList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "currentCount", m.CurrentCount)
	populate(objectMap, "maxCount", m.MaxCount)
	populate(objectMap, "models", m.Models)
	populate(objectMap, "nextLink", m.NextLink)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateModelList.
func (m *MultivariateModelList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentCount":
			err = unpopulate(val, "CurrentCount", &m.CurrentCount)
			delete(rawMsg, key)
		case "maxCount":
			err = unpopulate(val, "MaxCount", &m.MaxCount)
			delete(rawMsg, key)
		case "models":
			err = unpopulate(val, "Models", &m.Models)
			delete(rawMsg, key)
		case "nextLink":
			err = unpopulate(val, "NextLink", &m.NextLink)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateModelState.
func (m MultivariateModelState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "epochIds", m.EpochIDs)
	populate(objectMap, "latenciesInSeconds", m.LatenciesInSeconds)
	populate(objectMap, "trainLosses", m.TrainLosses)
	populate(objectMap, "validationLosses", m.ValidationLosses)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateModelState.
func (m *MultivariateModelState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "epochIds":
			err = unpopulate(val, "EpochIDs", &m.EpochIDs)
			delete(rawMsg, key)
		case "latenciesInSeconds":
			err = unpopulate(val, "LatenciesInSeconds", &m.LatenciesInSeconds)
			delete(rawMsg, key)
		case "trainLosses":
			err = unpopulate(val, "TrainLosses", &m.TrainLosses)
			delete(rawMsg, key)
		case "validationLosses":
			err = unpopulate(val, "ValidationLosses", &m.ValidationLosses)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateResponseError.
func (m MultivariateResponseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", m.Code)
	populate(objectMap, "message", m.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateResponseError.
func (m *MultivariateResponseError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &m.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &m.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateVariableState.
func (m MultivariateVariableState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "effectiveCount", m.EffectiveCount)
	populate(objectMap, "filledNARatio", m.FilledNARatio)
	populateTimeRFC3339(objectMap, "firstTimestamp", m.FirstTimestamp)
	populateTimeRFC3339(objectMap, "lastTimestamp", m.LastTimestamp)
	populate(objectMap, "variable", m.Variable)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateVariableState.
func (m *MultivariateVariableState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "effectiveCount":
			err = unpopulate(val, "EffectiveCount", &m.EffectiveCount)
			delete(rawMsg, key)
		case "filledNARatio":
			err = unpopulate(val, "FilledNARatio", &m.FilledNARatio)
			delete(rawMsg, key)
		case "firstTimestamp":
			err = unpopulateTimeRFC3339(val, "FirstTimestamp", &m.FirstTimestamp)
			delete(rawMsg, key)
		case "lastTimestamp":
			err = unpopulateTimeRFC3339(val, "LastTimestamp", &m.LastTimestamp)
			delete(rawMsg, key)
		case "variable":
			err = unpopulate(val, "Variable", &m.Variable)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultivariateVariableValues.
func (m MultivariateVariableValues) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "timestamps", m.Timestamps)
	populate(objectMap, "values", m.Values)
	populate(objectMap, "variable", m.Variable)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultivariateVariableValues.
func (m *MultivariateVariableValues) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "timestamps":
			err = unpopulate(val, "Timestamps", &m.Timestamps)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &m.Values)
			delete(rawMsg, key)
		case "variable":
			err = unpopulate(val, "Variable", &m.Variable)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UnivariateAnomalyDetectorError.
func (u UnivariateAnomalyDetectorError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", u.Code)
	populate(objectMap, "message", u.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UnivariateAnomalyDetectorError.
func (u *UnivariateAnomalyDetectorError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &u.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &u.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UnivariateChangePointDetectionOptions.
func (u UnivariateChangePointDetectionOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customInterval", u.CustomInterval)
	populate(objectMap, "granularity", u.Granularity)
	populate(objectMap, "period", u.Period)
	populate(objectMap, "series", u.Series)
	populate(objectMap, "stableTrendWindow", u.StableTrendWindow)
	populate(objectMap, "threshold", u.Threshold)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UnivariateChangePointDetectionOptions.
func (u *UnivariateChangePointDetectionOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customInterval":
			err = unpopulate(val, "CustomInterval", &u.CustomInterval)
			delete(rawMsg, key)
		case "granularity":
			err = unpopulate(val, "Granularity", &u.Granularity)
			delete(rawMsg, key)
		case "period":
			err = unpopulate(val, "Period", &u.Period)
			delete(rawMsg, key)
		case "series":
			err = unpopulate(val, "Series", &u.Series)
			delete(rawMsg, key)
		case "stableTrendWindow":
			err = unpopulate(val, "StableTrendWindow", &u.StableTrendWindow)
			delete(rawMsg, key)
		case "threshold":
			err = unpopulate(val, "Threshold", &u.Threshold)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UnivariateChangePointDetectionResult.
func (u UnivariateChangePointDetectionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "confidenceScores", u.ConfidenceScores)
	populate(objectMap, "isChangePoint", u.IsChangePoint)
	populate(objectMap, "period", u.Period)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UnivariateChangePointDetectionResult.
func (u *UnivariateChangePointDetectionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "confidenceScores":
			err = unpopulate(val, "ConfidenceScores", &u.ConfidenceScores)
			delete(rawMsg, key)
		case "isChangePoint":
			err = unpopulate(val, "IsChangePoint", &u.IsChangePoint)
			delete(rawMsg, key)
		case "period":
			err = unpopulate(val, "Period", &u.Period)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UnivariateDetectionOptions.
func (u UnivariateDetectionOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customInterval", u.CustomInterval)
	populate(objectMap, "granularity", u.Granularity)
	populate(objectMap, "imputeFixedValue", u.ImputeFixedValue)
	populate(objectMap, "imputeMode", u.ImputeMode)
	populate(objectMap, "maxAnomalyRatio", u.MaxAnomalyRatio)
	populate(objectMap, "period", u.Period)
	populate(objectMap, "sensitivity", u.Sensitivity)
	populate(objectMap, "series", u.Series)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UnivariateDetectionOptions.
func (u *UnivariateDetectionOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customInterval":
			err = unpopulate(val, "CustomInterval", &u.CustomInterval)
			delete(rawMsg, key)
		case "granularity":
			err = unpopulate(val, "Granularity", &u.Granularity)
			delete(rawMsg, key)
		case "imputeFixedValue":
			err = unpopulate(val, "ImputeFixedValue", &u.ImputeFixedValue)
			delete(rawMsg, key)
		case "imputeMode":
			err = unpopulate(val, "ImputeMode", &u.ImputeMode)
			delete(rawMsg, key)
		case "maxAnomalyRatio":
			err = unpopulate(val, "MaxAnomalyRatio", &u.MaxAnomalyRatio)
			delete(rawMsg, key)
		case "period":
			err = unpopulate(val, "Period", &u.Period)
			delete(rawMsg, key)
		case "sensitivity":
			err = unpopulate(val, "Sensitivity", &u.Sensitivity)
			delete(rawMsg, key)
		case "series":
			err = unpopulate(val, "Series", &u.Series)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UnivariateEntireDetectionResult.
func (u UnivariateEntireDetectionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expectedValues", u.ExpectedValues)
	populate(objectMap, "isAnomaly", u.IsAnomaly)
	populate(objectMap, "isNegativeAnomaly", u.IsNegativeAnomaly)
	populate(objectMap, "isPositiveAnomaly", u.IsPositiveAnomaly)
	populate(objectMap, "lowerMargins", u.LowerMargins)
	populate(objectMap, "period", u.Period)
	populate(objectMap, "severity", u.Severity)
	populate(objectMap, "upperMargins", u.UpperMargins)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UnivariateEntireDetectionResult.
func (u *UnivariateEntireDetectionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expectedValues":
			err = unpopulate(val, "ExpectedValues", &u.ExpectedValues)
			delete(rawMsg, key)
		case "isAnomaly":
			err = unpopulate(val, "IsAnomaly", &u.IsAnomaly)
			delete(rawMsg, key)
		case "isNegativeAnomaly":
			err = unpopulate(val, "IsNegativeAnomaly", &u.IsNegativeAnomaly)
			delete(rawMsg, key)
		case "isPositiveAnomaly":
			err = unpopulate(val, "IsPositiveAnomaly", &u.IsPositiveAnomaly)
			delete(rawMsg, key)
		case "lowerMargins":
			err = unpopulate(val, "LowerMargins", &u.LowerMargins)
			delete(rawMsg, key)
		case "period":
			err = unpopulate(val, "Period", &u.Period)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &u.Severity)
			delete(rawMsg, key)
		case "upperMargins":
			err = unpopulate(val, "UpperMargins", &u.UpperMargins)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UnivariateLastDetectionResult.
func (u UnivariateLastDetectionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expectedValue", u.ExpectedValue)
	populate(objectMap, "isAnomaly", u.IsAnomaly)
	populate(objectMap, "isNegativeAnomaly", u.IsNegativeAnomaly)
	populate(objectMap, "isPositiveAnomaly", u.IsPositiveAnomaly)
	populate(objectMap, "lowerMargin", u.LowerMargin)
	populate(objectMap, "period", u.Period)
	populate(objectMap, "severity", u.Severity)
	populate(objectMap, "suggestedWindow", u.SuggestedWindow)
	populate(objectMap, "upperMargin", u.UpperMargin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UnivariateLastDetectionResult.
func (u *UnivariateLastDetectionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expectedValue":
			err = unpopulate(val, "ExpectedValue", &u.ExpectedValue)
			delete(rawMsg, key)
		case "isAnomaly":
			err = unpopulate(val, "IsAnomaly", &u.IsAnomaly)
			delete(rawMsg, key)
		case "isNegativeAnomaly":
			err = unpopulate(val, "IsNegativeAnomaly", &u.IsNegativeAnomaly)
			delete(rawMsg, key)
		case "isPositiveAnomaly":
			err = unpopulate(val, "IsPositiveAnomaly", &u.IsPositiveAnomaly)
			delete(rawMsg, key)
		case "lowerMargin":
			err = unpopulate(val, "LowerMargin", &u.LowerMargin)
			delete(rawMsg, key)
		case "period":
			err = unpopulate(val, "Period", &u.Period)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &u.Severity)
			delete(rawMsg, key)
		case "suggestedWindow":
			err = unpopulate(val, "SuggestedWindow", &u.SuggestedWindow)
			delete(rawMsg, key)
		case "upperMargin":
			err = unpopulate(val, "UpperMargin", &u.UpperMargin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UnivariateTimeSeriesPoint.
func (u UnivariateTimeSeriesPoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "timestamp", u.Timestamp)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UnivariateTimeSeriesPoint.
func (u *UnivariateTimeSeriesPoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "timestamp":
			err = unpopulateTimeRFC3339(val, "Timestamp", &u.Timestamp)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &u.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
