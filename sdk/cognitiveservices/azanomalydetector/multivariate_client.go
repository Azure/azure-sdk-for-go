//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package azanomalydetector

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// MultivariateClient contains the methods for the Multivariate group.
// Don't use this type directly, use a constructor function instead.
type MultivariateClient struct {
	internal *azcore.Client
	endpoint string
}

// DeleteMultivariateModel - Delete an existing multivariate model according to the modelId value.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version v1.1
//   - modelID - Model identifier.
//   - options - MultivariateClientDeleteMultivariateModelOptions contains the optional parameters for the MultivariateClient.DeleteMultivariateModel
//     method.
func (client *MultivariateClient) DeleteMultivariateModel(ctx context.Context, modelID string, options *MultivariateClientDeleteMultivariateModelOptions) (MultivariateClientDeleteMultivariateModelResponse, error) {
	req, err := client.deleteMultivariateModelCreateRequest(ctx, modelID, options)
	if err != nil {
		return MultivariateClientDeleteMultivariateModelResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultivariateClientDeleteMultivariateModelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return MultivariateClientDeleteMultivariateModelResponse{}, runtime.NewResponseError(resp)
	}
	return MultivariateClientDeleteMultivariateModelResponse{}, nil
}

// deleteMultivariateModelCreateRequest creates the DeleteMultivariateModel request.
func (client *MultivariateClient) deleteMultivariateModelCreateRequest(ctx context.Context, modelID string, options *MultivariateClientDeleteMultivariateModelOptions) (*policy.Request, error) {
	urlPath := "/multivariate/models/{modelId}"
	if modelID == "" {
		return nil, errors.New("parameter modelID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{modelId}", url.PathEscape(modelID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DetectMultivariateBatchAnomaly - Submit a multivariate anomaly detection task with the modelId value of a trained model
// and inference data. The input schema should be the same with the training request. The request will finish
// asynchronously and return a resultId value to query the detection result. The request should be a source link to indicate
// an externally accessible Azure Storage URI that either points to an Azure Blob
// Storage folder or points to a CSV file in Azure Blob Storage.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version v1.1
//   - modelID - Model identifier.
//   - body - Request of multivariate anomaly detection.
//   - options - MultivariateClientDetectMultivariateBatchAnomalyOptions contains the optional parameters for the MultivariateClient.DetectMultivariateBatchAnomaly
//     method.
func (client *MultivariateClient) DetectMultivariateBatchAnomaly(ctx context.Context, modelID string, body MultivariateBatchDetectionOptions, options *MultivariateClientDetectMultivariateBatchAnomalyOptions) (MultivariateClientDetectMultivariateBatchAnomalyResponse, error) {
	req, err := client.detectMultivariateBatchAnomalyCreateRequest(ctx, modelID, body, options)
	if err != nil {
		return MultivariateClientDetectMultivariateBatchAnomalyResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultivariateClientDetectMultivariateBatchAnomalyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return MultivariateClientDetectMultivariateBatchAnomalyResponse{}, runtime.NewResponseError(resp)
	}
	return client.detectMultivariateBatchAnomalyHandleResponse(resp)
}

// detectMultivariateBatchAnomalyCreateRequest creates the DetectMultivariateBatchAnomaly request.
func (client *MultivariateClient) detectMultivariateBatchAnomalyCreateRequest(ctx context.Context, modelID string, body MultivariateBatchDetectionOptions, options *MultivariateClientDetectMultivariateBatchAnomalyOptions) (*policy.Request, error) {
	urlPath := "/multivariate/models/{modelId}:detect-batch"
	if modelID == "" {
		return nil, errors.New("parameter modelID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{modelId}", url.PathEscape(modelID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// detectMultivariateBatchAnomalyHandleResponse handles the DetectMultivariateBatchAnomaly response.
func (client *MultivariateClient) detectMultivariateBatchAnomalyHandleResponse(resp *http.Response) (MultivariateClientDetectMultivariateBatchAnomalyResponse, error) {
	result := MultivariateClientDetectMultivariateBatchAnomalyResponse{}
	if val := resp.Header.Get("operation-id"); val != "" {
		result.OperationID = &val
	}
	if val := resp.Header.Get("operation-location"); val != "" {
		result.OperationLocation = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.MultivariateDetectionResult); err != nil {
		return MultivariateClientDetectMultivariateBatchAnomalyResponse{}, err
	}
	return result, nil
}

// DetectMultivariateLastAnomaly - Submit a multivariate anomaly detection task with the modelId value of a trained model
// and inference data. The inference data should be put into the request body in JSON format. The request will
// finish synchronously and return the detection immediately in the response body.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version v1.1
//   - modelID - Model identifier.
//   - body - Request of the last detection.
//   - options - MultivariateClientDetectMultivariateLastAnomalyOptions contains the optional parameters for the MultivariateClient.DetectMultivariateLastAnomaly
//     method.
func (client *MultivariateClient) DetectMultivariateLastAnomaly(ctx context.Context, modelID string, body MultivariateLastDetectionOptions, options *MultivariateClientDetectMultivariateLastAnomalyOptions) (MultivariateClientDetectMultivariateLastAnomalyResponse, error) {
	req, err := client.detectMultivariateLastAnomalyCreateRequest(ctx, modelID, body, options)
	if err != nil {
		return MultivariateClientDetectMultivariateLastAnomalyResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultivariateClientDetectMultivariateLastAnomalyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return MultivariateClientDetectMultivariateLastAnomalyResponse{}, runtime.NewResponseError(resp)
	}
	return client.detectMultivariateLastAnomalyHandleResponse(resp)
}

// detectMultivariateLastAnomalyCreateRequest creates the DetectMultivariateLastAnomaly request.
func (client *MultivariateClient) detectMultivariateLastAnomalyCreateRequest(ctx context.Context, modelID string, body MultivariateLastDetectionOptions, options *MultivariateClientDetectMultivariateLastAnomalyOptions) (*policy.Request, error) {
	urlPath := "/multivariate/models/{modelId}:detect-last"
	if modelID == "" {
		return nil, errors.New("parameter modelID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{modelId}", url.PathEscape(modelID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// detectMultivariateLastAnomalyHandleResponse handles the DetectMultivariateLastAnomaly response.
func (client *MultivariateClient) detectMultivariateLastAnomalyHandleResponse(resp *http.Response) (MultivariateClientDetectMultivariateLastAnomalyResponse, error) {
	result := MultivariateClientDetectMultivariateLastAnomalyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MultivariateLastDetectionResult); err != nil {
		return MultivariateClientDetectMultivariateLastAnomalyResponse{}, err
	}
	return result, nil
}

// GetMultivariateBatchDetectionResult - For asynchronous inference, get a multivariate anomaly detection result based on
// the resultId value that the BatchDetectAnomaly API returns.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version v1.1
//   - resultID - ID of a batch detection result.
//   - options - MultivariateClientGetMultivariateBatchDetectionResultOptions contains the optional parameters for the MultivariateClient.GetMultivariateBatchDetectionResult
//     method.
func (client *MultivariateClient) GetMultivariateBatchDetectionResult(ctx context.Context, resultID string, options *MultivariateClientGetMultivariateBatchDetectionResultOptions) (MultivariateClientGetMultivariateBatchDetectionResultResponse, error) {
	req, err := client.getMultivariateBatchDetectionResultCreateRequest(ctx, resultID, options)
	if err != nil {
		return MultivariateClientGetMultivariateBatchDetectionResultResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultivariateClientGetMultivariateBatchDetectionResultResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return MultivariateClientGetMultivariateBatchDetectionResultResponse{}, runtime.NewResponseError(resp)
	}
	return client.getMultivariateBatchDetectionResultHandleResponse(resp)
}

// getMultivariateBatchDetectionResultCreateRequest creates the GetMultivariateBatchDetectionResult request.
func (client *MultivariateClient) getMultivariateBatchDetectionResultCreateRequest(ctx context.Context, resultID string, options *MultivariateClientGetMultivariateBatchDetectionResultOptions) (*policy.Request, error) {
	urlPath := "/multivariate/detect-batch/{resultId}"
	urlPath = strings.ReplaceAll(urlPath, "{resultId}", url.PathEscape(resultID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMultivariateBatchDetectionResultHandleResponse handles the GetMultivariateBatchDetectionResult response.
func (client *MultivariateClient) getMultivariateBatchDetectionResultHandleResponse(resp *http.Response) (MultivariateClientGetMultivariateBatchDetectionResultResponse, error) {
	result := MultivariateClientGetMultivariateBatchDetectionResultResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MultivariateDetectionResult); err != nil {
		return MultivariateClientGetMultivariateBatchDetectionResultResponse{}, err
	}
	return result, nil
}

// GetMultivariateModel - Get detailed information about the multivariate model, including the training status and variables
// used in the model.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version v1.1
//   - modelID - Model identifier.
//   - options - MultivariateClientGetMultivariateModelOptions contains the optional parameters for the MultivariateClient.GetMultivariateModel
//     method.
func (client *MultivariateClient) GetMultivariateModel(ctx context.Context, modelID string, options *MultivariateClientGetMultivariateModelOptions) (MultivariateClientGetMultivariateModelResponse, error) {
	req, err := client.getMultivariateModelCreateRequest(ctx, modelID, options)
	if err != nil {
		return MultivariateClientGetMultivariateModelResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultivariateClientGetMultivariateModelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return MultivariateClientGetMultivariateModelResponse{}, runtime.NewResponseError(resp)
	}
	return client.getMultivariateModelHandleResponse(resp)
}

// getMultivariateModelCreateRequest creates the GetMultivariateModel request.
func (client *MultivariateClient) getMultivariateModelCreateRequest(ctx context.Context, modelID string, options *MultivariateClientGetMultivariateModelOptions) (*policy.Request, error) {
	urlPath := "/multivariate/models/{modelId}"
	if modelID == "" {
		return nil, errors.New("parameter modelID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{modelId}", url.PathEscape(modelID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMultivariateModelHandleResponse handles the GetMultivariateModel response.
func (client *MultivariateClient) getMultivariateModelHandleResponse(resp *http.Response) (MultivariateClientGetMultivariateModelResponse, error) {
	result := MultivariateClientGetMultivariateModelResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MultivariateAnomalyDetectionModel); err != nil {
		return MultivariateClientGetMultivariateModelResponse{}, err
	}
	return result, nil
}

// NewListMultivariateModelsPager - List models of a resource.
//
// Generated from API version v1.1
//   - options - MultivariateClientListMultivariateModelsOptions contains the optional parameters for the MultivariateClient.NewListMultivariateModelsPager
//     method.
func (client *MultivariateClient) NewListMultivariateModelsPager(options *MultivariateClientListMultivariateModelsOptions) *runtime.Pager[MultivariateClientListMultivariateModelsResponse] {
	return runtime.NewPager(runtime.PagingHandler[MultivariateClientListMultivariateModelsResponse]{
		More: func(page MultivariateClientListMultivariateModelsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *MultivariateClientListMultivariateModelsResponse) (MultivariateClientListMultivariateModelsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listMultivariateModelsCreateRequest(ctx, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return MultivariateClientListMultivariateModelsResponse{}, err
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return MultivariateClientListMultivariateModelsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return MultivariateClientListMultivariateModelsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listMultivariateModelsHandleResponse(resp)
		},
	})
}

// listMultivariateModelsCreateRequest creates the ListMultivariateModels request.
func (client *MultivariateClient) listMultivariateModelsCreateRequest(ctx context.Context, options *MultivariateClientListMultivariateModelsOptions) (*policy.Request, error) {
	urlPath := "/multivariate/models"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Skip != nil {
		reqQP.Set("skip", strconv.FormatInt(int64(*options.Skip), 10))
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listMultivariateModelsHandleResponse handles the ListMultivariateModels response.
func (client *MultivariateClient) listMultivariateModelsHandleResponse(resp *http.Response) (MultivariateClientListMultivariateModelsResponse, error) {
	result := MultivariateClientListMultivariateModelsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MultivariateModelList); err != nil {
		return MultivariateClientListMultivariateModelsResponse{}, err
	}
	return result, nil
}

// TrainMultivariateModel - Create and train a multivariate anomaly detection model. The request must include a source parameter
// to indicate an Azure Blob Storage URI that's accessible to the service. There are two types of data
// input. The Blob Storage URI can point to an Azure Blob Storage folder that contains multiple CSV files, where each CSV
// file has two columns, time stamp and variable. Or the Blob Storage URI can point
// to a single blob that contains a CSV file that has all the variables and a time stamp column.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version v1.1
//   - modelInfo - Model information.
//   - options - MultivariateClientTrainMultivariateModelOptions contains the optional parameters for the MultivariateClient.TrainMultivariateModel
//     method.
func (client *MultivariateClient) TrainMultivariateModel(ctx context.Context, modelInfo MultivariateModelInfo, options *MultivariateClientTrainMultivariateModelOptions) (MultivariateClientTrainMultivariateModelResponse, error) {
	req, err := client.trainMultivariateModelCreateRequest(ctx, modelInfo, options)
	if err != nil {
		return MultivariateClientTrainMultivariateModelResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultivariateClientTrainMultivariateModelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return MultivariateClientTrainMultivariateModelResponse{}, runtime.NewResponseError(resp)
	}
	return client.trainMultivariateModelHandleResponse(resp)
}

// trainMultivariateModelCreateRequest creates the TrainMultivariateModel request.
func (client *MultivariateClient) trainMultivariateModelCreateRequest(ctx context.Context, modelInfo MultivariateModelInfo, options *MultivariateClientTrainMultivariateModelOptions) (*policy.Request, error) {
	urlPath := "/multivariate/models"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, modelInfo)
}

// trainMultivariateModelHandleResponse handles the TrainMultivariateModel response.
func (client *MultivariateClient) trainMultivariateModelHandleResponse(resp *http.Response) (MultivariateClientTrainMultivariateModelResponse, error) {
	result := MultivariateClientTrainMultivariateModelResponse{}
	if val := resp.Header.Get("location"); val != "" {
		result.Location = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.MultivariateAnomalyDetectionModel); err != nil {
		return MultivariateClientTrainMultivariateModelResponse{}, err
	}
	return result, nil
}
