// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// AccessURIPoller provides polling facilities until the operation reaches a terminal state.
type AccessURIPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AccessURIResponse will be returned.
	FinalResponse(ctx context.Context) (AccessURIResponse, error)
}

type accessURIPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *accessURIPoller) Done() bool {
	return p.pt.Done()
}

func (p *accessURIPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *accessURIPoller) FinalResponse(ctx context.Context) (AccessURIResponse, error) {
	respType := AccessURIResponse{AccessURI: &AccessURI{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.AccessURI)
	if err != nil {
		return AccessURIResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *accessURIPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *accessURIPoller) pollUntilDone(ctx context.Context, freq time.Duration) (AccessURIResponse, error) {
	respType := AccessURIResponse{AccessURI: &AccessURI{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.AccessURI)
	if err != nil {
		return AccessURIResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CloudServicePoller provides polling facilities until the operation reaches a terminal state.
type CloudServicePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CloudServiceResponse will be returned.
	FinalResponse(ctx context.Context) (CloudServiceResponse, error)
}

type cloudServicePoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *cloudServicePoller) Done() bool {
	return p.pt.Done()
}

func (p *cloudServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *cloudServicePoller) FinalResponse(ctx context.Context) (CloudServiceResponse, error) {
	respType := CloudServiceResponse{CloudService: &CloudService{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.CloudService)
	if err != nil {
		return CloudServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *cloudServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *cloudServicePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CloudServiceResponse, error) {
	respType := CloudServiceResponse{CloudService: &CloudService{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.CloudService)
	if err != nil {
		return CloudServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DedicatedHostPoller provides polling facilities until the operation reaches a terminal state.
type DedicatedHostPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DedicatedHostResponse will be returned.
	FinalResponse(ctx context.Context) (DedicatedHostResponse, error)
}

type dedicatedHostPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *dedicatedHostPoller) Done() bool {
	return p.pt.Done()
}

func (p *dedicatedHostPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *dedicatedHostPoller) FinalResponse(ctx context.Context) (DedicatedHostResponse, error) {
	respType := DedicatedHostResponse{DedicatedHost: &DedicatedHost{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.DedicatedHost)
	if err != nil {
		return DedicatedHostResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *dedicatedHostPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *dedicatedHostPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DedicatedHostResponse, error) {
	respType := DedicatedHostResponse{DedicatedHost: &DedicatedHost{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.DedicatedHost)
	if err != nil {
		return DedicatedHostResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DiskAccessPoller provides polling facilities until the operation reaches a terminal state.
type DiskAccessPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DiskAccessResponse will be returned.
	FinalResponse(ctx context.Context) (DiskAccessResponse, error)
}

type diskAccessPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *diskAccessPoller) Done() bool {
	return p.pt.Done()
}

func (p *diskAccessPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *diskAccessPoller) FinalResponse(ctx context.Context) (DiskAccessResponse, error) {
	respType := DiskAccessResponse{DiskAccess: &DiskAccess{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.DiskAccess)
	if err != nil {
		return DiskAccessResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *diskAccessPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *diskAccessPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DiskAccessResponse, error) {
	respType := DiskAccessResponse{DiskAccess: &DiskAccess{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.DiskAccess)
	if err != nil {
		return DiskAccessResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DiskEncryptionSetPoller provides polling facilities until the operation reaches a terminal state.
type DiskEncryptionSetPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DiskEncryptionSetResponse will be returned.
	FinalResponse(ctx context.Context) (DiskEncryptionSetResponse, error)
}

type diskEncryptionSetPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *diskEncryptionSetPoller) Done() bool {
	return p.pt.Done()
}

func (p *diskEncryptionSetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *diskEncryptionSetPoller) FinalResponse(ctx context.Context) (DiskEncryptionSetResponse, error) {
	respType := DiskEncryptionSetResponse{DiskEncryptionSet: &DiskEncryptionSet{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.DiskEncryptionSet)
	if err != nil {
		return DiskEncryptionSetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *diskEncryptionSetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *diskEncryptionSetPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DiskEncryptionSetResponse, error) {
	respType := DiskEncryptionSetResponse{DiskEncryptionSet: &DiskEncryptionSet{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.DiskEncryptionSet)
	if err != nil {
		return DiskEncryptionSetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DiskPoller provides polling facilities until the operation reaches a terminal state.
type DiskPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DiskResponse will be returned.
	FinalResponse(ctx context.Context) (DiskResponse, error)
}

type diskPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *diskPoller) Done() bool {
	return p.pt.Done()
}

func (p *diskPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *diskPoller) FinalResponse(ctx context.Context) (DiskResponse, error) {
	respType := DiskResponse{Disk: &Disk{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.Disk)
	if err != nil {
		return DiskResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *diskPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *diskPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DiskResponse, error) {
	respType := DiskResponse{Disk: &Disk{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.Disk)
	if err != nil {
		return DiskResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GalleryApplicationPoller provides polling facilities until the operation reaches a terminal state.
type GalleryApplicationPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GalleryApplicationResponse will be returned.
	FinalResponse(ctx context.Context) (GalleryApplicationResponse, error)
}

type galleryApplicationPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *galleryApplicationPoller) Done() bool {
	return p.pt.Done()
}

func (p *galleryApplicationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *galleryApplicationPoller) FinalResponse(ctx context.Context) (GalleryApplicationResponse, error) {
	respType := GalleryApplicationResponse{GalleryApplication: &GalleryApplication{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.GalleryApplication)
	if err != nil {
		return GalleryApplicationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *galleryApplicationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *galleryApplicationPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationResponse, error) {
	respType := GalleryApplicationResponse{GalleryApplication: &GalleryApplication{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.GalleryApplication)
	if err != nil {
		return GalleryApplicationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GalleryApplicationVersionPoller provides polling facilities until the operation reaches a terminal state.
type GalleryApplicationVersionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GalleryApplicationVersionResponse will be returned.
	FinalResponse(ctx context.Context) (GalleryApplicationVersionResponse, error)
}

type galleryApplicationVersionPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *galleryApplicationVersionPoller) Done() bool {
	return p.pt.Done()
}

func (p *galleryApplicationVersionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *galleryApplicationVersionPoller) FinalResponse(ctx context.Context) (GalleryApplicationVersionResponse, error) {
	respType := GalleryApplicationVersionResponse{GalleryApplicationVersion: &GalleryApplicationVersion{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.GalleryApplicationVersion)
	if err != nil {
		return GalleryApplicationVersionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *galleryApplicationVersionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *galleryApplicationVersionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationVersionResponse, error) {
	respType := GalleryApplicationVersionResponse{GalleryApplicationVersion: &GalleryApplicationVersion{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.GalleryApplicationVersion)
	if err != nil {
		return GalleryApplicationVersionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GalleryImagePoller provides polling facilities until the operation reaches a terminal state.
type GalleryImagePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GalleryImageResponse will be returned.
	FinalResponse(ctx context.Context) (GalleryImageResponse, error)
}

type galleryImagePoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *galleryImagePoller) Done() bool {
	return p.pt.Done()
}

func (p *galleryImagePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *galleryImagePoller) FinalResponse(ctx context.Context) (GalleryImageResponse, error) {
	respType := GalleryImageResponse{GalleryImage: &GalleryImage{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.GalleryImage)
	if err != nil {
		return GalleryImageResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *galleryImagePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *galleryImagePoller) pollUntilDone(ctx context.Context, freq time.Duration) (GalleryImageResponse, error) {
	respType := GalleryImageResponse{GalleryImage: &GalleryImage{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.GalleryImage)
	if err != nil {
		return GalleryImageResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GalleryImageVersionPoller provides polling facilities until the operation reaches a terminal state.
type GalleryImageVersionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GalleryImageVersionResponse will be returned.
	FinalResponse(ctx context.Context) (GalleryImageVersionResponse, error)
}

type galleryImageVersionPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *galleryImageVersionPoller) Done() bool {
	return p.pt.Done()
}

func (p *galleryImageVersionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *galleryImageVersionPoller) FinalResponse(ctx context.Context) (GalleryImageVersionResponse, error) {
	respType := GalleryImageVersionResponse{GalleryImageVersion: &GalleryImageVersion{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.GalleryImageVersion)
	if err != nil {
		return GalleryImageVersionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *galleryImageVersionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *galleryImageVersionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GalleryImageVersionResponse, error) {
	respType := GalleryImageVersionResponse{GalleryImageVersion: &GalleryImageVersion{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.GalleryImageVersion)
	if err != nil {
		return GalleryImageVersionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GalleryPoller provides polling facilities until the operation reaches a terminal state.
type GalleryPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GalleryResponse will be returned.
	FinalResponse(ctx context.Context) (GalleryResponse, error)
}

type galleryPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *galleryPoller) Done() bool {
	return p.pt.Done()
}

func (p *galleryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *galleryPoller) FinalResponse(ctx context.Context) (GalleryResponse, error) {
	respType := GalleryResponse{Gallery: &Gallery{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.Gallery)
	if err != nil {
		return GalleryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *galleryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *galleryPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GalleryResponse, error) {
	respType := GalleryResponse{Gallery: &Gallery{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.Gallery)
	if err != nil {
		return GalleryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// HTTPPoller provides polling facilities until the operation reaches a terminal state.
type HTTPPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final *http.Response will be returned.
	FinalResponse(ctx context.Context) (*http.Response, error)
}

type httpPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *httpPoller) Done() bool {
	return p.pt.Done()
}

func (p *httpPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *httpPoller) FinalResponse(ctx context.Context) (*http.Response, error) {
	return p.pt.FinalResponse(ctx, p.pipeline, nil)
}

func (p *httpPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *httpPoller) pollUntilDone(ctx context.Context, freq time.Duration) (*http.Response, error) {
	return p.pt.PollUntilDone(ctx, freq, p.pipeline, nil)
}

// ImagePoller provides polling facilities until the operation reaches a terminal state.
type ImagePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ImageResponse will be returned.
	FinalResponse(ctx context.Context) (ImageResponse, error)
}

type imagePoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *imagePoller) Done() bool {
	return p.pt.Done()
}

func (p *imagePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *imagePoller) FinalResponse(ctx context.Context) (ImageResponse, error) {
	respType := ImageResponse{Image: &Image{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.Image)
	if err != nil {
		return ImageResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *imagePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *imagePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ImageResponse, error) {
	respType := ImageResponse{Image: &Image{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.Image)
	if err != nil {
		return ImageResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LogAnalyticsOperationResultPoller provides polling facilities until the operation reaches a terminal state.
type LogAnalyticsOperationResultPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LogAnalyticsOperationResultResponse will be returned.
	FinalResponse(ctx context.Context) (LogAnalyticsOperationResultResponse, error)
}

type logAnalyticsOperationResultPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *logAnalyticsOperationResultPoller) Done() bool {
	return p.pt.Done()
}

func (p *logAnalyticsOperationResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *logAnalyticsOperationResultPoller) FinalResponse(ctx context.Context) (LogAnalyticsOperationResultResponse, error) {
	respType := LogAnalyticsOperationResultResponse{LogAnalyticsOperationResult: &LogAnalyticsOperationResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.LogAnalyticsOperationResult)
	if err != nil {
		return LogAnalyticsOperationResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *logAnalyticsOperationResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *logAnalyticsOperationResultPoller) pollUntilDone(ctx context.Context, freq time.Duration) (LogAnalyticsOperationResultResponse, error) {
	respType := LogAnalyticsOperationResultResponse{LogAnalyticsOperationResult: &LogAnalyticsOperationResult{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.LogAnalyticsOperationResult)
	if err != nil {
		return LogAnalyticsOperationResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateEndpointConnectionPoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateEndpointConnectionResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateEndpointConnectionResponse, error)
}

type privateEndpointConnectionPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *privateEndpointConnectionPoller) Done() bool {
	return p.pt.Done()
}

func (p *privateEndpointConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *privateEndpointConnectionPoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionResponse, error) {
	respType := PrivateEndpointConnectionResponse{PrivateEndpointConnection: &PrivateEndpointConnection{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateEndpointConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateEndpointConnectionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionResponse, error) {
	respType := PrivateEndpointConnectionResponse{PrivateEndpointConnection: &PrivateEndpointConnection{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RestorePointPoller provides polling facilities until the operation reaches a terminal state.
type RestorePointPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RestorePointResponse will be returned.
	FinalResponse(ctx context.Context) (RestorePointResponse, error)
}

type restorePointPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *restorePointPoller) Done() bool {
	return p.pt.Done()
}

func (p *restorePointPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *restorePointPoller) FinalResponse(ctx context.Context) (RestorePointResponse, error) {
	respType := RestorePointResponse{RestorePoint: &RestorePoint{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.RestorePoint)
	if err != nil {
		return RestorePointResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *restorePointPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *restorePointPoller) pollUntilDone(ctx context.Context, freq time.Duration) (RestorePointResponse, error) {
	respType := RestorePointResponse{RestorePoint: &RestorePoint{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.RestorePoint)
	if err != nil {
		return RestorePointResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RunCommandResultPoller provides polling facilities until the operation reaches a terminal state.
type RunCommandResultPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RunCommandResultResponse will be returned.
	FinalResponse(ctx context.Context) (RunCommandResultResponse, error)
}

type runCommandResultPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *runCommandResultPoller) Done() bool {
	return p.pt.Done()
}

func (p *runCommandResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *runCommandResultPoller) FinalResponse(ctx context.Context) (RunCommandResultResponse, error) {
	respType := RunCommandResultResponse{RunCommandResult: &RunCommandResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.RunCommandResult)
	if err != nil {
		return RunCommandResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *runCommandResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *runCommandResultPoller) pollUntilDone(ctx context.Context, freq time.Duration) (RunCommandResultResponse, error) {
	respType := RunCommandResultResponse{RunCommandResult: &RunCommandResult{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.RunCommandResult)
	if err != nil {
		return RunCommandResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SharingUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SharingUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SharingUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SharingUpdateResponse, error)
}

type sharingUpdatePoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *sharingUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *sharingUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *sharingUpdatePoller) FinalResponse(ctx context.Context) (SharingUpdateResponse, error) {
	respType := SharingUpdateResponse{SharingUpdate: &SharingUpdate{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.SharingUpdate)
	if err != nil {
		return SharingUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sharingUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sharingUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SharingUpdateResponse, error) {
	respType := SharingUpdateResponse{SharingUpdate: &SharingUpdate{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.SharingUpdate)
	if err != nil {
		return SharingUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SnapshotPoller provides polling facilities until the operation reaches a terminal state.
type SnapshotPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SnapshotResponse will be returned.
	FinalResponse(ctx context.Context) (SnapshotResponse, error)
}

type snapshotPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *snapshotPoller) Done() bool {
	return p.pt.Done()
}

func (p *snapshotPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *snapshotPoller) FinalResponse(ctx context.Context) (SnapshotResponse, error) {
	respType := SnapshotResponse{Snapshot: &Snapshot{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.Snapshot)
	if err != nil {
		return SnapshotResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *snapshotPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *snapshotPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SnapshotResponse, error) {
	respType := SnapshotResponse{Snapshot: &Snapshot{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.Snapshot)
	if err != nil {
		return SnapshotResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineAssessPatchesResultPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineAssessPatchesResultPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineAssessPatchesResultResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineAssessPatchesResultResponse, error)
}

type virtualMachineAssessPatchesResultPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *virtualMachineAssessPatchesResultPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineAssessPatchesResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualMachineAssessPatchesResultPoller) FinalResponse(ctx context.Context) (VirtualMachineAssessPatchesResultResponse, error) {
	respType := VirtualMachineAssessPatchesResultResponse{VirtualMachineAssessPatchesResult: &VirtualMachineAssessPatchesResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualMachineAssessPatchesResult)
	if err != nil {
		return VirtualMachineAssessPatchesResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineAssessPatchesResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineAssessPatchesResultPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineAssessPatchesResultResponse, error) {
	respType := VirtualMachineAssessPatchesResultResponse{VirtualMachineAssessPatchesResult: &VirtualMachineAssessPatchesResult{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.VirtualMachineAssessPatchesResult)
	if err != nil {
		return VirtualMachineAssessPatchesResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineCaptureResultPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineCaptureResultPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineCaptureResultResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineCaptureResultResponse, error)
}

type virtualMachineCaptureResultPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *virtualMachineCaptureResultPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineCaptureResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualMachineCaptureResultPoller) FinalResponse(ctx context.Context) (VirtualMachineCaptureResultResponse, error) {
	respType := VirtualMachineCaptureResultResponse{VirtualMachineCaptureResult: &VirtualMachineCaptureResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualMachineCaptureResult)
	if err != nil {
		return VirtualMachineCaptureResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineCaptureResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineCaptureResultPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineCaptureResultResponse, error) {
	respType := VirtualMachineCaptureResultResponse{VirtualMachineCaptureResult: &VirtualMachineCaptureResult{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.VirtualMachineCaptureResult)
	if err != nil {
		return VirtualMachineCaptureResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineExtensionPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineExtensionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineExtensionResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineExtensionResponse, error)
}

type virtualMachineExtensionPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *virtualMachineExtensionPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineExtensionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualMachineExtensionPoller) FinalResponse(ctx context.Context) (VirtualMachineExtensionResponse, error) {
	respType := VirtualMachineExtensionResponse{VirtualMachineExtension: &VirtualMachineExtension{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualMachineExtension)
	if err != nil {
		return VirtualMachineExtensionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineExtensionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineExtensionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineExtensionResponse, error) {
	respType := VirtualMachineExtensionResponse{VirtualMachineExtension: &VirtualMachineExtension{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.VirtualMachineExtension)
	if err != nil {
		return VirtualMachineExtensionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineInstallPatchesResultPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineInstallPatchesResultPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineInstallPatchesResultResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineInstallPatchesResultResponse, error)
}

type virtualMachineInstallPatchesResultPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *virtualMachineInstallPatchesResultPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineInstallPatchesResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualMachineInstallPatchesResultPoller) FinalResponse(ctx context.Context) (VirtualMachineInstallPatchesResultResponse, error) {
	respType := VirtualMachineInstallPatchesResultResponse{VirtualMachineInstallPatchesResult: &VirtualMachineInstallPatchesResult{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualMachineInstallPatchesResult)
	if err != nil {
		return VirtualMachineInstallPatchesResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineInstallPatchesResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineInstallPatchesResultPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineInstallPatchesResultResponse, error) {
	respType := VirtualMachineInstallPatchesResultResponse{VirtualMachineInstallPatchesResult: &VirtualMachineInstallPatchesResult{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.VirtualMachineInstallPatchesResult)
	if err != nil {
		return VirtualMachineInstallPatchesResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachinePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineResponse, error)
}

type virtualMachinePoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *virtualMachinePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachinePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualMachinePoller) FinalResponse(ctx context.Context) (VirtualMachineResponse, error) {
	respType := VirtualMachineResponse{VirtualMachine: &VirtualMachine{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualMachine)
	if err != nil {
		return VirtualMachineResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachinePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineResponse, error) {
	respType := VirtualMachineResponse{VirtualMachine: &VirtualMachine{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.VirtualMachine)
	if err != nil {
		return VirtualMachineResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineRunCommandPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineRunCommandPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineRunCommandResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineRunCommandResponse, error)
}

type virtualMachineRunCommandPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *virtualMachineRunCommandPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineRunCommandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualMachineRunCommandPoller) FinalResponse(ctx context.Context) (VirtualMachineRunCommandResponse, error) {
	respType := VirtualMachineRunCommandResponse{VirtualMachineRunCommand: &VirtualMachineRunCommand{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualMachineRunCommand)
	if err != nil {
		return VirtualMachineRunCommandResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineRunCommandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineRunCommandPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineRunCommandResponse, error) {
	respType := VirtualMachineRunCommandResponse{VirtualMachineRunCommand: &VirtualMachineRunCommand{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.VirtualMachineRunCommand)
	if err != nil {
		return VirtualMachineRunCommandResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineScaleSetExtensionPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetExtensionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineScaleSetExtensionResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineScaleSetExtensionResponse, error)
}

type virtualMachineScaleSetExtensionPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *virtualMachineScaleSetExtensionPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineScaleSetExtensionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualMachineScaleSetExtensionPoller) FinalResponse(ctx context.Context) (VirtualMachineScaleSetExtensionResponse, error) {
	respType := VirtualMachineScaleSetExtensionResponse{VirtualMachineScaleSetExtension: &VirtualMachineScaleSetExtension{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualMachineScaleSetExtension)
	if err != nil {
		return VirtualMachineScaleSetExtensionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineScaleSetExtensionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineScaleSetExtensionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetExtensionResponse, error) {
	respType := VirtualMachineScaleSetExtensionResponse{VirtualMachineScaleSetExtension: &VirtualMachineScaleSetExtension{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.VirtualMachineScaleSetExtension)
	if err != nil {
		return VirtualMachineScaleSetExtensionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineScaleSetPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineScaleSetResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineScaleSetResponse, error)
}

type virtualMachineScaleSetPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *virtualMachineScaleSetPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineScaleSetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualMachineScaleSetPoller) FinalResponse(ctx context.Context) (VirtualMachineScaleSetResponse, error) {
	respType := VirtualMachineScaleSetResponse{VirtualMachineScaleSet: &VirtualMachineScaleSet{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualMachineScaleSet)
	if err != nil {
		return VirtualMachineScaleSetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineScaleSetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineScaleSetPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetResponse, error) {
	respType := VirtualMachineScaleSetResponse{VirtualMachineScaleSet: &VirtualMachineScaleSet{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.VirtualMachineScaleSet)
	if err != nil {
		return VirtualMachineScaleSetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineScaleSetVMExtensionPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMExtensionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineScaleSetVMExtensionResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineScaleSetVMExtensionResponse, error)
}

type virtualMachineScaleSetVMExtensionPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *virtualMachineScaleSetVMExtensionPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineScaleSetVMExtensionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualMachineScaleSetVMExtensionPoller) FinalResponse(ctx context.Context) (VirtualMachineScaleSetVMExtensionResponse, error) {
	respType := VirtualMachineScaleSetVMExtensionResponse{VirtualMachineScaleSetVMExtension: &VirtualMachineScaleSetVMExtension{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualMachineScaleSetVMExtension)
	if err != nil {
		return VirtualMachineScaleSetVMExtensionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineScaleSetVMExtensionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineScaleSetVMExtensionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMExtensionResponse, error) {
	respType := VirtualMachineScaleSetVMExtensionResponse{VirtualMachineScaleSetVMExtension: &VirtualMachineScaleSetVMExtension{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.VirtualMachineScaleSetVMExtension)
	if err != nil {
		return VirtualMachineScaleSetVMExtensionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineScaleSetVMPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineScaleSetVMResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineScaleSetVMResponse, error)
}

type virtualMachineScaleSetVMPoller struct {
	pipeline azcore.Pipeline
	pt       armcore.Poller
}

func (p *virtualMachineScaleSetVMPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineScaleSetVMPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx, p.pipeline)
}

func (p *virtualMachineScaleSetVMPoller) FinalResponse(ctx context.Context) (VirtualMachineScaleSetVMResponse, error) {
	respType := VirtualMachineScaleSetVMResponse{VirtualMachineScaleSetVM: &VirtualMachineScaleSetVM{}}
	resp, err := p.pt.FinalResponse(ctx, p.pipeline, respType.VirtualMachineScaleSetVM)
	if err != nil {
		return VirtualMachineScaleSetVMResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineScaleSetVMPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineScaleSetVMPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMResponse, error) {
	respType := VirtualMachineScaleSetVMResponse{VirtualMachineScaleSetVM: &VirtualMachineScaleSetVM{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, p.pipeline, respType.VirtualMachineScaleSetVM)
	if err != nil {
		return VirtualMachineScaleSetVMResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}
