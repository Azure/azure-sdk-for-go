// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azcompute

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// VirtualMachineScaleSetsOperations contains the methods for the VirtualMachineScaleSets group.
type VirtualMachineScaleSetsOperations interface {
	// ConvertToSinglePlacementGroup - Converts SinglePlacementGroup property to false for a existing virtual machine scale set.
	ConvertToSinglePlacementGroup(ctx context.Context, resourceGroupName string, vmScaleSetName string, parameters VMScaleSetConvertToSinglePlacementGroupInput) (*http.Response, error)
	// BeginCreateOrUpdate - Create or update a VM scale set.
	BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, vmScaleSetName string, parameters VirtualMachineScaleSet) (*VirtualMachineScaleSetResponse, error)
	// ResumeCreateOrUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeCreateOrUpdate(token string) (VirtualMachineScaleSetPoller, error)
	// BeginDeallocate - Deallocates specific virtual machines in a VM scale set. Shuts down the virtual machines and releases the compute resources. You are not billed for the compute resources that this virtual machine scale set deallocates.
	BeginDeallocate(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsDeallocateOptions *VirtualMachineScaleSetsDeallocateOptions) (*HTTPResponse, error)
	// ResumeDeallocate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeallocate(token string) (HTTPPoller, error)
	// BeginDelete - Deletes a VM scale set.
	BeginDelete(ctx context.Context, resourceGroupName string, vmScaleSetName string) (*HTTPResponse, error)
	// ResumeDelete - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDelete(token string) (HTTPPoller, error)
	// BeginDeleteInstances - Deletes virtual machines in a VM scale set.
	BeginDeleteInstances(ctx context.Context, resourceGroupName string, vmScaleSetName string, vmInstanceIDs VirtualMachineScaleSetVMInstanceRequiredIDs) (*HTTPResponse, error)
	// ResumeDeleteInstances - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeDeleteInstances(token string) (HTTPPoller, error)
	// ForceRecoveryServiceFabricPlatformUpdateDomainWalk - Manual platform update domain walk to update virtual machines in a service fabric virtual machine scale set.
	ForceRecoveryServiceFabricPlatformUpdateDomainWalk(ctx context.Context, resourceGroupName string, vmScaleSetName string, platformUpdateDomain int32) (*RecoveryWalkResponseResponse, error)
	// Get - Display information about a virtual machine scale set.
	Get(ctx context.Context, resourceGroupName string, vmScaleSetName string) (*VirtualMachineScaleSetResponse, error)
	// GetInstanceView - Gets the status of a VM scale set instance.
	GetInstanceView(ctx context.Context, resourceGroupName string, vmScaleSetName string) (*VirtualMachineScaleSetInstanceViewResponse, error)
	// GetOSUpgradeHistory - Gets list of OS upgrades on a VM scale set instance.
	GetOSUpgradeHistory(resourceGroupName string, vmScaleSetName string) (VirtualMachineScaleSetListOSUpgradeHistoryPager, error)
	// List - Gets a list of all VM scale sets under a resource group.
	List(resourceGroupName string) (VirtualMachineScaleSetListResultPager, error)
	// ListAll - Gets a list of all VM Scale Sets in the subscription, regardless of the associated resource group. Use nextLink property in the response to get the next page of VM Scale Sets. Do this till nextLink is null to fetch all the VM Scale Sets.
	ListAll() (VirtualMachineScaleSetListWithLinkResultPager, error)
	// ListSkus - Gets a list of SKUs available for your VM scale set, including the minimum and maximum VM instances allowed for each SKU.
	ListSkus(resourceGroupName string, vmScaleSetName string) (VirtualMachineScaleSetListSkusResultPager, error)
	// BeginPerformMaintenance - Perform maintenance on one or more virtual machines in a VM scale set. Operation on instances which are not eligible for perform maintenance will be failed. Please refer to best practices for more details: https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-maintenance-notifications
	BeginPerformMaintenance(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsPerformMaintenanceOptions *VirtualMachineScaleSetsPerformMaintenanceOptions) (*HTTPResponse, error)
	// ResumePerformMaintenance - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePerformMaintenance(token string) (HTTPPoller, error)
	// BeginPowerOff - Power off (stop) one or more virtual machines in a VM scale set. Note that resources are still attached and you are getting charged for the resources. Instead, use deallocate to release resources and avoid charges.
	BeginPowerOff(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsPowerOffOptions *VirtualMachineScaleSetsPowerOffOptions) (*HTTPResponse, error)
	// ResumePowerOff - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumePowerOff(token string) (HTTPPoller, error)
	// BeginRedeploy - Shuts down all the virtual machines in the virtual machine scale set, moves them to a new node, and powers them back on.
	BeginRedeploy(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsRedeployOptions *VirtualMachineScaleSetsRedeployOptions) (*HTTPResponse, error)
	// ResumeRedeploy - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeRedeploy(token string) (HTTPPoller, error)
	// BeginReimage - Reimages (upgrade the operating system) one or more virtual machines in a VM scale set which don't have a ephemeral OS disk, for virtual machines who have a ephemeral OS disk the virtual machine is reset to initial state.
	BeginReimage(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsReimageOptions *VirtualMachineScaleSetsReimageOptions) (*HTTPResponse, error)
	// ResumeReimage - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeReimage(token string) (HTTPPoller, error)
	// BeginReimageAll - Reimages all the disks ( including data disks ) in the virtual machines in a VM scale set. This operation is only supported for managed disks.
	BeginReimageAll(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsReimageAllOptions *VirtualMachineScaleSetsReimageAllOptions) (*HTTPResponse, error)
	// ResumeReimageAll - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeReimageAll(token string) (HTTPPoller, error)
	// BeginRestart - Restarts one or more virtual machines in a VM scale set.
	BeginRestart(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsRestartOptions *VirtualMachineScaleSetsRestartOptions) (*HTTPResponse, error)
	// ResumeRestart - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeRestart(token string) (HTTPPoller, error)
	// BeginSetOrchestrationServiceState - Changes ServiceState property for a given service
	BeginSetOrchestrationServiceState(ctx context.Context, resourceGroupName string, vmScaleSetName string, parameters OrchestrationServiceStateInput) (*HTTPResponse, error)
	// ResumeSetOrchestrationServiceState - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeSetOrchestrationServiceState(token string) (HTTPPoller, error)
	// BeginStart - Starts one or more virtual machines in a VM scale set.
	BeginStart(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsStartOptions *VirtualMachineScaleSetsStartOptions) (*HTTPResponse, error)
	// ResumeStart - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeStart(token string) (HTTPPoller, error)
	// BeginUpdate - Update a VM scale set.
	BeginUpdate(ctx context.Context, resourceGroupName string, vmScaleSetName string, parameters VirtualMachineScaleSetUpdate) (*VirtualMachineScaleSetResponse, error)
	// ResumeUpdate - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeUpdate(token string) (VirtualMachineScaleSetPoller, error)
	// BeginUpdateInstances - Upgrades one or more virtual machines to the latest SKU set in the VM scale set model.
	BeginUpdateInstances(ctx context.Context, resourceGroupName string, vmScaleSetName string, vmInstanceIDs VirtualMachineScaleSetVMInstanceRequiredIDs) (*HTTPResponse, error)
	// ResumeUpdateInstances - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeUpdateInstances(token string) (HTTPPoller, error)
}

// virtualMachineScaleSetsOperations implements the VirtualMachineScaleSetsOperations interface.
type virtualMachineScaleSetsOperations struct {
	*Client
	subscriptionID string
}

// ConvertToSinglePlacementGroup - Converts SinglePlacementGroup property to false for a existing virtual machine scale set.
func (client *virtualMachineScaleSetsOperations) ConvertToSinglePlacementGroup(ctx context.Context, resourceGroupName string, vmScaleSetName string, parameters VMScaleSetConvertToSinglePlacementGroupInput) (*http.Response, error) {
	req, err := client.convertToSinglePlacementGroupCreateRequest(resourceGroupName, vmScaleSetName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.convertToSinglePlacementGroupHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// convertToSinglePlacementGroupCreateRequest creates the ConvertToSinglePlacementGroup request.
func (client *virtualMachineScaleSetsOperations) convertToSinglePlacementGroupCreateRequest(resourceGroupName string, vmScaleSetName string, parameters VMScaleSetConvertToSinglePlacementGroupInput) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/convertToSinglePlacementGroup"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(parameters)
}

// convertToSinglePlacementGroupHandleResponse handles the ConvertToSinglePlacementGroup response.
func (client *virtualMachineScaleSetsOperations) convertToSinglePlacementGroupHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.convertToSinglePlacementGroupHandleError(resp)
	}
	return resp.Response, nil
}

// convertToSinglePlacementGroupHandleError handles the ConvertToSinglePlacementGroup error response.
func (client *virtualMachineScaleSetsOperations) convertToSinglePlacementGroupHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// CreateOrUpdate - Create or update a VM scale set.
func (client *virtualMachineScaleSetsOperations) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, vmScaleSetName string, parameters VirtualMachineScaleSet) (*VirtualMachineScaleSetResponse, error) {
	req, err := client.createOrUpdateCreateRequest(resourceGroupName, vmScaleSetName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createOrUpdateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.CreateOrUpdate", "", resp, client.createOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &virtualMachineScaleSetPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*VirtualMachineScaleSetResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumeCreateOrUpdate(token string) (VirtualMachineScaleSetPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.CreateOrUpdate", token, client.createOrUpdateHandleError)
	if err != nil {
		return nil, err
	}
	return &virtualMachineScaleSetPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *virtualMachineScaleSetsOperations) createOrUpdateCreateRequest(resourceGroupName string, vmScaleSetName string, parameters VirtualMachineScaleSet) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateHandleResponse handles the CreateOrUpdate response.
func (client *virtualMachineScaleSetsOperations) createOrUpdateHandleResponse(resp *azcore.Response) (*VirtualMachineScaleSetResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusNoContent) {
		return nil, client.createOrUpdateHandleError(resp)
	}
	result := VirtualMachineScaleSetResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineScaleSet)
}

// createOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *virtualMachineScaleSetsOperations) createOrUpdateHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Deallocate - Deallocates specific virtual machines in a VM scale set. Shuts down the virtual machines and releases the compute resources. You are not billed for the compute resources that this virtual machine scale set deallocates.
func (client *virtualMachineScaleSetsOperations) BeginDeallocate(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsDeallocateOptions *VirtualMachineScaleSetsDeallocateOptions) (*HTTPResponse, error) {
	req, err := client.deallocateCreateRequest(resourceGroupName, vmScaleSetName, virtualMachineScaleSetsDeallocateOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deallocateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.Deallocate", "", resp, client.deallocateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumeDeallocate(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.Deallocate", token, client.deallocateHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deallocateCreateRequest creates the Deallocate request.
func (client *virtualMachineScaleSetsOperations) deallocateCreateRequest(resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsDeallocateOptions *VirtualMachineScaleSetsDeallocateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/deallocate"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	if virtualMachineScaleSetsDeallocateOptions != nil {
		return req, req.MarshalAsJSON(virtualMachineScaleSetsDeallocateOptions.VMInstanceIDs)
	}
	return req, nil
}

// deallocateHandleResponse handles the Deallocate response.
func (client *virtualMachineScaleSetsOperations) deallocateHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deallocateHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// deallocateHandleError handles the Deallocate error response.
func (client *virtualMachineScaleSetsOperations) deallocateHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Delete - Deletes a VM scale set.
func (client *virtualMachineScaleSetsOperations) BeginDelete(ctx context.Context, resourceGroupName string, vmScaleSetName string) (*HTTPResponse, error) {
	req, err := client.deleteCreateRequest(resourceGroupName, vmScaleSetName)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.Delete", "", resp, client.deleteHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumeDelete(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.Delete", token, client.deleteHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *virtualMachineScaleSetsOperations) deleteCreateRequest(resourceGroupName string, vmScaleSetName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *virtualMachineScaleSetsOperations) deleteHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// deleteHandleError handles the Delete error response.
func (client *virtualMachineScaleSetsOperations) deleteHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// DeleteInstances - Deletes virtual machines in a VM scale set.
func (client *virtualMachineScaleSetsOperations) BeginDeleteInstances(ctx context.Context, resourceGroupName string, vmScaleSetName string, vmInstanceIDs VirtualMachineScaleSetVMInstanceRequiredIDs) (*HTTPResponse, error) {
	req, err := client.deleteInstancesCreateRequest(resourceGroupName, vmScaleSetName, vmInstanceIDs)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteInstancesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.DeleteInstances", "", resp, client.deleteInstancesHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumeDeleteInstances(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.DeleteInstances", token, client.deleteInstancesHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// deleteInstancesCreateRequest creates the DeleteInstances request.
func (client *virtualMachineScaleSetsOperations) deleteInstancesCreateRequest(resourceGroupName string, vmScaleSetName string, vmInstanceIDs VirtualMachineScaleSetVMInstanceRequiredIDs) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/delete"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(vmInstanceIDs)
}

// deleteInstancesHandleResponse handles the DeleteInstances response.
func (client *virtualMachineScaleSetsOperations) deleteInstancesHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteInstancesHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// deleteInstancesHandleError handles the DeleteInstances error response.
func (client *virtualMachineScaleSetsOperations) deleteInstancesHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// ForceRecoveryServiceFabricPlatformUpdateDomainWalk - Manual platform update domain walk to update virtual machines in a service fabric virtual machine scale set.
func (client *virtualMachineScaleSetsOperations) ForceRecoveryServiceFabricPlatformUpdateDomainWalk(ctx context.Context, resourceGroupName string, vmScaleSetName string, platformUpdateDomain int32) (*RecoveryWalkResponseResponse, error) {
	req, err := client.forceRecoveryServiceFabricPlatformUpdateDomainWalkCreateRequest(resourceGroupName, vmScaleSetName, platformUpdateDomain)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.forceRecoveryServiceFabricPlatformUpdateDomainWalkHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// forceRecoveryServiceFabricPlatformUpdateDomainWalkCreateRequest creates the ForceRecoveryServiceFabricPlatformUpdateDomainWalk request.
func (client *virtualMachineScaleSetsOperations) forceRecoveryServiceFabricPlatformUpdateDomainWalkCreateRequest(resourceGroupName string, vmScaleSetName string, platformUpdateDomain int32) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/forceRecoveryServiceFabricPlatformUpdateDomainWalk"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	query.Set("platformUpdateDomain", strconv.FormatInt(int64(platformUpdateDomain), 10))
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// forceRecoveryServiceFabricPlatformUpdateDomainWalkHandleResponse handles the ForceRecoveryServiceFabricPlatformUpdateDomainWalk response.
func (client *virtualMachineScaleSetsOperations) forceRecoveryServiceFabricPlatformUpdateDomainWalkHandleResponse(resp *azcore.Response) (*RecoveryWalkResponseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.forceRecoveryServiceFabricPlatformUpdateDomainWalkHandleError(resp)
	}
	result := RecoveryWalkResponseResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.RecoveryWalkResponse)
}

// forceRecoveryServiceFabricPlatformUpdateDomainWalkHandleError handles the ForceRecoveryServiceFabricPlatformUpdateDomainWalk error response.
func (client *virtualMachineScaleSetsOperations) forceRecoveryServiceFabricPlatformUpdateDomainWalkHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Get - Display information about a virtual machine scale set.
func (client *virtualMachineScaleSetsOperations) Get(ctx context.Context, resourceGroupName string, vmScaleSetName string) (*VirtualMachineScaleSetResponse, error) {
	req, err := client.getCreateRequest(resourceGroupName, vmScaleSetName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getCreateRequest creates the Get request.
func (client *virtualMachineScaleSetsOperations) getCreateRequest(resourceGroupName string, vmScaleSetName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *virtualMachineScaleSetsOperations) getHandleResponse(resp *azcore.Response) (*VirtualMachineScaleSetResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getHandleError(resp)
	}
	result := VirtualMachineScaleSetResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineScaleSet)
}

// getHandleError handles the Get error response.
func (client *virtualMachineScaleSetsOperations) getHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetInstanceView - Gets the status of a VM scale set instance.
func (client *virtualMachineScaleSetsOperations) GetInstanceView(ctx context.Context, resourceGroupName string, vmScaleSetName string) (*VirtualMachineScaleSetInstanceViewResponse, error) {
	req, err := client.getInstanceViewCreateRequest(resourceGroupName, vmScaleSetName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getInstanceViewHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getInstanceViewCreateRequest creates the GetInstanceView request.
func (client *virtualMachineScaleSetsOperations) getInstanceViewCreateRequest(resourceGroupName string, vmScaleSetName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/instanceView"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getInstanceViewHandleResponse handles the GetInstanceView response.
func (client *virtualMachineScaleSetsOperations) getInstanceViewHandleResponse(resp *azcore.Response) (*VirtualMachineScaleSetInstanceViewResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getInstanceViewHandleError(resp)
	}
	result := VirtualMachineScaleSetInstanceViewResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineScaleSetInstanceView)
}

// getInstanceViewHandleError handles the GetInstanceView error response.
func (client *virtualMachineScaleSetsOperations) getInstanceViewHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetOSUpgradeHistory - Gets list of OS upgrades on a VM scale set instance.
func (client *virtualMachineScaleSetsOperations) GetOSUpgradeHistory(resourceGroupName string, vmScaleSetName string) (VirtualMachineScaleSetListOSUpgradeHistoryPager, error) {
	req, err := client.getOSUpgradeHistoryCreateRequest(resourceGroupName, vmScaleSetName)
	if err != nil {
		return nil, err
	}
	return &virtualMachineScaleSetListOSUpgradeHistoryPager{
		pipeline:  client.p,
		request:   req,
		responder: client.getOSUpgradeHistoryHandleResponse,
		advancer: func(resp *VirtualMachineScaleSetListOSUpgradeHistoryResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.VirtualMachineScaleSetListOSUpgradeHistory.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.VirtualMachineScaleSetListOSUpgradeHistory.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getOSUpgradeHistoryCreateRequest creates the GetOSUpgradeHistory request.
func (client *virtualMachineScaleSetsOperations) getOSUpgradeHistoryCreateRequest(resourceGroupName string, vmScaleSetName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/osUpgradeHistory"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getOSUpgradeHistoryHandleResponse handles the GetOSUpgradeHistory response.
func (client *virtualMachineScaleSetsOperations) getOSUpgradeHistoryHandleResponse(resp *azcore.Response) (*VirtualMachineScaleSetListOSUpgradeHistoryResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getOSUpgradeHistoryHandleError(resp)
	}
	result := VirtualMachineScaleSetListOSUpgradeHistoryResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineScaleSetListOSUpgradeHistory)
}

// getOSUpgradeHistoryHandleError handles the GetOSUpgradeHistory error response.
func (client *virtualMachineScaleSetsOperations) getOSUpgradeHistoryHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// List - Gets a list of all VM scale sets under a resource group.
func (client *virtualMachineScaleSetsOperations) List(resourceGroupName string) (VirtualMachineScaleSetListResultPager, error) {
	req, err := client.listCreateRequest(resourceGroupName)
	if err != nil {
		return nil, err
	}
	return &virtualMachineScaleSetListResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listHandleResponse,
		advancer: func(resp *VirtualMachineScaleSetListResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.VirtualMachineScaleSetListResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.VirtualMachineScaleSetListResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listCreateRequest creates the List request.
func (client *virtualMachineScaleSetsOperations) listCreateRequest(resourceGroupName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listHandleResponse handles the List response.
func (client *virtualMachineScaleSetsOperations) listHandleResponse(resp *azcore.Response) (*VirtualMachineScaleSetListResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listHandleError(resp)
	}
	result := VirtualMachineScaleSetListResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineScaleSetListResult)
}

// listHandleError handles the List error response.
func (client *virtualMachineScaleSetsOperations) listHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// ListAll - Gets a list of all VM Scale Sets in the subscription, regardless of the associated resource group. Use nextLink property in the response to get the next page of VM Scale Sets. Do this till nextLink is null to fetch all the VM Scale Sets.
func (client *virtualMachineScaleSetsOperations) ListAll() (VirtualMachineScaleSetListWithLinkResultPager, error) {
	req, err := client.listAllCreateRequest()
	if err != nil {
		return nil, err
	}
	return &virtualMachineScaleSetListWithLinkResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listAllHandleResponse,
		advancer: func(resp *VirtualMachineScaleSetListWithLinkResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.VirtualMachineScaleSetListWithLinkResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.VirtualMachineScaleSetListWithLinkResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listAllCreateRequest creates the ListAll request.
func (client *virtualMachineScaleSetsOperations) listAllCreateRequest() (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/virtualMachineScaleSets"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listAllHandleResponse handles the ListAll response.
func (client *virtualMachineScaleSetsOperations) listAllHandleResponse(resp *azcore.Response) (*VirtualMachineScaleSetListWithLinkResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listAllHandleError(resp)
	}
	result := VirtualMachineScaleSetListWithLinkResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineScaleSetListWithLinkResult)
}

// listAllHandleError handles the ListAll error response.
func (client *virtualMachineScaleSetsOperations) listAllHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// ListSkus - Gets a list of SKUs available for your VM scale set, including the minimum and maximum VM instances allowed for each SKU.
func (client *virtualMachineScaleSetsOperations) ListSkus(resourceGroupName string, vmScaleSetName string) (VirtualMachineScaleSetListSkusResultPager, error) {
	req, err := client.listSkusCreateRequest(resourceGroupName, vmScaleSetName)
	if err != nil {
		return nil, err
	}
	return &virtualMachineScaleSetListSkusResultPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listSkusHandleResponse,
		advancer: func(resp *VirtualMachineScaleSetListSkusResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.VirtualMachineScaleSetListSkusResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.VirtualMachineScaleSetListSkusResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listSkusCreateRequest creates the ListSkus request.
func (client *virtualMachineScaleSetsOperations) listSkusCreateRequest(resourceGroupName string, vmScaleSetName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/skus"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listSkusHandleResponse handles the ListSkus response.
func (client *virtualMachineScaleSetsOperations) listSkusHandleResponse(resp *azcore.Response) (*VirtualMachineScaleSetListSkusResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listSkusHandleError(resp)
	}
	result := VirtualMachineScaleSetListSkusResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineScaleSetListSkusResult)
}

// listSkusHandleError handles the ListSkus error response.
func (client *virtualMachineScaleSetsOperations) listSkusHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// PerformMaintenance - Perform maintenance on one or more virtual machines in a VM scale set. Operation on instances which are not eligible for perform maintenance will be failed. Please refer to best practices for more details: https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-maintenance-notifications
func (client *virtualMachineScaleSetsOperations) BeginPerformMaintenance(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsPerformMaintenanceOptions *VirtualMachineScaleSetsPerformMaintenanceOptions) (*HTTPResponse, error) {
	req, err := client.performMaintenanceCreateRequest(resourceGroupName, vmScaleSetName, virtualMachineScaleSetsPerformMaintenanceOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.performMaintenanceHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.PerformMaintenance", "", resp, client.performMaintenanceHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumePerformMaintenance(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.PerformMaintenance", token, client.performMaintenanceHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// performMaintenanceCreateRequest creates the PerformMaintenance request.
func (client *virtualMachineScaleSetsOperations) performMaintenanceCreateRequest(resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsPerformMaintenanceOptions *VirtualMachineScaleSetsPerformMaintenanceOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/performMaintenance"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	if virtualMachineScaleSetsPerformMaintenanceOptions != nil {
		return req, req.MarshalAsJSON(virtualMachineScaleSetsPerformMaintenanceOptions.VMInstanceIDs)
	}
	return req, nil
}

// performMaintenanceHandleResponse handles the PerformMaintenance response.
func (client *virtualMachineScaleSetsOperations) performMaintenanceHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.performMaintenanceHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// performMaintenanceHandleError handles the PerformMaintenance error response.
func (client *virtualMachineScaleSetsOperations) performMaintenanceHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// PowerOff - Power off (stop) one or more virtual machines in a VM scale set. Note that resources are still attached and you are getting charged for the resources. Instead, use deallocate to release resources and avoid charges.
func (client *virtualMachineScaleSetsOperations) BeginPowerOff(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsPowerOffOptions *VirtualMachineScaleSetsPowerOffOptions) (*HTTPResponse, error) {
	req, err := client.powerOffCreateRequest(resourceGroupName, vmScaleSetName, virtualMachineScaleSetsPowerOffOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.powerOffHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.PowerOff", "", resp, client.powerOffHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumePowerOff(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.PowerOff", token, client.powerOffHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// powerOffCreateRequest creates the PowerOff request.
func (client *virtualMachineScaleSetsOperations) powerOffCreateRequest(resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsPowerOffOptions *VirtualMachineScaleSetsPowerOffOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/poweroff"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	if virtualMachineScaleSetsPowerOffOptions != nil && virtualMachineScaleSetsPowerOffOptions.SkipShutdown != nil {
		query.Set("skipShutdown", strconv.FormatBool(*virtualMachineScaleSetsPowerOffOptions.SkipShutdown))
	}
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	if virtualMachineScaleSetsPowerOffOptions != nil {
		return req, req.MarshalAsJSON(virtualMachineScaleSetsPowerOffOptions.VMInstanceIDs)
	}
	return req, nil
}

// powerOffHandleResponse handles the PowerOff response.
func (client *virtualMachineScaleSetsOperations) powerOffHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.powerOffHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// powerOffHandleError handles the PowerOff error response.
func (client *virtualMachineScaleSetsOperations) powerOffHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Redeploy - Shuts down all the virtual machines in the virtual machine scale set, moves them to a new node, and powers them back on.
func (client *virtualMachineScaleSetsOperations) BeginRedeploy(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsRedeployOptions *VirtualMachineScaleSetsRedeployOptions) (*HTTPResponse, error) {
	req, err := client.redeployCreateRequest(resourceGroupName, vmScaleSetName, virtualMachineScaleSetsRedeployOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.redeployHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.Redeploy", "", resp, client.redeployHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumeRedeploy(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.Redeploy", token, client.redeployHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// redeployCreateRequest creates the Redeploy request.
func (client *virtualMachineScaleSetsOperations) redeployCreateRequest(resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsRedeployOptions *VirtualMachineScaleSetsRedeployOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/redeploy"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	if virtualMachineScaleSetsRedeployOptions != nil {
		return req, req.MarshalAsJSON(virtualMachineScaleSetsRedeployOptions.VMInstanceIDs)
	}
	return req, nil
}

// redeployHandleResponse handles the Redeploy response.
func (client *virtualMachineScaleSetsOperations) redeployHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.redeployHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// redeployHandleError handles the Redeploy error response.
func (client *virtualMachineScaleSetsOperations) redeployHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Reimage - Reimages (upgrade the operating system) one or more virtual machines in a VM scale set which don't have a ephemeral OS disk, for virtual machines who have a ephemeral OS disk the virtual machine is reset to initial state.
func (client *virtualMachineScaleSetsOperations) BeginReimage(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsReimageOptions *VirtualMachineScaleSetsReimageOptions) (*HTTPResponse, error) {
	req, err := client.reimageCreateRequest(resourceGroupName, vmScaleSetName, virtualMachineScaleSetsReimageOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.reimageHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.Reimage", "", resp, client.reimageHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumeReimage(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.Reimage", token, client.reimageHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// reimageCreateRequest creates the Reimage request.
func (client *virtualMachineScaleSetsOperations) reimageCreateRequest(resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsReimageOptions *VirtualMachineScaleSetsReimageOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/reimage"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	if virtualMachineScaleSetsReimageOptions != nil {
		return req, req.MarshalAsJSON(virtualMachineScaleSetsReimageOptions.VMScaleSetReimageInput)
	}
	return req, nil
}

// reimageHandleResponse handles the Reimage response.
func (client *virtualMachineScaleSetsOperations) reimageHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.reimageHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// reimageHandleError handles the Reimage error response.
func (client *virtualMachineScaleSetsOperations) reimageHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// ReimageAll - Reimages all the disks ( including data disks ) in the virtual machines in a VM scale set. This operation is only supported for managed disks.
func (client *virtualMachineScaleSetsOperations) BeginReimageAll(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsReimageAllOptions *VirtualMachineScaleSetsReimageAllOptions) (*HTTPResponse, error) {
	req, err := client.reimageAllCreateRequest(resourceGroupName, vmScaleSetName, virtualMachineScaleSetsReimageAllOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.reimageAllHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.ReimageAll", "", resp, client.reimageAllHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumeReimageAll(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.ReimageAll", token, client.reimageAllHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// reimageAllCreateRequest creates the ReimageAll request.
func (client *virtualMachineScaleSetsOperations) reimageAllCreateRequest(resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsReimageAllOptions *VirtualMachineScaleSetsReimageAllOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/reimageall"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	if virtualMachineScaleSetsReimageAllOptions != nil {
		return req, req.MarshalAsJSON(virtualMachineScaleSetsReimageAllOptions.VMInstanceIDs)
	}
	return req, nil
}

// reimageAllHandleResponse handles the ReimageAll response.
func (client *virtualMachineScaleSetsOperations) reimageAllHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.reimageAllHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// reimageAllHandleError handles the ReimageAll error response.
func (client *virtualMachineScaleSetsOperations) reimageAllHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Restart - Restarts one or more virtual machines in a VM scale set.
func (client *virtualMachineScaleSetsOperations) BeginRestart(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsRestartOptions *VirtualMachineScaleSetsRestartOptions) (*HTTPResponse, error) {
	req, err := client.restartCreateRequest(resourceGroupName, vmScaleSetName, virtualMachineScaleSetsRestartOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.restartHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.Restart", "", resp, client.restartHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumeRestart(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.Restart", token, client.restartHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// restartCreateRequest creates the Restart request.
func (client *virtualMachineScaleSetsOperations) restartCreateRequest(resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsRestartOptions *VirtualMachineScaleSetsRestartOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/restart"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	if virtualMachineScaleSetsRestartOptions != nil {
		return req, req.MarshalAsJSON(virtualMachineScaleSetsRestartOptions.VMInstanceIDs)
	}
	return req, nil
}

// restartHandleResponse handles the Restart response.
func (client *virtualMachineScaleSetsOperations) restartHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.restartHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// restartHandleError handles the Restart error response.
func (client *virtualMachineScaleSetsOperations) restartHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// SetOrchestrationServiceState - Changes ServiceState property for a given service
func (client *virtualMachineScaleSetsOperations) BeginSetOrchestrationServiceState(ctx context.Context, resourceGroupName string, vmScaleSetName string, parameters OrchestrationServiceStateInput) (*HTTPResponse, error) {
	req, err := client.setOrchestrationServiceStateCreateRequest(resourceGroupName, vmScaleSetName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.setOrchestrationServiceStateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.SetOrchestrationServiceState", "", resp, client.setOrchestrationServiceStateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumeSetOrchestrationServiceState(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.SetOrchestrationServiceState", token, client.setOrchestrationServiceStateHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// setOrchestrationServiceStateCreateRequest creates the SetOrchestrationServiceState request.
func (client *virtualMachineScaleSetsOperations) setOrchestrationServiceStateCreateRequest(resourceGroupName string, vmScaleSetName string, parameters OrchestrationServiceStateInput) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/setOrchestrationServiceState"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(parameters)
}

// setOrchestrationServiceStateHandleResponse handles the SetOrchestrationServiceState response.
func (client *virtualMachineScaleSetsOperations) setOrchestrationServiceStateHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.setOrchestrationServiceStateHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// setOrchestrationServiceStateHandleError handles the SetOrchestrationServiceState error response.
func (client *virtualMachineScaleSetsOperations) setOrchestrationServiceStateHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Start - Starts one or more virtual machines in a VM scale set.
func (client *virtualMachineScaleSetsOperations) BeginStart(ctx context.Context, resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsStartOptions *VirtualMachineScaleSetsStartOptions) (*HTTPResponse, error) {
	req, err := client.startCreateRequest(resourceGroupName, vmScaleSetName, virtualMachineScaleSetsStartOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.startHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.Start", "", resp, client.startHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumeStart(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.Start", token, client.startHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// startCreateRequest creates the Start request.
func (client *virtualMachineScaleSetsOperations) startCreateRequest(resourceGroupName string, vmScaleSetName string, virtualMachineScaleSetsStartOptions *VirtualMachineScaleSetsStartOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/start"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	if virtualMachineScaleSetsStartOptions != nil {
		return req, req.MarshalAsJSON(virtualMachineScaleSetsStartOptions.VMInstanceIDs)
	}
	return req, nil
}

// startHandleResponse handles the Start response.
func (client *virtualMachineScaleSetsOperations) startHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.startHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// startHandleError handles the Start error response.
func (client *virtualMachineScaleSetsOperations) startHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Update - Update a VM scale set.
func (client *virtualMachineScaleSetsOperations) BeginUpdate(ctx context.Context, resourceGroupName string, vmScaleSetName string, parameters VirtualMachineScaleSetUpdate) (*VirtualMachineScaleSetResponse, error) {
	req, err := client.updateCreateRequest(resourceGroupName, vmScaleSetName, parameters)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.updateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.Update", "", resp, client.updateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &virtualMachineScaleSetPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*VirtualMachineScaleSetResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumeUpdate(token string) (VirtualMachineScaleSetPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.Update", token, client.updateHandleError)
	if err != nil {
		return nil, err
	}
	return &virtualMachineScaleSetPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// updateCreateRequest creates the Update request.
func (client *virtualMachineScaleSetsOperations) updateCreateRequest(resourceGroupName string, vmScaleSetName string, parameters VirtualMachineScaleSetUpdate) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPatch, *u)
	return req, req.MarshalAsJSON(parameters)
}

// updateHandleResponse handles the Update response.
func (client *virtualMachineScaleSetsOperations) updateHandleResponse(resp *azcore.Response) (*VirtualMachineScaleSetResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.updateHandleError(resp)
	}
	result := VirtualMachineScaleSetResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.VirtualMachineScaleSet)
}

// updateHandleError handles the Update error response.
func (client *virtualMachineScaleSetsOperations) updateHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// UpdateInstances - Upgrades one or more virtual machines to the latest SKU set in the VM scale set model.
func (client *virtualMachineScaleSetsOperations) BeginUpdateInstances(ctx context.Context, resourceGroupName string, vmScaleSetName string, vmInstanceIDs VirtualMachineScaleSetVMInstanceRequiredIDs) (*HTTPResponse, error) {
	req, err := client.updateInstancesCreateRequest(resourceGroupName, vmScaleSetName, vmInstanceIDs)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.updateInstancesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("virtualMachineScaleSetsOperations.UpdateInstances", "", resp, client.updateInstancesHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *virtualMachineScaleSetsOperations) ResumeUpdateInstances(token string) (HTTPPoller, error) {
	pt, err := resumePollingTracker("virtualMachineScaleSetsOperations.UpdateInstances", token, client.updateInstancesHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// updateInstancesCreateRequest creates the UpdateInstances request.
func (client *virtualMachineScaleSetsOperations) updateInstancesCreateRequest(resourceGroupName string, vmScaleSetName string, vmInstanceIDs VirtualMachineScaleSetVMInstanceRequiredIDs) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/manualupgrade"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{vmScaleSetName}", url.PathEscape(vmScaleSetName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-12-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(vmInstanceIDs)
}

// updateInstancesHandleResponse handles the UpdateInstances response.
func (client *virtualMachineScaleSetsOperations) updateInstancesHandleResponse(resp *azcore.Response) (*HTTPResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.updateInstancesHandleError(resp)
	}
	return &HTTPResponse{RawResponse: resp.Response}, nil
}

// updateInstancesHandleError handles the UpdateInstances error response.
func (client *virtualMachineScaleSetsOperations) updateInstancesHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}
