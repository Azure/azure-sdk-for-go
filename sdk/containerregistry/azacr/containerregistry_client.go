//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package azacr

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// ContainerRegistryClient contains the methods for the ContainerRegistry group.
// Don't use this type directly, use NewContainerRegistryClient() instead.
type ContainerRegistryClient struct {
	endpoint string
	pl       runtime.Pipeline
}

// CheckDockerV2Support - Tells whether this Docker Registry instance supports Docker Registry HTTP API v2
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - options - ContainerRegistryClientCheckDockerV2SupportOptions contains the optional parameters for the ContainerRegistryClient.CheckDockerV2Support
//     method.
func (client *ContainerRegistryClient) CheckDockerV2Support(ctx context.Context, options *ContainerRegistryClientCheckDockerV2SupportOptions) (ContainerRegistryClientCheckDockerV2SupportResponse, error) {
	req, err := client.checkDockerV2SupportCreateRequest(ctx, options)
	if err != nil {
		return ContainerRegistryClientCheckDockerV2SupportResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientCheckDockerV2SupportResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientCheckDockerV2SupportResponse{}, runtime.NewResponseError(resp)
	}
	return ContainerRegistryClientCheckDockerV2SupportResponse{}, nil
}

// checkDockerV2SupportCreateRequest creates the CheckDockerV2Support request.
func (client *ContainerRegistryClient) checkDockerV2SupportCreateRequest(ctx context.Context, options *ContainerRegistryClientCheckDockerV2SupportOptions) (*policy.Request, error) {
	urlPath := "/v2/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteManifest - Delete the manifest identified by name and reference. Note that a manifest can only be deleted by digest.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - digest - Digest of a BLOB
//   - options - ContainerRegistryClientDeleteManifestOptions contains the optional parameters for the ContainerRegistryClient.DeleteManifest
//     method.
func (client *ContainerRegistryClient) deleteManifest(ctx context.Context, name string, digest string, options *ContainerRegistryClientDeleteManifestOptions) (ContainerRegistryClientDeleteManifestResponse, error) {
	req, err := client.deleteManifestCreateRequest(ctx, name, digest, options)
	if err != nil {
		return ContainerRegistryClientDeleteManifestResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientDeleteManifestResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNotFound) {
		return ContainerRegistryClientDeleteManifestResponse{}, runtime.NewResponseError(resp)
	}
	return ContainerRegistryClientDeleteManifestResponse{}, nil
}

// deleteManifestCreateRequest creates the DeleteManifest request.
func (client *ContainerRegistryClient) deleteManifestCreateRequest(ctx context.Context, name string, digest string, options *ContainerRegistryClientDeleteManifestOptions) (*policy.Request, error) {
	urlPath := "/v2/{name}/manifests/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if digest == "" {
		return nil, errors.New("parameter digest cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(digest))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteRepository - Delete the repository identified by name
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientDeleteRepositoryOptions contains the optional parameters for the ContainerRegistryClient.DeleteRepository
//     method.
func (client *ContainerRegistryClient) DeleteRepository(ctx context.Context, name string, options *ContainerRegistryClientDeleteRepositoryOptions) (ContainerRegistryClientDeleteRepositoryResponse, error) {
	req, err := client.deleteRepositoryCreateRequest(ctx, name, options)
	if err != nil {
		return ContainerRegistryClientDeleteRepositoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientDeleteRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNotFound) {
		return ContainerRegistryClientDeleteRepositoryResponse{}, runtime.NewResponseError(resp)
	}
	return ContainerRegistryClientDeleteRepositoryResponse{}, nil
}

// deleteRepositoryCreateRequest creates the DeleteRepository request.
func (client *ContainerRegistryClient) deleteRepositoryCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientDeleteRepositoryOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteTag - Delete tag
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - tag - Tag name
//   - options - ContainerRegistryClientDeleteTagOptions contains the optional parameters for the ContainerRegistryClient.DeleteTag
//     method.
func (client *ContainerRegistryClient) DeleteTag(ctx context.Context, name string, tag string, options *ContainerRegistryClientDeleteTagOptions) (ContainerRegistryClientDeleteTagResponse, error) {
	req, err := client.deleteTagCreateRequest(ctx, name, tag, options)
	if err != nil {
		return ContainerRegistryClientDeleteTagResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientDeleteTagResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNotFound) {
		return ContainerRegistryClientDeleteTagResponse{}, runtime.NewResponseError(resp)
	}
	return ContainerRegistryClientDeleteTagResponse{}, nil
}

// deleteTagCreateRequest creates the DeleteTag request.
func (client *ContainerRegistryClient) deleteTagCreateRequest(ctx context.Context, name string, tag string, options *ContainerRegistryClientDeleteTagOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_tags/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if tag == "" {
		return nil, errors.New("parameter tag cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(tag))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetManifest - Get the manifest identified by name and reference where reference can be a tag or digest.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - A tag or a digest, pointing to a specific image
//   - options - ContainerRegistryClientGetManifestOptions contains the optional parameters for the ContainerRegistryClient.GetManifest
//     method.
func (client *ContainerRegistryClient) GetManifest(ctx context.Context, name string, reference string, options *ContainerRegistryClientGetManifestOptions) (ContainerRegistryClientGetManifestResponse, error) {
	req, err := client.getManifestCreateRequest(ctx, name, reference, options)
	if err != nil {
		return ContainerRegistryClientGetManifestResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientGetManifestResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientGetManifestResponse{}, runtime.NewResponseError(resp)
	}
	return client.getManifestHandleResponse(resp)
}

// getManifestCreateRequest creates the GetManifest request.
func (client *ContainerRegistryClient) getManifestCreateRequest(ctx context.Context, name string, reference string, options *ContainerRegistryClientGetManifestOptions) (*policy.Request, error) {
	urlPath := "/v2/{name}/manifests/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	runtime.SkipBodyDownload(req)
	if options != nil && options.Accept != nil {
		req.Raw().Header["accept"] = []string{*options.Accept}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getManifestHandleResponse handles the GetManifest response.
func (client *ContainerRegistryClient) getManifestHandleResponse(resp *http.Response) (ContainerRegistryClientGetManifestResponse, error) {
	result := ContainerRegistryClientGetManifestResponse{Body: resp.Body}
	if val := resp.Header.Get("Docker-Content-Digest"); val != "" {
		result.DockerContentDigest = &val
	}
	return result, nil
}

// GetManifestProperties - Get manifest attributes
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - digest - Digest of a BLOB
//   - options - ContainerRegistryClientGetManifestPropertiesOptions contains the optional parameters for the ContainerRegistryClient.GetManifestProperties
//     method.
func (client *ContainerRegistryClient) getManifestProperties(ctx context.Context, name string, digest string, options *ContainerRegistryClientGetManifestPropertiesOptions) (ContainerRegistryClientGetManifestPropertiesResponse, error) {
	req, err := client.getManifestPropertiesCreateRequest(ctx, name, digest, options)
	if err != nil {
		return ContainerRegistryClientGetManifestPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientGetManifestPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientGetManifestPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getManifestPropertiesHandleResponse(resp)
}

// getManifestPropertiesCreateRequest creates the GetManifestProperties request.
func (client *ContainerRegistryClient) getManifestPropertiesCreateRequest(ctx context.Context, name string, digest string, options *ContainerRegistryClientGetManifestPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_manifests/{digest}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if digest == "" {
		return nil, errors.New("parameter digest cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{digest}", url.PathEscape(digest))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getManifestPropertiesHandleResponse handles the GetManifestProperties response.
func (client *ContainerRegistryClient) getManifestPropertiesHandleResponse(resp *http.Response) (ContainerRegistryClientGetManifestPropertiesResponse, error) {
	result := ContainerRegistryClientGetManifestPropertiesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ArtifactManifestProperties); err != nil {
		return ContainerRegistryClientGetManifestPropertiesResponse{}, err
	}
	return result, nil
}

// GetRepositoryProperties - Get repository attributes
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientGetRepositoryPropertiesOptions contains the optional parameters for the ContainerRegistryClient.GetRepositoryProperties
//     method.
func (client *ContainerRegistryClient) GetRepositoryProperties(ctx context.Context, name string, options *ContainerRegistryClientGetRepositoryPropertiesOptions) (ContainerRegistryClientGetRepositoryPropertiesResponse, error) {
	req, err := client.getRepositoryPropertiesCreateRequest(ctx, name, options)
	if err != nil {
		return ContainerRegistryClientGetRepositoryPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientGetRepositoryPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientGetRepositoryPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getRepositoryPropertiesHandleResponse(resp)
}

// getRepositoryPropertiesCreateRequest creates the GetRepositoryProperties request.
func (client *ContainerRegistryClient) getRepositoryPropertiesCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientGetRepositoryPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getRepositoryPropertiesHandleResponse handles the GetRepositoryProperties response.
func (client *ContainerRegistryClient) getRepositoryPropertiesHandleResponse(resp *http.Response) (ContainerRegistryClientGetRepositoryPropertiesResponse, error) {
	result := ContainerRegistryClientGetRepositoryPropertiesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContainerRepositoryProperties); err != nil {
		return ContainerRegistryClientGetRepositoryPropertiesResponse{}, err
	}
	return result, nil
}

// GetTagProperties - Get tag attributes by tag
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - tag - Tag name
//   - options - ContainerRegistryClientGetTagPropertiesOptions contains the optional parameters for the ContainerRegistryClient.GetTagProperties
//     method.
func (client *ContainerRegistryClient) GetTagProperties(ctx context.Context, name string, tag string, options *ContainerRegistryClientGetTagPropertiesOptions) (ContainerRegistryClientGetTagPropertiesResponse, error) {
	req, err := client.getTagPropertiesCreateRequest(ctx, name, tag, options)
	if err != nil {
		return ContainerRegistryClientGetTagPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientGetTagPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientGetTagPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getTagPropertiesHandleResponse(resp)
}

// getTagPropertiesCreateRequest creates the GetTagProperties request.
func (client *ContainerRegistryClient) getTagPropertiesCreateRequest(ctx context.Context, name string, tag string, options *ContainerRegistryClientGetTagPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_tags/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if tag == "" {
		return nil, errors.New("parameter tag cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(tag))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTagPropertiesHandleResponse handles the GetTagProperties response.
func (client *ContainerRegistryClient) getTagPropertiesHandleResponse(resp *http.Response) (ContainerRegistryClientGetTagPropertiesResponse, error) {
	result := ContainerRegistryClientGetTagPropertiesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ArtifactTagProperties); err != nil {
		return ContainerRegistryClientGetTagPropertiesResponse{}, err
	}
	return result, nil
}

// NewListManifestsPager - List manifests of a repository
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientListManifestsOptions contains the optional parameters for the ContainerRegistryClient.NewListManifestsPager
//     method.
func (client *ContainerRegistryClient) NewListManifestsPager(name string, options *ContainerRegistryClientListManifestsOptions) *runtime.Pager[ContainerRegistryClientListManifestsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ContainerRegistryClientListManifestsResponse]{
		More: func(page ContainerRegistryClientListManifestsResponse) bool {
			return page.Link != nil && len(*page.Link) > 0
		},
		Fetcher: func(ctx context.Context, page *ContainerRegistryClientListManifestsResponse) (ContainerRegistryClientListManifestsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listManifestsCreateRequest(ctx, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.Link)
			}
			if err != nil {
				return ContainerRegistryClientListManifestsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ContainerRegistryClientListManifestsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ContainerRegistryClientListManifestsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listManifestsHandleResponse(resp)
		},
	})
}

// listManifestsCreateRequest creates the ListManifests request.
func (client *ContainerRegistryClient) listManifestsCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientListManifestsOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_manifests"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Last != nil {
		reqQP.Set("last", *options.Last)
	}
	if options != nil && options.N != nil {
		reqQP.Set("n", strconv.FormatInt(int64(*options.N), 10))
	}
	reqQP.Set("api-version", "2021-07-01")
	if options != nil && options.OrderBy != nil {
		reqQP.Set("orderby", string(*options.OrderBy))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listManifestsHandleResponse handles the ListManifests response.
func (client *ContainerRegistryClient) listManifestsHandleResponse(resp *http.Response) (ContainerRegistryClientListManifestsResponse, error) {
	result := ContainerRegistryClientListManifestsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Manifests); err != nil {
		return ContainerRegistryClientListManifestsResponse{}, err
	}
	return result, nil
}

// NewListRepositoriesPager - List repositories
//
// Generated from API version 2021-07-01
//   - options - ContainerRegistryClientListRepositoriesOptions contains the optional parameters for the ContainerRegistryClient.NewListRepositoriesPager
//     method.
func (client *ContainerRegistryClient) NewListRepositoriesPager(options *ContainerRegistryClientListRepositoriesOptions) *runtime.Pager[ContainerRegistryClientListRepositoriesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ContainerRegistryClientListRepositoriesResponse]{
		More: func(page ContainerRegistryClientListRepositoriesResponse) bool {
			return page.Link != nil && len(*page.Link) > 0
		},
		Fetcher: func(ctx context.Context, page *ContainerRegistryClientListRepositoriesResponse) (ContainerRegistryClientListRepositoriesResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listRepositoriesCreateRequest(ctx, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.Link)
			}
			if err != nil {
				return ContainerRegistryClientListRepositoriesResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ContainerRegistryClientListRepositoriesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ContainerRegistryClientListRepositoriesResponse{}, runtime.NewResponseError(resp)
			}
			return client.listRepositoriesHandleResponse(resp)
		},
	})
}

// listRepositoriesCreateRequest creates the ListRepositories request.
func (client *ContainerRegistryClient) listRepositoriesCreateRequest(ctx context.Context, options *ContainerRegistryClientListRepositoriesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/_catalog"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Last != nil {
		reqQP.Set("last", *options.Last)
	}
	if options != nil && options.N != nil {
		reqQP.Set("n", strconv.FormatInt(int64(*options.N), 10))
	}
	reqQP.Set("api-version", "2021-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listRepositoriesHandleResponse handles the ListRepositories response.
func (client *ContainerRegistryClient) listRepositoriesHandleResponse(resp *http.Response) (ContainerRegistryClientListRepositoriesResponse, error) {
	result := ContainerRegistryClientListRepositoriesResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Repositories); err != nil {
		return ContainerRegistryClientListRepositoriesResponse{}, err
	}
	return result, nil
}

// NewListTagsPager - List tags of a repository
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientListTagsOptions contains the optional parameters for the ContainerRegistryClient.NewListTagsPager
//     method.
func (client *ContainerRegistryClient) NewListTagsPager(name string, options *ContainerRegistryClientListTagsOptions) *runtime.Pager[ContainerRegistryClientListTagsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ContainerRegistryClientListTagsResponse]{
		More: func(page ContainerRegistryClientListTagsResponse) bool {
			return page.Link != nil && len(*page.Link) > 0
		},
		Fetcher: func(ctx context.Context, page *ContainerRegistryClientListTagsResponse) (ContainerRegistryClientListTagsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listTagsCreateRequest(ctx, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.Link)
			}
			if err != nil {
				return ContainerRegistryClientListTagsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ContainerRegistryClientListTagsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ContainerRegistryClientListTagsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listTagsHandleResponse(resp)
		},
	})
}

// listTagsCreateRequest creates the ListTags request.
func (client *ContainerRegistryClient) listTagsCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientListTagsOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_tags"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Last != nil {
		reqQP.Set("last", *options.Last)
	}
	if options != nil && options.N != nil {
		reqQP.Set("n", strconv.FormatInt(int64(*options.N), 10))
	}
	if options != nil && options.Digest != nil {
		reqQP.Set("digest", *options.Digest)
	}
	reqQP.Set("api-version", "2021-07-01")
	if options != nil && options.OrderBy != nil {
		reqQP.Set("orderby", string(*options.OrderBy))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listTagsHandleResponse handles the ListTags response.
func (client *ContainerRegistryClient) listTagsHandleResponse(resp *http.Response) (ContainerRegistryClientListTagsResponse, error) {
	result := ContainerRegistryClientListTagsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TagList); err != nil {
		return ContainerRegistryClientListTagsResponse{}, err
	}
	return result, nil
}

// UpdateManifestProperties - Update properties of a manifest
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - digest - Digest of a BLOB
//   - options - ContainerRegistryClientUpdateManifestPropertiesOptions contains the optional parameters for the ContainerRegistryClient.UpdateManifestProperties
//     method.
func (client *ContainerRegistryClient) updateManifestProperties(ctx context.Context, name string, digest string, options *ContainerRegistryClientUpdateManifestPropertiesOptions) (ContainerRegistryClientUpdateManifestPropertiesResponse, error) {
	req, err := client.updateManifestPropertiesCreateRequest(ctx, name, digest, options)
	if err != nil {
		return ContainerRegistryClientUpdateManifestPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientUpdateManifestPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientUpdateManifestPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateManifestPropertiesHandleResponse(resp)
}

// updateManifestPropertiesCreateRequest creates the UpdateManifestProperties request.
func (client *ContainerRegistryClient) updateManifestPropertiesCreateRequest(ctx context.Context, name string, digest string, options *ContainerRegistryClientUpdateManifestPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_manifests/{digest}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if digest == "" {
		return nil, errors.New("parameter digest cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{digest}", url.PathEscape(digest))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Value != nil {
		return req, runtime.MarshalAsJSON(req, *options.Value)
	}
	return req, nil
}

// updateManifestPropertiesHandleResponse handles the UpdateManifestProperties response.
func (client *ContainerRegistryClient) updateManifestPropertiesHandleResponse(resp *http.Response) (ContainerRegistryClientUpdateManifestPropertiesResponse, error) {
	result := ContainerRegistryClientUpdateManifestPropertiesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ArtifactManifestProperties); err != nil {
		return ContainerRegistryClientUpdateManifestPropertiesResponse{}, err
	}
	return result, nil
}

// UpdateRepositoryProperties - Update the attribute identified by name where reference is the name of the repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientUpdateRepositoryPropertiesOptions contains the optional parameters for the ContainerRegistryClient.UpdateRepositoryProperties
//     method.
func (client *ContainerRegistryClient) UpdateRepositoryProperties(ctx context.Context, name string, options *ContainerRegistryClientUpdateRepositoryPropertiesOptions) (ContainerRegistryClientUpdateRepositoryPropertiesResponse, error) {
	req, err := client.updateRepositoryPropertiesCreateRequest(ctx, name, options)
	if err != nil {
		return ContainerRegistryClientUpdateRepositoryPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientUpdateRepositoryPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientUpdateRepositoryPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateRepositoryPropertiesHandleResponse(resp)
}

// updateRepositoryPropertiesCreateRequest creates the UpdateRepositoryProperties request.
func (client *ContainerRegistryClient) updateRepositoryPropertiesCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientUpdateRepositoryPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Value != nil {
		return req, runtime.MarshalAsJSON(req, *options.Value)
	}
	return req, nil
}

// updateRepositoryPropertiesHandleResponse handles the UpdateRepositoryProperties response.
func (client *ContainerRegistryClient) updateRepositoryPropertiesHandleResponse(resp *http.Response) (ContainerRegistryClientUpdateRepositoryPropertiesResponse, error) {
	result := ContainerRegistryClientUpdateRepositoryPropertiesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContainerRepositoryProperties); err != nil {
		return ContainerRegistryClientUpdateRepositoryPropertiesResponse{}, err
	}
	return result, nil
}

// UpdateTagProperties - Update tag attributes
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - tag - Tag name
//   - options - ContainerRegistryClientUpdateTagPropertiesOptions contains the optional parameters for the ContainerRegistryClient.UpdateTagProperties
//     method.
func (client *ContainerRegistryClient) UpdateTagProperties(ctx context.Context, name string, tag string, options *ContainerRegistryClientUpdateTagPropertiesOptions) (ContainerRegistryClientUpdateTagPropertiesResponse, error) {
	req, err := client.updateTagPropertiesCreateRequest(ctx, name, tag, options)
	if err != nil {
		return ContainerRegistryClientUpdateTagPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientUpdateTagPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientUpdateTagPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateTagPropertiesHandleResponse(resp)
}

// updateTagPropertiesCreateRequest creates the UpdateTagProperties request.
func (client *ContainerRegistryClient) updateTagPropertiesCreateRequest(ctx context.Context, name string, tag string, options *ContainerRegistryClientUpdateTagPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_tags/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if tag == "" {
		return nil, errors.New("parameter tag cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(tag))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Value != nil {
		return req, runtime.MarshalAsJSON(req, *options.Value)
	}
	return req, nil
}

// updateTagPropertiesHandleResponse handles the UpdateTagProperties response.
func (client *ContainerRegistryClient) updateTagPropertiesHandleResponse(resp *http.Response) (ContainerRegistryClientUpdateTagPropertiesResponse, error) {
	result := ContainerRegistryClientUpdateTagPropertiesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ArtifactTagProperties); err != nil {
		return ContainerRegistryClientUpdateTagPropertiesResponse{}, err
	}
	return result, nil
}

// UploadManifest - Put the manifest identified by name and reference where reference can be a tag or digest.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - A tag or a digest, pointing to a specific image
//   - contentType - Upload file type
//   - payload - Manifest body, can take v1 or v2 values depending on accept header
//   - options - ContainerRegistryClientUploadManifestOptions contains the optional parameters for the ContainerRegistryClient.UploadManifest
//     method.
func (client *ContainerRegistryClient) UploadManifest(ctx context.Context, name string, reference string, contentType ContentType, payload io.ReadSeekCloser, options *ContainerRegistryClientUploadManifestOptions) (ContainerRegistryClientUploadManifestResponse, error) {
	req, err := client.uploadManifestCreateRequest(ctx, name, reference, contentType, payload, options)
	if err != nil {
		return ContainerRegistryClientUploadManifestResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientUploadManifestResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ContainerRegistryClientUploadManifestResponse{}, runtime.NewResponseError(resp)
	}
	return client.uploadManifestHandleResponse(resp)
}

// uploadManifestCreateRequest creates the UploadManifest request.
func (client *ContainerRegistryClient) uploadManifestCreateRequest(ctx context.Context, name string, reference string, contentType ContentType, payload io.ReadSeekCloser, options *ContainerRegistryClientUploadManifestOptions) (*policy.Request, error) {
	urlPath := "/v2/{name}/manifests/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{string(contentType)}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, req.SetBody(payload, string(contentType))
}

// uploadManifestHandleResponse handles the UploadManifest response.
func (client *ContainerRegistryClient) uploadManifestHandleResponse(resp *http.Response) (ContainerRegistryClientUploadManifestResponse, error) {
	result := ContainerRegistryClientUploadManifestResponse{}
	if val := resp.Header.Get("Docker-Content-Digest"); val != "" {
		result.DockerContentDigest = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return ContainerRegistryClientUploadManifestResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	return result, nil
}
