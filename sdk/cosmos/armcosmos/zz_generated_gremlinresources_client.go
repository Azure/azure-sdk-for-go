// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcosmos

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// GremlinResourcesClient contains the methods for the GremlinResources group.
// Don't use this type directly, use NewGremlinResourcesClient() instead.
type GremlinResourcesClient struct {
	con            *armcore.Connection
	subscriptionID string
}

// NewGremlinResourcesClient creates a new instance of GremlinResourcesClient with the specified values.
func NewGremlinResourcesClient(con *armcore.Connection, subscriptionID string) *GremlinResourcesClient {
	return &GremlinResourcesClient{con: con, subscriptionID: subscriptionID}
}

// BeginCreateUpdateGremlinDatabase - Create or update an Azure Cosmos DB Gremlin database
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) BeginCreateUpdateGremlinDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, createUpdateGremlinDatabaseParameters GremlinDatabaseCreateUpdateParameters, options *GremlinResourcesBeginCreateUpdateGremlinDatabaseOptions) (GremlinResourcesCreateUpdateGremlinDatabasePollerResponse, error) {
	resp, err := client.createUpdateGremlinDatabase(ctx, resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinDatabasePollerResponse{}, err
	}
	result := GremlinResourcesCreateUpdateGremlinDatabasePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("GremlinResourcesClient.CreateUpdateGremlinDatabase", "", resp, client.con.Pipeline(), client.createUpdateGremlinDatabaseHandleError)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinDatabasePollerResponse{}, err
	}
	poller := &gremlinResourcesCreateUpdateGremlinDatabasePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesCreateUpdateGremlinDatabaseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateUpdateGremlinDatabase creates a new GremlinResourcesCreateUpdateGremlinDatabasePoller from the specified resume token.
// token - The value must come from a previous call to GremlinResourcesCreateUpdateGremlinDatabasePoller.ResumeToken().
func (client *GremlinResourcesClient) ResumeCreateUpdateGremlinDatabase(ctx context.Context, token string) (GremlinResourcesCreateUpdateGremlinDatabasePollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("GremlinResourcesClient.CreateUpdateGremlinDatabase", token, client.con.Pipeline(), client.createUpdateGremlinDatabaseHandleError)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinDatabasePollerResponse{}, err
	}
	poller := &gremlinResourcesCreateUpdateGremlinDatabasePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinDatabasePollerResponse{}, err
	}
	result := GremlinResourcesCreateUpdateGremlinDatabasePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesCreateUpdateGremlinDatabaseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateUpdateGremlinDatabase - Create or update an Azure Cosmos DB Gremlin database
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) createUpdateGremlinDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, createUpdateGremlinDatabaseParameters GremlinDatabaseCreateUpdateParameters, options *GremlinResourcesBeginCreateUpdateGremlinDatabaseOptions) (*azcore.Response, error) {
	req, err := client.createUpdateGremlinDatabaseCreateRequest(ctx, resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.createUpdateGremlinDatabaseHandleError(resp)
	}
	return resp, nil
}

// createUpdateGremlinDatabaseCreateRequest creates the CreateUpdateGremlinDatabase request.
func (client *GremlinResourcesClient) createUpdateGremlinDatabaseCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, createUpdateGremlinDatabaseParameters GremlinDatabaseCreateUpdateParameters, options *GremlinResourcesBeginCreateUpdateGremlinDatabaseOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(createUpdateGremlinDatabaseParameters)
}

// createUpdateGremlinDatabaseHandleError handles the CreateUpdateGremlinDatabase error response.
func (client *GremlinResourcesClient) createUpdateGremlinDatabaseHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// BeginCreateUpdateGremlinGraph - Create or update an Azure Cosmos DB Gremlin graph
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) BeginCreateUpdateGremlinGraph(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, createUpdateGremlinGraphParameters GremlinGraphCreateUpdateParameters, options *GremlinResourcesBeginCreateUpdateGremlinGraphOptions) (GremlinResourcesCreateUpdateGremlinGraphPollerResponse, error) {
	resp, err := client.createUpdateGremlinGraph(ctx, resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinGraphPollerResponse{}, err
	}
	result := GremlinResourcesCreateUpdateGremlinGraphPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("GremlinResourcesClient.CreateUpdateGremlinGraph", "", resp, client.con.Pipeline(), client.createUpdateGremlinGraphHandleError)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinGraphPollerResponse{}, err
	}
	poller := &gremlinResourcesCreateUpdateGremlinGraphPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesCreateUpdateGremlinGraphResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateUpdateGremlinGraph creates a new GremlinResourcesCreateUpdateGremlinGraphPoller from the specified resume token.
// token - The value must come from a previous call to GremlinResourcesCreateUpdateGremlinGraphPoller.ResumeToken().
func (client *GremlinResourcesClient) ResumeCreateUpdateGremlinGraph(ctx context.Context, token string) (GremlinResourcesCreateUpdateGremlinGraphPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("GremlinResourcesClient.CreateUpdateGremlinGraph", token, client.con.Pipeline(), client.createUpdateGremlinGraphHandleError)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinGraphPollerResponse{}, err
	}
	poller := &gremlinResourcesCreateUpdateGremlinGraphPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinGraphPollerResponse{}, err
	}
	result := GremlinResourcesCreateUpdateGremlinGraphPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesCreateUpdateGremlinGraphResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateUpdateGremlinGraph - Create or update an Azure Cosmos DB Gremlin graph
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) createUpdateGremlinGraph(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, createUpdateGremlinGraphParameters GremlinGraphCreateUpdateParameters, options *GremlinResourcesBeginCreateUpdateGremlinGraphOptions) (*azcore.Response, error) {
	req, err := client.createUpdateGremlinGraphCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.createUpdateGremlinGraphHandleError(resp)
	}
	return resp, nil
}

// createUpdateGremlinGraphCreateRequest creates the CreateUpdateGremlinGraph request.
func (client *GremlinResourcesClient) createUpdateGremlinGraphCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, createUpdateGremlinGraphParameters GremlinGraphCreateUpdateParameters, options *GremlinResourcesBeginCreateUpdateGremlinGraphOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(createUpdateGremlinGraphParameters)
}

// createUpdateGremlinGraphHandleError handles the CreateUpdateGremlinGraph error response.
func (client *GremlinResourcesClient) createUpdateGremlinGraphHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// BeginDeleteGremlinDatabase - Deletes an existing Azure Cosmos DB Gremlin database.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) BeginDeleteGremlinDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginDeleteGremlinDatabaseOptions) (GremlinResourcesDeleteGremlinDatabasePollerResponse, error) {
	resp, err := client.deleteGremlinDatabase(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return GremlinResourcesDeleteGremlinDatabasePollerResponse{}, err
	}
	result := GremlinResourcesDeleteGremlinDatabasePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("GremlinResourcesClient.DeleteGremlinDatabase", "", resp, client.con.Pipeline(), client.deleteGremlinDatabaseHandleError)
	if err != nil {
		return GremlinResourcesDeleteGremlinDatabasePollerResponse{}, err
	}
	poller := &gremlinResourcesDeleteGremlinDatabasePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesDeleteGremlinDatabaseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteGremlinDatabase creates a new GremlinResourcesDeleteGremlinDatabasePoller from the specified resume token.
// token - The value must come from a previous call to GremlinResourcesDeleteGremlinDatabasePoller.ResumeToken().
func (client *GremlinResourcesClient) ResumeDeleteGremlinDatabase(ctx context.Context, token string) (GremlinResourcesDeleteGremlinDatabasePollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("GremlinResourcesClient.DeleteGremlinDatabase", token, client.con.Pipeline(), client.deleteGremlinDatabaseHandleError)
	if err != nil {
		return GremlinResourcesDeleteGremlinDatabasePollerResponse{}, err
	}
	poller := &gremlinResourcesDeleteGremlinDatabasePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return GremlinResourcesDeleteGremlinDatabasePollerResponse{}, err
	}
	result := GremlinResourcesDeleteGremlinDatabasePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesDeleteGremlinDatabaseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteGremlinDatabase - Deletes an existing Azure Cosmos DB Gremlin database.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) deleteGremlinDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginDeleteGremlinDatabaseOptions) (*azcore.Response, error) {
	req, err := client.deleteGremlinDatabaseCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteGremlinDatabaseHandleError(resp)
	}
	return resp, nil
}

// deleteGremlinDatabaseCreateRequest creates the DeleteGremlinDatabase request.
func (client *GremlinResourcesClient) deleteGremlinDatabaseCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginDeleteGremlinDatabaseOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	return req, nil
}

// deleteGremlinDatabaseHandleError handles the DeleteGremlinDatabase error response.
func (client *GremlinResourcesClient) deleteGremlinDatabaseHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// BeginDeleteGremlinGraph - Deletes an existing Azure Cosmos DB Gremlin graph.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) BeginDeleteGremlinGraph(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginDeleteGremlinGraphOptions) (GremlinResourcesDeleteGremlinGraphPollerResponse, error) {
	resp, err := client.deleteGremlinGraph(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return GremlinResourcesDeleteGremlinGraphPollerResponse{}, err
	}
	result := GremlinResourcesDeleteGremlinGraphPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("GremlinResourcesClient.DeleteGremlinGraph", "", resp, client.con.Pipeline(), client.deleteGremlinGraphHandleError)
	if err != nil {
		return GremlinResourcesDeleteGremlinGraphPollerResponse{}, err
	}
	poller := &gremlinResourcesDeleteGremlinGraphPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesDeleteGremlinGraphResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteGremlinGraph creates a new GremlinResourcesDeleteGremlinGraphPoller from the specified resume token.
// token - The value must come from a previous call to GremlinResourcesDeleteGremlinGraphPoller.ResumeToken().
func (client *GremlinResourcesClient) ResumeDeleteGremlinGraph(ctx context.Context, token string) (GremlinResourcesDeleteGremlinGraphPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("GremlinResourcesClient.DeleteGremlinGraph", token, client.con.Pipeline(), client.deleteGremlinGraphHandleError)
	if err != nil {
		return GremlinResourcesDeleteGremlinGraphPollerResponse{}, err
	}
	poller := &gremlinResourcesDeleteGremlinGraphPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return GremlinResourcesDeleteGremlinGraphPollerResponse{}, err
	}
	result := GremlinResourcesDeleteGremlinGraphPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesDeleteGremlinGraphResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteGremlinGraph - Deletes an existing Azure Cosmos DB Gremlin graph.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) deleteGremlinGraph(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginDeleteGremlinGraphOptions) (*azcore.Response, error) {
	req, err := client.deleteGremlinGraphCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteGremlinGraphHandleError(resp)
	}
	return resp, nil
}

// deleteGremlinGraphCreateRequest creates the DeleteGremlinGraph request.
func (client *GremlinResourcesClient) deleteGremlinGraphCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginDeleteGremlinGraphOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	return req, nil
}

// deleteGremlinGraphHandleError handles the DeleteGremlinGraph error response.
func (client *GremlinResourcesClient) deleteGremlinGraphHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetGremlinDatabase - Gets the Gremlin databases under an existing Azure Cosmos DB database account with the provided name.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) GetGremlinDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesGetGremlinDatabaseOptions) (GremlinResourcesGetGremlinDatabaseResponse, error) {
	req, err := client.getGremlinDatabaseCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return GremlinResourcesGetGremlinDatabaseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GremlinResourcesGetGremlinDatabaseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GremlinResourcesGetGremlinDatabaseResponse{}, client.getGremlinDatabaseHandleError(resp)
	}
	return client.getGremlinDatabaseHandleResponse(resp)
}

// getGremlinDatabaseCreateRequest creates the GetGremlinDatabase request.
func (client *GremlinResourcesClient) getGremlinDatabaseCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesGetGremlinDatabaseOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getGremlinDatabaseHandleResponse handles the GetGremlinDatabase response.
func (client *GremlinResourcesClient) getGremlinDatabaseHandleResponse(resp *azcore.Response) (GremlinResourcesGetGremlinDatabaseResponse, error) {
	result := GremlinResourcesGetGremlinDatabaseResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.GremlinDatabaseGetResults); err != nil {
		return GremlinResourcesGetGremlinDatabaseResponse{}, err
	}
	return result, nil
}

// getGremlinDatabaseHandleError handles the GetGremlinDatabase error response.
func (client *GremlinResourcesClient) getGremlinDatabaseHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetGremlinDatabaseThroughput - Gets the RUs per second of the Gremlin database under an existing Azure Cosmos DB database account with the provided name.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) GetGremlinDatabaseThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesGetGremlinDatabaseThroughputOptions) (GremlinResourcesGetGremlinDatabaseThroughputResponse, error) {
	req, err := client.getGremlinDatabaseThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return GremlinResourcesGetGremlinDatabaseThroughputResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GremlinResourcesGetGremlinDatabaseThroughputResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GremlinResourcesGetGremlinDatabaseThroughputResponse{}, client.getGremlinDatabaseThroughputHandleError(resp)
	}
	return client.getGremlinDatabaseThroughputHandleResponse(resp)
}

// getGremlinDatabaseThroughputCreateRequest creates the GetGremlinDatabaseThroughput request.
func (client *GremlinResourcesClient) getGremlinDatabaseThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesGetGremlinDatabaseThroughputOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/throughputSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getGremlinDatabaseThroughputHandleResponse handles the GetGremlinDatabaseThroughput response.
func (client *GremlinResourcesClient) getGremlinDatabaseThroughputHandleResponse(resp *azcore.Response) (GremlinResourcesGetGremlinDatabaseThroughputResponse, error) {
	result := GremlinResourcesGetGremlinDatabaseThroughputResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.ThroughputSettingsGetResults); err != nil {
		return GremlinResourcesGetGremlinDatabaseThroughputResponse{}, err
	}
	return result, nil
}

// getGremlinDatabaseThroughputHandleError handles the GetGremlinDatabaseThroughput error response.
func (client *GremlinResourcesClient) getGremlinDatabaseThroughputHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetGremlinGraph - Gets the Gremlin graph under an existing Azure Cosmos DB database account.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) GetGremlinGraph(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesGetGremlinGraphOptions) (GremlinResourcesGetGremlinGraphResponse, error) {
	req, err := client.getGremlinGraphCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return GremlinResourcesGetGremlinGraphResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GremlinResourcesGetGremlinGraphResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GremlinResourcesGetGremlinGraphResponse{}, client.getGremlinGraphHandleError(resp)
	}
	return client.getGremlinGraphHandleResponse(resp)
}

// getGremlinGraphCreateRequest creates the GetGremlinGraph request.
func (client *GremlinResourcesClient) getGremlinGraphCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesGetGremlinGraphOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getGremlinGraphHandleResponse handles the GetGremlinGraph response.
func (client *GremlinResourcesClient) getGremlinGraphHandleResponse(resp *azcore.Response) (GremlinResourcesGetGremlinGraphResponse, error) {
	result := GremlinResourcesGetGremlinGraphResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.GremlinGraphGetResults); err != nil {
		return GremlinResourcesGetGremlinGraphResponse{}, err
	}
	return result, nil
}

// getGremlinGraphHandleError handles the GetGremlinGraph error response.
func (client *GremlinResourcesClient) getGremlinGraphHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetGremlinGraphThroughput - Gets the Gremlin graph throughput under an existing Azure Cosmos DB database account with the provided name.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) GetGremlinGraphThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesGetGremlinGraphThroughputOptions) (GremlinResourcesGetGremlinGraphThroughputResponse, error) {
	req, err := client.getGremlinGraphThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return GremlinResourcesGetGremlinGraphThroughputResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GremlinResourcesGetGremlinGraphThroughputResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GremlinResourcesGetGremlinGraphThroughputResponse{}, client.getGremlinGraphThroughputHandleError(resp)
	}
	return client.getGremlinGraphThroughputHandleResponse(resp)
}

// getGremlinGraphThroughputCreateRequest creates the GetGremlinGraphThroughput request.
func (client *GremlinResourcesClient) getGremlinGraphThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesGetGremlinGraphThroughputOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/throughputSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getGremlinGraphThroughputHandleResponse handles the GetGremlinGraphThroughput response.
func (client *GremlinResourcesClient) getGremlinGraphThroughputHandleResponse(resp *azcore.Response) (GremlinResourcesGetGremlinGraphThroughputResponse, error) {
	result := GremlinResourcesGetGremlinGraphThroughputResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.ThroughputSettingsGetResults); err != nil {
		return GremlinResourcesGetGremlinGraphThroughputResponse{}, err
	}
	return result, nil
}

// getGremlinGraphThroughputHandleError handles the GetGremlinGraphThroughput error response.
func (client *GremlinResourcesClient) getGremlinGraphThroughputHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListGremlinDatabases - Lists the Gremlin databases under an existing Azure Cosmos DB database account.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) ListGremlinDatabases(ctx context.Context, resourceGroupName string, accountName string, options *GremlinResourcesListGremlinDatabasesOptions) (GremlinResourcesListGremlinDatabasesResponse, error) {
	req, err := client.listGremlinDatabasesCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return GremlinResourcesListGremlinDatabasesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GremlinResourcesListGremlinDatabasesResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GremlinResourcesListGremlinDatabasesResponse{}, client.listGremlinDatabasesHandleError(resp)
	}
	return client.listGremlinDatabasesHandleResponse(resp)
}

// listGremlinDatabasesCreateRequest creates the ListGremlinDatabases request.
func (client *GremlinResourcesClient) listGremlinDatabasesCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *GremlinResourcesListGremlinDatabasesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listGremlinDatabasesHandleResponse handles the ListGremlinDatabases response.
func (client *GremlinResourcesClient) listGremlinDatabasesHandleResponse(resp *azcore.Response) (GremlinResourcesListGremlinDatabasesResponse, error) {
	result := GremlinResourcesListGremlinDatabasesResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.GremlinDatabaseListResult); err != nil {
		return GremlinResourcesListGremlinDatabasesResponse{}, err
	}
	return result, nil
}

// listGremlinDatabasesHandleError handles the ListGremlinDatabases error response.
func (client *GremlinResourcesClient) listGremlinDatabasesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListGremlinGraphs - Lists the Gremlin graph under an existing Azure Cosmos DB database account.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) ListGremlinGraphs(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesListGremlinGraphsOptions) (GremlinResourcesListGremlinGraphsResponse, error) {
	req, err := client.listGremlinGraphsCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return GremlinResourcesListGremlinGraphsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GremlinResourcesListGremlinGraphsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GremlinResourcesListGremlinGraphsResponse{}, client.listGremlinGraphsHandleError(resp)
	}
	return client.listGremlinGraphsHandleResponse(resp)
}

// listGremlinGraphsCreateRequest creates the ListGremlinGraphs request.
func (client *GremlinResourcesClient) listGremlinGraphsCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesListGremlinGraphsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listGremlinGraphsHandleResponse handles the ListGremlinGraphs response.
func (client *GremlinResourcesClient) listGremlinGraphsHandleResponse(resp *azcore.Response) (GremlinResourcesListGremlinGraphsResponse, error) {
	result := GremlinResourcesListGremlinGraphsResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.GremlinGraphListResult); err != nil {
		return GremlinResourcesListGremlinGraphsResponse{}, err
	}
	return result, nil
}

// listGremlinGraphsHandleError handles the ListGremlinGraphs error response.
func (client *GremlinResourcesClient) listGremlinGraphsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// BeginMigrateGremlinDatabaseToAutoscale - Migrate an Azure Cosmos DB Gremlin database from manual throughput to autoscale
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) BeginMigrateGremlinDatabaseToAutoscale(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginMigrateGremlinDatabaseToAutoscaleOptions) (GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse, error) {
	resp, err := client.migrateGremlinDatabaseToAutoscale(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse{}, err
	}
	result := GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("GremlinResourcesClient.MigrateGremlinDatabaseToAutoscale", "", resp, client.con.Pipeline(), client.migrateGremlinDatabaseToAutoscaleHandleError)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse{}, err
	}
	poller := &gremlinResourcesMigrateGremlinDatabaseToAutoscalePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeMigrateGremlinDatabaseToAutoscale creates a new GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller from the specified resume token.
// token - The value must come from a previous call to GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller.ResumeToken().
func (client *GremlinResourcesClient) ResumeMigrateGremlinDatabaseToAutoscale(ctx context.Context, token string) (GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("GremlinResourcesClient.MigrateGremlinDatabaseToAutoscale", token, client.con.Pipeline(), client.migrateGremlinDatabaseToAutoscaleHandleError)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse{}, err
	}
	poller := &gremlinResourcesMigrateGremlinDatabaseToAutoscalePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse{}, err
	}
	result := GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// MigrateGremlinDatabaseToAutoscale - Migrate an Azure Cosmos DB Gremlin database from manual throughput to autoscale
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) migrateGremlinDatabaseToAutoscale(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginMigrateGremlinDatabaseToAutoscaleOptions) (*azcore.Response, error) {
	req, err := client.migrateGremlinDatabaseToAutoscaleCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.migrateGremlinDatabaseToAutoscaleHandleError(resp)
	}
	return resp, nil
}

// migrateGremlinDatabaseToAutoscaleCreateRequest creates the MigrateGremlinDatabaseToAutoscale request.
func (client *GremlinResourcesClient) migrateGremlinDatabaseToAutoscaleCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginMigrateGremlinDatabaseToAutoscaleOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// migrateGremlinDatabaseToAutoscaleHandleError handles the MigrateGremlinDatabaseToAutoscale error response.
func (client *GremlinResourcesClient) migrateGremlinDatabaseToAutoscaleHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginMigrateGremlinDatabaseToManualThroughput - Migrate an Azure Cosmos DB Gremlin database from autoscale to manual throughput
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) BeginMigrateGremlinDatabaseToManualThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginMigrateGremlinDatabaseToManualThroughputOptions) (GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse, error) {
	resp, err := client.migrateGremlinDatabaseToManualThroughput(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse{}, err
	}
	result := GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("GremlinResourcesClient.MigrateGremlinDatabaseToManualThroughput", "", resp, client.con.Pipeline(), client.migrateGremlinDatabaseToManualThroughputHandleError)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse{}, err
	}
	poller := &gremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeMigrateGremlinDatabaseToManualThroughput creates a new GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller from the specified resume token.
// token - The value must come from a previous call to GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller.ResumeToken().
func (client *GremlinResourcesClient) ResumeMigrateGremlinDatabaseToManualThroughput(ctx context.Context, token string) (GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("GremlinResourcesClient.MigrateGremlinDatabaseToManualThroughput", token, client.con.Pipeline(), client.migrateGremlinDatabaseToManualThroughputHandleError)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse{}, err
	}
	poller := &gremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse{}, err
	}
	result := GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// MigrateGremlinDatabaseToManualThroughput - Migrate an Azure Cosmos DB Gremlin database from autoscale to manual throughput
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) migrateGremlinDatabaseToManualThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginMigrateGremlinDatabaseToManualThroughputOptions) (*azcore.Response, error) {
	req, err := client.migrateGremlinDatabaseToManualThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.migrateGremlinDatabaseToManualThroughputHandleError(resp)
	}
	return resp, nil
}

// migrateGremlinDatabaseToManualThroughputCreateRequest creates the MigrateGremlinDatabaseToManualThroughput request.
func (client *GremlinResourcesClient) migrateGremlinDatabaseToManualThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginMigrateGremlinDatabaseToManualThroughputOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// migrateGremlinDatabaseToManualThroughputHandleError handles the MigrateGremlinDatabaseToManualThroughput error response.
func (client *GremlinResourcesClient) migrateGremlinDatabaseToManualThroughputHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginMigrateGremlinGraphToAutoscale - Migrate an Azure Cosmos DB Gremlin graph from manual throughput to autoscale
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) BeginMigrateGremlinGraphToAutoscale(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginMigrateGremlinGraphToAutoscaleOptions) (GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse, error) {
	resp, err := client.migrateGremlinGraphToAutoscale(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse{}, err
	}
	result := GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("GremlinResourcesClient.MigrateGremlinGraphToAutoscale", "", resp, client.con.Pipeline(), client.migrateGremlinGraphToAutoscaleHandleError)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse{}, err
	}
	poller := &gremlinResourcesMigrateGremlinGraphToAutoscalePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesMigrateGremlinGraphToAutoscaleResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeMigrateGremlinGraphToAutoscale creates a new GremlinResourcesMigrateGremlinGraphToAutoscalePoller from the specified resume token.
// token - The value must come from a previous call to GremlinResourcesMigrateGremlinGraphToAutoscalePoller.ResumeToken().
func (client *GremlinResourcesClient) ResumeMigrateGremlinGraphToAutoscale(ctx context.Context, token string) (GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("GremlinResourcesClient.MigrateGremlinGraphToAutoscale", token, client.con.Pipeline(), client.migrateGremlinGraphToAutoscaleHandleError)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse{}, err
	}
	poller := &gremlinResourcesMigrateGremlinGraphToAutoscalePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse{}, err
	}
	result := GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesMigrateGremlinGraphToAutoscaleResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// MigrateGremlinGraphToAutoscale - Migrate an Azure Cosmos DB Gremlin graph from manual throughput to autoscale
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) migrateGremlinGraphToAutoscale(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginMigrateGremlinGraphToAutoscaleOptions) (*azcore.Response, error) {
	req, err := client.migrateGremlinGraphToAutoscaleCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.migrateGremlinGraphToAutoscaleHandleError(resp)
	}
	return resp, nil
}

// migrateGremlinGraphToAutoscaleCreateRequest creates the MigrateGremlinGraphToAutoscale request.
func (client *GremlinResourcesClient) migrateGremlinGraphToAutoscaleCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginMigrateGremlinGraphToAutoscaleOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/throughputSettings/default/migrateToAutoscale"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// migrateGremlinGraphToAutoscaleHandleError handles the MigrateGremlinGraphToAutoscale error response.
func (client *GremlinResourcesClient) migrateGremlinGraphToAutoscaleHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginMigrateGremlinGraphToManualThroughput - Migrate an Azure Cosmos DB Gremlin graph from autoscale to manual throughput
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) BeginMigrateGremlinGraphToManualThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginMigrateGremlinGraphToManualThroughputOptions) (GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse, error) {
	resp, err := client.migrateGremlinGraphToManualThroughput(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse{}, err
	}
	result := GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("GremlinResourcesClient.MigrateGremlinGraphToManualThroughput", "", resp, client.con.Pipeline(), client.migrateGremlinGraphToManualThroughputHandleError)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse{}, err
	}
	poller := &gremlinResourcesMigrateGremlinGraphToManualThroughputPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesMigrateGremlinGraphToManualThroughputResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeMigrateGremlinGraphToManualThroughput creates a new GremlinResourcesMigrateGremlinGraphToManualThroughputPoller from the specified resume token.
// token - The value must come from a previous call to GremlinResourcesMigrateGremlinGraphToManualThroughputPoller.ResumeToken().
func (client *GremlinResourcesClient) ResumeMigrateGremlinGraphToManualThroughput(ctx context.Context, token string) (GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("GremlinResourcesClient.MigrateGremlinGraphToManualThroughput", token, client.con.Pipeline(), client.migrateGremlinGraphToManualThroughputHandleError)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse{}, err
	}
	poller := &gremlinResourcesMigrateGremlinGraphToManualThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse{}, err
	}
	result := GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesMigrateGremlinGraphToManualThroughputResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// MigrateGremlinGraphToManualThroughput - Migrate an Azure Cosmos DB Gremlin graph from autoscale to manual throughput
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) migrateGremlinGraphToManualThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginMigrateGremlinGraphToManualThroughputOptions) (*azcore.Response, error) {
	req, err := client.migrateGremlinGraphToManualThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.migrateGremlinGraphToManualThroughputHandleError(resp)
	}
	return resp, nil
}

// migrateGremlinGraphToManualThroughputCreateRequest creates the MigrateGremlinGraphToManualThroughput request.
func (client *GremlinResourcesClient) migrateGremlinGraphToManualThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginMigrateGremlinGraphToManualThroughputOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/throughputSettings/default/migrateToManualThroughput"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// migrateGremlinGraphToManualThroughputHandleError handles the MigrateGremlinGraphToManualThroughput error response.
func (client *GremlinResourcesClient) migrateGremlinGraphToManualThroughputHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginUpdateGremlinDatabaseThroughput - Update RUs per second of an Azure Cosmos DB Gremlin database
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) BeginUpdateGremlinDatabaseThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *GremlinResourcesBeginUpdateGremlinDatabaseThroughputOptions) (GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse, error) {
	resp, err := client.updateGremlinDatabaseThroughput(ctx, resourceGroupName, accountName, databaseName, updateThroughputParameters, options)
	if err != nil {
		return GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse{}, err
	}
	result := GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("GremlinResourcesClient.UpdateGremlinDatabaseThroughput", "", resp, client.con.Pipeline(), client.updateGremlinDatabaseThroughputHandleError)
	if err != nil {
		return GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse{}, err
	}
	poller := &gremlinResourcesUpdateGremlinDatabaseThroughputPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesUpdateGremlinDatabaseThroughputResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeUpdateGremlinDatabaseThroughput creates a new GremlinResourcesUpdateGremlinDatabaseThroughputPoller from the specified resume token.
// token - The value must come from a previous call to GremlinResourcesUpdateGremlinDatabaseThroughputPoller.ResumeToken().
func (client *GremlinResourcesClient) ResumeUpdateGremlinDatabaseThroughput(ctx context.Context, token string) (GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("GremlinResourcesClient.UpdateGremlinDatabaseThroughput", token, client.con.Pipeline(), client.updateGremlinDatabaseThroughputHandleError)
	if err != nil {
		return GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse{}, err
	}
	poller := &gremlinResourcesUpdateGremlinDatabaseThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse{}, err
	}
	result := GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesUpdateGremlinDatabaseThroughputResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// UpdateGremlinDatabaseThroughput - Update RUs per second of an Azure Cosmos DB Gremlin database
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) updateGremlinDatabaseThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *GremlinResourcesBeginUpdateGremlinDatabaseThroughputOptions) (*azcore.Response, error) {
	req, err := client.updateGremlinDatabaseThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, updateThroughputParameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.updateGremlinDatabaseThroughputHandleError(resp)
	}
	return resp, nil
}

// updateGremlinDatabaseThroughputCreateRequest creates the UpdateGremlinDatabaseThroughput request.
func (client *GremlinResourcesClient) updateGremlinDatabaseThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *GremlinResourcesBeginUpdateGremlinDatabaseThroughputOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/throughputSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(updateThroughputParameters)
}

// updateGremlinDatabaseThroughputHandleError handles the UpdateGremlinDatabaseThroughput error response.
func (client *GremlinResourcesClient) updateGremlinDatabaseThroughputHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// BeginUpdateGremlinGraphThroughput - Update RUs per second of an Azure Cosmos DB Gremlin graph
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) BeginUpdateGremlinGraphThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *GremlinResourcesBeginUpdateGremlinGraphThroughputOptions) (GremlinResourcesUpdateGremlinGraphThroughputPollerResponse, error) {
	resp, err := client.updateGremlinGraphThroughput(ctx, resourceGroupName, accountName, databaseName, graphName, updateThroughputParameters, options)
	if err != nil {
		return GremlinResourcesUpdateGremlinGraphThroughputPollerResponse{}, err
	}
	result := GremlinResourcesUpdateGremlinGraphThroughputPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("GremlinResourcesClient.UpdateGremlinGraphThroughput", "", resp, client.con.Pipeline(), client.updateGremlinGraphThroughputHandleError)
	if err != nil {
		return GremlinResourcesUpdateGremlinGraphThroughputPollerResponse{}, err
	}
	poller := &gremlinResourcesUpdateGremlinGraphThroughputPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesUpdateGremlinGraphThroughputResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeUpdateGremlinGraphThroughput creates a new GremlinResourcesUpdateGremlinGraphThroughputPoller from the specified resume token.
// token - The value must come from a previous call to GremlinResourcesUpdateGremlinGraphThroughputPoller.ResumeToken().
func (client *GremlinResourcesClient) ResumeUpdateGremlinGraphThroughput(ctx context.Context, token string) (GremlinResourcesUpdateGremlinGraphThroughputPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("GremlinResourcesClient.UpdateGremlinGraphThroughput", token, client.con.Pipeline(), client.updateGremlinGraphThroughputHandleError)
	if err != nil {
		return GremlinResourcesUpdateGremlinGraphThroughputPollerResponse{}, err
	}
	poller := &gremlinResourcesUpdateGremlinGraphThroughputPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return GremlinResourcesUpdateGremlinGraphThroughputPollerResponse{}, err
	}
	result := GremlinResourcesUpdateGremlinGraphThroughputPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (GremlinResourcesUpdateGremlinGraphThroughputResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// UpdateGremlinGraphThroughput - Update RUs per second of an Azure Cosmos DB Gremlin graph
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) updateGremlinGraphThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *GremlinResourcesBeginUpdateGremlinGraphThroughputOptions) (*azcore.Response, error) {
	req, err := client.updateGremlinGraphThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, updateThroughputParameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.updateGremlinGraphThroughputHandleError(resp)
	}
	return resp, nil
}

// updateGremlinGraphThroughputCreateRequest creates the UpdateGremlinGraphThroughput request.
func (client *GremlinResourcesClient) updateGremlinGraphThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *GremlinResourcesBeginUpdateGremlinGraphThroughputOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/throughputSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(updateThroughputParameters)
}

// updateGremlinGraphThroughputHandleError handles the UpdateGremlinGraphThroughput error response.
func (client *GremlinResourcesClient) updateGremlinGraphThroughputHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}
