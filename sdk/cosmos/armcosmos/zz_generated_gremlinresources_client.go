//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcosmos

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// GremlinResourcesClient contains the methods for the GremlinResources group.
// Don't use this type directly, use NewGremlinResourcesClient() instead.
type GremlinResourcesClient struct {
	ep             string
	pl             runtime.Pipeline
	subscriptionID string
}

// NewGremlinResourcesClient creates a new instance of GremlinResourcesClient with the specified values.
func NewGremlinResourcesClient(con *arm.Connection, subscriptionID string) *GremlinResourcesClient {
	return &GremlinResourcesClient{ep: con.Endpoint(), pl: con.NewPipeline(module, version), subscriptionID: subscriptionID}
}

// BeginCreateUpdateGremlinDatabase - Create or update an Azure Cosmos DB Gremlin database
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) BeginCreateUpdateGremlinDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, createUpdateGremlinDatabaseParameters GremlinDatabaseCreateUpdateParameters, options *GremlinResourcesBeginCreateUpdateGremlinDatabaseOptions) (GremlinResourcesCreateUpdateGremlinDatabasePollerResponse, error) {
	resp, err := client.createUpdateGremlinDatabase(ctx, resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinDatabasePollerResponse{}, err
	}
	result := GremlinResourcesCreateUpdateGremlinDatabasePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("GremlinResourcesClient.CreateUpdateGremlinDatabase", "", resp, client.pl, client.createUpdateGremlinDatabaseHandleError)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinDatabasePollerResponse{}, err
	}
	result.Poller = &GremlinResourcesCreateUpdateGremlinDatabasePoller{
		pt: pt,
	}
	return result, nil
}

// CreateUpdateGremlinDatabase - Create or update an Azure Cosmos DB Gremlin database
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) createUpdateGremlinDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, createUpdateGremlinDatabaseParameters GremlinDatabaseCreateUpdateParameters, options *GremlinResourcesBeginCreateUpdateGremlinDatabaseOptions) (*http.Response, error) {
	req, err := client.createUpdateGremlinDatabaseCreateRequest(ctx, resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.createUpdateGremlinDatabaseHandleError(resp)
	}
	return resp, nil
}

// createUpdateGremlinDatabaseCreateRequest creates the CreateUpdateGremlinDatabase request.
func (client *GremlinResourcesClient) createUpdateGremlinDatabaseCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, createUpdateGremlinDatabaseParameters GremlinDatabaseCreateUpdateParameters, options *GremlinResourcesBeginCreateUpdateGremlinDatabaseOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, createUpdateGremlinDatabaseParameters)
}

// createUpdateGremlinDatabaseHandleError handles the CreateUpdateGremlinDatabase error response.
func (client *GremlinResourcesClient) createUpdateGremlinDatabaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginCreateUpdateGremlinGraph - Create or update an Azure Cosmos DB Gremlin graph
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) BeginCreateUpdateGremlinGraph(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, createUpdateGremlinGraphParameters GremlinGraphCreateUpdateParameters, options *GremlinResourcesBeginCreateUpdateGremlinGraphOptions) (GremlinResourcesCreateUpdateGremlinGraphPollerResponse, error) {
	resp, err := client.createUpdateGremlinGraph(ctx, resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinGraphPollerResponse{}, err
	}
	result := GremlinResourcesCreateUpdateGremlinGraphPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("GremlinResourcesClient.CreateUpdateGremlinGraph", "", resp, client.pl, client.createUpdateGremlinGraphHandleError)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinGraphPollerResponse{}, err
	}
	result.Poller = &GremlinResourcesCreateUpdateGremlinGraphPoller{
		pt: pt,
	}
	return result, nil
}

// CreateUpdateGremlinGraph - Create or update an Azure Cosmos DB Gremlin graph
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) createUpdateGremlinGraph(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, createUpdateGremlinGraphParameters GremlinGraphCreateUpdateParameters, options *GremlinResourcesBeginCreateUpdateGremlinGraphOptions) (*http.Response, error) {
	req, err := client.createUpdateGremlinGraphCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.createUpdateGremlinGraphHandleError(resp)
	}
	return resp, nil
}

// createUpdateGremlinGraphCreateRequest creates the CreateUpdateGremlinGraph request.
func (client *GremlinResourcesClient) createUpdateGremlinGraphCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, createUpdateGremlinGraphParameters GremlinGraphCreateUpdateParameters, options *GremlinResourcesBeginCreateUpdateGremlinGraphOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, createUpdateGremlinGraphParameters)
}

// createUpdateGremlinGraphHandleError handles the CreateUpdateGremlinGraph error response.
func (client *GremlinResourcesClient) createUpdateGremlinGraphHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginDeleteGremlinDatabase - Deletes an existing Azure Cosmos DB Gremlin database.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) BeginDeleteGremlinDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginDeleteGremlinDatabaseOptions) (GremlinResourcesDeleteGremlinDatabasePollerResponse, error) {
	resp, err := client.deleteGremlinDatabase(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return GremlinResourcesDeleteGremlinDatabasePollerResponse{}, err
	}
	result := GremlinResourcesDeleteGremlinDatabasePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("GremlinResourcesClient.DeleteGremlinDatabase", "", resp, client.pl, client.deleteGremlinDatabaseHandleError)
	if err != nil {
		return GremlinResourcesDeleteGremlinDatabasePollerResponse{}, err
	}
	result.Poller = &GremlinResourcesDeleteGremlinDatabasePoller{
		pt: pt,
	}
	return result, nil
}

// DeleteGremlinDatabase - Deletes an existing Azure Cosmos DB Gremlin database.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) deleteGremlinDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginDeleteGremlinDatabaseOptions) (*http.Response, error) {
	req, err := client.deleteGremlinDatabaseCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteGremlinDatabaseHandleError(resp)
	}
	return resp, nil
}

// deleteGremlinDatabaseCreateRequest creates the DeleteGremlinDatabase request.
func (client *GremlinResourcesClient) deleteGremlinDatabaseCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginDeleteGremlinDatabaseOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// deleteGremlinDatabaseHandleError handles the DeleteGremlinDatabase error response.
func (client *GremlinResourcesClient) deleteGremlinDatabaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginDeleteGremlinGraph - Deletes an existing Azure Cosmos DB Gremlin graph.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) BeginDeleteGremlinGraph(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginDeleteGremlinGraphOptions) (GremlinResourcesDeleteGremlinGraphPollerResponse, error) {
	resp, err := client.deleteGremlinGraph(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return GremlinResourcesDeleteGremlinGraphPollerResponse{}, err
	}
	result := GremlinResourcesDeleteGremlinGraphPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("GremlinResourcesClient.DeleteGremlinGraph", "", resp, client.pl, client.deleteGremlinGraphHandleError)
	if err != nil {
		return GremlinResourcesDeleteGremlinGraphPollerResponse{}, err
	}
	result.Poller = &GremlinResourcesDeleteGremlinGraphPoller{
		pt: pt,
	}
	return result, nil
}

// DeleteGremlinGraph - Deletes an existing Azure Cosmos DB Gremlin graph.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) deleteGremlinGraph(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginDeleteGremlinGraphOptions) (*http.Response, error) {
	req, err := client.deleteGremlinGraphCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteGremlinGraphHandleError(resp)
	}
	return resp, nil
}

// deleteGremlinGraphCreateRequest creates the DeleteGremlinGraph request.
func (client *GremlinResourcesClient) deleteGremlinGraphCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginDeleteGremlinGraphOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// deleteGremlinGraphHandleError handles the DeleteGremlinGraph error response.
func (client *GremlinResourcesClient) deleteGremlinGraphHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetGremlinDatabase - Gets the Gremlin databases under an existing Azure Cosmos DB database account with the provided name.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) GetGremlinDatabase(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesGetGremlinDatabaseOptions) (GremlinResourcesGetGremlinDatabaseResponse, error) {
	req, err := client.getGremlinDatabaseCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return GremlinResourcesGetGremlinDatabaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GremlinResourcesGetGremlinDatabaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GremlinResourcesGetGremlinDatabaseResponse{}, client.getGremlinDatabaseHandleError(resp)
	}
	return client.getGremlinDatabaseHandleResponse(resp)
}

// getGremlinDatabaseCreateRequest creates the GetGremlinDatabase request.
func (client *GremlinResourcesClient) getGremlinDatabaseCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesGetGremlinDatabaseOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getGremlinDatabaseHandleResponse handles the GetGremlinDatabase response.
func (client *GremlinResourcesClient) getGremlinDatabaseHandleResponse(resp *http.Response) (GremlinResourcesGetGremlinDatabaseResponse, error) {
	result := GremlinResourcesGetGremlinDatabaseResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.GremlinDatabaseGetResults); err != nil {
		return GremlinResourcesGetGremlinDatabaseResponse{}, err
	}
	return result, nil
}

// getGremlinDatabaseHandleError handles the GetGremlinDatabase error response.
func (client *GremlinResourcesClient) getGremlinDatabaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetGremlinDatabaseThroughput - Gets the RUs per second of the Gremlin database under an existing Azure Cosmos DB database account with the provided name.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) GetGremlinDatabaseThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesGetGremlinDatabaseThroughputOptions) (GremlinResourcesGetGremlinDatabaseThroughputResponse, error) {
	req, err := client.getGremlinDatabaseThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return GremlinResourcesGetGremlinDatabaseThroughputResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GremlinResourcesGetGremlinDatabaseThroughputResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GremlinResourcesGetGremlinDatabaseThroughputResponse{}, client.getGremlinDatabaseThroughputHandleError(resp)
	}
	return client.getGremlinDatabaseThroughputHandleResponse(resp)
}

// getGremlinDatabaseThroughputCreateRequest creates the GetGremlinDatabaseThroughput request.
func (client *GremlinResourcesClient) getGremlinDatabaseThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesGetGremlinDatabaseThroughputOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/throughputSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getGremlinDatabaseThroughputHandleResponse handles the GetGremlinDatabaseThroughput response.
func (client *GremlinResourcesClient) getGremlinDatabaseThroughputHandleResponse(resp *http.Response) (GremlinResourcesGetGremlinDatabaseThroughputResponse, error) {
	result := GremlinResourcesGetGremlinDatabaseThroughputResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThroughputSettingsGetResults); err != nil {
		return GremlinResourcesGetGremlinDatabaseThroughputResponse{}, err
	}
	return result, nil
}

// getGremlinDatabaseThroughputHandleError handles the GetGremlinDatabaseThroughput error response.
func (client *GremlinResourcesClient) getGremlinDatabaseThroughputHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetGremlinGraph - Gets the Gremlin graph under an existing Azure Cosmos DB database account.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) GetGremlinGraph(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesGetGremlinGraphOptions) (GremlinResourcesGetGremlinGraphResponse, error) {
	req, err := client.getGremlinGraphCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return GremlinResourcesGetGremlinGraphResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GremlinResourcesGetGremlinGraphResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GremlinResourcesGetGremlinGraphResponse{}, client.getGremlinGraphHandleError(resp)
	}
	return client.getGremlinGraphHandleResponse(resp)
}

// getGremlinGraphCreateRequest creates the GetGremlinGraph request.
func (client *GremlinResourcesClient) getGremlinGraphCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesGetGremlinGraphOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getGremlinGraphHandleResponse handles the GetGremlinGraph response.
func (client *GremlinResourcesClient) getGremlinGraphHandleResponse(resp *http.Response) (GremlinResourcesGetGremlinGraphResponse, error) {
	result := GremlinResourcesGetGremlinGraphResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.GremlinGraphGetResults); err != nil {
		return GremlinResourcesGetGremlinGraphResponse{}, err
	}
	return result, nil
}

// getGremlinGraphHandleError handles the GetGremlinGraph error response.
func (client *GremlinResourcesClient) getGremlinGraphHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetGremlinGraphThroughput - Gets the Gremlin graph throughput under an existing Azure Cosmos DB database account with the provided name.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) GetGremlinGraphThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesGetGremlinGraphThroughputOptions) (GremlinResourcesGetGremlinGraphThroughputResponse, error) {
	req, err := client.getGremlinGraphThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return GremlinResourcesGetGremlinGraphThroughputResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GremlinResourcesGetGremlinGraphThroughputResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GremlinResourcesGetGremlinGraphThroughputResponse{}, client.getGremlinGraphThroughputHandleError(resp)
	}
	return client.getGremlinGraphThroughputHandleResponse(resp)
}

// getGremlinGraphThroughputCreateRequest creates the GetGremlinGraphThroughput request.
func (client *GremlinResourcesClient) getGremlinGraphThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesGetGremlinGraphThroughputOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/throughputSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getGremlinGraphThroughputHandleResponse handles the GetGremlinGraphThroughput response.
func (client *GremlinResourcesClient) getGremlinGraphThroughputHandleResponse(resp *http.Response) (GremlinResourcesGetGremlinGraphThroughputResponse, error) {
	result := GremlinResourcesGetGremlinGraphThroughputResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThroughputSettingsGetResults); err != nil {
		return GremlinResourcesGetGremlinGraphThroughputResponse{}, err
	}
	return result, nil
}

// getGremlinGraphThroughputHandleError handles the GetGremlinGraphThroughput error response.
func (client *GremlinResourcesClient) getGremlinGraphThroughputHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListGremlinDatabases - Lists the Gremlin databases under an existing Azure Cosmos DB database account.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) ListGremlinDatabases(ctx context.Context, resourceGroupName string, accountName string, options *GremlinResourcesListGremlinDatabasesOptions) (GremlinResourcesListGremlinDatabasesResponse, error) {
	req, err := client.listGremlinDatabasesCreateRequest(ctx, resourceGroupName, accountName, options)
	if err != nil {
		return GremlinResourcesListGremlinDatabasesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GremlinResourcesListGremlinDatabasesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GremlinResourcesListGremlinDatabasesResponse{}, client.listGremlinDatabasesHandleError(resp)
	}
	return client.listGremlinDatabasesHandleResponse(resp)
}

// listGremlinDatabasesCreateRequest creates the ListGremlinDatabases request.
func (client *GremlinResourcesClient) listGremlinDatabasesCreateRequest(ctx context.Context, resourceGroupName string, accountName string, options *GremlinResourcesListGremlinDatabasesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listGremlinDatabasesHandleResponse handles the ListGremlinDatabases response.
func (client *GremlinResourcesClient) listGremlinDatabasesHandleResponse(resp *http.Response) (GremlinResourcesListGremlinDatabasesResponse, error) {
	result := GremlinResourcesListGremlinDatabasesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.GremlinDatabaseListResult); err != nil {
		return GremlinResourcesListGremlinDatabasesResponse{}, err
	}
	return result, nil
}

// listGremlinDatabasesHandleError handles the ListGremlinDatabases error response.
func (client *GremlinResourcesClient) listGremlinDatabasesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListGremlinGraphs - Lists the Gremlin graph under an existing Azure Cosmos DB database account.
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) ListGremlinGraphs(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesListGremlinGraphsOptions) (GremlinResourcesListGremlinGraphsResponse, error) {
	req, err := client.listGremlinGraphsCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return GremlinResourcesListGremlinGraphsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GremlinResourcesListGremlinGraphsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GremlinResourcesListGremlinGraphsResponse{}, client.listGremlinGraphsHandleError(resp)
	}
	return client.listGremlinGraphsHandleResponse(resp)
}

// listGremlinGraphsCreateRequest creates the ListGremlinGraphs request.
func (client *GremlinResourcesClient) listGremlinGraphsCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesListGremlinGraphsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listGremlinGraphsHandleResponse handles the ListGremlinGraphs response.
func (client *GremlinResourcesClient) listGremlinGraphsHandleResponse(resp *http.Response) (GremlinResourcesListGremlinGraphsResponse, error) {
	result := GremlinResourcesListGremlinGraphsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.GremlinGraphListResult); err != nil {
		return GremlinResourcesListGremlinGraphsResponse{}, err
	}
	return result, nil
}

// listGremlinGraphsHandleError handles the ListGremlinGraphs error response.
func (client *GremlinResourcesClient) listGremlinGraphsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginMigrateGremlinDatabaseToAutoscale - Migrate an Azure Cosmos DB Gremlin database from manual throughput to autoscale
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) BeginMigrateGremlinDatabaseToAutoscale(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginMigrateGremlinDatabaseToAutoscaleOptions) (GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse, error) {
	resp, err := client.migrateGremlinDatabaseToAutoscale(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse{}, err
	}
	result := GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("GremlinResourcesClient.MigrateGremlinDatabaseToAutoscale", "", resp, client.pl, client.migrateGremlinDatabaseToAutoscaleHandleError)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToAutoscalePollerResponse{}, err
	}
	result.Poller = &GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller{
		pt: pt,
	}
	return result, nil
}

// MigrateGremlinDatabaseToAutoscale - Migrate an Azure Cosmos DB Gremlin database from manual throughput to autoscale
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) migrateGremlinDatabaseToAutoscale(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginMigrateGremlinDatabaseToAutoscaleOptions) (*http.Response, error) {
	req, err := client.migrateGremlinDatabaseToAutoscaleCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.migrateGremlinDatabaseToAutoscaleHandleError(resp)
	}
	return resp, nil
}

// migrateGremlinDatabaseToAutoscaleCreateRequest creates the MigrateGremlinDatabaseToAutoscale request.
func (client *GremlinResourcesClient) migrateGremlinDatabaseToAutoscaleCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginMigrateGremlinDatabaseToAutoscaleOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// migrateGremlinDatabaseToAutoscaleHandleError handles the MigrateGremlinDatabaseToAutoscale error response.
func (client *GremlinResourcesClient) migrateGremlinDatabaseToAutoscaleHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginMigrateGremlinDatabaseToManualThroughput - Migrate an Azure Cosmos DB Gremlin database from autoscale to manual throughput
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) BeginMigrateGremlinDatabaseToManualThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginMigrateGremlinDatabaseToManualThroughputOptions) (GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse, error) {
	resp, err := client.migrateGremlinDatabaseToManualThroughput(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse{}, err
	}
	result := GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("GremlinResourcesClient.MigrateGremlinDatabaseToManualThroughput", "", resp, client.pl, client.migrateGremlinDatabaseToManualThroughputHandleError)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToManualThroughputPollerResponse{}, err
	}
	result.Poller = &GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller{
		pt: pt,
	}
	return result, nil
}

// MigrateGremlinDatabaseToManualThroughput - Migrate an Azure Cosmos DB Gremlin database from autoscale to manual throughput
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) migrateGremlinDatabaseToManualThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginMigrateGremlinDatabaseToManualThroughputOptions) (*http.Response, error) {
	req, err := client.migrateGremlinDatabaseToManualThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.migrateGremlinDatabaseToManualThroughputHandleError(resp)
	}
	return resp, nil
}

// migrateGremlinDatabaseToManualThroughputCreateRequest creates the MigrateGremlinDatabaseToManualThroughput request.
func (client *GremlinResourcesClient) migrateGremlinDatabaseToManualThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, options *GremlinResourcesBeginMigrateGremlinDatabaseToManualThroughputOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// migrateGremlinDatabaseToManualThroughputHandleError handles the MigrateGremlinDatabaseToManualThroughput error response.
func (client *GremlinResourcesClient) migrateGremlinDatabaseToManualThroughputHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginMigrateGremlinGraphToAutoscale - Migrate an Azure Cosmos DB Gremlin graph from manual throughput to autoscale
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) BeginMigrateGremlinGraphToAutoscale(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginMigrateGremlinGraphToAutoscaleOptions) (GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse, error) {
	resp, err := client.migrateGremlinGraphToAutoscale(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse{}, err
	}
	result := GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("GremlinResourcesClient.MigrateGremlinGraphToAutoscale", "", resp, client.pl, client.migrateGremlinGraphToAutoscaleHandleError)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToAutoscalePollerResponse{}, err
	}
	result.Poller = &GremlinResourcesMigrateGremlinGraphToAutoscalePoller{
		pt: pt,
	}
	return result, nil
}

// MigrateGremlinGraphToAutoscale - Migrate an Azure Cosmos DB Gremlin graph from manual throughput to autoscale
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) migrateGremlinGraphToAutoscale(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginMigrateGremlinGraphToAutoscaleOptions) (*http.Response, error) {
	req, err := client.migrateGremlinGraphToAutoscaleCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.migrateGremlinGraphToAutoscaleHandleError(resp)
	}
	return resp, nil
}

// migrateGremlinGraphToAutoscaleCreateRequest creates the MigrateGremlinGraphToAutoscale request.
func (client *GremlinResourcesClient) migrateGremlinGraphToAutoscaleCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginMigrateGremlinGraphToAutoscaleOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/throughputSettings/default/migrateToAutoscale"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// migrateGremlinGraphToAutoscaleHandleError handles the MigrateGremlinGraphToAutoscale error response.
func (client *GremlinResourcesClient) migrateGremlinGraphToAutoscaleHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginMigrateGremlinGraphToManualThroughput - Migrate an Azure Cosmos DB Gremlin graph from autoscale to manual throughput
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) BeginMigrateGremlinGraphToManualThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginMigrateGremlinGraphToManualThroughputOptions) (GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse, error) {
	resp, err := client.migrateGremlinGraphToManualThroughput(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse{}, err
	}
	result := GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("GremlinResourcesClient.MigrateGremlinGraphToManualThroughput", "", resp, client.pl, client.migrateGremlinGraphToManualThroughputHandleError)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToManualThroughputPollerResponse{}, err
	}
	result.Poller = &GremlinResourcesMigrateGremlinGraphToManualThroughputPoller{
		pt: pt,
	}
	return result, nil
}

// MigrateGremlinGraphToManualThroughput - Migrate an Azure Cosmos DB Gremlin graph from autoscale to manual throughput
// If the operation fails it returns the *CloudError error type.
func (client *GremlinResourcesClient) migrateGremlinGraphToManualThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginMigrateGremlinGraphToManualThroughputOptions) (*http.Response, error) {
	req, err := client.migrateGremlinGraphToManualThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.migrateGremlinGraphToManualThroughputHandleError(resp)
	}
	return resp, nil
}

// migrateGremlinGraphToManualThroughputCreateRequest creates the MigrateGremlinGraphToManualThroughput request.
func (client *GremlinResourcesClient) migrateGremlinGraphToManualThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, options *GremlinResourcesBeginMigrateGremlinGraphToManualThroughputOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/throughputSettings/default/migrateToManualThroughput"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// migrateGremlinGraphToManualThroughputHandleError handles the MigrateGremlinGraphToManualThroughput error response.
func (client *GremlinResourcesClient) migrateGremlinGraphToManualThroughputHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginUpdateGremlinDatabaseThroughput - Update RUs per second of an Azure Cosmos DB Gremlin database
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) BeginUpdateGremlinDatabaseThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *GremlinResourcesBeginUpdateGremlinDatabaseThroughputOptions) (GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse, error) {
	resp, err := client.updateGremlinDatabaseThroughput(ctx, resourceGroupName, accountName, databaseName, updateThroughputParameters, options)
	if err != nil {
		return GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse{}, err
	}
	result := GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("GremlinResourcesClient.UpdateGremlinDatabaseThroughput", "", resp, client.pl, client.updateGremlinDatabaseThroughputHandleError)
	if err != nil {
		return GremlinResourcesUpdateGremlinDatabaseThroughputPollerResponse{}, err
	}
	result.Poller = &GremlinResourcesUpdateGremlinDatabaseThroughputPoller{
		pt: pt,
	}
	return result, nil
}

// UpdateGremlinDatabaseThroughput - Update RUs per second of an Azure Cosmos DB Gremlin database
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) updateGremlinDatabaseThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *GremlinResourcesBeginUpdateGremlinDatabaseThroughputOptions) (*http.Response, error) {
	req, err := client.updateGremlinDatabaseThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, updateThroughputParameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.updateGremlinDatabaseThroughputHandleError(resp)
	}
	return resp, nil
}

// updateGremlinDatabaseThroughputCreateRequest creates the UpdateGremlinDatabaseThroughput request.
func (client *GremlinResourcesClient) updateGremlinDatabaseThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *GremlinResourcesBeginUpdateGremlinDatabaseThroughputOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/throughputSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, updateThroughputParameters)
}

// updateGremlinDatabaseThroughputHandleError handles the UpdateGremlinDatabaseThroughput error response.
func (client *GremlinResourcesClient) updateGremlinDatabaseThroughputHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginUpdateGremlinGraphThroughput - Update RUs per second of an Azure Cosmos DB Gremlin graph
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) BeginUpdateGremlinGraphThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *GremlinResourcesBeginUpdateGremlinGraphThroughputOptions) (GremlinResourcesUpdateGremlinGraphThroughputPollerResponse, error) {
	resp, err := client.updateGremlinGraphThroughput(ctx, resourceGroupName, accountName, databaseName, graphName, updateThroughputParameters, options)
	if err != nil {
		return GremlinResourcesUpdateGremlinGraphThroughputPollerResponse{}, err
	}
	result := GremlinResourcesUpdateGremlinGraphThroughputPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("GremlinResourcesClient.UpdateGremlinGraphThroughput", "", resp, client.pl, client.updateGremlinGraphThroughputHandleError)
	if err != nil {
		return GremlinResourcesUpdateGremlinGraphThroughputPollerResponse{}, err
	}
	result.Poller = &GremlinResourcesUpdateGremlinGraphThroughputPoller{
		pt: pt,
	}
	return result, nil
}

// UpdateGremlinGraphThroughput - Update RUs per second of an Azure Cosmos DB Gremlin graph
// If the operation fails it returns a generic error.
func (client *GremlinResourcesClient) updateGremlinGraphThroughput(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *GremlinResourcesBeginUpdateGremlinGraphThroughputOptions) (*http.Response, error) {
	req, err := client.updateGremlinGraphThroughputCreateRequest(ctx, resourceGroupName, accountName, databaseName, graphName, updateThroughputParameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.updateGremlinGraphThroughputHandleError(resp)
	}
	return resp, nil
}

// updateGremlinGraphThroughputCreateRequest creates the UpdateGremlinGraphThroughput request.
func (client *GremlinResourcesClient) updateGremlinGraphThroughputCreateRequest(ctx context.Context, resourceGroupName string, accountName string, databaseName string, graphName string, updateThroughputParameters ThroughputSettingsUpdateParameters, options *GremlinResourcesBeginUpdateGremlinGraphThroughputOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/throughputSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if accountName == "" {
		return nil, errors.New("parameter accountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	if databaseName == "" {
		return nil, errors.New("parameter databaseName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{databaseName}", url.PathEscape(databaseName))
	if graphName == "" {
		return nil, errors.New("parameter graphName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{graphName}", url.PathEscape(graphName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-06-15")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, updateThroughputParameters)
}

// updateGremlinGraphThroughputHandleError handles the UpdateGremlinGraphThroughput error response.
func (client *GremlinResourcesClient) updateGremlinGraphThroughputHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}
