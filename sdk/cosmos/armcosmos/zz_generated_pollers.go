// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcosmos

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// CassandraResourcesCreateUpdateCassandraKeyspacePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesCreateUpdateCassandraKeyspacePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CassandraResourcesCreateUpdateCassandraKeyspaceResponse will be returned.
	FinalResponse(ctx context.Context) (CassandraResourcesCreateUpdateCassandraKeyspaceResponse, error)
}

type cassandraResourcesCreateUpdateCassandraKeyspacePoller struct {
	pt *armcore.LROPoller
}

func (p *cassandraResourcesCreateUpdateCassandraKeyspacePoller) Done() bool {
	return p.pt.Done()
}

func (p *cassandraResourcesCreateUpdateCassandraKeyspacePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *cassandraResourcesCreateUpdateCassandraKeyspacePoller) FinalResponse(ctx context.Context) (CassandraResourcesCreateUpdateCassandraKeyspaceResponse, error) {
	respType := CassandraResourcesCreateUpdateCassandraKeyspaceResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CassandraKeyspaceGetResults)
	if err != nil {
		return CassandraResourcesCreateUpdateCassandraKeyspaceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *cassandraResourcesCreateUpdateCassandraKeyspacePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *cassandraResourcesCreateUpdateCassandraKeyspacePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesCreateUpdateCassandraKeyspaceResponse, error) {
	respType := CassandraResourcesCreateUpdateCassandraKeyspaceResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.CassandraKeyspaceGetResults)
	if err != nil {
		return CassandraResourcesCreateUpdateCassandraKeyspaceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CassandraResourcesCreateUpdateCassandraTablePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesCreateUpdateCassandraTablePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CassandraResourcesCreateUpdateCassandraTableResponse will be returned.
	FinalResponse(ctx context.Context) (CassandraResourcesCreateUpdateCassandraTableResponse, error)
}

type cassandraResourcesCreateUpdateCassandraTablePoller struct {
	pt *armcore.LROPoller
}

func (p *cassandraResourcesCreateUpdateCassandraTablePoller) Done() bool {
	return p.pt.Done()
}

func (p *cassandraResourcesCreateUpdateCassandraTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *cassandraResourcesCreateUpdateCassandraTablePoller) FinalResponse(ctx context.Context) (CassandraResourcesCreateUpdateCassandraTableResponse, error) {
	respType := CassandraResourcesCreateUpdateCassandraTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CassandraTableGetResults)
	if err != nil {
		return CassandraResourcesCreateUpdateCassandraTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *cassandraResourcesCreateUpdateCassandraTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *cassandraResourcesCreateUpdateCassandraTablePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesCreateUpdateCassandraTableResponse, error) {
	respType := CassandraResourcesCreateUpdateCassandraTableResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.CassandraTableGetResults)
	if err != nil {
		return CassandraResourcesCreateUpdateCassandraTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CassandraResourcesDeleteCassandraKeyspacePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesDeleteCassandraKeyspacePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CassandraResourcesDeleteCassandraKeyspaceResponse will be returned.
	FinalResponse(ctx context.Context) (CassandraResourcesDeleteCassandraKeyspaceResponse, error)
}

type cassandraResourcesDeleteCassandraKeyspacePoller struct {
	pt *armcore.LROPoller
}

func (p *cassandraResourcesDeleteCassandraKeyspacePoller) Done() bool {
	return p.pt.Done()
}

func (p *cassandraResourcesDeleteCassandraKeyspacePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *cassandraResourcesDeleteCassandraKeyspacePoller) FinalResponse(ctx context.Context) (CassandraResourcesDeleteCassandraKeyspaceResponse, error) {
	respType := CassandraResourcesDeleteCassandraKeyspaceResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraResourcesDeleteCassandraKeyspaceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *cassandraResourcesDeleteCassandraKeyspacePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *cassandraResourcesDeleteCassandraKeyspacePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesDeleteCassandraKeyspaceResponse, error) {
	respType := CassandraResourcesDeleteCassandraKeyspaceResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return CassandraResourcesDeleteCassandraKeyspaceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CassandraResourcesDeleteCassandraTablePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesDeleteCassandraTablePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CassandraResourcesDeleteCassandraTableResponse will be returned.
	FinalResponse(ctx context.Context) (CassandraResourcesDeleteCassandraTableResponse, error)
}

type cassandraResourcesDeleteCassandraTablePoller struct {
	pt *armcore.LROPoller
}

func (p *cassandraResourcesDeleteCassandraTablePoller) Done() bool {
	return p.pt.Done()
}

func (p *cassandraResourcesDeleteCassandraTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *cassandraResourcesDeleteCassandraTablePoller) FinalResponse(ctx context.Context) (CassandraResourcesDeleteCassandraTableResponse, error) {
	respType := CassandraResourcesDeleteCassandraTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CassandraResourcesDeleteCassandraTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *cassandraResourcesDeleteCassandraTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *cassandraResourcesDeleteCassandraTablePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesDeleteCassandraTableResponse, error) {
	respType := CassandraResourcesDeleteCassandraTableResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return CassandraResourcesDeleteCassandraTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse will be returned.
	FinalResponse(ctx context.Context) (CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse, error)
}

type cassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller struct {
	pt *armcore.LROPoller
}

func (p *cassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

func (p *cassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *cassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller) FinalResponse(ctx context.Context) (CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse, error) {
	respType := CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *cassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *cassandraResourcesMigrateCassandraKeyspaceToAutoscalePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse, error) {
	respType := CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesMigrateCassandraKeyspaceToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse, error)
}

type cassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *cassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *cassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *cassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller) FinalResponse(ctx context.Context) (CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse, error) {
	respType := CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *cassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *cassandraResourcesMigrateCassandraKeyspaceToManualThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse, error) {
	respType := CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesMigrateCassandraKeyspaceToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CassandraResourcesMigrateCassandraTableToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesMigrateCassandraTableToAutoscalePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CassandraResourcesMigrateCassandraTableToAutoscaleResponse will be returned.
	FinalResponse(ctx context.Context) (CassandraResourcesMigrateCassandraTableToAutoscaleResponse, error)
}

type cassandraResourcesMigrateCassandraTableToAutoscalePoller struct {
	pt *armcore.LROPoller
}

func (p *cassandraResourcesMigrateCassandraTableToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

func (p *cassandraResourcesMigrateCassandraTableToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *cassandraResourcesMigrateCassandraTableToAutoscalePoller) FinalResponse(ctx context.Context) (CassandraResourcesMigrateCassandraTableToAutoscaleResponse, error) {
	respType := CassandraResourcesMigrateCassandraTableToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesMigrateCassandraTableToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *cassandraResourcesMigrateCassandraTableToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *cassandraResourcesMigrateCassandraTableToAutoscalePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesMigrateCassandraTableToAutoscaleResponse, error) {
	respType := CassandraResourcesMigrateCassandraTableToAutoscaleResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesMigrateCassandraTableToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CassandraResourcesMigrateCassandraTableToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesMigrateCassandraTableToManualThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CassandraResourcesMigrateCassandraTableToManualThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (CassandraResourcesMigrateCassandraTableToManualThroughputResponse, error)
}

type cassandraResourcesMigrateCassandraTableToManualThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *cassandraResourcesMigrateCassandraTableToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *cassandraResourcesMigrateCassandraTableToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *cassandraResourcesMigrateCassandraTableToManualThroughputPoller) FinalResponse(ctx context.Context) (CassandraResourcesMigrateCassandraTableToManualThroughputResponse, error) {
	respType := CassandraResourcesMigrateCassandraTableToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesMigrateCassandraTableToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *cassandraResourcesMigrateCassandraTableToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *cassandraResourcesMigrateCassandraTableToManualThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesMigrateCassandraTableToManualThroughputResponse, error) {
	respType := CassandraResourcesMigrateCassandraTableToManualThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesMigrateCassandraTableToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CassandraResourcesUpdateCassandraKeyspaceThroughputPoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesUpdateCassandraKeyspaceThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CassandraResourcesUpdateCassandraKeyspaceThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (CassandraResourcesUpdateCassandraKeyspaceThroughputResponse, error)
}

type cassandraResourcesUpdateCassandraKeyspaceThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *cassandraResourcesUpdateCassandraKeyspaceThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *cassandraResourcesUpdateCassandraKeyspaceThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *cassandraResourcesUpdateCassandraKeyspaceThroughputPoller) FinalResponse(ctx context.Context) (CassandraResourcesUpdateCassandraKeyspaceThroughputResponse, error) {
	respType := CassandraResourcesUpdateCassandraKeyspaceThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesUpdateCassandraKeyspaceThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *cassandraResourcesUpdateCassandraKeyspaceThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *cassandraResourcesUpdateCassandraKeyspaceThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesUpdateCassandraKeyspaceThroughputResponse, error) {
	respType := CassandraResourcesUpdateCassandraKeyspaceThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesUpdateCassandraKeyspaceThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CassandraResourcesUpdateCassandraTableThroughputPoller provides polling facilities until the operation reaches a terminal state.
type CassandraResourcesUpdateCassandraTableThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CassandraResourcesUpdateCassandraTableThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (CassandraResourcesUpdateCassandraTableThroughputResponse, error)
}

type cassandraResourcesUpdateCassandraTableThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *cassandraResourcesUpdateCassandraTableThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *cassandraResourcesUpdateCassandraTableThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *cassandraResourcesUpdateCassandraTableThroughputPoller) FinalResponse(ctx context.Context) (CassandraResourcesUpdateCassandraTableThroughputResponse, error) {
	respType := CassandraResourcesUpdateCassandraTableThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesUpdateCassandraTableThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *cassandraResourcesUpdateCassandraTableThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *cassandraResourcesUpdateCassandraTableThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (CassandraResourcesUpdateCassandraTableThroughputResponse, error) {
	respType := CassandraResourcesUpdateCassandraTableThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return CassandraResourcesUpdateCassandraTableThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabaseAccountsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabaseAccountsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (DatabaseAccountsCreateOrUpdateResponse, error)
}

type databaseAccountsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *databaseAccountsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *databaseAccountsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databaseAccountsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DatabaseAccountsCreateOrUpdateResponse, error) {
	respType := DatabaseAccountsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DatabaseAccountGetResults)
	if err != nil {
		return DatabaseAccountsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databaseAccountsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databaseAccountsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsCreateOrUpdateResponse, error) {
	respType := DatabaseAccountsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.DatabaseAccountGetResults)
	if err != nil {
		return DatabaseAccountsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabaseAccountsDeletePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabaseAccountsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (DatabaseAccountsDeleteResponse, error)
}

type databaseAccountsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *databaseAccountsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *databaseAccountsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databaseAccountsDeletePoller) FinalResponse(ctx context.Context) (DatabaseAccountsDeleteResponse, error) {
	respType := DatabaseAccountsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databaseAccountsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databaseAccountsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsDeleteResponse, error) {
	respType := DatabaseAccountsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DatabaseAccountsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabaseAccountsFailoverPriorityChangePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsFailoverPriorityChangePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabaseAccountsFailoverPriorityChangeResponse will be returned.
	FinalResponse(ctx context.Context) (DatabaseAccountsFailoverPriorityChangeResponse, error)
}

type databaseAccountsFailoverPriorityChangePoller struct {
	pt *armcore.LROPoller
}

func (p *databaseAccountsFailoverPriorityChangePoller) Done() bool {
	return p.pt.Done()
}

func (p *databaseAccountsFailoverPriorityChangePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databaseAccountsFailoverPriorityChangePoller) FinalResponse(ctx context.Context) (DatabaseAccountsFailoverPriorityChangeResponse, error) {
	respType := DatabaseAccountsFailoverPriorityChangeResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsFailoverPriorityChangeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databaseAccountsFailoverPriorityChangePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databaseAccountsFailoverPriorityChangePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsFailoverPriorityChangeResponse, error) {
	respType := DatabaseAccountsFailoverPriorityChangeResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DatabaseAccountsFailoverPriorityChangeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabaseAccountsOfflineRegionPoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsOfflineRegionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabaseAccountsOfflineRegionResponse will be returned.
	FinalResponse(ctx context.Context) (DatabaseAccountsOfflineRegionResponse, error)
}

type databaseAccountsOfflineRegionPoller struct {
	pt *armcore.LROPoller
}

func (p *databaseAccountsOfflineRegionPoller) Done() bool {
	return p.pt.Done()
}

func (p *databaseAccountsOfflineRegionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databaseAccountsOfflineRegionPoller) FinalResponse(ctx context.Context) (DatabaseAccountsOfflineRegionResponse, error) {
	respType := DatabaseAccountsOfflineRegionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsOfflineRegionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databaseAccountsOfflineRegionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databaseAccountsOfflineRegionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsOfflineRegionResponse, error) {
	respType := DatabaseAccountsOfflineRegionResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DatabaseAccountsOfflineRegionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabaseAccountsOnlineRegionPoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsOnlineRegionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabaseAccountsOnlineRegionResponse will be returned.
	FinalResponse(ctx context.Context) (DatabaseAccountsOnlineRegionResponse, error)
}

type databaseAccountsOnlineRegionPoller struct {
	pt *armcore.LROPoller
}

func (p *databaseAccountsOnlineRegionPoller) Done() bool {
	return p.pt.Done()
}

func (p *databaseAccountsOnlineRegionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databaseAccountsOnlineRegionPoller) FinalResponse(ctx context.Context) (DatabaseAccountsOnlineRegionResponse, error) {
	respType := DatabaseAccountsOnlineRegionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsOnlineRegionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databaseAccountsOnlineRegionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databaseAccountsOnlineRegionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsOnlineRegionResponse, error) {
	respType := DatabaseAccountsOnlineRegionResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DatabaseAccountsOnlineRegionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabaseAccountsRegenerateKeyPoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsRegenerateKeyPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabaseAccountsRegenerateKeyResponse will be returned.
	FinalResponse(ctx context.Context) (DatabaseAccountsRegenerateKeyResponse, error)
}

type databaseAccountsRegenerateKeyPoller struct {
	pt *armcore.LROPoller
}

func (p *databaseAccountsRegenerateKeyPoller) Done() bool {
	return p.pt.Done()
}

func (p *databaseAccountsRegenerateKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databaseAccountsRegenerateKeyPoller) FinalResponse(ctx context.Context) (DatabaseAccountsRegenerateKeyResponse, error) {
	respType := DatabaseAccountsRegenerateKeyResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseAccountsRegenerateKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databaseAccountsRegenerateKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databaseAccountsRegenerateKeyPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsRegenerateKeyResponse, error) {
	respType := DatabaseAccountsRegenerateKeyResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DatabaseAccountsRegenerateKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabaseAccountsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseAccountsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabaseAccountsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (DatabaseAccountsUpdateResponse, error)
}

type databaseAccountsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *databaseAccountsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *databaseAccountsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databaseAccountsUpdatePoller) FinalResponse(ctx context.Context) (DatabaseAccountsUpdateResponse, error) {
	respType := DatabaseAccountsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DatabaseAccountGetResults)
	if err != nil {
		return DatabaseAccountsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databaseAccountsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databaseAccountsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabaseAccountsUpdateResponse, error) {
	respType := DatabaseAccountsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.DatabaseAccountGetResults)
	if err != nil {
		return DatabaseAccountsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GremlinResourcesCreateUpdateGremlinDatabasePoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesCreateUpdateGremlinDatabasePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GremlinResourcesCreateUpdateGremlinDatabaseResponse will be returned.
	FinalResponse(ctx context.Context) (GremlinResourcesCreateUpdateGremlinDatabaseResponse, error)
}

type gremlinResourcesCreateUpdateGremlinDatabasePoller struct {
	pt *armcore.LROPoller
}

func (p *gremlinResourcesCreateUpdateGremlinDatabasePoller) Done() bool {
	return p.pt.Done()
}

func (p *gremlinResourcesCreateUpdateGremlinDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *gremlinResourcesCreateUpdateGremlinDatabasePoller) FinalResponse(ctx context.Context) (GremlinResourcesCreateUpdateGremlinDatabaseResponse, error) {
	respType := GremlinResourcesCreateUpdateGremlinDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GremlinDatabaseGetResults)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *gremlinResourcesCreateUpdateGremlinDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *gremlinResourcesCreateUpdateGremlinDatabasePoller) pollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesCreateUpdateGremlinDatabaseResponse, error) {
	respType := GremlinResourcesCreateUpdateGremlinDatabaseResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.GremlinDatabaseGetResults)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GremlinResourcesCreateUpdateGremlinGraphPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesCreateUpdateGremlinGraphPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GremlinResourcesCreateUpdateGremlinGraphResponse will be returned.
	FinalResponse(ctx context.Context) (GremlinResourcesCreateUpdateGremlinGraphResponse, error)
}

type gremlinResourcesCreateUpdateGremlinGraphPoller struct {
	pt *armcore.LROPoller
}

func (p *gremlinResourcesCreateUpdateGremlinGraphPoller) Done() bool {
	return p.pt.Done()
}

func (p *gremlinResourcesCreateUpdateGremlinGraphPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *gremlinResourcesCreateUpdateGremlinGraphPoller) FinalResponse(ctx context.Context) (GremlinResourcesCreateUpdateGremlinGraphResponse, error) {
	respType := GremlinResourcesCreateUpdateGremlinGraphResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GremlinGraphGetResults)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinGraphResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *gremlinResourcesCreateUpdateGremlinGraphPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *gremlinResourcesCreateUpdateGremlinGraphPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesCreateUpdateGremlinGraphResponse, error) {
	respType := GremlinResourcesCreateUpdateGremlinGraphResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.GremlinGraphGetResults)
	if err != nil {
		return GremlinResourcesCreateUpdateGremlinGraphResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GremlinResourcesDeleteGremlinDatabasePoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesDeleteGremlinDatabasePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GremlinResourcesDeleteGremlinDatabaseResponse will be returned.
	FinalResponse(ctx context.Context) (GremlinResourcesDeleteGremlinDatabaseResponse, error)
}

type gremlinResourcesDeleteGremlinDatabasePoller struct {
	pt *armcore.LROPoller
}

func (p *gremlinResourcesDeleteGremlinDatabasePoller) Done() bool {
	return p.pt.Done()
}

func (p *gremlinResourcesDeleteGremlinDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *gremlinResourcesDeleteGremlinDatabasePoller) FinalResponse(ctx context.Context) (GremlinResourcesDeleteGremlinDatabaseResponse, error) {
	respType := GremlinResourcesDeleteGremlinDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return GremlinResourcesDeleteGremlinDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *gremlinResourcesDeleteGremlinDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *gremlinResourcesDeleteGremlinDatabasePoller) pollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesDeleteGremlinDatabaseResponse, error) {
	respType := GremlinResourcesDeleteGremlinDatabaseResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return GremlinResourcesDeleteGremlinDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GremlinResourcesDeleteGremlinGraphPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesDeleteGremlinGraphPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GremlinResourcesDeleteGremlinGraphResponse will be returned.
	FinalResponse(ctx context.Context) (GremlinResourcesDeleteGremlinGraphResponse, error)
}

type gremlinResourcesDeleteGremlinGraphPoller struct {
	pt *armcore.LROPoller
}

func (p *gremlinResourcesDeleteGremlinGraphPoller) Done() bool {
	return p.pt.Done()
}

func (p *gremlinResourcesDeleteGremlinGraphPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *gremlinResourcesDeleteGremlinGraphPoller) FinalResponse(ctx context.Context) (GremlinResourcesDeleteGremlinGraphResponse, error) {
	respType := GremlinResourcesDeleteGremlinGraphResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return GremlinResourcesDeleteGremlinGraphResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *gremlinResourcesDeleteGremlinGraphPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *gremlinResourcesDeleteGremlinGraphPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesDeleteGremlinGraphResponse, error) {
	respType := GremlinResourcesDeleteGremlinGraphResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return GremlinResourcesDeleteGremlinGraphResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesMigrateGremlinDatabaseToAutoscalePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse will be returned.
	FinalResponse(ctx context.Context) (GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse, error)
}

type gremlinResourcesMigrateGremlinDatabaseToAutoscalePoller struct {
	pt *armcore.LROPoller
}

func (p *gremlinResourcesMigrateGremlinDatabaseToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

func (p *gremlinResourcesMigrateGremlinDatabaseToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *gremlinResourcesMigrateGremlinDatabaseToAutoscalePoller) FinalResponse(ctx context.Context) (GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse, error) {
	respType := GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *gremlinResourcesMigrateGremlinDatabaseToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *gremlinResourcesMigrateGremlinDatabaseToAutoscalePoller) pollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse, error) {
	respType := GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse, error)
}

type gremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *gremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *gremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *gremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller) FinalResponse(ctx context.Context) (GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse, error) {
	respType := GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *gremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *gremlinResourcesMigrateGremlinDatabaseToManualThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse, error) {
	respType := GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesMigrateGremlinDatabaseToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GremlinResourcesMigrateGremlinGraphToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesMigrateGremlinGraphToAutoscalePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GremlinResourcesMigrateGremlinGraphToAutoscaleResponse will be returned.
	FinalResponse(ctx context.Context) (GremlinResourcesMigrateGremlinGraphToAutoscaleResponse, error)
}

type gremlinResourcesMigrateGremlinGraphToAutoscalePoller struct {
	pt *armcore.LROPoller
}

func (p *gremlinResourcesMigrateGremlinGraphToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

func (p *gremlinResourcesMigrateGremlinGraphToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *gremlinResourcesMigrateGremlinGraphToAutoscalePoller) FinalResponse(ctx context.Context) (GremlinResourcesMigrateGremlinGraphToAutoscaleResponse, error) {
	respType := GremlinResourcesMigrateGremlinGraphToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *gremlinResourcesMigrateGremlinGraphToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *gremlinResourcesMigrateGremlinGraphToAutoscalePoller) pollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesMigrateGremlinGraphToAutoscaleResponse, error) {
	respType := GremlinResourcesMigrateGremlinGraphToAutoscaleResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GremlinResourcesMigrateGremlinGraphToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesMigrateGremlinGraphToManualThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GremlinResourcesMigrateGremlinGraphToManualThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (GremlinResourcesMigrateGremlinGraphToManualThroughputResponse, error)
}

type gremlinResourcesMigrateGremlinGraphToManualThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *gremlinResourcesMigrateGremlinGraphToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *gremlinResourcesMigrateGremlinGraphToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *gremlinResourcesMigrateGremlinGraphToManualThroughputPoller) FinalResponse(ctx context.Context) (GremlinResourcesMigrateGremlinGraphToManualThroughputResponse, error) {
	respType := GremlinResourcesMigrateGremlinGraphToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *gremlinResourcesMigrateGremlinGraphToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *gremlinResourcesMigrateGremlinGraphToManualThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesMigrateGremlinGraphToManualThroughputResponse, error) {
	respType := GremlinResourcesMigrateGremlinGraphToManualThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesMigrateGremlinGraphToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GremlinResourcesUpdateGremlinDatabaseThroughputPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesUpdateGremlinDatabaseThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GremlinResourcesUpdateGremlinDatabaseThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (GremlinResourcesUpdateGremlinDatabaseThroughputResponse, error)
}

type gremlinResourcesUpdateGremlinDatabaseThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *gremlinResourcesUpdateGremlinDatabaseThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *gremlinResourcesUpdateGremlinDatabaseThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *gremlinResourcesUpdateGremlinDatabaseThroughputPoller) FinalResponse(ctx context.Context) (GremlinResourcesUpdateGremlinDatabaseThroughputResponse, error) {
	respType := GremlinResourcesUpdateGremlinDatabaseThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesUpdateGremlinDatabaseThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *gremlinResourcesUpdateGremlinDatabaseThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *gremlinResourcesUpdateGremlinDatabaseThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesUpdateGremlinDatabaseThroughputResponse, error) {
	respType := GremlinResourcesUpdateGremlinDatabaseThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesUpdateGremlinDatabaseThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GremlinResourcesUpdateGremlinGraphThroughputPoller provides polling facilities until the operation reaches a terminal state.
type GremlinResourcesUpdateGremlinGraphThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GremlinResourcesUpdateGremlinGraphThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (GremlinResourcesUpdateGremlinGraphThroughputResponse, error)
}

type gremlinResourcesUpdateGremlinGraphThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *gremlinResourcesUpdateGremlinGraphThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *gremlinResourcesUpdateGremlinGraphThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *gremlinResourcesUpdateGremlinGraphThroughputPoller) FinalResponse(ctx context.Context) (GremlinResourcesUpdateGremlinGraphThroughputResponse, error) {
	respType := GremlinResourcesUpdateGremlinGraphThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesUpdateGremlinGraphThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *gremlinResourcesUpdateGremlinGraphThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *gremlinResourcesUpdateGremlinGraphThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GremlinResourcesUpdateGremlinGraphThroughputResponse, error) {
	respType := GremlinResourcesUpdateGremlinGraphThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return GremlinResourcesUpdateGremlinGraphThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// MongoDBResourcesCreateUpdateMongoDBCollectionPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesCreateUpdateMongoDBCollectionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final MongoDBResourcesCreateUpdateMongoDBCollectionResponse will be returned.
	FinalResponse(ctx context.Context) (MongoDBResourcesCreateUpdateMongoDBCollectionResponse, error)
}

type mongoDBResourcesCreateUpdateMongoDBCollectionPoller struct {
	pt *armcore.LROPoller
}

func (p *mongoDBResourcesCreateUpdateMongoDBCollectionPoller) Done() bool {
	return p.pt.Done()
}

func (p *mongoDBResourcesCreateUpdateMongoDBCollectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *mongoDBResourcesCreateUpdateMongoDBCollectionPoller) FinalResponse(ctx context.Context) (MongoDBResourcesCreateUpdateMongoDBCollectionResponse, error) {
	respType := MongoDBResourcesCreateUpdateMongoDBCollectionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MongoDBCollectionGetResults)
	if err != nil {
		return MongoDBResourcesCreateUpdateMongoDBCollectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *mongoDBResourcesCreateUpdateMongoDBCollectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *mongoDBResourcesCreateUpdateMongoDBCollectionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesCreateUpdateMongoDBCollectionResponse, error) {
	respType := MongoDBResourcesCreateUpdateMongoDBCollectionResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.MongoDBCollectionGetResults)
	if err != nil {
		return MongoDBResourcesCreateUpdateMongoDBCollectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// MongoDBResourcesCreateUpdateMongoDBDatabasePoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesCreateUpdateMongoDBDatabasePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final MongoDBResourcesCreateUpdateMongoDBDatabaseResponse will be returned.
	FinalResponse(ctx context.Context) (MongoDBResourcesCreateUpdateMongoDBDatabaseResponse, error)
}

type mongoDBResourcesCreateUpdateMongoDBDatabasePoller struct {
	pt *armcore.LROPoller
}

func (p *mongoDBResourcesCreateUpdateMongoDBDatabasePoller) Done() bool {
	return p.pt.Done()
}

func (p *mongoDBResourcesCreateUpdateMongoDBDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *mongoDBResourcesCreateUpdateMongoDBDatabasePoller) FinalResponse(ctx context.Context) (MongoDBResourcesCreateUpdateMongoDBDatabaseResponse, error) {
	respType := MongoDBResourcesCreateUpdateMongoDBDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MongoDBDatabaseGetResults)
	if err != nil {
		return MongoDBResourcesCreateUpdateMongoDBDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *mongoDBResourcesCreateUpdateMongoDBDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *mongoDBResourcesCreateUpdateMongoDBDatabasePoller) pollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesCreateUpdateMongoDBDatabaseResponse, error) {
	respType := MongoDBResourcesCreateUpdateMongoDBDatabaseResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.MongoDBDatabaseGetResults)
	if err != nil {
		return MongoDBResourcesCreateUpdateMongoDBDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// MongoDBResourcesDeleteMongoDBCollectionPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesDeleteMongoDBCollectionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final MongoDBResourcesDeleteMongoDBCollectionResponse will be returned.
	FinalResponse(ctx context.Context) (MongoDBResourcesDeleteMongoDBCollectionResponse, error)
}

type mongoDBResourcesDeleteMongoDBCollectionPoller struct {
	pt *armcore.LROPoller
}

func (p *mongoDBResourcesDeleteMongoDBCollectionPoller) Done() bool {
	return p.pt.Done()
}

func (p *mongoDBResourcesDeleteMongoDBCollectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *mongoDBResourcesDeleteMongoDBCollectionPoller) FinalResponse(ctx context.Context) (MongoDBResourcesDeleteMongoDBCollectionResponse, error) {
	respType := MongoDBResourcesDeleteMongoDBCollectionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return MongoDBResourcesDeleteMongoDBCollectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *mongoDBResourcesDeleteMongoDBCollectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *mongoDBResourcesDeleteMongoDBCollectionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesDeleteMongoDBCollectionResponse, error) {
	respType := MongoDBResourcesDeleteMongoDBCollectionResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return MongoDBResourcesDeleteMongoDBCollectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// MongoDBResourcesDeleteMongoDBDatabasePoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesDeleteMongoDBDatabasePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final MongoDBResourcesDeleteMongoDBDatabaseResponse will be returned.
	FinalResponse(ctx context.Context) (MongoDBResourcesDeleteMongoDBDatabaseResponse, error)
}

type mongoDBResourcesDeleteMongoDBDatabasePoller struct {
	pt *armcore.LROPoller
}

func (p *mongoDBResourcesDeleteMongoDBDatabasePoller) Done() bool {
	return p.pt.Done()
}

func (p *mongoDBResourcesDeleteMongoDBDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *mongoDBResourcesDeleteMongoDBDatabasePoller) FinalResponse(ctx context.Context) (MongoDBResourcesDeleteMongoDBDatabaseResponse, error) {
	respType := MongoDBResourcesDeleteMongoDBDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return MongoDBResourcesDeleteMongoDBDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *mongoDBResourcesDeleteMongoDBDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *mongoDBResourcesDeleteMongoDBDatabasePoller) pollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesDeleteMongoDBDatabaseResponse, error) {
	respType := MongoDBResourcesDeleteMongoDBDatabaseResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return MongoDBResourcesDeleteMongoDBDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// MongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse will be returned.
	FinalResponse(ctx context.Context) (MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse, error)
}

type mongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller struct {
	pt *armcore.LROPoller
}

func (p *mongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

func (p *mongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *mongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller) FinalResponse(ctx context.Context) (MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *mongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *mongoDBResourcesMigrateMongoDBCollectionToAutoscalePoller) pollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse, error)
}

type mongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *mongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *mongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *mongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller) FinalResponse(ctx context.Context) (MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *mongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *mongoDBResourcesMigrateMongoDBCollectionToManualThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse will be returned.
	FinalResponse(ctx context.Context) (MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse, error)
}

type mongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller struct {
	pt *armcore.LROPoller
}

func (p *mongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

func (p *mongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *mongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller) FinalResponse(ctx context.Context) (MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *mongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *mongoDBResourcesMigrateMongoDBDatabaseToAutoscalePoller) pollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse, error)
}

type mongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *mongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *mongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *mongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller) FinalResponse(ctx context.Context) (MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *mongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *mongoDBResourcesMigrateMongoDBDatabaseToManualThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse, error) {
	respType := MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// MongoDBResourcesUpdateMongoDBCollectionThroughputPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesUpdateMongoDBCollectionThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final MongoDBResourcesUpdateMongoDBCollectionThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (MongoDBResourcesUpdateMongoDBCollectionThroughputResponse, error)
}

type mongoDBResourcesUpdateMongoDBCollectionThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *mongoDBResourcesUpdateMongoDBCollectionThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *mongoDBResourcesUpdateMongoDBCollectionThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *mongoDBResourcesUpdateMongoDBCollectionThroughputPoller) FinalResponse(ctx context.Context) (MongoDBResourcesUpdateMongoDBCollectionThroughputResponse, error) {
	respType := MongoDBResourcesUpdateMongoDBCollectionThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesUpdateMongoDBCollectionThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *mongoDBResourcesUpdateMongoDBCollectionThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *mongoDBResourcesUpdateMongoDBCollectionThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesUpdateMongoDBCollectionThroughputResponse, error) {
	respType := MongoDBResourcesUpdateMongoDBCollectionThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesUpdateMongoDBCollectionThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// MongoDBResourcesUpdateMongoDBDatabaseThroughputPoller provides polling facilities until the operation reaches a terminal state.
type MongoDBResourcesUpdateMongoDBDatabaseThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse, error)
}

type mongoDBResourcesUpdateMongoDBDatabaseThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *mongoDBResourcesUpdateMongoDBDatabaseThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *mongoDBResourcesUpdateMongoDBDatabaseThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *mongoDBResourcesUpdateMongoDBDatabaseThroughputPoller) FinalResponse(ctx context.Context) (MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse, error) {
	respType := MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *mongoDBResourcesUpdateMongoDBDatabaseThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *mongoDBResourcesUpdateMongoDBDatabaseThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse, error) {
	respType := MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NotebookWorkspacesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NotebookWorkspacesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NotebookWorkspacesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (NotebookWorkspacesCreateOrUpdateResponse, error)
}

type notebookWorkspacesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *notebookWorkspacesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *notebookWorkspacesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *notebookWorkspacesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NotebookWorkspacesCreateOrUpdateResponse, error) {
	respType := NotebookWorkspacesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NotebookWorkspace)
	if err != nil {
		return NotebookWorkspacesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *notebookWorkspacesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *notebookWorkspacesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NotebookWorkspacesCreateOrUpdateResponse, error) {
	respType := NotebookWorkspacesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.NotebookWorkspace)
	if err != nil {
		return NotebookWorkspacesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NotebookWorkspacesDeletePoller provides polling facilities until the operation reaches a terminal state.
type NotebookWorkspacesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NotebookWorkspacesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (NotebookWorkspacesDeleteResponse, error)
}

type notebookWorkspacesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *notebookWorkspacesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *notebookWorkspacesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *notebookWorkspacesDeletePoller) FinalResponse(ctx context.Context) (NotebookWorkspacesDeleteResponse, error) {
	respType := NotebookWorkspacesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NotebookWorkspacesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *notebookWorkspacesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *notebookWorkspacesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NotebookWorkspacesDeleteResponse, error) {
	respType := NotebookWorkspacesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return NotebookWorkspacesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NotebookWorkspacesRegenerateAuthTokenPoller provides polling facilities until the operation reaches a terminal state.
type NotebookWorkspacesRegenerateAuthTokenPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NotebookWorkspacesRegenerateAuthTokenResponse will be returned.
	FinalResponse(ctx context.Context) (NotebookWorkspacesRegenerateAuthTokenResponse, error)
}

type notebookWorkspacesRegenerateAuthTokenPoller struct {
	pt *armcore.LROPoller
}

func (p *notebookWorkspacesRegenerateAuthTokenPoller) Done() bool {
	return p.pt.Done()
}

func (p *notebookWorkspacesRegenerateAuthTokenPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *notebookWorkspacesRegenerateAuthTokenPoller) FinalResponse(ctx context.Context) (NotebookWorkspacesRegenerateAuthTokenResponse, error) {
	respType := NotebookWorkspacesRegenerateAuthTokenResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NotebookWorkspacesRegenerateAuthTokenResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *notebookWorkspacesRegenerateAuthTokenPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *notebookWorkspacesRegenerateAuthTokenPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NotebookWorkspacesRegenerateAuthTokenResponse, error) {
	respType := NotebookWorkspacesRegenerateAuthTokenResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return NotebookWorkspacesRegenerateAuthTokenResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NotebookWorkspacesStartPoller provides polling facilities until the operation reaches a terminal state.
type NotebookWorkspacesStartPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NotebookWorkspacesStartResponse will be returned.
	FinalResponse(ctx context.Context) (NotebookWorkspacesStartResponse, error)
}

type notebookWorkspacesStartPoller struct {
	pt *armcore.LROPoller
}

func (p *notebookWorkspacesStartPoller) Done() bool {
	return p.pt.Done()
}

func (p *notebookWorkspacesStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *notebookWorkspacesStartPoller) FinalResponse(ctx context.Context) (NotebookWorkspacesStartResponse, error) {
	respType := NotebookWorkspacesStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NotebookWorkspacesStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *notebookWorkspacesStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *notebookWorkspacesStartPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NotebookWorkspacesStartResponse, error) {
	respType := NotebookWorkspacesStartResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return NotebookWorkspacesStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateEndpointConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateEndpointConnectionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateEndpointConnectionsCreateOrUpdateResponse, error)
}

type privateEndpointConnectionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *privateEndpointConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *privateEndpointConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateEndpointConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateEndpointConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateEndpointConnectionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateEndpointConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateEndpointConnectionsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateEndpointConnectionsDeleteResponse, error)
}

type privateEndpointConnectionsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *privateEndpointConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *privateEndpointConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateEndpointConnectionsDeletePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateEndpointConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateEndpointConnectionsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesCreateUpdateSQLContainerPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLContainerPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLContainerResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLContainerResponse, error)
}

type sqlResourcesCreateUpdateSQLContainerPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesCreateUpdateSQLContainerPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesCreateUpdateSQLContainerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesCreateUpdateSQLContainerPoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLContainerResponse, error) {
	respType := SQLResourcesCreateUpdateSQLContainerResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLContainerGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLContainerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesCreateUpdateSQLContainerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesCreateUpdateSQLContainerPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLContainerResponse, error) {
	respType := SQLResourcesCreateUpdateSQLContainerResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SQLContainerGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLContainerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesCreateUpdateSQLDatabasePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLDatabasePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLDatabaseResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLDatabaseResponse, error)
}

type sqlResourcesCreateUpdateSQLDatabasePoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesCreateUpdateSQLDatabasePoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesCreateUpdateSQLDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesCreateUpdateSQLDatabasePoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLDatabaseResponse, error) {
	respType := SQLResourcesCreateUpdateSQLDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLDatabaseGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesCreateUpdateSQLDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesCreateUpdateSQLDatabasePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLDatabaseResponse, error) {
	respType := SQLResourcesCreateUpdateSQLDatabaseResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SQLDatabaseGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesCreateUpdateSQLRoleAssignmentPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLRoleAssignmentPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLRoleAssignmentResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLRoleAssignmentResponse, error)
}

type sqlResourcesCreateUpdateSQLRoleAssignmentPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesCreateUpdateSQLRoleAssignmentPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesCreateUpdateSQLRoleAssignmentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesCreateUpdateSQLRoleAssignmentPoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLRoleAssignmentResponse, error) {
	respType := SQLResourcesCreateUpdateSQLRoleAssignmentResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLRoleAssignmentGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLRoleAssignmentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesCreateUpdateSQLRoleAssignmentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesCreateUpdateSQLRoleAssignmentPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLRoleAssignmentResponse, error) {
	respType := SQLResourcesCreateUpdateSQLRoleAssignmentResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SQLRoleAssignmentGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLRoleAssignmentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesCreateUpdateSQLRoleDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLRoleDefinitionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLRoleDefinitionResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLRoleDefinitionResponse, error)
}

type sqlResourcesCreateUpdateSQLRoleDefinitionPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesCreateUpdateSQLRoleDefinitionPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesCreateUpdateSQLRoleDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesCreateUpdateSQLRoleDefinitionPoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLRoleDefinitionResponse, error) {
	respType := SQLResourcesCreateUpdateSQLRoleDefinitionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLRoleDefinitionGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLRoleDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesCreateUpdateSQLRoleDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesCreateUpdateSQLRoleDefinitionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLRoleDefinitionResponse, error) {
	respType := SQLResourcesCreateUpdateSQLRoleDefinitionResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SQLRoleDefinitionGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLRoleDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesCreateUpdateSQLStoredProcedurePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLStoredProcedurePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLStoredProcedureResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLStoredProcedureResponse, error)
}

type sqlResourcesCreateUpdateSQLStoredProcedurePoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesCreateUpdateSQLStoredProcedurePoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesCreateUpdateSQLStoredProcedurePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesCreateUpdateSQLStoredProcedurePoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLStoredProcedureResponse, error) {
	respType := SQLResourcesCreateUpdateSQLStoredProcedureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLStoredProcedureGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLStoredProcedureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesCreateUpdateSQLStoredProcedurePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesCreateUpdateSQLStoredProcedurePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLStoredProcedureResponse, error) {
	respType := SQLResourcesCreateUpdateSQLStoredProcedureResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SQLStoredProcedureGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLStoredProcedureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesCreateUpdateSQLTriggerPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLTriggerPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLTriggerResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLTriggerResponse, error)
}

type sqlResourcesCreateUpdateSQLTriggerPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesCreateUpdateSQLTriggerPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesCreateUpdateSQLTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesCreateUpdateSQLTriggerPoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLTriggerResponse, error) {
	respType := SQLResourcesCreateUpdateSQLTriggerResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLTriggerGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLTriggerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesCreateUpdateSQLTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesCreateUpdateSQLTriggerPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLTriggerResponse, error) {
	respType := SQLResourcesCreateUpdateSQLTriggerResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SQLTriggerGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLTriggerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesCreateUpdateSQLUserDefinedFunctionPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesCreateUpdateSQLUserDefinedFunctionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse, error)
}

type sqlResourcesCreateUpdateSQLUserDefinedFunctionPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesCreateUpdateSQLUserDefinedFunctionPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesCreateUpdateSQLUserDefinedFunctionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesCreateUpdateSQLUserDefinedFunctionPoller) FinalResponse(ctx context.Context) (SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse, error) {
	respType := SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLUserDefinedFunctionGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesCreateUpdateSQLUserDefinedFunctionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesCreateUpdateSQLUserDefinedFunctionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse, error) {
	respType := SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SQLUserDefinedFunctionGetResults)
	if err != nil {
		return SQLResourcesCreateUpdateSQLUserDefinedFunctionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesDeleteSQLContainerPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLContainerPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesDeleteSQLContainerResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLContainerResponse, error)
}

type sqlResourcesDeleteSQLContainerPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesDeleteSQLContainerPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesDeleteSQLContainerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesDeleteSQLContainerPoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLContainerResponse, error) {
	respType := SQLResourcesDeleteSQLContainerResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLContainerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesDeleteSQLContainerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesDeleteSQLContainerPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLContainerResponse, error) {
	respType := SQLResourcesDeleteSQLContainerResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SQLResourcesDeleteSQLContainerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesDeleteSQLDatabasePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLDatabasePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesDeleteSQLDatabaseResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLDatabaseResponse, error)
}

type sqlResourcesDeleteSQLDatabasePoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesDeleteSQLDatabasePoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesDeleteSQLDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesDeleteSQLDatabasePoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLDatabaseResponse, error) {
	respType := SQLResourcesDeleteSQLDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesDeleteSQLDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesDeleteSQLDatabasePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLDatabaseResponse, error) {
	respType := SQLResourcesDeleteSQLDatabaseResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SQLResourcesDeleteSQLDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesDeleteSQLRoleAssignmentPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLRoleAssignmentPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesDeleteSQLRoleAssignmentResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLRoleAssignmentResponse, error)
}

type sqlResourcesDeleteSQLRoleAssignmentPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesDeleteSQLRoleAssignmentPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesDeleteSQLRoleAssignmentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesDeleteSQLRoleAssignmentPoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLRoleAssignmentResponse, error) {
	respType := SQLResourcesDeleteSQLRoleAssignmentResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLRoleAssignmentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesDeleteSQLRoleAssignmentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesDeleteSQLRoleAssignmentPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLRoleAssignmentResponse, error) {
	respType := SQLResourcesDeleteSQLRoleAssignmentResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SQLResourcesDeleteSQLRoleAssignmentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesDeleteSQLRoleDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLRoleDefinitionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesDeleteSQLRoleDefinitionResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLRoleDefinitionResponse, error)
}

type sqlResourcesDeleteSQLRoleDefinitionPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesDeleteSQLRoleDefinitionPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesDeleteSQLRoleDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesDeleteSQLRoleDefinitionPoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLRoleDefinitionResponse, error) {
	respType := SQLResourcesDeleteSQLRoleDefinitionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLRoleDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesDeleteSQLRoleDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesDeleteSQLRoleDefinitionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLRoleDefinitionResponse, error) {
	respType := SQLResourcesDeleteSQLRoleDefinitionResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SQLResourcesDeleteSQLRoleDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesDeleteSQLStoredProcedurePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLStoredProcedurePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesDeleteSQLStoredProcedureResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLStoredProcedureResponse, error)
}

type sqlResourcesDeleteSQLStoredProcedurePoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesDeleteSQLStoredProcedurePoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesDeleteSQLStoredProcedurePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesDeleteSQLStoredProcedurePoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLStoredProcedureResponse, error) {
	respType := SQLResourcesDeleteSQLStoredProcedureResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLStoredProcedureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesDeleteSQLStoredProcedurePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesDeleteSQLStoredProcedurePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLStoredProcedureResponse, error) {
	respType := SQLResourcesDeleteSQLStoredProcedureResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SQLResourcesDeleteSQLStoredProcedureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesDeleteSQLTriggerPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLTriggerPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesDeleteSQLTriggerResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLTriggerResponse, error)
}

type sqlResourcesDeleteSQLTriggerPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesDeleteSQLTriggerPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesDeleteSQLTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesDeleteSQLTriggerPoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLTriggerResponse, error) {
	respType := SQLResourcesDeleteSQLTriggerResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLTriggerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesDeleteSQLTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesDeleteSQLTriggerPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLTriggerResponse, error) {
	respType := SQLResourcesDeleteSQLTriggerResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SQLResourcesDeleteSQLTriggerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesDeleteSQLUserDefinedFunctionPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesDeleteSQLUserDefinedFunctionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesDeleteSQLUserDefinedFunctionResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLUserDefinedFunctionResponse, error)
}

type sqlResourcesDeleteSQLUserDefinedFunctionPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesDeleteSQLUserDefinedFunctionPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesDeleteSQLUserDefinedFunctionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesDeleteSQLUserDefinedFunctionPoller) FinalResponse(ctx context.Context) (SQLResourcesDeleteSQLUserDefinedFunctionResponse, error) {
	respType := SQLResourcesDeleteSQLUserDefinedFunctionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLResourcesDeleteSQLUserDefinedFunctionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesDeleteSQLUserDefinedFunctionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesDeleteSQLUserDefinedFunctionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesDeleteSQLUserDefinedFunctionResponse, error) {
	respType := SQLResourcesDeleteSQLUserDefinedFunctionResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SQLResourcesDeleteSQLUserDefinedFunctionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesMigrateSQLContainerToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesMigrateSQLContainerToAutoscalePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesMigrateSQLContainerToAutoscaleResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesMigrateSQLContainerToAutoscaleResponse, error)
}

type sqlResourcesMigrateSQLContainerToAutoscalePoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesMigrateSQLContainerToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesMigrateSQLContainerToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesMigrateSQLContainerToAutoscalePoller) FinalResponse(ctx context.Context) (SQLResourcesMigrateSQLContainerToAutoscaleResponse, error) {
	respType := SQLResourcesMigrateSQLContainerToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesMigrateSQLContainerToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesMigrateSQLContainerToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesMigrateSQLContainerToAutoscalePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesMigrateSQLContainerToAutoscaleResponse, error) {
	respType := SQLResourcesMigrateSQLContainerToAutoscaleResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesMigrateSQLContainerToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesMigrateSQLContainerToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesMigrateSQLContainerToManualThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesMigrateSQLContainerToManualThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesMigrateSQLContainerToManualThroughputResponse, error)
}

type sqlResourcesMigrateSQLContainerToManualThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesMigrateSQLContainerToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesMigrateSQLContainerToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesMigrateSQLContainerToManualThroughputPoller) FinalResponse(ctx context.Context) (SQLResourcesMigrateSQLContainerToManualThroughputResponse, error) {
	respType := SQLResourcesMigrateSQLContainerToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesMigrateSQLContainerToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesMigrateSQLContainerToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesMigrateSQLContainerToManualThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesMigrateSQLContainerToManualThroughputResponse, error) {
	respType := SQLResourcesMigrateSQLContainerToManualThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesMigrateSQLContainerToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesMigrateSQLDatabaseToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesMigrateSQLDatabaseToAutoscalePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesMigrateSQLDatabaseToAutoscaleResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesMigrateSQLDatabaseToAutoscaleResponse, error)
}

type sqlResourcesMigrateSQLDatabaseToAutoscalePoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesMigrateSQLDatabaseToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesMigrateSQLDatabaseToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesMigrateSQLDatabaseToAutoscalePoller) FinalResponse(ctx context.Context) (SQLResourcesMigrateSQLDatabaseToAutoscaleResponse, error) {
	respType := SQLResourcesMigrateSQLDatabaseToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesMigrateSQLDatabaseToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesMigrateSQLDatabaseToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesMigrateSQLDatabaseToAutoscalePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesMigrateSQLDatabaseToAutoscaleResponse, error) {
	respType := SQLResourcesMigrateSQLDatabaseToAutoscaleResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesMigrateSQLDatabaseToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesMigrateSQLDatabaseToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesMigrateSQLDatabaseToManualThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesMigrateSQLDatabaseToManualThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesMigrateSQLDatabaseToManualThroughputResponse, error)
}

type sqlResourcesMigrateSQLDatabaseToManualThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesMigrateSQLDatabaseToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesMigrateSQLDatabaseToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesMigrateSQLDatabaseToManualThroughputPoller) FinalResponse(ctx context.Context) (SQLResourcesMigrateSQLDatabaseToManualThroughputResponse, error) {
	respType := SQLResourcesMigrateSQLDatabaseToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesMigrateSQLDatabaseToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesMigrateSQLDatabaseToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesMigrateSQLDatabaseToManualThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesMigrateSQLDatabaseToManualThroughputResponse, error) {
	respType := SQLResourcesMigrateSQLDatabaseToManualThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesMigrateSQLDatabaseToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesRetrieveContinuousBackupInformationPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesRetrieveContinuousBackupInformationPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesRetrieveContinuousBackupInformationResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesRetrieveContinuousBackupInformationResponse, error)
}

type sqlResourcesRetrieveContinuousBackupInformationPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesRetrieveContinuousBackupInformationPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesRetrieveContinuousBackupInformationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesRetrieveContinuousBackupInformationPoller) FinalResponse(ctx context.Context) (SQLResourcesRetrieveContinuousBackupInformationResponse, error) {
	respType := SQLResourcesRetrieveContinuousBackupInformationResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupInformation)
	if err != nil {
		return SQLResourcesRetrieveContinuousBackupInformationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesRetrieveContinuousBackupInformationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesRetrieveContinuousBackupInformationPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesRetrieveContinuousBackupInformationResponse, error) {
	respType := SQLResourcesRetrieveContinuousBackupInformationResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.BackupInformation)
	if err != nil {
		return SQLResourcesRetrieveContinuousBackupInformationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesUpdateSQLContainerThroughputPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesUpdateSQLContainerThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesUpdateSQLContainerThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesUpdateSQLContainerThroughputResponse, error)
}

type sqlResourcesUpdateSQLContainerThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesUpdateSQLContainerThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesUpdateSQLContainerThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesUpdateSQLContainerThroughputPoller) FinalResponse(ctx context.Context) (SQLResourcesUpdateSQLContainerThroughputResponse, error) {
	respType := SQLResourcesUpdateSQLContainerThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesUpdateSQLContainerThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesUpdateSQLContainerThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesUpdateSQLContainerThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesUpdateSQLContainerThroughputResponse, error) {
	respType := SQLResourcesUpdateSQLContainerThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesUpdateSQLContainerThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SQLResourcesUpdateSQLDatabaseThroughputPoller provides polling facilities until the operation reaches a terminal state.
type SQLResourcesUpdateSQLDatabaseThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SQLResourcesUpdateSQLDatabaseThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (SQLResourcesUpdateSQLDatabaseThroughputResponse, error)
}

type sqlResourcesUpdateSQLDatabaseThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *sqlResourcesUpdateSQLDatabaseThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *sqlResourcesUpdateSQLDatabaseThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *sqlResourcesUpdateSQLDatabaseThroughputPoller) FinalResponse(ctx context.Context) (SQLResourcesUpdateSQLDatabaseThroughputResponse, error) {
	respType := SQLResourcesUpdateSQLDatabaseThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesUpdateSQLDatabaseThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *sqlResourcesUpdateSQLDatabaseThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *sqlResourcesUpdateSQLDatabaseThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SQLResourcesUpdateSQLDatabaseThroughputResponse, error) {
	respType := SQLResourcesUpdateSQLDatabaseThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return SQLResourcesUpdateSQLDatabaseThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// TableResourcesCreateUpdateTablePoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesCreateUpdateTablePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final TableResourcesCreateUpdateTableResponse will be returned.
	FinalResponse(ctx context.Context) (TableResourcesCreateUpdateTableResponse, error)
}

type tableResourcesCreateUpdateTablePoller struct {
	pt *armcore.LROPoller
}

func (p *tableResourcesCreateUpdateTablePoller) Done() bool {
	return p.pt.Done()
}

func (p *tableResourcesCreateUpdateTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *tableResourcesCreateUpdateTablePoller) FinalResponse(ctx context.Context) (TableResourcesCreateUpdateTableResponse, error) {
	respType := TableResourcesCreateUpdateTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.TableGetResults)
	if err != nil {
		return TableResourcesCreateUpdateTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *tableResourcesCreateUpdateTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *tableResourcesCreateUpdateTablePoller) pollUntilDone(ctx context.Context, freq time.Duration) (TableResourcesCreateUpdateTableResponse, error) {
	respType := TableResourcesCreateUpdateTableResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.TableGetResults)
	if err != nil {
		return TableResourcesCreateUpdateTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// TableResourcesDeleteTablePoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesDeleteTablePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final TableResourcesDeleteTableResponse will be returned.
	FinalResponse(ctx context.Context) (TableResourcesDeleteTableResponse, error)
}

type tableResourcesDeleteTablePoller struct {
	pt *armcore.LROPoller
}

func (p *tableResourcesDeleteTablePoller) Done() bool {
	return p.pt.Done()
}

func (p *tableResourcesDeleteTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *tableResourcesDeleteTablePoller) FinalResponse(ctx context.Context) (TableResourcesDeleteTableResponse, error) {
	respType := TableResourcesDeleteTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TableResourcesDeleteTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *tableResourcesDeleteTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *tableResourcesDeleteTablePoller) pollUntilDone(ctx context.Context, freq time.Duration) (TableResourcesDeleteTableResponse, error) {
	respType := TableResourcesDeleteTableResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return TableResourcesDeleteTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// TableResourcesMigrateTableToAutoscalePoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesMigrateTableToAutoscalePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final TableResourcesMigrateTableToAutoscaleResponse will be returned.
	FinalResponse(ctx context.Context) (TableResourcesMigrateTableToAutoscaleResponse, error)
}

type tableResourcesMigrateTableToAutoscalePoller struct {
	pt *armcore.LROPoller
}

func (p *tableResourcesMigrateTableToAutoscalePoller) Done() bool {
	return p.pt.Done()
}

func (p *tableResourcesMigrateTableToAutoscalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *tableResourcesMigrateTableToAutoscalePoller) FinalResponse(ctx context.Context) (TableResourcesMigrateTableToAutoscaleResponse, error) {
	respType := TableResourcesMigrateTableToAutoscaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return TableResourcesMigrateTableToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *tableResourcesMigrateTableToAutoscalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *tableResourcesMigrateTableToAutoscalePoller) pollUntilDone(ctx context.Context, freq time.Duration) (TableResourcesMigrateTableToAutoscaleResponse, error) {
	respType := TableResourcesMigrateTableToAutoscaleResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return TableResourcesMigrateTableToAutoscaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// TableResourcesMigrateTableToManualThroughputPoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesMigrateTableToManualThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final TableResourcesMigrateTableToManualThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (TableResourcesMigrateTableToManualThroughputResponse, error)
}

type tableResourcesMigrateTableToManualThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *tableResourcesMigrateTableToManualThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *tableResourcesMigrateTableToManualThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *tableResourcesMigrateTableToManualThroughputPoller) FinalResponse(ctx context.Context) (TableResourcesMigrateTableToManualThroughputResponse, error) {
	respType := TableResourcesMigrateTableToManualThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return TableResourcesMigrateTableToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *tableResourcesMigrateTableToManualThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *tableResourcesMigrateTableToManualThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (TableResourcesMigrateTableToManualThroughputResponse, error) {
	respType := TableResourcesMigrateTableToManualThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return TableResourcesMigrateTableToManualThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// TableResourcesUpdateTableThroughputPoller provides polling facilities until the operation reaches a terminal state.
type TableResourcesUpdateTableThroughputPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final TableResourcesUpdateTableThroughputResponse will be returned.
	FinalResponse(ctx context.Context) (TableResourcesUpdateTableThroughputResponse, error)
}

type tableResourcesUpdateTableThroughputPoller struct {
	pt *armcore.LROPoller
}

func (p *tableResourcesUpdateTableThroughputPoller) Done() bool {
	return p.pt.Done()
}

func (p *tableResourcesUpdateTableThroughputPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *tableResourcesUpdateTableThroughputPoller) FinalResponse(ctx context.Context) (TableResourcesUpdateTableThroughputResponse, error) {
	respType := TableResourcesUpdateTableThroughputResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return TableResourcesUpdateTableThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *tableResourcesUpdateTableThroughputPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *tableResourcesUpdateTableThroughputPoller) pollUntilDone(ctx context.Context, freq time.Duration) (TableResourcesUpdateTableThroughputResponse, error) {
	respType := TableResourcesUpdateTableThroughputResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ThroughputSettingsGetResults)
	if err != nil {
		return TableResourcesUpdateTableThroughputResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}
