//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package azappconfig

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strings"
)

// Client contains the methods for the Client group.
// Don't use this type directly, use a constructor function instead.
type Client struct {
	internal *azcore.Client
	endpoint string
	syncTokenPolicy *syncTokenPolicy
}

// AddSetting - Creates a key-value.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0
//   - key - The key of the key-value to create.
//   - entity - The key-value to create.
//   - options - AddSettingOptions contains the optional parameters for the Client.AddSetting method.
func (client *Client) AddSetting(ctx context.Context, key string, entity KeyValue, options *AddSettingOptions) (AddSettingResponse, error) {
	req, err := client.addSettingCreateRequest(ctx, key, entity, options)
	if err != nil {
		return AddSettingResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return AddSettingResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AddSettingResponse{}, runtime.NewResponseError(resp)
	}
	return client.addSettingHandleResponse(resp)
}

// addSettingCreateRequest creates the AddSetting request.
func (client *Client) addSettingCreateRequest(ctx context.Context, key string, entity KeyValue, options *AddSettingOptions) (*policy.Request, error) {
	urlPath := "/kv/{key}"
	if key == "" {
		return nil, errors.New("parameter key cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key}", url.PathEscape(key))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Label != nil {
		reqQP.Set("label", *options.Label)
	}
	reqQP.Set("api-version", "1.0")
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	req.Raw().Header["Accept"] = []string{"application/vnd.microsoft.appconfig.kv+json, application/json, application/problem+json"}
	if err := runtime.MarshalAsJSON(req, entity); err != nil {
	return nil, err
}
	return req, nil
}

// addSettingHandleResponse handles the AddSetting response.
func (client *Client) addSettingHandleResponse(resp *http.Response) (AddSettingResponse, error) {
	result := AddSettingResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyValue); err != nil {
		return AddSettingResponse{}, err
	}
	return result, nil
}

// CheckKeyValue - Requests the headers and status of the given resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0
//   - key - The key of the key-value to retrieve.
//   - options - CheckKeyValueOptions contains the optional parameters for the Client.CheckKeyValue method.
func (client *Client) CheckKeyValue(ctx context.Context, key string, options *CheckKeyValueOptions) (CheckKeyValueResponse, error) {
	req, err := client.checkKeyValueCreateRequest(ctx, key, options)
	if err != nil {
		return CheckKeyValueResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CheckKeyValueResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CheckKeyValueResponse{}, runtime.NewResponseError(resp)
	}
	return client.checkKeyValueHandleResponse(resp)
}

// checkKeyValueCreateRequest creates the CheckKeyValue request.
func (client *Client) checkKeyValueCreateRequest(ctx context.Context, key string, options *CheckKeyValueOptions) (*policy.Request, error) {
	urlPath := "/kv/{key}"
	if key == "" {
		return nil, errors.New("parameter key cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key}", url.PathEscape(key))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Label != nil {
		reqQP.Set("label", *options.Label)
	}
	reqQP.Set("api-version", "1.0")
	if options != nil && options.Select != nil {
		reqQP.Set("$Select", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.Select), "[]")), ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.AcceptDatetime != nil {
		req.Raw().Header["Accept-Datetime"] = []string{*options.AcceptDatetime}
	}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	return req, nil
}

// checkKeyValueHandleResponse handles the CheckKeyValue response.
func (client *Client) checkKeyValueHandleResponse(resp *http.Response) (CheckKeyValueResponse, error) {
	result := CheckKeyValueResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		result.LastModified = &val
	}
	return result, nil
}

// CheckKeyValues - Requests the headers and status of the given resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0
//   - options - CheckKeyValuesOptions contains the optional parameters for the Client.CheckKeyValues method.
func (client *Client) CheckKeyValues(ctx context.Context, options *CheckKeyValuesOptions) (CheckKeyValuesResponse, error) {
	req, err := client.checkKeyValuesCreateRequest(ctx, options)
	if err != nil {
		return CheckKeyValuesResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CheckKeyValuesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CheckKeyValuesResponse{}, runtime.NewResponseError(resp)
	}
	return client.checkKeyValuesHandleResponse(resp)
}

// checkKeyValuesCreateRequest creates the CheckKeyValues request.
func (client *Client) checkKeyValuesCreateRequest(ctx context.Context, options *CheckKeyValuesOptions) (*policy.Request, error) {
	urlPath := "/kv"
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Key != nil {
		reqQP.Set("key", *options.Key)
	}
	if options != nil && options.Label != nil {
		reqQP.Set("label", *options.Label)
	}
	reqQP.Set("api-version", "1.0")
	if options != nil && options.After != nil {
		reqQP.Set("After", *options.After)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$Select", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.Select), "[]")), ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.AcceptDatetime != nil {
		req.Raw().Header["Accept-Datetime"] = []string{*options.AcceptDatetime}
	}
	return req, nil
}

// checkKeyValuesHandleResponse handles the CheckKeyValues response.
func (client *Client) checkKeyValuesHandleResponse(resp *http.Response) (CheckKeyValuesResponse, error) {
	result := CheckKeyValuesResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	return result, nil
}

// CheckKeys - Requests the headers and status of the given resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0
//   - options - CheckKeysOptions contains the optional parameters for the Client.CheckKeys method.
func (client *Client) CheckKeys(ctx context.Context, options *CheckKeysOptions) (CheckKeysResponse, error) {
	req, err := client.checkKeysCreateRequest(ctx, options)
	if err != nil {
		return CheckKeysResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CheckKeysResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CheckKeysResponse{}, runtime.NewResponseError(resp)
	}
	return client.checkKeysHandleResponse(resp)
}

// checkKeysCreateRequest creates the CheckKeys request.
func (client *Client) checkKeysCreateRequest(ctx context.Context, options *CheckKeysOptions) (*policy.Request, error) {
	urlPath := "/keys"
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Name != nil {
		reqQP.Set("name", *options.Name)
	}
	reqQP.Set("api-version", "1.0")
	if options != nil && options.After != nil {
		reqQP.Set("After", *options.After)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.AcceptDatetime != nil {
		req.Raw().Header["Accept-Datetime"] = []string{*options.AcceptDatetime}
	}
	return req, nil
}

// checkKeysHandleResponse handles the CheckKeys response.
func (client *Client) checkKeysHandleResponse(resp *http.Response) (CheckKeysResponse, error) {
	result := CheckKeysResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	return result, nil
}

// CheckLabels - Requests the headers and status of the given resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0
//   - options - CheckLabelsOptions contains the optional parameters for the Client.CheckLabels method.
func (client *Client) CheckLabels(ctx context.Context, options *CheckLabelsOptions) (CheckLabelsResponse, error) {
	req, err := client.checkLabelsCreateRequest(ctx, options)
	if err != nil {
		return CheckLabelsResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CheckLabelsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CheckLabelsResponse{}, runtime.NewResponseError(resp)
	}
	return client.checkLabelsHandleResponse(resp)
}

// checkLabelsCreateRequest creates the CheckLabels request.
func (client *Client) checkLabelsCreateRequest(ctx context.Context, options *CheckLabelsOptions) (*policy.Request, error) {
	urlPath := "/labels"
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Name != nil {
		reqQP.Set("name", *options.Name)
	}
	reqQP.Set("api-version", "1.0")
	if options != nil && options.After != nil {
		reqQP.Set("After", *options.After)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$Select", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.Select), "[]")), ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.AcceptDatetime != nil {
		req.Raw().Header["Accept-Datetime"] = []string{*options.AcceptDatetime}
	}
	return req, nil
}

// checkLabelsHandleResponse handles the CheckLabels response.
func (client *Client) checkLabelsHandleResponse(resp *http.Response) (CheckLabelsResponse, error) {
	result := CheckLabelsResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	return result, nil
}

// CheckRevisions - Requests the headers and status of the given resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0
//   - options - CheckRevisionsOptions contains the optional parameters for the Client.CheckRevisions method.
func (client *Client) CheckRevisions(ctx context.Context, options *CheckRevisionsOptions) (CheckRevisionsResponse, error) {
	req, err := client.checkRevisionsCreateRequest(ctx, options)
	if err != nil {
		return CheckRevisionsResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CheckRevisionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CheckRevisionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.checkRevisionsHandleResponse(resp)
}

// checkRevisionsCreateRequest creates the CheckRevisions request.
func (client *Client) checkRevisionsCreateRequest(ctx context.Context, options *CheckRevisionsOptions) (*policy.Request, error) {
	urlPath := "/revisions"
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Key != nil {
		reqQP.Set("key", *options.Key)
	}
	if options != nil && options.Label != nil {
		reqQP.Set("label", *options.Label)
	}
	reqQP.Set("api-version", "1.0")
	if options != nil && options.After != nil {
		reqQP.Set("After", *options.After)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$Select", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.Select), "[]")), ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.AcceptDatetime != nil {
		req.Raw().Header["Accept-Datetime"] = []string{*options.AcceptDatetime}
	}
	return req, nil
}

// checkRevisionsHandleResponse handles the CheckRevisions response.
func (client *Client) checkRevisionsHandleResponse(resp *http.Response) (CheckRevisionsResponse, error) {
	result := CheckRevisionsResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	return result, nil
}

// DeleteKeyValue - Deletes a key-value.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0
//   - key - The key of the key-value to delete.
//   - options - DeleteKeyValueOptions contains the optional parameters for the Client.DeleteKeyValue method.
func (client *Client) DeleteKeyValue(ctx context.Context, key string, options *DeleteKeyValueOptions) (DeleteKeyValueResponse, error) {
	req, err := client.deleteKeyValueCreateRequest(ctx, key, options)
	if err != nil {
		return DeleteKeyValueResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteKeyValueResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return DeleteKeyValueResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteKeyValueHandleResponse(resp)
}

// deleteKeyValueCreateRequest creates the DeleteKeyValue request.
func (client *Client) deleteKeyValueCreateRequest(ctx context.Context, key string, options *DeleteKeyValueOptions) (*policy.Request, error) {
	urlPath := "/kv/{key}"
	if key == "" {
		return nil, errors.New("parameter key cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key}", url.PathEscape(key))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Label != nil {
		reqQP.Set("label", *options.Label)
	}
	reqQP.Set("api-version", "1.0")
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	req.Raw().Header["Accept"] = []string{"application/vnd.microsoft.appconfig.kv+json, application/json, application/problem+json"}
	return req, nil
}

// deleteKeyValueHandleResponse handles the DeleteKeyValue response.
func (client *Client) deleteKeyValueHandleResponse(resp *http.Response) (DeleteKeyValueResponse, error) {
	result := DeleteKeyValueResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyValue); err != nil {
		return DeleteKeyValueResponse{}, err
	}
	return result, nil
}

// DeleteLock - Unlocks a key-value.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0
//   - key - The key of the key-value to unlock.
//   - options - DeleteLockOptions contains the optional parameters for the Client.DeleteLock method.
func (client *Client) DeleteLock(ctx context.Context, key string, options *DeleteLockOptions) (DeleteLockResponse, error) {
	req, err := client.deleteLockCreateRequest(ctx, key, options)
	if err != nil {
		return DeleteLockResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteLockResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DeleteLockResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteLockHandleResponse(resp)
}

// deleteLockCreateRequest creates the DeleteLock request.
func (client *Client) deleteLockCreateRequest(ctx context.Context, key string, options *DeleteLockOptions) (*policy.Request, error) {
	urlPath := "/locks/{key}"
	if key == "" {
		return nil, errors.New("parameter key cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key}", url.PathEscape(key))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Label != nil {
		reqQP.Set("label", *options.Label)
	}
	reqQP.Set("api-version", "1.0")
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	req.Raw().Header["Accept"] = []string{"application/vnd.microsoft.appconfig.kv+json, application/json, application/problem+json"}
	return req, nil
}

// deleteLockHandleResponse handles the DeleteLock response.
func (client *Client) deleteLockHandleResponse(resp *http.Response) (DeleteLockResponse, error) {
	result := DeleteLockResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyValue); err != nil {
		return DeleteLockResponse{}, err
	}
	return result, nil
}

// NewGetKeyValuesPager - Gets a list of key-values.
//
// Generated from API version 1.0
//   - options - GetKeyValuesOptions contains the optional parameters for the Client.NewGetKeyValuesPager method.
func (client *Client) NewGetKeyValuesPager(options *GetKeyValuesOptions) (*runtime.Pager[GetKeyValuesResponse]) {
	return runtime.NewPager(runtime.PagingHandler[GetKeyValuesResponse]{
		More: func(page GetKeyValuesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *GetKeyValuesResponse) (GetKeyValuesResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getKeyValuesCreateRequest(ctx, options)
			} else {
				req, err = client.getNextPageCreateRequest(ctx, *page.NextLink)
			}
			if err != nil {
				return GetKeyValuesResponse{}, err
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return GetKeyValuesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return GetKeyValuesResponse{}, runtime.NewResponseError(resp)
			}
			return client.getKeyValuesHandleResponse(resp)
		},
	})
}

// getKeyValuesCreateRequest creates the GetKeyValues request.
func (client *Client) getKeyValuesCreateRequest(ctx context.Context, options *GetKeyValuesOptions) (*policy.Request, error) {
	urlPath := "/kv"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Key != nil {
		reqQP.Set("key", *options.Key)
	}
	if options != nil && options.Label != nil {
		reqQP.Set("label", *options.Label)
	}
	reqQP.Set("api-version", "1.0")
	if options != nil && options.After != nil {
		reqQP.Set("After", *options.After)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$Select", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.Select), "[]")), ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.AcceptDatetime != nil {
		req.Raw().Header["Accept-Datetime"] = []string{*options.AcceptDatetime}
	}
	req.Raw().Header["Accept"] = []string{"application/vnd.microsoft.appconfig.kvset+json, application/json, application/problem+json"}
	return req, nil
}

// getKeyValuesHandleResponse handles the GetKeyValues response.
func (client *Client) getKeyValuesHandleResponse(resp *http.Response) (GetKeyValuesResponse, error) {
	result := GetKeyValuesResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyValueListResult); err != nil {
		return GetKeyValuesResponse{}, err
	}
	return result, nil
}

// NewGetKeysPager - Gets a list of keys.
//
// Generated from API version 1.0
//   - options - GetKeysOptions contains the optional parameters for the Client.NewGetKeysPager method.
func (client *Client) NewGetKeysPager(options *GetKeysOptions) (*runtime.Pager[GetKeysResponse]) {
	return runtime.NewPager(runtime.PagingHandler[GetKeysResponse]{
		More: func(page GetKeysResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *GetKeysResponse) (GetKeysResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getKeysCreateRequest(ctx, options)
			} else {
				req, err = client.getNextPageCreateRequest(ctx, *page.NextLink)
			}
			if err != nil {
				return GetKeysResponse{}, err
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return GetKeysResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return GetKeysResponse{}, runtime.NewResponseError(resp)
			}
			return client.getKeysHandleResponse(resp)
		},
	})
}

// getKeysCreateRequest creates the GetKeys request.
func (client *Client) getKeysCreateRequest(ctx context.Context, options *GetKeysOptions) (*policy.Request, error) {
	urlPath := "/keys"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Name != nil {
		reqQP.Set("name", *options.Name)
	}
	reqQP.Set("api-version", "1.0")
	if options != nil && options.After != nil {
		reqQP.Set("After", *options.After)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.AcceptDatetime != nil {
		req.Raw().Header["Accept-Datetime"] = []string{*options.AcceptDatetime}
	}
	req.Raw().Header["Accept"] = []string{"application/vnd.microsoft.appconfig.keyset+json, application/json, application/problem+json"}
	return req, nil
}

// getKeysHandleResponse handles the GetKeys response.
func (client *Client) getKeysHandleResponse(resp *http.Response) (GetKeysResponse, error) {
	result := GetKeysResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyListResult); err != nil {
		return GetKeysResponse{}, err
	}
	return result, nil
}

// NewGetLabelsPager - Gets a list of labels.
//
// Generated from API version 1.0
//   - options - GetLabelsOptions contains the optional parameters for the Client.NewGetLabelsPager method.
func (client *Client) NewGetLabelsPager(options *GetLabelsOptions) (*runtime.Pager[GetLabelsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[GetLabelsResponse]{
		More: func(page GetLabelsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *GetLabelsResponse) (GetLabelsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getLabelsCreateRequest(ctx, options)
			} else {
				req, err = client.getNextPageCreateRequest(ctx, *page.NextLink)
			}
			if err != nil {
				return GetLabelsResponse{}, err
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return GetLabelsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return GetLabelsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getLabelsHandleResponse(resp)
		},
	})
}

// getLabelsCreateRequest creates the GetLabels request.
func (client *Client) getLabelsCreateRequest(ctx context.Context, options *GetLabelsOptions) (*policy.Request, error) {
	urlPath := "/labels"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Name != nil {
		reqQP.Set("name", *options.Name)
	}
	reqQP.Set("api-version", "1.0")
	if options != nil && options.After != nil {
		reqQP.Set("After", *options.After)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$Select", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.Select), "[]")), ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.AcceptDatetime != nil {
		req.Raw().Header["Accept-Datetime"] = []string{*options.AcceptDatetime}
	}
	req.Raw().Header["Accept"] = []string{"application/vnd.microsoft.appconfig.labelset+json, application/json, application/problem+json"}
	return req, nil
}

// getLabelsHandleResponse handles the GetLabels response.
func (client *Client) getLabelsHandleResponse(resp *http.Response) (GetLabelsResponse, error) {
	result := GetLabelsResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.LabelListResult); err != nil {
		return GetLabelsResponse{}, err
	}
	return result, nil
}

// getNextPageCreateRequest creates the GetNextPage request.
func (client *Client) getNextPageCreateRequest(ctx context.Context, nextLink string) (*policy.Request, error) {
	urlPath := "/{nextLink}"
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNextPageHandleResponse handles the GetNextPage response.
func (client *Client) getNextPageHandleResponse(resp *http.Response) (GetNextPageResponse, error) {
	result := GetNextPageResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyListResult); err != nil {
		return GetNextPageResponse{}, err
	}
	return result, nil
}

// NewGetRevisionsPager - Gets a list of key-value revisions.
//
// Generated from API version 1.0
//   - options - GetRevisionsOptions contains the optional parameters for the Client.NewGetRevisionsPager method.
func (client *Client) NewGetRevisionsPager(options *GetRevisionsOptions) (*runtime.Pager[GetRevisionsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[GetRevisionsResponse]{
		More: func(page GetRevisionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *GetRevisionsResponse) (GetRevisionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getRevisionsCreateRequest(ctx, options)
			} else {
				req, err = client.getNextPageCreateRequest(ctx, *page.NextLink)
			}
			if err != nil {
				return GetRevisionsResponse{}, err
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return GetRevisionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return GetRevisionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getRevisionsHandleResponse(resp)
		},
	})
}

// getRevisionsCreateRequest creates the GetRevisions request.
func (client *Client) getRevisionsCreateRequest(ctx context.Context, options *GetRevisionsOptions) (*policy.Request, error) {
	urlPath := "/revisions"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Key != nil {
		reqQP.Set("key", *options.Key)
	}
	if options != nil && options.Label != nil {
		reqQP.Set("label", *options.Label)
	}
	reqQP.Set("api-version", "1.0")
	if options != nil && options.After != nil {
		reqQP.Set("After", *options.After)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$Select", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.Select), "[]")), ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.AcceptDatetime != nil {
		req.Raw().Header["Accept-Datetime"] = []string{*options.AcceptDatetime}
	}
	req.Raw().Header["Accept"] = []string{"application/vnd.microsoft.appconfig.kvset+json, application/json, application/problem+json"}
	return req, nil
}

// getRevisionsHandleResponse handles the GetRevisions response.
func (client *Client) getRevisionsHandleResponse(resp *http.Response) (GetRevisionsResponse, error) {
	result := GetRevisionsResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyValueListResult); err != nil {
		return GetRevisionsResponse{}, err
	}
	return result, nil
}

// GetSetting - Gets a single key-value.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0
//   - key - The key of the key-value to retrieve.
//   - options - GetSettingOptions contains the optional parameters for the Client.GetSetting method.
func (client *Client) GetSetting(ctx context.Context, key string, options *GetSettingOptions) (GetSettingResponse, error) {
	req, err := client.getSettingCreateRequest(ctx, key, options)
	if err != nil {
		return GetSettingResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetSettingResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GetSettingResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSettingHandleResponse(resp)
}

// getSettingCreateRequest creates the GetSetting request.
func (client *Client) getSettingCreateRequest(ctx context.Context, key string, options *GetSettingOptions) (*policy.Request, error) {
	urlPath := "/kv/{key}"
	if key == "" {
		return nil, errors.New("parameter key cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key}", url.PathEscape(key))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Label != nil {
		reqQP.Set("label", *options.Label)
	}
	reqQP.Set("api-version", "1.0")
	if options != nil && options.Select != nil {
		reqQP.Set("$Select", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.Select), "[]")), ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.AcceptDatetime != nil {
		req.Raw().Header["Accept-Datetime"] = []string{*options.AcceptDatetime}
	}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	req.Raw().Header["Accept"] = []string{"application/vnd.microsoft.appconfig.kv+json, application/json, application/problem+json"}
	return req, nil
}

// getSettingHandleResponse handles the GetSetting response.
func (client *Client) getSettingHandleResponse(resp *http.Response) (GetSettingResponse, error) {
	result := GetSettingResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		result.LastModified = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyValue); err != nil {
		return GetSettingResponse{}, err
	}
	return result, nil
}

// SetReadOnly - Locks a key-value.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0
//   - key - The key of the key-value to lock.
//   - options - SetReadOnlyOptions contains the optional parameters for the Client.SetReadOnly method.
func (client *Client) SetReadOnly(ctx context.Context, key string, options *SetReadOnlyOptions) (SetReadOnlyResponse, error) {
	req, err := client.setReadOnlyCreateRequest(ctx, key, options)
	if err != nil {
		return SetReadOnlyResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SetReadOnlyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return SetReadOnlyResponse{}, runtime.NewResponseError(resp)
	}
	return client.setReadOnlyHandleResponse(resp)
}

// setReadOnlyCreateRequest creates the SetReadOnly request.
func (client *Client) setReadOnlyCreateRequest(ctx context.Context, key string, options *SetReadOnlyOptions) (*policy.Request, error) {
	urlPath := "/locks/{key}"
	if key == "" {
		return nil, errors.New("parameter key cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key}", url.PathEscape(key))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Label != nil {
		reqQP.Set("label", *options.Label)
	}
	reqQP.Set("api-version", "1.0")
	req.Raw().URL.RawQuery = reqQP.Encode()
	
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	req.Raw().Header["Accept"] = []string{"application/vnd.microsoft.appconfig.kv+json, application/json, application/problem+json"}
	return req, nil
}

// setReadOnlyHandleResponse handles the SetReadOnly response.
func (client *Client) setReadOnlyHandleResponse(resp *http.Response) (SetReadOnlyResponse, error) {
	result := SetReadOnlyResponse{}
	if val := resp.Header.Get("Sync-Token"); val != "" {
		result.SyncToken = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyValue); err != nil {
		return SetReadOnlyResponse{}, err
	}
	return result, nil
}

