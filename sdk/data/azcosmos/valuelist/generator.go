package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strings"
)

func main() {
	args := os.Args[1:]
	if len(args) != 2 {
		fmt.Println("Usage: generator <input_file> <output_file>")
		os.Exit(1)
	}
	inputFile := args[0]
	outputFile := args[1]

	content, err := generate(inputFile, nil)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating code: %v\n", err)
		os.Exit(1)
	}

	if err := os.WriteFile(outputFile, content, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing file: %v\n", err)
		os.Exit(1)
	}
}

func generate(filename string, src interface{}) ([]byte, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, src, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var sb bytes.Buffer
	// Write package declaration
	fmt.Fprintf(&sb, "// Copyright (c) Microsoft Corporation. All rights reserved.\n")
	fmt.Fprintf(&sb, "// Licensed under the MIT License.\n\n")
	fmt.Fprintf(&sb, "// Code generated by valuelist generator. DO NOT EDIT.\n\n")
	fmt.Fprintf(&sb, "package %s\n\n", node.Name.Name)

	found := false

	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.CONST {
			continue
		}

		if genDecl.Doc == nil {
			continue
		}

		for _, comment := range genDecl.Doc.List {
			text := strings.TrimSpace(comment.Text)
			content := strings.TrimSpace(strings.TrimPrefix(text, "//"))
			if strings.HasPrefix(content, "valueList") {
				parts := strings.Fields(content)
				if len(parts) < 2 {
					continue
				}
				varName := parts[1]

				if err := writeValueList(&sb, varName, genDecl); err != nil {
					return nil, err
				}
				found = true
			}
		}
	}

	if !found {
		return nil, fmt.Errorf("no valueList marker found in %s", filename)
	}

	return format.Source(sb.Bytes())
}

func writeValueList(sb *bytes.Buffer, varName string, decl *ast.GenDecl) error {
	fmt.Fprintf(sb, "var %s []string = []string {\n", varName)
	for _, spec := range decl.Specs {
		vSpec, ok := spec.(*ast.ValueSpec)
		if !ok {
			continue
		}
		for _, name := range vSpec.Names {
			fmt.Fprintf(sb, "\t%s,\n", name.Name)
		}
	}
	fmt.Fprintf(sb, "}\n\n")
	return nil
}
