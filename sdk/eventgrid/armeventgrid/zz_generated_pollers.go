// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armeventgrid

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// DomainTopicsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DomainTopicsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DomainTopicsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (DomainTopicsCreateOrUpdateResponse, error)
}

type domainTopicsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *domainTopicsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *domainTopicsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *domainTopicsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DomainTopicsCreateOrUpdateResponse, error) {
	respType := DomainTopicsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DomainTopic)
	if err != nil {
		return DomainTopicsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *domainTopicsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *domainTopicsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DomainTopicsCreateOrUpdateResponse, error) {
	respType := DomainTopicsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.DomainTopic)
	if err != nil {
		return DomainTopicsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DomainTopicsDeletePoller provides polling facilities until the operation reaches a terminal state.
type DomainTopicsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DomainTopicsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (DomainTopicsDeleteResponse, error)
}

type domainTopicsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *domainTopicsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *domainTopicsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *domainTopicsDeletePoller) FinalResponse(ctx context.Context) (DomainTopicsDeleteResponse, error) {
	respType := DomainTopicsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DomainTopicsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *domainTopicsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *domainTopicsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DomainTopicsDeleteResponse, error) {
	respType := DomainTopicsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DomainTopicsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DomainsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DomainsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DomainsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (DomainsCreateOrUpdateResponse, error)
}

type domainsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *domainsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *domainsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *domainsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DomainsCreateOrUpdateResponse, error) {
	respType := DomainsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Domain)
	if err != nil {
		return DomainsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *domainsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *domainsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DomainsCreateOrUpdateResponse, error) {
	respType := DomainsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Domain)
	if err != nil {
		return DomainsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DomainsDeletePoller provides polling facilities until the operation reaches a terminal state.
type DomainsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DomainsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (DomainsDeleteResponse, error)
}

type domainsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *domainsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *domainsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *domainsDeletePoller) FinalResponse(ctx context.Context) (DomainsDeleteResponse, error) {
	respType := DomainsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DomainsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *domainsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *domainsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DomainsDeleteResponse, error) {
	respType := DomainsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DomainsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DomainsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DomainsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DomainsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (DomainsUpdateResponse, error)
}

type domainsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *domainsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *domainsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *domainsUpdatePoller) FinalResponse(ctx context.Context) (DomainsUpdateResponse, error) {
	respType := DomainsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Domain)
	if err != nil {
		return DomainsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *domainsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *domainsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DomainsUpdateResponse, error) {
	respType := DomainsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Domain)
	if err != nil {
		return DomainsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EventChannelsDeletePoller provides polling facilities until the operation reaches a terminal state.
type EventChannelsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EventChannelsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (EventChannelsDeleteResponse, error)
}

type eventChannelsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *eventChannelsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *eventChannelsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *eventChannelsDeletePoller) FinalResponse(ctx context.Context) (EventChannelsDeleteResponse, error) {
	respType := EventChannelsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return EventChannelsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *eventChannelsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *eventChannelsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (EventChannelsDeleteResponse, error) {
	respType := EventChannelsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return EventChannelsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EventSubscriptionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type EventSubscriptionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EventSubscriptionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (EventSubscriptionsCreateOrUpdateResponse, error)
}

type eventSubscriptionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *eventSubscriptionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *eventSubscriptionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *eventSubscriptionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (EventSubscriptionsCreateOrUpdateResponse, error) {
	respType := EventSubscriptionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EventSubscription)
	if err != nil {
		return EventSubscriptionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *eventSubscriptionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *eventSubscriptionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (EventSubscriptionsCreateOrUpdateResponse, error) {
	respType := EventSubscriptionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.EventSubscription)
	if err != nil {
		return EventSubscriptionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EventSubscriptionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type EventSubscriptionsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EventSubscriptionsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (EventSubscriptionsDeleteResponse, error)
}

type eventSubscriptionsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *eventSubscriptionsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *eventSubscriptionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *eventSubscriptionsDeletePoller) FinalResponse(ctx context.Context) (EventSubscriptionsDeleteResponse, error) {
	respType := EventSubscriptionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return EventSubscriptionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *eventSubscriptionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *eventSubscriptionsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (EventSubscriptionsDeleteResponse, error) {
	respType := EventSubscriptionsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return EventSubscriptionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EventSubscriptionsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type EventSubscriptionsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EventSubscriptionsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (EventSubscriptionsUpdateResponse, error)
}

type eventSubscriptionsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *eventSubscriptionsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *eventSubscriptionsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *eventSubscriptionsUpdatePoller) FinalResponse(ctx context.Context) (EventSubscriptionsUpdateResponse, error) {
	respType := EventSubscriptionsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EventSubscription)
	if err != nil {
		return EventSubscriptionsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *eventSubscriptionsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *eventSubscriptionsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (EventSubscriptionsUpdateResponse, error) {
	respType := EventSubscriptionsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.EventSubscription)
	if err != nil {
		return EventSubscriptionsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PartnerNamespacesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PartnerNamespacesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PartnerNamespacesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PartnerNamespacesCreateOrUpdateResponse, error)
}

type partnerNamespacesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *partnerNamespacesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *partnerNamespacesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *partnerNamespacesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PartnerNamespacesCreateOrUpdateResponse, error) {
	respType := PartnerNamespacesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PartnerNamespace)
	if err != nil {
		return PartnerNamespacesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *partnerNamespacesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *partnerNamespacesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PartnerNamespacesCreateOrUpdateResponse, error) {
	respType := PartnerNamespacesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PartnerNamespace)
	if err != nil {
		return PartnerNamespacesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PartnerNamespacesDeletePoller provides polling facilities until the operation reaches a terminal state.
type PartnerNamespacesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PartnerNamespacesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (PartnerNamespacesDeleteResponse, error)
}

type partnerNamespacesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *partnerNamespacesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *partnerNamespacesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *partnerNamespacesDeletePoller) FinalResponse(ctx context.Context) (PartnerNamespacesDeleteResponse, error) {
	respType := PartnerNamespacesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PartnerNamespacesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *partnerNamespacesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *partnerNamespacesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PartnerNamespacesDeleteResponse, error) {
	respType := PartnerNamespacesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PartnerNamespacesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PartnerNamespacesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PartnerNamespacesUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PartnerNamespacesUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PartnerNamespacesUpdateResponse, error)
}

type partnerNamespacesUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *partnerNamespacesUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *partnerNamespacesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *partnerNamespacesUpdatePoller) FinalResponse(ctx context.Context) (PartnerNamespacesUpdateResponse, error) {
	respType := PartnerNamespacesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PartnerNamespace)
	if err != nil {
		return PartnerNamespacesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *partnerNamespacesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *partnerNamespacesUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PartnerNamespacesUpdateResponse, error) {
	respType := PartnerNamespacesUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PartnerNamespace)
	if err != nil {
		return PartnerNamespacesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PartnerTopicEventSubscriptionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PartnerTopicEventSubscriptionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PartnerTopicEventSubscriptionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PartnerTopicEventSubscriptionsCreateOrUpdateResponse, error)
}

type partnerTopicEventSubscriptionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *partnerTopicEventSubscriptionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *partnerTopicEventSubscriptionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *partnerTopicEventSubscriptionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PartnerTopicEventSubscriptionsCreateOrUpdateResponse, error) {
	respType := PartnerTopicEventSubscriptionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EventSubscription)
	if err != nil {
		return PartnerTopicEventSubscriptionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *partnerTopicEventSubscriptionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *partnerTopicEventSubscriptionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PartnerTopicEventSubscriptionsCreateOrUpdateResponse, error) {
	respType := PartnerTopicEventSubscriptionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.EventSubscription)
	if err != nil {
		return PartnerTopicEventSubscriptionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PartnerTopicEventSubscriptionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PartnerTopicEventSubscriptionsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PartnerTopicEventSubscriptionsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (PartnerTopicEventSubscriptionsDeleteResponse, error)
}

type partnerTopicEventSubscriptionsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *partnerTopicEventSubscriptionsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *partnerTopicEventSubscriptionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *partnerTopicEventSubscriptionsDeletePoller) FinalResponse(ctx context.Context) (PartnerTopicEventSubscriptionsDeleteResponse, error) {
	respType := PartnerTopicEventSubscriptionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PartnerTopicEventSubscriptionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *partnerTopicEventSubscriptionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *partnerTopicEventSubscriptionsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PartnerTopicEventSubscriptionsDeleteResponse, error) {
	respType := PartnerTopicEventSubscriptionsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PartnerTopicEventSubscriptionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PartnerTopicEventSubscriptionsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PartnerTopicEventSubscriptionsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PartnerTopicEventSubscriptionsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PartnerTopicEventSubscriptionsUpdateResponse, error)
}

type partnerTopicEventSubscriptionsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *partnerTopicEventSubscriptionsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *partnerTopicEventSubscriptionsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *partnerTopicEventSubscriptionsUpdatePoller) FinalResponse(ctx context.Context) (PartnerTopicEventSubscriptionsUpdateResponse, error) {
	respType := PartnerTopicEventSubscriptionsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EventSubscription)
	if err != nil {
		return PartnerTopicEventSubscriptionsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *partnerTopicEventSubscriptionsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *partnerTopicEventSubscriptionsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PartnerTopicEventSubscriptionsUpdateResponse, error) {
	respType := PartnerTopicEventSubscriptionsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.EventSubscription)
	if err != nil {
		return PartnerTopicEventSubscriptionsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PartnerTopicsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PartnerTopicsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PartnerTopicsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (PartnerTopicsDeleteResponse, error)
}

type partnerTopicsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *partnerTopicsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *partnerTopicsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *partnerTopicsDeletePoller) FinalResponse(ctx context.Context) (PartnerTopicsDeleteResponse, error) {
	respType := PartnerTopicsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PartnerTopicsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *partnerTopicsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *partnerTopicsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PartnerTopicsDeleteResponse, error) {
	respType := PartnerTopicsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PartnerTopicsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateEndpointConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateEndpointConnectionsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateEndpointConnectionsDeleteResponse, error)
}

type privateEndpointConnectionsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *privateEndpointConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *privateEndpointConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateEndpointConnectionsDeletePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateEndpointConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateEndpointConnectionsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateEndpointConnectionsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateEndpointConnectionsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateEndpointConnectionsUpdateResponse, error)
}

type privateEndpointConnectionsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *privateEndpointConnectionsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *privateEndpointConnectionsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateEndpointConnectionsUpdatePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsUpdateResponse, error) {
	respType := PrivateEndpointConnectionsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateEndpointConnectionsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateEndpointConnectionsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsUpdateResponse, error) {
	respType := PrivateEndpointConnectionsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SystemTopicEventSubscriptionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SystemTopicEventSubscriptionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SystemTopicEventSubscriptionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SystemTopicEventSubscriptionsCreateOrUpdateResponse, error)
}

type systemTopicEventSubscriptionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *systemTopicEventSubscriptionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *systemTopicEventSubscriptionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *systemTopicEventSubscriptionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SystemTopicEventSubscriptionsCreateOrUpdateResponse, error) {
	respType := SystemTopicEventSubscriptionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EventSubscription)
	if err != nil {
		return SystemTopicEventSubscriptionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *systemTopicEventSubscriptionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *systemTopicEventSubscriptionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SystemTopicEventSubscriptionsCreateOrUpdateResponse, error) {
	respType := SystemTopicEventSubscriptionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.EventSubscription)
	if err != nil {
		return SystemTopicEventSubscriptionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SystemTopicEventSubscriptionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type SystemTopicEventSubscriptionsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SystemTopicEventSubscriptionsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (SystemTopicEventSubscriptionsDeleteResponse, error)
}

type systemTopicEventSubscriptionsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *systemTopicEventSubscriptionsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *systemTopicEventSubscriptionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *systemTopicEventSubscriptionsDeletePoller) FinalResponse(ctx context.Context) (SystemTopicEventSubscriptionsDeleteResponse, error) {
	respType := SystemTopicEventSubscriptionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SystemTopicEventSubscriptionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *systemTopicEventSubscriptionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *systemTopicEventSubscriptionsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SystemTopicEventSubscriptionsDeleteResponse, error) {
	respType := SystemTopicEventSubscriptionsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SystemTopicEventSubscriptionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SystemTopicEventSubscriptionsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SystemTopicEventSubscriptionsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SystemTopicEventSubscriptionsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SystemTopicEventSubscriptionsUpdateResponse, error)
}

type systemTopicEventSubscriptionsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *systemTopicEventSubscriptionsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *systemTopicEventSubscriptionsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *systemTopicEventSubscriptionsUpdatePoller) FinalResponse(ctx context.Context) (SystemTopicEventSubscriptionsUpdateResponse, error) {
	respType := SystemTopicEventSubscriptionsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EventSubscription)
	if err != nil {
		return SystemTopicEventSubscriptionsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *systemTopicEventSubscriptionsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *systemTopicEventSubscriptionsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SystemTopicEventSubscriptionsUpdateResponse, error) {
	respType := SystemTopicEventSubscriptionsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.EventSubscription)
	if err != nil {
		return SystemTopicEventSubscriptionsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SystemTopicsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SystemTopicsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SystemTopicsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SystemTopicsCreateOrUpdateResponse, error)
}

type systemTopicsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *systemTopicsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *systemTopicsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *systemTopicsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SystemTopicsCreateOrUpdateResponse, error) {
	respType := SystemTopicsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SystemTopic)
	if err != nil {
		return SystemTopicsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *systemTopicsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *systemTopicsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SystemTopicsCreateOrUpdateResponse, error) {
	respType := SystemTopicsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SystemTopic)
	if err != nil {
		return SystemTopicsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SystemTopicsDeletePoller provides polling facilities until the operation reaches a terminal state.
type SystemTopicsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SystemTopicsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (SystemTopicsDeleteResponse, error)
}

type systemTopicsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *systemTopicsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *systemTopicsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *systemTopicsDeletePoller) FinalResponse(ctx context.Context) (SystemTopicsDeleteResponse, error) {
	respType := SystemTopicsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SystemTopicsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *systemTopicsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *systemTopicsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SystemTopicsDeleteResponse, error) {
	respType := SystemTopicsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SystemTopicsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SystemTopicsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SystemTopicsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SystemTopicsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SystemTopicsUpdateResponse, error)
}

type systemTopicsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *systemTopicsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *systemTopicsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *systemTopicsUpdatePoller) FinalResponse(ctx context.Context) (SystemTopicsUpdateResponse, error) {
	respType := SystemTopicsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SystemTopic)
	if err != nil {
		return SystemTopicsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *systemTopicsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *systemTopicsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SystemTopicsUpdateResponse, error) {
	respType := SystemTopicsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SystemTopic)
	if err != nil {
		return SystemTopicsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// TopicsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type TopicsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final TopicsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (TopicsCreateOrUpdateResponse, error)
}

type topicsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *topicsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *topicsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *topicsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (TopicsCreateOrUpdateResponse, error) {
	respType := TopicsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Topic)
	if err != nil {
		return TopicsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *topicsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *topicsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (TopicsCreateOrUpdateResponse, error) {
	respType := TopicsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Topic)
	if err != nil {
		return TopicsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// TopicsDeletePoller provides polling facilities until the operation reaches a terminal state.
type TopicsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final TopicsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (TopicsDeleteResponse, error)
}

type topicsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *topicsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *topicsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *topicsDeletePoller) FinalResponse(ctx context.Context) (TopicsDeleteResponse, error) {
	respType := TopicsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TopicsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *topicsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *topicsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (TopicsDeleteResponse, error) {
	respType := TopicsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return TopicsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// TopicsRegenerateKeyPoller provides polling facilities until the operation reaches a terminal state.
type TopicsRegenerateKeyPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final TopicsRegenerateKeyResponse will be returned.
	FinalResponse(ctx context.Context) (TopicsRegenerateKeyResponse, error)
}

type topicsRegenerateKeyPoller struct {
	pt *armcore.LROPoller
}

func (p *topicsRegenerateKeyPoller) Done() bool {
	return p.pt.Done()
}

func (p *topicsRegenerateKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *topicsRegenerateKeyPoller) FinalResponse(ctx context.Context) (TopicsRegenerateKeyResponse, error) {
	respType := TopicsRegenerateKeyResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.TopicSharedAccessKeys)
	if err != nil {
		return TopicsRegenerateKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *topicsRegenerateKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *topicsRegenerateKeyPoller) pollUntilDone(ctx context.Context, freq time.Duration) (TopicsRegenerateKeyResponse, error) {
	respType := TopicsRegenerateKeyResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.TopicSharedAccessKeys)
	if err != nil {
		return TopicsRegenerateKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// TopicsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type TopicsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final TopicsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (TopicsUpdateResponse, error)
}

type topicsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *topicsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *topicsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *topicsUpdatePoller) FinalResponse(ctx context.Context) (TopicsUpdateResponse, error) {
	respType := TopicsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Topic)
	if err != nil {
		return TopicsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *topicsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *topicsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (TopicsUpdateResponse, error) {
	respType := TopicsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Topic)
	if err != nil {
		return TopicsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}
