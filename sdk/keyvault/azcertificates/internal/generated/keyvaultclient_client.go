//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package generated

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// KeyVaultClient contains the methods for the KeyVaultClient group.
// Don't use this type directly, use NewKeyVaultClient() instead.
type KeyVaultClient struct {
	con *Connection
}

// NewKeyVaultClient creates a new instance of KeyVaultClient with the specified values.
func NewKeyVaultClient(con *Connection) *KeyVaultClient {
	return &KeyVaultClient{con: con}
}

// BackupCertificate - Requests that a backup of the specified certificate be downloaded to the client. All versions of the certificate will be downloaded.
// This operation requires the certificates/backup permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) BackupCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientBackupCertificateOptions) (KeyVaultClientBackupCertificateResponse, error) {
	req, err := client.backupCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return KeyVaultClientBackupCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientBackupCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientBackupCertificateResponse{}, client.backupCertificateHandleError(resp)
	}
	return client.backupCertificateHandleResponse(resp)
}

// backupCertificateCreateRequest creates the BackupCertificate request.
func (client *KeyVaultClient) backupCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientBackupCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/backup"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// backupCertificateHandleResponse handles the BackupCertificate response.
func (client *KeyVaultClient) backupCertificateHandleResponse(resp *http.Response) (KeyVaultClientBackupCertificateResponse, error) {
	result := KeyVaultClientBackupCertificateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupCertificateResult); err != nil {
		return KeyVaultClientBackupCertificateResponse{}, err
	}
	return result, nil
}

// backupCertificateHandleError handles the BackupCertificate error response.
func (client *KeyVaultClient) backupCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateCertificate - If this is the first version, the certificate resource is created. This operation requires the certificates/create permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) CreateCertificate(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateCreateParameters, options *KeyVaultClientCreateCertificateOptions) (KeyVaultClientCreateCertificateResponse, error) {
	req, err := client.createCertificateCreateRequest(ctx, vaultBaseURL, certificateName, parameters, options)
	if err != nil {
		return KeyVaultClientCreateCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientCreateCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return KeyVaultClientCreateCertificateResponse{}, client.createCertificateHandleError(resp)
	}
	return client.createCertificateHandleResponse(resp)
}

// createCertificateCreateRequest creates the CreateCertificate request.
func (client *KeyVaultClient) createCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateCreateParameters, options *KeyVaultClientCreateCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/create"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createCertificateHandleResponse handles the CreateCertificate response.
func (client *KeyVaultClient) createCertificateHandleResponse(resp *http.Response) (KeyVaultClientCreateCertificateResponse, error) {
	result := KeyVaultClientCreateCertificateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateOperation); err != nil {
		return KeyVaultClientCreateCertificateResponse{}, err
	}
	return result, nil
}

// createCertificateHandleError handles the CreateCertificate error response.
func (client *KeyVaultClient) createCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteCertificate - Deletes all versions of a certificate object along with its associated policy. Delete certificate cannot be used to remove individual
// versions of a certificate object. This operation requires the
// certificates/delete permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) DeleteCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientDeleteCertificateOptions) (KeyVaultClientDeleteCertificateResponse, error) {
	req, err := client.deleteCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return KeyVaultClientDeleteCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientDeleteCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientDeleteCertificateResponse{}, client.deleteCertificateHandleError(resp)
	}
	return client.deleteCertificateHandleResponse(resp)
}

// deleteCertificateCreateRequest creates the DeleteCertificate request.
func (client *KeyVaultClient) deleteCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientDeleteCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteCertificateHandleResponse handles the DeleteCertificate response.
func (client *KeyVaultClient) deleteCertificateHandleResponse(resp *http.Response) (KeyVaultClientDeleteCertificateResponse, error) {
	result := KeyVaultClientDeleteCertificateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedCertificateBundle); err != nil {
		return KeyVaultClientDeleteCertificateResponse{}, err
	}
	return result, nil
}

// deleteCertificateHandleError handles the DeleteCertificate error response.
func (client *KeyVaultClient) deleteCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteCertificateContacts - Deletes the certificate contacts for a specified key vault certificate. This operation requires the certificates/managecontacts
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) DeleteCertificateContacts(ctx context.Context, vaultBaseURL string, options *KeyVaultClientDeleteCertificateContactsOptions) (KeyVaultClientDeleteCertificateContactsResponse, error) {
	req, err := client.deleteCertificateContactsCreateRequest(ctx, vaultBaseURL, options)
	if err != nil {
		return KeyVaultClientDeleteCertificateContactsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientDeleteCertificateContactsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientDeleteCertificateContactsResponse{}, client.deleteCertificateContactsHandleError(resp)
	}
	return client.deleteCertificateContactsHandleResponse(resp)
}

// deleteCertificateContactsCreateRequest creates the DeleteCertificateContacts request.
func (client *KeyVaultClient) deleteCertificateContactsCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientDeleteCertificateContactsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/contacts"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteCertificateContactsHandleResponse handles the DeleteCertificateContacts response.
func (client *KeyVaultClient) deleteCertificateContactsHandleResponse(resp *http.Response) (KeyVaultClientDeleteCertificateContactsResponse, error) {
	result := KeyVaultClientDeleteCertificateContactsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Contacts); err != nil {
		return KeyVaultClientDeleteCertificateContactsResponse{}, err
	}
	return result, nil
}

// deleteCertificateContactsHandleError handles the DeleteCertificateContacts error response.
func (client *KeyVaultClient) deleteCertificateContactsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteCertificateIssuer - The DeleteCertificateIssuer operation permanently removes the specified certificate issuer from the vault. This operation requires
// the certificates/manageissuers/deleteissuers permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) DeleteCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, options *KeyVaultClientDeleteCertificateIssuerOptions) (KeyVaultClientDeleteCertificateIssuerResponse, error) {
	req, err := client.deleteCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, options)
	if err != nil {
		return KeyVaultClientDeleteCertificateIssuerResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientDeleteCertificateIssuerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientDeleteCertificateIssuerResponse{}, client.deleteCertificateIssuerHandleError(resp)
	}
	return client.deleteCertificateIssuerHandleResponse(resp)
}

// deleteCertificateIssuerCreateRequest creates the DeleteCertificateIssuer request.
func (client *KeyVaultClient) deleteCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, options *KeyVaultClientDeleteCertificateIssuerOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteCertificateIssuerHandleResponse handles the DeleteCertificateIssuer response.
func (client *KeyVaultClient) deleteCertificateIssuerHandleResponse(resp *http.Response) (KeyVaultClientDeleteCertificateIssuerResponse, error) {
	result := KeyVaultClientDeleteCertificateIssuerResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.IssuerBundle); err != nil {
		return KeyVaultClientDeleteCertificateIssuerResponse{}, err
	}
	return result, nil
}

// deleteCertificateIssuerHandleError handles the DeleteCertificateIssuer error response.
func (client *KeyVaultClient) deleteCertificateIssuerHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteCertificateOperation - Deletes the creation operation for a specified certificate that is in the process of being created. The certificate is no
// longer created. This operation requires the certificates/update permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) DeleteCertificateOperation(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientDeleteCertificateOperationOptions) (KeyVaultClientDeleteCertificateOperationResponse, error) {
	req, err := client.deleteCertificateOperationCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return KeyVaultClientDeleteCertificateOperationResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientDeleteCertificateOperationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientDeleteCertificateOperationResponse{}, client.deleteCertificateOperationHandleError(resp)
	}
	return client.deleteCertificateOperationHandleResponse(resp)
}

// deleteCertificateOperationCreateRequest creates the DeleteCertificateOperation request.
func (client *KeyVaultClient) deleteCertificateOperationCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientDeleteCertificateOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteCertificateOperationHandleResponse handles the DeleteCertificateOperation response.
func (client *KeyVaultClient) deleteCertificateOperationHandleResponse(resp *http.Response) (KeyVaultClientDeleteCertificateOperationResponse, error) {
	result := KeyVaultClientDeleteCertificateOperationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateOperation); err != nil {
		return KeyVaultClientDeleteCertificateOperationResponse{}, err
	}
	return result, nil
}

// deleteCertificateOperationHandleError handles the DeleteCertificateOperation error response.
func (client *KeyVaultClient) deleteCertificateOperationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetCertificate - Gets information about a specific certificate. This operation requires the certificates/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificate(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, options *KeyVaultClientGetCertificateOptions) (KeyVaultClientGetCertificateResponse, error) {
	req, err := client.getCertificateCreateRequest(ctx, vaultBaseURL, certificateName, certificateVersion, options)
	if err != nil {
		return KeyVaultClientGetCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientGetCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientGetCertificateResponse{}, client.getCertificateHandleError(resp)
	}
	return client.getCertificateHandleResponse(resp)
}

// getCertificateCreateRequest creates the GetCertificate request.
func (client *KeyVaultClient) getCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, options *KeyVaultClientGetCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/{certificate-version}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	if certificateVersion == "" {
		return nil, errors.New("parameter certificateVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-version}", url.PathEscape(certificateVersion))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificateHandleResponse handles the GetCertificate response.
func (client *KeyVaultClient) getCertificateHandleResponse(resp *http.Response) (KeyVaultClientGetCertificateResponse, error) {
	result := KeyVaultClientGetCertificateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		return KeyVaultClientGetCertificateResponse{}, err
	}
	return result, nil
}

// getCertificateHandleError handles the GetCertificate error response.
func (client *KeyVaultClient) getCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetCertificateContacts - The GetCertificateContacts operation returns the set of certificate contact resources in the specified key vault. This operation
// requires the certificates/managecontacts permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificateContacts(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetCertificateContactsOptions) (KeyVaultClientGetCertificateContactsResponse, error) {
	req, err := client.getCertificateContactsCreateRequest(ctx, vaultBaseURL, options)
	if err != nil {
		return KeyVaultClientGetCertificateContactsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientGetCertificateContactsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientGetCertificateContactsResponse{}, client.getCertificateContactsHandleError(resp)
	}
	return client.getCertificateContactsHandleResponse(resp)
}

// getCertificateContactsCreateRequest creates the GetCertificateContacts request.
func (client *KeyVaultClient) getCertificateContactsCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetCertificateContactsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/contacts"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificateContactsHandleResponse handles the GetCertificateContacts response.
func (client *KeyVaultClient) getCertificateContactsHandleResponse(resp *http.Response) (KeyVaultClientGetCertificateContactsResponse, error) {
	result := KeyVaultClientGetCertificateContactsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Contacts); err != nil {
		return KeyVaultClientGetCertificateContactsResponse{}, err
	}
	return result, nil
}

// getCertificateContactsHandleError handles the GetCertificateContacts error response.
func (client *KeyVaultClient) getCertificateContactsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetCertificateIssuer - The GetCertificateIssuer operation returns the specified certificate issuer resources in the specified key vault. This operation
// requires the certificates/manageissuers/getissuers permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, options *KeyVaultClientGetCertificateIssuerOptions) (KeyVaultClientGetCertificateIssuerResponse, error) {
	req, err := client.getCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, options)
	if err != nil {
		return KeyVaultClientGetCertificateIssuerResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientGetCertificateIssuerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientGetCertificateIssuerResponse{}, client.getCertificateIssuerHandleError(resp)
	}
	return client.getCertificateIssuerHandleResponse(resp)
}

// getCertificateIssuerCreateRequest creates the GetCertificateIssuer request.
func (client *KeyVaultClient) getCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, options *KeyVaultClientGetCertificateIssuerOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificateIssuerHandleResponse handles the GetCertificateIssuer response.
func (client *KeyVaultClient) getCertificateIssuerHandleResponse(resp *http.Response) (KeyVaultClientGetCertificateIssuerResponse, error) {
	result := KeyVaultClientGetCertificateIssuerResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.IssuerBundle); err != nil {
		return KeyVaultClientGetCertificateIssuerResponse{}, err
	}
	return result, nil
}

// getCertificateIssuerHandleError handles the GetCertificateIssuer error response.
func (client *KeyVaultClient) getCertificateIssuerHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetCertificateIssuers - The GetCertificateIssuers operation returns the set of certificate issuer resources in the specified key vault. This operation
// requires the certificates/manageissuers/getissuers permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificateIssuers(vaultBaseURL string, options *KeyVaultClientGetCertificateIssuersOptions) *KeyVaultClientGetCertificateIssuersPager {
	return &KeyVaultClientGetCertificateIssuersPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getCertificateIssuersCreateRequest(ctx, vaultBaseURL, options)
		},
		advancer: func(ctx context.Context, resp KeyVaultClientGetCertificateIssuersResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.CertificateIssuerListResult.NextLink)
		},
	}
}

// getCertificateIssuersCreateRequest creates the GetCertificateIssuers request.
func (client *KeyVaultClient) getCertificateIssuersCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetCertificateIssuersOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificateIssuersHandleResponse handles the GetCertificateIssuers response.
func (client *KeyVaultClient) getCertificateIssuersHandleResponse(resp *http.Response) (KeyVaultClientGetCertificateIssuersResponse, error) {
	result := KeyVaultClientGetCertificateIssuersResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateIssuerListResult); err != nil {
		return KeyVaultClientGetCertificateIssuersResponse{}, err
	}
	return result, nil
}

// getCertificateIssuersHandleError handles the GetCertificateIssuers error response.
func (client *KeyVaultClient) getCertificateIssuersHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetCertificateOperation - Gets the creation operation associated with a specified certificate. This operation requires the certificates/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificateOperation(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetCertificateOperationOptions) (KeyVaultClientGetCertificateOperationResponse, error) {
	req, err := client.getCertificateOperationCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return KeyVaultClientGetCertificateOperationResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientGetCertificateOperationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientGetCertificateOperationResponse{}, client.getCertificateOperationHandleError(resp)
	}
	return client.getCertificateOperationHandleResponse(resp)
}

// getCertificateOperationCreateRequest creates the GetCertificateOperation request.
func (client *KeyVaultClient) getCertificateOperationCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetCertificateOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificateOperationHandleResponse handles the GetCertificateOperation response.
func (client *KeyVaultClient) getCertificateOperationHandleResponse(resp *http.Response) (KeyVaultClientGetCertificateOperationResponse, error) {
	result := KeyVaultClientGetCertificateOperationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateOperation); err != nil {
		return KeyVaultClientGetCertificateOperationResponse{}, err
	}
	return result, nil
}

// getCertificateOperationHandleError handles the GetCertificateOperation error response.
func (client *KeyVaultClient) getCertificateOperationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetCertificatePolicy - The GetCertificatePolicy operation returns the specified certificate policy resources in the specified key vault. This operation
// requires the certificates/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificatePolicy(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetCertificatePolicyOptions) (KeyVaultClientGetCertificatePolicyResponse, error) {
	req, err := client.getCertificatePolicyCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return KeyVaultClientGetCertificatePolicyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientGetCertificatePolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientGetCertificatePolicyResponse{}, client.getCertificatePolicyHandleError(resp)
	}
	return client.getCertificatePolicyHandleResponse(resp)
}

// getCertificatePolicyCreateRequest creates the GetCertificatePolicy request.
func (client *KeyVaultClient) getCertificatePolicyCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetCertificatePolicyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/policy"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificatePolicyHandleResponse handles the GetCertificatePolicy response.
func (client *KeyVaultClient) getCertificatePolicyHandleResponse(resp *http.Response) (KeyVaultClientGetCertificatePolicyResponse, error) {
	result := KeyVaultClientGetCertificatePolicyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificatePolicy); err != nil {
		return KeyVaultClientGetCertificatePolicyResponse{}, err
	}
	return result, nil
}

// getCertificatePolicyHandleError handles the GetCertificatePolicy error response.
func (client *KeyVaultClient) getCertificatePolicyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetCertificateVersions - The GetCertificateVersions operation returns the versions of a certificate in the specified key vault. This operation requires
// the certificates/list permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificateVersions(vaultBaseURL string, certificateName string, options *KeyVaultClientGetCertificateVersionsOptions) *KeyVaultClientGetCertificateVersionsPager {
	return &KeyVaultClientGetCertificateVersionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getCertificateVersionsCreateRequest(ctx, vaultBaseURL, certificateName, options)
		},
		advancer: func(ctx context.Context, resp KeyVaultClientGetCertificateVersionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.CertificateListResult.NextLink)
		},
	}
}

// getCertificateVersionsCreateRequest creates the GetCertificateVersions request.
func (client *KeyVaultClient) getCertificateVersionsCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetCertificateVersionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/versions"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificateVersionsHandleResponse handles the GetCertificateVersions response.
func (client *KeyVaultClient) getCertificateVersionsHandleResponse(resp *http.Response) (KeyVaultClientGetCertificateVersionsResponse, error) {
	result := KeyVaultClientGetCertificateVersionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateListResult); err != nil {
		return KeyVaultClientGetCertificateVersionsResponse{}, err
	}
	return result, nil
}

// getCertificateVersionsHandleError handles the GetCertificateVersions error response.
func (client *KeyVaultClient) getCertificateVersionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetCertificates - The GetCertificates operation returns the set of certificates resources in the specified key vault. This operation requires the certificates/list
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificates(vaultBaseURL string, options *KeyVaultClientGetCertificatesOptions) *KeyVaultClientGetCertificatesPager {
	return &KeyVaultClientGetCertificatesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getCertificatesCreateRequest(ctx, vaultBaseURL, options)
		},
		advancer: func(ctx context.Context, resp KeyVaultClientGetCertificatesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.CertificateListResult.NextLink)
		},
	}
}

// getCertificatesCreateRequest creates the GetCertificates request.
func (client *KeyVaultClient) getCertificatesCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetCertificatesOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.IncludePending != nil {
		reqQP.Set("includePending", strconv.FormatBool(*options.IncludePending))
	}
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificatesHandleResponse handles the GetCertificates response.
func (client *KeyVaultClient) getCertificatesHandleResponse(resp *http.Response) (KeyVaultClientGetCertificatesResponse, error) {
	result := KeyVaultClientGetCertificatesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateListResult); err != nil {
		return KeyVaultClientGetCertificatesResponse{}, err
	}
	return result, nil
}

// getCertificatesHandleError handles the GetCertificates error response.
func (client *KeyVaultClient) getCertificatesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDeletedCertificate - The GetDeletedCertificate operation retrieves the deleted certificate information plus its attributes, such as retention interval,
// scheduled permanent deletion and the current deletion recovery level.
// This operation requires the certificates/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetDeletedCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetDeletedCertificateOptions) (KeyVaultClientGetDeletedCertificateResponse, error) {
	req, err := client.getDeletedCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return KeyVaultClientGetDeletedCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientGetDeletedCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientGetDeletedCertificateResponse{}, client.getDeletedCertificateHandleError(resp)
	}
	return client.getDeletedCertificateHandleResponse(resp)
}

// getDeletedCertificateCreateRequest creates the GetDeletedCertificate request.
func (client *KeyVaultClient) getDeletedCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetDeletedCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates/{certificate-name}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDeletedCertificateHandleResponse handles the GetDeletedCertificate response.
func (client *KeyVaultClient) getDeletedCertificateHandleResponse(resp *http.Response) (KeyVaultClientGetDeletedCertificateResponse, error) {
	result := KeyVaultClientGetDeletedCertificateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedCertificateBundle); err != nil {
		return KeyVaultClientGetDeletedCertificateResponse{}, err
	}
	return result, nil
}

// getDeletedCertificateHandleError handles the GetDeletedCertificate error response.
func (client *KeyVaultClient) getDeletedCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDeletedCertificates - The GetDeletedCertificates operation retrieves the certificates in the current vault which are in a deleted state and ready
// for recovery or purging. This operation includes deletion-specific
// information. This operation requires the certificates/get/list permission. This operation can only be enabled on soft-delete enabled vaults.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetDeletedCertificates(vaultBaseURL string, options *KeyVaultClientGetDeletedCertificatesOptions) *KeyVaultClientGetDeletedCertificatesPager {
	return &KeyVaultClientGetDeletedCertificatesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getDeletedCertificatesCreateRequest(ctx, vaultBaseURL, options)
		},
		advancer: func(ctx context.Context, resp KeyVaultClientGetDeletedCertificatesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.DeletedCertificateListResult.NextLink)
		},
	}
}

// getDeletedCertificatesCreateRequest creates the GetDeletedCertificates request.
func (client *KeyVaultClient) getDeletedCertificatesCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetDeletedCertificatesOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.IncludePending != nil {
		reqQP.Set("includePending", strconv.FormatBool(*options.IncludePending))
	}
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDeletedCertificatesHandleResponse handles the GetDeletedCertificates response.
func (client *KeyVaultClient) getDeletedCertificatesHandleResponse(resp *http.Response) (KeyVaultClientGetDeletedCertificatesResponse, error) {
	result := KeyVaultClientGetDeletedCertificatesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedCertificateListResult); err != nil {
		return KeyVaultClientGetDeletedCertificatesResponse{}, err
	}
	return result, nil
}

// getDeletedCertificatesHandleError handles the GetDeletedCertificates error response.
func (client *KeyVaultClient) getDeletedCertificatesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ImportCertificate - Imports an existing valid certificate, containing a private key, into Azure Key Vault. This operation requires the certificates/import
// permission. The certificate to be imported can be in either PFX
// or PEM format. If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates. Key Vault will only accept a key in
// PKCS#8 format.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) ImportCertificate(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateImportParameters, options *KeyVaultClientImportCertificateOptions) (KeyVaultClientImportCertificateResponse, error) {
	req, err := client.importCertificateCreateRequest(ctx, vaultBaseURL, certificateName, parameters, options)
	if err != nil {
		return KeyVaultClientImportCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientImportCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientImportCertificateResponse{}, client.importCertificateHandleError(resp)
	}
	return client.importCertificateHandleResponse(resp)
}

// importCertificateCreateRequest creates the ImportCertificate request.
func (client *KeyVaultClient) importCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateImportParameters, options *KeyVaultClientImportCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/import"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// importCertificateHandleResponse handles the ImportCertificate response.
func (client *KeyVaultClient) importCertificateHandleResponse(resp *http.Response) (KeyVaultClientImportCertificateResponse, error) {
	result := KeyVaultClientImportCertificateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		return KeyVaultClientImportCertificateResponse{}, err
	}
	return result, nil
}

// importCertificateHandleError handles the ImportCertificate error response.
func (client *KeyVaultClient) importCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// MergeCertificate - The MergeCertificate operation performs the merging of a certificate or certificate chain with a key pair currently available in the
// service. This operation requires the certificates/create
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) MergeCertificate(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateMergeParameters, options *KeyVaultClientMergeCertificateOptions) (KeyVaultClientMergeCertificateResponse, error) {
	req, err := client.mergeCertificateCreateRequest(ctx, vaultBaseURL, certificateName, parameters, options)
	if err != nil {
		return KeyVaultClientMergeCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientMergeCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return KeyVaultClientMergeCertificateResponse{}, client.mergeCertificateHandleError(resp)
	}
	return client.mergeCertificateHandleResponse(resp)
}

// mergeCertificateCreateRequest creates the MergeCertificate request.
func (client *KeyVaultClient) mergeCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateMergeParameters, options *KeyVaultClientMergeCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending/merge"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// mergeCertificateHandleResponse handles the MergeCertificate response.
func (client *KeyVaultClient) mergeCertificateHandleResponse(resp *http.Response) (KeyVaultClientMergeCertificateResponse, error) {
	result := KeyVaultClientMergeCertificateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		return KeyVaultClientMergeCertificateResponse{}, err
	}
	return result, nil
}

// mergeCertificateHandleError handles the MergeCertificate error response.
func (client *KeyVaultClient) mergeCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PurgeDeletedCertificate - The PurgeDeletedCertificate operation performs an irreversible deletion of the specified certificate, without possibility for
// recovery. The operation is not available if the recovery level does not
// specify 'Purgeable'. This operation requires the certificate/purge permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) PurgeDeletedCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientPurgeDeletedCertificateOptions) (KeyVaultClientPurgeDeletedCertificateResponse, error) {
	req, err := client.purgeDeletedCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return KeyVaultClientPurgeDeletedCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientPurgeDeletedCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return KeyVaultClientPurgeDeletedCertificateResponse{}, client.purgeDeletedCertificateHandleError(resp)
	}
	return KeyVaultClientPurgeDeletedCertificateResponse{RawResponse: resp}, nil
}

// purgeDeletedCertificateCreateRequest creates the PurgeDeletedCertificate request.
func (client *KeyVaultClient) purgeDeletedCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientPurgeDeletedCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates/{certificate-name}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// purgeDeletedCertificateHandleError handles the PurgeDeletedCertificate error response.
func (client *KeyVaultClient) purgeDeletedCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// RecoverDeletedCertificate - The RecoverDeletedCertificate operation performs the reversal of the Delete operation. The operation is applicable in vaults
// enabled for soft-delete, and must be issued during the retention interval
// (available in the deleted certificate's attributes). This operation requires the certificates/recover permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RecoverDeletedCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientRecoverDeletedCertificateOptions) (KeyVaultClientRecoverDeletedCertificateResponse, error) {
	req, err := client.recoverDeletedCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return KeyVaultClientRecoverDeletedCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientRecoverDeletedCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientRecoverDeletedCertificateResponse{}, client.recoverDeletedCertificateHandleError(resp)
	}
	return client.recoverDeletedCertificateHandleResponse(resp)
}

// recoverDeletedCertificateCreateRequest creates the RecoverDeletedCertificate request.
func (client *KeyVaultClient) recoverDeletedCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientRecoverDeletedCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates/{certificate-name}/recover"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// recoverDeletedCertificateHandleResponse handles the RecoverDeletedCertificate response.
func (client *KeyVaultClient) recoverDeletedCertificateHandleResponse(resp *http.Response) (KeyVaultClientRecoverDeletedCertificateResponse, error) {
	result := KeyVaultClientRecoverDeletedCertificateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		return KeyVaultClientRecoverDeletedCertificateResponse{}, err
	}
	return result, nil
}

// recoverDeletedCertificateHandleError handles the RecoverDeletedCertificate error response.
func (client *KeyVaultClient) recoverDeletedCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// RestoreCertificate - Restores a backed up certificate, and all its versions, to a vault. This operation requires the certificates/restore permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RestoreCertificate(ctx context.Context, vaultBaseURL string, parameters CertificateRestoreParameters, options *KeyVaultClientRestoreCertificateOptions) (KeyVaultClientRestoreCertificateResponse, error) {
	req, err := client.restoreCertificateCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return KeyVaultClientRestoreCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientRestoreCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientRestoreCertificateResponse{}, client.restoreCertificateHandleError(resp)
	}
	return client.restoreCertificateHandleResponse(resp)
}

// restoreCertificateCreateRequest creates the RestoreCertificate request.
func (client *KeyVaultClient) restoreCertificateCreateRequest(ctx context.Context, vaultBaseURL string, parameters CertificateRestoreParameters, options *KeyVaultClientRestoreCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// restoreCertificateHandleResponse handles the RestoreCertificate response.
func (client *KeyVaultClient) restoreCertificateHandleResponse(resp *http.Response) (KeyVaultClientRestoreCertificateResponse, error) {
	result := KeyVaultClientRestoreCertificateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		return KeyVaultClientRestoreCertificateResponse{}, err
	}
	return result, nil
}

// restoreCertificateHandleError handles the RestoreCertificate error response.
func (client *KeyVaultClient) restoreCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetCertificateContacts - Sets the certificate contacts for the specified key vault. This operation requires the certificates/managecontacts permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) SetCertificateContacts(ctx context.Context, vaultBaseURL string, contacts Contacts, options *KeyVaultClientSetCertificateContactsOptions) (KeyVaultClientSetCertificateContactsResponse, error) {
	req, err := client.setCertificateContactsCreateRequest(ctx, vaultBaseURL, contacts, options)
	if err != nil {
		return KeyVaultClientSetCertificateContactsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientSetCertificateContactsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientSetCertificateContactsResponse{}, client.setCertificateContactsHandleError(resp)
	}
	return client.setCertificateContactsHandleResponse(resp)
}

// setCertificateContactsCreateRequest creates the SetCertificateContacts request.
func (client *KeyVaultClient) setCertificateContactsCreateRequest(ctx context.Context, vaultBaseURL string, contacts Contacts, options *KeyVaultClientSetCertificateContactsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/contacts"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, contacts)
}

// setCertificateContactsHandleResponse handles the SetCertificateContacts response.
func (client *KeyVaultClient) setCertificateContactsHandleResponse(resp *http.Response) (KeyVaultClientSetCertificateContactsResponse, error) {
	result := KeyVaultClientSetCertificateContactsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Contacts); err != nil {
		return KeyVaultClientSetCertificateContactsResponse{}, err
	}
	return result, nil
}

// setCertificateContactsHandleError handles the SetCertificateContacts error response.
func (client *KeyVaultClient) setCertificateContactsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetCertificateIssuer - The SetCertificateIssuer operation adds or updates the specified certificate issuer. This operation requires the certificates/setissuers
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) SetCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerSetParameters, options *KeyVaultClientSetCertificateIssuerOptions) (KeyVaultClientSetCertificateIssuerResponse, error) {
	req, err := client.setCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, parameter, options)
	if err != nil {
		return KeyVaultClientSetCertificateIssuerResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientSetCertificateIssuerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientSetCertificateIssuerResponse{}, client.setCertificateIssuerHandleError(resp)
	}
	return client.setCertificateIssuerHandleResponse(resp)
}

// setCertificateIssuerCreateRequest creates the SetCertificateIssuer request.
func (client *KeyVaultClient) setCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerSetParameters, options *KeyVaultClientSetCertificateIssuerOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameter)
}

// setCertificateIssuerHandleResponse handles the SetCertificateIssuer response.
func (client *KeyVaultClient) setCertificateIssuerHandleResponse(resp *http.Response) (KeyVaultClientSetCertificateIssuerResponse, error) {
	result := KeyVaultClientSetCertificateIssuerResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.IssuerBundle); err != nil {
		return KeyVaultClientSetCertificateIssuerResponse{}, err
	}
	return result, nil
}

// setCertificateIssuerHandleError handles the SetCertificateIssuer error response.
func (client *KeyVaultClient) setCertificateIssuerHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateCertificate - The UpdateCertificate operation applies the specified update on the given certificate; the only elements updated are the certificate's
// attributes. This operation requires the certificates/update
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UpdateCertificate(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, parameters CertificateUpdateParameters, options *KeyVaultClientUpdateCertificateOptions) (KeyVaultClientUpdateCertificateResponse, error) {
	req, err := client.updateCertificateCreateRequest(ctx, vaultBaseURL, certificateName, certificateVersion, parameters, options)
	if err != nil {
		return KeyVaultClientUpdateCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientUpdateCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientUpdateCertificateResponse{}, client.updateCertificateHandleError(resp)
	}
	return client.updateCertificateHandleResponse(resp)
}

// updateCertificateCreateRequest creates the UpdateCertificate request.
func (client *KeyVaultClient) updateCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, parameters CertificateUpdateParameters, options *KeyVaultClientUpdateCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/{certificate-version}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	if certificateVersion == "" {
		return nil, errors.New("parameter certificateVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-version}", url.PathEscape(certificateVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateCertificateHandleResponse handles the UpdateCertificate response.
func (client *KeyVaultClient) updateCertificateHandleResponse(resp *http.Response) (KeyVaultClientUpdateCertificateResponse, error) {
	result := KeyVaultClientUpdateCertificateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		return KeyVaultClientUpdateCertificateResponse{}, err
	}
	return result, nil
}

// updateCertificateHandleError handles the UpdateCertificate error response.
func (client *KeyVaultClient) updateCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateCertificateIssuer - The UpdateCertificateIssuer operation performs an update on the specified certificate issuer entity. This operation requires
// the certificates/setissuers permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UpdateCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerUpdateParameters, options *KeyVaultClientUpdateCertificateIssuerOptions) (KeyVaultClientUpdateCertificateIssuerResponse, error) {
	req, err := client.updateCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, parameter, options)
	if err != nil {
		return KeyVaultClientUpdateCertificateIssuerResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientUpdateCertificateIssuerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientUpdateCertificateIssuerResponse{}, client.updateCertificateIssuerHandleError(resp)
	}
	return client.updateCertificateIssuerHandleResponse(resp)
}

// updateCertificateIssuerCreateRequest creates the UpdateCertificateIssuer request.
func (client *KeyVaultClient) updateCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerUpdateParameters, options *KeyVaultClientUpdateCertificateIssuerOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameter)
}

// updateCertificateIssuerHandleResponse handles the UpdateCertificateIssuer response.
func (client *KeyVaultClient) updateCertificateIssuerHandleResponse(resp *http.Response) (KeyVaultClientUpdateCertificateIssuerResponse, error) {
	result := KeyVaultClientUpdateCertificateIssuerResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.IssuerBundle); err != nil {
		return KeyVaultClientUpdateCertificateIssuerResponse{}, err
	}
	return result, nil
}

// updateCertificateIssuerHandleError handles the UpdateCertificateIssuer error response.
func (client *KeyVaultClient) updateCertificateIssuerHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateCertificateOperation - Updates a certificate creation operation that is already in progress. This operation requires the certificates/update permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UpdateCertificateOperation(ctx context.Context, vaultBaseURL string, certificateName string, certificateOperation CertificateOperationUpdateParameter, options *KeyVaultClientUpdateCertificateOperationOptions) (KeyVaultClientUpdateCertificateOperationResponse, error) {
	req, err := client.updateCertificateOperationCreateRequest(ctx, vaultBaseURL, certificateName, certificateOperation, options)
	if err != nil {
		return KeyVaultClientUpdateCertificateOperationResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientUpdateCertificateOperationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientUpdateCertificateOperationResponse{}, client.updateCertificateOperationHandleError(resp)
	}
	return client.updateCertificateOperationHandleResponse(resp)
}

// updateCertificateOperationCreateRequest creates the UpdateCertificateOperation request.
func (client *KeyVaultClient) updateCertificateOperationCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificateOperation CertificateOperationUpdateParameter, options *KeyVaultClientUpdateCertificateOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, certificateOperation)
}

// updateCertificateOperationHandleResponse handles the UpdateCertificateOperation response.
func (client *KeyVaultClient) updateCertificateOperationHandleResponse(resp *http.Response) (KeyVaultClientUpdateCertificateOperationResponse, error) {
	result := KeyVaultClientUpdateCertificateOperationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateOperation); err != nil {
		return KeyVaultClientUpdateCertificateOperationResponse{}, err
	}
	return result, nil
}

// updateCertificateOperationHandleError handles the UpdateCertificateOperation error response.
func (client *KeyVaultClient) updateCertificateOperationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateCertificatePolicy - Set specified members in the certificate policy. Leave others as null. This operation requires the certificates/update permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UpdateCertificatePolicy(ctx context.Context, vaultBaseURL string, certificateName string, certificatePolicy CertificatePolicy, options *KeyVaultClientUpdateCertificatePolicyOptions) (KeyVaultClientUpdateCertificatePolicyResponse, error) {
	req, err := client.updateCertificatePolicyCreateRequest(ctx, vaultBaseURL, certificateName, certificatePolicy, options)
	if err != nil {
		return KeyVaultClientUpdateCertificatePolicyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientUpdateCertificatePolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return KeyVaultClientUpdateCertificatePolicyResponse{}, client.updateCertificatePolicyHandleError(resp)
	}
	return client.updateCertificatePolicyHandleResponse(resp)
}

// updateCertificatePolicyCreateRequest creates the UpdateCertificatePolicy request.
func (client *KeyVaultClient) updateCertificatePolicyCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificatePolicy CertificatePolicy, options *KeyVaultClientUpdateCertificatePolicyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/policy"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.3-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, certificatePolicy)
}

// updateCertificatePolicyHandleResponse handles the UpdateCertificatePolicy response.
func (client *KeyVaultClient) updateCertificatePolicyHandleResponse(resp *http.Response) (KeyVaultClientUpdateCertificatePolicyResponse, error) {
	result := KeyVaultClientUpdateCertificatePolicyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificatePolicy); err != nil {
		return KeyVaultClientUpdateCertificatePolicyResponse{}, err
	}
	return result, nil
}

// updateCertificatePolicyHandleError handles the UpdateCertificatePolicy error response.
func (client *KeyVaultClient) updateCertificatePolicyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
