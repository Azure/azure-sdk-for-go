//go:build go1.16
// +build go1.16

// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.4.3, generator: @autorest/go@4.0.0-preview.27)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azsecrets

import (
	"context"
	"errors"
	"net/http"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/keyvault/azsecrets/internal"
)

type Client struct {
	kvClient *internal.KeyVaultClient
	vaultUrl string
}

type ClientOptions struct {
	// HTTPClient sets the transport for making HTTP requests.
	HTTPClient policy.Transporter
	// Retry configures the built-in retry policy behavior.
	Retry policy.RetryOptions
	// Telemetry configures the built-in telemetry policy behavior.
	Telemetry policy.TelemetryOptions
	// Logging configures the built-in logging policy behavior.
	Logging policy.LogOptions
	// PerCallPolicies contains custom policies to inject into the pipeline.
	// Each policy is executed once per request.
	PerCallPolicies []policy.Policy
	// PerRetryPolicies contains custom policies to inject into the pipeline.
	// Each policy is executed once per request, and for each retry request.
	PerRetryPolicies []policy.Policy
}

func (c *ClientOptions) toConnectionOptions() *internal.ConnectionOptions {
	if c == nil {
		return nil
	}

	return &internal.ConnectionOptions{
		HTTPClient:       c.HTTPClient,
		Retry:            c.Retry,
		Telemetry:        c.Telemetry,
		Logging:          c.Logging,
		PerCallPolicies:  c.PerCallPolicies,
		PerRetryPolicies: c.PerRetryPolicies,
	}
}

// NewClient returns a pointer to a Client object affinitized to a vaultUrl.
func NewClient(vaultUrl string, credential azcore.TokenCredential, options *ClientOptions) (*Client, error) {
	if options == nil {
		options = &ClientOptions{}
	}

	conn := internal.NewConnection(credential, options.toConnectionOptions())

	return &Client{
		kvClient: &internal.KeyVaultClient{
			Con: conn,
		},
		vaultUrl: vaultUrl,
	}, nil
}

type GetSecretOptions struct {
}

func (g *GetSecretOptions) toGenerated() *internal.KeyVaultClientGetSecretOptions {
	if g == nil {
		return &internal.KeyVaultClientGetSecretOptions{}
	}
	return &internal.KeyVaultClientGetSecretOptions{}
}

type GetSecretResponse struct {
	RawResponse *http.Response
	Attributes  *internal.SecretAttributes
	ID          *string
	Tags        map[string]*string
	Value       *string
	Kid         *string
	Managed     *bool
}

func getSecretResponseFromGenerated(i internal.KeyVaultClientGetSecretResponse) *GetSecretResponse {
	return &GetSecretResponse{
		RawResponse: i.RawResponse,
		Attributes:  i.Attributes,
		ID:          i.ID,
		Tags:        i.Tags,
		Value:       i.Value,
		Kid:         i.Kid,
		Managed:     i.Managed,
	}
}

func (c *Client) GetSecret(ctx context.Context, name string, secretVersion string, options *GetSecretOptions) (GetSecretResponse, error) {
	resp, err := c.kvClient.GetSecret(ctx, c.vaultUrl, name, secretVersion, options.toGenerated())
	return *getSecretResponseFromGenerated(resp), err
}

type SetSecretOptions struct {
	// Type of the secret value such as a password.
	ContentType *string `json:"contentType,omitempty"`

	// The secret management attributes.
	SecretAttributes *internal.SecretAttributes `json:"attributes,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

func (s *SetSecretOptions) toGenerated() *internal.KeyVaultClientSetSecretOptions {
	if s == nil {
		return nil
	}
	return &internal.KeyVaultClientSetSecretOptions{}
}

type SetSecretResponse struct {
	RawResponse *http.Response

	// The secret management attributes.
	Attributes *internal.SecretAttributes `json:"attributes,omitempty"`

	// The secret id.
	ID *string `json:"id,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// The secret value.
	Value *string `json:"value,omitempty"`

	// READ-ONLY; If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
	Kid *string `json:"kid,omitempty" azure:"ro"`

	// READ-ONLY; True if the secret's lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
	Managed *bool `json:"managed,omitempty" azure:"ro"`
}

func setSecretResponseFromGenerated(i internal.KeyVaultClientSetSecretResponse) *SetSecretResponse {
	return &SetSecretResponse{
		RawResponse: i.RawResponse,
		Attributes:  i.Attributes,
		ID:          i.ID,
		Tags:        i.Tags,
		Value:       i.Value,
		Kid:         i.Kid,
		Managed:     i.Managed,
	}
}

type SetSecretParameters struct {
}

func (c *Client) SetSecret(ctx context.Context, name string, value string, options *SetSecretOptions) (SetSecretResponse, error) {
	if options == nil {
		options = &SetSecretOptions{}
	}
	resp, err := c.kvClient.SetSecret(ctx, c.vaultUrl, name, internal.SecretSetParameters{
		Value:            &value,
		ContentType:      options.ContentType,
		SecretAttributes: options.SecretAttributes,
		Tags:             options.Tags,
	}, options.toGenerated())
	return *setSecretResponseFromGenerated(resp), err
}

type DeleteSecretResponse struct {
	DeletedSecretBundle
	RawResponse *http.Response
}

func deleteSecretResponseFromGenerated(i *internal.KeyVaultClientDeleteSecretResponse) *DeleteSecretResponse {
	if i == nil {
		return nil
	}
	return &DeleteSecretResponse{
		RawResponse: i.RawResponse,
	}
}

// BeginDeleteSecretOptions contains the optional parameters for the Client.BeginDeleteSecret method.
type BeginDeleteSecretOptions struct {
	// placeholder for future optional parameters
}

func (b *BeginDeleteSecretOptions) toGenerated() *internal.KeyVaultClientDeleteSecretOptions {
	return &internal.KeyVaultClientDeleteSecretOptions{}
}

type DeleteSecretPoller interface {
	// Done returns true if the LRO has reached a terminal state
	Done() bool

	// ResumeToken returns a value representing the poller that can be used to resume
	// the LRO at a later time. ResumeTokens are unique per service operation
	ResumeToken() string

	// Poll fetches the latest state of the LRO. It returns an HTTP response or error.
	// If the LRO has completed successfully, the poller's state is updated and the HTTP response is returned.
	// If the LRO has completed with failure or was cancelled, the poller's state is updated and the error is returned.

	Poll(context.Context) (*http.Response, error)
	FinalResponse(context.Context) (DeleteSecretResponse, error)
}

type startDeletePoller struct {
	secretName     string // This is the secret to Poll for in GetDeletedSecret
	vaultUrl       string
	client         *internal.KeyVaultClient
	deleteResponse internal.KeyVaultClientDeleteSecretResponse
}

func (s *startDeletePoller) Done() bool {
	return false
}

func (s *startDeletePoller) ResumeToken() string {
	return ""
}

func (s *startDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	resp, err := s.client.GetDeletedSecret(context.Background(), s.vaultUrl, s.secretName, nil)
	if err != nil {
		return resp.RawResponse, err
	}
	return resp.RawResponse, nil
}

func (s *startDeletePoller) FinalResponse(context.Context) (DeleteSecretResponse, error) {
	return *deleteSecretResponseFromGenerated(&s.deleteResponse), nil
}

func (c *Client) BeginDeleteSecret(ctx context.Context, name string, options *BeginDeleteSecretOptions) (DeleteSecretPoller, error) {
	// TODO: this is kvSecretClient.DeleteSecret and a GetDeletedSecret under the hood for the polling version
	if options == nil {
		options = &BeginDeleteSecretOptions{}
	}
	resp, err := c.kvClient.DeleteSecret(ctx, c.vaultUrl, name, options.toGenerated())
	if err != nil {
		return &startDeletePoller{}, err
	}

	return &startDeletePoller{
		vaultUrl:       c.vaultUrl,
		secretName:     name,
		client:         c.kvClient,
		deleteResponse: resp,
	}, nil
}

type GetDeletedSecretOptions struct{}

type GetDeletedSecretResponse struct{}

func (c *Client) GetDeletedSecret(ctx context.Context, name string, options *GetDeletedSecretOptions) (GetDeletedSecretResponse, error) {
	if options == nil {
		options = &GetDeletedSecretOptions{}
	}

	return GetDeletedSecretResponse{}, errors.New("not implemented")
}

type UpdateSecretPropertiesOptions struct{}

type UpdateSecretPropertiesResponse struct{}

func (c *Client) UpdateSecretProperties(ctx context.Context, options *UpdateSecretPropertiesOptions) (UpdateSecretPropertiesResponse, error) {
	if options == nil {
		options = &UpdateSecretPropertiesOptions{}
	}

	return UpdateSecretPropertiesResponse{}, errors.New("not implemented")
}

type BackupSecretOptions struct{}

type BackupSecretResponse struct{}

func (c *Client) BackupSecret(ctx context.Context, options *BackupSecretOptions) (BackupSecretResponse, error) {
	if options == nil {
		options = &BackupSecretOptions{}
	}

	return BackupSecretResponse{}, errors.New("not implemented")
}

type RestoreSecretBackupOptions struct{}

type RestoreSecretBackupResponse struct{}

func (c *Client) RestoreSecretBackup(ctx context.Context, options *RestoreSecretBackupOptions) (RestoreSecretBackupResponse, error) {
	if options == nil {
		options = &RestoreSecretBackupOptions{}
	}

	return RestoreSecretBackupResponse{}, errors.New("not implemented")
}

type PurgeDeletedSecretOptions struct{}

type PurgeDeletedSecretResponse struct{}

func (c *Client) PurgeDeletedSecret(ctx context.Context, options *PurgeDeletedSecretOptions) (PurgeDeletedSecretResponse, error) {
	if options == nil {
		options = &PurgeDeletedSecretOptions{}
	}

	return PurgeDeletedSecretResponse{}, errors.New("not implemented")
}

type StartRecoverDeletedSecretOptions struct{}

type StartRecoverDeletedSecretResponse struct{}

func (c *Client) StartRecoverDeletedSecret(ctx context.Context, options *StartRecoverDeletedSecretOptions) (StartRecoverDeletedSecretResponse, error) {
	if options == nil {
		options = &StartRecoverDeletedSecretOptions{}
	}

	return StartRecoverDeletedSecretResponse{}, errors.New("not implemented")
}

type GetSecretPropertiesOptions struct{}

type GetSecretPropertiesResponse struct{}

func (c *Client) GetSecretProperties(ctx context.Context, options *GetSecretPropertiesOptions) (GetSecretPropertiesResponse, error) {
	if options == nil {
		options = &GetSecretPropertiesOptions{}
	}

	return GetSecretPropertiesResponse{}, errors.New("not implemented")
}

type GetSecretVersionsPropertiesOptions struct{}

type GetSecretVersionsPropertiesResponse struct{}

func (c *Client) GetSecretVersionsProperties(ctx context.Context, options *GetSecretVersionsPropertiesOptions) (GetSecretVersionsPropertiesResponse, error) {
	if options == nil {
		options = &GetSecretVersionsPropertiesOptions{}
	}

	return GetSecretVersionsPropertiesResponse{}, errors.New("not implemented")
}

type ListDeletedSecretsOptions struct{}

type ListDeletedSecretsResponse struct{}

func (c *Client) ListDeletedSecrets(ctx context.Context, options *ListDeletedSecretsOptions) (ListDeletedSecretsResponse, error) {
	if options == nil {
		options = &ListDeletedSecretsOptions{}
	}

	return ListDeletedSecretsResponse{}, errors.New("not implemented")
}

type ListSecretsPager interface {
	PageResponse() ListSecretsPage

	Err() error

	NextPage(context.Context) bool
}

type listSecretsPager struct {
	genPager *internal.KeyVaultClientGetSecretVersionsPager
}

func (l *listSecretsPager) PageResponse() ListSecretsPage {
	return listSecretsPageFromGenerated(l.genPager.PageResponse())
}

func (l *listSecretsPager) Err() error {
	return l.genPager.Err()
}

func (l *listSecretsPager) NextPage(ctx context.Context) bool {
	return l.genPager.NextPage(ctx)
}

type ListSecretVersionsOptions struct {
	MaxResults *int32
}

func (l *ListSecretVersionsOptions) toGenerated() *internal.KeyVaultClientGetSecretVersionsOptions {
	if l == nil {
		return &internal.KeyVaultClientGetSecretVersionsOptions{}
	}
	return &internal.KeyVaultClientGetSecretVersionsOptions{
		Maxresults: l.MaxResults,
	}
}

// The secret list result
type ListSecretsPage struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// READ-ONLY; The URL to get the next set of secrets.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A response message containing a list of secrets in the key vault along with a link to the next page of secrets.
	Secrets []*SecretItem `json:"value,omitempty" azure:"ro"`
}

func listSecretsPageFromGenerated(i internal.KeyVaultClientGetSecretVersionsResponse) ListSecretsPage {
	var secrets []*SecretItem
	for _, s := range i.Value {
		secrets = append(secrets, secretItemFromGenerated(s))
	}
	return ListSecretsPage{
		RawResponse: i.RawResponse,
		NextLink:    i.NextLink,
		Secrets:     secrets,
	}
}

func (c *Client) ListSecretVersions(name string, options *ListSecretVersionsOptions) ListSecretsPager {
	if options == nil {
		options = &ListSecretVersionsOptions{}
	}

	return &listSecretsPager{
		genPager: c.kvClient.GetSecretVersions(
			c.vaultUrl,
			name,
			options.toGenerated(),
		),
	}
}

type ListSecretsOptions struct{}

type ListSecretsResponse struct{}

func (c *Client) ListSecrets(ctx context.Context, options *ListSecretsOptions) (ListSecretsResponse, error) {
	if options == nil {
		options = &ListSecretsOptions{}
	}

	return ListSecretsResponse{}, errors.New("not implemented")
}
