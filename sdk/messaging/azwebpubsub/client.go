//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azwebpubsub

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// Client contains the methods for the WebPubSub group.
// Don't use this type directly, use a constructor function instead.
type Client struct {
	internal *azcore.Client
	endpoint string
	key *string
}

// AddConnectionToGroup - Add a connection to the target group.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - group - Target group name, which length should be greater than 0 and less than 1025.
//   - connectionID - Target connection Id
//   - options - ClientAddConnectionToGroupOptions contains the optional parameters for the Client.AddConnectionToGroup method.
func (client *Client) AddConnectionToGroup(ctx context.Context, hub string, group string, connectionID string, options *ClientAddConnectionToGroupOptions) (ClientAddConnectionToGroupResponse, error) {
	var err error
	req, err := client.addConnectionToGroupCreateRequest(ctx, hub, group, connectionID, options)
	if err != nil {
		return ClientAddConnectionToGroupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientAddConnectionToGroupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientAddConnectionToGroupResponse{}, err
	}
	return ClientAddConnectionToGroupResponse{}, nil
}

// addConnectionToGroupCreateRequest creates the AddConnectionToGroup request.
func (client *Client) addConnectionToGroupCreateRequest(ctx context.Context, hub string, group string, connectionID string, options *ClientAddConnectionToGroupOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/groups/{group}/connections/{connectionId}"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if group == "" {
		return nil, errors.New("parameter group cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{group}", url.PathEscape(group))
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// AddConnectionsToGroups - Add filtered connections to multiple groups.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - groupsToAdd - Target groups and connection filter.
//   - options - ClientAddConnectionsToGroupsOptions contains the optional parameters for the Client.AddConnectionsToGroups method.
func (client *Client) AddConnectionsToGroups(ctx context.Context, hub string, groupsToAdd AddToGroupsRequest, options *ClientAddConnectionsToGroupsOptions) (ClientAddConnectionsToGroupsResponse, error) {
	var err error
	req, err := client.addConnectionsToGroupsCreateRequest(ctx, hub, groupsToAdd, options)
	if err != nil {
		return ClientAddConnectionsToGroupsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientAddConnectionsToGroupsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientAddConnectionsToGroupsResponse{}, err
	}
	return ClientAddConnectionsToGroupsResponse{}, nil
}

// addConnectionsToGroupsCreateRequest creates the AddConnectionsToGroups request.
func (client *Client) addConnectionsToGroupsCreateRequest(ctx context.Context, hub string, groupsToAdd AddToGroupsRequest, options *ClientAddConnectionsToGroupsOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/:addToGroups"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, groupsToAdd); err != nil {
	return nil, err
}
	return req, nil
}

// AddUserToGroup - Add a user to the target group.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - group - Target group name, which length should be greater than 0 and less than 1025.
//   - userID - Target user Id.
//   - options - ClientAddUserToGroupOptions contains the optional parameters for the Client.AddUserToGroup method.
func (client *Client) AddUserToGroup(ctx context.Context, hub string, group string, userID string, options *ClientAddUserToGroupOptions) (ClientAddUserToGroupResponse, error) {
	var err error
	req, err := client.addUserToGroupCreateRequest(ctx, hub, group, userID, options)
	if err != nil {
		return ClientAddUserToGroupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientAddUserToGroupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientAddUserToGroupResponse{}, err
	}
	return ClientAddUserToGroupResponse{}, nil
}

// addUserToGroupCreateRequest creates the AddUserToGroup request.
func (client *Client) addUserToGroupCreateRequest(ctx context.Context, hub string, group string, userID string, options *ClientAddUserToGroupOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/users/{userId}/groups/{group}"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if group == "" {
		return nil, errors.New("parameter group cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{group}", url.PathEscape(group))
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// checkPermission - Check if a connection has permission to the specified action.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - permission - The permission: current supported actions are joinLeaveGroup and sendToGroup.
//   - connectionID - Target connection Id.
//   - options - ClientCheckPermissionOptions contains the optional parameters for the Client.checkPermission method.
func (client *Client) checkPermission(ctx context.Context, hub string, permission Permission, connectionID string, options *ClientCheckPermissionOptions) (ClientCheckPermissionResponse, error) {
	var err error
	req, err := client.checkPermissionCreateRequest(ctx, hub, permission, connectionID, options)
	if err != nil {
		return ClientCheckPermissionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCheckPermissionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return ClientCheckPermissionResponse{}, err
	}
	return ClientCheckPermissionResponse{}, nil
}

// checkPermissionCreateRequest creates the checkPermission request.
func (client *Client) checkPermissionCreateRequest(ctx context.Context, hub string, permission Permission, connectionID string, options *ClientCheckPermissionOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if permission == "" {
		return nil, errors.New("parameter permission cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{permission}", url.PathEscape(string(permission)))
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.TargetName != nil {
		reqQP.Set("targetName", *options.TargetName)
	}
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// CloseAllConnections - Close the connections in the hub.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - options - ClientCloseAllConnectionsOptions contains the optional parameters for the Client.CloseAllConnections method.
func (client *Client) CloseAllConnections(ctx context.Context, hub string, options *ClientCloseAllConnectionsOptions) (ClientCloseAllConnectionsResponse, error) {
	var err error
	req, err := client.closeAllConnectionsCreateRequest(ctx, hub, options)
	if err != nil {
		return ClientCloseAllConnectionsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCloseAllConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientCloseAllConnectionsResponse{}, err
	}
	return ClientCloseAllConnectionsResponse{}, nil
}

// closeAllConnectionsCreateRequest creates the CloseAllConnections request.
func (client *Client) closeAllConnectionsCreateRequest(ctx context.Context, hub string, options *ClientCloseAllConnectionsOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/:closeConnections"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Excluded != nil {
			for _, qv := range options.Excluded {
		reqQP.Add("excluded", qv)
	}
	}
	if options != nil && options.Reason != nil {
		reqQP.Set("reason", *options.Reason)
	}
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CloseConnection - Close the client connection.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - connectionID - Target connection Id.
//   - options - ClientCloseConnectionOptions contains the optional parameters for the Client.CloseConnection method.
func (client *Client) CloseConnection(ctx context.Context, hub string, connectionID string, options *ClientCloseConnectionOptions) (ClientCloseConnectionResponse, error) {
	var err error
	req, err := client.closeConnectionCreateRequest(ctx, hub, connectionID, options)
	if err != nil {
		return ClientCloseConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCloseConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientCloseConnectionResponse{}, err
	}
	return ClientCloseConnectionResponse{}, nil
}

// closeConnectionCreateRequest creates the CloseConnection request.
func (client *Client) closeConnectionCreateRequest(ctx context.Context, hub string, connectionID string, options *ClientCloseConnectionOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/connections/{connectionId}"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Reason != nil {
		reqQP.Set("reason", *options.Reason)
	}
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CloseGroupConnections - Close connections in the specific group.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - group - Target group name, which length should be greater than 0 and less than 1025.
//   - options - ClientCloseGroupConnectionsOptions contains the optional parameters for the Client.CloseGroupConnections method.
func (client *Client) CloseGroupConnections(ctx context.Context, hub string, group string, options *ClientCloseGroupConnectionsOptions) (ClientCloseGroupConnectionsResponse, error) {
	var err error
	req, err := client.closeGroupConnectionsCreateRequest(ctx, hub, group, options)
	if err != nil {
		return ClientCloseGroupConnectionsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCloseGroupConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientCloseGroupConnectionsResponse{}, err
	}
	return ClientCloseGroupConnectionsResponse{}, nil
}

// closeGroupConnectionsCreateRequest creates the CloseGroupConnections request.
func (client *Client) closeGroupConnectionsCreateRequest(ctx context.Context, hub string, group string, options *ClientCloseGroupConnectionsOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/groups/{group}/:closeConnections"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if group == "" {
		return nil, errors.New("parameter group cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{group}", url.PathEscape(group))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Excluded != nil {
			for _, qv := range options.Excluded {
		reqQP.Add("excluded", qv)
	}
	}
	if options != nil && options.Reason != nil {
		reqQP.Set("reason", *options.Reason)
	}
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CloseUserConnections - Close connections for the specific user.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - userID - The user Id.
//   - options - ClientCloseUserConnectionsOptions contains the optional parameters for the Client.CloseUserConnections method.
func (client *Client) CloseUserConnections(ctx context.Context, hub string, userID string, options *ClientCloseUserConnectionsOptions) (ClientCloseUserConnectionsResponse, error) {
	var err error
	req, err := client.closeUserConnectionsCreateRequest(ctx, hub, userID, options)
	if err != nil {
		return ClientCloseUserConnectionsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCloseUserConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientCloseUserConnectionsResponse{}, err
	}
	return ClientCloseUserConnectionsResponse{}, nil
}

// closeUserConnectionsCreateRequest creates the CloseUserConnections request.
func (client *Client) closeUserConnectionsCreateRequest(ctx context.Context, hub string, userID string, options *ClientCloseUserConnectionsOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/users/{userId}/:closeConnections"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Excluded != nil {
			for _, qv := range options.Excluded {
		reqQP.Add("excluded", qv)
	}
	}
	if options != nil && options.Reason != nil {
		reqQP.Set("reason", *options.Reason)
	}
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// connectionExists - Check if the connection with the given connectionId exists.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - connectionID - The connection Id.
//   - options - ClientConnectionExistsOptions contains the optional parameters for the Client.connectionExists method.
func (client *Client) connectionExists(ctx context.Context, hub string, connectionID string, options *ClientConnectionExistsOptions) (ClientConnectionExistsResponse, error) {
	var err error
	req, err := client.connectionExistsCreateRequest(ctx, hub, connectionID, options)
	if err != nil {
		return ClientConnectionExistsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientConnectionExistsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return ClientConnectionExistsResponse{}, err
	}
	return ClientConnectionExistsResponse{}, nil
}

// connectionExistsCreateRequest creates the connectionExists request.
func (client *Client) connectionExistsCreateRequest(ctx context.Context, hub string, connectionID string, options *ClientConnectionExistsOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/connections/{connectionId}"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// generateClientToken - Generate token for the client to connect Azure Web PubSub service.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - options - ClientGenerateClientTokenOptions contains the optional parameters for the Client.generateClientToken method.
func (client *Client) generateClientToken(ctx context.Context, hub string, options *ClientGenerateClientTokenOptions) (ClientGenerateClientTokenResponse, error) {
	var err error
	req, err := client.generateClientTokenCreateRequest(ctx, hub, options)
	if err != nil {
		return ClientGenerateClientTokenResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientGenerateClientTokenResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientGenerateClientTokenResponse{}, err
	}
	resp, err := client.generateClientTokenHandleResponse(httpResp)
	return resp, err
}

// generateClientTokenCreateRequest creates the generateClientToken request.
func (client *Client) generateClientTokenCreateRequest(ctx context.Context, hub string, options *ClientGenerateClientTokenOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/:generateToken"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.UserID != nil {
		reqQP.Set("userId", *options.UserID)
	}
	if options != nil && options.Role != nil {
			for _, qv := range options.Role {
		reqQP.Add("role", qv)
	}
	}
	if options != nil && options.MinutesToExpire != nil {
		reqQP.Set("minutesToExpire", strconv.FormatInt(int64(*options.MinutesToExpire), 10))
	}
	reqQP.Set("api-version", "2023-07-01")
	if options != nil && options.Group != nil {
			for _, qv := range options.Group {
		reqQP.Add("group", qv)
	}
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json, text/json"}
	return req, nil
}

// generateClientTokenHandleResponse handles the generateClientToken response.
func (client *Client) generateClientTokenHandleResponse(resp *http.Response) (ClientGenerateClientTokenResponse, error) {
	result := ClientGenerateClientTokenResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ClientTokenResponse); err != nil {
		return ClientGenerateClientTokenResponse{}, err
	}
	return result, nil
}

// GrantPermission - Grant permission to the connection.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - permission - The permission: current supported actions are joinLeaveGroup and sendToGroup.
//   - connectionID - Target connection Id.
//   - options - ClientGrantPermissionOptions contains the optional parameters for the Client.GrantPermission method.
func (client *Client) GrantPermission(ctx context.Context, hub string, permission Permission, connectionID string, options *ClientGrantPermissionOptions) (ClientGrantPermissionResponse, error) {
	var err error
	req, err := client.grantPermissionCreateRequest(ctx, hub, permission, connectionID, options)
	if err != nil {
		return ClientGrantPermissionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientGrantPermissionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientGrantPermissionResponse{}, err
	}
	return ClientGrantPermissionResponse{}, nil
}

// grantPermissionCreateRequest creates the GrantPermission request.
func (client *Client) grantPermissionCreateRequest(ctx context.Context, hub string, permission Permission, connectionID string, options *ClientGrantPermissionOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if permission == "" {
		return nil, errors.New("parameter permission cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{permission}", url.PathEscape(string(permission)))
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.TargetName != nil {
		reqQP.Set("targetName", *options.TargetName)
	}
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// groupExists - Check if there are any client connections inside the given group
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - group - Target group name, which length should be greater than 0 and less than 1025.
//   - options - ClientGroupExistsOptions contains the optional parameters for the Client.groupExists method.
func (client *Client) groupExists(ctx context.Context, hub string, group string, options *ClientGroupExistsOptions) (ClientGroupExistsResponse, error) {
	var err error
	req, err := client.groupExistsCreateRequest(ctx, hub, group, options)
	if err != nil {
		return ClientGroupExistsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientGroupExistsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return ClientGroupExistsResponse{}, err
	}
	return ClientGroupExistsResponse{}, nil
}

// groupExistsCreateRequest creates the groupExists request.
func (client *Client) groupExistsCreateRequest(ctx context.Context, hub string, group string, options *ClientGroupExistsOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/groups/{group}"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if group == "" {
		return nil, errors.New("parameter group cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{group}", url.PathEscape(group))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// RemoveConnectionFromAllGroups - Remove a connection from all groups.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - connectionID - Target connection Id.
//   - options - ClientRemoveConnectionFromAllGroupsOptions contains the optional parameters for the Client.RemoveConnectionFromAllGroups
//     method.
func (client *Client) RemoveConnectionFromAllGroups(ctx context.Context, hub string, connectionID string, options *ClientRemoveConnectionFromAllGroupsOptions) (ClientRemoveConnectionFromAllGroupsResponse, error) {
	var err error
	req, err := client.removeConnectionFromAllGroupsCreateRequest(ctx, hub, connectionID, options)
	if err != nil {
		return ClientRemoveConnectionFromAllGroupsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientRemoveConnectionFromAllGroupsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientRemoveConnectionFromAllGroupsResponse{}, err
	}
	return ClientRemoveConnectionFromAllGroupsResponse{}, nil
}

// removeConnectionFromAllGroupsCreateRequest creates the RemoveConnectionFromAllGroups request.
func (client *Client) removeConnectionFromAllGroupsCreateRequest(ctx context.Context, hub string, connectionID string, options *ClientRemoveConnectionFromAllGroupsOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/connections/{connectionId}/groups"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// RemoveConnectionFromGroup - Remove a connection from the target group.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - group - Target group name, which length should be greater than 0 and less than 1025.
//   - connectionID - Target connection Id.
//   - options - ClientRemoveConnectionFromGroupOptions contains the optional parameters for the Client.RemoveConnectionFromGroup
//     method.
func (client *Client) RemoveConnectionFromGroup(ctx context.Context, hub string, group string, connectionID string, options *ClientRemoveConnectionFromGroupOptions) (ClientRemoveConnectionFromGroupResponse, error) {
	var err error
	req, err := client.removeConnectionFromGroupCreateRequest(ctx, hub, group, connectionID, options)
	if err != nil {
		return ClientRemoveConnectionFromGroupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientRemoveConnectionFromGroupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientRemoveConnectionFromGroupResponse{}, err
	}
	return ClientRemoveConnectionFromGroupResponse{}, nil
}

// removeConnectionFromGroupCreateRequest creates the RemoveConnectionFromGroup request.
func (client *Client) removeConnectionFromGroupCreateRequest(ctx context.Context, hub string, group string, connectionID string, options *ClientRemoveConnectionFromGroupOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/groups/{group}/connections/{connectionId}"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if group == "" {
		return nil, errors.New("parameter group cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{group}", url.PathEscape(group))
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// RemoveConnectionsFromGroups - Remove filtered connections from multiple groups.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - groupsToRemove - Target groups and connection filter.
//   - options - ClientRemoveConnectionsFromGroupsOptions contains the optional parameters for the Client.RemoveConnectionsFromGroups
//     method.
func (client *Client) RemoveConnectionsFromGroups(ctx context.Context, hub string, groupsToRemove RemoveFromGroupsRequest, options *ClientRemoveConnectionsFromGroupsOptions) (ClientRemoveConnectionsFromGroupsResponse, error) {
	var err error
	req, err := client.removeConnectionsFromGroupsCreateRequest(ctx, hub, groupsToRemove, options)
	if err != nil {
		return ClientRemoveConnectionsFromGroupsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientRemoveConnectionsFromGroupsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientRemoveConnectionsFromGroupsResponse{}, err
	}
	return ClientRemoveConnectionsFromGroupsResponse{}, nil
}

// removeConnectionsFromGroupsCreateRequest creates the RemoveConnectionsFromGroups request.
func (client *Client) removeConnectionsFromGroupsCreateRequest(ctx context.Context, hub string, groupsToRemove RemoveFromGroupsRequest, options *ClientRemoveConnectionsFromGroupsOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/:removeFromGroups"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, groupsToRemove); err != nil {
	return nil, err
}
	return req, nil
}

// RemoveUserFromAllGroups - Remove a user from all groups.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - userID - Target user Id.
//   - options - ClientRemoveUserFromAllGroupsOptions contains the optional parameters for the Client.RemoveUserFromAllGroups
//     method.
func (client *Client) RemoveUserFromAllGroups(ctx context.Context, hub string, userID string, options *ClientRemoveUserFromAllGroupsOptions) (ClientRemoveUserFromAllGroupsResponse, error) {
	var err error
	req, err := client.removeUserFromAllGroupsCreateRequest(ctx, hub, userID, options)
	if err != nil {
		return ClientRemoveUserFromAllGroupsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientRemoveUserFromAllGroupsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientRemoveUserFromAllGroupsResponse{}, err
	}
	return ClientRemoveUserFromAllGroupsResponse{}, nil
}

// removeUserFromAllGroupsCreateRequest creates the RemoveUserFromAllGroups request.
func (client *Client) removeUserFromAllGroupsCreateRequest(ctx context.Context, hub string, userID string, options *ClientRemoveUserFromAllGroupsOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/users/{userId}/groups"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// RemoveUserFromGroup - Remove a user from the target group.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - group - Target group name, which length should be greater than 0 and less than 1025.
//   - userID - Target user Id.
//   - options - ClientRemoveUserFromGroupOptions contains the optional parameters for the Client.RemoveUserFromGroup method.
func (client *Client) RemoveUserFromGroup(ctx context.Context, hub string, group string, userID string, options *ClientRemoveUserFromGroupOptions) (ClientRemoveUserFromGroupResponse, error) {
	var err error
	req, err := client.removeUserFromGroupCreateRequest(ctx, hub, group, userID, options)
	if err != nil {
		return ClientRemoveUserFromGroupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientRemoveUserFromGroupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientRemoveUserFromGroupResponse{}, err
	}
	return ClientRemoveUserFromGroupResponse{}, nil
}

// removeUserFromGroupCreateRequest creates the RemoveUserFromGroup request.
func (client *Client) removeUserFromGroupCreateRequest(ctx context.Context, hub string, group string, userID string, options *ClientRemoveUserFromGroupOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/users/{userId}/groups/{group}"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if group == "" {
		return nil, errors.New("parameter group cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{group}", url.PathEscape(group))
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// RevokePermission - Revoke permission for the connection.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - permission - The permission: current supported actions are joinLeaveGroup and sendToGroup.
//   - connectionID - Target connection Id.
//   - options - ClientRevokePermissionOptions contains the optional parameters for the Client.RevokePermission method.
func (client *Client) RevokePermission(ctx context.Context, hub string, permission Permission, connectionID string, options *ClientRevokePermissionOptions) (ClientRevokePermissionResponse, error) {
	var err error
	req, err := client.revokePermissionCreateRequest(ctx, hub, permission, connectionID, options)
	if err != nil {
		return ClientRevokePermissionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientRevokePermissionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientRevokePermissionResponse{}, err
	}
	return ClientRevokePermissionResponse{}, nil
}

// revokePermissionCreateRequest creates the RevokePermission request.
func (client *Client) revokePermissionCreateRequest(ctx context.Context, hub string, permission Permission, connectionID string, options *ClientRevokePermissionOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if permission == "" {
		return nil, errors.New("parameter permission cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{permission}", url.PathEscape(string(permission)))
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.TargetName != nil {
		reqQP.Set("targetName", *options.TargetName)
	}
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// SendToAll - Broadcast content inside request body to all the connected client connections.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - contentType - Upload file type
//   - message - The payload body.
//   - options - ClientSendToAllOptions contains the optional parameters for the Client.SendToAll method.
func (client *Client) SendToAll(ctx context.Context, hub string, contentType ContentType, message io.ReadSeekCloser, options *ClientSendToAllOptions) (ClientSendToAllResponse, error) {
	var err error
	req, err := client.sendToAllCreateRequest(ctx, hub, contentType, message, options)
	if err != nil {
		return ClientSendToAllResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientSendToAllResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return ClientSendToAllResponse{}, err
	}
	return ClientSendToAllResponse{}, nil
}

// sendToAllCreateRequest creates the SendToAll request.
func (client *Client) sendToAllCreateRequest(ctx context.Context, hub string, contentType ContentType, message io.ReadSeekCloser, options *ClientSendToAllOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/:send"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Excluded != nil {
			for _, qv := range options.Excluded {
		reqQP.Add("excluded", qv)
	}
	}
	reqQP.Set("api-version", "2023-07-01")
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", *options.Filter)
	}
	if options != nil && options.MessageTTLSeconds != nil {
		reqQP.Set("messageTtlSeconds", strconv.FormatInt(int64(*options.MessageTTLSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Content-Type"] = []string{string(contentType)}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := req.SetBody(message, string(contentType)); err != nil {
	return nil, err
}
	return req, nil
}

// SendToConnection - Send content inside request body to the specific connection.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - connectionID - The connection Id.
//   - contentType - Upload file type
//   - message - The payload body.
//   - options - ClientSendToConnectionOptions contains the optional parameters for the Client.SendToConnection method.
func (client *Client) SendToConnection(ctx context.Context, hub string, connectionID string, contentType ContentType, message io.ReadSeekCloser, options *ClientSendToConnectionOptions) (ClientSendToConnectionResponse, error) {
	var err error
	req, err := client.sendToConnectionCreateRequest(ctx, hub, connectionID, contentType, message, options)
	if err != nil {
		return ClientSendToConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientSendToConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return ClientSendToConnectionResponse{}, err
	}
	return ClientSendToConnectionResponse{}, nil
}

// sendToConnectionCreateRequest creates the SendToConnection request.
func (client *Client) sendToConnectionCreateRequest(ctx context.Context, hub string, connectionID string, contentType ContentType, message io.ReadSeekCloser, options *ClientSendToConnectionOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/connections/{connectionId}/:send"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	if options != nil && options.MessageTTLSeconds != nil {
		reqQP.Set("messageTtlSeconds", strconv.FormatInt(int64(*options.MessageTTLSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Content-Type"] = []string{string(contentType)}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := req.SetBody(message, string(contentType)); err != nil {
	return nil, err
}
	return req, nil
}

// SendToGroup - Send content inside request body to a group of connections.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - group - Target group name, which length should be greater than 0 and less than 1025.
//   - contentType - Upload file type
//   - message - The payload body.
//   - options - ClientSendToGroupOptions contains the optional parameters for the Client.SendToGroup method.
func (client *Client) SendToGroup(ctx context.Context, hub string, group string, contentType ContentType, message io.ReadSeekCloser, options *ClientSendToGroupOptions) (ClientSendToGroupResponse, error) {
	var err error
	req, err := client.sendToGroupCreateRequest(ctx, hub, group, contentType, message, options)
	if err != nil {
		return ClientSendToGroupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientSendToGroupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return ClientSendToGroupResponse{}, err
	}
	return ClientSendToGroupResponse{}, nil
}

// sendToGroupCreateRequest creates the SendToGroup request.
func (client *Client) sendToGroupCreateRequest(ctx context.Context, hub string, group string, contentType ContentType, message io.ReadSeekCloser, options *ClientSendToGroupOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/groups/{group}/:send"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if group == "" {
		return nil, errors.New("parameter group cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{group}", url.PathEscape(group))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Excluded != nil {
			for _, qv := range options.Excluded {
		reqQP.Add("excluded", qv)
	}
	}
	reqQP.Set("api-version", "2023-07-01")
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", *options.Filter)
	}
	if options != nil && options.MessageTTLSeconds != nil {
		reqQP.Set("messageTtlSeconds", strconv.FormatInt(int64(*options.MessageTTLSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Content-Type"] = []string{string(contentType)}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := req.SetBody(message, string(contentType)); err != nil {
	return nil, err
}
	return req, nil
}

// SendToUser - Send content inside request body to the specific user.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - userID - The user Id.
//   - contentType - Upload file type
//   - message - The payload body.
//   - options - ClientSendToUserOptions contains the optional parameters for the Client.SendToUser method.
func (client *Client) SendToUser(ctx context.Context, hub string, userID string, contentType ContentType, message io.ReadSeekCloser, options *ClientSendToUserOptions) (ClientSendToUserResponse, error) {
	var err error
	req, err := client.sendToUserCreateRequest(ctx, hub, userID, contentType, message, options)
	if err != nil {
		return ClientSendToUserResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientSendToUserResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return ClientSendToUserResponse{}, err
	}
	return ClientSendToUserResponse{}, nil
}

// sendToUserCreateRequest creates the SendToUser request.
func (client *Client) sendToUserCreateRequest(ctx context.Context, hub string, userID string, contentType ContentType, message io.ReadSeekCloser, options *ClientSendToUserOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/users/{userId}/:send"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", *options.Filter)
	}
	if options != nil && options.MessageTTLSeconds != nil {
		reqQP.Set("messageTtlSeconds", strconv.FormatInt(int64(*options.MessageTTLSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Content-Type"] = []string{string(contentType)}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := req.SetBody(message, string(contentType)); err != nil {
	return nil, err
}
	return req, nil
}

// userExists - Check if there are any client connections connected for the given user.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-07-01
//   - hub - Target hub name, which should start with alphabetic characters and only contain alpha-numeric characters or underscore.
//   - userID - Target user Id.
//   - options - ClientUserExistsOptions contains the optional parameters for the Client.userExists method.
func (client *Client) userExists(ctx context.Context, hub string, userID string, options *ClientUserExistsOptions) (ClientUserExistsResponse, error) {
	var err error
	req, err := client.userExistsCreateRequest(ctx, hub, userID, options)
	if err != nil {
		return ClientUserExistsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientUserExistsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return ClientUserExistsResponse{}, err
	}
	return ClientUserExistsResponse{}, nil
}

// userExistsCreateRequest creates the userExists request.
func (client *Client) userExistsCreateRequest(ctx context.Context, hub string, userID string, options *ClientUserExistsOptions) (*policy.Request, error) {
	urlPath := "/api/hubs/{hub}/users/{userId}"
	if hub == "" {
		return nil, errors.New("parameter hub cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hub}", url.PathEscape(hub))
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

