// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armoperationalinsights

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// ClustersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ClustersCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ClustersCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ClustersCreateOrUpdateResponse, error)
}

type clustersCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *clustersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *clustersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *clustersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ClustersCreateOrUpdateResponse, error) {
	respType := ClustersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Cluster)
	if err != nil {
		return ClustersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *clustersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *clustersCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ClustersCreateOrUpdateResponse, error) {
	respType := ClustersCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Cluster)
	if err != nil {
		return ClustersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ClustersDeletePoller provides polling facilities until the operation reaches a terminal state.
type ClustersDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ClustersDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ClustersDeleteResponse, error)
}

type clustersDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *clustersDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *clustersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *clustersDeletePoller) FinalResponse(ctx context.Context) (ClustersDeleteResponse, error) {
	respType := ClustersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ClustersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *clustersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *clustersDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ClustersDeleteResponse, error) {
	respType := ClustersDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ClustersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LinkedServicesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LinkedServicesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LinkedServicesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (LinkedServicesCreateOrUpdateResponse, error)
}

type linkedServicesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *linkedServicesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *linkedServicesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *linkedServicesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (LinkedServicesCreateOrUpdateResponse, error) {
	respType := LinkedServicesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LinkedService)
	if err != nil {
		return LinkedServicesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *linkedServicesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *linkedServicesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (LinkedServicesCreateOrUpdateResponse, error) {
	respType := LinkedServicesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.LinkedService)
	if err != nil {
		return LinkedServicesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LinkedServicesDeletePoller provides polling facilities until the operation reaches a terminal state.
type LinkedServicesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LinkedServicesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (LinkedServicesDeleteResponse, error)
}

type linkedServicesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *linkedServicesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *linkedServicesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *linkedServicesDeletePoller) FinalResponse(ctx context.Context) (LinkedServicesDeleteResponse, error) {
	respType := LinkedServicesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LinkedService)
	if err != nil {
		return LinkedServicesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *linkedServicesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *linkedServicesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (LinkedServicesDeleteResponse, error) {
	respType := LinkedServicesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.LinkedService)
	if err != nil {
		return LinkedServicesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// WorkspacesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspacesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final WorkspacesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (WorkspacesCreateOrUpdateResponse, error)
}

type workspacesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *workspacesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *workspacesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *workspacesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspacesCreateOrUpdateResponse, error) {
	respType := WorkspacesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Workspace)
	if err != nil {
		return WorkspacesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *workspacesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *workspacesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (WorkspacesCreateOrUpdateResponse, error) {
	respType := WorkspacesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Workspace)
	if err != nil {
		return WorkspacesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// WorkspacesDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkspacesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final WorkspacesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (WorkspacesDeleteResponse, error)
}

type workspacesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *workspacesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *workspacesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *workspacesDeletePoller) FinalResponse(ctx context.Context) (WorkspacesDeleteResponse, error) {
	respType := WorkspacesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkspacesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *workspacesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *workspacesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (WorkspacesDeleteResponse, error) {
	respType := WorkspacesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return WorkspacesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}
