//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package armweb

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/cloud"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/profiles/hybrid20200901/internal"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// AppsClient contains the methods for the WebApps group.
// Don't use this type directly, use NewAppsClient() instead.
type AppsClient struct {
	host           string
	subscriptionID string
	pl             runtime.Pipeline
}

// NewAppsClient creates a new instance of AppsClient with the specified values.
// subscriptionID - Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
// credential - used to authorize requests. Usually a credential from azidentity.
// options - pass nil to accept the default values.
func NewAppsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*AppsClient, error) {
	if options == nil {
		options = &arm.ClientOptions{}
	}
	ep := cloud.AzurePublic.Services[cloud.ResourceManager].Endpoint
	if c, ok := options.Cloud.Services[cloud.ResourceManager]; ok {
		ep = c.Endpoint
	}
	pl, err := armruntime.NewPipeline(hybrid20200901.ModuleName, hybrid20200901.ModuleVersion, credential, runtime.PipelineOptions{}, options)
	if err != nil {
		return nil, err
	}
	client := &AppsClient{
		subscriptionID: subscriptionID,
		host:           ep,
		pl:             pl,
	}
	return client, nil
}

// AddPremierAddOn - Updates a named add-on of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// premierAddOnName - Add-on name.
// premierAddOn - A JSON representation of the edited premier add-on.
// options - AppsClientAddPremierAddOnOptions contains the optional parameters for the AppsClient.AddPremierAddOn method.
func (client *AppsClient) AddPremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOn, options *AppsClientAddPremierAddOnOptions) (AppsClientAddPremierAddOnResponse, error) {
	req, err := client.addPremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, premierAddOn, options)
	if err != nil {
		return AppsClientAddPremierAddOnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientAddPremierAddOnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientAddPremierAddOnResponse{}, runtime.NewResponseError(resp)
	}
	return client.addPremierAddOnHandleResponse(resp)
}

// addPremierAddOnCreateRequest creates the AddPremierAddOn request.
func (client *AppsClient) addPremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOn, options *AppsClientAddPremierAddOnOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, premierAddOn)
}

// addPremierAddOnHandleResponse handles the AddPremierAddOn response.
func (client *AppsClient) addPremierAddOnHandleResponse(resp *http.Response) (AppsClientAddPremierAddOnResponse, error) {
	result := AppsClientAddPremierAddOnResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return AppsClientAddPremierAddOnResponse{}, err
	}
	return result, nil
}

// AddPremierAddOnSlot - Updates a named add-on of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// premierAddOnName - Add-on name.
// slot - Name of the deployment slot. If a slot is not specified, the API will update the named add-on for the production
// slot.
// premierAddOn - A JSON representation of the edited premier add-on.
// options - AppsClientAddPremierAddOnSlotOptions contains the optional parameters for the AppsClient.AddPremierAddOnSlot
// method.
func (client *AppsClient) AddPremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOn, options *AppsClientAddPremierAddOnSlotOptions) (AppsClientAddPremierAddOnSlotResponse, error) {
	req, err := client.addPremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, premierAddOn, options)
	if err != nil {
		return AppsClientAddPremierAddOnSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientAddPremierAddOnSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientAddPremierAddOnSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.addPremierAddOnSlotHandleResponse(resp)
}

// addPremierAddOnSlotCreateRequest creates the AddPremierAddOnSlot request.
func (client *AppsClient) addPremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOn, options *AppsClientAddPremierAddOnSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, premierAddOn)
}

// addPremierAddOnSlotHandleResponse handles the AddPremierAddOnSlot response.
func (client *AppsClient) addPremierAddOnSlotHandleResponse(resp *http.Response) (AppsClientAddPremierAddOnSlotResponse, error) {
	result := AppsClientAddPremierAddOnSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return AppsClientAddPremierAddOnSlotResponse{}, err
	}
	return result, nil
}

// AnalyzeCustomHostname - Analyze a custom hostname.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// options - AppsClientAnalyzeCustomHostnameOptions contains the optional parameters for the AppsClient.AnalyzeCustomHostname
// method.
func (client *AppsClient) AnalyzeCustomHostname(ctx context.Context, resourceGroupName string, name string, options *AppsClientAnalyzeCustomHostnameOptions) (AppsClientAnalyzeCustomHostnameResponse, error) {
	req, err := client.analyzeCustomHostnameCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientAnalyzeCustomHostnameResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientAnalyzeCustomHostnameResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientAnalyzeCustomHostnameResponse{}, runtime.NewResponseError(resp)
	}
	return client.analyzeCustomHostnameHandleResponse(resp)
}

// analyzeCustomHostnameCreateRequest creates the AnalyzeCustomHostname request.
func (client *AppsClient) analyzeCustomHostnameCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientAnalyzeCustomHostnameOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/analyzeCustomHostname"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.HostName != nil {
		reqQP.Set("hostName", *options.HostName)
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// analyzeCustomHostnameHandleResponse handles the AnalyzeCustomHostname response.
func (client *AppsClient) analyzeCustomHostnameHandleResponse(resp *http.Response) (AppsClientAnalyzeCustomHostnameResponse, error) {
	result := AppsClientAnalyzeCustomHostnameResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CustomHostnameAnalysisResult); err != nil {
		return AppsClientAnalyzeCustomHostnameResponse{}, err
	}
	return result, nil
}

// AnalyzeCustomHostnameSlot - Analyze a custom hostname.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// options - AppsClientAnalyzeCustomHostnameSlotOptions contains the optional parameters for the AppsClient.AnalyzeCustomHostnameSlot
// method.
func (client *AppsClient) AnalyzeCustomHostnameSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientAnalyzeCustomHostnameSlotOptions) (AppsClientAnalyzeCustomHostnameSlotResponse, error) {
	req, err := client.analyzeCustomHostnameSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientAnalyzeCustomHostnameSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientAnalyzeCustomHostnameSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientAnalyzeCustomHostnameSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.analyzeCustomHostnameSlotHandleResponse(resp)
}

// analyzeCustomHostnameSlotCreateRequest creates the AnalyzeCustomHostnameSlot request.
func (client *AppsClient) analyzeCustomHostnameSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientAnalyzeCustomHostnameSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/analyzeCustomHostname"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.HostName != nil {
		reqQP.Set("hostName", *options.HostName)
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// analyzeCustomHostnameSlotHandleResponse handles the AnalyzeCustomHostnameSlot response.
func (client *AppsClient) analyzeCustomHostnameSlotHandleResponse(resp *http.Response) (AppsClientAnalyzeCustomHostnameSlotResponse, error) {
	result := AppsClientAnalyzeCustomHostnameSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CustomHostnameAnalysisResult); err != nil {
		return AppsClientAnalyzeCustomHostnameSlotResponse{}, err
	}
	return result, nil
}

// ApplySlotConfigToProduction - Applies the configuration settings from the target slot onto the current slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slotSwapEntity - JSON object that contains the target slot name. See example.
// options - AppsClientApplySlotConfigToProductionOptions contains the optional parameters for the AppsClient.ApplySlotConfigToProduction
// method.
func (client *AppsClient) ApplySlotConfigToProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *AppsClientApplySlotConfigToProductionOptions) (AppsClientApplySlotConfigToProductionResponse, error) {
	req, err := client.applySlotConfigToProductionCreateRequest(ctx, resourceGroupName, name, slotSwapEntity, options)
	if err != nil {
		return AppsClientApplySlotConfigToProductionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientApplySlotConfigToProductionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientApplySlotConfigToProductionResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientApplySlotConfigToProductionResponse{}, nil
}

// applySlotConfigToProductionCreateRequest creates the ApplySlotConfigToProduction request.
func (client *AppsClient) applySlotConfigToProductionCreateRequest(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *AppsClientApplySlotConfigToProductionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, slotSwapEntity)
}

// ApplySlotConfigurationSlot - Applies the configuration settings from the target slot onto the current slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
// slotSwapEntity - JSON object that contains the target slot name. See example.
// options - AppsClientApplySlotConfigurationSlotOptions contains the optional parameters for the AppsClient.ApplySlotConfigurationSlot
// method.
func (client *AppsClient) ApplySlotConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *AppsClientApplySlotConfigurationSlotOptions) (AppsClientApplySlotConfigurationSlotResponse, error) {
	req, err := client.applySlotConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
	if err != nil {
		return AppsClientApplySlotConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientApplySlotConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientApplySlotConfigurationSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientApplySlotConfigurationSlotResponse{}, nil
}

// applySlotConfigurationSlotCreateRequest creates the ApplySlotConfigurationSlot request.
func (client *AppsClient) applySlotConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *AppsClientApplySlotConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, slotSwapEntity)
}

// Backup - Creates a backup of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// request - Backup configuration. You can use the JSON response from the POST action as input here.
// options - AppsClientBackupOptions contains the optional parameters for the AppsClient.Backup method.
func (client *AppsClient) Backup(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *AppsClientBackupOptions) (AppsClientBackupResponse, error) {
	req, err := client.backupCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return AppsClientBackupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientBackupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientBackupResponse{}, runtime.NewResponseError(resp)
	}
	return client.backupHandleResponse(resp)
}

// backupCreateRequest creates the Backup request.
func (client *AppsClient) backupCreateRequest(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *AppsClientBackupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, request)
}

// backupHandleResponse handles the Backup response.
func (client *AppsClient) backupHandleResponse(resp *http.Response) (AppsClientBackupResponse, error) {
	result := AppsClientBackupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return AppsClientBackupResponse{}, err
	}
	return result, nil
}

// BackupSlot - Creates a backup of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will create a backup for the production slot.
// request - Backup configuration. You can use the JSON response from the POST action as input here.
// options - AppsClientBackupSlotOptions contains the optional parameters for the AppsClient.BackupSlot method.
func (client *AppsClient) BackupSlot(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *AppsClientBackupSlotOptions) (AppsClientBackupSlotResponse, error) {
	req, err := client.backupSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return AppsClientBackupSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientBackupSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientBackupSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.backupSlotHandleResponse(resp)
}

// backupSlotCreateRequest creates the BackupSlot request.
func (client *AppsClient) backupSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *AppsClientBackupSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, request)
}

// backupSlotHandleResponse handles the BackupSlot response.
func (client *AppsClient) backupSlotHandleResponse(resp *http.Response) (AppsClientBackupSlotResponse, error) {
	result := AppsClientBackupSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return AppsClientBackupSlotResponse{}, err
	}
	return result, nil
}

// CreateDeployment - Create a deployment for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// id - ID of an existing deployment.
// deployment - Deployment details.
// options - AppsClientCreateDeploymentOptions contains the optional parameters for the AppsClient.CreateDeployment method.
func (client *AppsClient) CreateDeployment(ctx context.Context, resourceGroupName string, name string, id string, deployment Deployment, options *AppsClientCreateDeploymentOptions) (AppsClientCreateDeploymentResponse, error) {
	req, err := client.createDeploymentCreateRequest(ctx, resourceGroupName, name, id, deployment, options)
	if err != nil {
		return AppsClientCreateDeploymentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateDeploymentResponse{}, runtime.NewResponseError(resp)
	}
	return client.createDeploymentHandleResponse(resp)
}

// createDeploymentCreateRequest creates the CreateDeployment request.
func (client *AppsClient) createDeploymentCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, deployment Deployment, options *AppsClientCreateDeploymentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, deployment)
}

// createDeploymentHandleResponse handles the CreateDeployment response.
func (client *AppsClient) createDeploymentHandleResponse(resp *http.Response) (AppsClientCreateDeploymentResponse, error) {
	result := AppsClientCreateDeploymentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return AppsClientCreateDeploymentResponse{}, err
	}
	return result, nil
}

// CreateDeploymentSlot - Create a deployment for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// id - ID of an existing deployment.
// slot - Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
// deployment - Deployment details.
// options - AppsClientCreateDeploymentSlotOptions contains the optional parameters for the AppsClient.CreateDeploymentSlot
// method.
func (client *AppsClient) CreateDeploymentSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, deployment Deployment, options *AppsClientCreateDeploymentSlotOptions) (AppsClientCreateDeploymentSlotResponse, error) {
	req, err := client.createDeploymentSlotCreateRequest(ctx, resourceGroupName, name, id, slot, deployment, options)
	if err != nil {
		return AppsClientCreateDeploymentSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateDeploymentSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateDeploymentSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createDeploymentSlotHandleResponse(resp)
}

// createDeploymentSlotCreateRequest creates the CreateDeploymentSlot request.
func (client *AppsClient) createDeploymentSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, deployment Deployment, options *AppsClientCreateDeploymentSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, deployment)
}

// createDeploymentSlotHandleResponse handles the CreateDeploymentSlot response.
func (client *AppsClient) createDeploymentSlotHandleResponse(resp *http.Response) (AppsClientCreateDeploymentSlotResponse, error) {
	result := AppsClientCreateDeploymentSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return AppsClientCreateDeploymentSlotResponse{}, err
	}
	return result, nil
}

// BeginCreateFunction - Create function for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - Function name.
// functionEnvelope - Function details.
// options - AppsClientBeginCreateFunctionOptions contains the optional parameters for the AppsClient.BeginCreateFunction
// method.
func (client *AppsClient) BeginCreateFunction(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope, options *AppsClientBeginCreateFunctionOptions) (*runtime.Poller[AppsClientCreateFunctionResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createFunction(ctx, resourceGroupName, name, functionName, functionEnvelope, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientCreateFunctionResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientCreateFunctionResponse](options.ResumeToken, client.pl, nil)
	}
}

// CreateFunction - Create function for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) createFunction(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope, options *AppsClientBeginCreateFunctionOptions) (*http.Response, error) {
	req, err := client.createFunctionCreateRequest(ctx, resourceGroupName, name, functionName, functionEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createFunctionCreateRequest creates the CreateFunction request.
func (client *AppsClient) createFunctionCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope, options *AppsClientBeginCreateFunctionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, functionEnvelope)
}

// BeginCreateInstanceFunctionSlot - Create function for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - Function name.
// slot - Name of the deployment slot.
// functionEnvelope - Function details.
// options - AppsClientBeginCreateInstanceFunctionSlotOptions contains the optional parameters for the AppsClient.BeginCreateInstanceFunctionSlot
// method.
func (client *AppsClient) BeginCreateInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope, options *AppsClientBeginCreateInstanceFunctionSlotOptions) (*runtime.Poller[AppsClientCreateInstanceFunctionSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createInstanceFunctionSlot(ctx, resourceGroupName, name, functionName, slot, functionEnvelope, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientCreateInstanceFunctionSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientCreateInstanceFunctionSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// CreateInstanceFunctionSlot - Create function for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) createInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope, options *AppsClientBeginCreateInstanceFunctionSlotOptions) (*http.Response, error) {
	req, err := client.createInstanceFunctionSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, functionEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createInstanceFunctionSlotCreateRequest creates the CreateInstanceFunctionSlot request.
func (client *AppsClient) createInstanceFunctionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope, options *AppsClientBeginCreateInstanceFunctionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, functionEnvelope)
}

// BeginCreateInstanceMSDeployOperation - Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// instanceID - ID of web app instance.
// msDeploy - Details of MSDeploy operation
// options - AppsClientBeginCreateInstanceMSDeployOperationOptions contains the optional parameters for the AppsClient.BeginCreateInstanceMSDeployOperation
// method.
func (client *AppsClient) BeginCreateInstanceMSDeployOperation(ctx context.Context, resourceGroupName string, name string, instanceID string, msDeploy MSDeploy, options *AppsClientBeginCreateInstanceMSDeployOperationOptions) (*runtime.Poller[AppsClientCreateInstanceMSDeployOperationResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createInstanceMSDeployOperation(ctx, resourceGroupName, name, instanceID, msDeploy, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientCreateInstanceMSDeployOperationResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientCreateInstanceMSDeployOperationResponse](options.ResumeToken, client.pl, nil)
	}
}

// CreateInstanceMSDeployOperation - Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) createInstanceMSDeployOperation(ctx context.Context, resourceGroupName string, name string, instanceID string, msDeploy MSDeploy, options *AppsClientBeginCreateInstanceMSDeployOperationOptions) (*http.Response, error) {
	req, err := client.createInstanceMSDeployOperationCreateRequest(ctx, resourceGroupName, name, instanceID, msDeploy, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusConflict) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createInstanceMSDeployOperationCreateRequest creates the CreateInstanceMSDeployOperation request.
func (client *AppsClient) createInstanceMSDeployOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, msDeploy MSDeploy, options *AppsClientBeginCreateInstanceMSDeployOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, msDeploy)
}

// BeginCreateInstanceMSDeployOperationSlot - Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// instanceID - ID of web app instance.
// msDeploy - Details of MSDeploy operation
// options - AppsClientBeginCreateInstanceMSDeployOperationSlotOptions contains the optional parameters for the AppsClient.BeginCreateInstanceMSDeployOperationSlot
// method.
func (client *AppsClient) BeginCreateInstanceMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, msDeploy MSDeploy, options *AppsClientBeginCreateInstanceMSDeployOperationSlotOptions) (*runtime.Poller[AppsClientCreateInstanceMSDeployOperationSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createInstanceMSDeployOperationSlot(ctx, resourceGroupName, name, slot, instanceID, msDeploy, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientCreateInstanceMSDeployOperationSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientCreateInstanceMSDeployOperationSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// CreateInstanceMSDeployOperationSlot - Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) createInstanceMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, msDeploy MSDeploy, options *AppsClientBeginCreateInstanceMSDeployOperationSlotOptions) (*http.Response, error) {
	req, err := client.createInstanceMSDeployOperationSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, msDeploy, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusConflict) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createInstanceMSDeployOperationSlotCreateRequest creates the CreateInstanceMSDeployOperationSlot request.
func (client *AppsClient) createInstanceMSDeployOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, msDeploy MSDeploy, options *AppsClientBeginCreateInstanceMSDeployOperationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, msDeploy)
}

// BeginCreateMSDeployOperation - Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// msDeploy - Details of MSDeploy operation
// options - AppsClientBeginCreateMSDeployOperationOptions contains the optional parameters for the AppsClient.BeginCreateMSDeployOperation
// method.
func (client *AppsClient) BeginCreateMSDeployOperation(ctx context.Context, resourceGroupName string, name string, msDeploy MSDeploy, options *AppsClientBeginCreateMSDeployOperationOptions) (*runtime.Poller[AppsClientCreateMSDeployOperationResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createMSDeployOperation(ctx, resourceGroupName, name, msDeploy, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientCreateMSDeployOperationResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientCreateMSDeployOperationResponse](options.ResumeToken, client.pl, nil)
	}
}

// CreateMSDeployOperation - Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) createMSDeployOperation(ctx context.Context, resourceGroupName string, name string, msDeploy MSDeploy, options *AppsClientBeginCreateMSDeployOperationOptions) (*http.Response, error) {
	req, err := client.createMSDeployOperationCreateRequest(ctx, resourceGroupName, name, msDeploy, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusConflict) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createMSDeployOperationCreateRequest creates the CreateMSDeployOperation request.
func (client *AppsClient) createMSDeployOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, msDeploy MSDeploy, options *AppsClientBeginCreateMSDeployOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, msDeploy)
}

// BeginCreateMSDeployOperationSlot - Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// msDeploy - Details of MSDeploy operation
// options - AppsClientBeginCreateMSDeployOperationSlotOptions contains the optional parameters for the AppsClient.BeginCreateMSDeployOperationSlot
// method.
func (client *AppsClient) BeginCreateMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, msDeploy MSDeploy, options *AppsClientBeginCreateMSDeployOperationSlotOptions) (*runtime.Poller[AppsClientCreateMSDeployOperationSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createMSDeployOperationSlot(ctx, resourceGroupName, name, slot, msDeploy, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientCreateMSDeployOperationSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientCreateMSDeployOperationSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// CreateMSDeployOperationSlot - Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) createMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, msDeploy MSDeploy, options *AppsClientBeginCreateMSDeployOperationSlotOptions) (*http.Response, error) {
	req, err := client.createMSDeployOperationSlotCreateRequest(ctx, resourceGroupName, name, slot, msDeploy, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusConflict) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createMSDeployOperationSlotCreateRequest creates the CreateMSDeployOperationSlot request.
func (client *AppsClient) createMSDeployOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, msDeploy MSDeploy, options *AppsClientBeginCreateMSDeployOperationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, msDeploy)
}

// BeginCreateOrUpdate - Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
// siteEnvelope - A JSON representation of the app properties. See example.
// options - AppsClientBeginCreateOrUpdateOptions contains the optional parameters for the AppsClient.BeginCreateOrUpdate
// method.
func (client *AppsClient) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, options *AppsClientBeginCreateOrUpdateOptions) (*runtime.Poller[AppsClientCreateOrUpdateResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdate(ctx, resourceGroupName, name, siteEnvelope, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientCreateOrUpdateResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientCreateOrUpdateResponse](options.ResumeToken, client.pl, nil)
	}
}

// CreateOrUpdate - Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) createOrUpdate(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, options *AppsClientBeginCreateOrUpdateOptions) (*http.Response, error) {
	req, err := client.createOrUpdateCreateRequest(ctx, resourceGroupName, name, siteEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *AppsClient) createOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, options *AppsClientBeginCreateOrUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteEnvelope)
}

// CreateOrUpdateConfiguration - Updates the configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// siteConfig - JSON representation of a SiteConfig object. See example.
// options - AppsClientCreateOrUpdateConfigurationOptions contains the optional parameters for the AppsClient.CreateOrUpdateConfiguration
// method.
func (client *AppsClient) CreateOrUpdateConfiguration(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *AppsClientCreateOrUpdateConfigurationOptions) (AppsClientCreateOrUpdateConfigurationResponse, error) {
	req, err := client.createOrUpdateConfigurationCreateRequest(ctx, resourceGroupName, name, siteConfig, options)
	if err != nil {
		return AppsClientCreateOrUpdateConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateConfigurationResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateConfigurationHandleResponse(resp)
}

// createOrUpdateConfigurationCreateRequest creates the CreateOrUpdateConfiguration request.
func (client *AppsClient) createOrUpdateConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *AppsClientCreateOrUpdateConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteConfig)
}

// createOrUpdateConfigurationHandleResponse handles the CreateOrUpdateConfiguration response.
func (client *AppsClient) createOrUpdateConfigurationHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateConfigurationResponse, error) {
	result := AppsClientCreateOrUpdateConfigurationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return AppsClientCreateOrUpdateConfigurationResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateConfigurationSlot - Updates the configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
// siteConfig - JSON representation of a SiteConfig object. See example.
// options - AppsClientCreateOrUpdateConfigurationSlotOptions contains the optional parameters for the AppsClient.CreateOrUpdateConfigurationSlot
// method.
func (client *AppsClient) CreateOrUpdateConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *AppsClientCreateOrUpdateConfigurationSlotOptions) (AppsClientCreateOrUpdateConfigurationSlotResponse, error) {
	req, err := client.createOrUpdateConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, siteConfig, options)
	if err != nil {
		return AppsClientCreateOrUpdateConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateConfigurationSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateConfigurationSlotHandleResponse(resp)
}

// createOrUpdateConfigurationSlotCreateRequest creates the CreateOrUpdateConfigurationSlot request.
func (client *AppsClient) createOrUpdateConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *AppsClientCreateOrUpdateConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteConfig)
}

// createOrUpdateConfigurationSlotHandleResponse handles the CreateOrUpdateConfigurationSlot response.
func (client *AppsClient) createOrUpdateConfigurationSlotHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateConfigurationSlotResponse, error) {
	result := AppsClientCreateOrUpdateConfigurationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return AppsClientCreateOrUpdateConfigurationSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateDomainOwnershipIdentifier - Creates a domain ownership identifier for web app, or updates an existing ownership
// identifier.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// domainOwnershipIdentifierName - Name of domain ownership identifier.
// domainOwnershipIdentifier - A JSON representation of the domain ownership properties.
// options - AppsClientCreateOrUpdateDomainOwnershipIdentifierOptions contains the optional parameters for the AppsClient.CreateOrUpdateDomainOwnershipIdentifier
// method.
func (client *AppsClient) CreateOrUpdateDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *AppsClientCreateOrUpdateDomainOwnershipIdentifierOptions) (AppsClientCreateOrUpdateDomainOwnershipIdentifierResponse, error) {
	req, err := client.createOrUpdateDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options)
	if err != nil {
		return AppsClientCreateOrUpdateDomainOwnershipIdentifierResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateDomainOwnershipIdentifierResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateDomainOwnershipIdentifierResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateDomainOwnershipIdentifierHandleResponse(resp)
}

// createOrUpdateDomainOwnershipIdentifierCreateRequest creates the CreateOrUpdateDomainOwnershipIdentifier request.
func (client *AppsClient) createOrUpdateDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *AppsClientCreateOrUpdateDomainOwnershipIdentifierOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, domainOwnershipIdentifier)
}

// createOrUpdateDomainOwnershipIdentifierHandleResponse handles the CreateOrUpdateDomainOwnershipIdentifier response.
func (client *AppsClient) createOrUpdateDomainOwnershipIdentifierHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateDomainOwnershipIdentifierResponse, error) {
	result := AppsClientCreateOrUpdateDomainOwnershipIdentifierResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return AppsClientCreateOrUpdateDomainOwnershipIdentifierResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateDomainOwnershipIdentifierSlot - Creates a domain ownership identifier for web app, or updates an existing
// ownership identifier.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// domainOwnershipIdentifierName - Name of domain ownership identifier.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
// domainOwnershipIdentifier - A JSON representation of the domain ownership properties.
// options - AppsClientCreateOrUpdateDomainOwnershipIdentifierSlotOptions contains the optional parameters for the AppsClient.CreateOrUpdateDomainOwnershipIdentifierSlot
// method.
func (client *AppsClient) CreateOrUpdateDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *AppsClientCreateOrUpdateDomainOwnershipIdentifierSlotOptions) (AppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse, error) {
	req, err := client.createOrUpdateDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier, options)
	if err != nil {
		return AppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateDomainOwnershipIdentifierSlotHandleResponse(resp)
}

// createOrUpdateDomainOwnershipIdentifierSlotCreateRequest creates the CreateOrUpdateDomainOwnershipIdentifierSlot request.
func (client *AppsClient) createOrUpdateDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *AppsClientCreateOrUpdateDomainOwnershipIdentifierSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, domainOwnershipIdentifier)
}

// createOrUpdateDomainOwnershipIdentifierSlotHandleResponse handles the CreateOrUpdateDomainOwnershipIdentifierSlot response.
func (client *AppsClient) createOrUpdateDomainOwnershipIdentifierSlotHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse, error) {
	result := AppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return AppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateFunctionSecret - Add or update a function secret.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - The name of the function.
// keyName - The name of the key.
// key - The key to create or update
// options - AppsClientCreateOrUpdateFunctionSecretOptions contains the optional parameters for the AppsClient.CreateOrUpdateFunctionSecret
// method.
func (client *AppsClient) CreateOrUpdateFunctionSecret(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, key KeyInfo, options *AppsClientCreateOrUpdateFunctionSecretOptions) (AppsClientCreateOrUpdateFunctionSecretResponse, error) {
	req, err := client.createOrUpdateFunctionSecretCreateRequest(ctx, resourceGroupName, name, functionName, keyName, key, options)
	if err != nil {
		return AppsClientCreateOrUpdateFunctionSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateFunctionSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return AppsClientCreateOrUpdateFunctionSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateFunctionSecretHandleResponse(resp)
}

// createOrUpdateFunctionSecretCreateRequest creates the CreateOrUpdateFunctionSecret request.
func (client *AppsClient) createOrUpdateFunctionSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, key KeyInfo, options *AppsClientCreateOrUpdateFunctionSecretOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, key)
}

// createOrUpdateFunctionSecretHandleResponse handles the CreateOrUpdateFunctionSecret response.
func (client *AppsClient) createOrUpdateFunctionSecretHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateFunctionSecretResponse, error) {
	result := AppsClientCreateOrUpdateFunctionSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyInfo); err != nil {
		return AppsClientCreateOrUpdateFunctionSecretResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateFunctionSecretSlot - Add or update a function secret.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - The name of the function.
// keyName - The name of the key.
// slot - Name of the deployment slot.
// key - The key to create or update
// options - AppsClientCreateOrUpdateFunctionSecretSlotOptions contains the optional parameters for the AppsClient.CreateOrUpdateFunctionSecretSlot
// method.
func (client *AppsClient) CreateOrUpdateFunctionSecretSlot(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, key KeyInfo, options *AppsClientCreateOrUpdateFunctionSecretSlotOptions) (AppsClientCreateOrUpdateFunctionSecretSlotResponse, error) {
	req, err := client.createOrUpdateFunctionSecretSlotCreateRequest(ctx, resourceGroupName, name, functionName, keyName, slot, key, options)
	if err != nil {
		return AppsClientCreateOrUpdateFunctionSecretSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateFunctionSecretSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return AppsClientCreateOrUpdateFunctionSecretSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateFunctionSecretSlotHandleResponse(resp)
}

// createOrUpdateFunctionSecretSlotCreateRequest creates the CreateOrUpdateFunctionSecretSlot request.
func (client *AppsClient) createOrUpdateFunctionSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, key KeyInfo, options *AppsClientCreateOrUpdateFunctionSecretSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, key)
}

// createOrUpdateFunctionSecretSlotHandleResponse handles the CreateOrUpdateFunctionSecretSlot response.
func (client *AppsClient) createOrUpdateFunctionSecretSlotHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateFunctionSecretSlotResponse, error) {
	result := AppsClientCreateOrUpdateFunctionSecretSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyInfo); err != nil {
		return AppsClientCreateOrUpdateFunctionSecretSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateHostNameBinding - Creates a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// hostName - Hostname in the hostname binding.
// hostNameBinding - Binding details. This is the JSON representation of a HostNameBinding object.
// options - AppsClientCreateOrUpdateHostNameBindingOptions contains the optional parameters for the AppsClient.CreateOrUpdateHostNameBinding
// method.
func (client *AppsClient) CreateOrUpdateHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, hostNameBinding HostNameBinding, options *AppsClientCreateOrUpdateHostNameBindingOptions) (AppsClientCreateOrUpdateHostNameBindingResponse, error) {
	req, err := client.createOrUpdateHostNameBindingCreateRequest(ctx, resourceGroupName, name, hostName, hostNameBinding, options)
	if err != nil {
		return AppsClientCreateOrUpdateHostNameBindingResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateHostNameBindingResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateHostNameBindingResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateHostNameBindingHandleResponse(resp)
}

// createOrUpdateHostNameBindingCreateRequest creates the CreateOrUpdateHostNameBinding request.
func (client *AppsClient) createOrUpdateHostNameBindingCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, hostNameBinding HostNameBinding, options *AppsClientCreateOrUpdateHostNameBindingOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, hostNameBinding)
}

// createOrUpdateHostNameBindingHandleResponse handles the CreateOrUpdateHostNameBinding response.
func (client *AppsClient) createOrUpdateHostNameBindingHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateHostNameBindingResponse, error) {
	result := AppsClientCreateOrUpdateHostNameBindingResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBinding); err != nil {
		return AppsClientCreateOrUpdateHostNameBindingResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateHostNameBindingSlot - Creates a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// hostName - Hostname in the hostname binding.
// slot - Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
// hostNameBinding - Binding details. This is the JSON representation of a HostNameBinding object.
// options - AppsClientCreateOrUpdateHostNameBindingSlotOptions contains the optional parameters for the AppsClient.CreateOrUpdateHostNameBindingSlot
// method.
func (client *AppsClient) CreateOrUpdateHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, hostName string, slot string, hostNameBinding HostNameBinding, options *AppsClientCreateOrUpdateHostNameBindingSlotOptions) (AppsClientCreateOrUpdateHostNameBindingSlotResponse, error) {
	req, err := client.createOrUpdateHostNameBindingSlotCreateRequest(ctx, resourceGroupName, name, hostName, slot, hostNameBinding, options)
	if err != nil {
		return AppsClientCreateOrUpdateHostNameBindingSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateHostNameBindingSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateHostNameBindingSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateHostNameBindingSlotHandleResponse(resp)
}

// createOrUpdateHostNameBindingSlotCreateRequest creates the CreateOrUpdateHostNameBindingSlot request.
func (client *AppsClient) createOrUpdateHostNameBindingSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, slot string, hostNameBinding HostNameBinding, options *AppsClientCreateOrUpdateHostNameBindingSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, hostNameBinding)
}

// createOrUpdateHostNameBindingSlotHandleResponse handles the CreateOrUpdateHostNameBindingSlot response.
func (client *AppsClient) createOrUpdateHostNameBindingSlotHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateHostNameBindingSlotResponse, error) {
	result := AppsClientCreateOrUpdateHostNameBindingSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBinding); err != nil {
		return AppsClientCreateOrUpdateHostNameBindingSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateHostSecret - Add or update a host level secret.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// keyType - The type of host key.
// keyName - The name of the key.
// key - The key to create or update
// options - AppsClientCreateOrUpdateHostSecretOptions contains the optional parameters for the AppsClient.CreateOrUpdateHostSecret
// method.
func (client *AppsClient) CreateOrUpdateHostSecret(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, key KeyInfo, options *AppsClientCreateOrUpdateHostSecretOptions) (AppsClientCreateOrUpdateHostSecretResponse, error) {
	req, err := client.createOrUpdateHostSecretCreateRequest(ctx, resourceGroupName, name, keyType, keyName, key, options)
	if err != nil {
		return AppsClientCreateOrUpdateHostSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateHostSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return AppsClientCreateOrUpdateHostSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateHostSecretHandleResponse(resp)
}

// createOrUpdateHostSecretCreateRequest creates the CreateOrUpdateHostSecret request.
func (client *AppsClient) createOrUpdateHostSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, key KeyInfo, options *AppsClientCreateOrUpdateHostSecretOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, key)
}

// createOrUpdateHostSecretHandleResponse handles the CreateOrUpdateHostSecret response.
func (client *AppsClient) createOrUpdateHostSecretHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateHostSecretResponse, error) {
	result := AppsClientCreateOrUpdateHostSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyInfo); err != nil {
		return AppsClientCreateOrUpdateHostSecretResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateHostSecretSlot - Add or update a host level secret.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// keyType - The type of host key.
// keyName - The name of the key.
// slot - Name of the deployment slot.
// key - The key to create or update
// options - AppsClientCreateOrUpdateHostSecretSlotOptions contains the optional parameters for the AppsClient.CreateOrUpdateHostSecretSlot
// method.
func (client *AppsClient) CreateOrUpdateHostSecretSlot(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, key KeyInfo, options *AppsClientCreateOrUpdateHostSecretSlotOptions) (AppsClientCreateOrUpdateHostSecretSlotResponse, error) {
	req, err := client.createOrUpdateHostSecretSlotCreateRequest(ctx, resourceGroupName, name, keyType, keyName, slot, key, options)
	if err != nil {
		return AppsClientCreateOrUpdateHostSecretSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateHostSecretSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return AppsClientCreateOrUpdateHostSecretSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateHostSecretSlotHandleResponse(resp)
}

// createOrUpdateHostSecretSlotCreateRequest creates the CreateOrUpdateHostSecretSlot request.
func (client *AppsClient) createOrUpdateHostSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, key KeyInfo, options *AppsClientCreateOrUpdateHostSecretSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, key)
}

// createOrUpdateHostSecretSlotHandleResponse handles the CreateOrUpdateHostSecretSlot response.
func (client *AppsClient) createOrUpdateHostSecretSlotHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateHostSecretSlotResponse, error) {
	result := AppsClientCreateOrUpdateHostSecretSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyInfo); err != nil {
		return AppsClientCreateOrUpdateHostSecretSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateHybridConnection - Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// namespaceName - The namespace for this hybrid connection.
// relayName - The relay name for this hybrid connection.
// connectionEnvelope - The details of the hybrid connection.
// options - AppsClientCreateOrUpdateHybridConnectionOptions contains the optional parameters for the AppsClient.CreateOrUpdateHybridConnection
// method.
func (client *AppsClient) CreateOrUpdateHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *AppsClientCreateOrUpdateHybridConnectionOptions) (AppsClientCreateOrUpdateHybridConnectionResponse, error) {
	req, err := client.createOrUpdateHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options)
	if err != nil {
		return AppsClientCreateOrUpdateHybridConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateHybridConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateHybridConnectionHandleResponse(resp)
}

// createOrUpdateHybridConnectionCreateRequest creates the CreateOrUpdateHybridConnection request.
func (client *AppsClient) createOrUpdateHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *AppsClientCreateOrUpdateHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateHybridConnectionHandleResponse handles the CreateOrUpdateHybridConnection response.
func (client *AppsClient) createOrUpdateHybridConnectionHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateHybridConnectionResponse, error) {
	result := AppsClientCreateOrUpdateHybridConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return AppsClientCreateOrUpdateHybridConnectionResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateHybridConnectionSlot - Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// namespaceName - The namespace for this hybrid connection.
// relayName - The relay name for this hybrid connection.
// slot - The name of the slot for the web app.
// connectionEnvelope - The details of the hybrid connection.
// options - AppsClientCreateOrUpdateHybridConnectionSlotOptions contains the optional parameters for the AppsClient.CreateOrUpdateHybridConnectionSlot
// method.
func (client *AppsClient) CreateOrUpdateHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *AppsClientCreateOrUpdateHybridConnectionSlotOptions) (AppsClientCreateOrUpdateHybridConnectionSlotResponse, error) {
	req, err := client.createOrUpdateHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope, options)
	if err != nil {
		return AppsClientCreateOrUpdateHybridConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateHybridConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateHybridConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateHybridConnectionSlotHandleResponse(resp)
}

// createOrUpdateHybridConnectionSlotCreateRequest creates the CreateOrUpdateHybridConnectionSlot request.
func (client *AppsClient) createOrUpdateHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *AppsClientCreateOrUpdateHybridConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateHybridConnectionSlotHandleResponse handles the CreateOrUpdateHybridConnectionSlot response.
func (client *AppsClient) createOrUpdateHybridConnectionSlotHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateHybridConnectionSlotResponse, error) {
	result := AppsClientCreateOrUpdateHybridConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return AppsClientCreateOrUpdateHybridConnectionSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdatePublicCertificate - Creates a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// publicCertificateName - Public certificate name.
// publicCertificate - Public certificate details. This is the JSON representation of a PublicCertificate object.
// options - AppsClientCreateOrUpdatePublicCertificateOptions contains the optional parameters for the AppsClient.CreateOrUpdatePublicCertificate
// method.
func (client *AppsClient) CreateOrUpdatePublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, publicCertificate PublicCertificate, options *AppsClientCreateOrUpdatePublicCertificateOptions) (AppsClientCreateOrUpdatePublicCertificateResponse, error) {
	req, err := client.createOrUpdatePublicCertificateCreateRequest(ctx, resourceGroupName, name, publicCertificateName, publicCertificate, options)
	if err != nil {
		return AppsClientCreateOrUpdatePublicCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdatePublicCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdatePublicCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdatePublicCertificateHandleResponse(resp)
}

// createOrUpdatePublicCertificateCreateRequest creates the CreateOrUpdatePublicCertificate request.
func (client *AppsClient) createOrUpdatePublicCertificateCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, publicCertificate PublicCertificate, options *AppsClientCreateOrUpdatePublicCertificateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, publicCertificate)
}

// createOrUpdatePublicCertificateHandleResponse handles the CreateOrUpdatePublicCertificate response.
func (client *AppsClient) createOrUpdatePublicCertificateHandleResponse(resp *http.Response) (AppsClientCreateOrUpdatePublicCertificateResponse, error) {
	result := AppsClientCreateOrUpdatePublicCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificate); err != nil {
		return AppsClientCreateOrUpdatePublicCertificateResponse{}, err
	}
	return result, nil
}

// CreateOrUpdatePublicCertificateSlot - Creates a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// publicCertificateName - Public certificate name.
// slot - Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
// publicCertificate - Public certificate details. This is the JSON representation of a PublicCertificate object.
// options - AppsClientCreateOrUpdatePublicCertificateSlotOptions contains the optional parameters for the AppsClient.CreateOrUpdatePublicCertificateSlot
// method.
func (client *AppsClient) CreateOrUpdatePublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, slot string, publicCertificate PublicCertificate, options *AppsClientCreateOrUpdatePublicCertificateSlotOptions) (AppsClientCreateOrUpdatePublicCertificateSlotResponse, error) {
	req, err := client.createOrUpdatePublicCertificateSlotCreateRequest(ctx, resourceGroupName, name, publicCertificateName, slot, publicCertificate, options)
	if err != nil {
		return AppsClientCreateOrUpdatePublicCertificateSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdatePublicCertificateSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdatePublicCertificateSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdatePublicCertificateSlotHandleResponse(resp)
}

// createOrUpdatePublicCertificateSlotCreateRequest creates the CreateOrUpdatePublicCertificateSlot request.
func (client *AppsClient) createOrUpdatePublicCertificateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, slot string, publicCertificate PublicCertificate, options *AppsClientCreateOrUpdatePublicCertificateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, publicCertificate)
}

// createOrUpdatePublicCertificateSlotHandleResponse handles the CreateOrUpdatePublicCertificateSlot response.
func (client *AppsClient) createOrUpdatePublicCertificateSlotHandleResponse(resp *http.Response) (AppsClientCreateOrUpdatePublicCertificateSlotResponse, error) {
	result := AppsClientCreateOrUpdatePublicCertificateSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificate); err != nil {
		return AppsClientCreateOrUpdatePublicCertificateSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateRelayServiceConnection - Creates a new hybrid connection configuration (PUT), or updates an existing one
// (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// entityName - Name of the hybrid connection configuration.
// connectionEnvelope - Details of the hybrid connection configuration.
// options - AppsClientCreateOrUpdateRelayServiceConnectionOptions contains the optional parameters for the AppsClient.CreateOrUpdateRelayServiceConnection
// method.
func (client *AppsClient) CreateOrUpdateRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *AppsClientCreateOrUpdateRelayServiceConnectionOptions) (AppsClientCreateOrUpdateRelayServiceConnectionResponse, error) {
	req, err := client.createOrUpdateRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, connectionEnvelope, options)
	if err != nil {
		return AppsClientCreateOrUpdateRelayServiceConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateRelayServiceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateRelayServiceConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateRelayServiceConnectionHandleResponse(resp)
}

// createOrUpdateRelayServiceConnectionCreateRequest creates the CreateOrUpdateRelayServiceConnection request.
func (client *AppsClient) createOrUpdateRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *AppsClientCreateOrUpdateRelayServiceConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateRelayServiceConnectionHandleResponse handles the CreateOrUpdateRelayServiceConnection response.
func (client *AppsClient) createOrUpdateRelayServiceConnectionHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateRelayServiceConnectionResponse, error) {
	result := AppsClientCreateOrUpdateRelayServiceConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return AppsClientCreateOrUpdateRelayServiceConnectionResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateRelayServiceConnectionSlot - Creates a new hybrid connection configuration (PUT), or updates an existing
// one (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// entityName - Name of the hybrid connection configuration.
// slot - Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the
// production slot.
// connectionEnvelope - Details of the hybrid connection configuration.
// options - AppsClientCreateOrUpdateRelayServiceConnectionSlotOptions contains the optional parameters for the AppsClient.CreateOrUpdateRelayServiceConnectionSlot
// method.
func (client *AppsClient) CreateOrUpdateRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *AppsClientCreateOrUpdateRelayServiceConnectionSlotOptions) (AppsClientCreateOrUpdateRelayServiceConnectionSlotResponse, error) {
	req, err := client.createOrUpdateRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, connectionEnvelope, options)
	if err != nil {
		return AppsClientCreateOrUpdateRelayServiceConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateRelayServiceConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateRelayServiceConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateRelayServiceConnectionSlotHandleResponse(resp)
}

// createOrUpdateRelayServiceConnectionSlotCreateRequest creates the CreateOrUpdateRelayServiceConnectionSlot request.
func (client *AppsClient) createOrUpdateRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *AppsClientCreateOrUpdateRelayServiceConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateRelayServiceConnectionSlotHandleResponse handles the CreateOrUpdateRelayServiceConnectionSlot response.
func (client *AppsClient) createOrUpdateRelayServiceConnectionSlotHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateRelayServiceConnectionSlotResponse, error) {
	result := AppsClientCreateOrUpdateRelayServiceConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return AppsClientCreateOrUpdateRelayServiceConnectionSlotResponse{}, err
	}
	return result, nil
}

// BeginCreateOrUpdateSlot - Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
// slot - Name of the deployment slot to create or update. The name 'production' is reserved.
// siteEnvelope - A JSON representation of the app properties. See example.
// options - AppsClientBeginCreateOrUpdateSlotOptions contains the optional parameters for the AppsClient.BeginCreateOrUpdateSlot
// method.
func (client *AppsClient) BeginCreateOrUpdateSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope Site, options *AppsClientBeginCreateOrUpdateSlotOptions) (*runtime.Poller[AppsClientCreateOrUpdateSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateSlot(ctx, resourceGroupName, name, slot, siteEnvelope, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientCreateOrUpdateSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientCreateOrUpdateSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// CreateOrUpdateSlot - Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) createOrUpdateSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope Site, options *AppsClientBeginCreateOrUpdateSlotOptions) (*http.Response, error) {
	req, err := client.createOrUpdateSlotCreateRequest(ctx, resourceGroupName, name, slot, siteEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createOrUpdateSlotCreateRequest creates the CreateOrUpdateSlot request.
func (client *AppsClient) createOrUpdateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope Site, options *AppsClientBeginCreateOrUpdateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteEnvelope)
}

// BeginCreateOrUpdateSourceControl - Updates the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// siteSourceControl - JSON representation of a SiteSourceControl object. See example.
// options - AppsClientBeginCreateOrUpdateSourceControlOptions contains the optional parameters for the AppsClient.BeginCreateOrUpdateSourceControl
// method.
func (client *AppsClient) BeginCreateOrUpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *AppsClientBeginCreateOrUpdateSourceControlOptions) (*runtime.Poller[AppsClientCreateOrUpdateSourceControlResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateSourceControl(ctx, resourceGroupName, name, siteSourceControl, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientCreateOrUpdateSourceControlResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientCreateOrUpdateSourceControlResponse](options.ResumeToken, client.pl, nil)
	}
}

// CreateOrUpdateSourceControl - Updates the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) createOrUpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *AppsClientBeginCreateOrUpdateSourceControlOptions) (*http.Response, error) {
	req, err := client.createOrUpdateSourceControlCreateRequest(ctx, resourceGroupName, name, siteSourceControl, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createOrUpdateSourceControlCreateRequest creates the CreateOrUpdateSourceControl request.
func (client *AppsClient) createOrUpdateSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *AppsClientBeginCreateOrUpdateSourceControlOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteSourceControl)
}

// BeginCreateOrUpdateSourceControlSlot - Updates the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for
// the production slot.
// siteSourceControl - JSON representation of a SiteSourceControl object. See example.
// options - AppsClientBeginCreateOrUpdateSourceControlSlotOptions contains the optional parameters for the AppsClient.BeginCreateOrUpdateSourceControlSlot
// method.
func (client *AppsClient) BeginCreateOrUpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *AppsClientBeginCreateOrUpdateSourceControlSlotOptions) (*runtime.Poller[AppsClientCreateOrUpdateSourceControlSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateSourceControlSlot(ctx, resourceGroupName, name, slot, siteSourceControl, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientCreateOrUpdateSourceControlSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientCreateOrUpdateSourceControlSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// CreateOrUpdateSourceControlSlot - Updates the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) createOrUpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *AppsClientBeginCreateOrUpdateSourceControlSlotOptions) (*http.Response, error) {
	req, err := client.createOrUpdateSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, siteSourceControl, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createOrUpdateSourceControlSlotCreateRequest creates the CreateOrUpdateSourceControlSlot request.
func (client *AppsClient) createOrUpdateSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *AppsClientBeginCreateOrUpdateSourceControlSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteSourceControl)
}

// CreateOrUpdateSwiftVirtualNetworkConnection - Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported"
// is true when doing a GET against this resource, and 2) that the target Subnet has already been delegated, and is
// not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// connectionEnvelope - Properties of the Virtual Network connection. See example.
// options - AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionOptions contains the optional parameters for the AppsClient.CreateOrUpdateSwiftVirtualNetworkConnection
// method.
func (client *AppsClient) CreateOrUpdateSwiftVirtualNetworkConnection(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionOptions) (AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionResponse, error) {
	req, err := client.createOrUpdateSwiftVirtualNetworkConnectionCreateRequest(ctx, resourceGroupName, name, connectionEnvelope, options)
	if err != nil {
		return AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateSwiftVirtualNetworkConnectionHandleResponse(resp)
}

// createOrUpdateSwiftVirtualNetworkConnectionCreateRequest creates the CreateOrUpdateSwiftVirtualNetworkConnection request.
func (client *AppsClient) createOrUpdateSwiftVirtualNetworkConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateSwiftVirtualNetworkConnectionHandleResponse handles the CreateOrUpdateSwiftVirtualNetworkConnection response.
func (client *AppsClient) createOrUpdateSwiftVirtualNetworkConnectionHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionResponse, error) {
	result := AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateSwiftVirtualNetworkConnectionSlot - Integrates this Web App with a Virtual Network. This requires that 1)
// "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has already been delegated,
// and is
// not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production
// slot.
// connectionEnvelope - Properties of the Virtual Network connection. See example.
// options - AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionSlotOptions contains the optional parameters for the AppsClient.CreateOrUpdateSwiftVirtualNetworkConnectionSlot
// method.
func (client *AppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionSlot(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionSlotOptions) (AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionSlotResponse, error) {
	req, err := client.createOrUpdateSwiftVirtualNetworkConnectionSlotCreateRequest(ctx, resourceGroupName, name, slot, connectionEnvelope, options)
	if err != nil {
		return AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateSwiftVirtualNetworkConnectionSlotHandleResponse(resp)
}

// createOrUpdateSwiftVirtualNetworkConnectionSlotCreateRequest creates the CreateOrUpdateSwiftVirtualNetworkConnectionSlot request.
func (client *AppsClient) createOrUpdateSwiftVirtualNetworkConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateSwiftVirtualNetworkConnectionSlotHandleResponse handles the CreateOrUpdateSwiftVirtualNetworkConnectionSlot response.
func (client *AppsClient) createOrUpdateSwiftVirtualNetworkConnectionSlotHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionSlotResponse, error) {
	result := AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return AppsClientCreateOrUpdateSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateVnetConnection - Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
// (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of an existing Virtual Network.
// connectionEnvelope - Properties of the Virtual Network connection. See example.
// options - AppsClientCreateOrUpdateVnetConnectionOptions contains the optional parameters for the AppsClient.CreateOrUpdateVnetConnection
// method.
func (client *AppsClient) CreateOrUpdateVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo, options *AppsClientCreateOrUpdateVnetConnectionOptions) (AppsClientCreateOrUpdateVnetConnectionResponse, error) {
	req, err := client.createOrUpdateVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, connectionEnvelope, options)
	if err != nil {
		return AppsClientCreateOrUpdateVnetConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateVnetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateVnetConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateVnetConnectionHandleResponse(resp)
}

// createOrUpdateVnetConnectionCreateRequest creates the CreateOrUpdateVnetConnection request.
func (client *AppsClient) createOrUpdateVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo, options *AppsClientCreateOrUpdateVnetConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateVnetConnectionHandleResponse handles the CreateOrUpdateVnetConnection response.
func (client *AppsClient) createOrUpdateVnetConnectionHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateVnetConnectionResponse, error) {
	result := AppsClientCreateOrUpdateVnetConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfo); err != nil {
		return AppsClientCreateOrUpdateVnetConnectionResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateVnetConnectionGateway - Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of the Virtual Network.
// gatewayName - Name of the gateway. Currently, the only supported string is "primary".
// connectionEnvelope - The properties to update this gateway with.
// options - AppsClientCreateOrUpdateVnetConnectionGatewayOptions contains the optional parameters for the AppsClient.CreateOrUpdateVnetConnectionGateway
// method.
func (client *AppsClient) CreateOrUpdateVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *AppsClientCreateOrUpdateVnetConnectionGatewayOptions) (AppsClientCreateOrUpdateVnetConnectionGatewayResponse, error) {
	req, err := client.createOrUpdateVnetConnectionGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options)
	if err != nil {
		return AppsClientCreateOrUpdateVnetConnectionGatewayResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateVnetConnectionGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateVnetConnectionGatewayResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateVnetConnectionGatewayHandleResponse(resp)
}

// createOrUpdateVnetConnectionGatewayCreateRequest creates the CreateOrUpdateVnetConnectionGateway request.
func (client *AppsClient) createOrUpdateVnetConnectionGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *AppsClientCreateOrUpdateVnetConnectionGatewayOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateVnetConnectionGatewayHandleResponse handles the CreateOrUpdateVnetConnectionGateway response.
func (client *AppsClient) createOrUpdateVnetConnectionGatewayHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateVnetConnectionGatewayResponse, error) {
	result := AppsClientCreateOrUpdateVnetConnectionGatewayResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return AppsClientCreateOrUpdateVnetConnectionGatewayResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateVnetConnectionGatewaySlot - Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of the Virtual Network.
// gatewayName - Name of the gateway. Currently, the only supported string is "primary".
// slot - Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production
// slot's Virtual Network.
// connectionEnvelope - The properties to update this gateway with.
// options - AppsClientCreateOrUpdateVnetConnectionGatewaySlotOptions contains the optional parameters for the AppsClient.CreateOrUpdateVnetConnectionGatewaySlot
// method.
func (client *AppsClient) CreateOrUpdateVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *AppsClientCreateOrUpdateVnetConnectionGatewaySlotOptions) (AppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse, error) {
	req, err := client.createOrUpdateVnetConnectionGatewaySlotCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope, options)
	if err != nil {
		return AppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateVnetConnectionGatewaySlotHandleResponse(resp)
}

// createOrUpdateVnetConnectionGatewaySlotCreateRequest creates the CreateOrUpdateVnetConnectionGatewaySlot request.
func (client *AppsClient) createOrUpdateVnetConnectionGatewaySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *AppsClientCreateOrUpdateVnetConnectionGatewaySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateVnetConnectionGatewaySlotHandleResponse handles the CreateOrUpdateVnetConnectionGatewaySlot response.
func (client *AppsClient) createOrUpdateVnetConnectionGatewaySlotHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse, error) {
	result := AppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return AppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateVnetConnectionSlot - Adds a Virtual Network connection to an app or slot (PUT) or updates the connection
// properties (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of an existing Virtual Network.
// slot - Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production
// slot.
// connectionEnvelope - Properties of the Virtual Network connection. See example.
// options - AppsClientCreateOrUpdateVnetConnectionSlotOptions contains the optional parameters for the AppsClient.CreateOrUpdateVnetConnectionSlot
// method.
func (client *AppsClient) CreateOrUpdateVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfo, options *AppsClientCreateOrUpdateVnetConnectionSlotOptions) (AppsClientCreateOrUpdateVnetConnectionSlotResponse, error) {
	req, err := client.createOrUpdateVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, connectionEnvelope, options)
	if err != nil {
		return AppsClientCreateOrUpdateVnetConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientCreateOrUpdateVnetConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientCreateOrUpdateVnetConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateVnetConnectionSlotHandleResponse(resp)
}

// createOrUpdateVnetConnectionSlotCreateRequest creates the CreateOrUpdateVnetConnectionSlot request.
func (client *AppsClient) createOrUpdateVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfo, options *AppsClientCreateOrUpdateVnetConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateVnetConnectionSlotHandleResponse handles the CreateOrUpdateVnetConnectionSlot response.
func (client *AppsClient) createOrUpdateVnetConnectionSlotHandleResponse(resp *http.Response) (AppsClientCreateOrUpdateVnetConnectionSlotResponse, error) {
	result := AppsClientCreateOrUpdateVnetConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfo); err != nil {
		return AppsClientCreateOrUpdateVnetConnectionSlotResponse{}, err
	}
	return result, nil
}

// Delete - Deletes a web, mobile, or API app, or one of the deployment slots.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app to delete.
// options - AppsClientDeleteOptions contains the optional parameters for the AppsClient.Delete method.
func (client *AppsClient) Delete(ctx context.Context, resourceGroupName string, name string, options *AppsClientDeleteOptions) (AppsClientDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteResponse{}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *AppsClient) deleteCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientDeleteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DeleteMetrics != nil {
		reqQP.Set("deleteMetrics", strconv.FormatBool(*options.DeleteMetrics))
	}
	if options != nil && options.DeleteEmptyServerFarm != nil {
		reqQP.Set("deleteEmptyServerFarm", strconv.FormatBool(*options.DeleteEmptyServerFarm))
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteBackup - Deletes a backup of an app by its ID.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// backupID - ID of the backup.
// options - AppsClientDeleteBackupOptions contains the optional parameters for the AppsClient.DeleteBackup method.
func (client *AppsClient) DeleteBackup(ctx context.Context, resourceGroupName string, name string, backupID string, options *AppsClientDeleteBackupOptions) (AppsClientDeleteBackupResponse, error) {
	req, err := client.deleteBackupCreateRequest(ctx, resourceGroupName, name, backupID, options)
	if err != nil {
		return AppsClientDeleteBackupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteBackupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientDeleteBackupResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteBackupResponse{}, nil
}

// deleteBackupCreateRequest creates the DeleteBackup request.
func (client *AppsClient) deleteBackupCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, options *AppsClientDeleteBackupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteBackupConfiguration - Deletes the backup configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientDeleteBackupConfigurationOptions contains the optional parameters for the AppsClient.DeleteBackupConfiguration
// method.
func (client *AppsClient) DeleteBackupConfiguration(ctx context.Context, resourceGroupName string, name string, options *AppsClientDeleteBackupConfigurationOptions) (AppsClientDeleteBackupConfigurationResponse, error) {
	req, err := client.deleteBackupConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientDeleteBackupConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteBackupConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientDeleteBackupConfigurationResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteBackupConfigurationResponse{}, nil
}

// deleteBackupConfigurationCreateRequest creates the DeleteBackupConfiguration request.
func (client *AppsClient) deleteBackupConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientDeleteBackupConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteBackupConfigurationSlot - Deletes the backup configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete the backup configuration for the production
// slot.
// options - AppsClientDeleteBackupConfigurationSlotOptions contains the optional parameters for the AppsClient.DeleteBackupConfigurationSlot
// method.
func (client *AppsClient) DeleteBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientDeleteBackupConfigurationSlotOptions) (AppsClientDeleteBackupConfigurationSlotResponse, error) {
	req, err := client.deleteBackupConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientDeleteBackupConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteBackupConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientDeleteBackupConfigurationSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteBackupConfigurationSlotResponse{}, nil
}

// deleteBackupConfigurationSlotCreateRequest creates the DeleteBackupConfigurationSlot request.
func (client *AppsClient) deleteBackupConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientDeleteBackupConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteBackupSlot - Deletes a backup of an app by its ID.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// backupID - ID of the backup.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete a backup of the production slot.
// options - AppsClientDeleteBackupSlotOptions contains the optional parameters for the AppsClient.DeleteBackupSlot method.
func (client *AppsClient) DeleteBackupSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *AppsClientDeleteBackupSlotOptions) (AppsClientDeleteBackupSlotResponse, error) {
	req, err := client.deleteBackupSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, options)
	if err != nil {
		return AppsClientDeleteBackupSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteBackupSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientDeleteBackupSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteBackupSlotResponse{}, nil
}

// deleteBackupSlotCreateRequest creates the DeleteBackupSlot request.
func (client *AppsClient) deleteBackupSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *AppsClientDeleteBackupSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteContinuousWebJob - Delete a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// options - AppsClientDeleteContinuousWebJobOptions contains the optional parameters for the AppsClient.DeleteContinuousWebJob
// method.
func (client *AppsClient) DeleteContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientDeleteContinuousWebJobOptions) (AppsClientDeleteContinuousWebJobResponse, error) {
	req, err := client.deleteContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return AppsClientDeleteContinuousWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteContinuousWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientDeleteContinuousWebJobResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteContinuousWebJobResponse{}, nil
}

// deleteContinuousWebJobCreateRequest creates the DeleteContinuousWebJob request.
func (client *AppsClient) deleteContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientDeleteContinuousWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteContinuousWebJobSlot - Delete a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientDeleteContinuousWebJobSlotOptions contains the optional parameters for the AppsClient.DeleteContinuousWebJobSlot
// method.
func (client *AppsClient) DeleteContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientDeleteContinuousWebJobSlotOptions) (AppsClientDeleteContinuousWebJobSlotResponse, error) {
	req, err := client.deleteContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return AppsClientDeleteContinuousWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteContinuousWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientDeleteContinuousWebJobSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteContinuousWebJobSlotResponse{}, nil
}

// deleteContinuousWebJobSlotCreateRequest creates the DeleteContinuousWebJobSlot request.
func (client *AppsClient) deleteContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientDeleteContinuousWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteDeployment - Delete a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// id - Deployment ID.
// options - AppsClientDeleteDeploymentOptions contains the optional parameters for the AppsClient.DeleteDeployment method.
func (client *AppsClient) DeleteDeployment(ctx context.Context, resourceGroupName string, name string, id string, options *AppsClientDeleteDeploymentOptions) (AppsClientDeleteDeploymentResponse, error) {
	req, err := client.deleteDeploymentCreateRequest(ctx, resourceGroupName, name, id, options)
	if err != nil {
		return AppsClientDeleteDeploymentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientDeleteDeploymentResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteDeploymentResponse{}, nil
}

// deleteDeploymentCreateRequest creates the DeleteDeployment request.
func (client *AppsClient) deleteDeploymentCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, options *AppsClientDeleteDeploymentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteDeploymentSlot - Delete a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// id - Deployment ID.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientDeleteDeploymentSlotOptions contains the optional parameters for the AppsClient.DeleteDeploymentSlot
// method.
func (client *AppsClient) DeleteDeploymentSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *AppsClientDeleteDeploymentSlotOptions) (AppsClientDeleteDeploymentSlotResponse, error) {
	req, err := client.deleteDeploymentSlotCreateRequest(ctx, resourceGroupName, name, id, slot, options)
	if err != nil {
		return AppsClientDeleteDeploymentSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteDeploymentSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientDeleteDeploymentSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteDeploymentSlotResponse{}, nil
}

// deleteDeploymentSlotCreateRequest creates the DeleteDeploymentSlot request.
func (client *AppsClient) deleteDeploymentSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *AppsClientDeleteDeploymentSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteDomainOwnershipIdentifier - Deletes a domain ownership identifier for a web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// domainOwnershipIdentifierName - Name of domain ownership identifier.
// options - AppsClientDeleteDomainOwnershipIdentifierOptions contains the optional parameters for the AppsClient.DeleteDomainOwnershipIdentifier
// method.
func (client *AppsClient) DeleteDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *AppsClientDeleteDomainOwnershipIdentifierOptions) (AppsClientDeleteDomainOwnershipIdentifierResponse, error) {
	req, err := client.deleteDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, options)
	if err != nil {
		return AppsClientDeleteDomainOwnershipIdentifierResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteDomainOwnershipIdentifierResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientDeleteDomainOwnershipIdentifierResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteDomainOwnershipIdentifierResponse{}, nil
}

// deleteDomainOwnershipIdentifierCreateRequest creates the DeleteDomainOwnershipIdentifier request.
func (client *AppsClient) deleteDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *AppsClientDeleteDomainOwnershipIdentifierOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteDomainOwnershipIdentifierSlot - Deletes a domain ownership identifier for a web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// domainOwnershipIdentifierName - Name of domain ownership identifier.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
// options - AppsClientDeleteDomainOwnershipIdentifierSlotOptions contains the optional parameters for the AppsClient.DeleteDomainOwnershipIdentifierSlot
// method.
func (client *AppsClient) DeleteDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *AppsClientDeleteDomainOwnershipIdentifierSlotOptions) (AppsClientDeleteDomainOwnershipIdentifierSlotResponse, error) {
	req, err := client.deleteDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, options)
	if err != nil {
		return AppsClientDeleteDomainOwnershipIdentifierSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteDomainOwnershipIdentifierSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientDeleteDomainOwnershipIdentifierSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteDomainOwnershipIdentifierSlotResponse{}, nil
}

// deleteDomainOwnershipIdentifierSlotCreateRequest creates the DeleteDomainOwnershipIdentifierSlot request.
func (client *AppsClient) deleteDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *AppsClientDeleteDomainOwnershipIdentifierSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteFunction - Delete a function for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - Function name.
// options - AppsClientDeleteFunctionOptions contains the optional parameters for the AppsClient.DeleteFunction method.
func (client *AppsClient) DeleteFunction(ctx context.Context, resourceGroupName string, name string, functionName string, options *AppsClientDeleteFunctionOptions) (AppsClientDeleteFunctionResponse, error) {
	req, err := client.deleteFunctionCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return AppsClientDeleteFunctionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteFunctionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteFunctionResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteFunctionResponse{}, nil
}

// deleteFunctionCreateRequest creates the DeleteFunction request.
func (client *AppsClient) deleteFunctionCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *AppsClientDeleteFunctionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteFunctionSecret - Delete a function secret.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - The name of the function.
// keyName - The name of the key.
// options - AppsClientDeleteFunctionSecretOptions contains the optional parameters for the AppsClient.DeleteFunctionSecret
// method.
func (client *AppsClient) DeleteFunctionSecret(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, options *AppsClientDeleteFunctionSecretOptions) (AppsClientDeleteFunctionSecretResponse, error) {
	req, err := client.deleteFunctionSecretCreateRequest(ctx, resourceGroupName, name, functionName, keyName, options)
	if err != nil {
		return AppsClientDeleteFunctionSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteFunctionSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteFunctionSecretResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteFunctionSecretResponse{}, nil
}

// deleteFunctionSecretCreateRequest creates the DeleteFunctionSecret request.
func (client *AppsClient) deleteFunctionSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, options *AppsClientDeleteFunctionSecretOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteFunctionSecretSlot - Delete a function secret.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - The name of the function.
// keyName - The name of the key.
// slot - Name of the deployment slot.
// options - AppsClientDeleteFunctionSecretSlotOptions contains the optional parameters for the AppsClient.DeleteFunctionSecretSlot
// method.
func (client *AppsClient) DeleteFunctionSecretSlot(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, options *AppsClientDeleteFunctionSecretSlotOptions) (AppsClientDeleteFunctionSecretSlotResponse, error) {
	req, err := client.deleteFunctionSecretSlotCreateRequest(ctx, resourceGroupName, name, functionName, keyName, slot, options)
	if err != nil {
		return AppsClientDeleteFunctionSecretSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteFunctionSecretSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteFunctionSecretSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteFunctionSecretSlotResponse{}, nil
}

// deleteFunctionSecretSlotCreateRequest creates the DeleteFunctionSecretSlot request.
func (client *AppsClient) deleteFunctionSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, options *AppsClientDeleteFunctionSecretSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteHostNameBinding - Deletes a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// hostName - Hostname in the hostname binding.
// options - AppsClientDeleteHostNameBindingOptions contains the optional parameters for the AppsClient.DeleteHostNameBinding
// method.
func (client *AppsClient) DeleteHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, options *AppsClientDeleteHostNameBindingOptions) (AppsClientDeleteHostNameBindingResponse, error) {
	req, err := client.deleteHostNameBindingCreateRequest(ctx, resourceGroupName, name, hostName, options)
	if err != nil {
		return AppsClientDeleteHostNameBindingResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteHostNameBindingResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientDeleteHostNameBindingResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteHostNameBindingResponse{}, nil
}

// deleteHostNameBindingCreateRequest creates the DeleteHostNameBinding request.
func (client *AppsClient) deleteHostNameBindingCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, options *AppsClientDeleteHostNameBindingOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteHostNameBindingSlot - Deletes a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
// hostName - Hostname in the hostname binding.
// options - AppsClientDeleteHostNameBindingSlotOptions contains the optional parameters for the AppsClient.DeleteHostNameBindingSlot
// method.
func (client *AppsClient) DeleteHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *AppsClientDeleteHostNameBindingSlotOptions) (AppsClientDeleteHostNameBindingSlotResponse, error) {
	req, err := client.deleteHostNameBindingSlotCreateRequest(ctx, resourceGroupName, name, slot, hostName, options)
	if err != nil {
		return AppsClientDeleteHostNameBindingSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteHostNameBindingSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientDeleteHostNameBindingSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteHostNameBindingSlotResponse{}, nil
}

// deleteHostNameBindingSlotCreateRequest creates the DeleteHostNameBindingSlot request.
func (client *AppsClient) deleteHostNameBindingSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *AppsClientDeleteHostNameBindingSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteHostSecret - Delete a host level secret.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// keyType - The type of host key.
// keyName - The name of the key.
// options - AppsClientDeleteHostSecretOptions contains the optional parameters for the AppsClient.DeleteHostSecret method.
func (client *AppsClient) DeleteHostSecret(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, options *AppsClientDeleteHostSecretOptions) (AppsClientDeleteHostSecretResponse, error) {
	req, err := client.deleteHostSecretCreateRequest(ctx, resourceGroupName, name, keyType, keyName, options)
	if err != nil {
		return AppsClientDeleteHostSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteHostSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteHostSecretResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteHostSecretResponse{}, nil
}

// deleteHostSecretCreateRequest creates the DeleteHostSecret request.
func (client *AppsClient) deleteHostSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, options *AppsClientDeleteHostSecretOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteHostSecretSlot - Delete a host level secret.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// keyType - The type of host key.
// keyName - The name of the key.
// slot - Name of the deployment slot.
// options - AppsClientDeleteHostSecretSlotOptions contains the optional parameters for the AppsClient.DeleteHostSecretSlot
// method.
func (client *AppsClient) DeleteHostSecretSlot(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, options *AppsClientDeleteHostSecretSlotOptions) (AppsClientDeleteHostSecretSlotResponse, error) {
	req, err := client.deleteHostSecretSlotCreateRequest(ctx, resourceGroupName, name, keyType, keyName, slot, options)
	if err != nil {
		return AppsClientDeleteHostSecretSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteHostSecretSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteHostSecretSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteHostSecretSlotResponse{}, nil
}

// deleteHostSecretSlotCreateRequest creates the DeleteHostSecretSlot request.
func (client *AppsClient) deleteHostSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, options *AppsClientDeleteHostSecretSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteHybridConnection - Removes a Hybrid Connection from this site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// namespaceName - The namespace for this hybrid connection.
// relayName - The relay name for this hybrid connection.
// options - AppsClientDeleteHybridConnectionOptions contains the optional parameters for the AppsClient.DeleteHybridConnection
// method.
func (client *AppsClient) DeleteHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppsClientDeleteHybridConnectionOptions) (AppsClientDeleteHybridConnectionResponse, error) {
	req, err := client.deleteHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
	if err != nil {
		return AppsClientDeleteHybridConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientDeleteHybridConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteHybridConnectionResponse{}, nil
}

// deleteHybridConnectionCreateRequest creates the DeleteHybridConnection request.
func (client *AppsClient) deleteHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppsClientDeleteHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteHybridConnectionSlot - Removes a Hybrid Connection from this site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// namespaceName - The namespace for this hybrid connection.
// relayName - The relay name for this hybrid connection.
// slot - The name of the slot for the web app.
// options - AppsClientDeleteHybridConnectionSlotOptions contains the optional parameters for the AppsClient.DeleteHybridConnectionSlot
// method.
func (client *AppsClient) DeleteHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *AppsClientDeleteHybridConnectionSlotOptions) (AppsClientDeleteHybridConnectionSlotResponse, error) {
	req, err := client.deleteHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, options)
	if err != nil {
		return AppsClientDeleteHybridConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteHybridConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientDeleteHybridConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteHybridConnectionSlotResponse{}, nil
}

// deleteHybridConnectionSlotCreateRequest creates the DeleteHybridConnectionSlot request.
func (client *AppsClient) deleteHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *AppsClientDeleteHybridConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteInstanceFunctionSlot - Delete a function for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - Function name.
// slot - Name of the deployment slot.
// options - AppsClientDeleteInstanceFunctionSlotOptions contains the optional parameters for the AppsClient.DeleteInstanceFunctionSlot
// method.
func (client *AppsClient) DeleteInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *AppsClientDeleteInstanceFunctionSlotOptions) (AppsClientDeleteInstanceFunctionSlotResponse, error) {
	req, err := client.deleteInstanceFunctionSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return AppsClientDeleteInstanceFunctionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteInstanceFunctionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteInstanceFunctionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteInstanceFunctionSlotResponse{}, nil
}

// deleteInstanceFunctionSlotCreateRequest creates the DeleteInstanceFunctionSlot request.
func (client *AppsClient) deleteInstanceFunctionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *AppsClientDeleteInstanceFunctionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteInstanceProcess - Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance
// in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientDeleteInstanceProcessOptions contains the optional parameters for the AppsClient.DeleteInstanceProcess
// method.
func (client *AppsClient) DeleteInstanceProcess(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *AppsClientDeleteInstanceProcessOptions) (AppsClientDeleteInstanceProcessResponse, error) {
	req, err := client.deleteInstanceProcessCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
	if err != nil {
		return AppsClientDeleteInstanceProcessResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteInstanceProcessResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteInstanceProcessResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteInstanceProcessResponse{}, nil
}

// deleteInstanceProcessCreateRequest creates the DeleteInstanceProcess request.
func (client *AppsClient) deleteInstanceProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *AppsClientDeleteInstanceProcessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteInstanceProcessSlot - Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out
// instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientDeleteInstanceProcessSlotOptions contains the optional parameters for the AppsClient.DeleteInstanceProcessSlot
// method.
func (client *AppsClient) DeleteInstanceProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *AppsClientDeleteInstanceProcessSlotOptions) (AppsClientDeleteInstanceProcessSlotResponse, error) {
	req, err := client.deleteInstanceProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
	if err != nil {
		return AppsClientDeleteInstanceProcessSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteInstanceProcessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteInstanceProcessSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteInstanceProcessSlotResponse{}, nil
}

// deleteInstanceProcessSlotCreateRequest creates the DeleteInstanceProcessSlot request.
func (client *AppsClient) deleteInstanceProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *AppsClientDeleteInstanceProcessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeletePremierAddOn - Delete a premier add-on from an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// premierAddOnName - Add-on name.
// options - AppsClientDeletePremierAddOnOptions contains the optional parameters for the AppsClient.DeletePremierAddOn method.
func (client *AppsClient) DeletePremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *AppsClientDeletePremierAddOnOptions) (AppsClientDeletePremierAddOnResponse, error) {
	req, err := client.deletePremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, options)
	if err != nil {
		return AppsClientDeletePremierAddOnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeletePremierAddOnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientDeletePremierAddOnResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeletePremierAddOnResponse{}, nil
}

// deletePremierAddOnCreateRequest creates the DeletePremierAddOn request.
func (client *AppsClient) deletePremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *AppsClientDeletePremierAddOnOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeletePremierAddOnSlot - Delete a premier add-on from an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// premierAddOnName - Add-on name.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete the named add-on for the production
// slot.
// options - AppsClientDeletePremierAddOnSlotOptions contains the optional parameters for the AppsClient.DeletePremierAddOnSlot
// method.
func (client *AppsClient) DeletePremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *AppsClientDeletePremierAddOnSlotOptions) (AppsClientDeletePremierAddOnSlotResponse, error) {
	req, err := client.deletePremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, options)
	if err != nil {
		return AppsClientDeletePremierAddOnSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeletePremierAddOnSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientDeletePremierAddOnSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeletePremierAddOnSlotResponse{}, nil
}

// deletePremierAddOnSlotCreateRequest creates the DeletePremierAddOnSlot request.
func (client *AppsClient) deletePremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *AppsClientDeletePremierAddOnSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteProcess - Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in
// a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// options - AppsClientDeleteProcessOptions contains the optional parameters for the AppsClient.DeleteProcess method.
func (client *AppsClient) DeleteProcess(ctx context.Context, resourceGroupName string, name string, processID string, options *AppsClientDeleteProcessOptions) (AppsClientDeleteProcessResponse, error) {
	req, err := client.deleteProcessCreateRequest(ctx, resourceGroupName, name, processID, options)
	if err != nil {
		return AppsClientDeleteProcessResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteProcessResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteProcessResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteProcessResponse{}, nil
}

// deleteProcessCreateRequest creates the DeleteProcess request.
func (client *AppsClient) deleteProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *AppsClientDeleteProcessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteProcessSlot - Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance
// in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// options - AppsClientDeleteProcessSlotOptions contains the optional parameters for the AppsClient.DeleteProcessSlot method.
func (client *AppsClient) DeleteProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *AppsClientDeleteProcessSlotOptions) (AppsClientDeleteProcessSlotResponse, error) {
	req, err := client.deleteProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
	if err != nil {
		return AppsClientDeleteProcessSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteProcessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteProcessSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteProcessSlotResponse{}, nil
}

// deleteProcessSlotCreateRequest creates the DeleteProcessSlot request.
func (client *AppsClient) deleteProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *AppsClientDeleteProcessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeletePublicCertificate - Deletes a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// publicCertificateName - Public certificate name.
// options - AppsClientDeletePublicCertificateOptions contains the optional parameters for the AppsClient.DeletePublicCertificate
// method.
func (client *AppsClient) DeletePublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *AppsClientDeletePublicCertificateOptions) (AppsClientDeletePublicCertificateResponse, error) {
	req, err := client.deletePublicCertificateCreateRequest(ctx, resourceGroupName, name, publicCertificateName, options)
	if err != nil {
		return AppsClientDeletePublicCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeletePublicCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientDeletePublicCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeletePublicCertificateResponse{}, nil
}

// deletePublicCertificateCreateRequest creates the DeletePublicCertificate request.
func (client *AppsClient) deletePublicCertificateCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *AppsClientDeletePublicCertificateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeletePublicCertificateSlot - Deletes a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
// publicCertificateName - Public certificate name.
// options - AppsClientDeletePublicCertificateSlotOptions contains the optional parameters for the AppsClient.DeletePublicCertificateSlot
// method.
func (client *AppsClient) DeletePublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *AppsClientDeletePublicCertificateSlotOptions) (AppsClientDeletePublicCertificateSlotResponse, error) {
	req, err := client.deletePublicCertificateSlotCreateRequest(ctx, resourceGroupName, name, slot, publicCertificateName, options)
	if err != nil {
		return AppsClientDeletePublicCertificateSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeletePublicCertificateSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientDeletePublicCertificateSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeletePublicCertificateSlotResponse{}, nil
}

// deletePublicCertificateSlotCreateRequest creates the DeletePublicCertificateSlot request.
func (client *AppsClient) deletePublicCertificateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *AppsClientDeletePublicCertificateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteRelayServiceConnection - Deletes a relay service connection by its name.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// entityName - Name of the hybrid connection configuration.
// options - AppsClientDeleteRelayServiceConnectionOptions contains the optional parameters for the AppsClient.DeleteRelayServiceConnection
// method.
func (client *AppsClient) DeleteRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, options *AppsClientDeleteRelayServiceConnectionOptions) (AppsClientDeleteRelayServiceConnectionResponse, error) {
	req, err := client.deleteRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, options)
	if err != nil {
		return AppsClientDeleteRelayServiceConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteRelayServiceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientDeleteRelayServiceConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteRelayServiceConnectionResponse{}, nil
}

// deleteRelayServiceConnectionCreateRequest creates the DeleteRelayServiceConnection request.
func (client *AppsClient) deleteRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, options *AppsClientDeleteRelayServiceConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteRelayServiceConnectionSlot - Deletes a relay service connection by its name.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// entityName - Name of the hybrid connection configuration.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete a hybrid connection for the production
// slot.
// options - AppsClientDeleteRelayServiceConnectionSlotOptions contains the optional parameters for the AppsClient.DeleteRelayServiceConnectionSlot
// method.
func (client *AppsClient) DeleteRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *AppsClientDeleteRelayServiceConnectionSlotOptions) (AppsClientDeleteRelayServiceConnectionSlotResponse, error) {
	req, err := client.deleteRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, options)
	if err != nil {
		return AppsClientDeleteRelayServiceConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteRelayServiceConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientDeleteRelayServiceConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteRelayServiceConnectionSlotResponse{}, nil
}

// deleteRelayServiceConnectionSlotCreateRequest creates the DeleteRelayServiceConnectionSlot request.
func (client *AppsClient) deleteRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *AppsClientDeleteRelayServiceConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteSiteExtension - Remove a site extension from a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// siteExtensionID - Site extension name.
// options - AppsClientDeleteSiteExtensionOptions contains the optional parameters for the AppsClient.DeleteSiteExtension
// method.
func (client *AppsClient) DeleteSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *AppsClientDeleteSiteExtensionOptions) (AppsClientDeleteSiteExtensionResponse, error) {
	req, err := client.deleteSiteExtensionCreateRequest(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return AppsClientDeleteSiteExtensionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteSiteExtensionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteSiteExtensionResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteSiteExtensionResponse{}, nil
}

// deleteSiteExtensionCreateRequest creates the DeleteSiteExtension request.
func (client *AppsClient) deleteSiteExtensionCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *AppsClientDeleteSiteExtensionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteSiteExtensionSlot - Remove a site extension from a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// siteExtensionID - Site extension name.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientDeleteSiteExtensionSlotOptions contains the optional parameters for the AppsClient.DeleteSiteExtensionSlot
// method.
func (client *AppsClient) DeleteSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *AppsClientDeleteSiteExtensionSlotOptions) (AppsClientDeleteSiteExtensionSlotResponse, error) {
	req, err := client.deleteSiteExtensionSlotCreateRequest(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return AppsClientDeleteSiteExtensionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteSiteExtensionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteSiteExtensionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteSiteExtensionSlotResponse{}, nil
}

// deleteSiteExtensionSlotCreateRequest creates the DeleteSiteExtensionSlot request.
func (client *AppsClient) deleteSiteExtensionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *AppsClientDeleteSiteExtensionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteSlot - Deletes a web, mobile, or API app, or one of the deployment slots.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app to delete.
// slot - Name of the deployment slot to delete. By default, the API deletes the production slot.
// options - AppsClientDeleteSlotOptions contains the optional parameters for the AppsClient.DeleteSlot method.
func (client *AppsClient) DeleteSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientDeleteSlotOptions) (AppsClientDeleteSlotResponse, error) {
	req, err := client.deleteSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientDeleteSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent, http.StatusNotFound) {
		return AppsClientDeleteSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteSlotResponse{}, nil
}

// deleteSlotCreateRequest creates the DeleteSlot request.
func (client *AppsClient) deleteSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientDeleteSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DeleteMetrics != nil {
		reqQP.Set("deleteMetrics", strconv.FormatBool(*options.DeleteMetrics))
	}
	if options != nil && options.DeleteEmptyServerFarm != nil {
		reqQP.Set("deleteEmptyServerFarm", strconv.FormatBool(*options.DeleteEmptyServerFarm))
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteSourceControl - Deletes the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientDeleteSourceControlOptions contains the optional parameters for the AppsClient.DeleteSourceControl
// method.
func (client *AppsClient) DeleteSourceControl(ctx context.Context, resourceGroupName string, name string, options *AppsClientDeleteSourceControlOptions) (AppsClientDeleteSourceControlResponse, error) {
	req, err := client.deleteSourceControlCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientDeleteSourceControlResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNotFound) {
		return AppsClientDeleteSourceControlResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteSourceControlResponse{}, nil
}

// deleteSourceControlCreateRequest creates the DeleteSourceControl request.
func (client *AppsClient) deleteSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientDeleteSourceControlOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteSourceControlSlot - Deletes the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete the source control configuration for
// the production slot.
// options - AppsClientDeleteSourceControlSlotOptions contains the optional parameters for the AppsClient.DeleteSourceControlSlot
// method.
func (client *AppsClient) DeleteSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientDeleteSourceControlSlotOptions) (AppsClientDeleteSourceControlSlotResponse, error) {
	req, err := client.deleteSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientDeleteSourceControlSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteSourceControlSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNotFound) {
		return AppsClientDeleteSourceControlSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteSourceControlSlotResponse{}, nil
}

// deleteSourceControlSlotCreateRequest creates the DeleteSourceControlSlot request.
func (client *AppsClient) deleteSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientDeleteSourceControlSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteSwiftVirtualNetwork - Deletes a Swift Virtual Network connection from an app (or deployment slot).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientDeleteSwiftVirtualNetworkOptions contains the optional parameters for the AppsClient.DeleteSwiftVirtualNetwork
// method.
func (client *AppsClient) DeleteSwiftVirtualNetwork(ctx context.Context, resourceGroupName string, name string, options *AppsClientDeleteSwiftVirtualNetworkOptions) (AppsClientDeleteSwiftVirtualNetworkResponse, error) {
	req, err := client.deleteSwiftVirtualNetworkCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientDeleteSwiftVirtualNetworkResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteSwiftVirtualNetworkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientDeleteSwiftVirtualNetworkResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteSwiftVirtualNetworkResponse{}, nil
}

// deleteSwiftVirtualNetworkCreateRequest creates the DeleteSwiftVirtualNetwork request.
func (client *AppsClient) deleteSwiftVirtualNetworkCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientDeleteSwiftVirtualNetworkOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteSwiftVirtualNetworkSlot - Deletes a Swift Virtual Network connection from an app (or deployment slot).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete the connection for the production slot.
// options - AppsClientDeleteSwiftVirtualNetworkSlotOptions contains the optional parameters for the AppsClient.DeleteSwiftVirtualNetworkSlot
// method.
func (client *AppsClient) DeleteSwiftVirtualNetworkSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientDeleteSwiftVirtualNetworkSlotOptions) (AppsClientDeleteSwiftVirtualNetworkSlotResponse, error) {
	req, err := client.deleteSwiftVirtualNetworkSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientDeleteSwiftVirtualNetworkSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteSwiftVirtualNetworkSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientDeleteSwiftVirtualNetworkSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteSwiftVirtualNetworkSlotResponse{}, nil
}

// deleteSwiftVirtualNetworkSlotCreateRequest creates the DeleteSwiftVirtualNetworkSlot request.
func (client *AppsClient) deleteSwiftVirtualNetworkSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientDeleteSwiftVirtualNetworkSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteTriggeredWebJob - Delete a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// options - AppsClientDeleteTriggeredWebJobOptions contains the optional parameters for the AppsClient.DeleteTriggeredWebJob
// method.
func (client *AppsClient) DeleteTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientDeleteTriggeredWebJobOptions) (AppsClientDeleteTriggeredWebJobResponse, error) {
	req, err := client.deleteTriggeredWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return AppsClientDeleteTriggeredWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteTriggeredWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientDeleteTriggeredWebJobResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteTriggeredWebJobResponse{}, nil
}

// deleteTriggeredWebJobCreateRequest creates the DeleteTriggeredWebJob request.
func (client *AppsClient) deleteTriggeredWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientDeleteTriggeredWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteTriggeredWebJobSlot - Delete a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientDeleteTriggeredWebJobSlotOptions contains the optional parameters for the AppsClient.DeleteTriggeredWebJobSlot
// method.
func (client *AppsClient) DeleteTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientDeleteTriggeredWebJobSlotOptions) (AppsClientDeleteTriggeredWebJobSlotResponse, error) {
	req, err := client.deleteTriggeredWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return AppsClientDeleteTriggeredWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteTriggeredWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientDeleteTriggeredWebJobSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteTriggeredWebJobSlotResponse{}, nil
}

// deleteTriggeredWebJobSlotCreateRequest creates the DeleteTriggeredWebJobSlot request.
func (client *AppsClient) deleteTriggeredWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientDeleteTriggeredWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteVnetConnection - Deletes a connection from an app (or deployment slot to a named virtual network.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of the virtual network.
// options - AppsClientDeleteVnetConnectionOptions contains the optional parameters for the AppsClient.DeleteVnetConnection
// method.
func (client *AppsClient) DeleteVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, options *AppsClientDeleteVnetConnectionOptions) (AppsClientDeleteVnetConnectionResponse, error) {
	req, err := client.deleteVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, options)
	if err != nil {
		return AppsClientDeleteVnetConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteVnetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientDeleteVnetConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteVnetConnectionResponse{}, nil
}

// deleteVnetConnectionCreateRequest creates the DeleteVnetConnection request.
func (client *AppsClient) deleteVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, options *AppsClientDeleteVnetConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteVnetConnectionSlot - Deletes a connection from an app (or deployment slot to a named virtual network.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of the virtual network.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete the connection for the production slot.
// options - AppsClientDeleteVnetConnectionSlotOptions contains the optional parameters for the AppsClient.DeleteVnetConnectionSlot
// method.
func (client *AppsClient) DeleteVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *AppsClientDeleteVnetConnectionSlotOptions) (AppsClientDeleteVnetConnectionSlotResponse, error) {
	req, err := client.deleteVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, options)
	if err != nil {
		return AppsClientDeleteVnetConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDeleteVnetConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientDeleteVnetConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientDeleteVnetConnectionSlotResponse{}, nil
}

// deleteVnetConnectionSlotCreateRequest creates the DeleteVnetConnectionSlot request.
func (client *AppsClient) deleteVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *AppsClientDeleteVnetConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DiscoverBackup - Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to get information
// about the databases stored in a backup.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// request - A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
// options - AppsClientDiscoverBackupOptions contains the optional parameters for the AppsClient.DiscoverBackup method.
func (client *AppsClient) DiscoverBackup(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *AppsClientDiscoverBackupOptions) (AppsClientDiscoverBackupResponse, error) {
	req, err := client.discoverBackupCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return AppsClientDiscoverBackupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDiscoverBackupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientDiscoverBackupResponse{}, runtime.NewResponseError(resp)
	}
	return client.discoverBackupHandleResponse(resp)
}

// discoverBackupCreateRequest creates the DiscoverBackup request.
func (client *AppsClient) discoverBackupCreateRequest(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *AppsClientDiscoverBackupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/discoverbackup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, request)
}

// discoverBackupHandleResponse handles the DiscoverBackup response.
func (client *AppsClient) discoverBackupHandleResponse(resp *http.Response) (AppsClientDiscoverBackupResponse, error) {
	result := AppsClientDiscoverBackupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RestoreRequest); err != nil {
		return AppsClientDiscoverBackupResponse{}, err
	}
	return result, nil
}

// DiscoverBackupSlot - Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to get
// information about the databases stored in a backup.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will perform discovery for the production slot.
// request - A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
// options - AppsClientDiscoverBackupSlotOptions contains the optional parameters for the AppsClient.DiscoverBackupSlot method.
func (client *AppsClient) DiscoverBackupSlot(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *AppsClientDiscoverBackupSlotOptions) (AppsClientDiscoverBackupSlotResponse, error) {
	req, err := client.discoverBackupSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return AppsClientDiscoverBackupSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientDiscoverBackupSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientDiscoverBackupSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.discoverBackupSlotHandleResponse(resp)
}

// discoverBackupSlotCreateRequest creates the DiscoverBackupSlot request.
func (client *AppsClient) discoverBackupSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *AppsClientDiscoverBackupSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/discoverbackup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, request)
}

// discoverBackupSlotHandleResponse handles the DiscoverBackupSlot response.
func (client *AppsClient) discoverBackupSlotHandleResponse(resp *http.Response) (AppsClientDiscoverBackupSlotResponse, error) {
	result := AppsClientDiscoverBackupSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RestoreRequest); err != nil {
		return AppsClientDiscoverBackupSlotResponse{}, err
	}
	return result, nil
}

// GenerateNewSitePublishingPassword - Generates a new publishing password for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientGenerateNewSitePublishingPasswordOptions contains the optional parameters for the AppsClient.GenerateNewSitePublishingPassword
// method.
func (client *AppsClient) GenerateNewSitePublishingPassword(ctx context.Context, resourceGroupName string, name string, options *AppsClientGenerateNewSitePublishingPasswordOptions) (AppsClientGenerateNewSitePublishingPasswordResponse, error) {
	req, err := client.generateNewSitePublishingPasswordCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGenerateNewSitePublishingPasswordResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGenerateNewSitePublishingPasswordResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientGenerateNewSitePublishingPasswordResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientGenerateNewSitePublishingPasswordResponse{}, nil
}

// generateNewSitePublishingPasswordCreateRequest creates the GenerateNewSitePublishingPassword request.
func (client *AppsClient) generateNewSitePublishingPasswordCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGenerateNewSitePublishingPasswordOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// GenerateNewSitePublishingPasswordSlot - Generates a new publishing password for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API generate a new publishing password for the production
// slot.
// options - AppsClientGenerateNewSitePublishingPasswordSlotOptions contains the optional parameters for the AppsClient.GenerateNewSitePublishingPasswordSlot
// method.
func (client *AppsClient) GenerateNewSitePublishingPasswordSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGenerateNewSitePublishingPasswordSlotOptions) (AppsClientGenerateNewSitePublishingPasswordSlotResponse, error) {
	req, err := client.generateNewSitePublishingPasswordSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGenerateNewSitePublishingPasswordSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGenerateNewSitePublishingPasswordSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientGenerateNewSitePublishingPasswordSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientGenerateNewSitePublishingPasswordSlotResponse{}, nil
}

// generateNewSitePublishingPasswordSlotCreateRequest creates the GenerateNewSitePublishingPasswordSlot request.
func (client *AppsClient) generateNewSitePublishingPasswordSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGenerateNewSitePublishingPasswordSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// Get - Gets the details of a web, mobile, or API app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientGetOptions contains the optional parameters for the AppsClient.Get method.
func (client *AppsClient) Get(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetOptions) (AppsClientGetResponse, error) {
	req, err := client.getCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.getHandleResponse(resp)
}

// getCreateRequest creates the Get request.
func (client *AppsClient) getCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *AppsClient) getHandleResponse(resp *http.Response) (AppsClientGetResponse, error) {
	result := AppsClientGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Site); err != nil {
		return AppsClientGetResponse{}, err
	}
	return result, nil
}

// GetAuthSettings - Gets the Authentication/Authorization settings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientGetAuthSettingsOptions contains the optional parameters for the AppsClient.GetAuthSettings method.
func (client *AppsClient) GetAuthSettings(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetAuthSettingsOptions) (AppsClientGetAuthSettingsResponse, error) {
	req, err := client.getAuthSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetAuthSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetAuthSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetAuthSettingsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAuthSettingsHandleResponse(resp)
}

// getAuthSettingsCreateRequest creates the GetAuthSettings request.
func (client *AppsClient) getAuthSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetAuthSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAuthSettingsHandleResponse handles the GetAuthSettings response.
func (client *AppsClient) getAuthSettingsHandleResponse(resp *http.Response) (AppsClientGetAuthSettingsResponse, error) {
	result := AppsClientGetAuthSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettings); err != nil {
		return AppsClientGetAuthSettingsResponse{}, err
	}
	return result, nil
}

// GetAuthSettingsSlot - Gets the Authentication/Authorization settings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get the settings for the production slot.
// options - AppsClientGetAuthSettingsSlotOptions contains the optional parameters for the AppsClient.GetAuthSettingsSlot
// method.
func (client *AppsClient) GetAuthSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetAuthSettingsSlotOptions) (AppsClientGetAuthSettingsSlotResponse, error) {
	req, err := client.getAuthSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetAuthSettingsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetAuthSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetAuthSettingsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAuthSettingsSlotHandleResponse(resp)
}

// getAuthSettingsSlotCreateRequest creates the GetAuthSettingsSlot request.
func (client *AppsClient) getAuthSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetAuthSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAuthSettingsSlotHandleResponse handles the GetAuthSettingsSlot response.
func (client *AppsClient) getAuthSettingsSlotHandleResponse(resp *http.Response) (AppsClientGetAuthSettingsSlotResponse, error) {
	result := AppsClientGetAuthSettingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettings); err != nil {
		return AppsClientGetAuthSettingsSlotResponse{}, err
	}
	return result, nil
}

// GetBackupConfiguration - Gets the backup configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientGetBackupConfigurationOptions contains the optional parameters for the AppsClient.GetBackupConfiguration
// method.
func (client *AppsClient) GetBackupConfiguration(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetBackupConfigurationOptions) (AppsClientGetBackupConfigurationResponse, error) {
	req, err := client.getBackupConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetBackupConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetBackupConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetBackupConfigurationResponse{}, runtime.NewResponseError(resp)
	}
	return client.getBackupConfigurationHandleResponse(resp)
}

// getBackupConfigurationCreateRequest creates the GetBackupConfiguration request.
func (client *AppsClient) getBackupConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetBackupConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getBackupConfigurationHandleResponse handles the GetBackupConfiguration response.
func (client *AppsClient) getBackupConfigurationHandleResponse(resp *http.Response) (AppsClientGetBackupConfigurationResponse, error) {
	result := AppsClientGetBackupConfigurationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupRequest); err != nil {
		return AppsClientGetBackupConfigurationResponse{}, err
	}
	return result, nil
}

// GetBackupConfigurationSlot - Gets the backup configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get the backup configuration for the production
// slot.
// options - AppsClientGetBackupConfigurationSlotOptions contains the optional parameters for the AppsClient.GetBackupConfigurationSlot
// method.
func (client *AppsClient) GetBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetBackupConfigurationSlotOptions) (AppsClientGetBackupConfigurationSlotResponse, error) {
	req, err := client.getBackupConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetBackupConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetBackupConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetBackupConfigurationSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getBackupConfigurationSlotHandleResponse(resp)
}

// getBackupConfigurationSlotCreateRequest creates the GetBackupConfigurationSlot request.
func (client *AppsClient) getBackupConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetBackupConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getBackupConfigurationSlotHandleResponse handles the GetBackupConfigurationSlot response.
func (client *AppsClient) getBackupConfigurationSlotHandleResponse(resp *http.Response) (AppsClientGetBackupConfigurationSlotResponse, error) {
	result := AppsClientGetBackupConfigurationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupRequest); err != nil {
		return AppsClientGetBackupConfigurationSlotResponse{}, err
	}
	return result, nil
}

// GetBackupStatus - Gets a backup of an app by its ID.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// backupID - ID of the backup.
// options - AppsClientGetBackupStatusOptions contains the optional parameters for the AppsClient.GetBackupStatus method.
func (client *AppsClient) GetBackupStatus(ctx context.Context, resourceGroupName string, name string, backupID string, options *AppsClientGetBackupStatusOptions) (AppsClientGetBackupStatusResponse, error) {
	req, err := client.getBackupStatusCreateRequest(ctx, resourceGroupName, name, backupID, options)
	if err != nil {
		return AppsClientGetBackupStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetBackupStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetBackupStatusResponse{}, runtime.NewResponseError(resp)
	}
	return client.getBackupStatusHandleResponse(resp)
}

// getBackupStatusCreateRequest creates the GetBackupStatus request.
func (client *AppsClient) getBackupStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, options *AppsClientGetBackupStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getBackupStatusHandleResponse handles the GetBackupStatus response.
func (client *AppsClient) getBackupStatusHandleResponse(resp *http.Response) (AppsClientGetBackupStatusResponse, error) {
	result := AppsClientGetBackupStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return AppsClientGetBackupStatusResponse{}, err
	}
	return result, nil
}

// GetBackupStatusSlot - Gets a backup of an app by its ID.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// backupID - ID of the backup.
// slot - Name of the deployment slot. If a slot is not specified, the API will get a backup of the production slot.
// options - AppsClientGetBackupStatusSlotOptions contains the optional parameters for the AppsClient.GetBackupStatusSlot
// method.
func (client *AppsClient) GetBackupStatusSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *AppsClientGetBackupStatusSlotOptions) (AppsClientGetBackupStatusSlotResponse, error) {
	req, err := client.getBackupStatusSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, options)
	if err != nil {
		return AppsClientGetBackupStatusSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetBackupStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetBackupStatusSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getBackupStatusSlotHandleResponse(resp)
}

// getBackupStatusSlotCreateRequest creates the GetBackupStatusSlot request.
func (client *AppsClient) getBackupStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *AppsClientGetBackupStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getBackupStatusSlotHandleResponse handles the GetBackupStatusSlot response.
func (client *AppsClient) getBackupStatusSlotHandleResponse(resp *http.Response) (AppsClientGetBackupStatusSlotResponse, error) {
	result := AppsClientGetBackupStatusSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return AppsClientGetBackupStatusSlotResponse{}, err
	}
	return result, nil
}

// GetConfiguration - Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications,
// Always On, etc.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientGetConfigurationOptions contains the optional parameters for the AppsClient.GetConfiguration method.
func (client *AppsClient) GetConfiguration(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetConfigurationOptions) (AppsClientGetConfigurationResponse, error) {
	req, err := client.getConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetConfigurationResponse{}, runtime.NewResponseError(resp)
	}
	return client.getConfigurationHandleResponse(resp)
}

// getConfigurationCreateRequest creates the GetConfiguration request.
func (client *AppsClient) getConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getConfigurationHandleResponse handles the GetConfiguration response.
func (client *AppsClient) getConfigurationHandleResponse(resp *http.Response) (AppsClientGetConfigurationResponse, error) {
	result := AppsClientGetConfigurationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return AppsClientGetConfigurationResponse{}, err
	}
	return result, nil
}

// GetConfigurationSlot - Gets the configuration of an app, such as platform version and bitness, default documents, virtual
// applications, Always On, etc.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
// options - AppsClientGetConfigurationSlotOptions contains the optional parameters for the AppsClient.GetConfigurationSlot
// method.
func (client *AppsClient) GetConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetConfigurationSlotOptions) (AppsClientGetConfigurationSlotResponse, error) {
	req, err := client.getConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetConfigurationSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getConfigurationSlotHandleResponse(resp)
}

// getConfigurationSlotCreateRequest creates the GetConfigurationSlot request.
func (client *AppsClient) getConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getConfigurationSlotHandleResponse handles the GetConfigurationSlot response.
func (client *AppsClient) getConfigurationSlotHandleResponse(resp *http.Response) (AppsClientGetConfigurationSlotResponse, error) {
	result := AppsClientGetConfigurationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return AppsClientGetConfigurationSlotResponse{}, err
	}
	return result, nil
}

// GetConfigurationSnapshot - Gets a snapshot of the configuration of an app at a previous point in time.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// snapshotID - The ID of the snapshot to read.
// options - AppsClientGetConfigurationSnapshotOptions contains the optional parameters for the AppsClient.GetConfigurationSnapshot
// method.
func (client *AppsClient) GetConfigurationSnapshot(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *AppsClientGetConfigurationSnapshotOptions) (AppsClientGetConfigurationSnapshotResponse, error) {
	req, err := client.getConfigurationSnapshotCreateRequest(ctx, resourceGroupName, name, snapshotID, options)
	if err != nil {
		return AppsClientGetConfigurationSnapshotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetConfigurationSnapshotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetConfigurationSnapshotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getConfigurationSnapshotHandleResponse(resp)
}

// getConfigurationSnapshotCreateRequest creates the GetConfigurationSnapshot request.
func (client *AppsClient) getConfigurationSnapshotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *AppsClientGetConfigurationSnapshotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getConfigurationSnapshotHandleResponse handles the GetConfigurationSnapshot response.
func (client *AppsClient) getConfigurationSnapshotHandleResponse(resp *http.Response) (AppsClientGetConfigurationSnapshotResponse, error) {
	result := AppsClientGetConfigurationSnapshotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return AppsClientGetConfigurationSnapshotResponse{}, err
	}
	return result, nil
}

// GetConfigurationSnapshotSlot - Gets a snapshot of the configuration of an app at a previous point in time.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// snapshotID - The ID of the snapshot to read.
// slot - Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
// options - AppsClientGetConfigurationSnapshotSlotOptions contains the optional parameters for the AppsClient.GetConfigurationSnapshotSlot
// method.
func (client *AppsClient) GetConfigurationSnapshotSlot(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *AppsClientGetConfigurationSnapshotSlotOptions) (AppsClientGetConfigurationSnapshotSlotResponse, error) {
	req, err := client.getConfigurationSnapshotSlotCreateRequest(ctx, resourceGroupName, name, snapshotID, slot, options)
	if err != nil {
		return AppsClientGetConfigurationSnapshotSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetConfigurationSnapshotSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetConfigurationSnapshotSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getConfigurationSnapshotSlotHandleResponse(resp)
}

// getConfigurationSnapshotSlotCreateRequest creates the GetConfigurationSnapshotSlot request.
func (client *AppsClient) getConfigurationSnapshotSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *AppsClientGetConfigurationSnapshotSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getConfigurationSnapshotSlotHandleResponse handles the GetConfigurationSnapshotSlot response.
func (client *AppsClient) getConfigurationSnapshotSlotHandleResponse(resp *http.Response) (AppsClientGetConfigurationSnapshotSlotResponse, error) {
	result := AppsClientGetConfigurationSnapshotSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return AppsClientGetConfigurationSnapshotSlotResponse{}, err
	}
	return result, nil
}

// GetContainerLogsZip - Gets the ZIP archived docker log files for the given site
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// options - AppsClientGetContainerLogsZipOptions contains the optional parameters for the AppsClient.GetContainerLogsZip
// method.
func (client *AppsClient) GetContainerLogsZip(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetContainerLogsZipOptions) (AppsClientGetContainerLogsZipResponse, error) {
	req, err := client.getContainerLogsZipCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetContainerLogsZipResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetContainerLogsZipResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientGetContainerLogsZipResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientGetContainerLogsZipResponse{Body: resp.Body}, nil
}

// getContainerLogsZipCreateRequest creates the GetContainerLogsZip request.
func (client *AppsClient) getContainerLogsZipCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetContainerLogsZipOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs/zip/download"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/zip"}
	return req, nil
}

// GetContainerLogsZipSlot - Gets the ZIP archived docker log files for the given site
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// options - AppsClientGetContainerLogsZipSlotOptions contains the optional parameters for the AppsClient.GetContainerLogsZipSlot
// method.
func (client *AppsClient) GetContainerLogsZipSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetContainerLogsZipSlotOptions) (AppsClientGetContainerLogsZipSlotResponse, error) {
	req, err := client.getContainerLogsZipSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetContainerLogsZipSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetContainerLogsZipSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientGetContainerLogsZipSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientGetContainerLogsZipSlotResponse{Body: resp.Body}, nil
}

// getContainerLogsZipSlotCreateRequest creates the GetContainerLogsZipSlot request.
func (client *AppsClient) getContainerLogsZipSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetContainerLogsZipSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs/zip/download"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/zip"}
	return req, nil
}

// GetContinuousWebJob - Gets a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// options - AppsClientGetContinuousWebJobOptions contains the optional parameters for the AppsClient.GetContinuousWebJob
// method.
func (client *AppsClient) GetContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientGetContinuousWebJobOptions) (AppsClientGetContinuousWebJobResponse, error) {
	req, err := client.getContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return AppsClientGetContinuousWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetContinuousWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetContinuousWebJobResponse{}, runtime.NewResponseError(resp)
	}
	return client.getContinuousWebJobHandleResponse(resp)
}

// getContinuousWebJobCreateRequest creates the GetContinuousWebJob request.
func (client *AppsClient) getContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientGetContinuousWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getContinuousWebJobHandleResponse handles the GetContinuousWebJob response.
func (client *AppsClient) getContinuousWebJobHandleResponse(resp *http.Response) (AppsClientGetContinuousWebJobResponse, error) {
	result := AppsClientGetContinuousWebJobResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContinuousWebJob); err != nil {
		return AppsClientGetContinuousWebJobResponse{}, err
	}
	return result, nil
}

// GetContinuousWebJobSlot - Gets a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientGetContinuousWebJobSlotOptions contains the optional parameters for the AppsClient.GetContinuousWebJobSlot
// method.
func (client *AppsClient) GetContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientGetContinuousWebJobSlotOptions) (AppsClientGetContinuousWebJobSlotResponse, error) {
	req, err := client.getContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return AppsClientGetContinuousWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetContinuousWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetContinuousWebJobSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getContinuousWebJobSlotHandleResponse(resp)
}

// getContinuousWebJobSlotCreateRequest creates the GetContinuousWebJobSlot request.
func (client *AppsClient) getContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientGetContinuousWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getContinuousWebJobSlotHandleResponse handles the GetContinuousWebJobSlot response.
func (client *AppsClient) getContinuousWebJobSlotHandleResponse(resp *http.Response) (AppsClientGetContinuousWebJobSlotResponse, error) {
	result := AppsClientGetContinuousWebJobSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContinuousWebJob); err != nil {
		return AppsClientGetContinuousWebJobSlotResponse{}, err
	}
	return result, nil
}

// GetDeployment - Get a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// id - Deployment ID.
// options - AppsClientGetDeploymentOptions contains the optional parameters for the AppsClient.GetDeployment method.
func (client *AppsClient) GetDeployment(ctx context.Context, resourceGroupName string, name string, id string, options *AppsClientGetDeploymentOptions) (AppsClientGetDeploymentResponse, error) {
	req, err := client.getDeploymentCreateRequest(ctx, resourceGroupName, name, id, options)
	if err != nil {
		return AppsClientGetDeploymentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetDeploymentResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDeploymentHandleResponse(resp)
}

// getDeploymentCreateRequest creates the GetDeployment request.
func (client *AppsClient) getDeploymentCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, options *AppsClientGetDeploymentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeploymentHandleResponse handles the GetDeployment response.
func (client *AppsClient) getDeploymentHandleResponse(resp *http.Response) (AppsClientGetDeploymentResponse, error) {
	result := AppsClientGetDeploymentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return AppsClientGetDeploymentResponse{}, err
	}
	return result, nil
}

// GetDeploymentSlot - Get a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// id - Deployment ID.
// slot - Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
// options - AppsClientGetDeploymentSlotOptions contains the optional parameters for the AppsClient.GetDeploymentSlot method.
func (client *AppsClient) GetDeploymentSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *AppsClientGetDeploymentSlotOptions) (AppsClientGetDeploymentSlotResponse, error) {
	req, err := client.getDeploymentSlotCreateRequest(ctx, resourceGroupName, name, id, slot, options)
	if err != nil {
		return AppsClientGetDeploymentSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetDeploymentSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetDeploymentSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDeploymentSlotHandleResponse(resp)
}

// getDeploymentSlotCreateRequest creates the GetDeploymentSlot request.
func (client *AppsClient) getDeploymentSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *AppsClientGetDeploymentSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeploymentSlotHandleResponse handles the GetDeploymentSlot response.
func (client *AppsClient) getDeploymentSlotHandleResponse(resp *http.Response) (AppsClientGetDeploymentSlotResponse, error) {
	result := AppsClientGetDeploymentSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return AppsClientGetDeploymentSlotResponse{}, err
	}
	return result, nil
}

// GetDiagnosticLogsConfiguration - Gets the logging configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientGetDiagnosticLogsConfigurationOptions contains the optional parameters for the AppsClient.GetDiagnosticLogsConfiguration
// method.
func (client *AppsClient) GetDiagnosticLogsConfiguration(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetDiagnosticLogsConfigurationOptions) (AppsClientGetDiagnosticLogsConfigurationResponse, error) {
	req, err := client.getDiagnosticLogsConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetDiagnosticLogsConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetDiagnosticLogsConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetDiagnosticLogsConfigurationResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDiagnosticLogsConfigurationHandleResponse(resp)
}

// getDiagnosticLogsConfigurationCreateRequest creates the GetDiagnosticLogsConfiguration request.
func (client *AppsClient) getDiagnosticLogsConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetDiagnosticLogsConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDiagnosticLogsConfigurationHandleResponse handles the GetDiagnosticLogsConfiguration response.
func (client *AppsClient) getDiagnosticLogsConfigurationHandleResponse(resp *http.Response) (AppsClientGetDiagnosticLogsConfigurationResponse, error) {
	result := AppsClientGetDiagnosticLogsConfigurationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteLogsConfig); err != nil {
		return AppsClientGetDiagnosticLogsConfigurationResponse{}, err
	}
	return result, nil
}

// GetDiagnosticLogsConfigurationSlot - Gets the logging configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get the logging configuration for the production
// slot.
// options - AppsClientGetDiagnosticLogsConfigurationSlotOptions contains the optional parameters for the AppsClient.GetDiagnosticLogsConfigurationSlot
// method.
func (client *AppsClient) GetDiagnosticLogsConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetDiagnosticLogsConfigurationSlotOptions) (AppsClientGetDiagnosticLogsConfigurationSlotResponse, error) {
	req, err := client.getDiagnosticLogsConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetDiagnosticLogsConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetDiagnosticLogsConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetDiagnosticLogsConfigurationSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDiagnosticLogsConfigurationSlotHandleResponse(resp)
}

// getDiagnosticLogsConfigurationSlotCreateRequest creates the GetDiagnosticLogsConfigurationSlot request.
func (client *AppsClient) getDiagnosticLogsConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetDiagnosticLogsConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDiagnosticLogsConfigurationSlotHandleResponse handles the GetDiagnosticLogsConfigurationSlot response.
func (client *AppsClient) getDiagnosticLogsConfigurationSlotHandleResponse(resp *http.Response) (AppsClientGetDiagnosticLogsConfigurationSlotResponse, error) {
	result := AppsClientGetDiagnosticLogsConfigurationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteLogsConfig); err != nil {
		return AppsClientGetDiagnosticLogsConfigurationSlotResponse{}, err
	}
	return result, nil
}

// GetDomainOwnershipIdentifier - Get domain ownership identifier for web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// domainOwnershipIdentifierName - Name of domain ownership identifier.
// options - AppsClientGetDomainOwnershipIdentifierOptions contains the optional parameters for the AppsClient.GetDomainOwnershipIdentifier
// method.
func (client *AppsClient) GetDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *AppsClientGetDomainOwnershipIdentifierOptions) (AppsClientGetDomainOwnershipIdentifierResponse, error) {
	req, err := client.getDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, options)
	if err != nil {
		return AppsClientGetDomainOwnershipIdentifierResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetDomainOwnershipIdentifierResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetDomainOwnershipIdentifierResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDomainOwnershipIdentifierHandleResponse(resp)
}

// getDomainOwnershipIdentifierCreateRequest creates the GetDomainOwnershipIdentifier request.
func (client *AppsClient) getDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *AppsClientGetDomainOwnershipIdentifierOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDomainOwnershipIdentifierHandleResponse handles the GetDomainOwnershipIdentifier response.
func (client *AppsClient) getDomainOwnershipIdentifierHandleResponse(resp *http.Response) (AppsClientGetDomainOwnershipIdentifierResponse, error) {
	result := AppsClientGetDomainOwnershipIdentifierResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return AppsClientGetDomainOwnershipIdentifierResponse{}, err
	}
	return result, nil
}

// GetDomainOwnershipIdentifierSlot - Get domain ownership identifier for web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// domainOwnershipIdentifierName - Name of domain ownership identifier.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
// options - AppsClientGetDomainOwnershipIdentifierSlotOptions contains the optional parameters for the AppsClient.GetDomainOwnershipIdentifierSlot
// method.
func (client *AppsClient) GetDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *AppsClientGetDomainOwnershipIdentifierSlotOptions) (AppsClientGetDomainOwnershipIdentifierSlotResponse, error) {
	req, err := client.getDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, options)
	if err != nil {
		return AppsClientGetDomainOwnershipIdentifierSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetDomainOwnershipIdentifierSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetDomainOwnershipIdentifierSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDomainOwnershipIdentifierSlotHandleResponse(resp)
}

// getDomainOwnershipIdentifierSlotCreateRequest creates the GetDomainOwnershipIdentifierSlot request.
func (client *AppsClient) getDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *AppsClientGetDomainOwnershipIdentifierSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDomainOwnershipIdentifierSlotHandleResponse handles the GetDomainOwnershipIdentifierSlot response.
func (client *AppsClient) getDomainOwnershipIdentifierSlotHandleResponse(resp *http.Response) (AppsClientGetDomainOwnershipIdentifierSlotResponse, error) {
	result := AppsClientGetDomainOwnershipIdentifierSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return AppsClientGetDomainOwnershipIdentifierSlotResponse{}, err
	}
	return result, nil
}

// GetFunction - Get function information by its ID for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - Function name.
// options - AppsClientGetFunctionOptions contains the optional parameters for the AppsClient.GetFunction method.
func (client *AppsClient) GetFunction(ctx context.Context, resourceGroupName string, name string, functionName string, options *AppsClientGetFunctionOptions) (AppsClientGetFunctionResponse, error) {
	req, err := client.getFunctionCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return AppsClientGetFunctionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetFunctionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetFunctionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getFunctionHandleResponse(resp)
}

// getFunctionCreateRequest creates the GetFunction request.
func (client *AppsClient) getFunctionCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *AppsClientGetFunctionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFunctionHandleResponse handles the GetFunction response.
func (client *AppsClient) getFunctionHandleResponse(resp *http.Response) (AppsClientGetFunctionResponse, error) {
	result := AppsClientGetFunctionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionEnvelope); err != nil {
		return AppsClientGetFunctionResponse{}, err
	}
	return result, nil
}

// GetFunctionsAdminToken - Fetch a short lived token that can be exchanged for a master key.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// options - AppsClientGetFunctionsAdminTokenOptions contains the optional parameters for the AppsClient.GetFunctionsAdminToken
// method.
func (client *AppsClient) GetFunctionsAdminToken(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetFunctionsAdminTokenOptions) (AppsClientGetFunctionsAdminTokenResponse, error) {
	req, err := client.getFunctionsAdminTokenCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetFunctionsAdminTokenResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetFunctionsAdminTokenResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetFunctionsAdminTokenResponse{}, runtime.NewResponseError(resp)
	}
	return client.getFunctionsAdminTokenHandleResponse(resp)
}

// getFunctionsAdminTokenCreateRequest creates the GetFunctionsAdminToken request.
func (client *AppsClient) getFunctionsAdminTokenCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetFunctionsAdminTokenOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/admin/token"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFunctionsAdminTokenHandleResponse handles the GetFunctionsAdminToken response.
func (client *AppsClient) getFunctionsAdminTokenHandleResponse(resp *http.Response) (AppsClientGetFunctionsAdminTokenResponse, error) {
	result := AppsClientGetFunctionsAdminTokenResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return AppsClientGetFunctionsAdminTokenResponse{}, err
	}
	return result, nil
}

// GetFunctionsAdminTokenSlot - Fetch a short lived token that can be exchanged for a master key.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// options - AppsClientGetFunctionsAdminTokenSlotOptions contains the optional parameters for the AppsClient.GetFunctionsAdminTokenSlot
// method.
func (client *AppsClient) GetFunctionsAdminTokenSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetFunctionsAdminTokenSlotOptions) (AppsClientGetFunctionsAdminTokenSlotResponse, error) {
	req, err := client.getFunctionsAdminTokenSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetFunctionsAdminTokenSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetFunctionsAdminTokenSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetFunctionsAdminTokenSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getFunctionsAdminTokenSlotHandleResponse(resp)
}

// getFunctionsAdminTokenSlotCreateRequest creates the GetFunctionsAdminTokenSlot request.
func (client *AppsClient) getFunctionsAdminTokenSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetFunctionsAdminTokenSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/admin/token"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFunctionsAdminTokenSlotHandleResponse handles the GetFunctionsAdminTokenSlot response.
func (client *AppsClient) getFunctionsAdminTokenSlotHandleResponse(resp *http.Response) (AppsClientGetFunctionsAdminTokenSlotResponse, error) {
	result := AppsClientGetFunctionsAdminTokenSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return AppsClientGetFunctionsAdminTokenSlotResponse{}, err
	}
	return result, nil
}

// GetHostNameBinding - Get the named hostname binding for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// hostName - Hostname in the hostname binding.
// options - AppsClientGetHostNameBindingOptions contains the optional parameters for the AppsClient.GetHostNameBinding method.
func (client *AppsClient) GetHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, options *AppsClientGetHostNameBindingOptions) (AppsClientGetHostNameBindingResponse, error) {
	req, err := client.getHostNameBindingCreateRequest(ctx, resourceGroupName, name, hostName, options)
	if err != nil {
		return AppsClientGetHostNameBindingResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetHostNameBindingResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetHostNameBindingResponse{}, runtime.NewResponseError(resp)
	}
	return client.getHostNameBindingHandleResponse(resp)
}

// getHostNameBindingCreateRequest creates the GetHostNameBinding request.
func (client *AppsClient) getHostNameBindingCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, options *AppsClientGetHostNameBindingOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHostNameBindingHandleResponse handles the GetHostNameBinding response.
func (client *AppsClient) getHostNameBindingHandleResponse(resp *http.Response) (AppsClientGetHostNameBindingResponse, error) {
	result := AppsClientGetHostNameBindingResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBinding); err != nil {
		return AppsClientGetHostNameBindingResponse{}, err
	}
	return result, nil
}

// GetHostNameBindingSlot - Get the named hostname binding for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
// hostName - Hostname in the hostname binding.
// options - AppsClientGetHostNameBindingSlotOptions contains the optional parameters for the AppsClient.GetHostNameBindingSlot
// method.
func (client *AppsClient) GetHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *AppsClientGetHostNameBindingSlotOptions) (AppsClientGetHostNameBindingSlotResponse, error) {
	req, err := client.getHostNameBindingSlotCreateRequest(ctx, resourceGroupName, name, slot, hostName, options)
	if err != nil {
		return AppsClientGetHostNameBindingSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetHostNameBindingSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetHostNameBindingSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getHostNameBindingSlotHandleResponse(resp)
}

// getHostNameBindingSlotCreateRequest creates the GetHostNameBindingSlot request.
func (client *AppsClient) getHostNameBindingSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *AppsClientGetHostNameBindingSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHostNameBindingSlotHandleResponse handles the GetHostNameBindingSlot response.
func (client *AppsClient) getHostNameBindingSlotHandleResponse(resp *http.Response) (AppsClientGetHostNameBindingSlotResponse, error) {
	result := AppsClientGetHostNameBindingSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBinding); err != nil {
		return AppsClientGetHostNameBindingSlotResponse{}, err
	}
	return result, nil
}

// GetHybridConnection - Retrieves a specific Service Bus Hybrid Connection used by this Web App.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// namespaceName - The namespace for this hybrid connection.
// relayName - The relay name for this hybrid connection.
// options - AppsClientGetHybridConnectionOptions contains the optional parameters for the AppsClient.GetHybridConnection
// method.
func (client *AppsClient) GetHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppsClientGetHybridConnectionOptions) (AppsClientGetHybridConnectionResponse, error) {
	req, err := client.getHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
	if err != nil {
		return AppsClientGetHybridConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetHybridConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getHybridConnectionHandleResponse(resp)
}

// getHybridConnectionCreateRequest creates the GetHybridConnection request.
func (client *AppsClient) getHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppsClientGetHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHybridConnectionHandleResponse handles the GetHybridConnection response.
func (client *AppsClient) getHybridConnectionHandleResponse(resp *http.Response) (AppsClientGetHybridConnectionResponse, error) {
	result := AppsClientGetHybridConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return AppsClientGetHybridConnectionResponse{}, err
	}
	return result, nil
}

// GetHybridConnectionSlot - Retrieves a specific Service Bus Hybrid Connection used by this Web App.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// namespaceName - The namespace for this hybrid connection.
// relayName - The relay name for this hybrid connection.
// slot - The name of the slot for the web app.
// options - AppsClientGetHybridConnectionSlotOptions contains the optional parameters for the AppsClient.GetHybridConnectionSlot
// method.
func (client *AppsClient) GetHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *AppsClientGetHybridConnectionSlotOptions) (AppsClientGetHybridConnectionSlotResponse, error) {
	req, err := client.getHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, options)
	if err != nil {
		return AppsClientGetHybridConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetHybridConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetHybridConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getHybridConnectionSlotHandleResponse(resp)
}

// getHybridConnectionSlotCreateRequest creates the GetHybridConnectionSlot request.
func (client *AppsClient) getHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *AppsClientGetHybridConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHybridConnectionSlotHandleResponse handles the GetHybridConnectionSlot response.
func (client *AppsClient) getHybridConnectionSlotHandleResponse(resp *http.Response) (AppsClientGetHybridConnectionSlotResponse, error) {
	result := AppsClientGetHybridConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return AppsClientGetHybridConnectionSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceFunctionSlot - Get function information by its ID for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - Function name.
// slot - Name of the deployment slot.
// options - AppsClientGetInstanceFunctionSlotOptions contains the optional parameters for the AppsClient.GetInstanceFunctionSlot
// method.
func (client *AppsClient) GetInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *AppsClientGetInstanceFunctionSlotOptions) (AppsClientGetInstanceFunctionSlotResponse, error) {
	req, err := client.getInstanceFunctionSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return AppsClientGetInstanceFunctionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceFunctionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetInstanceFunctionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInstanceFunctionSlotHandleResponse(resp)
}

// getInstanceFunctionSlotCreateRequest creates the GetInstanceFunctionSlot request.
func (client *AppsClient) getInstanceFunctionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *AppsClientGetInstanceFunctionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceFunctionSlotHandleResponse handles the GetInstanceFunctionSlot response.
func (client *AppsClient) getInstanceFunctionSlotHandleResponse(resp *http.Response) (AppsClientGetInstanceFunctionSlotResponse, error) {
	result := AppsClientGetInstanceFunctionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionEnvelope); err != nil {
		return AppsClientGetInstanceFunctionSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceMSDeployLog - Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// instanceID - ID of web app instance.
// options - AppsClientGetInstanceMSDeployLogOptions contains the optional parameters for the AppsClient.GetInstanceMSDeployLog
// method.
func (client *AppsClient) GetInstanceMSDeployLog(ctx context.Context, resourceGroupName string, name string, instanceID string, options *AppsClientGetInstanceMSDeployLogOptions) (AppsClientGetInstanceMSDeployLogResponse, error) {
	req, err := client.getInstanceMSDeployLogCreateRequest(ctx, resourceGroupName, name, instanceID, options)
	if err != nil {
		return AppsClientGetInstanceMSDeployLogResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceMSDeployLogResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetInstanceMSDeployLogResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInstanceMSDeployLogHandleResponse(resp)
}

// getInstanceMSDeployLogCreateRequest creates the GetInstanceMSDeployLog request.
func (client *AppsClient) getInstanceMSDeployLogCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *AppsClientGetInstanceMSDeployLogOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceMSDeployLogHandleResponse handles the GetInstanceMSDeployLog response.
func (client *AppsClient) getInstanceMSDeployLogHandleResponse(resp *http.Response) (AppsClientGetInstanceMSDeployLogResponse, error) {
	result := AppsClientGetInstanceMSDeployLogResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployLog); err != nil {
		return AppsClientGetInstanceMSDeployLogResponse{}, err
	}
	return result, nil
}

// GetInstanceMSDeployLogSlot - Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// instanceID - ID of web app instance.
// options - AppsClientGetInstanceMSDeployLogSlotOptions contains the optional parameters for the AppsClient.GetInstanceMSDeployLogSlot
// method.
func (client *AppsClient) GetInstanceMSDeployLogSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *AppsClientGetInstanceMSDeployLogSlotOptions) (AppsClientGetInstanceMSDeployLogSlotResponse, error) {
	req, err := client.getInstanceMSDeployLogSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, options)
	if err != nil {
		return AppsClientGetInstanceMSDeployLogSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceMSDeployLogSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetInstanceMSDeployLogSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInstanceMSDeployLogSlotHandleResponse(resp)
}

// getInstanceMSDeployLogSlotCreateRequest creates the GetInstanceMSDeployLogSlot request.
func (client *AppsClient) getInstanceMSDeployLogSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *AppsClientGetInstanceMSDeployLogSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceMSDeployLogSlotHandleResponse handles the GetInstanceMSDeployLogSlot response.
func (client *AppsClient) getInstanceMSDeployLogSlotHandleResponse(resp *http.Response) (AppsClientGetInstanceMSDeployLogSlotResponse, error) {
	result := AppsClientGetInstanceMSDeployLogSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployLog); err != nil {
		return AppsClientGetInstanceMSDeployLogSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceMsDeployStatus - Get the status of the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// instanceID - ID of web app instance.
// options - AppsClientGetInstanceMsDeployStatusOptions contains the optional parameters for the AppsClient.GetInstanceMsDeployStatus
// method.
func (client *AppsClient) GetInstanceMsDeployStatus(ctx context.Context, resourceGroupName string, name string, instanceID string, options *AppsClientGetInstanceMsDeployStatusOptions) (AppsClientGetInstanceMsDeployStatusResponse, error) {
	req, err := client.getInstanceMsDeployStatusCreateRequest(ctx, resourceGroupName, name, instanceID, options)
	if err != nil {
		return AppsClientGetInstanceMsDeployStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceMsDeployStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetInstanceMsDeployStatusResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInstanceMsDeployStatusHandleResponse(resp)
}

// getInstanceMsDeployStatusCreateRequest creates the GetInstanceMsDeployStatus request.
func (client *AppsClient) getInstanceMsDeployStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *AppsClientGetInstanceMsDeployStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceMsDeployStatusHandleResponse handles the GetInstanceMsDeployStatus response.
func (client *AppsClient) getInstanceMsDeployStatusHandleResponse(resp *http.Response) (AppsClientGetInstanceMsDeployStatusResponse, error) {
	result := AppsClientGetInstanceMsDeployStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployStatus); err != nil {
		return AppsClientGetInstanceMsDeployStatusResponse{}, err
	}
	return result, nil
}

// GetInstanceMsDeployStatusSlot - Get the status of the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// instanceID - ID of web app instance.
// options - AppsClientGetInstanceMsDeployStatusSlotOptions contains the optional parameters for the AppsClient.GetInstanceMsDeployStatusSlot
// method.
func (client *AppsClient) GetInstanceMsDeployStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *AppsClientGetInstanceMsDeployStatusSlotOptions) (AppsClientGetInstanceMsDeployStatusSlotResponse, error) {
	req, err := client.getInstanceMsDeployStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, options)
	if err != nil {
		return AppsClientGetInstanceMsDeployStatusSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceMsDeployStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetInstanceMsDeployStatusSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInstanceMsDeployStatusSlotHandleResponse(resp)
}

// getInstanceMsDeployStatusSlotCreateRequest creates the GetInstanceMsDeployStatusSlot request.
func (client *AppsClient) getInstanceMsDeployStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *AppsClientGetInstanceMsDeployStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceMsDeployStatusSlotHandleResponse handles the GetInstanceMsDeployStatusSlot response.
func (client *AppsClient) getInstanceMsDeployStatusSlotHandleResponse(resp *http.Response) (AppsClientGetInstanceMsDeployStatusSlotResponse, error) {
	result := AppsClientGetInstanceMsDeployStatusSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployStatus); err != nil {
		return AppsClientGetInstanceMsDeployStatusSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceProcess - Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientGetInstanceProcessOptions contains the optional parameters for the AppsClient.GetInstanceProcess method.
func (client *AppsClient) GetInstanceProcess(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *AppsClientGetInstanceProcessOptions) (AppsClientGetInstanceProcessResponse, error) {
	req, err := client.getInstanceProcessCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
	if err != nil {
		return AppsClientGetInstanceProcessResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceProcessResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetInstanceProcessResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInstanceProcessHandleResponse(resp)
}

// getInstanceProcessCreateRequest creates the GetInstanceProcess request.
func (client *AppsClient) getInstanceProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *AppsClientGetInstanceProcessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceProcessHandleResponse handles the GetInstanceProcess response.
func (client *AppsClient) getInstanceProcessHandleResponse(resp *http.Response) (AppsClientGetInstanceProcessResponse, error) {
	result := AppsClientGetInstanceProcessResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfo); err != nil {
		return AppsClientGetInstanceProcessResponse{}, err
	}
	return result, nil
}

// GetInstanceProcessDump - Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientGetInstanceProcessDumpOptions contains the optional parameters for the AppsClient.GetInstanceProcessDump
// method.
func (client *AppsClient) GetInstanceProcessDump(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *AppsClientGetInstanceProcessDumpOptions) (AppsClientGetInstanceProcessDumpResponse, error) {
	req, err := client.getInstanceProcessDumpCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
	if err != nil {
		return AppsClientGetInstanceProcessDumpResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceProcessDumpResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetInstanceProcessDumpResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientGetInstanceProcessDumpResponse{Body: resp.Body}, nil
}

// getInstanceProcessDumpCreateRequest creates the GetInstanceProcessDump request.
func (client *AppsClient) getInstanceProcessDumpCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *AppsClientGetInstanceProcessDumpOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetInstanceProcessDumpSlot - Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientGetInstanceProcessDumpSlotOptions contains the optional parameters for the AppsClient.GetInstanceProcessDumpSlot
// method.
func (client *AppsClient) GetInstanceProcessDumpSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *AppsClientGetInstanceProcessDumpSlotOptions) (AppsClientGetInstanceProcessDumpSlotResponse, error) {
	req, err := client.getInstanceProcessDumpSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
	if err != nil {
		return AppsClientGetInstanceProcessDumpSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceProcessDumpSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetInstanceProcessDumpSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientGetInstanceProcessDumpSlotResponse{Body: resp.Body}, nil
}

// getInstanceProcessDumpSlotCreateRequest creates the GetInstanceProcessDumpSlot request.
func (client *AppsClient) getInstanceProcessDumpSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *AppsClientGetInstanceProcessDumpSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetInstanceProcessModule - Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// baseAddress - Module base address.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientGetInstanceProcessModuleOptions contains the optional parameters for the AppsClient.GetInstanceProcessModule
// method.
func (client *AppsClient) GetInstanceProcessModule(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, instanceID string, options *AppsClientGetInstanceProcessModuleOptions) (AppsClientGetInstanceProcessModuleResponse, error) {
	req, err := client.getInstanceProcessModuleCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, instanceID, options)
	if err != nil {
		return AppsClientGetInstanceProcessModuleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceProcessModuleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetInstanceProcessModuleResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInstanceProcessModuleHandleResponse(resp)
}

// getInstanceProcessModuleCreateRequest creates the GetInstanceProcessModule request.
func (client *AppsClient) getInstanceProcessModuleCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, instanceID string, options *AppsClientGetInstanceProcessModuleOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceProcessModuleHandleResponse handles the GetInstanceProcessModule response.
func (client *AppsClient) getInstanceProcessModuleHandleResponse(resp *http.Response) (AppsClientGetInstanceProcessModuleResponse, error) {
	result := AppsClientGetInstanceProcessModuleResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfo); err != nil {
		return AppsClientGetInstanceProcessModuleResponse{}, err
	}
	return result, nil
}

// GetInstanceProcessModuleSlot - Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// baseAddress - Module base address.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientGetInstanceProcessModuleSlotOptions contains the optional parameters for the AppsClient.GetInstanceProcessModuleSlot
// method.
func (client *AppsClient) GetInstanceProcessModuleSlot(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, instanceID string, options *AppsClientGetInstanceProcessModuleSlotOptions) (AppsClientGetInstanceProcessModuleSlotResponse, error) {
	req, err := client.getInstanceProcessModuleSlotCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, slot, instanceID, options)
	if err != nil {
		return AppsClientGetInstanceProcessModuleSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceProcessModuleSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetInstanceProcessModuleSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInstanceProcessModuleSlotHandleResponse(resp)
}

// getInstanceProcessModuleSlotCreateRequest creates the GetInstanceProcessModuleSlot request.
func (client *AppsClient) getInstanceProcessModuleSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, instanceID string, options *AppsClientGetInstanceProcessModuleSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceProcessModuleSlotHandleResponse handles the GetInstanceProcessModuleSlot response.
func (client *AppsClient) getInstanceProcessModuleSlotHandleResponse(resp *http.Response) (AppsClientGetInstanceProcessModuleSlotResponse, error) {
	result := AppsClientGetInstanceProcessModuleSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfo); err != nil {
		return AppsClientGetInstanceProcessModuleSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceProcessSlot - Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientGetInstanceProcessSlotOptions contains the optional parameters for the AppsClient.GetInstanceProcessSlot
// method.
func (client *AppsClient) GetInstanceProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *AppsClientGetInstanceProcessSlotOptions) (AppsClientGetInstanceProcessSlotResponse, error) {
	req, err := client.getInstanceProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
	if err != nil {
		return AppsClientGetInstanceProcessSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceProcessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetInstanceProcessSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInstanceProcessSlotHandleResponse(resp)
}

// getInstanceProcessSlotCreateRequest creates the GetInstanceProcessSlot request.
func (client *AppsClient) getInstanceProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *AppsClientGetInstanceProcessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceProcessSlotHandleResponse handles the GetInstanceProcessSlot response.
func (client *AppsClient) getInstanceProcessSlotHandleResponse(resp *http.Response) (AppsClientGetInstanceProcessSlotResponse, error) {
	result := AppsClientGetInstanceProcessSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfo); err != nil {
		return AppsClientGetInstanceProcessSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceProcessThread - Get thread information by Thread ID for a specific process, in a specific scaled-out instance
// in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// threadID - TID.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientGetInstanceProcessThreadOptions contains the optional parameters for the AppsClient.GetInstanceProcessThread
// method.
func (client *AppsClient) GetInstanceProcessThread(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, instanceID string, options *AppsClientGetInstanceProcessThreadOptions) (AppsClientGetInstanceProcessThreadResponse, error) {
	req, err := client.getInstanceProcessThreadCreateRequest(ctx, resourceGroupName, name, processID, threadID, instanceID, options)
	if err != nil {
		return AppsClientGetInstanceProcessThreadResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceProcessThreadResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetInstanceProcessThreadResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInstanceProcessThreadHandleResponse(resp)
}

// getInstanceProcessThreadCreateRequest creates the GetInstanceProcessThread request.
func (client *AppsClient) getInstanceProcessThreadCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, instanceID string, options *AppsClientGetInstanceProcessThreadOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/threads/{threadId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceProcessThreadHandleResponse handles the GetInstanceProcessThread response.
func (client *AppsClient) getInstanceProcessThreadHandleResponse(resp *http.Response) (AppsClientGetInstanceProcessThreadResponse, error) {
	result := AppsClientGetInstanceProcessThreadResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfo); err != nil {
		return AppsClientGetInstanceProcessThreadResponse{}, err
	}
	return result, nil
}

// GetInstanceProcessThreadSlot - Get thread information by Thread ID for a specific process, in a specific scaled-out instance
// in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// threadID - TID.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientGetInstanceProcessThreadSlotOptions contains the optional parameters for the AppsClient.GetInstanceProcessThreadSlot
// method.
func (client *AppsClient) GetInstanceProcessThreadSlot(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, slot string, instanceID string, options *AppsClientGetInstanceProcessThreadSlotOptions) (AppsClientGetInstanceProcessThreadSlotResponse, error) {
	req, err := client.getInstanceProcessThreadSlotCreateRequest(ctx, resourceGroupName, name, processID, threadID, slot, instanceID, options)
	if err != nil {
		return AppsClientGetInstanceProcessThreadSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetInstanceProcessThreadSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetInstanceProcessThreadSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInstanceProcessThreadSlotHandleResponse(resp)
}

// getInstanceProcessThreadSlotCreateRequest creates the GetInstanceProcessThreadSlot request.
func (client *AppsClient) getInstanceProcessThreadSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, slot string, instanceID string, options *AppsClientGetInstanceProcessThreadSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/threads/{threadId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceProcessThreadSlotHandleResponse handles the GetInstanceProcessThreadSlot response.
func (client *AppsClient) getInstanceProcessThreadSlotHandleResponse(resp *http.Response) (AppsClientGetInstanceProcessThreadSlotResponse, error) {
	result := AppsClientGetInstanceProcessThreadSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfo); err != nil {
		return AppsClientGetInstanceProcessThreadSlotResponse{}, err
	}
	return result, nil
}

// GetMSDeployLog - Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// options - AppsClientGetMSDeployLogOptions contains the optional parameters for the AppsClient.GetMSDeployLog method.
func (client *AppsClient) GetMSDeployLog(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetMSDeployLogOptions) (AppsClientGetMSDeployLogResponse, error) {
	req, err := client.getMSDeployLogCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetMSDeployLogResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetMSDeployLogResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetMSDeployLogResponse{}, runtime.NewResponseError(resp)
	}
	return client.getMSDeployLogHandleResponse(resp)
}

// getMSDeployLogCreateRequest creates the GetMSDeployLog request.
func (client *AppsClient) getMSDeployLogCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetMSDeployLogOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMSDeployLogHandleResponse handles the GetMSDeployLog response.
func (client *AppsClient) getMSDeployLogHandleResponse(resp *http.Response) (AppsClientGetMSDeployLogResponse, error) {
	result := AppsClientGetMSDeployLogResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployLog); err != nil {
		return AppsClientGetMSDeployLogResponse{}, err
	}
	return result, nil
}

// GetMSDeployLogSlot - Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// options - AppsClientGetMSDeployLogSlotOptions contains the optional parameters for the AppsClient.GetMSDeployLogSlot method.
func (client *AppsClient) GetMSDeployLogSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetMSDeployLogSlotOptions) (AppsClientGetMSDeployLogSlotResponse, error) {
	req, err := client.getMSDeployLogSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetMSDeployLogSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetMSDeployLogSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetMSDeployLogSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getMSDeployLogSlotHandleResponse(resp)
}

// getMSDeployLogSlotCreateRequest creates the GetMSDeployLogSlot request.
func (client *AppsClient) getMSDeployLogSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetMSDeployLogSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMSDeployLogSlotHandleResponse handles the GetMSDeployLogSlot response.
func (client *AppsClient) getMSDeployLogSlotHandleResponse(resp *http.Response) (AppsClientGetMSDeployLogSlotResponse, error) {
	result := AppsClientGetMSDeployLogSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployLog); err != nil {
		return AppsClientGetMSDeployLogSlotResponse{}, err
	}
	return result, nil
}

// GetMSDeployStatus - Get the status of the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// options - AppsClientGetMSDeployStatusOptions contains the optional parameters for the AppsClient.GetMSDeployStatus method.
func (client *AppsClient) GetMSDeployStatus(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetMSDeployStatusOptions) (AppsClientGetMSDeployStatusResponse, error) {
	req, err := client.getMSDeployStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetMSDeployStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetMSDeployStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetMSDeployStatusResponse{}, runtime.NewResponseError(resp)
	}
	return client.getMSDeployStatusHandleResponse(resp)
}

// getMSDeployStatusCreateRequest creates the GetMSDeployStatus request.
func (client *AppsClient) getMSDeployStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetMSDeployStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMSDeployStatusHandleResponse handles the GetMSDeployStatus response.
func (client *AppsClient) getMSDeployStatusHandleResponse(resp *http.Response) (AppsClientGetMSDeployStatusResponse, error) {
	result := AppsClientGetMSDeployStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployStatus); err != nil {
		return AppsClientGetMSDeployStatusResponse{}, err
	}
	return result, nil
}

// GetMSDeployStatusSlot - Get the status of the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// options - AppsClientGetMSDeployStatusSlotOptions contains the optional parameters for the AppsClient.GetMSDeployStatusSlot
// method.
func (client *AppsClient) GetMSDeployStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetMSDeployStatusSlotOptions) (AppsClientGetMSDeployStatusSlotResponse, error) {
	req, err := client.getMSDeployStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetMSDeployStatusSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetMSDeployStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetMSDeployStatusSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getMSDeployStatusSlotHandleResponse(resp)
}

// getMSDeployStatusSlotCreateRequest creates the GetMSDeployStatusSlot request.
func (client *AppsClient) getMSDeployStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetMSDeployStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMSDeployStatusSlotHandleResponse handles the GetMSDeployStatusSlot response.
func (client *AppsClient) getMSDeployStatusSlotHandleResponse(resp *http.Response) (AppsClientGetMSDeployStatusSlotResponse, error) {
	result := AppsClientGetMSDeployStatusSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployStatus); err != nil {
		return AppsClientGetMSDeployStatusSlotResponse{}, err
	}
	return result, nil
}

// GetMigrateMySQLStatus - Returns the status of MySql in app migration, if one is active, and whether or not MySql in app
// is enabled
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// options - AppsClientGetMigrateMySQLStatusOptions contains the optional parameters for the AppsClient.GetMigrateMySQLStatus
// method.
func (client *AppsClient) GetMigrateMySQLStatus(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetMigrateMySQLStatusOptions) (AppsClientGetMigrateMySQLStatusResponse, error) {
	req, err := client.getMigrateMySQLStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetMigrateMySQLStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetMigrateMySQLStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetMigrateMySQLStatusResponse{}, runtime.NewResponseError(resp)
	}
	return client.getMigrateMySQLStatusHandleResponse(resp)
}

// getMigrateMySQLStatusCreateRequest creates the GetMigrateMySQLStatus request.
func (client *AppsClient) getMigrateMySQLStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetMigrateMySQLStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql/status"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMigrateMySQLStatusHandleResponse handles the GetMigrateMySQLStatus response.
func (client *AppsClient) getMigrateMySQLStatusHandleResponse(resp *http.Response) (AppsClientGetMigrateMySQLStatusResponse, error) {
	result := AppsClientGetMigrateMySQLStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MigrateMySQLStatus); err != nil {
		return AppsClientGetMigrateMySQLStatusResponse{}, err
	}
	return result, nil
}

// GetMigrateMySQLStatusSlot - Returns the status of MySql in app migration, if one is active, and whether or not MySql in
// app is enabled
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of the deployment slot.
// options - AppsClientGetMigrateMySQLStatusSlotOptions contains the optional parameters for the AppsClient.GetMigrateMySQLStatusSlot
// method.
func (client *AppsClient) GetMigrateMySQLStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetMigrateMySQLStatusSlotOptions) (AppsClientGetMigrateMySQLStatusSlotResponse, error) {
	req, err := client.getMigrateMySQLStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetMigrateMySQLStatusSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetMigrateMySQLStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetMigrateMySQLStatusSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getMigrateMySQLStatusSlotHandleResponse(resp)
}

// getMigrateMySQLStatusSlotCreateRequest creates the GetMigrateMySQLStatusSlot request.
func (client *AppsClient) getMigrateMySQLStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetMigrateMySQLStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/migratemysql/status"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMigrateMySQLStatusSlotHandleResponse handles the GetMigrateMySQLStatusSlot response.
func (client *AppsClient) getMigrateMySQLStatusSlotHandleResponse(resp *http.Response) (AppsClientGetMigrateMySQLStatusSlotResponse, error) {
	result := AppsClientGetMigrateMySQLStatusSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MigrateMySQLStatus); err != nil {
		return AppsClientGetMigrateMySQLStatusSlotResponse{}, err
	}
	return result, nil
}

// GetNetworkTraceOperation - Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// operationID - GUID of the operation.
// options - AppsClientGetNetworkTraceOperationOptions contains the optional parameters for the AppsClient.GetNetworkTraceOperation
// method.
func (client *AppsClient) GetNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, operationID string, options *AppsClientGetNetworkTraceOperationOptions) (AppsClientGetNetworkTraceOperationResponse, error) {
	req, err := client.getNetworkTraceOperationCreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return AppsClientGetNetworkTraceOperationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetNetworkTraceOperationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return AppsClientGetNetworkTraceOperationResponse{}, runtime.NewResponseError(resp)
	}
	return client.getNetworkTraceOperationHandleResponse(resp)
}

// getNetworkTraceOperationCreateRequest creates the GetNetworkTraceOperation request.
func (client *AppsClient) getNetworkTraceOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *AppsClientGetNetworkTraceOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTraceOperationHandleResponse handles the GetNetworkTraceOperation response.
func (client *AppsClient) getNetworkTraceOperationHandleResponse(resp *http.Response) (AppsClientGetNetworkTraceOperationResponse, error) {
	result := AppsClientGetNetworkTraceOperationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return AppsClientGetNetworkTraceOperationResponse{}, err
	}
	return result, nil
}

// GetNetworkTraceOperationSlot - Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// operationID - GUID of the operation.
// slot - Name of the deployment slot. If a slot is not specified, the API will get an operation for the production slot.
// options - AppsClientGetNetworkTraceOperationSlotOptions contains the optional parameters for the AppsClient.GetNetworkTraceOperationSlot
// method.
func (client *AppsClient) GetNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *AppsClientGetNetworkTraceOperationSlotOptions) (AppsClientGetNetworkTraceOperationSlotResponse, error) {
	req, err := client.getNetworkTraceOperationSlotCreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return AppsClientGetNetworkTraceOperationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetNetworkTraceOperationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return AppsClientGetNetworkTraceOperationSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getNetworkTraceOperationSlotHandleResponse(resp)
}

// getNetworkTraceOperationSlotCreateRequest creates the GetNetworkTraceOperationSlot request.
func (client *AppsClient) getNetworkTraceOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *AppsClientGetNetworkTraceOperationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTraceOperationSlotHandleResponse handles the GetNetworkTraceOperationSlot response.
func (client *AppsClient) getNetworkTraceOperationSlotHandleResponse(resp *http.Response) (AppsClientGetNetworkTraceOperationSlotResponse, error) {
	result := AppsClientGetNetworkTraceOperationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return AppsClientGetNetworkTraceOperationSlotResponse{}, err
	}
	return result, nil
}

// GetNetworkTraceOperationSlotV2 - Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// operationID - GUID of the operation.
// slot - Name of the deployment slot. If a slot is not specified, the API will get an operation for the production slot.
// options - AppsClientGetNetworkTraceOperationSlotV2Options contains the optional parameters for the AppsClient.GetNetworkTraceOperationSlotV2
// method.
func (client *AppsClient) GetNetworkTraceOperationSlotV2(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *AppsClientGetNetworkTraceOperationSlotV2Options) (AppsClientGetNetworkTraceOperationSlotV2Response, error) {
	req, err := client.getNetworkTraceOperationSlotV2CreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return AppsClientGetNetworkTraceOperationSlotV2Response{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetNetworkTraceOperationSlotV2Response{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return AppsClientGetNetworkTraceOperationSlotV2Response{}, runtime.NewResponseError(resp)
	}
	return client.getNetworkTraceOperationSlotV2HandleResponse(resp)
}

// getNetworkTraceOperationSlotV2CreateRequest creates the GetNetworkTraceOperationSlotV2 request.
func (client *AppsClient) getNetworkTraceOperationSlotV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *AppsClientGetNetworkTraceOperationSlotV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/current/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTraceOperationSlotV2HandleResponse handles the GetNetworkTraceOperationSlotV2 response.
func (client *AppsClient) getNetworkTraceOperationSlotV2HandleResponse(resp *http.Response) (AppsClientGetNetworkTraceOperationSlotV2Response, error) {
	result := AppsClientGetNetworkTraceOperationSlotV2Response{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return AppsClientGetNetworkTraceOperationSlotV2Response{}, err
	}
	return result, nil
}

// GetNetworkTraceOperationV2 - Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// operationID - GUID of the operation.
// options - AppsClientGetNetworkTraceOperationV2Options contains the optional parameters for the AppsClient.GetNetworkTraceOperationV2
// method.
func (client *AppsClient) GetNetworkTraceOperationV2(ctx context.Context, resourceGroupName string, name string, operationID string, options *AppsClientGetNetworkTraceOperationV2Options) (AppsClientGetNetworkTraceOperationV2Response, error) {
	req, err := client.getNetworkTraceOperationV2CreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return AppsClientGetNetworkTraceOperationV2Response{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetNetworkTraceOperationV2Response{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return AppsClientGetNetworkTraceOperationV2Response{}, runtime.NewResponseError(resp)
	}
	return client.getNetworkTraceOperationV2HandleResponse(resp)
}

// getNetworkTraceOperationV2CreateRequest creates the GetNetworkTraceOperationV2 request.
func (client *AppsClient) getNetworkTraceOperationV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *AppsClientGetNetworkTraceOperationV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/current/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTraceOperationV2HandleResponse handles the GetNetworkTraceOperationV2 response.
func (client *AppsClient) getNetworkTraceOperationV2HandleResponse(resp *http.Response) (AppsClientGetNetworkTraceOperationV2Response, error) {
	result := AppsClientGetNetworkTraceOperationV2Response{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return AppsClientGetNetworkTraceOperationV2Response{}, err
	}
	return result, nil
}

// GetNetworkTraces - Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// operationID - GUID of the operation.
// options - AppsClientGetNetworkTracesOptions contains the optional parameters for the AppsClient.GetNetworkTraces method.
func (client *AppsClient) GetNetworkTraces(ctx context.Context, resourceGroupName string, name string, operationID string, options *AppsClientGetNetworkTracesOptions) (AppsClientGetNetworkTracesResponse, error) {
	req, err := client.getNetworkTracesCreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return AppsClientGetNetworkTracesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetNetworkTracesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetNetworkTracesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getNetworkTracesHandleResponse(resp)
}

// getNetworkTracesCreateRequest creates the GetNetworkTraces request.
func (client *AppsClient) getNetworkTracesCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *AppsClientGetNetworkTracesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTracesHandleResponse handles the GetNetworkTraces response.
func (client *AppsClient) getNetworkTracesHandleResponse(resp *http.Response) (AppsClientGetNetworkTracesResponse, error) {
	result := AppsClientGetNetworkTracesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return AppsClientGetNetworkTracesResponse{}, err
	}
	return result, nil
}

// GetNetworkTracesSlot - Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// operationID - GUID of the operation.
// slot - Name of the deployment slot. If a slot is not specified, the API will get an operation for the production slot.
// options - AppsClientGetNetworkTracesSlotOptions contains the optional parameters for the AppsClient.GetNetworkTracesSlot
// method.
func (client *AppsClient) GetNetworkTracesSlot(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *AppsClientGetNetworkTracesSlotOptions) (AppsClientGetNetworkTracesSlotResponse, error) {
	req, err := client.getNetworkTracesSlotCreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return AppsClientGetNetworkTracesSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetNetworkTracesSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetNetworkTracesSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getNetworkTracesSlotHandleResponse(resp)
}

// getNetworkTracesSlotCreateRequest creates the GetNetworkTracesSlot request.
func (client *AppsClient) getNetworkTracesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *AppsClientGetNetworkTracesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTracesSlotHandleResponse handles the GetNetworkTracesSlot response.
func (client *AppsClient) getNetworkTracesSlotHandleResponse(resp *http.Response) (AppsClientGetNetworkTracesSlotResponse, error) {
	result := AppsClientGetNetworkTracesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return AppsClientGetNetworkTracesSlotResponse{}, err
	}
	return result, nil
}

// GetNetworkTracesSlotV2 - Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// operationID - GUID of the operation.
// slot - Name of the deployment slot. If a slot is not specified, the API will get an operation for the production slot.
// options - AppsClientGetNetworkTracesSlotV2Options contains the optional parameters for the AppsClient.GetNetworkTracesSlotV2
// method.
func (client *AppsClient) GetNetworkTracesSlotV2(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *AppsClientGetNetworkTracesSlotV2Options) (AppsClientGetNetworkTracesSlotV2Response, error) {
	req, err := client.getNetworkTracesSlotV2CreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return AppsClientGetNetworkTracesSlotV2Response{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetNetworkTracesSlotV2Response{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetNetworkTracesSlotV2Response{}, runtime.NewResponseError(resp)
	}
	return client.getNetworkTracesSlotV2HandleResponse(resp)
}

// getNetworkTracesSlotV2CreateRequest creates the GetNetworkTracesSlotV2 request.
func (client *AppsClient) getNetworkTracesSlotV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *AppsClientGetNetworkTracesSlotV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTracesSlotV2HandleResponse handles the GetNetworkTracesSlotV2 response.
func (client *AppsClient) getNetworkTracesSlotV2HandleResponse(resp *http.Response) (AppsClientGetNetworkTracesSlotV2Response, error) {
	result := AppsClientGetNetworkTracesSlotV2Response{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return AppsClientGetNetworkTracesSlotV2Response{}, err
	}
	return result, nil
}

// GetNetworkTracesV2 - Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// operationID - GUID of the operation.
// options - AppsClientGetNetworkTracesV2Options contains the optional parameters for the AppsClient.GetNetworkTracesV2 method.
func (client *AppsClient) GetNetworkTracesV2(ctx context.Context, resourceGroupName string, name string, operationID string, options *AppsClientGetNetworkTracesV2Options) (AppsClientGetNetworkTracesV2Response, error) {
	req, err := client.getNetworkTracesV2CreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return AppsClientGetNetworkTracesV2Response{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetNetworkTracesV2Response{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetNetworkTracesV2Response{}, runtime.NewResponseError(resp)
	}
	return client.getNetworkTracesV2HandleResponse(resp)
}

// getNetworkTracesV2CreateRequest creates the GetNetworkTracesV2 request.
func (client *AppsClient) getNetworkTracesV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *AppsClientGetNetworkTracesV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTracesV2HandleResponse handles the GetNetworkTracesV2 response.
func (client *AppsClient) getNetworkTracesV2HandleResponse(resp *http.Response) (AppsClientGetNetworkTracesV2Response, error) {
	result := AppsClientGetNetworkTracesV2Response{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return AppsClientGetNetworkTracesV2Response{}, err
	}
	return result, nil
}

// GetPremierAddOn - Gets a named add-on of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// premierAddOnName - Add-on name.
// options - AppsClientGetPremierAddOnOptions contains the optional parameters for the AppsClient.GetPremierAddOn method.
func (client *AppsClient) GetPremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *AppsClientGetPremierAddOnOptions) (AppsClientGetPremierAddOnResponse, error) {
	req, err := client.getPremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, options)
	if err != nil {
		return AppsClientGetPremierAddOnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetPremierAddOnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetPremierAddOnResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPremierAddOnHandleResponse(resp)
}

// getPremierAddOnCreateRequest creates the GetPremierAddOn request.
func (client *AppsClient) getPremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *AppsClientGetPremierAddOnOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPremierAddOnHandleResponse handles the GetPremierAddOn response.
func (client *AppsClient) getPremierAddOnHandleResponse(resp *http.Response) (AppsClientGetPremierAddOnResponse, error) {
	result := AppsClientGetPremierAddOnResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return AppsClientGetPremierAddOnResponse{}, err
	}
	return result, nil
}

// GetPremierAddOnSlot - Gets a named add-on of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// premierAddOnName - Add-on name.
// slot - Name of the deployment slot. If a slot is not specified, the API will get the named add-on for the production slot.
// options - AppsClientGetPremierAddOnSlotOptions contains the optional parameters for the AppsClient.GetPremierAddOnSlot
// method.
func (client *AppsClient) GetPremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *AppsClientGetPremierAddOnSlotOptions) (AppsClientGetPremierAddOnSlotResponse, error) {
	req, err := client.getPremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, options)
	if err != nil {
		return AppsClientGetPremierAddOnSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetPremierAddOnSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetPremierAddOnSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPremierAddOnSlotHandleResponse(resp)
}

// getPremierAddOnSlotCreateRequest creates the GetPremierAddOnSlot request.
func (client *AppsClient) getPremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *AppsClientGetPremierAddOnSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPremierAddOnSlotHandleResponse handles the GetPremierAddOnSlot response.
func (client *AppsClient) getPremierAddOnSlotHandleResponse(resp *http.Response) (AppsClientGetPremierAddOnSlotResponse, error) {
	result := AppsClientGetPremierAddOnSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return AppsClientGetPremierAddOnSlotResponse{}, err
	}
	return result, nil
}

// GetPrivateAccess - Gets data around private site access enablement and authorized Virtual Networks that can access the
// site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// options - AppsClientGetPrivateAccessOptions contains the optional parameters for the AppsClient.GetPrivateAccess method.
func (client *AppsClient) GetPrivateAccess(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetPrivateAccessOptions) (AppsClientGetPrivateAccessResponse, error) {
	req, err := client.getPrivateAccessCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetPrivateAccessResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetPrivateAccessResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetPrivateAccessResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPrivateAccessHandleResponse(resp)
}

// getPrivateAccessCreateRequest creates the GetPrivateAccess request.
func (client *AppsClient) getPrivateAccessCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetPrivateAccessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPrivateAccessHandleResponse handles the GetPrivateAccess response.
func (client *AppsClient) getPrivateAccessHandleResponse(resp *http.Response) (AppsClientGetPrivateAccessResponse, error) {
	result := AppsClientGetPrivateAccessResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateAccess); err != nil {
		return AppsClientGetPrivateAccessResponse{}, err
	}
	return result, nil
}

// GetPrivateAccessSlot - Gets data around private site access enablement and authorized Virtual Networks that can access
// the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// slot - The name of the slot for the web app.
// options - AppsClientGetPrivateAccessSlotOptions contains the optional parameters for the AppsClient.GetPrivateAccessSlot
// method.
func (client *AppsClient) GetPrivateAccessSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetPrivateAccessSlotOptions) (AppsClientGetPrivateAccessSlotResponse, error) {
	req, err := client.getPrivateAccessSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetPrivateAccessSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetPrivateAccessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetPrivateAccessSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPrivateAccessSlotHandleResponse(resp)
}

// getPrivateAccessSlotCreateRequest creates the GetPrivateAccessSlot request.
func (client *AppsClient) getPrivateAccessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetPrivateAccessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPrivateAccessSlotHandleResponse handles the GetPrivateAccessSlot response.
func (client *AppsClient) getPrivateAccessSlotHandleResponse(resp *http.Response) (AppsClientGetPrivateAccessSlotResponse, error) {
	result := AppsClientGetPrivateAccessSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateAccess); err != nil {
		return AppsClientGetPrivateAccessSlotResponse{}, err
	}
	return result, nil
}

// GetProcess - Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// options - AppsClientGetProcessOptions contains the optional parameters for the AppsClient.GetProcess method.
func (client *AppsClient) GetProcess(ctx context.Context, resourceGroupName string, name string, processID string, options *AppsClientGetProcessOptions) (AppsClientGetProcessResponse, error) {
	req, err := client.getProcessCreateRequest(ctx, resourceGroupName, name, processID, options)
	if err != nil {
		return AppsClientGetProcessResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetProcessResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetProcessResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProcessHandleResponse(resp)
}

// getProcessCreateRequest creates the GetProcess request.
func (client *AppsClient) getProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *AppsClientGetProcessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getProcessHandleResponse handles the GetProcess response.
func (client *AppsClient) getProcessHandleResponse(resp *http.Response) (AppsClientGetProcessResponse, error) {
	result := AppsClientGetProcessResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfo); err != nil {
		return AppsClientGetProcessResponse{}, err
	}
	return result, nil
}

// GetProcessDump - Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// options - AppsClientGetProcessDumpOptions contains the optional parameters for the AppsClient.GetProcessDump method.
func (client *AppsClient) GetProcessDump(ctx context.Context, resourceGroupName string, name string, processID string, options *AppsClientGetProcessDumpOptions) (AppsClientGetProcessDumpResponse, error) {
	req, err := client.getProcessDumpCreateRequest(ctx, resourceGroupName, name, processID, options)
	if err != nil {
		return AppsClientGetProcessDumpResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetProcessDumpResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetProcessDumpResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientGetProcessDumpResponse{Body: resp.Body}, nil
}

// getProcessDumpCreateRequest creates the GetProcessDump request.
func (client *AppsClient) getProcessDumpCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *AppsClientGetProcessDumpOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetProcessDumpSlot - Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// options - AppsClientGetProcessDumpSlotOptions contains the optional parameters for the AppsClient.GetProcessDumpSlot method.
func (client *AppsClient) GetProcessDumpSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *AppsClientGetProcessDumpSlotOptions) (AppsClientGetProcessDumpSlotResponse, error) {
	req, err := client.getProcessDumpSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
	if err != nil {
		return AppsClientGetProcessDumpSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetProcessDumpSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetProcessDumpSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientGetProcessDumpSlotResponse{Body: resp.Body}, nil
}

// getProcessDumpSlotCreateRequest creates the GetProcessDumpSlot request.
func (client *AppsClient) getProcessDumpSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *AppsClientGetProcessDumpSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetProcessModule - Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// baseAddress - Module base address.
// options - AppsClientGetProcessModuleOptions contains the optional parameters for the AppsClient.GetProcessModule method.
func (client *AppsClient) GetProcessModule(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, options *AppsClientGetProcessModuleOptions) (AppsClientGetProcessModuleResponse, error) {
	req, err := client.getProcessModuleCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, options)
	if err != nil {
		return AppsClientGetProcessModuleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetProcessModuleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetProcessModuleResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProcessModuleHandleResponse(resp)
}

// getProcessModuleCreateRequest creates the GetProcessModule request.
func (client *AppsClient) getProcessModuleCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, options *AppsClientGetProcessModuleOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getProcessModuleHandleResponse handles the GetProcessModule response.
func (client *AppsClient) getProcessModuleHandleResponse(resp *http.Response) (AppsClientGetProcessModuleResponse, error) {
	result := AppsClientGetProcessModuleResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfo); err != nil {
		return AppsClientGetProcessModuleResponse{}, err
	}
	return result, nil
}

// GetProcessModuleSlot - Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// baseAddress - Module base address.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// options - AppsClientGetProcessModuleSlotOptions contains the optional parameters for the AppsClient.GetProcessModuleSlot
// method.
func (client *AppsClient) GetProcessModuleSlot(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, options *AppsClientGetProcessModuleSlotOptions) (AppsClientGetProcessModuleSlotResponse, error) {
	req, err := client.getProcessModuleSlotCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, slot, options)
	if err != nil {
		return AppsClientGetProcessModuleSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetProcessModuleSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetProcessModuleSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProcessModuleSlotHandleResponse(resp)
}

// getProcessModuleSlotCreateRequest creates the GetProcessModuleSlot request.
func (client *AppsClient) getProcessModuleSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, options *AppsClientGetProcessModuleSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getProcessModuleSlotHandleResponse handles the GetProcessModuleSlot response.
func (client *AppsClient) getProcessModuleSlotHandleResponse(resp *http.Response) (AppsClientGetProcessModuleSlotResponse, error) {
	result := AppsClientGetProcessModuleSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfo); err != nil {
		return AppsClientGetProcessModuleSlotResponse{}, err
	}
	return result, nil
}

// GetProcessSlot - Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// options - AppsClientGetProcessSlotOptions contains the optional parameters for the AppsClient.GetProcessSlot method.
func (client *AppsClient) GetProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *AppsClientGetProcessSlotOptions) (AppsClientGetProcessSlotResponse, error) {
	req, err := client.getProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
	if err != nil {
		return AppsClientGetProcessSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetProcessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetProcessSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProcessSlotHandleResponse(resp)
}

// getProcessSlotCreateRequest creates the GetProcessSlot request.
func (client *AppsClient) getProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *AppsClientGetProcessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getProcessSlotHandleResponse handles the GetProcessSlot response.
func (client *AppsClient) getProcessSlotHandleResponse(resp *http.Response) (AppsClientGetProcessSlotResponse, error) {
	result := AppsClientGetProcessSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfo); err != nil {
		return AppsClientGetProcessSlotResponse{}, err
	}
	return result, nil
}

// GetProcessThread - Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web
// site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// threadID - TID.
// options - AppsClientGetProcessThreadOptions contains the optional parameters for the AppsClient.GetProcessThread method.
func (client *AppsClient) GetProcessThread(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, options *AppsClientGetProcessThreadOptions) (AppsClientGetProcessThreadResponse, error) {
	req, err := client.getProcessThreadCreateRequest(ctx, resourceGroupName, name, processID, threadID, options)
	if err != nil {
		return AppsClientGetProcessThreadResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetProcessThreadResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetProcessThreadResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProcessThreadHandleResponse(resp)
}

// getProcessThreadCreateRequest creates the GetProcessThread request.
func (client *AppsClient) getProcessThreadCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, options *AppsClientGetProcessThreadOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/threads/{threadId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getProcessThreadHandleResponse handles the GetProcessThread response.
func (client *AppsClient) getProcessThreadHandleResponse(resp *http.Response) (AppsClientGetProcessThreadResponse, error) {
	result := AppsClientGetProcessThreadResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfo); err != nil {
		return AppsClientGetProcessThreadResponse{}, err
	}
	return result, nil
}

// GetProcessThreadSlot - Get thread information by Thread ID for a specific process, in a specific scaled-out instance in
// a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// threadID - TID.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// options - AppsClientGetProcessThreadSlotOptions contains the optional parameters for the AppsClient.GetProcessThreadSlot
// method.
func (client *AppsClient) GetProcessThreadSlot(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, slot string, options *AppsClientGetProcessThreadSlotOptions) (AppsClientGetProcessThreadSlotResponse, error) {
	req, err := client.getProcessThreadSlotCreateRequest(ctx, resourceGroupName, name, processID, threadID, slot, options)
	if err != nil {
		return AppsClientGetProcessThreadSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetProcessThreadSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetProcessThreadSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProcessThreadSlotHandleResponse(resp)
}

// getProcessThreadSlotCreateRequest creates the GetProcessThreadSlot request.
func (client *AppsClient) getProcessThreadSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, slot string, options *AppsClientGetProcessThreadSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/threads/{threadId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if threadID == "" {
		return nil, errors.New("parameter threadID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{threadId}", url.PathEscape(threadID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getProcessThreadSlotHandleResponse handles the GetProcessThreadSlot response.
func (client *AppsClient) getProcessThreadSlotHandleResponse(resp *http.Response) (AppsClientGetProcessThreadSlotResponse, error) {
	result := AppsClientGetProcessThreadSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfo); err != nil {
		return AppsClientGetProcessThreadSlotResponse{}, err
	}
	return result, nil
}

// GetPublicCertificate - Get the named public certificate for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// publicCertificateName - Public certificate name.
// options - AppsClientGetPublicCertificateOptions contains the optional parameters for the AppsClient.GetPublicCertificate
// method.
func (client *AppsClient) GetPublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *AppsClientGetPublicCertificateOptions) (AppsClientGetPublicCertificateResponse, error) {
	req, err := client.getPublicCertificateCreateRequest(ctx, resourceGroupName, name, publicCertificateName, options)
	if err != nil {
		return AppsClientGetPublicCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetPublicCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetPublicCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPublicCertificateHandleResponse(resp)
}

// getPublicCertificateCreateRequest creates the GetPublicCertificate request.
func (client *AppsClient) getPublicCertificateCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *AppsClientGetPublicCertificateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPublicCertificateHandleResponse handles the GetPublicCertificate response.
func (client *AppsClient) getPublicCertificateHandleResponse(resp *http.Response) (AppsClientGetPublicCertificateResponse, error) {
	result := AppsClientGetPublicCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificate); err != nil {
		return AppsClientGetPublicCertificateResponse{}, err
	}
	return result, nil
}

// GetPublicCertificateSlot - Get the named public certificate for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
// publicCertificateName - Public certificate name.
// options - AppsClientGetPublicCertificateSlotOptions contains the optional parameters for the AppsClient.GetPublicCertificateSlot
// method.
func (client *AppsClient) GetPublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *AppsClientGetPublicCertificateSlotOptions) (AppsClientGetPublicCertificateSlotResponse, error) {
	req, err := client.getPublicCertificateSlotCreateRequest(ctx, resourceGroupName, name, slot, publicCertificateName, options)
	if err != nil {
		return AppsClientGetPublicCertificateSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetPublicCertificateSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetPublicCertificateSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPublicCertificateSlotHandleResponse(resp)
}

// getPublicCertificateSlotCreateRequest creates the GetPublicCertificateSlot request.
func (client *AppsClient) getPublicCertificateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *AppsClientGetPublicCertificateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPublicCertificateSlotHandleResponse handles the GetPublicCertificateSlot response.
func (client *AppsClient) getPublicCertificateSlotHandleResponse(resp *http.Response) (AppsClientGetPublicCertificateSlotResponse, error) {
	result := AppsClientGetPublicCertificateSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificate); err != nil {
		return AppsClientGetPublicCertificateSlotResponse{}, err
	}
	return result, nil
}

// GetRelayServiceConnection - Gets a hybrid connection configuration by its name.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// entityName - Name of the hybrid connection.
// options - AppsClientGetRelayServiceConnectionOptions contains the optional parameters for the AppsClient.GetRelayServiceConnection
// method.
func (client *AppsClient) GetRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, options *AppsClientGetRelayServiceConnectionOptions) (AppsClientGetRelayServiceConnectionResponse, error) {
	req, err := client.getRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, options)
	if err != nil {
		return AppsClientGetRelayServiceConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetRelayServiceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetRelayServiceConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getRelayServiceConnectionHandleResponse(resp)
}

// getRelayServiceConnectionCreateRequest creates the GetRelayServiceConnection request.
func (client *AppsClient) getRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, options *AppsClientGetRelayServiceConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getRelayServiceConnectionHandleResponse handles the GetRelayServiceConnection response.
func (client *AppsClient) getRelayServiceConnectionHandleResponse(resp *http.Response) (AppsClientGetRelayServiceConnectionResponse, error) {
	result := AppsClientGetRelayServiceConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return AppsClientGetRelayServiceConnectionResponse{}, err
	}
	return result, nil
}

// GetRelayServiceConnectionSlot - Gets a hybrid connection configuration by its name.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// entityName - Name of the hybrid connection.
// slot - Name of the deployment slot. If a slot is not specified, the API will get a hybrid connection for the production
// slot.
// options - AppsClientGetRelayServiceConnectionSlotOptions contains the optional parameters for the AppsClient.GetRelayServiceConnectionSlot
// method.
func (client *AppsClient) GetRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *AppsClientGetRelayServiceConnectionSlotOptions) (AppsClientGetRelayServiceConnectionSlotResponse, error) {
	req, err := client.getRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, options)
	if err != nil {
		return AppsClientGetRelayServiceConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetRelayServiceConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetRelayServiceConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getRelayServiceConnectionSlotHandleResponse(resp)
}

// getRelayServiceConnectionSlotCreateRequest creates the GetRelayServiceConnectionSlot request.
func (client *AppsClient) getRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *AppsClientGetRelayServiceConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getRelayServiceConnectionSlotHandleResponse handles the GetRelayServiceConnectionSlot response.
func (client *AppsClient) getRelayServiceConnectionSlotHandleResponse(resp *http.Response) (AppsClientGetRelayServiceConnectionSlotResponse, error) {
	result := AppsClientGetRelayServiceConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return AppsClientGetRelayServiceConnectionSlotResponse{}, err
	}
	return result, nil
}

// GetSiteExtension - Get site extension information by its ID for a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// siteExtensionID - Site extension name.
// options - AppsClientGetSiteExtensionOptions contains the optional parameters for the AppsClient.GetSiteExtension method.
func (client *AppsClient) GetSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *AppsClientGetSiteExtensionOptions) (AppsClientGetSiteExtensionResponse, error) {
	req, err := client.getSiteExtensionCreateRequest(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return AppsClientGetSiteExtensionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetSiteExtensionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetSiteExtensionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSiteExtensionHandleResponse(resp)
}

// getSiteExtensionCreateRequest creates the GetSiteExtension request.
func (client *AppsClient) getSiteExtensionCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *AppsClientGetSiteExtensionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSiteExtensionHandleResponse handles the GetSiteExtension response.
func (client *AppsClient) getSiteExtensionHandleResponse(resp *http.Response) (AppsClientGetSiteExtensionResponse, error) {
	result := AppsClientGetSiteExtensionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteExtensionInfo); err != nil {
		return AppsClientGetSiteExtensionResponse{}, err
	}
	return result, nil
}

// GetSiteExtensionSlot - Get site extension information by its ID for a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// siteExtensionID - Site extension name.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientGetSiteExtensionSlotOptions contains the optional parameters for the AppsClient.GetSiteExtensionSlot
// method.
func (client *AppsClient) GetSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *AppsClientGetSiteExtensionSlotOptions) (AppsClientGetSiteExtensionSlotResponse, error) {
	req, err := client.getSiteExtensionSlotCreateRequest(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return AppsClientGetSiteExtensionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetSiteExtensionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetSiteExtensionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSiteExtensionSlotHandleResponse(resp)
}

// getSiteExtensionSlotCreateRequest creates the GetSiteExtensionSlot request.
func (client *AppsClient) getSiteExtensionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *AppsClientGetSiteExtensionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSiteExtensionSlotHandleResponse handles the GetSiteExtensionSlot response.
func (client *AppsClient) getSiteExtensionSlotHandleResponse(resp *http.Response) (AppsClientGetSiteExtensionSlotResponse, error) {
	result := AppsClientGetSiteExtensionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteExtensionInfo); err != nil {
		return AppsClientGetSiteExtensionSlotResponse{}, err
	}
	return result, nil
}

// GetSitePhpErrorLogFlag - Gets web app's event logs.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// options - AppsClientGetSitePhpErrorLogFlagOptions contains the optional parameters for the AppsClient.GetSitePhpErrorLogFlag
// method.
func (client *AppsClient) GetSitePhpErrorLogFlag(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetSitePhpErrorLogFlagOptions) (AppsClientGetSitePhpErrorLogFlagResponse, error) {
	req, err := client.getSitePhpErrorLogFlagCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetSitePhpErrorLogFlagResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetSitePhpErrorLogFlagResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetSitePhpErrorLogFlagResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSitePhpErrorLogFlagHandleResponse(resp)
}

// getSitePhpErrorLogFlagCreateRequest creates the GetSitePhpErrorLogFlag request.
func (client *AppsClient) getSitePhpErrorLogFlagCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetSitePhpErrorLogFlagOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/phplogging"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSitePhpErrorLogFlagHandleResponse handles the GetSitePhpErrorLogFlag response.
func (client *AppsClient) getSitePhpErrorLogFlagHandleResponse(resp *http.Response) (AppsClientGetSitePhpErrorLogFlagResponse, error) {
	result := AppsClientGetSitePhpErrorLogFlagResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SitePhpErrorLogFlag); err != nil {
		return AppsClientGetSitePhpErrorLogFlagResponse{}, err
	}
	return result, nil
}

// GetSitePhpErrorLogFlagSlot - Gets web app's event logs.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// options - AppsClientGetSitePhpErrorLogFlagSlotOptions contains the optional parameters for the AppsClient.GetSitePhpErrorLogFlagSlot
// method.
func (client *AppsClient) GetSitePhpErrorLogFlagSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetSitePhpErrorLogFlagSlotOptions) (AppsClientGetSitePhpErrorLogFlagSlotResponse, error) {
	req, err := client.getSitePhpErrorLogFlagSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetSitePhpErrorLogFlagSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetSitePhpErrorLogFlagSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetSitePhpErrorLogFlagSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSitePhpErrorLogFlagSlotHandleResponse(resp)
}

// getSitePhpErrorLogFlagSlotCreateRequest creates the GetSitePhpErrorLogFlagSlot request.
func (client *AppsClient) getSitePhpErrorLogFlagSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetSitePhpErrorLogFlagSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/phplogging"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSitePhpErrorLogFlagSlotHandleResponse handles the GetSitePhpErrorLogFlagSlot response.
func (client *AppsClient) getSitePhpErrorLogFlagSlotHandleResponse(resp *http.Response) (AppsClientGetSitePhpErrorLogFlagSlotResponse, error) {
	result := AppsClientGetSitePhpErrorLogFlagSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SitePhpErrorLogFlag); err != nil {
		return AppsClientGetSitePhpErrorLogFlagSlotResponse{}, err
	}
	return result, nil
}

// GetSlot - Gets the details of a web, mobile, or API app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. By default, this API returns the production slot.
// options - AppsClientGetSlotOptions contains the optional parameters for the AppsClient.GetSlot method.
func (client *AppsClient) GetSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetSlotOptions) (AppsClientGetSlotResponse, error) {
	req, err := client.getSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSlotHandleResponse(resp)
}

// getSlotCreateRequest creates the GetSlot request.
func (client *AppsClient) getSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSlotHandleResponse handles the GetSlot response.
func (client *AppsClient) getSlotHandleResponse(resp *http.Response) (AppsClientGetSlotResponse, error) {
	result := AppsClientGetSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Site); err != nil {
		return AppsClientGetSlotResponse{}, err
	}
	return result, nil
}

// GetSourceControl - Gets the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientGetSourceControlOptions contains the optional parameters for the AppsClient.GetSourceControl method.
func (client *AppsClient) GetSourceControl(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetSourceControlOptions) (AppsClientGetSourceControlResponse, error) {
	req, err := client.getSourceControlCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetSourceControlResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return AppsClientGetSourceControlResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSourceControlHandleResponse(resp)
}

// getSourceControlCreateRequest creates the GetSourceControl request.
func (client *AppsClient) getSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetSourceControlOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSourceControlHandleResponse handles the GetSourceControl response.
func (client *AppsClient) getSourceControlHandleResponse(resp *http.Response) (AppsClientGetSourceControlResponse, error) {
	result := AppsClientGetSourceControlResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteSourceControl); err != nil {
		return AppsClientGetSourceControlResponse{}, err
	}
	return result, nil
}

// GetSourceControlSlot - Gets the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get the source control configuration for the
// production slot.
// options - AppsClientGetSourceControlSlotOptions contains the optional parameters for the AppsClient.GetSourceControlSlot
// method.
func (client *AppsClient) GetSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetSourceControlSlotOptions) (AppsClientGetSourceControlSlotResponse, error) {
	req, err := client.getSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetSourceControlSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetSourceControlSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return AppsClientGetSourceControlSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSourceControlSlotHandleResponse(resp)
}

// getSourceControlSlotCreateRequest creates the GetSourceControlSlot request.
func (client *AppsClient) getSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetSourceControlSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSourceControlSlotHandleResponse handles the GetSourceControlSlot response.
func (client *AppsClient) getSourceControlSlotHandleResponse(resp *http.Response) (AppsClientGetSourceControlSlotResponse, error) {
	result := AppsClientGetSourceControlSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteSourceControl); err != nil {
		return AppsClientGetSourceControlSlotResponse{}, err
	}
	return result, nil
}

// GetSwiftVirtualNetworkConnection - Gets a Swift Virtual Network connection.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientGetSwiftVirtualNetworkConnectionOptions contains the optional parameters for the AppsClient.GetSwiftVirtualNetworkConnection
// method.
func (client *AppsClient) GetSwiftVirtualNetworkConnection(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetSwiftVirtualNetworkConnectionOptions) (AppsClientGetSwiftVirtualNetworkConnectionResponse, error) {
	req, err := client.getSwiftVirtualNetworkConnectionCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetSwiftVirtualNetworkConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetSwiftVirtualNetworkConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetSwiftVirtualNetworkConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSwiftVirtualNetworkConnectionHandleResponse(resp)
}

// getSwiftVirtualNetworkConnectionCreateRequest creates the GetSwiftVirtualNetworkConnection request.
func (client *AppsClient) getSwiftVirtualNetworkConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetSwiftVirtualNetworkConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSwiftVirtualNetworkConnectionHandleResponse handles the GetSwiftVirtualNetworkConnection response.
func (client *AppsClient) getSwiftVirtualNetworkConnectionHandleResponse(resp *http.Response) (AppsClientGetSwiftVirtualNetworkConnectionResponse, error) {
	result := AppsClientGetSwiftVirtualNetworkConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return AppsClientGetSwiftVirtualNetworkConnectionResponse{}, err
	}
	return result, nil
}

// GetSwiftVirtualNetworkConnectionSlot - Gets a Swift Virtual Network connection.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get a gateway for the production slot's Virtual
// Network.
// options - AppsClientGetSwiftVirtualNetworkConnectionSlotOptions contains the optional parameters for the AppsClient.GetSwiftVirtualNetworkConnectionSlot
// method.
func (client *AppsClient) GetSwiftVirtualNetworkConnectionSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetSwiftVirtualNetworkConnectionSlotOptions) (AppsClientGetSwiftVirtualNetworkConnectionSlotResponse, error) {
	req, err := client.getSwiftVirtualNetworkConnectionSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetSwiftVirtualNetworkConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSwiftVirtualNetworkConnectionSlotHandleResponse(resp)
}

// getSwiftVirtualNetworkConnectionSlotCreateRequest creates the GetSwiftVirtualNetworkConnectionSlot request.
func (client *AppsClient) getSwiftVirtualNetworkConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetSwiftVirtualNetworkConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSwiftVirtualNetworkConnectionSlotHandleResponse handles the GetSwiftVirtualNetworkConnectionSlot response.
func (client *AppsClient) getSwiftVirtualNetworkConnectionSlotHandleResponse(resp *http.Response) (AppsClientGetSwiftVirtualNetworkConnectionSlotResponse, error) {
	result := AppsClientGetSwiftVirtualNetworkConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return AppsClientGetSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	return result, nil
}

// GetTriggeredWebJob - Gets a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// options - AppsClientGetTriggeredWebJobOptions contains the optional parameters for the AppsClient.GetTriggeredWebJob method.
func (client *AppsClient) GetTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientGetTriggeredWebJobOptions) (AppsClientGetTriggeredWebJobResponse, error) {
	req, err := client.getTriggeredWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return AppsClientGetTriggeredWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetTriggeredWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetTriggeredWebJobResponse{}, runtime.NewResponseError(resp)
	}
	return client.getTriggeredWebJobHandleResponse(resp)
}

// getTriggeredWebJobCreateRequest creates the GetTriggeredWebJob request.
func (client *AppsClient) getTriggeredWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientGetTriggeredWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTriggeredWebJobHandleResponse handles the GetTriggeredWebJob response.
func (client *AppsClient) getTriggeredWebJobHandleResponse(resp *http.Response) (AppsClientGetTriggeredWebJobResponse, error) {
	result := AppsClientGetTriggeredWebJobResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredWebJob); err != nil {
		return AppsClientGetTriggeredWebJobResponse{}, err
	}
	return result, nil
}

// GetTriggeredWebJobHistory - Gets a triggered web job's history by its ID for an app, , or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// id - History ID.
// options - AppsClientGetTriggeredWebJobHistoryOptions contains the optional parameters for the AppsClient.GetTriggeredWebJobHistory
// method.
func (client *AppsClient) GetTriggeredWebJobHistory(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, options *AppsClientGetTriggeredWebJobHistoryOptions) (AppsClientGetTriggeredWebJobHistoryResponse, error) {
	req, err := client.getTriggeredWebJobHistoryCreateRequest(ctx, resourceGroupName, name, webJobName, id, options)
	if err != nil {
		return AppsClientGetTriggeredWebJobHistoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetTriggeredWebJobHistoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetTriggeredWebJobHistoryResponse{}, runtime.NewResponseError(resp)
	}
	return client.getTriggeredWebJobHistoryHandleResponse(resp)
}

// getTriggeredWebJobHistoryCreateRequest creates the GetTriggeredWebJobHistory request.
func (client *AppsClient) getTriggeredWebJobHistoryCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, options *AppsClientGetTriggeredWebJobHistoryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTriggeredWebJobHistoryHandleResponse handles the GetTriggeredWebJobHistory response.
func (client *AppsClient) getTriggeredWebJobHistoryHandleResponse(resp *http.Response) (AppsClientGetTriggeredWebJobHistoryResponse, error) {
	result := AppsClientGetTriggeredWebJobHistoryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredJobHistory); err != nil {
		return AppsClientGetTriggeredWebJobHistoryResponse{}, err
	}
	return result, nil
}

// GetTriggeredWebJobHistorySlot - Gets a triggered web job's history by its ID for an app, , or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// id - History ID.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientGetTriggeredWebJobHistorySlotOptions contains the optional parameters for the AppsClient.GetTriggeredWebJobHistorySlot
// method.
func (client *AppsClient) GetTriggeredWebJobHistorySlot(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, slot string, options *AppsClientGetTriggeredWebJobHistorySlotOptions) (AppsClientGetTriggeredWebJobHistorySlotResponse, error) {
	req, err := client.getTriggeredWebJobHistorySlotCreateRequest(ctx, resourceGroupName, name, webJobName, id, slot, options)
	if err != nil {
		return AppsClientGetTriggeredWebJobHistorySlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetTriggeredWebJobHistorySlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetTriggeredWebJobHistorySlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getTriggeredWebJobHistorySlotHandleResponse(resp)
}

// getTriggeredWebJobHistorySlotCreateRequest creates the GetTriggeredWebJobHistorySlot request.
func (client *AppsClient) getTriggeredWebJobHistorySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, slot string, options *AppsClientGetTriggeredWebJobHistorySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTriggeredWebJobHistorySlotHandleResponse handles the GetTriggeredWebJobHistorySlot response.
func (client *AppsClient) getTriggeredWebJobHistorySlotHandleResponse(resp *http.Response) (AppsClientGetTriggeredWebJobHistorySlotResponse, error) {
	result := AppsClientGetTriggeredWebJobHistorySlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredJobHistory); err != nil {
		return AppsClientGetTriggeredWebJobHistorySlotResponse{}, err
	}
	return result, nil
}

// GetTriggeredWebJobSlot - Gets a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientGetTriggeredWebJobSlotOptions contains the optional parameters for the AppsClient.GetTriggeredWebJobSlot
// method.
func (client *AppsClient) GetTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientGetTriggeredWebJobSlotOptions) (AppsClientGetTriggeredWebJobSlotResponse, error) {
	req, err := client.getTriggeredWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return AppsClientGetTriggeredWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetTriggeredWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetTriggeredWebJobSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getTriggeredWebJobSlotHandleResponse(resp)
}

// getTriggeredWebJobSlotCreateRequest creates the GetTriggeredWebJobSlot request.
func (client *AppsClient) getTriggeredWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientGetTriggeredWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTriggeredWebJobSlotHandleResponse handles the GetTriggeredWebJobSlot response.
func (client *AppsClient) getTriggeredWebJobSlotHandleResponse(resp *http.Response) (AppsClientGetTriggeredWebJobSlotResponse, error) {
	result := AppsClientGetTriggeredWebJobSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredWebJob); err != nil {
		return AppsClientGetTriggeredWebJobSlotResponse{}, err
	}
	return result, nil
}

// GetVnetConnection - Gets a virtual network the app (or deployment slot) is connected to by name.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of the virtual network.
// options - AppsClientGetVnetConnectionOptions contains the optional parameters for the AppsClient.GetVnetConnection method.
func (client *AppsClient) GetVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, options *AppsClientGetVnetConnectionOptions) (AppsClientGetVnetConnectionResponse, error) {
	req, err := client.getVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, options)
	if err != nil {
		return AppsClientGetVnetConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetVnetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetVnetConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getVnetConnectionHandleResponse(resp)
}

// getVnetConnectionCreateRequest creates the GetVnetConnection request.
func (client *AppsClient) getVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, options *AppsClientGetVnetConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVnetConnectionHandleResponse handles the GetVnetConnection response.
func (client *AppsClient) getVnetConnectionHandleResponse(resp *http.Response) (AppsClientGetVnetConnectionResponse, error) {
	result := AppsClientGetVnetConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfo); err != nil {
		return AppsClientGetVnetConnectionResponse{}, err
	}
	return result, nil
}

// GetVnetConnectionGateway - Gets an app's Virtual Network gateway.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of the Virtual Network.
// gatewayName - Name of the gateway. Currently, the only supported string is "primary".
// options - AppsClientGetVnetConnectionGatewayOptions contains the optional parameters for the AppsClient.GetVnetConnectionGateway
// method.
func (client *AppsClient) GetVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, options *AppsClientGetVnetConnectionGatewayOptions) (AppsClientGetVnetConnectionGatewayResponse, error) {
	req, err := client.getVnetConnectionGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, options)
	if err != nil {
		return AppsClientGetVnetConnectionGatewayResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetVnetConnectionGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetVnetConnectionGatewayResponse{}, runtime.NewResponseError(resp)
	}
	return client.getVnetConnectionGatewayHandleResponse(resp)
}

// getVnetConnectionGatewayCreateRequest creates the GetVnetConnectionGateway request.
func (client *AppsClient) getVnetConnectionGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, options *AppsClientGetVnetConnectionGatewayOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVnetConnectionGatewayHandleResponse handles the GetVnetConnectionGateway response.
func (client *AppsClient) getVnetConnectionGatewayHandleResponse(resp *http.Response) (AppsClientGetVnetConnectionGatewayResponse, error) {
	result := AppsClientGetVnetConnectionGatewayResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return AppsClientGetVnetConnectionGatewayResponse{}, err
	}
	return result, nil
}

// GetVnetConnectionGatewaySlot - Gets an app's Virtual Network gateway.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of the Virtual Network.
// gatewayName - Name of the gateway. Currently, the only supported string is "primary".
// slot - Name of the deployment slot. If a slot is not specified, the API will get a gateway for the production slot's Virtual
// Network.
// options - AppsClientGetVnetConnectionGatewaySlotOptions contains the optional parameters for the AppsClient.GetVnetConnectionGatewaySlot
// method.
func (client *AppsClient) GetVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, options *AppsClientGetVnetConnectionGatewaySlotOptions) (AppsClientGetVnetConnectionGatewaySlotResponse, error) {
	req, err := client.getVnetConnectionGatewaySlotCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, slot, options)
	if err != nil {
		return AppsClientGetVnetConnectionGatewaySlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetVnetConnectionGatewaySlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientGetVnetConnectionGatewaySlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getVnetConnectionGatewaySlotHandleResponse(resp)
}

// getVnetConnectionGatewaySlotCreateRequest creates the GetVnetConnectionGatewaySlot request.
func (client *AppsClient) getVnetConnectionGatewaySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, options *AppsClientGetVnetConnectionGatewaySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVnetConnectionGatewaySlotHandleResponse handles the GetVnetConnectionGatewaySlot response.
func (client *AppsClient) getVnetConnectionGatewaySlotHandleResponse(resp *http.Response) (AppsClientGetVnetConnectionGatewaySlotResponse, error) {
	result := AppsClientGetVnetConnectionGatewaySlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return AppsClientGetVnetConnectionGatewaySlotResponse{}, err
	}
	return result, nil
}

// GetVnetConnectionSlot - Gets a virtual network the app (or deployment slot) is connected to by name.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of the virtual network.
// slot - Name of the deployment slot. If a slot is not specified, the API will get the named virtual network for the production
// slot.
// options - AppsClientGetVnetConnectionSlotOptions contains the optional parameters for the AppsClient.GetVnetConnectionSlot
// method.
func (client *AppsClient) GetVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *AppsClientGetVnetConnectionSlotOptions) (AppsClientGetVnetConnectionSlotResponse, error) {
	req, err := client.getVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, options)
	if err != nil {
		return AppsClientGetVnetConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetVnetConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetVnetConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getVnetConnectionSlotHandleResponse(resp)
}

// getVnetConnectionSlotCreateRequest creates the GetVnetConnectionSlot request.
func (client *AppsClient) getVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *AppsClientGetVnetConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVnetConnectionSlotHandleResponse handles the GetVnetConnectionSlot response.
func (client *AppsClient) getVnetConnectionSlotHandleResponse(resp *http.Response) (AppsClientGetVnetConnectionSlotResponse, error) {
	result := AppsClientGetVnetConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfo); err != nil {
		return AppsClientGetVnetConnectionSlotResponse{}, err
	}
	return result, nil
}

// GetWebJob - Get webjob information for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of the web job.
// options - AppsClientGetWebJobOptions contains the optional parameters for the AppsClient.GetWebJob method.
func (client *AppsClient) GetWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientGetWebJobOptions) (AppsClientGetWebJobResponse, error) {
	req, err := client.getWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return AppsClientGetWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetWebJobResponse{}, runtime.NewResponseError(resp)
	}
	return client.getWebJobHandleResponse(resp)
}

// getWebJobCreateRequest creates the GetWebJob request.
func (client *AppsClient) getWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientGetWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getWebJobHandleResponse handles the GetWebJob response.
func (client *AppsClient) getWebJobHandleResponse(resp *http.Response) (AppsClientGetWebJobResponse, error) {
	result := AppsClientGetWebJobResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Job); err != nil {
		return AppsClientGetWebJobResponse{}, err
	}
	return result, nil
}

// GetWebJobSlot - Get webjob information for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of the web job.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// options - AppsClientGetWebJobSlotOptions contains the optional parameters for the AppsClient.GetWebJobSlot method.
func (client *AppsClient) GetWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientGetWebJobSlotOptions) (AppsClientGetWebJobSlotResponse, error) {
	req, err := client.getWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return AppsClientGetWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientGetWebJobSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.getWebJobSlotHandleResponse(resp)
}

// getWebJobSlotCreateRequest creates the GetWebJobSlot request.
func (client *AppsClient) getWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientGetWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getWebJobSlotHandleResponse handles the GetWebJobSlot response.
func (client *AppsClient) getWebJobSlotHandleResponse(resp *http.Response) (AppsClientGetWebJobSlotResponse, error) {
	result := AppsClientGetWebJobSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Job); err != nil {
		return AppsClientGetWebJobSlotResponse{}, err
	}
	return result, nil
}

// GetWebSiteContainerLogs - Gets the last lines of docker logs for the given site
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// options - AppsClientGetWebSiteContainerLogsOptions contains the optional parameters for the AppsClient.GetWebSiteContainerLogs
// method.
func (client *AppsClient) GetWebSiteContainerLogs(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetWebSiteContainerLogsOptions) (AppsClientGetWebSiteContainerLogsResponse, error) {
	req, err := client.getWebSiteContainerLogsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientGetWebSiteContainerLogsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetWebSiteContainerLogsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientGetWebSiteContainerLogsResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientGetWebSiteContainerLogsResponse{Body: resp.Body}, nil
}

// getWebSiteContainerLogsCreateRequest creates the GetWebSiteContainerLogs request.
func (client *AppsClient) getWebSiteContainerLogsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientGetWebSiteContainerLogsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/octet-stream"}
	return req, nil
}

// GetWebSiteContainerLogsSlot - Gets the last lines of docker logs for the given site
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// options - AppsClientGetWebSiteContainerLogsSlotOptions contains the optional parameters for the AppsClient.GetWebSiteContainerLogsSlot
// method.
func (client *AppsClient) GetWebSiteContainerLogsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetWebSiteContainerLogsSlotOptions) (AppsClientGetWebSiteContainerLogsSlotResponse, error) {
	req, err := client.getWebSiteContainerLogsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientGetWebSiteContainerLogsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientGetWebSiteContainerLogsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientGetWebSiteContainerLogsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientGetWebSiteContainerLogsSlotResponse{Body: resp.Body}, nil
}

// getWebSiteContainerLogsSlotCreateRequest creates the GetWebSiteContainerLogsSlot request.
func (client *AppsClient) getWebSiteContainerLogsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientGetWebSiteContainerLogsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/octet-stream"}
	return req, nil
}

// BeginInstallSiteExtension - Install site extension on a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// siteExtensionID - Site extension name.
// options - AppsClientBeginInstallSiteExtensionOptions contains the optional parameters for the AppsClient.BeginInstallSiteExtension
// method.
func (client *AppsClient) BeginInstallSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *AppsClientBeginInstallSiteExtensionOptions) (*runtime.Poller[AppsClientInstallSiteExtensionResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.installSiteExtension(ctx, resourceGroupName, name, siteExtensionID, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientInstallSiteExtensionResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientInstallSiteExtensionResponse](options.ResumeToken, client.pl, nil)
	}
}

// InstallSiteExtension - Install site extension on a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) installSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *AppsClientBeginInstallSiteExtensionOptions) (*http.Response, error) {
	req, err := client.installSiteExtensionCreateRequest(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusTooManyRequests) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// installSiteExtensionCreateRequest creates the InstallSiteExtension request.
func (client *AppsClient) installSiteExtensionCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *AppsClientBeginInstallSiteExtensionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginInstallSiteExtensionSlot - Install site extension on a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// siteExtensionID - Site extension name.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientBeginInstallSiteExtensionSlotOptions contains the optional parameters for the AppsClient.BeginInstallSiteExtensionSlot
// method.
func (client *AppsClient) BeginInstallSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *AppsClientBeginInstallSiteExtensionSlotOptions) (*runtime.Poller[AppsClientInstallSiteExtensionSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.installSiteExtensionSlot(ctx, resourceGroupName, name, siteExtensionID, slot, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientInstallSiteExtensionSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientInstallSiteExtensionSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// InstallSiteExtensionSlot - Install site extension on a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) installSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *AppsClientBeginInstallSiteExtensionSlotOptions) (*http.Response, error) {
	req, err := client.installSiteExtensionSlotCreateRequest(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusTooManyRequests) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// installSiteExtensionSlotCreateRequest creates the InstallSiteExtensionSlot request.
func (client *AppsClient) installSiteExtensionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *AppsClientBeginInstallSiteExtensionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// IsCloneable - Shows whether an app can be cloned to another resource group or subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientIsCloneableOptions contains the optional parameters for the AppsClient.IsCloneable method.
func (client *AppsClient) IsCloneable(ctx context.Context, resourceGroupName string, name string, options *AppsClientIsCloneableOptions) (AppsClientIsCloneableResponse, error) {
	req, err := client.isCloneableCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientIsCloneableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientIsCloneableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientIsCloneableResponse{}, runtime.NewResponseError(resp)
	}
	return client.isCloneableHandleResponse(resp)
}

// isCloneableCreateRequest creates the IsCloneable request.
func (client *AppsClient) isCloneableCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientIsCloneableOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// isCloneableHandleResponse handles the IsCloneable response.
func (client *AppsClient) isCloneableHandleResponse(resp *http.Response) (AppsClientIsCloneableResponse, error) {
	result := AppsClientIsCloneableResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteCloneability); err != nil {
		return AppsClientIsCloneableResponse{}, err
	}
	return result, nil
}

// IsCloneableSlot - Shows whether an app can be cloned to another resource group or subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. By default, this API returns information on the production slot.
// options - AppsClientIsCloneableSlotOptions contains the optional parameters for the AppsClient.IsCloneableSlot method.
func (client *AppsClient) IsCloneableSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientIsCloneableSlotOptions) (AppsClientIsCloneableSlotResponse, error) {
	req, err := client.isCloneableSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientIsCloneableSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientIsCloneableSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientIsCloneableSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.isCloneableSlotHandleResponse(resp)
}

// isCloneableSlotCreateRequest creates the IsCloneableSlot request.
func (client *AppsClient) isCloneableSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientIsCloneableSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// isCloneableSlotHandleResponse handles the IsCloneableSlot response.
func (client *AppsClient) isCloneableSlotHandleResponse(resp *http.Response) (AppsClientIsCloneableSlotResponse, error) {
	result := AppsClientIsCloneableSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteCloneability); err != nil {
		return AppsClientIsCloneableSlotResponse{}, err
	}
	return result, nil
}

// NewListPager - Get all apps for a subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// options - AppsClientListOptions contains the optional parameters for the AppsClient.List method.
func (client *AppsClient) NewListPager(options *AppsClientListOptions) *runtime.Pager[AppsClientListResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListResponse]{
		More: func(page AppsClientListResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListResponse) (AppsClientListResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listCreateRequest(ctx, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListResponse{}, runtime.NewResponseError(resp)
			}
			return client.listHandleResponse(resp)
		},
	})
}

// listCreateRequest creates the List request.
func (client *AppsClient) listCreateRequest(ctx context.Context, options *AppsClientListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/sites"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHandleResponse handles the List response.
func (client *AppsClient) listHandleResponse(resp *http.Response) (AppsClientListResponse, error) {
	result := AppsClientListResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppCollection); err != nil {
		return AppsClientListResponse{}, err
	}
	return result, nil
}

// ListApplicationSettings - Gets the application settings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListApplicationSettingsOptions contains the optional parameters for the AppsClient.ListApplicationSettings
// method.
func (client *AppsClient) ListApplicationSettings(ctx context.Context, resourceGroupName string, name string, options *AppsClientListApplicationSettingsOptions) (AppsClientListApplicationSettingsResponse, error) {
	req, err := client.listApplicationSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListApplicationSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListApplicationSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListApplicationSettingsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listApplicationSettingsHandleResponse(resp)
}

// listApplicationSettingsCreateRequest creates the ListApplicationSettings request.
func (client *AppsClient) listApplicationSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListApplicationSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listApplicationSettingsHandleResponse handles the ListApplicationSettings response.
func (client *AppsClient) listApplicationSettingsHandleResponse(resp *http.Response) (AppsClientListApplicationSettingsResponse, error) {
	result := AppsClientListApplicationSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return AppsClientListApplicationSettingsResponse{}, err
	}
	return result, nil
}

// ListApplicationSettingsSlot - Gets the application settings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get the application settings for the production
// slot.
// options - AppsClientListApplicationSettingsSlotOptions contains the optional parameters for the AppsClient.ListApplicationSettingsSlot
// method.
func (client *AppsClient) ListApplicationSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListApplicationSettingsSlotOptions) (AppsClientListApplicationSettingsSlotResponse, error) {
	req, err := client.listApplicationSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientListApplicationSettingsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListApplicationSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListApplicationSettingsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listApplicationSettingsSlotHandleResponse(resp)
}

// listApplicationSettingsSlotCreateRequest creates the ListApplicationSettingsSlot request.
func (client *AppsClient) listApplicationSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListApplicationSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listApplicationSettingsSlotHandleResponse handles the ListApplicationSettingsSlot response.
func (client *AppsClient) listApplicationSettingsSlotHandleResponse(resp *http.Response) (AppsClientListApplicationSettingsSlotResponse, error) {
	result := AppsClientListApplicationSettingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return AppsClientListApplicationSettingsSlotResponse{}, err
	}
	return result, nil
}

// ListAzureStorageAccounts - Gets the Azure storage account configurations of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListAzureStorageAccountsOptions contains the optional parameters for the AppsClient.ListAzureStorageAccounts
// method.
func (client *AppsClient) ListAzureStorageAccounts(ctx context.Context, resourceGroupName string, name string, options *AppsClientListAzureStorageAccountsOptions) (AppsClientListAzureStorageAccountsResponse, error) {
	req, err := client.listAzureStorageAccountsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListAzureStorageAccountsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListAzureStorageAccountsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListAzureStorageAccountsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listAzureStorageAccountsHandleResponse(resp)
}

// listAzureStorageAccountsCreateRequest creates the ListAzureStorageAccounts request.
func (client *AppsClient) listAzureStorageAccountsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListAzureStorageAccountsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAzureStorageAccountsHandleResponse handles the ListAzureStorageAccounts response.
func (client *AppsClient) listAzureStorageAccountsHandleResponse(resp *http.Response) (AppsClientListAzureStorageAccountsResponse, error) {
	result := AppsClientListAzureStorageAccountsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AzureStoragePropertyDictionaryResource); err != nil {
		return AppsClientListAzureStorageAccountsResponse{}, err
	}
	return result, nil
}

// ListAzureStorageAccountsSlot - Gets the Azure storage account configurations of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will update the Azure storage account configurations
// for the production slot.
// options - AppsClientListAzureStorageAccountsSlotOptions contains the optional parameters for the AppsClient.ListAzureStorageAccountsSlot
// method.
func (client *AppsClient) ListAzureStorageAccountsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListAzureStorageAccountsSlotOptions) (AppsClientListAzureStorageAccountsSlotResponse, error) {
	req, err := client.listAzureStorageAccountsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientListAzureStorageAccountsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListAzureStorageAccountsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListAzureStorageAccountsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listAzureStorageAccountsSlotHandleResponse(resp)
}

// listAzureStorageAccountsSlotCreateRequest creates the ListAzureStorageAccountsSlot request.
func (client *AppsClient) listAzureStorageAccountsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListAzureStorageAccountsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAzureStorageAccountsSlotHandleResponse handles the ListAzureStorageAccountsSlot response.
func (client *AppsClient) listAzureStorageAccountsSlotHandleResponse(resp *http.Response) (AppsClientListAzureStorageAccountsSlotResponse, error) {
	result := AppsClientListAzureStorageAccountsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AzureStoragePropertyDictionaryResource); err != nil {
		return AppsClientListAzureStorageAccountsSlotResponse{}, err
	}
	return result, nil
}

// ListBackupStatusSecrets - Gets status of a web app backup that may be in progress, including secrets associated with the
// backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new
// URL is passed in the request body.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// backupID - ID of backup.
// request - Information on backup request.
// options - AppsClientListBackupStatusSecretsOptions contains the optional parameters for the AppsClient.ListBackupStatusSecrets
// method.
func (client *AppsClient) ListBackupStatusSecrets(ctx context.Context, resourceGroupName string, name string, backupID string, request BackupRequest, options *AppsClientListBackupStatusSecretsOptions) (AppsClientListBackupStatusSecretsResponse, error) {
	req, err := client.listBackupStatusSecretsCreateRequest(ctx, resourceGroupName, name, backupID, request, options)
	if err != nil {
		return AppsClientListBackupStatusSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListBackupStatusSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListBackupStatusSecretsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listBackupStatusSecretsHandleResponse(resp)
}

// listBackupStatusSecretsCreateRequest creates the ListBackupStatusSecrets request.
func (client *AppsClient) listBackupStatusSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, request BackupRequest, options *AppsClientListBackupStatusSecretsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, request)
}

// listBackupStatusSecretsHandleResponse handles the ListBackupStatusSecrets response.
func (client *AppsClient) listBackupStatusSecretsHandleResponse(resp *http.Response) (AppsClientListBackupStatusSecretsResponse, error) {
	result := AppsClientListBackupStatusSecretsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return AppsClientListBackupStatusSecretsResponse{}, err
	}
	return result, nil
}

// ListBackupStatusSecretsSlot - Gets status of a web app backup that may be in progress, including secrets associated with
// the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new
// URL is passed in the request body.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// backupID - ID of backup.
// slot - Name of web app slot. If not specified then will default to production slot.
// request - Information on backup request.
// options - AppsClientListBackupStatusSecretsSlotOptions contains the optional parameters for the AppsClient.ListBackupStatusSecretsSlot
// method.
func (client *AppsClient) ListBackupStatusSecretsSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request BackupRequest, options *AppsClientListBackupStatusSecretsSlotOptions) (AppsClientListBackupStatusSecretsSlotResponse, error) {
	req, err := client.listBackupStatusSecretsSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, request, options)
	if err != nil {
		return AppsClientListBackupStatusSecretsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListBackupStatusSecretsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListBackupStatusSecretsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listBackupStatusSecretsSlotHandleResponse(resp)
}

// listBackupStatusSecretsSlotCreateRequest creates the ListBackupStatusSecretsSlot request.
func (client *AppsClient) listBackupStatusSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request BackupRequest, options *AppsClientListBackupStatusSecretsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, request)
}

// listBackupStatusSecretsSlotHandleResponse handles the ListBackupStatusSecretsSlot response.
func (client *AppsClient) listBackupStatusSecretsSlotHandleResponse(resp *http.Response) (AppsClientListBackupStatusSecretsSlotResponse, error) {
	result := AppsClientListBackupStatusSecretsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return AppsClientListBackupStatusSecretsSlotResponse{}, err
	}
	return result, nil
}

// NewListBackupsPager - Gets existing backups of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListBackupsOptions contains the optional parameters for the AppsClient.ListBackups method.
func (client *AppsClient) NewListBackupsPager(resourceGroupName string, name string, options *AppsClientListBackupsOptions) *runtime.Pager[AppsClientListBackupsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListBackupsResponse]{
		More: func(page AppsClientListBackupsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListBackupsResponse) (AppsClientListBackupsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listBackupsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListBackupsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListBackupsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListBackupsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listBackupsHandleResponse(resp)
		},
	})
}

// listBackupsCreateRequest creates the ListBackups request.
func (client *AppsClient) listBackupsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListBackupsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listBackupsHandleResponse handles the ListBackups response.
func (client *AppsClient) listBackupsHandleResponse(resp *http.Response) (AppsClientListBackupsResponse, error) {
	result := AppsClientListBackupsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItemCollection); err != nil {
		return AppsClientListBackupsResponse{}, err
	}
	return result, nil
}

// NewListBackupsSlotPager - Gets existing backups of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
// options - AppsClientListBackupsSlotOptions contains the optional parameters for the AppsClient.ListBackupsSlot method.
func (client *AppsClient) NewListBackupsSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListBackupsSlotOptions) *runtime.Pager[AppsClientListBackupsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListBackupsSlotResponse]{
		More: func(page AppsClientListBackupsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListBackupsSlotResponse) (AppsClientListBackupsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listBackupsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListBackupsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListBackupsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListBackupsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listBackupsSlotHandleResponse(resp)
		},
	})
}

// listBackupsSlotCreateRequest creates the ListBackupsSlot request.
func (client *AppsClient) listBackupsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListBackupsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listBackupsSlotHandleResponse handles the ListBackupsSlot response.
func (client *AppsClient) listBackupsSlotHandleResponse(resp *http.Response) (AppsClientListBackupsSlotResponse, error) {
	result := AppsClientListBackupsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItemCollection); err != nil {
		return AppsClientListBackupsSlotResponse{}, err
	}
	return result, nil
}

// NewListByResourceGroupPager - Gets all web, mobile, and API apps in the specified resource group.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// options - AppsClientListByResourceGroupOptions contains the optional parameters for the AppsClient.ListByResourceGroup
// method.
func (client *AppsClient) NewListByResourceGroupPager(resourceGroupName string, options *AppsClientListByResourceGroupOptions) *runtime.Pager[AppsClientListByResourceGroupResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListByResourceGroupResponse]{
		More: func(page AppsClientListByResourceGroupResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListByResourceGroupResponse) (AppsClientListByResourceGroupResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listByResourceGroupCreateRequest(ctx, resourceGroupName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListByResourceGroupResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListByResourceGroupResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
			}
			return client.listByResourceGroupHandleResponse(resp)
		},
	})
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *AppsClient) listByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *AppsClientListByResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.IncludeSlots != nil {
		reqQP.Set("includeSlots", strconv.FormatBool(*options.IncludeSlots))
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *AppsClient) listByResourceGroupHandleResponse(resp *http.Response) (AppsClientListByResourceGroupResponse, error) {
	result := AppsClientListByResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppCollection); err != nil {
		return AppsClientListByResourceGroupResponse{}, err
	}
	return result, nil
}

// NewListConfigurationSnapshotInfoPager - Gets a list of web app configuration snapshots identifiers. Each element of the
// list contains a timestamp and the ID of the snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListConfigurationSnapshotInfoOptions contains the optional parameters for the AppsClient.ListConfigurationSnapshotInfo
// method.
func (client *AppsClient) NewListConfigurationSnapshotInfoPager(resourceGroupName string, name string, options *AppsClientListConfigurationSnapshotInfoOptions) *runtime.Pager[AppsClientListConfigurationSnapshotInfoResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListConfigurationSnapshotInfoResponse]{
		More: func(page AppsClientListConfigurationSnapshotInfoResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListConfigurationSnapshotInfoResponse) (AppsClientListConfigurationSnapshotInfoResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listConfigurationSnapshotInfoCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListConfigurationSnapshotInfoResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListConfigurationSnapshotInfoResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListConfigurationSnapshotInfoResponse{}, runtime.NewResponseError(resp)
			}
			return client.listConfigurationSnapshotInfoHandleResponse(resp)
		},
	})
}

// listConfigurationSnapshotInfoCreateRequest creates the ListConfigurationSnapshotInfo request.
func (client *AppsClient) listConfigurationSnapshotInfoCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListConfigurationSnapshotInfoOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConfigurationSnapshotInfoHandleResponse handles the ListConfigurationSnapshotInfo response.
func (client *AppsClient) listConfigurationSnapshotInfoHandleResponse(resp *http.Response) (AppsClientListConfigurationSnapshotInfoResponse, error) {
	result := AppsClientListConfigurationSnapshotInfoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigurationSnapshotInfoCollection); err != nil {
		return AppsClientListConfigurationSnapshotInfoResponse{}, err
	}
	return result, nil
}

// NewListConfigurationSnapshotInfoSlotPager - Gets a list of web app configuration snapshots identifiers. Each element of
// the list contains a timestamp and the ID of the snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
// options - AppsClientListConfigurationSnapshotInfoSlotOptions contains the optional parameters for the AppsClient.ListConfigurationSnapshotInfoSlot
// method.
func (client *AppsClient) NewListConfigurationSnapshotInfoSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListConfigurationSnapshotInfoSlotOptions) *runtime.Pager[AppsClientListConfigurationSnapshotInfoSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListConfigurationSnapshotInfoSlotResponse]{
		More: func(page AppsClientListConfigurationSnapshotInfoSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListConfigurationSnapshotInfoSlotResponse) (AppsClientListConfigurationSnapshotInfoSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listConfigurationSnapshotInfoSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListConfigurationSnapshotInfoSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListConfigurationSnapshotInfoSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListConfigurationSnapshotInfoSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listConfigurationSnapshotInfoSlotHandleResponse(resp)
		},
	})
}

// listConfigurationSnapshotInfoSlotCreateRequest creates the ListConfigurationSnapshotInfoSlot request.
func (client *AppsClient) listConfigurationSnapshotInfoSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListConfigurationSnapshotInfoSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConfigurationSnapshotInfoSlotHandleResponse handles the ListConfigurationSnapshotInfoSlot response.
func (client *AppsClient) listConfigurationSnapshotInfoSlotHandleResponse(resp *http.Response) (AppsClientListConfigurationSnapshotInfoSlotResponse, error) {
	result := AppsClientListConfigurationSnapshotInfoSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigurationSnapshotInfoCollection); err != nil {
		return AppsClientListConfigurationSnapshotInfoSlotResponse{}, err
	}
	return result, nil
}

// NewListConfigurationsPager - List the configurations of an app
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListConfigurationsOptions contains the optional parameters for the AppsClient.ListConfigurations method.
func (client *AppsClient) NewListConfigurationsPager(resourceGroupName string, name string, options *AppsClientListConfigurationsOptions) *runtime.Pager[AppsClientListConfigurationsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListConfigurationsResponse]{
		More: func(page AppsClientListConfigurationsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListConfigurationsResponse) (AppsClientListConfigurationsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listConfigurationsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListConfigurationsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListConfigurationsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListConfigurationsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listConfigurationsHandleResponse(resp)
		},
	})
}

// listConfigurationsCreateRequest creates the ListConfigurations request.
func (client *AppsClient) listConfigurationsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListConfigurationsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConfigurationsHandleResponse handles the ListConfigurations response.
func (client *AppsClient) listConfigurationsHandleResponse(resp *http.Response) (AppsClientListConfigurationsResponse, error) {
	result := AppsClientListConfigurationsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResourceCollection); err != nil {
		return AppsClientListConfigurationsResponse{}, err
	}
	return result, nil
}

// NewListConfigurationsSlotPager - List the configurations of an app
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
// options - AppsClientListConfigurationsSlotOptions contains the optional parameters for the AppsClient.ListConfigurationsSlot
// method.
func (client *AppsClient) NewListConfigurationsSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListConfigurationsSlotOptions) *runtime.Pager[AppsClientListConfigurationsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListConfigurationsSlotResponse]{
		More: func(page AppsClientListConfigurationsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListConfigurationsSlotResponse) (AppsClientListConfigurationsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listConfigurationsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListConfigurationsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListConfigurationsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListConfigurationsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listConfigurationsSlotHandleResponse(resp)
		},
	})
}

// listConfigurationsSlotCreateRequest creates the ListConfigurationsSlot request.
func (client *AppsClient) listConfigurationsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListConfigurationsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConfigurationsSlotHandleResponse handles the ListConfigurationsSlot response.
func (client *AppsClient) listConfigurationsSlotHandleResponse(resp *http.Response) (AppsClientListConfigurationsSlotResponse, error) {
	result := AppsClientListConfigurationsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResourceCollection); err != nil {
		return AppsClientListConfigurationsSlotResponse{}, err
	}
	return result, nil
}

// ListConnectionStrings - Gets the connection strings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListConnectionStringsOptions contains the optional parameters for the AppsClient.ListConnectionStrings
// method.
func (client *AppsClient) ListConnectionStrings(ctx context.Context, resourceGroupName string, name string, options *AppsClientListConnectionStringsOptions) (AppsClientListConnectionStringsResponse, error) {
	req, err := client.listConnectionStringsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListConnectionStringsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListConnectionStringsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListConnectionStringsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listConnectionStringsHandleResponse(resp)
}

// listConnectionStringsCreateRequest creates the ListConnectionStrings request.
func (client *AppsClient) listConnectionStringsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListConnectionStringsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConnectionStringsHandleResponse handles the ListConnectionStrings response.
func (client *AppsClient) listConnectionStringsHandleResponse(resp *http.Response) (AppsClientListConnectionStringsResponse, error) {
	result := AppsClientListConnectionStringsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionStringDictionary); err != nil {
		return AppsClientListConnectionStringsResponse{}, err
	}
	return result, nil
}

// ListConnectionStringsSlot - Gets the connection strings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get the connection settings for the production
// slot.
// options - AppsClientListConnectionStringsSlotOptions contains the optional parameters for the AppsClient.ListConnectionStringsSlot
// method.
func (client *AppsClient) ListConnectionStringsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListConnectionStringsSlotOptions) (AppsClientListConnectionStringsSlotResponse, error) {
	req, err := client.listConnectionStringsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientListConnectionStringsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListConnectionStringsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListConnectionStringsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listConnectionStringsSlotHandleResponse(resp)
}

// listConnectionStringsSlotCreateRequest creates the ListConnectionStringsSlot request.
func (client *AppsClient) listConnectionStringsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListConnectionStringsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConnectionStringsSlotHandleResponse handles the ListConnectionStringsSlot response.
func (client *AppsClient) listConnectionStringsSlotHandleResponse(resp *http.Response) (AppsClientListConnectionStringsSlotResponse, error) {
	result := AppsClientListConnectionStringsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionStringDictionary); err != nil {
		return AppsClientListConnectionStringsSlotResponse{}, err
	}
	return result, nil
}

// NewListContinuousWebJobsPager - List continuous web jobs for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// options - AppsClientListContinuousWebJobsOptions contains the optional parameters for the AppsClient.ListContinuousWebJobs
// method.
func (client *AppsClient) NewListContinuousWebJobsPager(resourceGroupName string, name string, options *AppsClientListContinuousWebJobsOptions) *runtime.Pager[AppsClientListContinuousWebJobsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListContinuousWebJobsResponse]{
		More: func(page AppsClientListContinuousWebJobsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListContinuousWebJobsResponse) (AppsClientListContinuousWebJobsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listContinuousWebJobsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListContinuousWebJobsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListContinuousWebJobsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListContinuousWebJobsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listContinuousWebJobsHandleResponse(resp)
		},
	})
}

// listContinuousWebJobsCreateRequest creates the ListContinuousWebJobs request.
func (client *AppsClient) listContinuousWebJobsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListContinuousWebJobsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listContinuousWebJobsHandleResponse handles the ListContinuousWebJobs response.
func (client *AppsClient) listContinuousWebJobsHandleResponse(resp *http.Response) (AppsClientListContinuousWebJobsResponse, error) {
	result := AppsClientListContinuousWebJobsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContinuousWebJobCollection); err != nil {
		return AppsClientListContinuousWebJobsResponse{}, err
	}
	return result, nil
}

// NewListContinuousWebJobsSlotPager - List continuous web jobs for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientListContinuousWebJobsSlotOptions contains the optional parameters for the AppsClient.ListContinuousWebJobsSlot
// method.
func (client *AppsClient) NewListContinuousWebJobsSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListContinuousWebJobsSlotOptions) *runtime.Pager[AppsClientListContinuousWebJobsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListContinuousWebJobsSlotResponse]{
		More: func(page AppsClientListContinuousWebJobsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListContinuousWebJobsSlotResponse) (AppsClientListContinuousWebJobsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listContinuousWebJobsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListContinuousWebJobsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListContinuousWebJobsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListContinuousWebJobsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listContinuousWebJobsSlotHandleResponse(resp)
		},
	})
}

// listContinuousWebJobsSlotCreateRequest creates the ListContinuousWebJobsSlot request.
func (client *AppsClient) listContinuousWebJobsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListContinuousWebJobsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listContinuousWebJobsSlotHandleResponse handles the ListContinuousWebJobsSlot response.
func (client *AppsClient) listContinuousWebJobsSlotHandleResponse(resp *http.Response) (AppsClientListContinuousWebJobsSlotResponse, error) {
	result := AppsClientListContinuousWebJobsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContinuousWebJobCollection); err != nil {
		return AppsClientListContinuousWebJobsSlotResponse{}, err
	}
	return result, nil
}

// ListDeploymentLog - List deployment log for specific deployment for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// id - The ID of a specific deployment. This is the value of the name property in the JSON response from "GET /api/sites/{siteName}/deployments".
// options - AppsClientListDeploymentLogOptions contains the optional parameters for the AppsClient.ListDeploymentLog method.
func (client *AppsClient) ListDeploymentLog(ctx context.Context, resourceGroupName string, name string, id string, options *AppsClientListDeploymentLogOptions) (AppsClientListDeploymentLogResponse, error) {
	req, err := client.listDeploymentLogCreateRequest(ctx, resourceGroupName, name, id, options)
	if err != nil {
		return AppsClientListDeploymentLogResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListDeploymentLogResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListDeploymentLogResponse{}, runtime.NewResponseError(resp)
	}
	return client.listDeploymentLogHandleResponse(resp)
}

// listDeploymentLogCreateRequest creates the ListDeploymentLog request.
func (client *AppsClient) listDeploymentLogCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, options *AppsClientListDeploymentLogOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDeploymentLogHandleResponse handles the ListDeploymentLog response.
func (client *AppsClient) listDeploymentLogHandleResponse(resp *http.Response) (AppsClientListDeploymentLogResponse, error) {
	result := AppsClientListDeploymentLogResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return AppsClientListDeploymentLogResponse{}, err
	}
	return result, nil
}

// ListDeploymentLogSlot - List deployment log for specific deployment for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// id - The ID of a specific deployment. This is the value of the name property in the JSON response from "GET /api/sites/{siteName}/deployments".
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// options - AppsClientListDeploymentLogSlotOptions contains the optional parameters for the AppsClient.ListDeploymentLogSlot
// method.
func (client *AppsClient) ListDeploymentLogSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *AppsClientListDeploymentLogSlotOptions) (AppsClientListDeploymentLogSlotResponse, error) {
	req, err := client.listDeploymentLogSlotCreateRequest(ctx, resourceGroupName, name, id, slot, options)
	if err != nil {
		return AppsClientListDeploymentLogSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListDeploymentLogSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListDeploymentLogSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listDeploymentLogSlotHandleResponse(resp)
}

// listDeploymentLogSlotCreateRequest creates the ListDeploymentLogSlot request.
func (client *AppsClient) listDeploymentLogSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *AppsClientListDeploymentLogSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDeploymentLogSlotHandleResponse handles the ListDeploymentLogSlot response.
func (client *AppsClient) listDeploymentLogSlotHandleResponse(resp *http.Response) (AppsClientListDeploymentLogSlotResponse, error) {
	result := AppsClientListDeploymentLogSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return AppsClientListDeploymentLogSlotResponse{}, err
	}
	return result, nil
}

// NewListDeploymentsPager - List deployments for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListDeploymentsOptions contains the optional parameters for the AppsClient.ListDeployments method.
func (client *AppsClient) NewListDeploymentsPager(resourceGroupName string, name string, options *AppsClientListDeploymentsOptions) *runtime.Pager[AppsClientListDeploymentsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListDeploymentsResponse]{
		More: func(page AppsClientListDeploymentsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListDeploymentsResponse) (AppsClientListDeploymentsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listDeploymentsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListDeploymentsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListDeploymentsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListDeploymentsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listDeploymentsHandleResponse(resp)
		},
	})
}

// listDeploymentsCreateRequest creates the ListDeployments request.
func (client *AppsClient) listDeploymentsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListDeploymentsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDeploymentsHandleResponse handles the ListDeployments response.
func (client *AppsClient) listDeploymentsHandleResponse(resp *http.Response) (AppsClientListDeploymentsResponse, error) {
	result := AppsClientListDeploymentsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentCollection); err != nil {
		return AppsClientListDeploymentsResponse{}, err
	}
	return result, nil
}

// NewListDeploymentsSlotPager - List deployments for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// options - AppsClientListDeploymentsSlotOptions contains the optional parameters for the AppsClient.ListDeploymentsSlot
// method.
func (client *AppsClient) NewListDeploymentsSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListDeploymentsSlotOptions) *runtime.Pager[AppsClientListDeploymentsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListDeploymentsSlotResponse]{
		More: func(page AppsClientListDeploymentsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListDeploymentsSlotResponse) (AppsClientListDeploymentsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listDeploymentsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListDeploymentsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListDeploymentsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListDeploymentsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listDeploymentsSlotHandleResponse(resp)
		},
	})
}

// listDeploymentsSlotCreateRequest creates the ListDeploymentsSlot request.
func (client *AppsClient) listDeploymentsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListDeploymentsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDeploymentsSlotHandleResponse handles the ListDeploymentsSlot response.
func (client *AppsClient) listDeploymentsSlotHandleResponse(resp *http.Response) (AppsClientListDeploymentsSlotResponse, error) {
	result := AppsClientListDeploymentsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentCollection); err != nil {
		return AppsClientListDeploymentsSlotResponse{}, err
	}
	return result, nil
}

// NewListDomainOwnershipIdentifiersPager - Lists ownership identifiers for domain associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListDomainOwnershipIdentifiersOptions contains the optional parameters for the AppsClient.ListDomainOwnershipIdentifiers
// method.
func (client *AppsClient) NewListDomainOwnershipIdentifiersPager(resourceGroupName string, name string, options *AppsClientListDomainOwnershipIdentifiersOptions) *runtime.Pager[AppsClientListDomainOwnershipIdentifiersResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListDomainOwnershipIdentifiersResponse]{
		More: func(page AppsClientListDomainOwnershipIdentifiersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListDomainOwnershipIdentifiersResponse) (AppsClientListDomainOwnershipIdentifiersResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listDomainOwnershipIdentifiersCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListDomainOwnershipIdentifiersResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListDomainOwnershipIdentifiersResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListDomainOwnershipIdentifiersResponse{}, runtime.NewResponseError(resp)
			}
			return client.listDomainOwnershipIdentifiersHandleResponse(resp)
		},
	})
}

// listDomainOwnershipIdentifiersCreateRequest creates the ListDomainOwnershipIdentifiers request.
func (client *AppsClient) listDomainOwnershipIdentifiersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListDomainOwnershipIdentifiersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDomainOwnershipIdentifiersHandleResponse handles the ListDomainOwnershipIdentifiers response.
func (client *AppsClient) listDomainOwnershipIdentifiersHandleResponse(resp *http.Response) (AppsClientListDomainOwnershipIdentifiersResponse, error) {
	result := AppsClientListDomainOwnershipIdentifiersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IdentifierCollection); err != nil {
		return AppsClientListDomainOwnershipIdentifiersResponse{}, err
	}
	return result, nil
}

// NewListDomainOwnershipIdentifiersSlotPager - Lists ownership identifiers for domain associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
// options - AppsClientListDomainOwnershipIdentifiersSlotOptions contains the optional parameters for the AppsClient.ListDomainOwnershipIdentifiersSlot
// method.
func (client *AppsClient) NewListDomainOwnershipIdentifiersSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListDomainOwnershipIdentifiersSlotOptions) *runtime.Pager[AppsClientListDomainOwnershipIdentifiersSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListDomainOwnershipIdentifiersSlotResponse]{
		More: func(page AppsClientListDomainOwnershipIdentifiersSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListDomainOwnershipIdentifiersSlotResponse) (AppsClientListDomainOwnershipIdentifiersSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listDomainOwnershipIdentifiersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListDomainOwnershipIdentifiersSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListDomainOwnershipIdentifiersSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListDomainOwnershipIdentifiersSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listDomainOwnershipIdentifiersSlotHandleResponse(resp)
		},
	})
}

// listDomainOwnershipIdentifiersSlotCreateRequest creates the ListDomainOwnershipIdentifiersSlot request.
func (client *AppsClient) listDomainOwnershipIdentifiersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListDomainOwnershipIdentifiersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDomainOwnershipIdentifiersSlotHandleResponse handles the ListDomainOwnershipIdentifiersSlot response.
func (client *AppsClient) listDomainOwnershipIdentifiersSlotHandleResponse(resp *http.Response) (AppsClientListDomainOwnershipIdentifiersSlotResponse, error) {
	result := AppsClientListDomainOwnershipIdentifiersSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IdentifierCollection); err != nil {
		return AppsClientListDomainOwnershipIdentifiersSlotResponse{}, err
	}
	return result, nil
}

// ListFunctionKeys - Get function keys for a function in a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - Function name.
// options - AppsClientListFunctionKeysOptions contains the optional parameters for the AppsClient.ListFunctionKeys method.
func (client *AppsClient) ListFunctionKeys(ctx context.Context, resourceGroupName string, name string, functionName string, options *AppsClientListFunctionKeysOptions) (AppsClientListFunctionKeysResponse, error) {
	req, err := client.listFunctionKeysCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return AppsClientListFunctionKeysResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListFunctionKeysResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListFunctionKeysResponse{}, runtime.NewResponseError(resp)
	}
	return client.listFunctionKeysHandleResponse(resp)
}

// listFunctionKeysCreateRequest creates the ListFunctionKeys request.
func (client *AppsClient) listFunctionKeysCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *AppsClientListFunctionKeysOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFunctionKeysHandleResponse handles the ListFunctionKeys response.
func (client *AppsClient) listFunctionKeysHandleResponse(resp *http.Response) (AppsClientListFunctionKeysResponse, error) {
	result := AppsClientListFunctionKeysResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return AppsClientListFunctionKeysResponse{}, err
	}
	return result, nil
}

// ListFunctionKeysSlot - Get function keys for a function in a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - Function name.
// slot - Name of the deployment slot.
// options - AppsClientListFunctionKeysSlotOptions contains the optional parameters for the AppsClient.ListFunctionKeysSlot
// method.
func (client *AppsClient) ListFunctionKeysSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *AppsClientListFunctionKeysSlotOptions) (AppsClientListFunctionKeysSlotResponse, error) {
	req, err := client.listFunctionKeysSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return AppsClientListFunctionKeysSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListFunctionKeysSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListFunctionKeysSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listFunctionKeysSlotHandleResponse(resp)
}

// listFunctionKeysSlotCreateRequest creates the ListFunctionKeysSlot request.
func (client *AppsClient) listFunctionKeysSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *AppsClientListFunctionKeysSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFunctionKeysSlotHandleResponse handles the ListFunctionKeysSlot response.
func (client *AppsClient) listFunctionKeysSlotHandleResponse(resp *http.Response) (AppsClientListFunctionKeysSlotResponse, error) {
	result := AppsClientListFunctionKeysSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return AppsClientListFunctionKeysSlotResponse{}, err
	}
	return result, nil
}

// ListFunctionSecrets - Get function secrets for a function in a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - Function name.
// options - AppsClientListFunctionSecretsOptions contains the optional parameters for the AppsClient.ListFunctionSecrets
// method.
func (client *AppsClient) ListFunctionSecrets(ctx context.Context, resourceGroupName string, name string, functionName string, options *AppsClientListFunctionSecretsOptions) (AppsClientListFunctionSecretsResponse, error) {
	req, err := client.listFunctionSecretsCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return AppsClientListFunctionSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListFunctionSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListFunctionSecretsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listFunctionSecretsHandleResponse(resp)
}

// listFunctionSecretsCreateRequest creates the ListFunctionSecrets request.
func (client *AppsClient) listFunctionSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *AppsClientListFunctionSecretsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listsecrets"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFunctionSecretsHandleResponse handles the ListFunctionSecrets response.
func (client *AppsClient) listFunctionSecretsHandleResponse(resp *http.Response) (AppsClientListFunctionSecretsResponse, error) {
	result := AppsClientListFunctionSecretsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionSecrets); err != nil {
		return AppsClientListFunctionSecretsResponse{}, err
	}
	return result, nil
}

// ListFunctionSecretsSlot - Get function secrets for a function in a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// functionName - Function name.
// slot - Name of the deployment slot.
// options - AppsClientListFunctionSecretsSlotOptions contains the optional parameters for the AppsClient.ListFunctionSecretsSlot
// method.
func (client *AppsClient) ListFunctionSecretsSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *AppsClientListFunctionSecretsSlotOptions) (AppsClientListFunctionSecretsSlotResponse, error) {
	req, err := client.listFunctionSecretsSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return AppsClientListFunctionSecretsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListFunctionSecretsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListFunctionSecretsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listFunctionSecretsSlotHandleResponse(resp)
}

// listFunctionSecretsSlotCreateRequest creates the ListFunctionSecretsSlot request.
func (client *AppsClient) listFunctionSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *AppsClientListFunctionSecretsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listsecrets"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFunctionSecretsSlotHandleResponse handles the ListFunctionSecretsSlot response.
func (client *AppsClient) listFunctionSecretsSlotHandleResponse(resp *http.Response) (AppsClientListFunctionSecretsSlotResponse, error) {
	result := AppsClientListFunctionSecretsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionSecrets); err != nil {
		return AppsClientListFunctionSecretsSlotResponse{}, err
	}
	return result, nil
}

// NewListFunctionsPager - List the functions for a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// options - AppsClientListFunctionsOptions contains the optional parameters for the AppsClient.ListFunctions method.
func (client *AppsClient) NewListFunctionsPager(resourceGroupName string, name string, options *AppsClientListFunctionsOptions) *runtime.Pager[AppsClientListFunctionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListFunctionsResponse]{
		More: func(page AppsClientListFunctionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListFunctionsResponse) (AppsClientListFunctionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listFunctionsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListFunctionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListFunctionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListFunctionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listFunctionsHandleResponse(resp)
		},
	})
}

// listFunctionsCreateRequest creates the ListFunctions request.
func (client *AppsClient) listFunctionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListFunctionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFunctionsHandleResponse handles the ListFunctions response.
func (client *AppsClient) listFunctionsHandleResponse(resp *http.Response) (AppsClientListFunctionsResponse, error) {
	result := AppsClientListFunctionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionEnvelopeCollection); err != nil {
		return AppsClientListFunctionsResponse{}, err
	}
	return result, nil
}

// ListHostKeys - Get host secrets for a function app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// options - AppsClientListHostKeysOptions contains the optional parameters for the AppsClient.ListHostKeys method.
func (client *AppsClient) ListHostKeys(ctx context.Context, resourceGroupName string, name string, options *AppsClientListHostKeysOptions) (AppsClientListHostKeysResponse, error) {
	req, err := client.listHostKeysCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListHostKeysResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListHostKeysResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListHostKeysResponse{}, runtime.NewResponseError(resp)
	}
	return client.listHostKeysHandleResponse(resp)
}

// listHostKeysCreateRequest creates the ListHostKeys request.
func (client *AppsClient) listHostKeysCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListHostKeysOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHostKeysHandleResponse handles the ListHostKeys response.
func (client *AppsClient) listHostKeysHandleResponse(resp *http.Response) (AppsClientListHostKeysResponse, error) {
	result := AppsClientListHostKeysResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostKeys); err != nil {
		return AppsClientListHostKeysResponse{}, err
	}
	return result, nil
}

// ListHostKeysSlot - Get host secrets for a function app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// slot - Name of the deployment slot.
// options - AppsClientListHostKeysSlotOptions contains the optional parameters for the AppsClient.ListHostKeysSlot method.
func (client *AppsClient) ListHostKeysSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListHostKeysSlotOptions) (AppsClientListHostKeysSlotResponse, error) {
	req, err := client.listHostKeysSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientListHostKeysSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListHostKeysSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListHostKeysSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listHostKeysSlotHandleResponse(resp)
}

// listHostKeysSlotCreateRequest creates the ListHostKeysSlot request.
func (client *AppsClient) listHostKeysSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListHostKeysSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHostKeysSlotHandleResponse handles the ListHostKeysSlot response.
func (client *AppsClient) listHostKeysSlotHandleResponse(resp *http.Response) (AppsClientListHostKeysSlotResponse, error) {
	result := AppsClientListHostKeysSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostKeys); err != nil {
		return AppsClientListHostKeysSlotResponse{}, err
	}
	return result, nil
}

// NewListHostNameBindingsPager - Get hostname bindings for an app or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListHostNameBindingsOptions contains the optional parameters for the AppsClient.ListHostNameBindings
// method.
func (client *AppsClient) NewListHostNameBindingsPager(resourceGroupName string, name string, options *AppsClientListHostNameBindingsOptions) *runtime.Pager[AppsClientListHostNameBindingsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListHostNameBindingsResponse]{
		More: func(page AppsClientListHostNameBindingsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListHostNameBindingsResponse) (AppsClientListHostNameBindingsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listHostNameBindingsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListHostNameBindingsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListHostNameBindingsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListHostNameBindingsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listHostNameBindingsHandleResponse(resp)
		},
	})
}

// listHostNameBindingsCreateRequest creates the ListHostNameBindings request.
func (client *AppsClient) listHostNameBindingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListHostNameBindingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHostNameBindingsHandleResponse handles the ListHostNameBindings response.
func (client *AppsClient) listHostNameBindingsHandleResponse(resp *http.Response) (AppsClientListHostNameBindingsResponse, error) {
	result := AppsClientListHostNameBindingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBindingCollection); err != nil {
		return AppsClientListHostNameBindingsResponse{}, err
	}
	return result, nil
}

// NewListHostNameBindingsSlotPager - Get hostname bindings for an app or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
// options - AppsClientListHostNameBindingsSlotOptions contains the optional parameters for the AppsClient.ListHostNameBindingsSlot
// method.
func (client *AppsClient) NewListHostNameBindingsSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListHostNameBindingsSlotOptions) *runtime.Pager[AppsClientListHostNameBindingsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListHostNameBindingsSlotResponse]{
		More: func(page AppsClientListHostNameBindingsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListHostNameBindingsSlotResponse) (AppsClientListHostNameBindingsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listHostNameBindingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListHostNameBindingsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListHostNameBindingsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListHostNameBindingsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listHostNameBindingsSlotHandleResponse(resp)
		},
	})
}

// listHostNameBindingsSlotCreateRequest creates the ListHostNameBindingsSlot request.
func (client *AppsClient) listHostNameBindingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListHostNameBindingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHostNameBindingsSlotHandleResponse handles the ListHostNameBindingsSlot response.
func (client *AppsClient) listHostNameBindingsSlotHandleResponse(resp *http.Response) (AppsClientListHostNameBindingsSlotResponse, error) {
	result := AppsClientListHostNameBindingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBindingCollection); err != nil {
		return AppsClientListHostNameBindingsSlotResponse{}, err
	}
	return result, nil
}

// ListHybridConnectionKeys - Gets the send key name and value for a Hybrid Connection.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// namespaceName - The namespace for this hybrid connection.
// relayName - The relay name for this hybrid connection.
// options - AppsClientListHybridConnectionKeysOptions contains the optional parameters for the AppsClient.ListHybridConnectionKeys
// method.
func (client *AppsClient) ListHybridConnectionKeys(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppsClientListHybridConnectionKeysOptions) (AppsClientListHybridConnectionKeysResponse, error) {
	req, err := client.listHybridConnectionKeysCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
	if err != nil {
		return AppsClientListHybridConnectionKeysResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListHybridConnectionKeysResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListHybridConnectionKeysResponse{}, runtime.NewResponseError(resp)
	}
	return client.listHybridConnectionKeysHandleResponse(resp)
}

// listHybridConnectionKeysCreateRequest creates the ListHybridConnectionKeys request.
func (client *AppsClient) listHybridConnectionKeysCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppsClientListHybridConnectionKeysOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHybridConnectionKeysHandleResponse handles the ListHybridConnectionKeys response.
func (client *AppsClient) listHybridConnectionKeysHandleResponse(resp *http.Response) (AppsClientListHybridConnectionKeysResponse, error) {
	result := AppsClientListHybridConnectionKeysResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnectionKey); err != nil {
		return AppsClientListHybridConnectionKeysResponse{}, err
	}
	return result, nil
}

// ListHybridConnectionKeysSlot - Gets the send key name and value for a Hybrid Connection.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// namespaceName - The namespace for this hybrid connection.
// relayName - The relay name for this hybrid connection.
// slot - The name of the slot for the web app.
// options - AppsClientListHybridConnectionKeysSlotOptions contains the optional parameters for the AppsClient.ListHybridConnectionKeysSlot
// method.
func (client *AppsClient) ListHybridConnectionKeysSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *AppsClientListHybridConnectionKeysSlotOptions) (AppsClientListHybridConnectionKeysSlotResponse, error) {
	req, err := client.listHybridConnectionKeysSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, options)
	if err != nil {
		return AppsClientListHybridConnectionKeysSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListHybridConnectionKeysSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListHybridConnectionKeysSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listHybridConnectionKeysSlotHandleResponse(resp)
}

// listHybridConnectionKeysSlotCreateRequest creates the ListHybridConnectionKeysSlot request.
func (client *AppsClient) listHybridConnectionKeysSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *AppsClientListHybridConnectionKeysSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHybridConnectionKeysSlotHandleResponse handles the ListHybridConnectionKeysSlot response.
func (client *AppsClient) listHybridConnectionKeysSlotHandleResponse(resp *http.Response) (AppsClientListHybridConnectionKeysSlotResponse, error) {
	result := AppsClientListHybridConnectionKeysSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnectionKey); err != nil {
		return AppsClientListHybridConnectionKeysSlotResponse{}, err
	}
	return result, nil
}

// ListHybridConnections - Retrieves all Service Bus Hybrid Connections used by this Web App.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// options - AppsClientListHybridConnectionsOptions contains the optional parameters for the AppsClient.ListHybridConnections
// method.
func (client *AppsClient) ListHybridConnections(ctx context.Context, resourceGroupName string, name string, options *AppsClientListHybridConnectionsOptions) (AppsClientListHybridConnectionsResponse, error) {
	req, err := client.listHybridConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListHybridConnectionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListHybridConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListHybridConnectionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listHybridConnectionsHandleResponse(resp)
}

// listHybridConnectionsCreateRequest creates the ListHybridConnections request.
func (client *AppsClient) listHybridConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListHybridConnectionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionRelays"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHybridConnectionsHandleResponse handles the ListHybridConnections response.
func (client *AppsClient) listHybridConnectionsHandleResponse(resp *http.Response) (AppsClientListHybridConnectionsResponse, error) {
	result := AppsClientListHybridConnectionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return AppsClientListHybridConnectionsResponse{}, err
	}
	return result, nil
}

// ListHybridConnectionsSlot - Retrieves all Service Bus Hybrid Connections used by this Web App.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// slot - The name of the slot for the web app.
// options - AppsClientListHybridConnectionsSlotOptions contains the optional parameters for the AppsClient.ListHybridConnectionsSlot
// method.
func (client *AppsClient) ListHybridConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListHybridConnectionsSlotOptions) (AppsClientListHybridConnectionsSlotResponse, error) {
	req, err := client.listHybridConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientListHybridConnectionsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListHybridConnectionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListHybridConnectionsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listHybridConnectionsSlotHandleResponse(resp)
}

// listHybridConnectionsSlotCreateRequest creates the ListHybridConnectionsSlot request.
func (client *AppsClient) listHybridConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListHybridConnectionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionRelays"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHybridConnectionsSlotHandleResponse handles the ListHybridConnectionsSlot response.
func (client *AppsClient) listHybridConnectionsSlotHandleResponse(resp *http.Response) (AppsClientListHybridConnectionsSlotResponse, error) {
	result := AppsClientListHybridConnectionsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return AppsClientListHybridConnectionsSlotResponse{}, err
	}
	return result, nil
}

// NewListInstanceFunctionsSlotPager - List the functions for a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// slot - Name of the deployment slot.
// options - AppsClientListInstanceFunctionsSlotOptions contains the optional parameters for the AppsClient.ListInstanceFunctionsSlot
// method.
func (client *AppsClient) NewListInstanceFunctionsSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListInstanceFunctionsSlotOptions) *runtime.Pager[AppsClientListInstanceFunctionsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListInstanceFunctionsSlotResponse]{
		More: func(page AppsClientListInstanceFunctionsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListInstanceFunctionsSlotResponse) (AppsClientListInstanceFunctionsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listInstanceFunctionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListInstanceFunctionsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListInstanceFunctionsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListInstanceFunctionsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listInstanceFunctionsSlotHandleResponse(resp)
		},
	})
}

// listInstanceFunctionsSlotCreateRequest creates the ListInstanceFunctionsSlot request.
func (client *AppsClient) listInstanceFunctionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListInstanceFunctionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceFunctionsSlotHandleResponse handles the ListInstanceFunctionsSlot response.
func (client *AppsClient) listInstanceFunctionsSlotHandleResponse(resp *http.Response) (AppsClientListInstanceFunctionsSlotResponse, error) {
	result := AppsClientListInstanceFunctionsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionEnvelopeCollection); err != nil {
		return AppsClientListInstanceFunctionsSlotResponse{}, err
	}
	return result, nil
}

// NewListInstanceIdentifiersPager - Gets all scale-out instances of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListInstanceIdentifiersOptions contains the optional parameters for the AppsClient.ListInstanceIdentifiers
// method.
func (client *AppsClient) NewListInstanceIdentifiersPager(resourceGroupName string, name string, options *AppsClientListInstanceIdentifiersOptions) *runtime.Pager[AppsClientListInstanceIdentifiersResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListInstanceIdentifiersResponse]{
		More: func(page AppsClientListInstanceIdentifiersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListInstanceIdentifiersResponse) (AppsClientListInstanceIdentifiersResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listInstanceIdentifiersCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListInstanceIdentifiersResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListInstanceIdentifiersResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListInstanceIdentifiersResponse{}, runtime.NewResponseError(resp)
			}
			return client.listInstanceIdentifiersHandleResponse(resp)
		},
	})
}

// listInstanceIdentifiersCreateRequest creates the ListInstanceIdentifiers request.
func (client *AppsClient) listInstanceIdentifiersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListInstanceIdentifiersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceIdentifiersHandleResponse handles the ListInstanceIdentifiers response.
func (client *AppsClient) listInstanceIdentifiersHandleResponse(resp *http.Response) (AppsClientListInstanceIdentifiersResponse, error) {
	result := AppsClientListInstanceIdentifiersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppInstanceCollection); err != nil {
		return AppsClientListInstanceIdentifiersResponse{}, err
	}
	return result, nil
}

// NewListInstanceIdentifiersSlotPager - Gets all scale-out instances of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
// options - AppsClientListInstanceIdentifiersSlotOptions contains the optional parameters for the AppsClient.ListInstanceIdentifiersSlot
// method.
func (client *AppsClient) NewListInstanceIdentifiersSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListInstanceIdentifiersSlotOptions) *runtime.Pager[AppsClientListInstanceIdentifiersSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListInstanceIdentifiersSlotResponse]{
		More: func(page AppsClientListInstanceIdentifiersSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListInstanceIdentifiersSlotResponse) (AppsClientListInstanceIdentifiersSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listInstanceIdentifiersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListInstanceIdentifiersSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListInstanceIdentifiersSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListInstanceIdentifiersSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listInstanceIdentifiersSlotHandleResponse(resp)
		},
	})
}

// listInstanceIdentifiersSlotCreateRequest creates the ListInstanceIdentifiersSlot request.
func (client *AppsClient) listInstanceIdentifiersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListInstanceIdentifiersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceIdentifiersSlotHandleResponse handles the ListInstanceIdentifiersSlot response.
func (client *AppsClient) listInstanceIdentifiersSlotHandleResponse(resp *http.Response) (AppsClientListInstanceIdentifiersSlotResponse, error) {
	result := AppsClientListInstanceIdentifiersSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppInstanceCollection); err != nil {
		return AppsClientListInstanceIdentifiersSlotResponse{}, err
	}
	return result, nil
}

// NewListInstanceProcessModulesPager - List module information for a process by its ID for a specific scaled-out instance
// in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientListInstanceProcessModulesOptions contains the optional parameters for the AppsClient.ListInstanceProcessModules
// method.
func (client *AppsClient) NewListInstanceProcessModulesPager(resourceGroupName string, name string, processID string, instanceID string, options *AppsClientListInstanceProcessModulesOptions) *runtime.Pager[AppsClientListInstanceProcessModulesResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListInstanceProcessModulesResponse]{
		More: func(page AppsClientListInstanceProcessModulesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListInstanceProcessModulesResponse) (AppsClientListInstanceProcessModulesResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listInstanceProcessModulesCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListInstanceProcessModulesResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListInstanceProcessModulesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListInstanceProcessModulesResponse{}, runtime.NewResponseError(resp)
			}
			return client.listInstanceProcessModulesHandleResponse(resp)
		},
	})
}

// listInstanceProcessModulesCreateRequest creates the ListInstanceProcessModules request.
func (client *AppsClient) listInstanceProcessModulesCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *AppsClientListInstanceProcessModulesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceProcessModulesHandleResponse handles the ListInstanceProcessModules response.
func (client *AppsClient) listInstanceProcessModulesHandleResponse(resp *http.Response) (AppsClientListInstanceProcessModulesResponse, error) {
	result := AppsClientListInstanceProcessModulesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfoCollection); err != nil {
		return AppsClientListInstanceProcessModulesResponse{}, err
	}
	return result, nil
}

// NewListInstanceProcessModulesSlotPager - List module information for a process by its ID for a specific scaled-out instance
// in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientListInstanceProcessModulesSlotOptions contains the optional parameters for the AppsClient.ListInstanceProcessModulesSlot
// method.
func (client *AppsClient) NewListInstanceProcessModulesSlotPager(resourceGroupName string, name string, processID string, slot string, instanceID string, options *AppsClientListInstanceProcessModulesSlotOptions) *runtime.Pager[AppsClientListInstanceProcessModulesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListInstanceProcessModulesSlotResponse]{
		More: func(page AppsClientListInstanceProcessModulesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListInstanceProcessModulesSlotResponse) (AppsClientListInstanceProcessModulesSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listInstanceProcessModulesSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListInstanceProcessModulesSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListInstanceProcessModulesSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListInstanceProcessModulesSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listInstanceProcessModulesSlotHandleResponse(resp)
		},
	})
}

// listInstanceProcessModulesSlotCreateRequest creates the ListInstanceProcessModulesSlot request.
func (client *AppsClient) listInstanceProcessModulesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *AppsClientListInstanceProcessModulesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceProcessModulesSlotHandleResponse handles the ListInstanceProcessModulesSlot response.
func (client *AppsClient) listInstanceProcessModulesSlotHandleResponse(resp *http.Response) (AppsClientListInstanceProcessModulesSlotResponse, error) {
	result := AppsClientListInstanceProcessModulesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfoCollection); err != nil {
		return AppsClientListInstanceProcessModulesSlotResponse{}, err
	}
	return result, nil
}

// NewListInstanceProcessThreadsPager - List the threads in a process by its ID for a specific scaled-out instance in a web
// site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientListInstanceProcessThreadsOptions contains the optional parameters for the AppsClient.ListInstanceProcessThreads
// method.
func (client *AppsClient) NewListInstanceProcessThreadsPager(resourceGroupName string, name string, processID string, instanceID string, options *AppsClientListInstanceProcessThreadsOptions) *runtime.Pager[AppsClientListInstanceProcessThreadsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListInstanceProcessThreadsResponse]{
		More: func(page AppsClientListInstanceProcessThreadsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListInstanceProcessThreadsResponse) (AppsClientListInstanceProcessThreadsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listInstanceProcessThreadsCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListInstanceProcessThreadsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListInstanceProcessThreadsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListInstanceProcessThreadsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listInstanceProcessThreadsHandleResponse(resp)
		},
	})
}

// listInstanceProcessThreadsCreateRequest creates the ListInstanceProcessThreads request.
func (client *AppsClient) listInstanceProcessThreadsCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *AppsClientListInstanceProcessThreadsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceProcessThreadsHandleResponse handles the ListInstanceProcessThreads response.
func (client *AppsClient) listInstanceProcessThreadsHandleResponse(resp *http.Response) (AppsClientListInstanceProcessThreadsResponse, error) {
	result := AppsClientListInstanceProcessThreadsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfoCollection); err != nil {
		return AppsClientListInstanceProcessThreadsResponse{}, err
	}
	return result, nil
}

// NewListInstanceProcessThreadsSlotPager - List the threads in a process by its ID for a specific scaled-out instance in
// a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientListInstanceProcessThreadsSlotOptions contains the optional parameters for the AppsClient.ListInstanceProcessThreadsSlot
// method.
func (client *AppsClient) NewListInstanceProcessThreadsSlotPager(resourceGroupName string, name string, processID string, slot string, instanceID string, options *AppsClientListInstanceProcessThreadsSlotOptions) *runtime.Pager[AppsClientListInstanceProcessThreadsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListInstanceProcessThreadsSlotResponse]{
		More: func(page AppsClientListInstanceProcessThreadsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListInstanceProcessThreadsSlotResponse) (AppsClientListInstanceProcessThreadsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listInstanceProcessThreadsSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListInstanceProcessThreadsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListInstanceProcessThreadsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListInstanceProcessThreadsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listInstanceProcessThreadsSlotHandleResponse(resp)
		},
	})
}

// listInstanceProcessThreadsSlotCreateRequest creates the ListInstanceProcessThreadsSlot request.
func (client *AppsClient) listInstanceProcessThreadsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *AppsClientListInstanceProcessThreadsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceProcessThreadsSlotHandleResponse handles the ListInstanceProcessThreadsSlot response.
func (client *AppsClient) listInstanceProcessThreadsSlotHandleResponse(resp *http.Response) (AppsClientListInstanceProcessThreadsSlotResponse, error) {
	result := AppsClientListInstanceProcessThreadsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfoCollection); err != nil {
		return AppsClientListInstanceProcessThreadsSlotResponse{}, err
	}
	return result, nil
}

// NewListInstanceProcessesPager - Get list of processes for a web site, or a deployment slot, or for a specific scaled-out
// instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientListInstanceProcessesOptions contains the optional parameters for the AppsClient.ListInstanceProcesses
// method.
func (client *AppsClient) NewListInstanceProcessesPager(resourceGroupName string, name string, instanceID string, options *AppsClientListInstanceProcessesOptions) *runtime.Pager[AppsClientListInstanceProcessesResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListInstanceProcessesResponse]{
		More: func(page AppsClientListInstanceProcessesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListInstanceProcessesResponse) (AppsClientListInstanceProcessesResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listInstanceProcessesCreateRequest(ctx, resourceGroupName, name, instanceID, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListInstanceProcessesResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListInstanceProcessesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListInstanceProcessesResponse{}, runtime.NewResponseError(resp)
			}
			return client.listInstanceProcessesHandleResponse(resp)
		},
	})
}

// listInstanceProcessesCreateRequest creates the ListInstanceProcesses request.
func (client *AppsClient) listInstanceProcessesCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *AppsClientListInstanceProcessesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceProcessesHandleResponse handles the ListInstanceProcesses response.
func (client *AppsClient) listInstanceProcessesHandleResponse(resp *http.Response) (AppsClientListInstanceProcessesResponse, error) {
	result := AppsClientListInstanceProcessesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfoCollection); err != nil {
		return AppsClientListInstanceProcessesResponse{}, err
	}
	return result, nil
}

// NewListInstanceProcessesSlotPager - Get list of processes for a web site, or a deployment slot, or for a specific scaled-out
// instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
// api/sites/{siteName}/instances".
// options - AppsClientListInstanceProcessesSlotOptions contains the optional parameters for the AppsClient.ListInstanceProcessesSlot
// method.
func (client *AppsClient) NewListInstanceProcessesSlotPager(resourceGroupName string, name string, slot string, instanceID string, options *AppsClientListInstanceProcessesSlotOptions) *runtime.Pager[AppsClientListInstanceProcessesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListInstanceProcessesSlotResponse]{
		More: func(page AppsClientListInstanceProcessesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListInstanceProcessesSlotResponse) (AppsClientListInstanceProcessesSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listInstanceProcessesSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListInstanceProcessesSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListInstanceProcessesSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListInstanceProcessesSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listInstanceProcessesSlotHandleResponse(resp)
		},
	})
}

// listInstanceProcessesSlotCreateRequest creates the ListInstanceProcessesSlot request.
func (client *AppsClient) listInstanceProcessesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *AppsClientListInstanceProcessesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceProcessesSlotHandleResponse handles the ListInstanceProcessesSlot response.
func (client *AppsClient) listInstanceProcessesSlotHandleResponse(resp *http.Response) (AppsClientListInstanceProcessesSlotResponse, error) {
	result := AppsClientListInstanceProcessesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfoCollection); err != nil {
		return AppsClientListInstanceProcessesSlotResponse{}, err
	}
	return result, nil
}

// ListMetadata - Gets the metadata of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListMetadataOptions contains the optional parameters for the AppsClient.ListMetadata method.
func (client *AppsClient) ListMetadata(ctx context.Context, resourceGroupName string, name string, options *AppsClientListMetadataOptions) (AppsClientListMetadataResponse, error) {
	req, err := client.listMetadataCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListMetadataResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListMetadataResponse{}, runtime.NewResponseError(resp)
	}
	return client.listMetadataHandleResponse(resp)
}

// listMetadataCreateRequest creates the ListMetadata request.
func (client *AppsClient) listMetadataCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListMetadataOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listMetadataHandleResponse handles the ListMetadata response.
func (client *AppsClient) listMetadataHandleResponse(resp *http.Response) (AppsClientListMetadataResponse, error) {
	result := AppsClientListMetadataResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return AppsClientListMetadataResponse{}, err
	}
	return result, nil
}

// ListMetadataSlot - Gets the metadata of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get the metadata for the production slot.
// options - AppsClientListMetadataSlotOptions contains the optional parameters for the AppsClient.ListMetadataSlot method.
func (client *AppsClient) ListMetadataSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListMetadataSlotOptions) (AppsClientListMetadataSlotResponse, error) {
	req, err := client.listMetadataSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientListMetadataSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListMetadataSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListMetadataSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listMetadataSlotHandleResponse(resp)
}

// listMetadataSlotCreateRequest creates the ListMetadataSlot request.
func (client *AppsClient) listMetadataSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListMetadataSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listMetadataSlotHandleResponse handles the ListMetadataSlot response.
func (client *AppsClient) listMetadataSlotHandleResponse(resp *http.Response) (AppsClientListMetadataSlotResponse, error) {
	result := AppsClientListMetadataSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return AppsClientListMetadataSlotResponse{}, err
	}
	return result, nil
}

// NewListMetricDefinitionsPager - Gets all metric definitions of an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListMetricDefinitionsOptions contains the optional parameters for the AppsClient.ListMetricDefinitions
// method.
func (client *AppsClient) NewListMetricDefinitionsPager(resourceGroupName string, name string, options *AppsClientListMetricDefinitionsOptions) *runtime.Pager[AppsClientListMetricDefinitionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListMetricDefinitionsResponse]{
		More: func(page AppsClientListMetricDefinitionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListMetricDefinitionsResponse) (AppsClientListMetricDefinitionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listMetricDefinitionsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListMetricDefinitionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListMetricDefinitionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListMetricDefinitionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listMetricDefinitionsHandleResponse(resp)
		},
	})
}

// listMetricDefinitionsCreateRequest creates the ListMetricDefinitions request.
func (client *AppsClient) listMetricDefinitionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListMetricDefinitionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metricdefinitions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listMetricDefinitionsHandleResponse handles the ListMetricDefinitions response.
func (client *AppsClient) listMetricDefinitionsHandleResponse(resp *http.Response) (AppsClientListMetricDefinitionsResponse, error) {
	result := AppsClientListMetricDefinitionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricDefinitionCollection); err != nil {
		return AppsClientListMetricDefinitionsResponse{}, err
	}
	return result, nil
}

// NewListMetricDefinitionsSlotPager - Gets all metric definitions of an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get metric definitions of the production slot.
// options - AppsClientListMetricDefinitionsSlotOptions contains the optional parameters for the AppsClient.ListMetricDefinitionsSlot
// method.
func (client *AppsClient) NewListMetricDefinitionsSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListMetricDefinitionsSlotOptions) *runtime.Pager[AppsClientListMetricDefinitionsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListMetricDefinitionsSlotResponse]{
		More: func(page AppsClientListMetricDefinitionsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListMetricDefinitionsSlotResponse) (AppsClientListMetricDefinitionsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listMetricDefinitionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListMetricDefinitionsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListMetricDefinitionsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListMetricDefinitionsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listMetricDefinitionsSlotHandleResponse(resp)
		},
	})
}

// listMetricDefinitionsSlotCreateRequest creates the ListMetricDefinitionsSlot request.
func (client *AppsClient) listMetricDefinitionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListMetricDefinitionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metricdefinitions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listMetricDefinitionsSlotHandleResponse handles the ListMetricDefinitionsSlot response.
func (client *AppsClient) listMetricDefinitionsSlotHandleResponse(resp *http.Response) (AppsClientListMetricDefinitionsSlotResponse, error) {
	result := AppsClientListMetricDefinitionsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricDefinitionCollection); err != nil {
		return AppsClientListMetricDefinitionsSlotResponse{}, err
	}
	return result, nil
}

// NewListMetricsPager - Gets performance metrics of an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListMetricsOptions contains the optional parameters for the AppsClient.ListMetrics method.
func (client *AppsClient) NewListMetricsPager(resourceGroupName string, name string, options *AppsClientListMetricsOptions) *runtime.Pager[AppsClientListMetricsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListMetricsResponse]{
		More: func(page AppsClientListMetricsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListMetricsResponse) (AppsClientListMetricsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listMetricsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListMetricsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListMetricsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListMetricsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listMetricsHandleResponse(resp)
		},
	})
}

// listMetricsCreateRequest creates the ListMetrics request.
func (client *AppsClient) listMetricsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListMetricsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metrics"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Details != nil {
		reqQP.Set("details", strconv.FormatBool(*options.Details))
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listMetricsHandleResponse handles the ListMetrics response.
func (client *AppsClient) listMetricsHandleResponse(resp *http.Response) (AppsClientListMetricsResponse, error) {
	result := AppsClientListMetricsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricCollection); err != nil {
		return AppsClientListMetricsResponse{}, err
	}
	return result, nil
}

// NewListMetricsSlotPager - Gets performance metrics of an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
// options - AppsClientListMetricsSlotOptions contains the optional parameters for the AppsClient.ListMetricsSlot method.
func (client *AppsClient) NewListMetricsSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListMetricsSlotOptions) *runtime.Pager[AppsClientListMetricsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListMetricsSlotResponse]{
		More: func(page AppsClientListMetricsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListMetricsSlotResponse) (AppsClientListMetricsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listMetricsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListMetricsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListMetricsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListMetricsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listMetricsSlotHandleResponse(resp)
		},
	})
}

// listMetricsSlotCreateRequest creates the ListMetricsSlot request.
func (client *AppsClient) listMetricsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListMetricsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metrics"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Details != nil {
		reqQP.Set("details", strconv.FormatBool(*options.Details))
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listMetricsSlotHandleResponse handles the ListMetricsSlot response.
func (client *AppsClient) listMetricsSlotHandleResponse(resp *http.Response) (AppsClientListMetricsSlotResponse, error) {
	result := AppsClientListMetricsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricCollection); err != nil {
		return AppsClientListMetricsSlotResponse{}, err
	}
	return result, nil
}

// ListNetworkFeatures - Gets all network features used by the app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// view - The type of view. This can either be "summary" or "detailed".
// options - AppsClientListNetworkFeaturesOptions contains the optional parameters for the AppsClient.ListNetworkFeatures
// method.
func (client *AppsClient) ListNetworkFeatures(ctx context.Context, resourceGroupName string, name string, view string, options *AppsClientListNetworkFeaturesOptions) (AppsClientListNetworkFeaturesResponse, error) {
	req, err := client.listNetworkFeaturesCreateRequest(ctx, resourceGroupName, name, view, options)
	if err != nil {
		return AppsClientListNetworkFeaturesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListNetworkFeaturesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientListNetworkFeaturesResponse{}, runtime.NewResponseError(resp)
	}
	return client.listNetworkFeaturesHandleResponse(resp)
}

// listNetworkFeaturesCreateRequest creates the ListNetworkFeatures request.
func (client *AppsClient) listNetworkFeaturesCreateRequest(ctx context.Context, resourceGroupName string, name string, view string, options *AppsClientListNetworkFeaturesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if view == "" {
		return nil, errors.New("parameter view cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{view}", url.PathEscape(view))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listNetworkFeaturesHandleResponse handles the ListNetworkFeatures response.
func (client *AppsClient) listNetworkFeaturesHandleResponse(resp *http.Response) (AppsClientListNetworkFeaturesResponse, error) {
	result := AppsClientListNetworkFeaturesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkFeatures); err != nil {
		return AppsClientListNetworkFeaturesResponse{}, err
	}
	return result, nil
}

// ListNetworkFeaturesSlot - Gets all network features used by the app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// view - The type of view. This can either be "summary" or "detailed".
// slot - Name of the deployment slot. If a slot is not specified, the API will get network features for the production slot.
// options - AppsClientListNetworkFeaturesSlotOptions contains the optional parameters for the AppsClient.ListNetworkFeaturesSlot
// method.
func (client *AppsClient) ListNetworkFeaturesSlot(ctx context.Context, resourceGroupName string, name string, view string, slot string, options *AppsClientListNetworkFeaturesSlotOptions) (AppsClientListNetworkFeaturesSlotResponse, error) {
	req, err := client.listNetworkFeaturesSlotCreateRequest(ctx, resourceGroupName, name, view, slot, options)
	if err != nil {
		return AppsClientListNetworkFeaturesSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListNetworkFeaturesSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientListNetworkFeaturesSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listNetworkFeaturesSlotHandleResponse(resp)
}

// listNetworkFeaturesSlotCreateRequest creates the ListNetworkFeaturesSlot request.
func (client *AppsClient) listNetworkFeaturesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, view string, slot string, options *AppsClientListNetworkFeaturesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if view == "" {
		return nil, errors.New("parameter view cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{view}", url.PathEscape(view))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listNetworkFeaturesSlotHandleResponse handles the ListNetworkFeaturesSlot response.
func (client *AppsClient) listNetworkFeaturesSlotHandleResponse(resp *http.Response) (AppsClientListNetworkFeaturesSlotResponse, error) {
	result := AppsClientListNetworkFeaturesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkFeatures); err != nil {
		return AppsClientListNetworkFeaturesSlotResponse{}, err
	}
	return result, nil
}

// NewListPerfMonCountersPager - Gets perfmon counters for web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// options - AppsClientListPerfMonCountersOptions contains the optional parameters for the AppsClient.ListPerfMonCounters
// method.
func (client *AppsClient) NewListPerfMonCountersPager(resourceGroupName string, name string, options *AppsClientListPerfMonCountersOptions) *runtime.Pager[AppsClientListPerfMonCountersResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListPerfMonCountersResponse]{
		More: func(page AppsClientListPerfMonCountersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListPerfMonCountersResponse) (AppsClientListPerfMonCountersResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listPerfMonCountersCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListPerfMonCountersResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListPerfMonCountersResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListPerfMonCountersResponse{}, runtime.NewResponseError(resp)
			}
			return client.listPerfMonCountersHandleResponse(resp)
		},
	})
}

// listPerfMonCountersCreateRequest creates the ListPerfMonCounters request.
func (client *AppsClient) listPerfMonCountersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListPerfMonCountersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/perfcounters"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPerfMonCountersHandleResponse handles the ListPerfMonCounters response.
func (client *AppsClient) listPerfMonCountersHandleResponse(resp *http.Response) (AppsClientListPerfMonCountersResponse, error) {
	result := AppsClientListPerfMonCountersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PerfMonCounterCollection); err != nil {
		return AppsClientListPerfMonCountersResponse{}, err
	}
	return result, nil
}

// NewListPerfMonCountersSlotPager - Gets perfmon counters for web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// options - AppsClientListPerfMonCountersSlotOptions contains the optional parameters for the AppsClient.ListPerfMonCountersSlot
// method.
func (client *AppsClient) NewListPerfMonCountersSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListPerfMonCountersSlotOptions) *runtime.Pager[AppsClientListPerfMonCountersSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListPerfMonCountersSlotResponse]{
		More: func(page AppsClientListPerfMonCountersSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListPerfMonCountersSlotResponse) (AppsClientListPerfMonCountersSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listPerfMonCountersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListPerfMonCountersSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListPerfMonCountersSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListPerfMonCountersSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listPerfMonCountersSlotHandleResponse(resp)
		},
	})
}

// listPerfMonCountersSlotCreateRequest creates the ListPerfMonCountersSlot request.
func (client *AppsClient) listPerfMonCountersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListPerfMonCountersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/perfcounters"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPerfMonCountersSlotHandleResponse handles the ListPerfMonCountersSlot response.
func (client *AppsClient) listPerfMonCountersSlotHandleResponse(resp *http.Response) (AppsClientListPerfMonCountersSlotResponse, error) {
	result := AppsClientListPerfMonCountersSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PerfMonCounterCollection); err != nil {
		return AppsClientListPerfMonCountersSlotResponse{}, err
	}
	return result, nil
}

// ListPremierAddOns - Gets the premier add-ons of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListPremierAddOnsOptions contains the optional parameters for the AppsClient.ListPremierAddOns method.
func (client *AppsClient) ListPremierAddOns(ctx context.Context, resourceGroupName string, name string, options *AppsClientListPremierAddOnsOptions) (AppsClientListPremierAddOnsResponse, error) {
	req, err := client.listPremierAddOnsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListPremierAddOnsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListPremierAddOnsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListPremierAddOnsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listPremierAddOnsHandleResponse(resp)
}

// listPremierAddOnsCreateRequest creates the ListPremierAddOns request.
func (client *AppsClient) listPremierAddOnsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListPremierAddOnsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPremierAddOnsHandleResponse handles the ListPremierAddOns response.
func (client *AppsClient) listPremierAddOnsHandleResponse(resp *http.Response) (AppsClientListPremierAddOnsResponse, error) {
	result := AppsClientListPremierAddOnsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return AppsClientListPremierAddOnsResponse{}, err
	}
	return result, nil
}

// ListPremierAddOnsSlot - Gets the premier add-ons of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get the premier add-ons for the production
// slot.
// options - AppsClientListPremierAddOnsSlotOptions contains the optional parameters for the AppsClient.ListPremierAddOnsSlot
// method.
func (client *AppsClient) ListPremierAddOnsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListPremierAddOnsSlotOptions) (AppsClientListPremierAddOnsSlotResponse, error) {
	req, err := client.listPremierAddOnsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientListPremierAddOnsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListPremierAddOnsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListPremierAddOnsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listPremierAddOnsSlotHandleResponse(resp)
}

// listPremierAddOnsSlotCreateRequest creates the ListPremierAddOnsSlot request.
func (client *AppsClient) listPremierAddOnsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListPremierAddOnsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPremierAddOnsSlotHandleResponse handles the ListPremierAddOnsSlot response.
func (client *AppsClient) listPremierAddOnsSlotHandleResponse(resp *http.Response) (AppsClientListPremierAddOnsSlotResponse, error) {
	result := AppsClientListPremierAddOnsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return AppsClientListPremierAddOnsSlotResponse{}, err
	}
	return result, nil
}

// NewListProcessModulesPager - List module information for a process by its ID for a specific scaled-out instance in a web
// site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// options - AppsClientListProcessModulesOptions contains the optional parameters for the AppsClient.ListProcessModules method.
func (client *AppsClient) NewListProcessModulesPager(resourceGroupName string, name string, processID string, options *AppsClientListProcessModulesOptions) *runtime.Pager[AppsClientListProcessModulesResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListProcessModulesResponse]{
		More: func(page AppsClientListProcessModulesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListProcessModulesResponse) (AppsClientListProcessModulesResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listProcessModulesCreateRequest(ctx, resourceGroupName, name, processID, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListProcessModulesResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListProcessModulesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListProcessModulesResponse{}, runtime.NewResponseError(resp)
			}
			return client.listProcessModulesHandleResponse(resp)
		},
	})
}

// listProcessModulesCreateRequest creates the ListProcessModules request.
func (client *AppsClient) listProcessModulesCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *AppsClientListProcessModulesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProcessModulesHandleResponse handles the ListProcessModules response.
func (client *AppsClient) listProcessModulesHandleResponse(resp *http.Response) (AppsClientListProcessModulesResponse, error) {
	result := AppsClientListProcessModulesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfoCollection); err != nil {
		return AppsClientListProcessModulesResponse{}, err
	}
	return result, nil
}

// NewListProcessModulesSlotPager - List module information for a process by its ID for a specific scaled-out instance in
// a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// options - AppsClientListProcessModulesSlotOptions contains the optional parameters for the AppsClient.ListProcessModulesSlot
// method.
func (client *AppsClient) NewListProcessModulesSlotPager(resourceGroupName string, name string, processID string, slot string, options *AppsClientListProcessModulesSlotOptions) *runtime.Pager[AppsClientListProcessModulesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListProcessModulesSlotResponse]{
		More: func(page AppsClientListProcessModulesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListProcessModulesSlotResponse) (AppsClientListProcessModulesSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listProcessModulesSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListProcessModulesSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListProcessModulesSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListProcessModulesSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listProcessModulesSlotHandleResponse(resp)
		},
	})
}

// listProcessModulesSlotCreateRequest creates the ListProcessModulesSlot request.
func (client *AppsClient) listProcessModulesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *AppsClientListProcessModulesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProcessModulesSlotHandleResponse handles the ListProcessModulesSlot response.
func (client *AppsClient) listProcessModulesSlotHandleResponse(resp *http.Response) (AppsClientListProcessModulesSlotResponse, error) {
	result := AppsClientListProcessModulesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfoCollection); err != nil {
		return AppsClientListProcessModulesSlotResponse{}, err
	}
	return result, nil
}

// NewListProcessThreadsPager - List the threads in a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// options - AppsClientListProcessThreadsOptions contains the optional parameters for the AppsClient.ListProcessThreads method.
func (client *AppsClient) NewListProcessThreadsPager(resourceGroupName string, name string, processID string, options *AppsClientListProcessThreadsOptions) *runtime.Pager[AppsClientListProcessThreadsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListProcessThreadsResponse]{
		More: func(page AppsClientListProcessThreadsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListProcessThreadsResponse) (AppsClientListProcessThreadsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listProcessThreadsCreateRequest(ctx, resourceGroupName, name, processID, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListProcessThreadsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListProcessThreadsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListProcessThreadsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listProcessThreadsHandleResponse(resp)
		},
	})
}

// listProcessThreadsCreateRequest creates the ListProcessThreads request.
func (client *AppsClient) listProcessThreadsCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *AppsClientListProcessThreadsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProcessThreadsHandleResponse handles the ListProcessThreads response.
func (client *AppsClient) listProcessThreadsHandleResponse(resp *http.Response) (AppsClientListProcessThreadsResponse, error) {
	result := AppsClientListProcessThreadsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfoCollection); err != nil {
		return AppsClientListProcessThreadsResponse{}, err
	}
	return result, nil
}

// NewListProcessThreadsSlotPager - List the threads in a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// processID - PID.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// options - AppsClientListProcessThreadsSlotOptions contains the optional parameters for the AppsClient.ListProcessThreadsSlot
// method.
func (client *AppsClient) NewListProcessThreadsSlotPager(resourceGroupName string, name string, processID string, slot string, options *AppsClientListProcessThreadsSlotOptions) *runtime.Pager[AppsClientListProcessThreadsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListProcessThreadsSlotResponse]{
		More: func(page AppsClientListProcessThreadsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListProcessThreadsSlotResponse) (AppsClientListProcessThreadsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listProcessThreadsSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListProcessThreadsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListProcessThreadsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListProcessThreadsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listProcessThreadsSlotHandleResponse(resp)
		},
	})
}

// listProcessThreadsSlotCreateRequest creates the ListProcessThreadsSlot request.
func (client *AppsClient) listProcessThreadsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *AppsClientListProcessThreadsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProcessThreadsSlotHandleResponse handles the ListProcessThreadsSlot response.
func (client *AppsClient) listProcessThreadsSlotHandleResponse(resp *http.Response) (AppsClientListProcessThreadsSlotResponse, error) {
	result := AppsClientListProcessThreadsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfoCollection); err != nil {
		return AppsClientListProcessThreadsSlotResponse{}, err
	}
	return result, nil
}

// NewListProcessesPager - Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance
// in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// options - AppsClientListProcessesOptions contains the optional parameters for the AppsClient.ListProcesses method.
func (client *AppsClient) NewListProcessesPager(resourceGroupName string, name string, options *AppsClientListProcessesOptions) *runtime.Pager[AppsClientListProcessesResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListProcessesResponse]{
		More: func(page AppsClientListProcessesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListProcessesResponse) (AppsClientListProcessesResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listProcessesCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListProcessesResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListProcessesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListProcessesResponse{}, runtime.NewResponseError(resp)
			}
			return client.listProcessesHandleResponse(resp)
		},
	})
}

// listProcessesCreateRequest creates the ListProcesses request.
func (client *AppsClient) listProcessesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListProcessesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProcessesHandleResponse handles the ListProcesses response.
func (client *AppsClient) listProcessesHandleResponse(resp *http.Response) (AppsClientListProcessesResponse, error) {
	result := AppsClientListProcessesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfoCollection); err != nil {
		return AppsClientListProcessesResponse{}, err
	}
	return result, nil
}

// NewListProcessesSlotPager - Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance
// in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// options - AppsClientListProcessesSlotOptions contains the optional parameters for the AppsClient.ListProcessesSlot method.
func (client *AppsClient) NewListProcessesSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListProcessesSlotOptions) *runtime.Pager[AppsClientListProcessesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListProcessesSlotResponse]{
		More: func(page AppsClientListProcessesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListProcessesSlotResponse) (AppsClientListProcessesSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listProcessesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListProcessesSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListProcessesSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListProcessesSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listProcessesSlotHandleResponse(resp)
		},
	})
}

// listProcessesSlotCreateRequest creates the ListProcessesSlot request.
func (client *AppsClient) listProcessesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListProcessesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProcessesSlotHandleResponse handles the ListProcessesSlot response.
func (client *AppsClient) listProcessesSlotHandleResponse(resp *http.Response) (AppsClientListProcessesSlotResponse, error) {
	result := AppsClientListProcessesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfoCollection); err != nil {
		return AppsClientListProcessesSlotResponse{}, err
	}
	return result, nil
}

// NewListPublicCertificatesPager - Get public certificates for an app or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListPublicCertificatesOptions contains the optional parameters for the AppsClient.ListPublicCertificates
// method.
func (client *AppsClient) NewListPublicCertificatesPager(resourceGroupName string, name string, options *AppsClientListPublicCertificatesOptions) *runtime.Pager[AppsClientListPublicCertificatesResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListPublicCertificatesResponse]{
		More: func(page AppsClientListPublicCertificatesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListPublicCertificatesResponse) (AppsClientListPublicCertificatesResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listPublicCertificatesCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListPublicCertificatesResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListPublicCertificatesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListPublicCertificatesResponse{}, runtime.NewResponseError(resp)
			}
			return client.listPublicCertificatesHandleResponse(resp)
		},
	})
}

// listPublicCertificatesCreateRequest creates the ListPublicCertificates request.
func (client *AppsClient) listPublicCertificatesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListPublicCertificatesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPublicCertificatesHandleResponse handles the ListPublicCertificates response.
func (client *AppsClient) listPublicCertificatesHandleResponse(resp *http.Response) (AppsClientListPublicCertificatesResponse, error) {
	result := AppsClientListPublicCertificatesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificateCollection); err != nil {
		return AppsClientListPublicCertificatesResponse{}, err
	}
	return result, nil
}

// NewListPublicCertificatesSlotPager - Get public certificates for an app or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
// options - AppsClientListPublicCertificatesSlotOptions contains the optional parameters for the AppsClient.ListPublicCertificatesSlot
// method.
func (client *AppsClient) NewListPublicCertificatesSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListPublicCertificatesSlotOptions) *runtime.Pager[AppsClientListPublicCertificatesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListPublicCertificatesSlotResponse]{
		More: func(page AppsClientListPublicCertificatesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListPublicCertificatesSlotResponse) (AppsClientListPublicCertificatesSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listPublicCertificatesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListPublicCertificatesSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListPublicCertificatesSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListPublicCertificatesSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listPublicCertificatesSlotHandleResponse(resp)
		},
	})
}

// listPublicCertificatesSlotCreateRequest creates the ListPublicCertificatesSlot request.
func (client *AppsClient) listPublicCertificatesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListPublicCertificatesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPublicCertificatesSlotHandleResponse handles the ListPublicCertificatesSlot response.
func (client *AppsClient) listPublicCertificatesSlotHandleResponse(resp *http.Response) (AppsClientListPublicCertificatesSlotResponse, error) {
	result := AppsClientListPublicCertificatesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificateCollection); err != nil {
		return AppsClientListPublicCertificatesSlotResponse{}, err
	}
	return result, nil
}

// BeginListPublishingCredentials - Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientBeginListPublishingCredentialsOptions contains the optional parameters for the AppsClient.BeginListPublishingCredentials
// method.
func (client *AppsClient) BeginListPublishingCredentials(ctx context.Context, resourceGroupName string, name string, options *AppsClientBeginListPublishingCredentialsOptions) (*runtime.Poller[AppsClientListPublishingCredentialsResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.listPublishingCredentials(ctx, resourceGroupName, name, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientListPublishingCredentialsResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientListPublishingCredentialsResponse](options.ResumeToken, client.pl, nil)
	}
}

// ListPublishingCredentials - Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) listPublishingCredentials(ctx context.Context, resourceGroupName string, name string, options *AppsClientBeginListPublishingCredentialsOptions) (*http.Response, error) {
	req, err := client.listPublishingCredentialsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// listPublishingCredentialsCreateRequest creates the ListPublishingCredentials request.
func (client *AppsClient) listPublishingCredentialsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientBeginListPublishingCredentialsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginListPublishingCredentialsSlot - Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production
// slot.
// options - AppsClientBeginListPublishingCredentialsSlotOptions contains the optional parameters for the AppsClient.BeginListPublishingCredentialsSlot
// method.
func (client *AppsClient) BeginListPublishingCredentialsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientBeginListPublishingCredentialsSlotOptions) (*runtime.Poller[AppsClientListPublishingCredentialsSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.listPublishingCredentialsSlot(ctx, resourceGroupName, name, slot, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientListPublishingCredentialsSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientListPublishingCredentialsSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// ListPublishingCredentialsSlot - Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) listPublishingCredentialsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientBeginListPublishingCredentialsSlotOptions) (*http.Response, error) {
	req, err := client.listPublishingCredentialsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// listPublishingCredentialsSlotCreateRequest creates the ListPublishingCredentialsSlot request.
func (client *AppsClient) listPublishingCredentialsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientBeginListPublishingCredentialsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ListPublishingProfileXMLWithSecrets - Gets the publishing profile for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// publishingProfileOptions - Specifies publishingProfileOptions for publishing profile. For example, use {"format": "FileZilla3"}
// to get a FileZilla publishing profile.
// options - AppsClientListPublishingProfileXMLWithSecretsOptions contains the optional parameters for the AppsClient.ListPublishingProfileXMLWithSecrets
// method.
func (client *AppsClient) ListPublishingProfileXMLWithSecrets(ctx context.Context, resourceGroupName string, name string, publishingProfileOptions CsmPublishingProfileOptions, options *AppsClientListPublishingProfileXMLWithSecretsOptions) (AppsClientListPublishingProfileXMLWithSecretsResponse, error) {
	req, err := client.listPublishingProfileXMLWithSecretsCreateRequest(ctx, resourceGroupName, name, publishingProfileOptions, options)
	if err != nil {
		return AppsClientListPublishingProfileXMLWithSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListPublishingProfileXMLWithSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListPublishingProfileXMLWithSecretsResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientListPublishingProfileXMLWithSecretsResponse{Body: resp.Body}, nil
}

// listPublishingProfileXMLWithSecretsCreateRequest creates the ListPublishingProfileXMLWithSecrets request.
func (client *AppsClient) listPublishingProfileXMLWithSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, publishingProfileOptions CsmPublishingProfileOptions, options *AppsClientListPublishingProfileXMLWithSecretsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, runtime.MarshalAsJSON(req, publishingProfileOptions)
}

// ListPublishingProfileXMLWithSecretsSlot - Gets the publishing profile for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production
// slot.
// publishingProfileOptions - Specifies publishingProfileOptions for publishing profile. For example, use {"format": "FileZilla3"}
// to get a FileZilla publishing profile.
// options - AppsClientListPublishingProfileXMLWithSecretsSlotOptions contains the optional parameters for the AppsClient.ListPublishingProfileXMLWithSecretsSlot
// method.
func (client *AppsClient) ListPublishingProfileXMLWithSecretsSlot(ctx context.Context, resourceGroupName string, name string, slot string, publishingProfileOptions CsmPublishingProfileOptions, options *AppsClientListPublishingProfileXMLWithSecretsSlotOptions) (AppsClientListPublishingProfileXMLWithSecretsSlotResponse, error) {
	req, err := client.listPublishingProfileXMLWithSecretsSlotCreateRequest(ctx, resourceGroupName, name, slot, publishingProfileOptions, options)
	if err != nil {
		return AppsClientListPublishingProfileXMLWithSecretsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListPublishingProfileXMLWithSecretsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListPublishingProfileXMLWithSecretsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientListPublishingProfileXMLWithSecretsSlotResponse{Body: resp.Body}, nil
}

// listPublishingProfileXMLWithSecretsSlotCreateRequest creates the ListPublishingProfileXMLWithSecretsSlot request.
func (client *AppsClient) listPublishingProfileXMLWithSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, publishingProfileOptions CsmPublishingProfileOptions, options *AppsClientListPublishingProfileXMLWithSecretsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, runtime.MarshalAsJSON(req, publishingProfileOptions)
}

// ListRelayServiceConnections - Gets hybrid connections configured for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListRelayServiceConnectionsOptions contains the optional parameters for the AppsClient.ListRelayServiceConnections
// method.
func (client *AppsClient) ListRelayServiceConnections(ctx context.Context, resourceGroupName string, name string, options *AppsClientListRelayServiceConnectionsOptions) (AppsClientListRelayServiceConnectionsResponse, error) {
	req, err := client.listRelayServiceConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListRelayServiceConnectionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListRelayServiceConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListRelayServiceConnectionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listRelayServiceConnectionsHandleResponse(resp)
}

// listRelayServiceConnectionsCreateRequest creates the ListRelayServiceConnections request.
func (client *AppsClient) listRelayServiceConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListRelayServiceConnectionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listRelayServiceConnectionsHandleResponse handles the ListRelayServiceConnections response.
func (client *AppsClient) listRelayServiceConnectionsHandleResponse(resp *http.Response) (AppsClientListRelayServiceConnectionsResponse, error) {
	result := AppsClientListRelayServiceConnectionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return AppsClientListRelayServiceConnectionsResponse{}, err
	}
	return result, nil
}

// ListRelayServiceConnectionsSlot - Gets hybrid connections configured for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get hybrid connections for the production
// slot.
// options - AppsClientListRelayServiceConnectionsSlotOptions contains the optional parameters for the AppsClient.ListRelayServiceConnectionsSlot
// method.
func (client *AppsClient) ListRelayServiceConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListRelayServiceConnectionsSlotOptions) (AppsClientListRelayServiceConnectionsSlotResponse, error) {
	req, err := client.listRelayServiceConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientListRelayServiceConnectionsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListRelayServiceConnectionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListRelayServiceConnectionsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listRelayServiceConnectionsSlotHandleResponse(resp)
}

// listRelayServiceConnectionsSlotCreateRequest creates the ListRelayServiceConnectionsSlot request.
func (client *AppsClient) listRelayServiceConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListRelayServiceConnectionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listRelayServiceConnectionsSlotHandleResponse handles the ListRelayServiceConnectionsSlot response.
func (client *AppsClient) listRelayServiceConnectionsSlotHandleResponse(resp *http.Response) (AppsClientListRelayServiceConnectionsSlotResponse, error) {
	result := AppsClientListRelayServiceConnectionsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return AppsClientListRelayServiceConnectionsSlotResponse{}, err
	}
	return result, nil
}

// NewListSiteExtensionsPager - Get list of siteextensions for a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// options - AppsClientListSiteExtensionsOptions contains the optional parameters for the AppsClient.ListSiteExtensions method.
func (client *AppsClient) NewListSiteExtensionsPager(resourceGroupName string, name string, options *AppsClientListSiteExtensionsOptions) *runtime.Pager[AppsClientListSiteExtensionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListSiteExtensionsResponse]{
		More: func(page AppsClientListSiteExtensionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListSiteExtensionsResponse) (AppsClientListSiteExtensionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listSiteExtensionsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListSiteExtensionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListSiteExtensionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListSiteExtensionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listSiteExtensionsHandleResponse(resp)
		},
	})
}

// listSiteExtensionsCreateRequest creates the ListSiteExtensions request.
func (client *AppsClient) listSiteExtensionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListSiteExtensionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSiteExtensionsHandleResponse handles the ListSiteExtensions response.
func (client *AppsClient) listSiteExtensionsHandleResponse(resp *http.Response) (AppsClientListSiteExtensionsResponse, error) {
	result := AppsClientListSiteExtensionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteExtensionInfoCollection); err != nil {
		return AppsClientListSiteExtensionsResponse{}, err
	}
	return result, nil
}

// NewListSiteExtensionsSlotPager - Get list of siteextensions for a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientListSiteExtensionsSlotOptions contains the optional parameters for the AppsClient.ListSiteExtensionsSlot
// method.
func (client *AppsClient) NewListSiteExtensionsSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListSiteExtensionsSlotOptions) *runtime.Pager[AppsClientListSiteExtensionsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListSiteExtensionsSlotResponse]{
		More: func(page AppsClientListSiteExtensionsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListSiteExtensionsSlotResponse) (AppsClientListSiteExtensionsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listSiteExtensionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListSiteExtensionsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListSiteExtensionsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListSiteExtensionsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listSiteExtensionsSlotHandleResponse(resp)
		},
	})
}

// listSiteExtensionsSlotCreateRequest creates the ListSiteExtensionsSlot request.
func (client *AppsClient) listSiteExtensionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListSiteExtensionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSiteExtensionsSlotHandleResponse handles the ListSiteExtensionsSlot response.
func (client *AppsClient) listSiteExtensionsSlotHandleResponse(resp *http.Response) (AppsClientListSiteExtensionsSlotResponse, error) {
	result := AppsClientListSiteExtensionsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteExtensionInfoCollection); err != nil {
		return AppsClientListSiteExtensionsSlotResponse{}, err
	}
	return result, nil
}

// ListSitePushSettings - Gets the Push settings associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// options - AppsClientListSitePushSettingsOptions contains the optional parameters for the AppsClient.ListSitePushSettings
// method.
func (client *AppsClient) ListSitePushSettings(ctx context.Context, resourceGroupName string, name string, options *AppsClientListSitePushSettingsOptions) (AppsClientListSitePushSettingsResponse, error) {
	req, err := client.listSitePushSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListSitePushSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListSitePushSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListSitePushSettingsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listSitePushSettingsHandleResponse(resp)
}

// listSitePushSettingsCreateRequest creates the ListSitePushSettings request.
func (client *AppsClient) listSitePushSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListSitePushSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSitePushSettingsHandleResponse handles the ListSitePushSettings response.
func (client *AppsClient) listSitePushSettingsHandleResponse(resp *http.Response) (AppsClientListSitePushSettingsResponse, error) {
	result := AppsClientListSitePushSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PushSettings); err != nil {
		return AppsClientListSitePushSettingsResponse{}, err
	}
	return result, nil
}

// ListSitePushSettingsSlot - Gets the Push settings associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// options - AppsClientListSitePushSettingsSlotOptions contains the optional parameters for the AppsClient.ListSitePushSettingsSlot
// method.
func (client *AppsClient) ListSitePushSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListSitePushSettingsSlotOptions) (AppsClientListSitePushSettingsSlotResponse, error) {
	req, err := client.listSitePushSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientListSitePushSettingsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListSitePushSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListSitePushSettingsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listSitePushSettingsSlotHandleResponse(resp)
}

// listSitePushSettingsSlotCreateRequest creates the ListSitePushSettingsSlot request.
func (client *AppsClient) listSitePushSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListSitePushSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSitePushSettingsSlotHandleResponse handles the ListSitePushSettingsSlot response.
func (client *AppsClient) listSitePushSettingsSlotHandleResponse(resp *http.Response) (AppsClientListSitePushSettingsSlotResponse, error) {
	result := AppsClientListSitePushSettingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PushSettings); err != nil {
		return AppsClientListSitePushSettingsSlotResponse{}, err
	}
	return result, nil
}

// ListSlotConfigurationNames - Gets the names of app settings and connection strings that stick to the slot (not swapped).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListSlotConfigurationNamesOptions contains the optional parameters for the AppsClient.ListSlotConfigurationNames
// method.
func (client *AppsClient) ListSlotConfigurationNames(ctx context.Context, resourceGroupName string, name string, options *AppsClientListSlotConfigurationNamesOptions) (AppsClientListSlotConfigurationNamesResponse, error) {
	req, err := client.listSlotConfigurationNamesCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListSlotConfigurationNamesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListSlotConfigurationNamesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListSlotConfigurationNamesResponse{}, runtime.NewResponseError(resp)
	}
	return client.listSlotConfigurationNamesHandleResponse(resp)
}

// listSlotConfigurationNamesCreateRequest creates the ListSlotConfigurationNames request.
func (client *AppsClient) listSlotConfigurationNamesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListSlotConfigurationNamesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSlotConfigurationNamesHandleResponse handles the ListSlotConfigurationNames response.
func (client *AppsClient) listSlotConfigurationNamesHandleResponse(resp *http.Response) (AppsClientListSlotConfigurationNamesResponse, error) {
	result := AppsClientListSlotConfigurationNamesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SlotConfigNamesResource); err != nil {
		return AppsClientListSlotConfigurationNamesResponse{}, err
	}
	return result, nil
}

// NewListSlotDifferencesFromProductionPager - Get the difference in configuration settings between two web app slots.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slotSwapEntity - JSON object that contains the target slot name. See example.
// options - AppsClientListSlotDifferencesFromProductionOptions contains the optional parameters for the AppsClient.ListSlotDifferencesFromProduction
// method.
func (client *AppsClient) NewListSlotDifferencesFromProductionPager(resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *AppsClientListSlotDifferencesFromProductionOptions) *runtime.Pager[AppsClientListSlotDifferencesFromProductionResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListSlotDifferencesFromProductionResponse]{
		More: func(page AppsClientListSlotDifferencesFromProductionResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListSlotDifferencesFromProductionResponse) (AppsClientListSlotDifferencesFromProductionResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listSlotDifferencesFromProductionCreateRequest(ctx, resourceGroupName, name, slotSwapEntity, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListSlotDifferencesFromProductionResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListSlotDifferencesFromProductionResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListSlotDifferencesFromProductionResponse{}, runtime.NewResponseError(resp)
			}
			return client.listSlotDifferencesFromProductionHandleResponse(resp)
		},
	})
}

// listSlotDifferencesFromProductionCreateRequest creates the ListSlotDifferencesFromProduction request.
func (client *AppsClient) listSlotDifferencesFromProductionCreateRequest(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *AppsClientListSlotDifferencesFromProductionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, slotSwapEntity)
}

// listSlotDifferencesFromProductionHandleResponse handles the ListSlotDifferencesFromProduction response.
func (client *AppsClient) listSlotDifferencesFromProductionHandleResponse(resp *http.Response) (AppsClientListSlotDifferencesFromProductionResponse, error) {
	result := AppsClientListSlotDifferencesFromProductionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SlotDifferenceCollection); err != nil {
		return AppsClientListSlotDifferencesFromProductionResponse{}, err
	}
	return result, nil
}

// NewListSlotDifferencesSlotPager - Get the difference in configuration settings between two web app slots.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
// slotSwapEntity - JSON object that contains the target slot name. See example.
// options - AppsClientListSlotDifferencesSlotOptions contains the optional parameters for the AppsClient.ListSlotDifferencesSlot
// method.
func (client *AppsClient) NewListSlotDifferencesSlotPager(resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *AppsClientListSlotDifferencesSlotOptions) *runtime.Pager[AppsClientListSlotDifferencesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListSlotDifferencesSlotResponse]{
		More: func(page AppsClientListSlotDifferencesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListSlotDifferencesSlotResponse) (AppsClientListSlotDifferencesSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listSlotDifferencesSlotCreateRequest(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListSlotDifferencesSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListSlotDifferencesSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListSlotDifferencesSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listSlotDifferencesSlotHandleResponse(resp)
		},
	})
}

// listSlotDifferencesSlotCreateRequest creates the ListSlotDifferencesSlot request.
func (client *AppsClient) listSlotDifferencesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *AppsClientListSlotDifferencesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, slotSwapEntity)
}

// listSlotDifferencesSlotHandleResponse handles the ListSlotDifferencesSlot response.
func (client *AppsClient) listSlotDifferencesSlotHandleResponse(resp *http.Response) (AppsClientListSlotDifferencesSlotResponse, error) {
	result := AppsClientListSlotDifferencesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SlotDifferenceCollection); err != nil {
		return AppsClientListSlotDifferencesSlotResponse{}, err
	}
	return result, nil
}

// NewListSlotsPager - Gets an app's deployment slots.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListSlotsOptions contains the optional parameters for the AppsClient.ListSlots method.
func (client *AppsClient) NewListSlotsPager(resourceGroupName string, name string, options *AppsClientListSlotsOptions) *runtime.Pager[AppsClientListSlotsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListSlotsResponse]{
		More: func(page AppsClientListSlotsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListSlotsResponse) (AppsClientListSlotsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listSlotsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListSlotsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListSlotsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListSlotsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listSlotsHandleResponse(resp)
		},
	})
}

// listSlotsCreateRequest creates the ListSlots request.
func (client *AppsClient) listSlotsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListSlotsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSlotsHandleResponse handles the ListSlots response.
func (client *AppsClient) listSlotsHandleResponse(resp *http.Response) (AppsClientListSlotsResponse, error) {
	result := AppsClientListSlotsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppCollection); err != nil {
		return AppsClientListSlotsResponse{}, err
	}
	return result, nil
}

// NewListSnapshotsPager - Returns all Snapshots to the user.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Website Name.
// options - AppsClientListSnapshotsOptions contains the optional parameters for the AppsClient.ListSnapshots method.
func (client *AppsClient) NewListSnapshotsPager(resourceGroupName string, name string, options *AppsClientListSnapshotsOptions) *runtime.Pager[AppsClientListSnapshotsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListSnapshotsResponse]{
		More: func(page AppsClientListSnapshotsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListSnapshotsResponse) (AppsClientListSnapshotsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listSnapshotsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListSnapshotsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListSnapshotsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListSnapshotsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listSnapshotsHandleResponse(resp)
		},
	})
}

// listSnapshotsCreateRequest creates the ListSnapshots request.
func (client *AppsClient) listSnapshotsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListSnapshotsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSnapshotsHandleResponse handles the ListSnapshots response.
func (client *AppsClient) listSnapshotsHandleResponse(resp *http.Response) (AppsClientListSnapshotsResponse, error) {
	result := AppsClientListSnapshotsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SnapshotCollection); err != nil {
		return AppsClientListSnapshotsResponse{}, err
	}
	return result, nil
}

// NewListSnapshotsFromDRSecondaryPager - Returns all Snapshots to the user from DRSecondary endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Website Name.
// options - AppsClientListSnapshotsFromDRSecondaryOptions contains the optional parameters for the AppsClient.ListSnapshotsFromDRSecondary
// method.
func (client *AppsClient) NewListSnapshotsFromDRSecondaryPager(resourceGroupName string, name string, options *AppsClientListSnapshotsFromDRSecondaryOptions) *runtime.Pager[AppsClientListSnapshotsFromDRSecondaryResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListSnapshotsFromDRSecondaryResponse]{
		More: func(page AppsClientListSnapshotsFromDRSecondaryResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListSnapshotsFromDRSecondaryResponse) (AppsClientListSnapshotsFromDRSecondaryResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listSnapshotsFromDRSecondaryCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListSnapshotsFromDRSecondaryResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListSnapshotsFromDRSecondaryResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListSnapshotsFromDRSecondaryResponse{}, runtime.NewResponseError(resp)
			}
			return client.listSnapshotsFromDRSecondaryHandleResponse(resp)
		},
	})
}

// listSnapshotsFromDRSecondaryCreateRequest creates the ListSnapshotsFromDRSecondary request.
func (client *AppsClient) listSnapshotsFromDRSecondaryCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListSnapshotsFromDRSecondaryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshotsdr"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSnapshotsFromDRSecondaryHandleResponse handles the ListSnapshotsFromDRSecondary response.
func (client *AppsClient) listSnapshotsFromDRSecondaryHandleResponse(resp *http.Response) (AppsClientListSnapshotsFromDRSecondaryResponse, error) {
	result := AppsClientListSnapshotsFromDRSecondaryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SnapshotCollection); err != nil {
		return AppsClientListSnapshotsFromDRSecondaryResponse{}, err
	}
	return result, nil
}

// NewListSnapshotsFromDRSecondarySlotPager - Returns all Snapshots to the user from DRSecondary endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Website Name.
// slot - Website Slot.
// options - AppsClientListSnapshotsFromDRSecondarySlotOptions contains the optional parameters for the AppsClient.ListSnapshotsFromDRSecondarySlot
// method.
func (client *AppsClient) NewListSnapshotsFromDRSecondarySlotPager(resourceGroupName string, name string, slot string, options *AppsClientListSnapshotsFromDRSecondarySlotOptions) *runtime.Pager[AppsClientListSnapshotsFromDRSecondarySlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListSnapshotsFromDRSecondarySlotResponse]{
		More: func(page AppsClientListSnapshotsFromDRSecondarySlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListSnapshotsFromDRSecondarySlotResponse) (AppsClientListSnapshotsFromDRSecondarySlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listSnapshotsFromDRSecondarySlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListSnapshotsFromDRSecondarySlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListSnapshotsFromDRSecondarySlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListSnapshotsFromDRSecondarySlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listSnapshotsFromDRSecondarySlotHandleResponse(resp)
		},
	})
}

// listSnapshotsFromDRSecondarySlotCreateRequest creates the ListSnapshotsFromDRSecondarySlot request.
func (client *AppsClient) listSnapshotsFromDRSecondarySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListSnapshotsFromDRSecondarySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshotsdr"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSnapshotsFromDRSecondarySlotHandleResponse handles the ListSnapshotsFromDRSecondarySlot response.
func (client *AppsClient) listSnapshotsFromDRSecondarySlotHandleResponse(resp *http.Response) (AppsClientListSnapshotsFromDRSecondarySlotResponse, error) {
	result := AppsClientListSnapshotsFromDRSecondarySlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SnapshotCollection); err != nil {
		return AppsClientListSnapshotsFromDRSecondarySlotResponse{}, err
	}
	return result, nil
}

// NewListSnapshotsSlotPager - Returns all Snapshots to the user.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Website Name.
// slot - Website Slot.
// options - AppsClientListSnapshotsSlotOptions contains the optional parameters for the AppsClient.ListSnapshotsSlot method.
func (client *AppsClient) NewListSnapshotsSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListSnapshotsSlotOptions) *runtime.Pager[AppsClientListSnapshotsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListSnapshotsSlotResponse]{
		More: func(page AppsClientListSnapshotsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListSnapshotsSlotResponse) (AppsClientListSnapshotsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listSnapshotsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListSnapshotsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListSnapshotsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListSnapshotsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listSnapshotsSlotHandleResponse(resp)
		},
	})
}

// listSnapshotsSlotCreateRequest creates the ListSnapshotsSlot request.
func (client *AppsClient) listSnapshotsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListSnapshotsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSnapshotsSlotHandleResponse handles the ListSnapshotsSlot response.
func (client *AppsClient) listSnapshotsSlotHandleResponse(resp *http.Response) (AppsClientListSnapshotsSlotResponse, error) {
	result := AppsClientListSnapshotsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SnapshotCollection); err != nil {
		return AppsClientListSnapshotsSlotResponse{}, err
	}
	return result, nil
}

// ListSyncFunctionTriggers - This is to allow calling via powershell and ARM template.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListSyncFunctionTriggersOptions contains the optional parameters for the AppsClient.ListSyncFunctionTriggers
// method.
func (client *AppsClient) ListSyncFunctionTriggers(ctx context.Context, resourceGroupName string, name string, options *AppsClientListSyncFunctionTriggersOptions) (AppsClientListSyncFunctionTriggersResponse, error) {
	req, err := client.listSyncFunctionTriggersCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListSyncFunctionTriggersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListSyncFunctionTriggersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListSyncFunctionTriggersResponse{}, runtime.NewResponseError(resp)
	}
	return client.listSyncFunctionTriggersHandleResponse(resp)
}

// listSyncFunctionTriggersCreateRequest creates the ListSyncFunctionTriggers request.
func (client *AppsClient) listSyncFunctionTriggersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListSyncFunctionTriggersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listsyncfunctiontriggerstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSyncFunctionTriggersHandleResponse handles the ListSyncFunctionTriggers response.
func (client *AppsClient) listSyncFunctionTriggersHandleResponse(resp *http.Response) (AppsClientListSyncFunctionTriggersResponse, error) {
	result := AppsClientListSyncFunctionTriggersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionSecrets); err != nil {
		return AppsClientListSyncFunctionTriggersResponse{}, err
	}
	return result, nil
}

// ListSyncFunctionTriggersSlot - This is to allow calling via powershell and ARM template.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot.
// options - AppsClientListSyncFunctionTriggersSlotOptions contains the optional parameters for the AppsClient.ListSyncFunctionTriggersSlot
// method.
func (client *AppsClient) ListSyncFunctionTriggersSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListSyncFunctionTriggersSlotOptions) (AppsClientListSyncFunctionTriggersSlotResponse, error) {
	req, err := client.listSyncFunctionTriggersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientListSyncFunctionTriggersSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListSyncFunctionTriggersSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListSyncFunctionTriggersSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listSyncFunctionTriggersSlotHandleResponse(resp)
}

// listSyncFunctionTriggersSlotCreateRequest creates the ListSyncFunctionTriggersSlot request.
func (client *AppsClient) listSyncFunctionTriggersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListSyncFunctionTriggersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listsyncfunctiontriggerstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSyncFunctionTriggersSlotHandleResponse handles the ListSyncFunctionTriggersSlot response.
func (client *AppsClient) listSyncFunctionTriggersSlotHandleResponse(resp *http.Response) (AppsClientListSyncFunctionTriggersSlotResponse, error) {
	result := AppsClientListSyncFunctionTriggersSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionSecrets); err != nil {
		return AppsClientListSyncFunctionTriggersSlotResponse{}, err
	}
	return result, nil
}

// ListSyncStatus - This is to allow calling via powershell and ARM template.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListSyncStatusOptions contains the optional parameters for the AppsClient.ListSyncStatus method.
func (client *AppsClient) ListSyncStatus(ctx context.Context, resourceGroupName string, name string, options *AppsClientListSyncStatusOptions) (AppsClientListSyncStatusResponse, error) {
	req, err := client.listSyncStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListSyncStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListSyncStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return AppsClientListSyncStatusResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientListSyncStatusResponse{}, nil
}

// listSyncStatusCreateRequest creates the ListSyncStatus request.
func (client *AppsClient) listSyncStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListSyncStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/listsyncstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ListSyncStatusSlot - This is to allow calling via powershell and ARM template.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot.
// options - AppsClientListSyncStatusSlotOptions contains the optional parameters for the AppsClient.ListSyncStatusSlot method.
func (client *AppsClient) ListSyncStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListSyncStatusSlotOptions) (AppsClientListSyncStatusSlotResponse, error) {
	req, err := client.listSyncStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientListSyncStatusSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListSyncStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return AppsClientListSyncStatusSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientListSyncStatusSlotResponse{}, nil
}

// listSyncStatusSlotCreateRequest creates the ListSyncStatusSlot request.
func (client *AppsClient) listSyncStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListSyncStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/listsyncstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// NewListTriggeredWebJobHistoryPager - List a triggered web job's history for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// options - AppsClientListTriggeredWebJobHistoryOptions contains the optional parameters for the AppsClient.ListTriggeredWebJobHistory
// method.
func (client *AppsClient) NewListTriggeredWebJobHistoryPager(resourceGroupName string, name string, webJobName string, options *AppsClientListTriggeredWebJobHistoryOptions) *runtime.Pager[AppsClientListTriggeredWebJobHistoryResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListTriggeredWebJobHistoryResponse]{
		More: func(page AppsClientListTriggeredWebJobHistoryResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListTriggeredWebJobHistoryResponse) (AppsClientListTriggeredWebJobHistoryResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listTriggeredWebJobHistoryCreateRequest(ctx, resourceGroupName, name, webJobName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListTriggeredWebJobHistoryResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListTriggeredWebJobHistoryResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListTriggeredWebJobHistoryResponse{}, runtime.NewResponseError(resp)
			}
			return client.listTriggeredWebJobHistoryHandleResponse(resp)
		},
	})
}

// listTriggeredWebJobHistoryCreateRequest creates the ListTriggeredWebJobHistory request.
func (client *AppsClient) listTriggeredWebJobHistoryCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientListTriggeredWebJobHistoryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listTriggeredWebJobHistoryHandleResponse handles the ListTriggeredWebJobHistory response.
func (client *AppsClient) listTriggeredWebJobHistoryHandleResponse(resp *http.Response) (AppsClientListTriggeredWebJobHistoryResponse, error) {
	result := AppsClientListTriggeredWebJobHistoryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredJobHistoryCollection); err != nil {
		return AppsClientListTriggeredWebJobHistoryResponse{}, err
	}
	return result, nil
}

// NewListTriggeredWebJobHistorySlotPager - List a triggered web job's history for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientListTriggeredWebJobHistorySlotOptions contains the optional parameters for the AppsClient.ListTriggeredWebJobHistorySlot
// method.
func (client *AppsClient) NewListTriggeredWebJobHistorySlotPager(resourceGroupName string, name string, webJobName string, slot string, options *AppsClientListTriggeredWebJobHistorySlotOptions) *runtime.Pager[AppsClientListTriggeredWebJobHistorySlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListTriggeredWebJobHistorySlotResponse]{
		More: func(page AppsClientListTriggeredWebJobHistorySlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListTriggeredWebJobHistorySlotResponse) (AppsClientListTriggeredWebJobHistorySlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listTriggeredWebJobHistorySlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListTriggeredWebJobHistorySlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListTriggeredWebJobHistorySlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListTriggeredWebJobHistorySlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listTriggeredWebJobHistorySlotHandleResponse(resp)
		},
	})
}

// listTriggeredWebJobHistorySlotCreateRequest creates the ListTriggeredWebJobHistorySlot request.
func (client *AppsClient) listTriggeredWebJobHistorySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientListTriggeredWebJobHistorySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listTriggeredWebJobHistorySlotHandleResponse handles the ListTriggeredWebJobHistorySlot response.
func (client *AppsClient) listTriggeredWebJobHistorySlotHandleResponse(resp *http.Response) (AppsClientListTriggeredWebJobHistorySlotResponse, error) {
	result := AppsClientListTriggeredWebJobHistorySlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredJobHistoryCollection); err != nil {
		return AppsClientListTriggeredWebJobHistorySlotResponse{}, err
	}
	return result, nil
}

// NewListTriggeredWebJobsPager - List triggered web jobs for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// options - AppsClientListTriggeredWebJobsOptions contains the optional parameters for the AppsClient.ListTriggeredWebJobs
// method.
func (client *AppsClient) NewListTriggeredWebJobsPager(resourceGroupName string, name string, options *AppsClientListTriggeredWebJobsOptions) *runtime.Pager[AppsClientListTriggeredWebJobsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListTriggeredWebJobsResponse]{
		More: func(page AppsClientListTriggeredWebJobsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListTriggeredWebJobsResponse) (AppsClientListTriggeredWebJobsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listTriggeredWebJobsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListTriggeredWebJobsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListTriggeredWebJobsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListTriggeredWebJobsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listTriggeredWebJobsHandleResponse(resp)
		},
	})
}

// listTriggeredWebJobsCreateRequest creates the ListTriggeredWebJobs request.
func (client *AppsClient) listTriggeredWebJobsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListTriggeredWebJobsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listTriggeredWebJobsHandleResponse handles the ListTriggeredWebJobs response.
func (client *AppsClient) listTriggeredWebJobsHandleResponse(resp *http.Response) (AppsClientListTriggeredWebJobsResponse, error) {
	result := AppsClientListTriggeredWebJobsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredWebJobCollection); err != nil {
		return AppsClientListTriggeredWebJobsResponse{}, err
	}
	return result, nil
}

// NewListTriggeredWebJobsSlotPager - List triggered web jobs for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientListTriggeredWebJobsSlotOptions contains the optional parameters for the AppsClient.ListTriggeredWebJobsSlot
// method.
func (client *AppsClient) NewListTriggeredWebJobsSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListTriggeredWebJobsSlotOptions) *runtime.Pager[AppsClientListTriggeredWebJobsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListTriggeredWebJobsSlotResponse]{
		More: func(page AppsClientListTriggeredWebJobsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListTriggeredWebJobsSlotResponse) (AppsClientListTriggeredWebJobsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listTriggeredWebJobsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListTriggeredWebJobsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListTriggeredWebJobsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListTriggeredWebJobsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listTriggeredWebJobsSlotHandleResponse(resp)
		},
	})
}

// listTriggeredWebJobsSlotCreateRequest creates the ListTriggeredWebJobsSlot request.
func (client *AppsClient) listTriggeredWebJobsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListTriggeredWebJobsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listTriggeredWebJobsSlotHandleResponse handles the ListTriggeredWebJobsSlot response.
func (client *AppsClient) listTriggeredWebJobsSlotHandleResponse(resp *http.Response) (AppsClientListTriggeredWebJobsSlotResponse, error) {
	result := AppsClientListTriggeredWebJobsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredWebJobCollection); err != nil {
		return AppsClientListTriggeredWebJobsSlotResponse{}, err
	}
	return result, nil
}

// NewListUsagesPager - Gets the quota usage information of an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListUsagesOptions contains the optional parameters for the AppsClient.ListUsages method.
func (client *AppsClient) NewListUsagesPager(resourceGroupName string, name string, options *AppsClientListUsagesOptions) *runtime.Pager[AppsClientListUsagesResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListUsagesResponse]{
		More: func(page AppsClientListUsagesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListUsagesResponse) (AppsClientListUsagesResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listUsagesCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListUsagesResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListUsagesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListUsagesResponse{}, runtime.NewResponseError(resp)
			}
			return client.listUsagesHandleResponse(resp)
		},
	})
}

// listUsagesCreateRequest creates the ListUsages request.
func (client *AppsClient) listUsagesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListUsagesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listUsagesHandleResponse handles the ListUsages response.
func (client *AppsClient) listUsagesHandleResponse(resp *http.Response) (AppsClientListUsagesResponse, error) {
	result := AppsClientListUsagesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmUsageQuotaCollection); err != nil {
		return AppsClientListUsagesResponse{}, err
	}
	return result, nil
}

// NewListUsagesSlotPager - Gets the quota usage information of an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
// options - AppsClientListUsagesSlotOptions contains the optional parameters for the AppsClient.ListUsagesSlot method.
func (client *AppsClient) NewListUsagesSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListUsagesSlotOptions) *runtime.Pager[AppsClientListUsagesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListUsagesSlotResponse]{
		More: func(page AppsClientListUsagesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListUsagesSlotResponse) (AppsClientListUsagesSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listUsagesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListUsagesSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListUsagesSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListUsagesSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listUsagesSlotHandleResponse(resp)
		},
	})
}

// listUsagesSlotCreateRequest creates the ListUsagesSlot request.
func (client *AppsClient) listUsagesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListUsagesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listUsagesSlotHandleResponse handles the ListUsagesSlot response.
func (client *AppsClient) listUsagesSlotHandleResponse(resp *http.Response) (AppsClientListUsagesSlotResponse, error) {
	result := AppsClientListUsagesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmUsageQuotaCollection); err != nil {
		return AppsClientListUsagesSlotResponse{}, err
	}
	return result, nil
}

// ListVnetConnections - Gets the virtual networks the app (or deployment slot) is connected to.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientListVnetConnectionsOptions contains the optional parameters for the AppsClient.ListVnetConnections
// method.
func (client *AppsClient) ListVnetConnections(ctx context.Context, resourceGroupName string, name string, options *AppsClientListVnetConnectionsOptions) (AppsClientListVnetConnectionsResponse, error) {
	req, err := client.listVnetConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientListVnetConnectionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListVnetConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListVnetConnectionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listVnetConnectionsHandleResponse(resp)
}

// listVnetConnectionsCreateRequest creates the ListVnetConnections request.
func (client *AppsClient) listVnetConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListVnetConnectionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listVnetConnectionsHandleResponse handles the ListVnetConnections response.
func (client *AppsClient) listVnetConnectionsHandleResponse(resp *http.Response) (AppsClientListVnetConnectionsResponse, error) {
	result := AppsClientListVnetConnectionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoArray); err != nil {
		return AppsClientListVnetConnectionsResponse{}, err
	}
	return result, nil
}

// ListVnetConnectionsSlot - Gets the virtual networks the app (or deployment slot) is connected to.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will get virtual network connections for the production
// slot.
// options - AppsClientListVnetConnectionsSlotOptions contains the optional parameters for the AppsClient.ListVnetConnectionsSlot
// method.
func (client *AppsClient) ListVnetConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListVnetConnectionsSlotOptions) (AppsClientListVnetConnectionsSlotResponse, error) {
	req, err := client.listVnetConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientListVnetConnectionsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientListVnetConnectionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientListVnetConnectionsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.listVnetConnectionsSlotHandleResponse(resp)
}

// listVnetConnectionsSlotCreateRequest creates the ListVnetConnectionsSlot request.
func (client *AppsClient) listVnetConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListVnetConnectionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listVnetConnectionsSlotHandleResponse handles the ListVnetConnectionsSlot response.
func (client *AppsClient) listVnetConnectionsSlotHandleResponse(resp *http.Response) (AppsClientListVnetConnectionsSlotResponse, error) {
	result := AppsClientListVnetConnectionsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoArray); err != nil {
		return AppsClientListVnetConnectionsSlotResponse{}, err
	}
	return result, nil
}

// NewListWebJobsPager - List webjobs for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// options - AppsClientListWebJobsOptions contains the optional parameters for the AppsClient.ListWebJobs method.
func (client *AppsClient) NewListWebJobsPager(resourceGroupName string, name string, options *AppsClientListWebJobsOptions) *runtime.Pager[AppsClientListWebJobsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListWebJobsResponse]{
		More: func(page AppsClientListWebJobsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListWebJobsResponse) (AppsClientListWebJobsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listWebJobsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListWebJobsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListWebJobsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListWebJobsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listWebJobsHandleResponse(resp)
		},
	})
}

// listWebJobsCreateRequest creates the ListWebJobs request.
func (client *AppsClient) listWebJobsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientListWebJobsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listWebJobsHandleResponse handles the ListWebJobs response.
func (client *AppsClient) listWebJobsHandleResponse(resp *http.Response) (AppsClientListWebJobsResponse, error) {
	result := AppsClientListWebJobsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.JobCollection); err != nil {
		return AppsClientListWebJobsResponse{}, err
	}
	return result, nil
}

// NewListWebJobsSlotPager - List webjobs for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
// options - AppsClientListWebJobsSlotOptions contains the optional parameters for the AppsClient.ListWebJobsSlot method.
func (client *AppsClient) NewListWebJobsSlotPager(resourceGroupName string, name string, slot string, options *AppsClientListWebJobsSlotOptions) *runtime.Pager[AppsClientListWebJobsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppsClientListWebJobsSlotResponse]{
		More: func(page AppsClientListWebJobsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppsClientListWebJobsSlotResponse) (AppsClientListWebJobsSlotResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listWebJobsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppsClientListWebJobsSlotResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppsClientListWebJobsSlotResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppsClientListWebJobsSlotResponse{}, runtime.NewResponseError(resp)
			}
			return client.listWebJobsSlotHandleResponse(resp)
		},
	})
}

// listWebJobsSlotCreateRequest creates the ListWebJobsSlot request.
func (client *AppsClient) listWebJobsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientListWebJobsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listWebJobsSlotHandleResponse handles the ListWebJobsSlot response.
func (client *AppsClient) listWebJobsSlotHandleResponse(resp *http.Response) (AppsClientListWebJobsSlotResponse, error) {
	result := AppsClientListWebJobsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.JobCollection); err != nil {
		return AppsClientListWebJobsSlotResponse{}, err
	}
	return result, nil
}

// BeginMigrateMySQL - Migrates a local (in-app) MySql database to a remote MySql database.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// migrationRequestEnvelope - MySql migration options.
// options - AppsClientBeginMigrateMySQLOptions contains the optional parameters for the AppsClient.BeginMigrateMySQL method.
func (client *AppsClient) BeginMigrateMySQL(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest, options *AppsClientBeginMigrateMySQLOptions) (*runtime.Poller[AppsClientMigrateMySQLResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.migrateMySQL(ctx, resourceGroupName, name, migrationRequestEnvelope, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientMigrateMySQLResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientMigrateMySQLResponse](options.ResumeToken, client.pl, nil)
	}
}

// MigrateMySQL - Migrates a local (in-app) MySql database to a remote MySql database.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) migrateMySQL(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest, options *AppsClientBeginMigrateMySQLOptions) (*http.Response, error) {
	req, err := client.migrateMySQLCreateRequest(ctx, resourceGroupName, name, migrationRequestEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// migrateMySQLCreateRequest creates the MigrateMySQL request.
func (client *AppsClient) migrateMySQLCreateRequest(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest, options *AppsClientBeginMigrateMySQLOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, migrationRequestEnvelope)
}

// BeginMigrateStorage - Restores a web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// subscriptionName - Azure subscription.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// migrationOptions - Migration migrationOptions.
// options - AppsClientBeginMigrateStorageOptions contains the optional parameters for the AppsClient.BeginMigrateStorage
// method.
func (client *AppsClient) BeginMigrateStorage(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions, options *AppsClientBeginMigrateStorageOptions) (*runtime.Poller[AppsClientMigrateStorageResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.migrateStorage(ctx, subscriptionName, resourceGroupName, name, migrationOptions, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientMigrateStorageResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientMigrateStorageResponse](options.ResumeToken, client.pl, nil)
	}
}

// MigrateStorage - Restores a web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) migrateStorage(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions, options *AppsClientBeginMigrateStorageOptions) (*http.Response, error) {
	req, err := client.migrateStorageCreateRequest(ctx, subscriptionName, resourceGroupName, name, migrationOptions, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// migrateStorageCreateRequest creates the MigrateStorage request.
func (client *AppsClient) migrateStorageCreateRequest(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions, options *AppsClientBeginMigrateStorageOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("subscriptionName", subscriptionName)
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, migrationOptions)
}

// PutPrivateAccessVnet - Sets data around private site access enablement and authorized Virtual Networks that can access
// the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// access - The information for the private access
// options - AppsClientPutPrivateAccessVnetOptions contains the optional parameters for the AppsClient.PutPrivateAccessVnet
// method.
func (client *AppsClient) PutPrivateAccessVnet(ctx context.Context, resourceGroupName string, name string, access PrivateAccess, options *AppsClientPutPrivateAccessVnetOptions) (AppsClientPutPrivateAccessVnetResponse, error) {
	req, err := client.putPrivateAccessVnetCreateRequest(ctx, resourceGroupName, name, access, options)
	if err != nil {
		return AppsClientPutPrivateAccessVnetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientPutPrivateAccessVnetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientPutPrivateAccessVnetResponse{}, runtime.NewResponseError(resp)
	}
	return client.putPrivateAccessVnetHandleResponse(resp)
}

// putPrivateAccessVnetCreateRequest creates the PutPrivateAccessVnet request.
func (client *AppsClient) putPrivateAccessVnetCreateRequest(ctx context.Context, resourceGroupName string, name string, access PrivateAccess, options *AppsClientPutPrivateAccessVnetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, access)
}

// putPrivateAccessVnetHandleResponse handles the PutPrivateAccessVnet response.
func (client *AppsClient) putPrivateAccessVnetHandleResponse(resp *http.Response) (AppsClientPutPrivateAccessVnetResponse, error) {
	result := AppsClientPutPrivateAccessVnetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateAccess); err != nil {
		return AppsClientPutPrivateAccessVnetResponse{}, err
	}
	return result, nil
}

// PutPrivateAccessVnetSlot - Sets data around private site access enablement and authorized Virtual Networks that can access
// the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// slot - The name of the slot for the web app.
// access - The information for the private access
// options - AppsClientPutPrivateAccessVnetSlotOptions contains the optional parameters for the AppsClient.PutPrivateAccessVnetSlot
// method.
func (client *AppsClient) PutPrivateAccessVnetSlot(ctx context.Context, resourceGroupName string, name string, slot string, access PrivateAccess, options *AppsClientPutPrivateAccessVnetSlotOptions) (AppsClientPutPrivateAccessVnetSlotResponse, error) {
	req, err := client.putPrivateAccessVnetSlotCreateRequest(ctx, resourceGroupName, name, slot, access, options)
	if err != nil {
		return AppsClientPutPrivateAccessVnetSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientPutPrivateAccessVnetSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientPutPrivateAccessVnetSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.putPrivateAccessVnetSlotHandleResponse(resp)
}

// putPrivateAccessVnetSlotCreateRequest creates the PutPrivateAccessVnetSlot request.
func (client *AppsClient) putPrivateAccessVnetSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, access PrivateAccess, options *AppsClientPutPrivateAccessVnetSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, access)
}

// putPrivateAccessVnetSlotHandleResponse handles the PutPrivateAccessVnetSlot response.
func (client *AppsClient) putPrivateAccessVnetSlotHandleResponse(resp *http.Response) (AppsClientPutPrivateAccessVnetSlotResponse, error) {
	result := AppsClientPutPrivateAccessVnetSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateAccess); err != nil {
		return AppsClientPutPrivateAccessVnetSlotResponse{}, err
	}
	return result, nil
}

// RecoverSiteConfigurationSnapshot - Reverts the configuration of an app to a previous snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// snapshotID - The ID of the snapshot to read.
// options - AppsClientRecoverSiteConfigurationSnapshotOptions contains the optional parameters for the AppsClient.RecoverSiteConfigurationSnapshot
// method.
func (client *AppsClient) RecoverSiteConfigurationSnapshot(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *AppsClientRecoverSiteConfigurationSnapshotOptions) (AppsClientRecoverSiteConfigurationSnapshotResponse, error) {
	req, err := client.recoverSiteConfigurationSnapshotCreateRequest(ctx, resourceGroupName, name, snapshotID, options)
	if err != nil {
		return AppsClientRecoverSiteConfigurationSnapshotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientRecoverSiteConfigurationSnapshotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return AppsClientRecoverSiteConfigurationSnapshotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientRecoverSiteConfigurationSnapshotResponse{}, nil
}

// recoverSiteConfigurationSnapshotCreateRequest creates the RecoverSiteConfigurationSnapshot request.
func (client *AppsClient) recoverSiteConfigurationSnapshotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *AppsClientRecoverSiteConfigurationSnapshotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}/recover"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// RecoverSiteConfigurationSnapshotSlot - Reverts the configuration of an app to a previous snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// snapshotID - The ID of the snapshot to read.
// slot - Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
// options - AppsClientRecoverSiteConfigurationSnapshotSlotOptions contains the optional parameters for the AppsClient.RecoverSiteConfigurationSnapshotSlot
// method.
func (client *AppsClient) RecoverSiteConfigurationSnapshotSlot(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *AppsClientRecoverSiteConfigurationSnapshotSlotOptions) (AppsClientRecoverSiteConfigurationSnapshotSlotResponse, error) {
	req, err := client.recoverSiteConfigurationSnapshotSlotCreateRequest(ctx, resourceGroupName, name, snapshotID, slot, options)
	if err != nil {
		return AppsClientRecoverSiteConfigurationSnapshotSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientRecoverSiteConfigurationSnapshotSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return AppsClientRecoverSiteConfigurationSnapshotSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientRecoverSiteConfigurationSnapshotSlotResponse{}, nil
}

// recoverSiteConfigurationSnapshotSlotCreateRequest creates the RecoverSiteConfigurationSnapshotSlot request.
func (client *AppsClient) recoverSiteConfigurationSnapshotSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *AppsClientRecoverSiteConfigurationSnapshotSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}/recover"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// ResetProductionSlotConfig - Resets the configuration settings of the current slot if they were previously modified by calling
// the API with POST.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientResetProductionSlotConfigOptions contains the optional parameters for the AppsClient.ResetProductionSlotConfig
// method.
func (client *AppsClient) ResetProductionSlotConfig(ctx context.Context, resourceGroupName string, name string, options *AppsClientResetProductionSlotConfigOptions) (AppsClientResetProductionSlotConfigResponse, error) {
	req, err := client.resetProductionSlotConfigCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientResetProductionSlotConfigResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientResetProductionSlotConfigResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientResetProductionSlotConfigResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientResetProductionSlotConfigResponse{}, nil
}

// resetProductionSlotConfigCreateRequest creates the ResetProductionSlotConfig request.
func (client *AppsClient) resetProductionSlotConfigCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientResetProductionSlotConfigOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// ResetSlotConfigurationSlot - Resets the configuration settings of the current slot if they were previously modified by
// calling the API with POST.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API resets configuration settings for the production
// slot.
// options - AppsClientResetSlotConfigurationSlotOptions contains the optional parameters for the AppsClient.ResetSlotConfigurationSlot
// method.
func (client *AppsClient) ResetSlotConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientResetSlotConfigurationSlotOptions) (AppsClientResetSlotConfigurationSlotResponse, error) {
	req, err := client.resetSlotConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientResetSlotConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientResetSlotConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientResetSlotConfigurationSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientResetSlotConfigurationSlotResponse{}, nil
}

// resetSlotConfigurationSlotCreateRequest creates the ResetSlotConfigurationSlot request.
func (client *AppsClient) resetSlotConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientResetSlotConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// Restart - Restarts an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientRestartOptions contains the optional parameters for the AppsClient.Restart method.
func (client *AppsClient) Restart(ctx context.Context, resourceGroupName string, name string, options *AppsClientRestartOptions) (AppsClientRestartResponse, error) {
	req, err := client.restartCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientRestartResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientRestartResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientRestartResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientRestartResponse{}, nil
}

// restartCreateRequest creates the Restart request.
func (client *AppsClient) restartCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientRestartOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SoftRestart != nil {
		reqQP.Set("softRestart", strconv.FormatBool(*options.SoftRestart))
	}
	if options != nil && options.Synchronous != nil {
		reqQP.Set("synchronous", strconv.FormatBool(*options.Synchronous))
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// RestartSlot - Restarts an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
// options - AppsClientRestartSlotOptions contains the optional parameters for the AppsClient.RestartSlot method.
func (client *AppsClient) RestartSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientRestartSlotOptions) (AppsClientRestartSlotResponse, error) {
	req, err := client.restartSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientRestartSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientRestartSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientRestartSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientRestartSlotResponse{}, nil
}

// restartSlotCreateRequest creates the RestartSlot request.
func (client *AppsClient) restartSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientRestartSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SoftRestart != nil {
		reqQP.Set("softRestart", strconv.FormatBool(*options.SoftRestart))
	}
	if options != nil && options.Synchronous != nil {
		reqQP.Set("synchronous", strconv.FormatBool(*options.Synchronous))
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// BeginRestore - Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// backupID - ID of the backup.
// request - Information on restore request .
// options - AppsClientBeginRestoreOptions contains the optional parameters for the AppsClient.BeginRestore method.
func (client *AppsClient) BeginRestore(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, options *AppsClientBeginRestoreOptions) (*runtime.Poller[AppsClientRestoreResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restore(ctx, resourceGroupName, name, backupID, request, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientRestoreResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientRestoreResponse](options.ResumeToken, client.pl, nil)
	}
}

// Restore - Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) restore(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, options *AppsClientBeginRestoreOptions) (*http.Response, error) {
	req, err := client.restoreCreateRequest(ctx, resourceGroupName, name, backupID, request, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// restoreCreateRequest creates the Restore request.
func (client *AppsClient) restoreCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, options *AppsClientBeginRestoreOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, request)
}

// BeginRestoreFromBackupBlob - Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// request - Information on restore request .
// options - AppsClientBeginRestoreFromBackupBlobOptions contains the optional parameters for the AppsClient.BeginRestoreFromBackupBlob
// method.
func (client *AppsClient) BeginRestoreFromBackupBlob(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *AppsClientBeginRestoreFromBackupBlobOptions) (*runtime.Poller[AppsClientRestoreFromBackupBlobResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreFromBackupBlob(ctx, resourceGroupName, name, request, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientRestoreFromBackupBlobResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientRestoreFromBackupBlobResponse](options.ResumeToken, client.pl, nil)
	}
}

// RestoreFromBackupBlob - Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) restoreFromBackupBlob(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *AppsClientBeginRestoreFromBackupBlobOptions) (*http.Response, error) {
	req, err := client.restoreFromBackupBlobCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// restoreFromBackupBlobCreateRequest creates the RestoreFromBackupBlob request.
func (client *AppsClient) restoreFromBackupBlobCreateRequest(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *AppsClientBeginRestoreFromBackupBlobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromBackupBlob"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, request)
}

// BeginRestoreFromBackupBlobSlot - Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
// request - Information on restore request .
// options - AppsClientBeginRestoreFromBackupBlobSlotOptions contains the optional parameters for the AppsClient.BeginRestoreFromBackupBlobSlot
// method.
func (client *AppsClient) BeginRestoreFromBackupBlobSlot(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *AppsClientBeginRestoreFromBackupBlobSlotOptions) (*runtime.Poller[AppsClientRestoreFromBackupBlobSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreFromBackupBlobSlot(ctx, resourceGroupName, name, slot, request, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientRestoreFromBackupBlobSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientRestoreFromBackupBlobSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// RestoreFromBackupBlobSlot - Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) restoreFromBackupBlobSlot(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *AppsClientBeginRestoreFromBackupBlobSlotOptions) (*http.Response, error) {
	req, err := client.restoreFromBackupBlobSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// restoreFromBackupBlobSlotCreateRequest creates the RestoreFromBackupBlobSlot request.
func (client *AppsClient) restoreFromBackupBlobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *AppsClientBeginRestoreFromBackupBlobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromBackupBlob"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, request)
}

// BeginRestoreFromDeletedApp - Restores a deleted web app to this web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// restoreRequest - Deleted web app restore information.
// options - AppsClientBeginRestoreFromDeletedAppOptions contains the optional parameters for the AppsClient.BeginRestoreFromDeletedApp
// method.
func (client *AppsClient) BeginRestoreFromDeletedApp(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, options *AppsClientBeginRestoreFromDeletedAppOptions) (*runtime.Poller[AppsClientRestoreFromDeletedAppResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreFromDeletedApp(ctx, resourceGroupName, name, restoreRequest, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientRestoreFromDeletedAppResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientRestoreFromDeletedAppResponse](options.ResumeToken, client.pl, nil)
	}
}

// RestoreFromDeletedApp - Restores a deleted web app to this web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) restoreFromDeletedApp(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, options *AppsClientBeginRestoreFromDeletedAppOptions) (*http.Response, error) {
	req, err := client.restoreFromDeletedAppCreateRequest(ctx, resourceGroupName, name, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// restoreFromDeletedAppCreateRequest creates the RestoreFromDeletedApp request.
func (client *AppsClient) restoreFromDeletedAppCreateRequest(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, options *AppsClientBeginRestoreFromDeletedAppOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromDeletedApp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, restoreRequest)
}

// BeginRestoreFromDeletedAppSlot - Restores a deleted web app to this web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// restoreRequest - Deleted web app restore information.
// options - AppsClientBeginRestoreFromDeletedAppSlotOptions contains the optional parameters for the AppsClient.BeginRestoreFromDeletedAppSlot
// method.
func (client *AppsClient) BeginRestoreFromDeletedAppSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest DeletedAppRestoreRequest, options *AppsClientBeginRestoreFromDeletedAppSlotOptions) (*runtime.Poller[AppsClientRestoreFromDeletedAppSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreFromDeletedAppSlot(ctx, resourceGroupName, name, slot, restoreRequest, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientRestoreFromDeletedAppSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientRestoreFromDeletedAppSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// RestoreFromDeletedAppSlot - Restores a deleted web app to this web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) restoreFromDeletedAppSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest DeletedAppRestoreRequest, options *AppsClientBeginRestoreFromDeletedAppSlotOptions) (*http.Response, error) {
	req, err := client.restoreFromDeletedAppSlotCreateRequest(ctx, resourceGroupName, name, slot, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// restoreFromDeletedAppSlotCreateRequest creates the RestoreFromDeletedAppSlot request.
func (client *AppsClient) restoreFromDeletedAppSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest DeletedAppRestoreRequest, options *AppsClientBeginRestoreFromDeletedAppSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromDeletedApp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, restoreRequest)
}

// BeginRestoreSlot - Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// backupID - ID of the backup.
// slot - Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
// request - Information on restore request .
// options - AppsClientBeginRestoreSlotOptions contains the optional parameters for the AppsClient.BeginRestoreSlot method.
func (client *AppsClient) BeginRestoreSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request RestoreRequest, options *AppsClientBeginRestoreSlotOptions) (*runtime.Poller[AppsClientRestoreSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreSlot(ctx, resourceGroupName, name, backupID, slot, request, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientRestoreSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientRestoreSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// RestoreSlot - Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) restoreSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request RestoreRequest, options *AppsClientBeginRestoreSlotOptions) (*http.Response, error) {
	req, err := client.restoreSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, request, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// restoreSlotCreateRequest creates the RestoreSlot request.
func (client *AppsClient) restoreSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request RestoreRequest, options *AppsClientBeginRestoreSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, request)
}

// BeginRestoreSnapshot - Restores a web app from a snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// restoreRequest - Snapshot restore settings. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots
// API.
// options - AppsClientBeginRestoreSnapshotOptions contains the optional parameters for the AppsClient.BeginRestoreSnapshot
// method.
func (client *AppsClient) BeginRestoreSnapshot(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, options *AppsClientBeginRestoreSnapshotOptions) (*runtime.Poller[AppsClientRestoreSnapshotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreSnapshot(ctx, resourceGroupName, name, restoreRequest, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientRestoreSnapshotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientRestoreSnapshotResponse](options.ResumeToken, client.pl, nil)
	}
}

// RestoreSnapshot - Restores a web app from a snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) restoreSnapshot(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, options *AppsClientBeginRestoreSnapshotOptions) (*http.Response, error) {
	req, err := client.restoreSnapshotCreateRequest(ctx, resourceGroupName, name, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// restoreSnapshotCreateRequest creates the RestoreSnapshot request.
func (client *AppsClient) restoreSnapshotCreateRequest(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, options *AppsClientBeginRestoreSnapshotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreSnapshot"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, restoreRequest)
}

// BeginRestoreSnapshotSlot - Restores a web app from a snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// restoreRequest - Snapshot restore settings. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots
// API.
// options - AppsClientBeginRestoreSnapshotSlotOptions contains the optional parameters for the AppsClient.BeginRestoreSnapshotSlot
// method.
func (client *AppsClient) BeginRestoreSnapshotSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest SnapshotRestoreRequest, options *AppsClientBeginRestoreSnapshotSlotOptions) (*runtime.Poller[AppsClientRestoreSnapshotSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreSnapshotSlot(ctx, resourceGroupName, name, slot, restoreRequest, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientRestoreSnapshotSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientRestoreSnapshotSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// RestoreSnapshotSlot - Restores a web app from a snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) restoreSnapshotSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest SnapshotRestoreRequest, options *AppsClientBeginRestoreSnapshotSlotOptions) (*http.Response, error) {
	req, err := client.restoreSnapshotSlotCreateRequest(ctx, resourceGroupName, name, slot, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// restoreSnapshotSlotCreateRequest creates the RestoreSnapshotSlot request.
func (client *AppsClient) restoreSnapshotSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest SnapshotRestoreRequest, options *AppsClientBeginRestoreSnapshotSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreSnapshot"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, restoreRequest)
}

// RunTriggeredWebJob - Run a triggered web job for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// options - AppsClientRunTriggeredWebJobOptions contains the optional parameters for the AppsClient.RunTriggeredWebJob method.
func (client *AppsClient) RunTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientRunTriggeredWebJobOptions) (AppsClientRunTriggeredWebJobResponse, error) {
	req, err := client.runTriggeredWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return AppsClientRunTriggeredWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientRunTriggeredWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientRunTriggeredWebJobResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientRunTriggeredWebJobResponse{}, nil
}

// runTriggeredWebJobCreateRequest creates the RunTriggeredWebJob request.
func (client *AppsClient) runTriggeredWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientRunTriggeredWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/run"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// RunTriggeredWebJobSlot - Run a triggered web job for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientRunTriggeredWebJobSlotOptions contains the optional parameters for the AppsClient.RunTriggeredWebJobSlot
// method.
func (client *AppsClient) RunTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientRunTriggeredWebJobSlotOptions) (AppsClientRunTriggeredWebJobSlotResponse, error) {
	req, err := client.runTriggeredWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return AppsClientRunTriggeredWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientRunTriggeredWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientRunTriggeredWebJobSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientRunTriggeredWebJobSlotResponse{}, nil
}

// runTriggeredWebJobSlotCreateRequest creates the RunTriggeredWebJobSlot request.
func (client *AppsClient) runTriggeredWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientRunTriggeredWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/run"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// Start - Starts an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientStartOptions contains the optional parameters for the AppsClient.Start method.
func (client *AppsClient) Start(ctx context.Context, resourceGroupName string, name string, options *AppsClientStartOptions) (AppsClientStartResponse, error) {
	req, err := client.startCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientStartResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStartResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientStartResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientStartResponse{}, nil
}

// startCreateRequest creates the Start request.
func (client *AppsClient) startCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientStartOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// StartContinuousWebJob - Start a continuous web job for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// options - AppsClientStartContinuousWebJobOptions contains the optional parameters for the AppsClient.StartContinuousWebJob
// method.
func (client *AppsClient) StartContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientStartContinuousWebJobOptions) (AppsClientStartContinuousWebJobResponse, error) {
	req, err := client.startContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return AppsClientStartContinuousWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStartContinuousWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientStartContinuousWebJobResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientStartContinuousWebJobResponse{}, nil
}

// startContinuousWebJobCreateRequest creates the StartContinuousWebJob request.
func (client *AppsClient) startContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientStartContinuousWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// StartContinuousWebJobSlot - Start a continuous web job for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientStartContinuousWebJobSlotOptions contains the optional parameters for the AppsClient.StartContinuousWebJobSlot
// method.
func (client *AppsClient) StartContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientStartContinuousWebJobSlotOptions) (AppsClientStartContinuousWebJobSlotResponse, error) {
	req, err := client.startContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return AppsClientStartContinuousWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStartContinuousWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientStartContinuousWebJobSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientStartContinuousWebJobSlotResponse{}, nil
}

// startContinuousWebJobSlotCreateRequest creates the StartContinuousWebJobSlot request.
func (client *AppsClient) startContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientStartContinuousWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// BeginStartNetworkTrace - Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// options - AppsClientBeginStartNetworkTraceOptions contains the optional parameters for the AppsClient.BeginStartNetworkTrace
// method.
func (client *AppsClient) BeginStartNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *AppsClientBeginStartNetworkTraceOptions) (*runtime.Poller[AppsClientStartNetworkTraceResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.startNetworkTrace(ctx, resourceGroupName, name, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientStartNetworkTraceResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientStartNetworkTraceResponse](options.ResumeToken, client.pl, nil)
	}
}

// StartNetworkTrace - Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) startNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *AppsClientBeginStartNetworkTraceOptions) (*http.Response, error) {
	req, err := client.startNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// startNetworkTraceCreateRequest creates the StartNetworkTrace request.
func (client *AppsClient) startNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientBeginStartNetworkTraceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/startNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginStartNetworkTraceSlot - Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// slot - The name of the slot for this web app.
// options - AppsClientBeginStartNetworkTraceSlotOptions contains the optional parameters for the AppsClient.BeginStartNetworkTraceSlot
// method.
func (client *AppsClient) BeginStartNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientBeginStartNetworkTraceSlotOptions) (*runtime.Poller[AppsClientStartNetworkTraceSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.startNetworkTraceSlot(ctx, resourceGroupName, name, slot, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientStartNetworkTraceSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientStartNetworkTraceSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// StartNetworkTraceSlot - Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) startNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientBeginStartNetworkTraceSlotOptions) (*http.Response, error) {
	req, err := client.startNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// startNetworkTraceSlotCreateRequest creates the StartNetworkTraceSlot request.
func (client *AppsClient) startNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientBeginStartNetworkTraceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/startNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StartSlot - Starts an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will start the production slot.
// options - AppsClientStartSlotOptions contains the optional parameters for the AppsClient.StartSlot method.
func (client *AppsClient) StartSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientStartSlotOptions) (AppsClientStartSlotResponse, error) {
	req, err := client.startSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientStartSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStartSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientStartSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientStartSlotResponse{}, nil
}

// startSlotCreateRequest creates the StartSlot request.
func (client *AppsClient) startSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientStartSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// StartWebSiteNetworkTrace - Start capturing network packets for the site (To be deprecated).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// options - AppsClientStartWebSiteNetworkTraceOptions contains the optional parameters for the AppsClient.StartWebSiteNetworkTrace
// method.
func (client *AppsClient) StartWebSiteNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *AppsClientStartWebSiteNetworkTraceOptions) (AppsClientStartWebSiteNetworkTraceResponse, error) {
	req, err := client.startWebSiteNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientStartWebSiteNetworkTraceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStartWebSiteNetworkTraceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientStartWebSiteNetworkTraceResponse{}, runtime.NewResponseError(resp)
	}
	return client.startWebSiteNetworkTraceHandleResponse(resp)
}

// startWebSiteNetworkTraceCreateRequest creates the StartWebSiteNetworkTrace request.
func (client *AppsClient) startWebSiteNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientStartWebSiteNetworkTraceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// startWebSiteNetworkTraceHandleResponse handles the StartWebSiteNetworkTrace response.
func (client *AppsClient) startWebSiteNetworkTraceHandleResponse(resp *http.Response) (AppsClientStartWebSiteNetworkTraceResponse, error) {
	result := AppsClientStartWebSiteNetworkTraceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return AppsClientStartWebSiteNetworkTraceResponse{}, err
	}
	return result, nil
}

// BeginStartWebSiteNetworkTraceOperation - Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// options - AppsClientBeginStartWebSiteNetworkTraceOperationOptions contains the optional parameters for the AppsClient.BeginStartWebSiteNetworkTraceOperation
// method.
func (client *AppsClient) BeginStartWebSiteNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, options *AppsClientBeginStartWebSiteNetworkTraceOperationOptions) (*runtime.Poller[AppsClientStartWebSiteNetworkTraceOperationResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.startWebSiteNetworkTraceOperation(ctx, resourceGroupName, name, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientStartWebSiteNetworkTraceOperationResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientStartWebSiteNetworkTraceOperationResponse](options.ResumeToken, client.pl, nil)
	}
}

// StartWebSiteNetworkTraceOperation - Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) startWebSiteNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, options *AppsClientBeginStartWebSiteNetworkTraceOperationOptions) (*http.Response, error) {
	req, err := client.startWebSiteNetworkTraceOperationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// startWebSiteNetworkTraceOperationCreateRequest creates the StartWebSiteNetworkTraceOperation request.
func (client *AppsClient) startWebSiteNetworkTraceOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientBeginStartWebSiteNetworkTraceOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/startOperation"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginStartWebSiteNetworkTraceOperationSlot - Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// slot - The name of the slot for this web app.
// options - AppsClientBeginStartWebSiteNetworkTraceOperationSlotOptions contains the optional parameters for the AppsClient.BeginStartWebSiteNetworkTraceOperationSlot
// method.
func (client *AppsClient) BeginStartWebSiteNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientBeginStartWebSiteNetworkTraceOperationSlotOptions) (*runtime.Poller[AppsClientStartWebSiteNetworkTraceOperationSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.startWebSiteNetworkTraceOperationSlot(ctx, resourceGroupName, name, slot, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientStartWebSiteNetworkTraceOperationSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientStartWebSiteNetworkTraceOperationSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// StartWebSiteNetworkTraceOperationSlot - Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) startWebSiteNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientBeginStartWebSiteNetworkTraceOperationSlotOptions) (*http.Response, error) {
	req, err := client.startWebSiteNetworkTraceOperationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// startWebSiteNetworkTraceOperationSlotCreateRequest creates the StartWebSiteNetworkTraceOperationSlot request.
func (client *AppsClient) startWebSiteNetworkTraceOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientBeginStartWebSiteNetworkTraceOperationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/startOperation"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StartWebSiteNetworkTraceSlot - Start capturing network packets for the site (To be deprecated).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// slot - The name of the slot for this web app.
// options - AppsClientStartWebSiteNetworkTraceSlotOptions contains the optional parameters for the AppsClient.StartWebSiteNetworkTraceSlot
// method.
func (client *AppsClient) StartWebSiteNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientStartWebSiteNetworkTraceSlotOptions) (AppsClientStartWebSiteNetworkTraceSlotResponse, error) {
	req, err := client.startWebSiteNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientStartWebSiteNetworkTraceSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStartWebSiteNetworkTraceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientStartWebSiteNetworkTraceSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.startWebSiteNetworkTraceSlotHandleResponse(resp)
}

// startWebSiteNetworkTraceSlotCreateRequest creates the StartWebSiteNetworkTraceSlot request.
func (client *AppsClient) startWebSiteNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientStartWebSiteNetworkTraceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// startWebSiteNetworkTraceSlotHandleResponse handles the StartWebSiteNetworkTraceSlot response.
func (client *AppsClient) startWebSiteNetworkTraceSlotHandleResponse(resp *http.Response) (AppsClientStartWebSiteNetworkTraceSlotResponse, error) {
	result := AppsClientStartWebSiteNetworkTraceSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return AppsClientStartWebSiteNetworkTraceSlotResponse{}, err
	}
	return result, nil
}

// Stop - Stops an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientStopOptions contains the optional parameters for the AppsClient.Stop method.
func (client *AppsClient) Stop(ctx context.Context, resourceGroupName string, name string, options *AppsClientStopOptions) (AppsClientStopResponse, error) {
	req, err := client.stopCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientStopResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStopResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientStopResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientStopResponse{}, nil
}

// stopCreateRequest creates the Stop request.
func (client *AppsClient) stopCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientStopOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// StopContinuousWebJob - Stop a continuous web job for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// options - AppsClientStopContinuousWebJobOptions contains the optional parameters for the AppsClient.StopContinuousWebJob
// method.
func (client *AppsClient) StopContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientStopContinuousWebJobOptions) (AppsClientStopContinuousWebJobResponse, error) {
	req, err := client.stopContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return AppsClientStopContinuousWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStopContinuousWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientStopContinuousWebJobResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientStopContinuousWebJobResponse{}, nil
}

// stopContinuousWebJobCreateRequest creates the StopContinuousWebJob request.
func (client *AppsClient) stopContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *AppsClientStopContinuousWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// StopContinuousWebJobSlot - Stop a continuous web job for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Site name.
// webJobName - Name of Web Job.
// slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
// options - AppsClientStopContinuousWebJobSlotOptions contains the optional parameters for the AppsClient.StopContinuousWebJobSlot
// method.
func (client *AppsClient) StopContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientStopContinuousWebJobSlotOptions) (AppsClientStopContinuousWebJobSlotResponse, error) {
	req, err := client.stopContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return AppsClientStopContinuousWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStopContinuousWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppsClientStopContinuousWebJobSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientStopContinuousWebJobSlotResponse{}, nil
}

// stopContinuousWebJobSlotCreateRequest creates the StopContinuousWebJobSlot request.
func (client *AppsClient) stopContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *AppsClientStopContinuousWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// StopNetworkTrace - Stop ongoing capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// options - AppsClientStopNetworkTraceOptions contains the optional parameters for the AppsClient.StopNetworkTrace method.
func (client *AppsClient) StopNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *AppsClientStopNetworkTraceOptions) (AppsClientStopNetworkTraceResponse, error) {
	req, err := client.stopNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientStopNetworkTraceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStopNetworkTraceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientStopNetworkTraceResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientStopNetworkTraceResponse{}, nil
}

// stopNetworkTraceCreateRequest creates the StopNetworkTrace request.
func (client *AppsClient) stopNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientStopNetworkTraceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stopNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// StopNetworkTraceSlot - Stop ongoing capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// slot - The name of the slot for this web app.
// options - AppsClientStopNetworkTraceSlotOptions contains the optional parameters for the AppsClient.StopNetworkTraceSlot
// method.
func (client *AppsClient) StopNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientStopNetworkTraceSlotOptions) (AppsClientStopNetworkTraceSlotResponse, error) {
	req, err := client.stopNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientStopNetworkTraceSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStopNetworkTraceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientStopNetworkTraceSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientStopNetworkTraceSlotResponse{}, nil
}

// stopNetworkTraceSlotCreateRequest creates the StopNetworkTraceSlot request.
func (client *AppsClient) stopNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientStopNetworkTraceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stopNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// StopSlot - Stops an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will stop the production slot.
// options - AppsClientStopSlotOptions contains the optional parameters for the AppsClient.StopSlot method.
func (client *AppsClient) StopSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientStopSlotOptions) (AppsClientStopSlotResponse, error) {
	req, err := client.stopSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientStopSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStopSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientStopSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientStopSlotResponse{}, nil
}

// stopSlotCreateRequest creates the StopSlot request.
func (client *AppsClient) stopSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientStopSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// StopWebSiteNetworkTrace - Stop ongoing capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// options - AppsClientStopWebSiteNetworkTraceOptions contains the optional parameters for the AppsClient.StopWebSiteNetworkTrace
// method.
func (client *AppsClient) StopWebSiteNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *AppsClientStopWebSiteNetworkTraceOptions) (AppsClientStopWebSiteNetworkTraceResponse, error) {
	req, err := client.stopWebSiteNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientStopWebSiteNetworkTraceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStopWebSiteNetworkTraceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientStopWebSiteNetworkTraceResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientStopWebSiteNetworkTraceResponse{}, nil
}

// stopWebSiteNetworkTraceCreateRequest creates the StopWebSiteNetworkTrace request.
func (client *AppsClient) stopWebSiteNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientStopWebSiteNetworkTraceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// StopWebSiteNetworkTraceSlot - Stop ongoing capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// slot - The name of the slot for this web app.
// options - AppsClientStopWebSiteNetworkTraceSlotOptions contains the optional parameters for the AppsClient.StopWebSiteNetworkTraceSlot
// method.
func (client *AppsClient) StopWebSiteNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientStopWebSiteNetworkTraceSlotOptions) (AppsClientStopWebSiteNetworkTraceSlotResponse, error) {
	req, err := client.stopWebSiteNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientStopWebSiteNetworkTraceSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientStopWebSiteNetworkTraceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppsClientStopWebSiteNetworkTraceSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientStopWebSiteNetworkTraceSlotResponse{}, nil
}

// stopWebSiteNetworkTraceSlotCreateRequest creates the StopWebSiteNetworkTraceSlot request.
func (client *AppsClient) stopWebSiteNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientStopWebSiteNetworkTraceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// BeginSwapSlot - Swaps two deployment slots of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
// slotSwapEntity - JSON object that contains the target slot name. See example.
// options - AppsClientBeginSwapSlotOptions contains the optional parameters for the AppsClient.BeginSwapSlot method.
func (client *AppsClient) BeginSwapSlot(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *AppsClientBeginSwapSlotOptions) (*runtime.Poller[AppsClientSwapSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.swapSlot(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientSwapSlotResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientSwapSlotResponse](options.ResumeToken, client.pl, nil)
	}
}

// SwapSlot - Swaps two deployment slots of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) swapSlot(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *AppsClientBeginSwapSlotOptions) (*http.Response, error) {
	req, err := client.swapSlotCreateRequest(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// swapSlotCreateRequest creates the SwapSlot request.
func (client *AppsClient) swapSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *AppsClientBeginSwapSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, slotSwapEntity)
}

// BeginSwapSlotWithProduction - Swaps two deployment slots of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slotSwapEntity - JSON object that contains the target slot name. See example.
// options - AppsClientBeginSwapSlotWithProductionOptions contains the optional parameters for the AppsClient.BeginSwapSlotWithProduction
// method.
func (client *AppsClient) BeginSwapSlotWithProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *AppsClientBeginSwapSlotWithProductionOptions) (*runtime.Poller[AppsClientSwapSlotWithProductionResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.swapSlotWithProduction(ctx, resourceGroupName, name, slotSwapEntity, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppsClientSwapSlotWithProductionResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppsClientSwapSlotWithProductionResponse](options.ResumeToken, client.pl, nil)
	}
}

// SwapSlotWithProduction - Swaps two deployment slots of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppsClient) swapSlotWithProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *AppsClientBeginSwapSlotWithProductionOptions) (*http.Response, error) {
	req, err := client.swapSlotWithProductionCreateRequest(ctx, resourceGroupName, name, slotSwapEntity, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// swapSlotWithProductionCreateRequest creates the SwapSlotWithProduction request.
func (client *AppsClient) swapSlotWithProductionCreateRequest(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *AppsClientBeginSwapSlotWithProductionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, slotSwapEntity)
}

// SyncFunctionTriggers - Syncs function trigger metadata to the management database
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientSyncFunctionTriggersOptions contains the optional parameters for the AppsClient.SyncFunctionTriggers
// method.
func (client *AppsClient) SyncFunctionTriggers(ctx context.Context, resourceGroupName string, name string, options *AppsClientSyncFunctionTriggersOptions) (AppsClientSyncFunctionTriggersResponse, error) {
	req, err := client.syncFunctionTriggersCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientSyncFunctionTriggersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientSyncFunctionTriggersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return AppsClientSyncFunctionTriggersResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientSyncFunctionTriggersResponse{}, nil
}

// syncFunctionTriggersCreateRequest creates the SyncFunctionTriggers request.
func (client *AppsClient) syncFunctionTriggersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientSyncFunctionTriggersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/syncfunctiontriggers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// SyncFunctionTriggersSlot - Syncs function trigger metadata to the management database
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot.
// options - AppsClientSyncFunctionTriggersSlotOptions contains the optional parameters for the AppsClient.SyncFunctionTriggersSlot
// method.
func (client *AppsClient) SyncFunctionTriggersSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientSyncFunctionTriggersSlotOptions) (AppsClientSyncFunctionTriggersSlotResponse, error) {
	req, err := client.syncFunctionTriggersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientSyncFunctionTriggersSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientSyncFunctionTriggersSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return AppsClientSyncFunctionTriggersSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientSyncFunctionTriggersSlotResponse{}, nil
}

// syncFunctionTriggersSlotCreateRequest creates the SyncFunctionTriggersSlot request.
func (client *AppsClient) syncFunctionTriggersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientSyncFunctionTriggersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/syncfunctiontriggers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// SyncFunctions - Syncs function trigger metadata to the management database
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// options - AppsClientSyncFunctionsOptions contains the optional parameters for the AppsClient.SyncFunctions method.
func (client *AppsClient) SyncFunctions(ctx context.Context, resourceGroupName string, name string, options *AppsClientSyncFunctionsOptions) (AppsClientSyncFunctionsResponse, error) {
	req, err := client.syncFunctionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientSyncFunctionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientSyncFunctionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return AppsClientSyncFunctionsResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientSyncFunctionsResponse{}, nil
}

// syncFunctionsCreateRequest creates the SyncFunctions request.
func (client *AppsClient) syncFunctionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientSyncFunctionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// SyncFunctionsSlot - Syncs function trigger metadata to the management database
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot.
// options - AppsClientSyncFunctionsSlotOptions contains the optional parameters for the AppsClient.SyncFunctionsSlot method.
func (client *AppsClient) SyncFunctionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientSyncFunctionsSlotOptions) (AppsClientSyncFunctionsSlotResponse, error) {
	req, err := client.syncFunctionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientSyncFunctionsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientSyncFunctionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return AppsClientSyncFunctionsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientSyncFunctionsSlotResponse{}, nil
}

// syncFunctionsSlotCreateRequest creates the SyncFunctionsSlot request.
func (client *AppsClient) syncFunctionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientSyncFunctionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// SyncRepository - Sync web app repository.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// options - AppsClientSyncRepositoryOptions contains the optional parameters for the AppsClient.SyncRepository method.
func (client *AppsClient) SyncRepository(ctx context.Context, resourceGroupName string, name string, options *AppsClientSyncRepositoryOptions) (AppsClientSyncRepositoryResponse, error) {
	req, err := client.syncRepositoryCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppsClientSyncRepositoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientSyncRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientSyncRepositoryResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientSyncRepositoryResponse{}, nil
}

// syncRepositoryCreateRequest creates the SyncRepository request.
func (client *AppsClient) syncRepositoryCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppsClientSyncRepositoryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// SyncRepositorySlot - Sync web app repository.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// options - AppsClientSyncRepositorySlotOptions contains the optional parameters for the AppsClient.SyncRepositorySlot method.
func (client *AppsClient) SyncRepositorySlot(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientSyncRepositorySlotOptions) (AppsClientSyncRepositorySlotResponse, error) {
	req, err := client.syncRepositorySlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AppsClientSyncRepositorySlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientSyncRepositorySlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientSyncRepositorySlotResponse{}, runtime.NewResponseError(resp)
	}
	return AppsClientSyncRepositorySlotResponse{}, nil
}

// syncRepositorySlotCreateRequest creates the SyncRepositorySlot request.
func (client *AppsClient) syncRepositorySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *AppsClientSyncRepositorySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// Update - Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
// siteEnvelope - A JSON representation of the app properties. See example.
// options - AppsClientUpdateOptions contains the optional parameters for the AppsClient.Update method.
func (client *AppsClient) Update(ctx context.Context, resourceGroupName string, name string, siteEnvelope SitePatchResource, options *AppsClientUpdateOptions) (AppsClientUpdateResponse, error) {
	req, err := client.updateCreateRequest(ctx, resourceGroupName, name, siteEnvelope, options)
	if err != nil {
		return AppsClientUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return AppsClientUpdateResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateHandleResponse(resp)
}

// updateCreateRequest creates the Update request.
func (client *AppsClient) updateCreateRequest(ctx context.Context, resourceGroupName string, name string, siteEnvelope SitePatchResource, options *AppsClientUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteEnvelope)
}

// updateHandleResponse handles the Update response.
func (client *AppsClient) updateHandleResponse(resp *http.Response) (AppsClientUpdateResponse, error) {
	result := AppsClientUpdateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Site); err != nil {
		return AppsClientUpdateResponse{}, err
	}
	return result, nil
}

// UpdateApplicationSettings - Replaces the application settings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// appSettings - Application settings of the app.
// options - AppsClientUpdateApplicationSettingsOptions contains the optional parameters for the AppsClient.UpdateApplicationSettings
// method.
func (client *AppsClient) UpdateApplicationSettings(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, options *AppsClientUpdateApplicationSettingsOptions) (AppsClientUpdateApplicationSettingsResponse, error) {
	req, err := client.updateApplicationSettingsCreateRequest(ctx, resourceGroupName, name, appSettings, options)
	if err != nil {
		return AppsClientUpdateApplicationSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateApplicationSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateApplicationSettingsResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateApplicationSettingsHandleResponse(resp)
}

// updateApplicationSettingsCreateRequest creates the UpdateApplicationSettings request.
func (client *AppsClient) updateApplicationSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, options *AppsClientUpdateApplicationSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, appSettings)
}

// updateApplicationSettingsHandleResponse handles the UpdateApplicationSettings response.
func (client *AppsClient) updateApplicationSettingsHandleResponse(resp *http.Response) (AppsClientUpdateApplicationSettingsResponse, error) {
	result := AppsClientUpdateApplicationSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return AppsClientUpdateApplicationSettingsResponse{}, err
	}
	return result, nil
}

// UpdateApplicationSettingsSlot - Replaces the application settings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will update the application settings for the production
// slot.
// appSettings - Application settings of the app.
// options - AppsClientUpdateApplicationSettingsSlotOptions contains the optional parameters for the AppsClient.UpdateApplicationSettingsSlot
// method.
func (client *AppsClient) UpdateApplicationSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, appSettings StringDictionary, options *AppsClientUpdateApplicationSettingsSlotOptions) (AppsClientUpdateApplicationSettingsSlotResponse, error) {
	req, err := client.updateApplicationSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, appSettings, options)
	if err != nil {
		return AppsClientUpdateApplicationSettingsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateApplicationSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateApplicationSettingsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateApplicationSettingsSlotHandleResponse(resp)
}

// updateApplicationSettingsSlotCreateRequest creates the UpdateApplicationSettingsSlot request.
func (client *AppsClient) updateApplicationSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, appSettings StringDictionary, options *AppsClientUpdateApplicationSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, appSettings)
}

// updateApplicationSettingsSlotHandleResponse handles the UpdateApplicationSettingsSlot response.
func (client *AppsClient) updateApplicationSettingsSlotHandleResponse(resp *http.Response) (AppsClientUpdateApplicationSettingsSlotResponse, error) {
	result := AppsClientUpdateApplicationSettingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return AppsClientUpdateApplicationSettingsSlotResponse{}, err
	}
	return result, nil
}

// UpdateAuthSettings - Updates the Authentication / Authorization settings associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// siteAuthSettings - Auth settings associated with web app.
// options - AppsClientUpdateAuthSettingsOptions contains the optional parameters for the AppsClient.UpdateAuthSettings method.
func (client *AppsClient) UpdateAuthSettings(ctx context.Context, resourceGroupName string, name string, siteAuthSettings SiteAuthSettings, options *AppsClientUpdateAuthSettingsOptions) (AppsClientUpdateAuthSettingsResponse, error) {
	req, err := client.updateAuthSettingsCreateRequest(ctx, resourceGroupName, name, siteAuthSettings, options)
	if err != nil {
		return AppsClientUpdateAuthSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateAuthSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateAuthSettingsResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateAuthSettingsHandleResponse(resp)
}

// updateAuthSettingsCreateRequest creates the UpdateAuthSettings request.
func (client *AppsClient) updateAuthSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, siteAuthSettings SiteAuthSettings, options *AppsClientUpdateAuthSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteAuthSettings)
}

// updateAuthSettingsHandleResponse handles the UpdateAuthSettings response.
func (client *AppsClient) updateAuthSettingsHandleResponse(resp *http.Response) (AppsClientUpdateAuthSettingsResponse, error) {
	result := AppsClientUpdateAuthSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettings); err != nil {
		return AppsClientUpdateAuthSettingsResponse{}, err
	}
	return result, nil
}

// UpdateAuthSettingsSlot - Updates the Authentication / Authorization settings associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// siteAuthSettings - Auth settings associated with web app.
// options - AppsClientUpdateAuthSettingsSlotOptions contains the optional parameters for the AppsClient.UpdateAuthSettingsSlot
// method.
func (client *AppsClient) UpdateAuthSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettings SiteAuthSettings, options *AppsClientUpdateAuthSettingsSlotOptions) (AppsClientUpdateAuthSettingsSlotResponse, error) {
	req, err := client.updateAuthSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, siteAuthSettings, options)
	if err != nil {
		return AppsClientUpdateAuthSettingsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateAuthSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateAuthSettingsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateAuthSettingsSlotHandleResponse(resp)
}

// updateAuthSettingsSlotCreateRequest creates the UpdateAuthSettingsSlot request.
func (client *AppsClient) updateAuthSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettings SiteAuthSettings, options *AppsClientUpdateAuthSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteAuthSettings)
}

// updateAuthSettingsSlotHandleResponse handles the UpdateAuthSettingsSlot response.
func (client *AppsClient) updateAuthSettingsSlotHandleResponse(resp *http.Response) (AppsClientUpdateAuthSettingsSlotResponse, error) {
	result := AppsClientUpdateAuthSettingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettings); err != nil {
		return AppsClientUpdateAuthSettingsSlotResponse{}, err
	}
	return result, nil
}

// UpdateAzureStorageAccounts - Updates the Azure storage account configurations of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// azureStorageAccounts - Azure storage accounts of the app.
// options - AppsClientUpdateAzureStorageAccountsOptions contains the optional parameters for the AppsClient.UpdateAzureStorageAccounts
// method.
func (client *AppsClient) UpdateAzureStorageAccounts(ctx context.Context, resourceGroupName string, name string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *AppsClientUpdateAzureStorageAccountsOptions) (AppsClientUpdateAzureStorageAccountsResponse, error) {
	req, err := client.updateAzureStorageAccountsCreateRequest(ctx, resourceGroupName, name, azureStorageAccounts, options)
	if err != nil {
		return AppsClientUpdateAzureStorageAccountsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateAzureStorageAccountsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateAzureStorageAccountsResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateAzureStorageAccountsHandleResponse(resp)
}

// updateAzureStorageAccountsCreateRequest creates the UpdateAzureStorageAccounts request.
func (client *AppsClient) updateAzureStorageAccountsCreateRequest(ctx context.Context, resourceGroupName string, name string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *AppsClientUpdateAzureStorageAccountsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, azureStorageAccounts)
}

// updateAzureStorageAccountsHandleResponse handles the UpdateAzureStorageAccounts response.
func (client *AppsClient) updateAzureStorageAccountsHandleResponse(resp *http.Response) (AppsClientUpdateAzureStorageAccountsResponse, error) {
	result := AppsClientUpdateAzureStorageAccountsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AzureStoragePropertyDictionaryResource); err != nil {
		return AppsClientUpdateAzureStorageAccountsResponse{}, err
	}
	return result, nil
}

// UpdateAzureStorageAccountsSlot - Updates the Azure storage account configurations of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will update the Azure storage account configurations
// for the production slot.
// azureStorageAccounts - Azure storage accounts of the app.
// options - AppsClientUpdateAzureStorageAccountsSlotOptions contains the optional parameters for the AppsClient.UpdateAzureStorageAccountsSlot
// method.
func (client *AppsClient) UpdateAzureStorageAccountsSlot(ctx context.Context, resourceGroupName string, name string, slot string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *AppsClientUpdateAzureStorageAccountsSlotOptions) (AppsClientUpdateAzureStorageAccountsSlotResponse, error) {
	req, err := client.updateAzureStorageAccountsSlotCreateRequest(ctx, resourceGroupName, name, slot, azureStorageAccounts, options)
	if err != nil {
		return AppsClientUpdateAzureStorageAccountsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateAzureStorageAccountsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateAzureStorageAccountsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateAzureStorageAccountsSlotHandleResponse(resp)
}

// updateAzureStorageAccountsSlotCreateRequest creates the UpdateAzureStorageAccountsSlot request.
func (client *AppsClient) updateAzureStorageAccountsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *AppsClientUpdateAzureStorageAccountsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, azureStorageAccounts)
}

// updateAzureStorageAccountsSlotHandleResponse handles the UpdateAzureStorageAccountsSlot response.
func (client *AppsClient) updateAzureStorageAccountsSlotHandleResponse(resp *http.Response) (AppsClientUpdateAzureStorageAccountsSlotResponse, error) {
	result := AppsClientUpdateAzureStorageAccountsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AzureStoragePropertyDictionaryResource); err != nil {
		return AppsClientUpdateAzureStorageAccountsSlotResponse{}, err
	}
	return result, nil
}

// UpdateBackupConfiguration - Updates the backup configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// request - Edited backup configuration.
// options - AppsClientUpdateBackupConfigurationOptions contains the optional parameters for the AppsClient.UpdateBackupConfiguration
// method.
func (client *AppsClient) UpdateBackupConfiguration(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *AppsClientUpdateBackupConfigurationOptions) (AppsClientUpdateBackupConfigurationResponse, error) {
	req, err := client.updateBackupConfigurationCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return AppsClientUpdateBackupConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateBackupConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateBackupConfigurationResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateBackupConfigurationHandleResponse(resp)
}

// updateBackupConfigurationCreateRequest creates the UpdateBackupConfiguration request.
func (client *AppsClient) updateBackupConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *AppsClientUpdateBackupConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, request)
}

// updateBackupConfigurationHandleResponse handles the UpdateBackupConfiguration response.
func (client *AppsClient) updateBackupConfigurationHandleResponse(resp *http.Response) (AppsClientUpdateBackupConfigurationResponse, error) {
	result := AppsClientUpdateBackupConfigurationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupRequest); err != nil {
		return AppsClientUpdateBackupConfigurationResponse{}, err
	}
	return result, nil
}

// UpdateBackupConfigurationSlot - Updates the backup configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will update the backup configuration for the production
// slot.
// request - Edited backup configuration.
// options - AppsClientUpdateBackupConfigurationSlotOptions contains the optional parameters for the AppsClient.UpdateBackupConfigurationSlot
// method.
func (client *AppsClient) UpdateBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *AppsClientUpdateBackupConfigurationSlotOptions) (AppsClientUpdateBackupConfigurationSlotResponse, error) {
	req, err := client.updateBackupConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return AppsClientUpdateBackupConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateBackupConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateBackupConfigurationSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateBackupConfigurationSlotHandleResponse(resp)
}

// updateBackupConfigurationSlotCreateRequest creates the UpdateBackupConfigurationSlot request.
func (client *AppsClient) updateBackupConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *AppsClientUpdateBackupConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, request)
}

// updateBackupConfigurationSlotHandleResponse handles the UpdateBackupConfigurationSlot response.
func (client *AppsClient) updateBackupConfigurationSlotHandleResponse(resp *http.Response) (AppsClientUpdateBackupConfigurationSlotResponse, error) {
	result := AppsClientUpdateBackupConfigurationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupRequest); err != nil {
		return AppsClientUpdateBackupConfigurationSlotResponse{}, err
	}
	return result, nil
}

// UpdateConfiguration - Updates the configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// siteConfig - JSON representation of a SiteConfig object. See example.
// options - AppsClientUpdateConfigurationOptions contains the optional parameters for the AppsClient.UpdateConfiguration
// method.
func (client *AppsClient) UpdateConfiguration(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *AppsClientUpdateConfigurationOptions) (AppsClientUpdateConfigurationResponse, error) {
	req, err := client.updateConfigurationCreateRequest(ctx, resourceGroupName, name, siteConfig, options)
	if err != nil {
		return AppsClientUpdateConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateConfigurationResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateConfigurationHandleResponse(resp)
}

// updateConfigurationCreateRequest creates the UpdateConfiguration request.
func (client *AppsClient) updateConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *AppsClientUpdateConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteConfig)
}

// updateConfigurationHandleResponse handles the UpdateConfiguration response.
func (client *AppsClient) updateConfigurationHandleResponse(resp *http.Response) (AppsClientUpdateConfigurationResponse, error) {
	result := AppsClientUpdateConfigurationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return AppsClientUpdateConfigurationResponse{}, err
	}
	return result, nil
}

// UpdateConfigurationSlot - Updates the configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
// siteConfig - JSON representation of a SiteConfig object. See example.
// options - AppsClientUpdateConfigurationSlotOptions contains the optional parameters for the AppsClient.UpdateConfigurationSlot
// method.
func (client *AppsClient) UpdateConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *AppsClientUpdateConfigurationSlotOptions) (AppsClientUpdateConfigurationSlotResponse, error) {
	req, err := client.updateConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, siteConfig, options)
	if err != nil {
		return AppsClientUpdateConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateConfigurationSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateConfigurationSlotHandleResponse(resp)
}

// updateConfigurationSlotCreateRequest creates the UpdateConfigurationSlot request.
func (client *AppsClient) updateConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *AppsClientUpdateConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteConfig)
}

// updateConfigurationSlotHandleResponse handles the UpdateConfigurationSlot response.
func (client *AppsClient) updateConfigurationSlotHandleResponse(resp *http.Response) (AppsClientUpdateConfigurationSlotResponse, error) {
	result := AppsClientUpdateConfigurationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return AppsClientUpdateConfigurationSlotResponse{}, err
	}
	return result, nil
}

// UpdateConnectionStrings - Replaces the connection strings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// connectionStrings - Connection strings of the app or deployment slot. See example.
// options - AppsClientUpdateConnectionStringsOptions contains the optional parameters for the AppsClient.UpdateConnectionStrings
// method.
func (client *AppsClient) UpdateConnectionStrings(ctx context.Context, resourceGroupName string, name string, connectionStrings ConnectionStringDictionary, options *AppsClientUpdateConnectionStringsOptions) (AppsClientUpdateConnectionStringsResponse, error) {
	req, err := client.updateConnectionStringsCreateRequest(ctx, resourceGroupName, name, connectionStrings, options)
	if err != nil {
		return AppsClientUpdateConnectionStringsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateConnectionStringsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateConnectionStringsResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateConnectionStringsHandleResponse(resp)
}

// updateConnectionStringsCreateRequest creates the UpdateConnectionStrings request.
func (client *AppsClient) updateConnectionStringsCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionStrings ConnectionStringDictionary, options *AppsClientUpdateConnectionStringsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionStrings)
}

// updateConnectionStringsHandleResponse handles the UpdateConnectionStrings response.
func (client *AppsClient) updateConnectionStringsHandleResponse(resp *http.Response) (AppsClientUpdateConnectionStringsResponse, error) {
	result := AppsClientUpdateConnectionStringsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionStringDictionary); err != nil {
		return AppsClientUpdateConnectionStringsResponse{}, err
	}
	return result, nil
}

// UpdateConnectionStringsSlot - Replaces the connection strings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will update the connection settings for the production
// slot.
// connectionStrings - Connection strings of the app or deployment slot. See example.
// options - AppsClientUpdateConnectionStringsSlotOptions contains the optional parameters for the AppsClient.UpdateConnectionStringsSlot
// method.
func (client *AppsClient) UpdateConnectionStringsSlot(ctx context.Context, resourceGroupName string, name string, slot string, connectionStrings ConnectionStringDictionary, options *AppsClientUpdateConnectionStringsSlotOptions) (AppsClientUpdateConnectionStringsSlotResponse, error) {
	req, err := client.updateConnectionStringsSlotCreateRequest(ctx, resourceGroupName, name, slot, connectionStrings, options)
	if err != nil {
		return AppsClientUpdateConnectionStringsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateConnectionStringsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateConnectionStringsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateConnectionStringsSlotHandleResponse(resp)
}

// updateConnectionStringsSlotCreateRequest creates the UpdateConnectionStringsSlot request.
func (client *AppsClient) updateConnectionStringsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, connectionStrings ConnectionStringDictionary, options *AppsClientUpdateConnectionStringsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionStrings)
}

// updateConnectionStringsSlotHandleResponse handles the UpdateConnectionStringsSlot response.
func (client *AppsClient) updateConnectionStringsSlotHandleResponse(resp *http.Response) (AppsClientUpdateConnectionStringsSlotResponse, error) {
	result := AppsClientUpdateConnectionStringsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionStringDictionary); err != nil {
		return AppsClientUpdateConnectionStringsSlotResponse{}, err
	}
	return result, nil
}

// UpdateDiagnosticLogsConfig - Updates the logging configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// siteLogsConfig - A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
// options - AppsClientUpdateDiagnosticLogsConfigOptions contains the optional parameters for the AppsClient.UpdateDiagnosticLogsConfig
// method.
func (client *AppsClient) UpdateDiagnosticLogsConfig(ctx context.Context, resourceGroupName string, name string, siteLogsConfig SiteLogsConfig, options *AppsClientUpdateDiagnosticLogsConfigOptions) (AppsClientUpdateDiagnosticLogsConfigResponse, error) {
	req, err := client.updateDiagnosticLogsConfigCreateRequest(ctx, resourceGroupName, name, siteLogsConfig, options)
	if err != nil {
		return AppsClientUpdateDiagnosticLogsConfigResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateDiagnosticLogsConfigResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateDiagnosticLogsConfigResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateDiagnosticLogsConfigHandleResponse(resp)
}

// updateDiagnosticLogsConfigCreateRequest creates the UpdateDiagnosticLogsConfig request.
func (client *AppsClient) updateDiagnosticLogsConfigCreateRequest(ctx context.Context, resourceGroupName string, name string, siteLogsConfig SiteLogsConfig, options *AppsClientUpdateDiagnosticLogsConfigOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteLogsConfig)
}

// updateDiagnosticLogsConfigHandleResponse handles the UpdateDiagnosticLogsConfig response.
func (client *AppsClient) updateDiagnosticLogsConfigHandleResponse(resp *http.Response) (AppsClientUpdateDiagnosticLogsConfigResponse, error) {
	result := AppsClientUpdateDiagnosticLogsConfigResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteLogsConfig); err != nil {
		return AppsClientUpdateDiagnosticLogsConfigResponse{}, err
	}
	return result, nil
}

// UpdateDiagnosticLogsConfigSlot - Updates the logging configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will update the logging configuration for the production
// slot.
// siteLogsConfig - A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
// options - AppsClientUpdateDiagnosticLogsConfigSlotOptions contains the optional parameters for the AppsClient.UpdateDiagnosticLogsConfigSlot
// method.
func (client *AppsClient) UpdateDiagnosticLogsConfigSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteLogsConfig SiteLogsConfig, options *AppsClientUpdateDiagnosticLogsConfigSlotOptions) (AppsClientUpdateDiagnosticLogsConfigSlotResponse, error) {
	req, err := client.updateDiagnosticLogsConfigSlotCreateRequest(ctx, resourceGroupName, name, slot, siteLogsConfig, options)
	if err != nil {
		return AppsClientUpdateDiagnosticLogsConfigSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateDiagnosticLogsConfigSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateDiagnosticLogsConfigSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateDiagnosticLogsConfigSlotHandleResponse(resp)
}

// updateDiagnosticLogsConfigSlotCreateRequest creates the UpdateDiagnosticLogsConfigSlot request.
func (client *AppsClient) updateDiagnosticLogsConfigSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteLogsConfig SiteLogsConfig, options *AppsClientUpdateDiagnosticLogsConfigSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteLogsConfig)
}

// updateDiagnosticLogsConfigSlotHandleResponse handles the UpdateDiagnosticLogsConfigSlot response.
func (client *AppsClient) updateDiagnosticLogsConfigSlotHandleResponse(resp *http.Response) (AppsClientUpdateDiagnosticLogsConfigSlotResponse, error) {
	result := AppsClientUpdateDiagnosticLogsConfigSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteLogsConfig); err != nil {
		return AppsClientUpdateDiagnosticLogsConfigSlotResponse{}, err
	}
	return result, nil
}

// UpdateDomainOwnershipIdentifier - Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// domainOwnershipIdentifierName - Name of domain ownership identifier.
// domainOwnershipIdentifier - A JSON representation of the domain ownership properties.
// options - AppsClientUpdateDomainOwnershipIdentifierOptions contains the optional parameters for the AppsClient.UpdateDomainOwnershipIdentifier
// method.
func (client *AppsClient) UpdateDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *AppsClientUpdateDomainOwnershipIdentifierOptions) (AppsClientUpdateDomainOwnershipIdentifierResponse, error) {
	req, err := client.updateDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options)
	if err != nil {
		return AppsClientUpdateDomainOwnershipIdentifierResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateDomainOwnershipIdentifierResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateDomainOwnershipIdentifierResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateDomainOwnershipIdentifierHandleResponse(resp)
}

// updateDomainOwnershipIdentifierCreateRequest creates the UpdateDomainOwnershipIdentifier request.
func (client *AppsClient) updateDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *AppsClientUpdateDomainOwnershipIdentifierOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, domainOwnershipIdentifier)
}

// updateDomainOwnershipIdentifierHandleResponse handles the UpdateDomainOwnershipIdentifier response.
func (client *AppsClient) updateDomainOwnershipIdentifierHandleResponse(resp *http.Response) (AppsClientUpdateDomainOwnershipIdentifierResponse, error) {
	result := AppsClientUpdateDomainOwnershipIdentifierResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return AppsClientUpdateDomainOwnershipIdentifierResponse{}, err
	}
	return result, nil
}

// UpdateDomainOwnershipIdentifierSlot - Creates a domain ownership identifier for web app, or updates an existing ownership
// identifier.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// domainOwnershipIdentifierName - Name of domain ownership identifier.
// slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
// domainOwnershipIdentifier - A JSON representation of the domain ownership properties.
// options - AppsClientUpdateDomainOwnershipIdentifierSlotOptions contains the optional parameters for the AppsClient.UpdateDomainOwnershipIdentifierSlot
// method.
func (client *AppsClient) UpdateDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *AppsClientUpdateDomainOwnershipIdentifierSlotOptions) (AppsClientUpdateDomainOwnershipIdentifierSlotResponse, error) {
	req, err := client.updateDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier, options)
	if err != nil {
		return AppsClientUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateDomainOwnershipIdentifierSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateDomainOwnershipIdentifierSlotHandleResponse(resp)
}

// updateDomainOwnershipIdentifierSlotCreateRequest creates the UpdateDomainOwnershipIdentifierSlot request.
func (client *AppsClient) updateDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *AppsClientUpdateDomainOwnershipIdentifierSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, domainOwnershipIdentifier)
}

// updateDomainOwnershipIdentifierSlotHandleResponse handles the UpdateDomainOwnershipIdentifierSlot response.
func (client *AppsClient) updateDomainOwnershipIdentifierSlotHandleResponse(resp *http.Response) (AppsClientUpdateDomainOwnershipIdentifierSlotResponse, error) {
	result := AppsClientUpdateDomainOwnershipIdentifierSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return AppsClientUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	return result, nil
}

// UpdateHybridConnection - Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// namespaceName - The namespace for this hybrid connection.
// relayName - The relay name for this hybrid connection.
// connectionEnvelope - The details of the hybrid connection.
// options - AppsClientUpdateHybridConnectionOptions contains the optional parameters for the AppsClient.UpdateHybridConnection
// method.
func (client *AppsClient) UpdateHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *AppsClientUpdateHybridConnectionOptions) (AppsClientUpdateHybridConnectionResponse, error) {
	req, err := client.updateHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options)
	if err != nil {
		return AppsClientUpdateHybridConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateHybridConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateHybridConnectionHandleResponse(resp)
}

// updateHybridConnectionCreateRequest creates the UpdateHybridConnection request.
func (client *AppsClient) updateHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *AppsClientUpdateHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateHybridConnectionHandleResponse handles the UpdateHybridConnection response.
func (client *AppsClient) updateHybridConnectionHandleResponse(resp *http.Response) (AppsClientUpdateHybridConnectionResponse, error) {
	result := AppsClientUpdateHybridConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return AppsClientUpdateHybridConnectionResponse{}, err
	}
	return result, nil
}

// UpdateHybridConnectionSlot - Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - The name of the web app.
// namespaceName - The namespace for this hybrid connection.
// relayName - The relay name for this hybrid connection.
// slot - The name of the slot for the web app.
// connectionEnvelope - The details of the hybrid connection.
// options - AppsClientUpdateHybridConnectionSlotOptions contains the optional parameters for the AppsClient.UpdateHybridConnectionSlot
// method.
func (client *AppsClient) UpdateHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *AppsClientUpdateHybridConnectionSlotOptions) (AppsClientUpdateHybridConnectionSlotResponse, error) {
	req, err := client.updateHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope, options)
	if err != nil {
		return AppsClientUpdateHybridConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateHybridConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateHybridConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateHybridConnectionSlotHandleResponse(resp)
}

// updateHybridConnectionSlotCreateRequest creates the UpdateHybridConnectionSlot request.
func (client *AppsClient) updateHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *AppsClientUpdateHybridConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateHybridConnectionSlotHandleResponse handles the UpdateHybridConnectionSlot response.
func (client *AppsClient) updateHybridConnectionSlotHandleResponse(resp *http.Response) (AppsClientUpdateHybridConnectionSlotResponse, error) {
	result := AppsClientUpdateHybridConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return AppsClientUpdateHybridConnectionSlotResponse{}, err
	}
	return result, nil
}

// UpdateMetadata - Replaces the metadata of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// metadata - Edited metadata of the app or deployment slot. See example.
// options - AppsClientUpdateMetadataOptions contains the optional parameters for the AppsClient.UpdateMetadata method.
func (client *AppsClient) UpdateMetadata(ctx context.Context, resourceGroupName string, name string, metadata StringDictionary, options *AppsClientUpdateMetadataOptions) (AppsClientUpdateMetadataResponse, error) {
	req, err := client.updateMetadataCreateRequest(ctx, resourceGroupName, name, metadata, options)
	if err != nil {
		return AppsClientUpdateMetadataResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateMetadataResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateMetadataHandleResponse(resp)
}

// updateMetadataCreateRequest creates the UpdateMetadata request.
func (client *AppsClient) updateMetadataCreateRequest(ctx context.Context, resourceGroupName string, name string, metadata StringDictionary, options *AppsClientUpdateMetadataOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, metadata)
}

// updateMetadataHandleResponse handles the UpdateMetadata response.
func (client *AppsClient) updateMetadataHandleResponse(resp *http.Response) (AppsClientUpdateMetadataResponse, error) {
	result := AppsClientUpdateMetadataResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return AppsClientUpdateMetadataResponse{}, err
	}
	return result, nil
}

// UpdateMetadataSlot - Replaces the metadata of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will update the metadata for the production slot.
// metadata - Edited metadata of the app or deployment slot. See example.
// options - AppsClientUpdateMetadataSlotOptions contains the optional parameters for the AppsClient.UpdateMetadataSlot method.
func (client *AppsClient) UpdateMetadataSlot(ctx context.Context, resourceGroupName string, name string, slot string, metadata StringDictionary, options *AppsClientUpdateMetadataSlotOptions) (AppsClientUpdateMetadataSlotResponse, error) {
	req, err := client.updateMetadataSlotCreateRequest(ctx, resourceGroupName, name, slot, metadata, options)
	if err != nil {
		return AppsClientUpdateMetadataSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateMetadataSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateMetadataSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateMetadataSlotHandleResponse(resp)
}

// updateMetadataSlotCreateRequest creates the UpdateMetadataSlot request.
func (client *AppsClient) updateMetadataSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, metadata StringDictionary, options *AppsClientUpdateMetadataSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, metadata)
}

// updateMetadataSlotHandleResponse handles the UpdateMetadataSlot response.
func (client *AppsClient) updateMetadataSlotHandleResponse(resp *http.Response) (AppsClientUpdateMetadataSlotResponse, error) {
	result := AppsClientUpdateMetadataSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return AppsClientUpdateMetadataSlotResponse{}, err
	}
	return result, nil
}

// UpdatePremierAddOn - Updates a named add-on of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// premierAddOnName - Add-on name.
// premierAddOn - A JSON representation of the edited premier add-on.
// options - AppsClientUpdatePremierAddOnOptions contains the optional parameters for the AppsClient.UpdatePremierAddOn method.
func (client *AppsClient) UpdatePremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOnPatchResource, options *AppsClientUpdatePremierAddOnOptions) (AppsClientUpdatePremierAddOnResponse, error) {
	req, err := client.updatePremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, premierAddOn, options)
	if err != nil {
		return AppsClientUpdatePremierAddOnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdatePremierAddOnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdatePremierAddOnResponse{}, runtime.NewResponseError(resp)
	}
	return client.updatePremierAddOnHandleResponse(resp)
}

// updatePremierAddOnCreateRequest creates the UpdatePremierAddOn request.
func (client *AppsClient) updatePremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOnPatchResource, options *AppsClientUpdatePremierAddOnOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, premierAddOn)
}

// updatePremierAddOnHandleResponse handles the UpdatePremierAddOn response.
func (client *AppsClient) updatePremierAddOnHandleResponse(resp *http.Response) (AppsClientUpdatePremierAddOnResponse, error) {
	result := AppsClientUpdatePremierAddOnResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return AppsClientUpdatePremierAddOnResponse{}, err
	}
	return result, nil
}

// UpdatePremierAddOnSlot - Updates a named add-on of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// premierAddOnName - Add-on name.
// slot - Name of the deployment slot. If a slot is not specified, the API will update the named add-on for the production
// slot.
// premierAddOn - A JSON representation of the edited premier add-on.
// options - AppsClientUpdatePremierAddOnSlotOptions contains the optional parameters for the AppsClient.UpdatePremierAddOnSlot
// method.
func (client *AppsClient) UpdatePremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOnPatchResource, options *AppsClientUpdatePremierAddOnSlotOptions) (AppsClientUpdatePremierAddOnSlotResponse, error) {
	req, err := client.updatePremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, premierAddOn, options)
	if err != nil {
		return AppsClientUpdatePremierAddOnSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdatePremierAddOnSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdatePremierAddOnSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updatePremierAddOnSlotHandleResponse(resp)
}

// updatePremierAddOnSlotCreateRequest creates the UpdatePremierAddOnSlot request.
func (client *AppsClient) updatePremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOnPatchResource, options *AppsClientUpdatePremierAddOnSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, premierAddOn)
}

// updatePremierAddOnSlotHandleResponse handles the UpdatePremierAddOnSlot response.
func (client *AppsClient) updatePremierAddOnSlotHandleResponse(resp *http.Response) (AppsClientUpdatePremierAddOnSlotResponse, error) {
	result := AppsClientUpdatePremierAddOnSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return AppsClientUpdatePremierAddOnSlotResponse{}, err
	}
	return result, nil
}

// UpdateRelayServiceConnection - Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// entityName - Name of the hybrid connection configuration.
// connectionEnvelope - Details of the hybrid connection configuration.
// options - AppsClientUpdateRelayServiceConnectionOptions contains the optional parameters for the AppsClient.UpdateRelayServiceConnection
// method.
func (client *AppsClient) UpdateRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *AppsClientUpdateRelayServiceConnectionOptions) (AppsClientUpdateRelayServiceConnectionResponse, error) {
	req, err := client.updateRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, connectionEnvelope, options)
	if err != nil {
		return AppsClientUpdateRelayServiceConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateRelayServiceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateRelayServiceConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateRelayServiceConnectionHandleResponse(resp)
}

// updateRelayServiceConnectionCreateRequest creates the UpdateRelayServiceConnection request.
func (client *AppsClient) updateRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *AppsClientUpdateRelayServiceConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateRelayServiceConnectionHandleResponse handles the UpdateRelayServiceConnection response.
func (client *AppsClient) updateRelayServiceConnectionHandleResponse(resp *http.Response) (AppsClientUpdateRelayServiceConnectionResponse, error) {
	result := AppsClientUpdateRelayServiceConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return AppsClientUpdateRelayServiceConnectionResponse{}, err
	}
	return result, nil
}

// UpdateRelayServiceConnectionSlot - Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// entityName - Name of the hybrid connection configuration.
// slot - Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the
// production slot.
// connectionEnvelope - Details of the hybrid connection configuration.
// options - AppsClientUpdateRelayServiceConnectionSlotOptions contains the optional parameters for the AppsClient.UpdateRelayServiceConnectionSlot
// method.
func (client *AppsClient) UpdateRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *AppsClientUpdateRelayServiceConnectionSlotOptions) (AppsClientUpdateRelayServiceConnectionSlotResponse, error) {
	req, err := client.updateRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, connectionEnvelope, options)
	if err != nil {
		return AppsClientUpdateRelayServiceConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateRelayServiceConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateRelayServiceConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateRelayServiceConnectionSlotHandleResponse(resp)
}

// updateRelayServiceConnectionSlotCreateRequest creates the UpdateRelayServiceConnectionSlot request.
func (client *AppsClient) updateRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *AppsClientUpdateRelayServiceConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateRelayServiceConnectionSlotHandleResponse handles the UpdateRelayServiceConnectionSlot response.
func (client *AppsClient) updateRelayServiceConnectionSlotHandleResponse(resp *http.Response) (AppsClientUpdateRelayServiceConnectionSlotResponse, error) {
	result := AppsClientUpdateRelayServiceConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return AppsClientUpdateRelayServiceConnectionSlotResponse{}, err
	}
	return result, nil
}

// UpdateSitePushSettings - Updates the Push settings associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// pushSettings - Push settings associated with web app.
// options - AppsClientUpdateSitePushSettingsOptions contains the optional parameters for the AppsClient.UpdateSitePushSettings
// method.
func (client *AppsClient) UpdateSitePushSettings(ctx context.Context, resourceGroupName string, name string, pushSettings PushSettings, options *AppsClientUpdateSitePushSettingsOptions) (AppsClientUpdateSitePushSettingsResponse, error) {
	req, err := client.updateSitePushSettingsCreateRequest(ctx, resourceGroupName, name, pushSettings, options)
	if err != nil {
		return AppsClientUpdateSitePushSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateSitePushSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateSitePushSettingsResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateSitePushSettingsHandleResponse(resp)
}

// updateSitePushSettingsCreateRequest creates the UpdateSitePushSettings request.
func (client *AppsClient) updateSitePushSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, pushSettings PushSettings, options *AppsClientUpdateSitePushSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, pushSettings)
}

// updateSitePushSettingsHandleResponse handles the UpdateSitePushSettings response.
func (client *AppsClient) updateSitePushSettingsHandleResponse(resp *http.Response) (AppsClientUpdateSitePushSettingsResponse, error) {
	result := AppsClientUpdateSitePushSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PushSettings); err != nil {
		return AppsClientUpdateSitePushSettingsResponse{}, err
	}
	return result, nil
}

// UpdateSitePushSettingsSlot - Updates the Push settings associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of web app.
// slot - Name of web app slot. If not specified then will default to production slot.
// pushSettings - Push settings associated with web app.
// options - AppsClientUpdateSitePushSettingsSlotOptions contains the optional parameters for the AppsClient.UpdateSitePushSettingsSlot
// method.
func (client *AppsClient) UpdateSitePushSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, pushSettings PushSettings, options *AppsClientUpdateSitePushSettingsSlotOptions) (AppsClientUpdateSitePushSettingsSlotResponse, error) {
	req, err := client.updateSitePushSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, pushSettings, options)
	if err != nil {
		return AppsClientUpdateSitePushSettingsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateSitePushSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateSitePushSettingsSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateSitePushSettingsSlotHandleResponse(resp)
}

// updateSitePushSettingsSlotCreateRequest creates the UpdateSitePushSettingsSlot request.
func (client *AppsClient) updateSitePushSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, pushSettings PushSettings, options *AppsClientUpdateSitePushSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, pushSettings)
}

// updateSitePushSettingsSlotHandleResponse handles the UpdateSitePushSettingsSlot response.
func (client *AppsClient) updateSitePushSettingsSlotHandleResponse(resp *http.Response) (AppsClientUpdateSitePushSettingsSlotResponse, error) {
	result := AppsClientUpdateSitePushSettingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PushSettings); err != nil {
		return AppsClientUpdateSitePushSettingsSlotResponse{}, err
	}
	return result, nil
}

// UpdateSlot - Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
// slot - Name of the deployment slot to create or update. By default, this API attempts to create or modify the production
// slot.
// siteEnvelope - A JSON representation of the app properties. See example.
// options - AppsClientUpdateSlotOptions contains the optional parameters for the AppsClient.UpdateSlot method.
func (client *AppsClient) UpdateSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope SitePatchResource, options *AppsClientUpdateSlotOptions) (AppsClientUpdateSlotResponse, error) {
	req, err := client.updateSlotCreateRequest(ctx, resourceGroupName, name, slot, siteEnvelope, options)
	if err != nil {
		return AppsClientUpdateSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return AppsClientUpdateSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateSlotHandleResponse(resp)
}

// updateSlotCreateRequest creates the UpdateSlot request.
func (client *AppsClient) updateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope SitePatchResource, options *AppsClientUpdateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteEnvelope)
}

// updateSlotHandleResponse handles the UpdateSlot response.
func (client *AppsClient) updateSlotHandleResponse(resp *http.Response) (AppsClientUpdateSlotResponse, error) {
	result := AppsClientUpdateSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Site); err != nil {
		return AppsClientUpdateSlotResponse{}, err
	}
	return result, nil
}

// UpdateSlotConfigurationNames - Updates the names of application settings and connection string that remain with the slot
// during swap operation.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slotConfigNames - Names of application settings and connection strings. See example.
// options - AppsClientUpdateSlotConfigurationNamesOptions contains the optional parameters for the AppsClient.UpdateSlotConfigurationNames
// method.
func (client *AppsClient) UpdateSlotConfigurationNames(ctx context.Context, resourceGroupName string, name string, slotConfigNames SlotConfigNamesResource, options *AppsClientUpdateSlotConfigurationNamesOptions) (AppsClientUpdateSlotConfigurationNamesResponse, error) {
	req, err := client.updateSlotConfigurationNamesCreateRequest(ctx, resourceGroupName, name, slotConfigNames, options)
	if err != nil {
		return AppsClientUpdateSlotConfigurationNamesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateSlotConfigurationNamesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateSlotConfigurationNamesResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateSlotConfigurationNamesHandleResponse(resp)
}

// updateSlotConfigurationNamesCreateRequest creates the UpdateSlotConfigurationNames request.
func (client *AppsClient) updateSlotConfigurationNamesCreateRequest(ctx context.Context, resourceGroupName string, name string, slotConfigNames SlotConfigNamesResource, options *AppsClientUpdateSlotConfigurationNamesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, slotConfigNames)
}

// updateSlotConfigurationNamesHandleResponse handles the UpdateSlotConfigurationNames response.
func (client *AppsClient) updateSlotConfigurationNamesHandleResponse(resp *http.Response) (AppsClientUpdateSlotConfigurationNamesResponse, error) {
	result := AppsClientUpdateSlotConfigurationNamesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SlotConfigNamesResource); err != nil {
		return AppsClientUpdateSlotConfigurationNamesResponse{}, err
	}
	return result, nil
}

// UpdateSourceControl - Updates the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// siteSourceControl - JSON representation of a SiteSourceControl object. See example.
// options - AppsClientUpdateSourceControlOptions contains the optional parameters for the AppsClient.UpdateSourceControl
// method.
func (client *AppsClient) UpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *AppsClientUpdateSourceControlOptions) (AppsClientUpdateSourceControlResponse, error) {
	req, err := client.updateSourceControlCreateRequest(ctx, resourceGroupName, name, siteSourceControl, options)
	if err != nil {
		return AppsClientUpdateSourceControlResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return AppsClientUpdateSourceControlResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateSourceControlHandleResponse(resp)
}

// updateSourceControlCreateRequest creates the UpdateSourceControl request.
func (client *AppsClient) updateSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *AppsClientUpdateSourceControlOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteSourceControl)
}

// updateSourceControlHandleResponse handles the UpdateSourceControl response.
func (client *AppsClient) updateSourceControlHandleResponse(resp *http.Response) (AppsClientUpdateSourceControlResponse, error) {
	result := AppsClientUpdateSourceControlResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteSourceControl); err != nil {
		return AppsClientUpdateSourceControlResponse{}, err
	}
	return result, nil
}

// UpdateSourceControlSlot - Updates the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for
// the production slot.
// siteSourceControl - JSON representation of a SiteSourceControl object. See example.
// options - AppsClientUpdateSourceControlSlotOptions contains the optional parameters for the AppsClient.UpdateSourceControlSlot
// method.
func (client *AppsClient) UpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *AppsClientUpdateSourceControlSlotOptions) (AppsClientUpdateSourceControlSlotResponse, error) {
	req, err := client.updateSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, siteSourceControl, options)
	if err != nil {
		return AppsClientUpdateSourceControlSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateSourceControlSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return AppsClientUpdateSourceControlSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateSourceControlSlotHandleResponse(resp)
}

// updateSourceControlSlotCreateRequest creates the UpdateSourceControlSlot request.
func (client *AppsClient) updateSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *AppsClientUpdateSourceControlSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, siteSourceControl)
}

// updateSourceControlSlotHandleResponse handles the UpdateSourceControlSlot response.
func (client *AppsClient) updateSourceControlSlotHandleResponse(resp *http.Response) (AppsClientUpdateSourceControlSlotResponse, error) {
	result := AppsClientUpdateSourceControlSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteSourceControl); err != nil {
		return AppsClientUpdateSourceControlSlotResponse{}, err
	}
	return result, nil
}

// UpdateSwiftVirtualNetworkConnection - Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported"
// is true when doing a GET against this resource, and 2) that the target Subnet has already been delegated, and is
// not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// connectionEnvelope - Properties of the Virtual Network connection. See example.
// options - AppsClientUpdateSwiftVirtualNetworkConnectionOptions contains the optional parameters for the AppsClient.UpdateSwiftVirtualNetworkConnection
// method.
func (client *AppsClient) UpdateSwiftVirtualNetworkConnection(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *AppsClientUpdateSwiftVirtualNetworkConnectionOptions) (AppsClientUpdateSwiftVirtualNetworkConnectionResponse, error) {
	req, err := client.updateSwiftVirtualNetworkConnectionCreateRequest(ctx, resourceGroupName, name, connectionEnvelope, options)
	if err != nil {
		return AppsClientUpdateSwiftVirtualNetworkConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateSwiftVirtualNetworkConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateSwiftVirtualNetworkConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateSwiftVirtualNetworkConnectionHandleResponse(resp)
}

// updateSwiftVirtualNetworkConnectionCreateRequest creates the UpdateSwiftVirtualNetworkConnection request.
func (client *AppsClient) updateSwiftVirtualNetworkConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *AppsClientUpdateSwiftVirtualNetworkConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateSwiftVirtualNetworkConnectionHandleResponse handles the UpdateSwiftVirtualNetworkConnection response.
func (client *AppsClient) updateSwiftVirtualNetworkConnectionHandleResponse(resp *http.Response) (AppsClientUpdateSwiftVirtualNetworkConnectionResponse, error) {
	result := AppsClientUpdateSwiftVirtualNetworkConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return AppsClientUpdateSwiftVirtualNetworkConnectionResponse{}, err
	}
	return result, nil
}

// UpdateSwiftVirtualNetworkConnectionSlot - Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported"
// is true when doing a GET against this resource, and 2) that the target Subnet has already been delegated, and is
// not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// slot - Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production
// slot.
// connectionEnvelope - Properties of the Virtual Network connection. See example.
// options - AppsClientUpdateSwiftVirtualNetworkConnectionSlotOptions contains the optional parameters for the AppsClient.UpdateSwiftVirtualNetworkConnectionSlot
// method.
func (client *AppsClient) UpdateSwiftVirtualNetworkConnectionSlot(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *AppsClientUpdateSwiftVirtualNetworkConnectionSlotOptions) (AppsClientUpdateSwiftVirtualNetworkConnectionSlotResponse, error) {
	req, err := client.updateSwiftVirtualNetworkConnectionSlotCreateRequest(ctx, resourceGroupName, name, slot, connectionEnvelope, options)
	if err != nil {
		return AppsClientUpdateSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateSwiftVirtualNetworkConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateSwiftVirtualNetworkConnectionSlotHandleResponse(resp)
}

// updateSwiftVirtualNetworkConnectionSlotCreateRequest creates the UpdateSwiftVirtualNetworkConnectionSlot request.
func (client *AppsClient) updateSwiftVirtualNetworkConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *AppsClientUpdateSwiftVirtualNetworkConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateSwiftVirtualNetworkConnectionSlotHandleResponse handles the UpdateSwiftVirtualNetworkConnectionSlot response.
func (client *AppsClient) updateSwiftVirtualNetworkConnectionSlotHandleResponse(resp *http.Response) (AppsClientUpdateSwiftVirtualNetworkConnectionSlotResponse, error) {
	result := AppsClientUpdateSwiftVirtualNetworkConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return AppsClientUpdateSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	return result, nil
}

// UpdateVnetConnection - Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of an existing Virtual Network.
// connectionEnvelope - Properties of the Virtual Network connection. See example.
// options - AppsClientUpdateVnetConnectionOptions contains the optional parameters for the AppsClient.UpdateVnetConnection
// method.
func (client *AppsClient) UpdateVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo, options *AppsClientUpdateVnetConnectionOptions) (AppsClientUpdateVnetConnectionResponse, error) {
	req, err := client.updateVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, connectionEnvelope, options)
	if err != nil {
		return AppsClientUpdateVnetConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateVnetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateVnetConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateVnetConnectionHandleResponse(resp)
}

// updateVnetConnectionCreateRequest creates the UpdateVnetConnection request.
func (client *AppsClient) updateVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo, options *AppsClientUpdateVnetConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateVnetConnectionHandleResponse handles the UpdateVnetConnection response.
func (client *AppsClient) updateVnetConnectionHandleResponse(resp *http.Response) (AppsClientUpdateVnetConnectionResponse, error) {
	result := AppsClientUpdateVnetConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfo); err != nil {
		return AppsClientUpdateVnetConnectionResponse{}, err
	}
	return result, nil
}

// UpdateVnetConnectionGateway - Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of the Virtual Network.
// gatewayName - Name of the gateway. Currently, the only supported string is "primary".
// connectionEnvelope - The properties to update this gateway with.
// options - AppsClientUpdateVnetConnectionGatewayOptions contains the optional parameters for the AppsClient.UpdateVnetConnectionGateway
// method.
func (client *AppsClient) UpdateVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *AppsClientUpdateVnetConnectionGatewayOptions) (AppsClientUpdateVnetConnectionGatewayResponse, error) {
	req, err := client.updateVnetConnectionGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options)
	if err != nil {
		return AppsClientUpdateVnetConnectionGatewayResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateVnetConnectionGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateVnetConnectionGatewayResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateVnetConnectionGatewayHandleResponse(resp)
}

// updateVnetConnectionGatewayCreateRequest creates the UpdateVnetConnectionGateway request.
func (client *AppsClient) updateVnetConnectionGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *AppsClientUpdateVnetConnectionGatewayOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateVnetConnectionGatewayHandleResponse handles the UpdateVnetConnectionGateway response.
func (client *AppsClient) updateVnetConnectionGatewayHandleResponse(resp *http.Response) (AppsClientUpdateVnetConnectionGatewayResponse, error) {
	result := AppsClientUpdateVnetConnectionGatewayResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return AppsClientUpdateVnetConnectionGatewayResponse{}, err
	}
	return result, nil
}

// UpdateVnetConnectionGatewaySlot - Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of the Virtual Network.
// gatewayName - Name of the gateway. Currently, the only supported string is "primary".
// slot - Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production
// slot's Virtual Network.
// connectionEnvelope - The properties to update this gateway with.
// options - AppsClientUpdateVnetConnectionGatewaySlotOptions contains the optional parameters for the AppsClient.UpdateVnetConnectionGatewaySlot
// method.
func (client *AppsClient) UpdateVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *AppsClientUpdateVnetConnectionGatewaySlotOptions) (AppsClientUpdateVnetConnectionGatewaySlotResponse, error) {
	req, err := client.updateVnetConnectionGatewaySlotCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope, options)
	if err != nil {
		return AppsClientUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateVnetConnectionGatewaySlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateVnetConnectionGatewaySlotHandleResponse(resp)
}

// updateVnetConnectionGatewaySlotCreateRequest creates the UpdateVnetConnectionGatewaySlot request.
func (client *AppsClient) updateVnetConnectionGatewaySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *AppsClientUpdateVnetConnectionGatewaySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateVnetConnectionGatewaySlotHandleResponse handles the UpdateVnetConnectionGatewaySlot response.
func (client *AppsClient) updateVnetConnectionGatewaySlotHandleResponse(resp *http.Response) (AppsClientUpdateVnetConnectionGatewaySlotResponse, error) {
	result := AppsClientUpdateVnetConnectionGatewaySlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return AppsClientUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	return result, nil
}

// UpdateVnetConnectionSlot - Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
// (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the app.
// vnetName - Name of an existing Virtual Network.
// slot - Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production
// slot.
// connectionEnvelope - Properties of the Virtual Network connection. See example.
// options - AppsClientUpdateVnetConnectionSlotOptions contains the optional parameters for the AppsClient.UpdateVnetConnectionSlot
// method.
func (client *AppsClient) UpdateVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfo, options *AppsClientUpdateVnetConnectionSlotOptions) (AppsClientUpdateVnetConnectionSlotResponse, error) {
	req, err := client.updateVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, connectionEnvelope, options)
	if err != nil {
		return AppsClientUpdateVnetConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppsClientUpdateVnetConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppsClientUpdateVnetConnectionSlotResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateVnetConnectionSlotHandleResponse(resp)
}

// updateVnetConnectionSlotCreateRequest creates the UpdateVnetConnectionSlot request.
func (client *AppsClient) updateVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfo, options *AppsClientUpdateVnetConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateVnetConnectionSlotHandleResponse handles the UpdateVnetConnectionSlot response.
func (client *AppsClient) updateVnetConnectionSlotHandleResponse(resp *http.Response) (AppsClientUpdateVnetConnectionSlotResponse, error) {
	result := AppsClientUpdateVnetConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfo); err != nil {
		return AppsClientUpdateVnetConnectionSlotResponse{}, err
	}
	return result, nil
}
