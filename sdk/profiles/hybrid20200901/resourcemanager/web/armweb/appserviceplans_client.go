//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package armweb

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/cloud"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/profiles/hybrid20200901/internal"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// AppServicePlansClient contains the methods for the AppServicePlans group.
// Don't use this type directly, use NewAppServicePlansClient() instead.
type AppServicePlansClient struct {
	host           string
	subscriptionID string
	pl             runtime.Pipeline
}

// NewAppServicePlansClient creates a new instance of AppServicePlansClient with the specified values.
// subscriptionID - Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
// credential - used to authorize requests. Usually a credential from azidentity.
// options - pass nil to accept the default values.
func NewAppServicePlansClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*AppServicePlansClient, error) {
	if options == nil {
		options = &arm.ClientOptions{}
	}
	ep := cloud.AzurePublic.Services[cloud.ResourceManager].Endpoint
	if c, ok := options.Cloud.Services[cloud.ResourceManager]; ok {
		ep = c.Endpoint
	}
	pl, err := armruntime.NewPipeline(internal.ModuleName, internal.ModuleVersion, credential, runtime.PipelineOptions{}, options)
	if err != nil {
		return nil, err
	}
	client := &AppServicePlansClient{
		subscriptionID: subscriptionID,
		host:           ep,
		pl:             pl,
	}
	return client, nil
}

// BeginCreateOrUpdate - Creates or updates an App Service Plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// appServicePlan - Details of the App Service plan.
// options - AppServicePlansClientBeginCreateOrUpdateOptions contains the optional parameters for the AppServicePlansClient.BeginCreateOrUpdate
// method.
func (client *AppServicePlansClient) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, name string, appServicePlan AppServicePlan, options *AppServicePlansClientBeginCreateOrUpdateOptions) (*runtime.Poller[AppServicePlansClientCreateOrUpdateResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdate(ctx, resourceGroupName, name, appServicePlan, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller[AppServicePlansClientCreateOrUpdateResponse](resp, client.pl, nil)
	} else {
		return runtime.NewPollerFromResumeToken[AppServicePlansClientCreateOrUpdateResponse](options.ResumeToken, client.pl, nil)
	}
}

// CreateOrUpdate - Creates or updates an App Service Plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
func (client *AppServicePlansClient) createOrUpdate(ctx context.Context, resourceGroupName string, name string, appServicePlan AppServicePlan, options *AppServicePlansClientBeginCreateOrUpdateOptions) (*http.Response, error) {
	req, err := client.createOrUpdateCreateRequest(ctx, resourceGroupName, name, appServicePlan, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *AppServicePlansClient) createOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, name string, appServicePlan AppServicePlan, options *AppServicePlansClientBeginCreateOrUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, appServicePlan)
}

// CreateOrUpdateVnetRoute - Create or update a Virtual Network route in an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// vnetName - Name of the Virtual Network.
// routeName - Name of the Virtual Network route.
// route - Definition of the Virtual Network route.
// options - AppServicePlansClientCreateOrUpdateVnetRouteOptions contains the optional parameters for the AppServicePlansClient.CreateOrUpdateVnetRoute
// method.
func (client *AppServicePlansClient) CreateOrUpdateVnetRoute(ctx context.Context, resourceGroupName string, name string, vnetName string, routeName string, route VnetRoute, options *AppServicePlansClientCreateOrUpdateVnetRouteOptions) (AppServicePlansClientCreateOrUpdateVnetRouteResponse, error) {
	req, err := client.createOrUpdateVnetRouteCreateRequest(ctx, resourceGroupName, name, vnetName, routeName, route, options)
	if err != nil {
		return AppServicePlansClientCreateOrUpdateVnetRouteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientCreateOrUpdateVnetRouteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusNotFound) {
		return AppServicePlansClientCreateOrUpdateVnetRouteResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateVnetRouteHandleResponse(resp)
}

// createOrUpdateVnetRouteCreateRequest creates the CreateOrUpdateVnetRoute request.
func (client *AppServicePlansClient) createOrUpdateVnetRouteCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, routeName string, route VnetRoute, options *AppServicePlansClientCreateOrUpdateVnetRouteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if routeName == "" {
		return nil, errors.New("parameter routeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{routeName}", url.PathEscape(routeName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, route)
}

// createOrUpdateVnetRouteHandleResponse handles the CreateOrUpdateVnetRoute response.
func (client *AppServicePlansClient) createOrUpdateVnetRouteHandleResponse(resp *http.Response) (AppServicePlansClientCreateOrUpdateVnetRouteResponse, error) {
	result := AppServicePlansClientCreateOrUpdateVnetRouteResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetRoute); err != nil {
		return AppServicePlansClientCreateOrUpdateVnetRouteResponse{}, err
	}
	return result, nil
}

// Delete - Delete an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// options - AppServicePlansClientDeleteOptions contains the optional parameters for the AppServicePlansClient.Delete method.
func (client *AppServicePlansClient) Delete(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientDeleteOptions) (AppServicePlansClientDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServicePlansClientDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppServicePlansClientDeleteResponse{}, runtime.NewResponseError(resp)
	}
	return AppServicePlansClientDeleteResponse{}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *AppServicePlansClient) deleteCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientDeleteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteHybridConnection - Delete a Hybrid Connection in use in an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// namespaceName - Name of the Service Bus namespace.
// relayName - Name of the Service Bus relay.
// options - AppServicePlansClientDeleteHybridConnectionOptions contains the optional parameters for the AppServicePlansClient.DeleteHybridConnection
// method.
func (client *AppServicePlansClient) DeleteHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppServicePlansClientDeleteHybridConnectionOptions) (AppServicePlansClientDeleteHybridConnectionResponse, error) {
	req, err := client.deleteHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
	if err != nil {
		return AppServicePlansClientDeleteHybridConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientDeleteHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return AppServicePlansClientDeleteHybridConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return AppServicePlansClientDeleteHybridConnectionResponse{}, nil
}

// deleteHybridConnectionCreateRequest creates the DeleteHybridConnection request.
func (client *AppServicePlansClient) deleteHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppServicePlansClientDeleteHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// DeleteVnetRoute - Delete a Virtual Network route in an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// vnetName - Name of the Virtual Network.
// routeName - Name of the Virtual Network route.
// options - AppServicePlansClientDeleteVnetRouteOptions contains the optional parameters for the AppServicePlansClient.DeleteVnetRoute
// method.
func (client *AppServicePlansClient) DeleteVnetRoute(ctx context.Context, resourceGroupName string, name string, vnetName string, routeName string, options *AppServicePlansClientDeleteVnetRouteOptions) (AppServicePlansClientDeleteVnetRouteResponse, error) {
	req, err := client.deleteVnetRouteCreateRequest(ctx, resourceGroupName, name, vnetName, routeName, options)
	if err != nil {
		return AppServicePlansClientDeleteVnetRouteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientDeleteVnetRouteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppServicePlansClientDeleteVnetRouteResponse{}, runtime.NewResponseError(resp)
	}
	return AppServicePlansClientDeleteVnetRouteResponse{}, nil
}

// deleteVnetRouteCreateRequest creates the DeleteVnetRoute request.
func (client *AppServicePlansClient) deleteVnetRouteCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, routeName string, options *AppServicePlansClientDeleteVnetRouteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if routeName == "" {
		return nil, errors.New("parameter routeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{routeName}", url.PathEscape(routeName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// Get - Get an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// options - AppServicePlansClientGetOptions contains the optional parameters for the AppServicePlansClient.Get method.
func (client *AppServicePlansClient) Get(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientGetOptions) (AppServicePlansClientGetResponse, error) {
	req, err := client.getCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServicePlansClientGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppServicePlansClientGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.getHandleResponse(resp)
}

// getCreateRequest creates the Get request.
func (client *AppServicePlansClient) getCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientGetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *AppServicePlansClient) getHandleResponse(resp *http.Response) (AppServicePlansClientGetResponse, error) {
	result := AppServicePlansClientGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppServicePlan); err != nil {
		return AppServicePlansClientGetResponse{}, err
	}
	return result, nil
}

// GetHybridConnection - Retrieve a Hybrid Connection in use in an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// namespaceName - Name of the Service Bus namespace.
// relayName - Name of the Service Bus relay.
// options - AppServicePlansClientGetHybridConnectionOptions contains the optional parameters for the AppServicePlansClient.GetHybridConnection
// method.
func (client *AppServicePlansClient) GetHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppServicePlansClientGetHybridConnectionOptions) (AppServicePlansClientGetHybridConnectionResponse, error) {
	req, err := client.getHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
	if err != nil {
		return AppServicePlansClientGetHybridConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientGetHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServicePlansClientGetHybridConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getHybridConnectionHandleResponse(resp)
}

// getHybridConnectionCreateRequest creates the GetHybridConnection request.
func (client *AppServicePlansClient) getHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppServicePlansClientGetHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHybridConnectionHandleResponse handles the GetHybridConnection response.
func (client *AppServicePlansClient) getHybridConnectionHandleResponse(resp *http.Response) (AppServicePlansClientGetHybridConnectionResponse, error) {
	result := AppServicePlansClientGetHybridConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return AppServicePlansClientGetHybridConnectionResponse{}, err
	}
	return result, nil
}

// GetHybridConnectionPlanLimit - Get the maximum number of Hybrid Connections allowed in an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// options - AppServicePlansClientGetHybridConnectionPlanLimitOptions contains the optional parameters for the AppServicePlansClient.GetHybridConnectionPlanLimit
// method.
func (client *AppServicePlansClient) GetHybridConnectionPlanLimit(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientGetHybridConnectionPlanLimitOptions) (AppServicePlansClientGetHybridConnectionPlanLimitResponse, error) {
	req, err := client.getHybridConnectionPlanLimitCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServicePlansClientGetHybridConnectionPlanLimitResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientGetHybridConnectionPlanLimitResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServicePlansClientGetHybridConnectionPlanLimitResponse{}, runtime.NewResponseError(resp)
	}
	return client.getHybridConnectionPlanLimitHandleResponse(resp)
}

// getHybridConnectionPlanLimitCreateRequest creates the GetHybridConnectionPlanLimit request.
func (client *AppServicePlansClient) getHybridConnectionPlanLimitCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientGetHybridConnectionPlanLimitOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionPlanLimits/limit"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHybridConnectionPlanLimitHandleResponse handles the GetHybridConnectionPlanLimit response.
func (client *AppServicePlansClient) getHybridConnectionPlanLimitHandleResponse(resp *http.Response) (AppServicePlansClientGetHybridConnectionPlanLimitResponse, error) {
	result := AppServicePlansClientGetHybridConnectionPlanLimitResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnectionLimits); err != nil {
		return AppServicePlansClientGetHybridConnectionPlanLimitResponse{}, err
	}
	return result, nil
}

// GetRouteForVnet - Get a Virtual Network route in an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// vnetName - Name of the Virtual Network.
// routeName - Name of the Virtual Network route.
// options - AppServicePlansClientGetRouteForVnetOptions contains the optional parameters for the AppServicePlansClient.GetRouteForVnet
// method.
func (client *AppServicePlansClient) GetRouteForVnet(ctx context.Context, resourceGroupName string, name string, vnetName string, routeName string, options *AppServicePlansClientGetRouteForVnetOptions) (AppServicePlansClientGetRouteForVnetResponse, error) {
	req, err := client.getRouteForVnetCreateRequest(ctx, resourceGroupName, name, vnetName, routeName, options)
	if err != nil {
		return AppServicePlansClientGetRouteForVnetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientGetRouteForVnetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppServicePlansClientGetRouteForVnetResponse{}, runtime.NewResponseError(resp)
	}
	return client.getRouteForVnetHandleResponse(resp)
}

// getRouteForVnetCreateRequest creates the GetRouteForVnet request.
func (client *AppServicePlansClient) getRouteForVnetCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, routeName string, options *AppServicePlansClientGetRouteForVnetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if routeName == "" {
		return nil, errors.New("parameter routeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{routeName}", url.PathEscape(routeName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getRouteForVnetHandleResponse handles the GetRouteForVnet response.
func (client *AppServicePlansClient) getRouteForVnetHandleResponse(resp *http.Response) (AppServicePlansClientGetRouteForVnetResponse, error) {
	result := AppServicePlansClientGetRouteForVnetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetRouteArray); err != nil {
		return AppServicePlansClientGetRouteForVnetResponse{}, err
	}
	return result, nil
}

// GetServerFarmSKUs - Gets all selectable SKUs for a given App Service Plan
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of App Service Plan
// options - AppServicePlansClientGetServerFarmSKUsOptions contains the optional parameters for the AppServicePlansClient.GetServerFarmSKUs
// method.
func (client *AppServicePlansClient) GetServerFarmSKUs(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientGetServerFarmSKUsOptions) (AppServicePlansClientGetServerFarmSKUsResponse, error) {
	req, err := client.getServerFarmSKUsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServicePlansClientGetServerFarmSKUsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientGetServerFarmSKUsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServicePlansClientGetServerFarmSKUsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getServerFarmSKUsHandleResponse(resp)
}

// getServerFarmSKUsCreateRequest creates the GetServerFarmSKUs request.
func (client *AppServicePlansClient) getServerFarmSKUsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientGetServerFarmSKUsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/skus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getServerFarmSKUsHandleResponse handles the GetServerFarmSKUs response.
func (client *AppServicePlansClient) getServerFarmSKUsHandleResponse(resp *http.Response) (AppServicePlansClientGetServerFarmSKUsResponse, error) {
	result := AppServicePlansClientGetServerFarmSKUsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return AppServicePlansClientGetServerFarmSKUsResponse{}, err
	}
	return result, nil
}

// GetVnetFromServerFarm - Get a Virtual Network associated with an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// vnetName - Name of the Virtual Network.
// options - AppServicePlansClientGetVnetFromServerFarmOptions contains the optional parameters for the AppServicePlansClient.GetVnetFromServerFarm
// method.
func (client *AppServicePlansClient) GetVnetFromServerFarm(ctx context.Context, resourceGroupName string, name string, vnetName string, options *AppServicePlansClientGetVnetFromServerFarmOptions) (AppServicePlansClientGetVnetFromServerFarmResponse, error) {
	req, err := client.getVnetFromServerFarmCreateRequest(ctx, resourceGroupName, name, vnetName, options)
	if err != nil {
		return AppServicePlansClientGetVnetFromServerFarmResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientGetVnetFromServerFarmResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return AppServicePlansClientGetVnetFromServerFarmResponse{}, runtime.NewResponseError(resp)
	}
	return client.getVnetFromServerFarmHandleResponse(resp)
}

// getVnetFromServerFarmCreateRequest creates the GetVnetFromServerFarm request.
func (client *AppServicePlansClient) getVnetFromServerFarmCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, options *AppServicePlansClientGetVnetFromServerFarmOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVnetFromServerFarmHandleResponse handles the GetVnetFromServerFarm response.
func (client *AppServicePlansClient) getVnetFromServerFarmHandleResponse(resp *http.Response) (AppServicePlansClientGetVnetFromServerFarmResponse, error) {
	result := AppServicePlansClientGetVnetFromServerFarmResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfo); err != nil {
		return AppServicePlansClientGetVnetFromServerFarmResponse{}, err
	}
	return result, nil
}

// GetVnetGateway - Get a Virtual Network gateway.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// vnetName - Name of the Virtual Network.
// gatewayName - Name of the gateway. Only the 'primary' gateway is supported.
// options - AppServicePlansClientGetVnetGatewayOptions contains the optional parameters for the AppServicePlansClient.GetVnetGateway
// method.
func (client *AppServicePlansClient) GetVnetGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, options *AppServicePlansClientGetVnetGatewayOptions) (AppServicePlansClientGetVnetGatewayResponse, error) {
	req, err := client.getVnetGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, options)
	if err != nil {
		return AppServicePlansClientGetVnetGatewayResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientGetVnetGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServicePlansClientGetVnetGatewayResponse{}, runtime.NewResponseError(resp)
	}
	return client.getVnetGatewayHandleResponse(resp)
}

// getVnetGatewayCreateRequest creates the GetVnetGateway request.
func (client *AppServicePlansClient) getVnetGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, options *AppServicePlansClientGetVnetGatewayOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVnetGatewayHandleResponse handles the GetVnetGateway response.
func (client *AppServicePlansClient) getVnetGatewayHandleResponse(resp *http.Response) (AppServicePlansClientGetVnetGatewayResponse, error) {
	result := AppServicePlansClientGetVnetGatewayResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return AppServicePlansClientGetVnetGatewayResponse{}, err
	}
	return result, nil
}

// NewListPager - Get all App Service plans for a subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// options - AppServicePlansClientListOptions contains the optional parameters for the AppServicePlansClient.List method.
func (client *AppServicePlansClient) NewListPager(options *AppServicePlansClientListOptions) *runtime.Pager[AppServicePlansClientListResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppServicePlansClientListResponse]{
		More: func(page AppServicePlansClientListResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppServicePlansClientListResponse) (AppServicePlansClientListResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listCreateRequest(ctx, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppServicePlansClientListResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppServicePlansClientListResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppServicePlansClientListResponse{}, runtime.NewResponseError(resp)
			}
			return client.listHandleResponse(resp)
		},
	})
}

// listCreateRequest creates the List request.
func (client *AppServicePlansClient) listCreateRequest(ctx context.Context, options *AppServicePlansClientListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/serverfarms"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Detailed != nil {
		reqQP.Set("detailed", strconv.FormatBool(*options.Detailed))
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHandleResponse handles the List response.
func (client *AppServicePlansClient) listHandleResponse(resp *http.Response) (AppServicePlansClientListResponse, error) {
	result := AppServicePlansClientListResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppServicePlanCollection); err != nil {
		return AppServicePlansClientListResponse{}, err
	}
	return result, nil
}

// NewListByResourceGroupPager - Get all App Service plans in a resource group.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// options - AppServicePlansClientListByResourceGroupOptions contains the optional parameters for the AppServicePlansClient.ListByResourceGroup
// method.
func (client *AppServicePlansClient) NewListByResourceGroupPager(resourceGroupName string, options *AppServicePlansClientListByResourceGroupOptions) *runtime.Pager[AppServicePlansClientListByResourceGroupResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppServicePlansClientListByResourceGroupResponse]{
		More: func(page AppServicePlansClientListByResourceGroupResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppServicePlansClientListByResourceGroupResponse) (AppServicePlansClientListByResourceGroupResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listByResourceGroupCreateRequest(ctx, resourceGroupName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppServicePlansClientListByResourceGroupResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppServicePlansClientListByResourceGroupResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppServicePlansClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
			}
			return client.listByResourceGroupHandleResponse(resp)
		},
	})
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *AppServicePlansClient) listByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *AppServicePlansClientListByResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *AppServicePlansClient) listByResourceGroupHandleResponse(resp *http.Response) (AppServicePlansClientListByResourceGroupResponse, error) {
	result := AppServicePlansClientListByResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppServicePlanCollection); err != nil {
		return AppServicePlansClientListByResourceGroupResponse{}, err
	}
	return result, nil
}

// ListCapabilities - List all capabilities of an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// options - AppServicePlansClientListCapabilitiesOptions contains the optional parameters for the AppServicePlansClient.ListCapabilities
// method.
func (client *AppServicePlansClient) ListCapabilities(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientListCapabilitiesOptions) (AppServicePlansClientListCapabilitiesResponse, error) {
	req, err := client.listCapabilitiesCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServicePlansClientListCapabilitiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientListCapabilitiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServicePlansClientListCapabilitiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.listCapabilitiesHandleResponse(resp)
}

// listCapabilitiesCreateRequest creates the ListCapabilities request.
func (client *AppServicePlansClient) listCapabilitiesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientListCapabilitiesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/capabilities"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listCapabilitiesHandleResponse handles the ListCapabilities response.
func (client *AppServicePlansClient) listCapabilitiesHandleResponse(resp *http.Response) (AppServicePlansClientListCapabilitiesResponse, error) {
	result := AppServicePlansClientListCapabilitiesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CapabilityArray); err != nil {
		return AppServicePlansClientListCapabilitiesResponse{}, err
	}
	return result, nil
}

// ListHybridConnectionKeys - Get the send key name and value of a Hybrid Connection.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// namespaceName - The name of the Service Bus namespace.
// relayName - The name of the Service Bus relay.
// options - AppServicePlansClientListHybridConnectionKeysOptions contains the optional parameters for the AppServicePlansClient.ListHybridConnectionKeys
// method.
func (client *AppServicePlansClient) ListHybridConnectionKeys(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppServicePlansClientListHybridConnectionKeysOptions) (AppServicePlansClientListHybridConnectionKeysResponse, error) {
	req, err := client.listHybridConnectionKeysCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
	if err != nil {
		return AppServicePlansClientListHybridConnectionKeysResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientListHybridConnectionKeysResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServicePlansClientListHybridConnectionKeysResponse{}, runtime.NewResponseError(resp)
	}
	return client.listHybridConnectionKeysHandleResponse(resp)
}

// listHybridConnectionKeysCreateRequest creates the ListHybridConnectionKeys request.
func (client *AppServicePlansClient) listHybridConnectionKeysCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppServicePlansClientListHybridConnectionKeysOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHybridConnectionKeysHandleResponse handles the ListHybridConnectionKeys response.
func (client *AppServicePlansClient) listHybridConnectionKeysHandleResponse(resp *http.Response) (AppServicePlansClientListHybridConnectionKeysResponse, error) {
	result := AppServicePlansClientListHybridConnectionKeysResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnectionKey); err != nil {
		return AppServicePlansClientListHybridConnectionKeysResponse{}, err
	}
	return result, nil
}

// NewListHybridConnectionsPager - Retrieve all Hybrid Connections in use in an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// options - AppServicePlansClientListHybridConnectionsOptions contains the optional parameters for the AppServicePlansClient.ListHybridConnections
// method.
func (client *AppServicePlansClient) NewListHybridConnectionsPager(resourceGroupName string, name string, options *AppServicePlansClientListHybridConnectionsOptions) *runtime.Pager[AppServicePlansClientListHybridConnectionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppServicePlansClientListHybridConnectionsResponse]{
		More: func(page AppServicePlansClientListHybridConnectionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppServicePlansClientListHybridConnectionsResponse) (AppServicePlansClientListHybridConnectionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listHybridConnectionsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppServicePlansClientListHybridConnectionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppServicePlansClientListHybridConnectionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppServicePlansClientListHybridConnectionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listHybridConnectionsHandleResponse(resp)
		},
	})
}

// listHybridConnectionsCreateRequest creates the ListHybridConnections request.
func (client *AppServicePlansClient) listHybridConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientListHybridConnectionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionRelays"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHybridConnectionsHandleResponse handles the ListHybridConnections response.
func (client *AppServicePlansClient) listHybridConnectionsHandleResponse(resp *http.Response) (AppServicePlansClientListHybridConnectionsResponse, error) {
	result := AppServicePlansClientListHybridConnectionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnectionCollection); err != nil {
		return AppServicePlansClientListHybridConnectionsResponse{}, err
	}
	return result, nil
}

// NewListMetricDefintionsPager - Get metrics that can be queried for an App Service plan, and their definitions.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// options - AppServicePlansClientListMetricDefintionsOptions contains the optional parameters for the AppServicePlansClient.ListMetricDefintions
// method.
func (client *AppServicePlansClient) NewListMetricDefintionsPager(resourceGroupName string, name string, options *AppServicePlansClientListMetricDefintionsOptions) *runtime.Pager[AppServicePlansClientListMetricDefintionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppServicePlansClientListMetricDefintionsResponse]{
		More: func(page AppServicePlansClientListMetricDefintionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppServicePlansClientListMetricDefintionsResponse) (AppServicePlansClientListMetricDefintionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listMetricDefintionsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppServicePlansClientListMetricDefintionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppServicePlansClientListMetricDefintionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppServicePlansClientListMetricDefintionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listMetricDefintionsHandleResponse(resp)
		},
	})
}

// listMetricDefintionsCreateRequest creates the ListMetricDefintions request.
func (client *AppServicePlansClient) listMetricDefintionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientListMetricDefintionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/metricdefinitions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listMetricDefintionsHandleResponse handles the ListMetricDefintions response.
func (client *AppServicePlansClient) listMetricDefintionsHandleResponse(resp *http.Response) (AppServicePlansClientListMetricDefintionsResponse, error) {
	result := AppServicePlansClientListMetricDefintionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricDefinitionCollection); err != nil {
		return AppServicePlansClientListMetricDefintionsResponse{}, err
	}
	return result, nil
}

// NewListMetricsPager - Get metrics for an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// options - AppServicePlansClientListMetricsOptions contains the optional parameters for the AppServicePlansClient.ListMetrics
// method.
func (client *AppServicePlansClient) NewListMetricsPager(resourceGroupName string, name string, options *AppServicePlansClientListMetricsOptions) *runtime.Pager[AppServicePlansClientListMetricsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppServicePlansClientListMetricsResponse]{
		More: func(page AppServicePlansClientListMetricsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppServicePlansClientListMetricsResponse) (AppServicePlansClientListMetricsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listMetricsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppServicePlansClientListMetricsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppServicePlansClientListMetricsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppServicePlansClientListMetricsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listMetricsHandleResponse(resp)
		},
	})
}

// listMetricsCreateRequest creates the ListMetrics request.
func (client *AppServicePlansClient) listMetricsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientListMetricsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/metrics"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Details != nil {
		reqQP.Set("details", strconv.FormatBool(*options.Details))
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listMetricsHandleResponse handles the ListMetrics response.
func (client *AppServicePlansClient) listMetricsHandleResponse(resp *http.Response) (AppServicePlansClientListMetricsResponse, error) {
	result := AppServicePlansClientListMetricsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricCollection); err != nil {
		return AppServicePlansClientListMetricsResponse{}, err
	}
	return result, nil
}

// ListRoutesForVnet - Get all routes that are associated with a Virtual Network in an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// vnetName - Name of the Virtual Network.
// options - AppServicePlansClientListRoutesForVnetOptions contains the optional parameters for the AppServicePlansClient.ListRoutesForVnet
// method.
func (client *AppServicePlansClient) ListRoutesForVnet(ctx context.Context, resourceGroupName string, name string, vnetName string, options *AppServicePlansClientListRoutesForVnetOptions) (AppServicePlansClientListRoutesForVnetResponse, error) {
	req, err := client.listRoutesForVnetCreateRequest(ctx, resourceGroupName, name, vnetName, options)
	if err != nil {
		return AppServicePlansClientListRoutesForVnetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientListRoutesForVnetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServicePlansClientListRoutesForVnetResponse{}, runtime.NewResponseError(resp)
	}
	return client.listRoutesForVnetHandleResponse(resp)
}

// listRoutesForVnetCreateRequest creates the ListRoutesForVnet request.
func (client *AppServicePlansClient) listRoutesForVnetCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, options *AppServicePlansClientListRoutesForVnetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listRoutesForVnetHandleResponse handles the ListRoutesForVnet response.
func (client *AppServicePlansClient) listRoutesForVnetHandleResponse(resp *http.Response) (AppServicePlansClientListRoutesForVnetResponse, error) {
	result := AppServicePlansClientListRoutesForVnetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetRouteArray); err != nil {
		return AppServicePlansClientListRoutesForVnetResponse{}, err
	}
	return result, nil
}

// NewListUsagesPager - Gets server farm usage information
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of App Service Plan
// options - AppServicePlansClientListUsagesOptions contains the optional parameters for the AppServicePlansClient.ListUsages
// method.
func (client *AppServicePlansClient) NewListUsagesPager(resourceGroupName string, name string, options *AppServicePlansClientListUsagesOptions) *runtime.Pager[AppServicePlansClientListUsagesResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppServicePlansClientListUsagesResponse]{
		More: func(page AppServicePlansClientListUsagesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppServicePlansClientListUsagesResponse) (AppServicePlansClientListUsagesResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listUsagesCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppServicePlansClientListUsagesResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppServicePlansClientListUsagesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppServicePlansClientListUsagesResponse{}, runtime.NewResponseError(resp)
			}
			return client.listUsagesHandleResponse(resp)
		},
	})
}

// listUsagesCreateRequest creates the ListUsages request.
func (client *AppServicePlansClient) listUsagesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientListUsagesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listUsagesHandleResponse handles the ListUsages response.
func (client *AppServicePlansClient) listUsagesHandleResponse(resp *http.Response) (AppServicePlansClientListUsagesResponse, error) {
	result := AppServicePlansClientListUsagesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmUsageQuotaCollection); err != nil {
		return AppServicePlansClientListUsagesResponse{}, err
	}
	return result, nil
}

// ListVnets - Get all Virtual Networks associated with an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// options - AppServicePlansClientListVnetsOptions contains the optional parameters for the AppServicePlansClient.ListVnets
// method.
func (client *AppServicePlansClient) ListVnets(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientListVnetsOptions) (AppServicePlansClientListVnetsResponse, error) {
	req, err := client.listVnetsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServicePlansClientListVnetsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientListVnetsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServicePlansClientListVnetsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listVnetsHandleResponse(resp)
}

// listVnetsCreateRequest creates the ListVnets request.
func (client *AppServicePlansClient) listVnetsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientListVnetsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listVnetsHandleResponse handles the ListVnets response.
func (client *AppServicePlansClient) listVnetsHandleResponse(resp *http.Response) (AppServicePlansClientListVnetsResponse, error) {
	result := AppServicePlansClientListVnetsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoArray); err != nil {
		return AppServicePlansClientListVnetsResponse{}, err
	}
	return result, nil
}

// NewListWebAppsPager - Get all apps associated with an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// options - AppServicePlansClientListWebAppsOptions contains the optional parameters for the AppServicePlansClient.ListWebApps
// method.
func (client *AppServicePlansClient) NewListWebAppsPager(resourceGroupName string, name string, options *AppServicePlansClientListWebAppsOptions) *runtime.Pager[AppServicePlansClientListWebAppsResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppServicePlansClientListWebAppsResponse]{
		More: func(page AppServicePlansClientListWebAppsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppServicePlansClientListWebAppsResponse) (AppServicePlansClientListWebAppsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listWebAppsCreateRequest(ctx, resourceGroupName, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppServicePlansClientListWebAppsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppServicePlansClientListWebAppsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppServicePlansClientListWebAppsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listWebAppsHandleResponse(resp)
		},
	})
}

// listWebAppsCreateRequest creates the ListWebApps request.
func (client *AppServicePlansClient) listWebAppsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientListWebAppsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/sites"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skipToken", *options.SkipToken)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("$top", *options.Top)
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listWebAppsHandleResponse handles the ListWebApps response.
func (client *AppServicePlansClient) listWebAppsHandleResponse(resp *http.Response) (AppServicePlansClientListWebAppsResponse, error) {
	result := AppServicePlansClientListWebAppsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppCollection); err != nil {
		return AppServicePlansClientListWebAppsResponse{}, err
	}
	return result, nil
}

// NewListWebAppsByHybridConnectionPager - Get all apps that use a Hybrid Connection in an App Service Plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// namespaceName - Name of the Hybrid Connection namespace.
// relayName - Name of the Hybrid Connection relay.
// options - AppServicePlansClientListWebAppsByHybridConnectionOptions contains the optional parameters for the AppServicePlansClient.ListWebAppsByHybridConnection
// method.
func (client *AppServicePlansClient) NewListWebAppsByHybridConnectionPager(resourceGroupName string, name string, namespaceName string, relayName string, options *AppServicePlansClientListWebAppsByHybridConnectionOptions) *runtime.Pager[AppServicePlansClientListWebAppsByHybridConnectionResponse] {
	return runtime.NewPager(runtime.PagingHandler[AppServicePlansClientListWebAppsByHybridConnectionResponse]{
		More: func(page AppServicePlansClientListWebAppsByHybridConnectionResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *AppServicePlansClientListWebAppsByHybridConnectionResponse) (AppServicePlansClientListWebAppsByHybridConnectionResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listWebAppsByHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return AppServicePlansClientListWebAppsByHybridConnectionResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return AppServicePlansClientListWebAppsByHybridConnectionResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return AppServicePlansClientListWebAppsByHybridConnectionResponse{}, runtime.NewResponseError(resp)
			}
			return client.listWebAppsByHybridConnectionHandleResponse(resp)
		},
	})
}

// listWebAppsByHybridConnectionCreateRequest creates the ListWebAppsByHybridConnection request.
func (client *AppServicePlansClient) listWebAppsByHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *AppServicePlansClientListWebAppsByHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/sites"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listWebAppsByHybridConnectionHandleResponse handles the ListWebAppsByHybridConnection response.
func (client *AppServicePlansClient) listWebAppsByHybridConnectionHandleResponse(resp *http.Response) (AppServicePlansClientListWebAppsByHybridConnectionResponse, error) {
	result := AppServicePlansClientListWebAppsByHybridConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceCollection); err != nil {
		return AppServicePlansClientListWebAppsByHybridConnectionResponse{}, err
	}
	return result, nil
}

// RebootWorker - Reboot a worker machine in an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// workerName - Name of worker machine, which typically starts with RD.
// options - AppServicePlansClientRebootWorkerOptions contains the optional parameters for the AppServicePlansClient.RebootWorker
// method.
func (client *AppServicePlansClient) RebootWorker(ctx context.Context, resourceGroupName string, name string, workerName string, options *AppServicePlansClientRebootWorkerOptions) (AppServicePlansClientRebootWorkerResponse, error) {
	req, err := client.rebootWorkerCreateRequest(ctx, resourceGroupName, name, workerName, options)
	if err != nil {
		return AppServicePlansClientRebootWorkerResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientRebootWorkerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return AppServicePlansClientRebootWorkerResponse{}, runtime.NewResponseError(resp)
	}
	return AppServicePlansClientRebootWorkerResponse{}, nil
}

// rebootWorkerCreateRequest creates the RebootWorker request.
func (client *AppServicePlansClient) rebootWorkerCreateRequest(ctx context.Context, resourceGroupName string, name string, workerName string, options *AppServicePlansClientRebootWorkerOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/workers/{workerName}/reboot"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerName == "" {
		return nil, errors.New("parameter workerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerName}", url.PathEscape(workerName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// RestartWebApps - Restart all apps in an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// options - AppServicePlansClientRestartWebAppsOptions contains the optional parameters for the AppServicePlansClient.RestartWebApps
// method.
func (client *AppServicePlansClient) RestartWebApps(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientRestartWebAppsOptions) (AppServicePlansClientRestartWebAppsResponse, error) {
	req, err := client.restartWebAppsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServicePlansClientRestartWebAppsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientRestartWebAppsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return AppServicePlansClientRestartWebAppsResponse{}, runtime.NewResponseError(resp)
	}
	return AppServicePlansClientRestartWebAppsResponse{}, nil
}

// restartWebAppsCreateRequest creates the RestartWebApps request.
func (client *AppServicePlansClient) restartWebAppsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServicePlansClientRestartWebAppsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/restartSites"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SoftRestart != nil {
		reqQP.Set("softRestart", strconv.FormatBool(*options.SoftRestart))
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// Update - Creates or updates an App Service Plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// appServicePlan - Details of the App Service plan.
// options - AppServicePlansClientUpdateOptions contains the optional parameters for the AppServicePlansClient.Update method.
func (client *AppServicePlansClient) Update(ctx context.Context, resourceGroupName string, name string, appServicePlan AppServicePlanPatchResource, options *AppServicePlansClientUpdateOptions) (AppServicePlansClientUpdateResponse, error) {
	req, err := client.updateCreateRequest(ctx, resourceGroupName, name, appServicePlan, options)
	if err != nil {
		return AppServicePlansClientUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return AppServicePlansClientUpdateResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateHandleResponse(resp)
}

// updateCreateRequest creates the Update request.
func (client *AppServicePlansClient) updateCreateRequest(ctx context.Context, resourceGroupName string, name string, appServicePlan AppServicePlanPatchResource, options *AppServicePlansClientUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, appServicePlan)
}

// updateHandleResponse handles the Update response.
func (client *AppServicePlansClient) updateHandleResponse(resp *http.Response) (AppServicePlansClientUpdateResponse, error) {
	result := AppServicePlansClientUpdateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppServicePlan); err != nil {
		return AppServicePlansClientUpdateResponse{}, err
	}
	return result, nil
}

// UpdateVnetGateway - Update a Virtual Network gateway.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// vnetName - Name of the Virtual Network.
// gatewayName - Name of the gateway. Only the 'primary' gateway is supported.
// connectionEnvelope - Definition of the gateway.
// options - AppServicePlansClientUpdateVnetGatewayOptions contains the optional parameters for the AppServicePlansClient.UpdateVnetGateway
// method.
func (client *AppServicePlansClient) UpdateVnetGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *AppServicePlansClientUpdateVnetGatewayOptions) (AppServicePlansClientUpdateVnetGatewayResponse, error) {
	req, err := client.updateVnetGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options)
	if err != nil {
		return AppServicePlansClientUpdateVnetGatewayResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientUpdateVnetGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServicePlansClientUpdateVnetGatewayResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateVnetGatewayHandleResponse(resp)
}

// updateVnetGatewayCreateRequest creates the UpdateVnetGateway request.
func (client *AppServicePlansClient) updateVnetGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *AppServicePlansClientUpdateVnetGatewayOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateVnetGatewayHandleResponse handles the UpdateVnetGateway response.
func (client *AppServicePlansClient) updateVnetGatewayHandleResponse(resp *http.Response) (AppServicePlansClientUpdateVnetGatewayResponse, error) {
	result := AppServicePlansClientUpdateVnetGatewayResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return AppServicePlansClientUpdateVnetGatewayResponse{}, err
	}
	return result, nil
}

// UpdateVnetRoute - Create or update a Virtual Network route in an App Service plan.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service plan.
// vnetName - Name of the Virtual Network.
// routeName - Name of the Virtual Network route.
// route - Definition of the Virtual Network route.
// options - AppServicePlansClientUpdateVnetRouteOptions contains the optional parameters for the AppServicePlansClient.UpdateVnetRoute
// method.
func (client *AppServicePlansClient) UpdateVnetRoute(ctx context.Context, resourceGroupName string, name string, vnetName string, routeName string, route VnetRoute, options *AppServicePlansClientUpdateVnetRouteOptions) (AppServicePlansClientUpdateVnetRouteResponse, error) {
	req, err := client.updateVnetRouteCreateRequest(ctx, resourceGroupName, name, vnetName, routeName, route, options)
	if err != nil {
		return AppServicePlansClientUpdateVnetRouteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServicePlansClientUpdateVnetRouteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusNotFound) {
		return AppServicePlansClientUpdateVnetRouteResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateVnetRouteHandleResponse(resp)
}

// updateVnetRouteCreateRequest creates the UpdateVnetRoute request.
func (client *AppServicePlansClient) updateVnetRouteCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, routeName string, route VnetRoute, options *AppServicePlansClientUpdateVnetRouteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if routeName == "" {
		return nil, errors.New("parameter routeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{routeName}", url.PathEscape(routeName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, route)
}

// updateVnetRouteHandleResponse handles the UpdateVnetRoute response.
func (client *AppServicePlansClient) updateVnetRouteHandleResponse(resp *http.Response) (AppServicePlansClientUpdateVnetRouteResponse, error) {
	result := AppServicePlansClientUpdateVnetRouteResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetRoute); err != nil {
		return AppServicePlansClientUpdateVnetRouteResponse{}, err
	}
	return result, nil
}
