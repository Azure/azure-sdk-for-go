//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package armweb

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/cloud"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/profiles/hybrid20200901/internal"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// SiteManagementClient contains the methods for the WebSiteManagementClient group.
// Don't use this type directly, use NewSiteManagementClient() instead.
type SiteManagementClient struct {
	host           string
	subscriptionID string
	pl             runtime.Pipeline
}

// NewSiteManagementClient creates a new instance of SiteManagementClient with the specified values.
// subscriptionID - Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
// credential - used to authorize requests. Usually a credential from azidentity.
// options - pass nil to accept the default values.
func NewSiteManagementClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*SiteManagementClient, error) {
	if options == nil {
		options = &arm.ClientOptions{}
	}
	ep := cloud.AzurePublic.Services[cloud.ResourceManager].Endpoint
	if c, ok := options.Cloud.Services[cloud.ResourceManager]; ok {
		ep = c.Endpoint
	}
	pl, err := armruntime.NewPipeline(hybrid20200901.ModuleName, hybrid20200901.ModuleVersion, credential, runtime.PipelineOptions{}, options)
	if err != nil {
		return nil, err
	}
	client := &SiteManagementClient{
		subscriptionID: subscriptionID,
		host:           ep,
		pl:             pl,
	}
	return client, nil
}

// CheckNameAvailability - Check if a resource name is available.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// request - Name availability request.
// options - SiteManagementClientCheckNameAvailabilityOptions contains the optional parameters for the SiteManagementClient.CheckNameAvailability
// method.
func (client *SiteManagementClient) CheckNameAvailability(ctx context.Context, request ResourceNameAvailabilityRequest, options *SiteManagementClientCheckNameAvailabilityOptions) (SiteManagementClientCheckNameAvailabilityResponse, error) {
	req, err := client.checkNameAvailabilityCreateRequest(ctx, request, options)
	if err != nil {
		return SiteManagementClientCheckNameAvailabilityResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return SiteManagementClientCheckNameAvailabilityResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return SiteManagementClientCheckNameAvailabilityResponse{}, runtime.NewResponseError(resp)
	}
	return client.checkNameAvailabilityHandleResponse(resp)
}

// checkNameAvailabilityCreateRequest creates the CheckNameAvailability request.
func (client *SiteManagementClient) checkNameAvailabilityCreateRequest(ctx context.Context, request ResourceNameAvailabilityRequest, options *SiteManagementClientCheckNameAvailabilityOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/checknameavailability"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, request)
}

// checkNameAvailabilityHandleResponse handles the CheckNameAvailability response.
func (client *SiteManagementClient) checkNameAvailabilityHandleResponse(resp *http.Response) (SiteManagementClientCheckNameAvailabilityResponse, error) {
	result := SiteManagementClientCheckNameAvailabilityResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceNameAvailability); err != nil {
		return SiteManagementClientCheckNameAvailabilityResponse{}, err
	}
	return result, nil
}

// GetPublishingUser - Gets publishing user
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// options - SiteManagementClientGetPublishingUserOptions contains the optional parameters for the SiteManagementClient.GetPublishingUser
// method.
func (client *SiteManagementClient) GetPublishingUser(ctx context.Context, options *SiteManagementClientGetPublishingUserOptions) (SiteManagementClientGetPublishingUserResponse, error) {
	req, err := client.getPublishingUserCreateRequest(ctx, options)
	if err != nil {
		return SiteManagementClientGetPublishingUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return SiteManagementClientGetPublishingUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return SiteManagementClientGetPublishingUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPublishingUserHandleResponse(resp)
}

// getPublishingUserCreateRequest creates the GetPublishingUser request.
func (client *SiteManagementClient) getPublishingUserCreateRequest(ctx context.Context, options *SiteManagementClientGetPublishingUserOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Web/publishingUsers/web"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPublishingUserHandleResponse handles the GetPublishingUser response.
func (client *SiteManagementClient) getPublishingUserHandleResponse(resp *http.Response) (SiteManagementClientGetPublishingUserResponse, error) {
	result := SiteManagementClientGetPublishingUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.User); err != nil {
		return SiteManagementClientGetPublishingUserResponse{}, err
	}
	return result, nil
}

// GetSourceControl - Gets source control token
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// sourceControlType - Type of source control
// options - SiteManagementClientGetSourceControlOptions contains the optional parameters for the SiteManagementClient.GetSourceControl
// method.
func (client *SiteManagementClient) GetSourceControl(ctx context.Context, sourceControlType string, options *SiteManagementClientGetSourceControlOptions) (SiteManagementClientGetSourceControlResponse, error) {
	req, err := client.getSourceControlCreateRequest(ctx, sourceControlType, options)
	if err != nil {
		return SiteManagementClientGetSourceControlResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return SiteManagementClientGetSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return SiteManagementClientGetSourceControlResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSourceControlHandleResponse(resp)
}

// getSourceControlCreateRequest creates the GetSourceControl request.
func (client *SiteManagementClient) getSourceControlCreateRequest(ctx context.Context, sourceControlType string, options *SiteManagementClientGetSourceControlOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Web/sourcecontrols/{sourceControlType}"
	if sourceControlType == "" {
		return nil, errors.New("parameter sourceControlType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sourceControlType}", url.PathEscape(sourceControlType))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSourceControlHandleResponse handles the GetSourceControl response.
func (client *SiteManagementClient) getSourceControlHandleResponse(resp *http.Response) (SiteManagementClientGetSourceControlResponse, error) {
	result := SiteManagementClientGetSourceControlResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SourceControl); err != nil {
		return SiteManagementClientGetSourceControlResponse{}, err
	}
	return result, nil
}

// GetSubscriptionDeploymentLocations - Gets list of available geo regions plus ministamps
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// options - SiteManagementClientGetSubscriptionDeploymentLocationsOptions contains the optional parameters for the SiteManagementClient.GetSubscriptionDeploymentLocations
// method.
func (client *SiteManagementClient) GetSubscriptionDeploymentLocations(ctx context.Context, options *SiteManagementClientGetSubscriptionDeploymentLocationsOptions) (SiteManagementClientGetSubscriptionDeploymentLocationsResponse, error) {
	req, err := client.getSubscriptionDeploymentLocationsCreateRequest(ctx, options)
	if err != nil {
		return SiteManagementClientGetSubscriptionDeploymentLocationsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return SiteManagementClientGetSubscriptionDeploymentLocationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return SiteManagementClientGetSubscriptionDeploymentLocationsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSubscriptionDeploymentLocationsHandleResponse(resp)
}

// getSubscriptionDeploymentLocationsCreateRequest creates the GetSubscriptionDeploymentLocations request.
func (client *SiteManagementClient) getSubscriptionDeploymentLocationsCreateRequest(ctx context.Context, options *SiteManagementClientGetSubscriptionDeploymentLocationsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deploymentLocations"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSubscriptionDeploymentLocationsHandleResponse handles the GetSubscriptionDeploymentLocations response.
func (client *SiteManagementClient) getSubscriptionDeploymentLocationsHandleResponse(resp *http.Response) (SiteManagementClientGetSubscriptionDeploymentLocationsResponse, error) {
	result := SiteManagementClientGetSubscriptionDeploymentLocationsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentLocations); err != nil {
		return SiteManagementClientGetSubscriptionDeploymentLocationsResponse{}, err
	}
	return result, nil
}

// NewListBillingMetersPager - Gets a list of meters for a given location.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// options - SiteManagementClientListBillingMetersOptions contains the optional parameters for the SiteManagementClient.ListBillingMeters
// method.
func (client *SiteManagementClient) NewListBillingMetersPager(options *SiteManagementClientListBillingMetersOptions) *runtime.Pager[SiteManagementClientListBillingMetersResponse] {
	return runtime.NewPager(runtime.PagingHandler[SiteManagementClientListBillingMetersResponse]{
		More: func(page SiteManagementClientListBillingMetersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *SiteManagementClientListBillingMetersResponse) (SiteManagementClientListBillingMetersResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listBillingMetersCreateRequest(ctx, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return SiteManagementClientListBillingMetersResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return SiteManagementClientListBillingMetersResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return SiteManagementClientListBillingMetersResponse{}, runtime.NewResponseError(resp)
			}
			return client.listBillingMetersHandleResponse(resp)
		},
	})
}

// listBillingMetersCreateRequest creates the ListBillingMeters request.
func (client *SiteManagementClient) listBillingMetersCreateRequest(ctx context.Context, options *SiteManagementClientListBillingMetersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/billingMeters"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.BillingLocation != nil {
		reqQP.Set("billingLocation", *options.BillingLocation)
	}
	if options != nil && options.OSType != nil {
		reqQP.Set("osType", *options.OSType)
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listBillingMetersHandleResponse handles the ListBillingMeters response.
func (client *SiteManagementClient) listBillingMetersHandleResponse(resp *http.Response) (SiteManagementClientListBillingMetersResponse, error) {
	result := SiteManagementClientListBillingMetersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingMeterCollection); err != nil {
		return SiteManagementClientListBillingMetersResponse{}, err
	}
	return result, nil
}

// NewListGeoRegionsPager - Get a list of available geographical regions.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// options - SiteManagementClientListGeoRegionsOptions contains the optional parameters for the SiteManagementClient.ListGeoRegions
// method.
func (client *SiteManagementClient) NewListGeoRegionsPager(options *SiteManagementClientListGeoRegionsOptions) *runtime.Pager[SiteManagementClientListGeoRegionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[SiteManagementClientListGeoRegionsResponse]{
		More: func(page SiteManagementClientListGeoRegionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *SiteManagementClientListGeoRegionsResponse) (SiteManagementClientListGeoRegionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listGeoRegionsCreateRequest(ctx, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return SiteManagementClientListGeoRegionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return SiteManagementClientListGeoRegionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return SiteManagementClientListGeoRegionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listGeoRegionsHandleResponse(resp)
		},
	})
}

// listGeoRegionsCreateRequest creates the ListGeoRegions request.
func (client *SiteManagementClient) listGeoRegionsCreateRequest(ctx context.Context, options *SiteManagementClientListGeoRegionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/geoRegions"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SKU != nil {
		reqQP.Set("sku", string(*options.SKU))
	}
	if options != nil && options.LinuxWorkersEnabled != nil {
		reqQP.Set("linuxWorkersEnabled", strconv.FormatBool(*options.LinuxWorkersEnabled))
	}
	if options != nil && options.XenonWorkersEnabled != nil {
		reqQP.Set("xenonWorkersEnabled", strconv.FormatBool(*options.XenonWorkersEnabled))
	}
	if options != nil && options.LinuxDynamicWorkersEnabled != nil {
		reqQP.Set("linuxDynamicWorkersEnabled", strconv.FormatBool(*options.LinuxDynamicWorkersEnabled))
	}
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listGeoRegionsHandleResponse handles the ListGeoRegions response.
func (client *SiteManagementClient) listGeoRegionsHandleResponse(resp *http.Response) (SiteManagementClientListGeoRegionsResponse, error) {
	result := SiteManagementClientListGeoRegionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.GeoRegionCollection); err != nil {
		return SiteManagementClientListGeoRegionsResponse{}, err
	}
	return result, nil
}

// NewListPremierAddOnOffersPager - List all premier add-on offers.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// options - SiteManagementClientListPremierAddOnOffersOptions contains the optional parameters for the SiteManagementClient.ListPremierAddOnOffers
// method.
func (client *SiteManagementClient) NewListPremierAddOnOffersPager(options *SiteManagementClientListPremierAddOnOffersOptions) *runtime.Pager[SiteManagementClientListPremierAddOnOffersResponse] {
	return runtime.NewPager(runtime.PagingHandler[SiteManagementClientListPremierAddOnOffersResponse]{
		More: func(page SiteManagementClientListPremierAddOnOffersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *SiteManagementClientListPremierAddOnOffersResponse) (SiteManagementClientListPremierAddOnOffersResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listPremierAddOnOffersCreateRequest(ctx, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return SiteManagementClientListPremierAddOnOffersResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return SiteManagementClientListPremierAddOnOffersResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return SiteManagementClientListPremierAddOnOffersResponse{}, runtime.NewResponseError(resp)
			}
			return client.listPremierAddOnOffersHandleResponse(resp)
		},
	})
}

// listPremierAddOnOffersCreateRequest creates the ListPremierAddOnOffers request.
func (client *SiteManagementClient) listPremierAddOnOffersCreateRequest(ctx context.Context, options *SiteManagementClientListPremierAddOnOffersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/premieraddonoffers"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPremierAddOnOffersHandleResponse handles the ListPremierAddOnOffers response.
func (client *SiteManagementClient) listPremierAddOnOffersHandleResponse(resp *http.Response) (SiteManagementClientListPremierAddOnOffersResponse, error) {
	result := SiteManagementClientListPremierAddOnOffersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOnOfferCollection); err != nil {
		return SiteManagementClientListPremierAddOnOffersResponse{}, err
	}
	return result, nil
}

// ListSKUs - List all SKUs.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// options - SiteManagementClientListSKUsOptions contains the optional parameters for the SiteManagementClient.ListSKUs method.
func (client *SiteManagementClient) ListSKUs(ctx context.Context, options *SiteManagementClientListSKUsOptions) (SiteManagementClientListSKUsResponse, error) {
	req, err := client.listSKUsCreateRequest(ctx, options)
	if err != nil {
		return SiteManagementClientListSKUsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return SiteManagementClientListSKUsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return SiteManagementClientListSKUsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listSKUsHandleResponse(resp)
}

// listSKUsCreateRequest creates the ListSKUs request.
func (client *SiteManagementClient) listSKUsCreateRequest(ctx context.Context, options *SiteManagementClientListSKUsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/skus"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSKUsHandleResponse handles the ListSKUs response.
func (client *SiteManagementClient) listSKUsHandleResponse(resp *http.Response) (SiteManagementClientListSKUsResponse, error) {
	result := SiteManagementClientListSKUsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SKUInfos); err != nil {
		return SiteManagementClientListSKUsResponse{}, err
	}
	return result, nil
}

// NewListSiteIdentifiersAssignedToHostNamePager - List all apps that are assigned to a hostname.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// nameIdentifier - Hostname information.
// options - SiteManagementClientListSiteIdentifiersAssignedToHostNameOptions contains the optional parameters for the SiteManagementClient.ListSiteIdentifiersAssignedToHostName
// method.
func (client *SiteManagementClient) NewListSiteIdentifiersAssignedToHostNamePager(nameIdentifier NameIdentifier, options *SiteManagementClientListSiteIdentifiersAssignedToHostNameOptions) *runtime.Pager[SiteManagementClientListSiteIdentifiersAssignedToHostNameResponse] {
	return runtime.NewPager(runtime.PagingHandler[SiteManagementClientListSiteIdentifiersAssignedToHostNameResponse]{
		More: func(page SiteManagementClientListSiteIdentifiersAssignedToHostNameResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *SiteManagementClientListSiteIdentifiersAssignedToHostNameResponse) (SiteManagementClientListSiteIdentifiersAssignedToHostNameResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listSiteIdentifiersAssignedToHostNameCreateRequest(ctx, nameIdentifier, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return SiteManagementClientListSiteIdentifiersAssignedToHostNameResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return SiteManagementClientListSiteIdentifiersAssignedToHostNameResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return SiteManagementClientListSiteIdentifiersAssignedToHostNameResponse{}, runtime.NewResponseError(resp)
			}
			return client.listSiteIdentifiersAssignedToHostNameHandleResponse(resp)
		},
	})
}

// listSiteIdentifiersAssignedToHostNameCreateRequest creates the ListSiteIdentifiersAssignedToHostName request.
func (client *SiteManagementClient) listSiteIdentifiersAssignedToHostNameCreateRequest(ctx context.Context, nameIdentifier NameIdentifier, options *SiteManagementClientListSiteIdentifiersAssignedToHostNameOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/listSitesAssignedToHostName"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, nameIdentifier)
}

// listSiteIdentifiersAssignedToHostNameHandleResponse handles the ListSiteIdentifiersAssignedToHostName response.
func (client *SiteManagementClient) listSiteIdentifiersAssignedToHostNameHandleResponse(resp *http.Response) (SiteManagementClientListSiteIdentifiersAssignedToHostNameResponse, error) {
	result := SiteManagementClientListSiteIdentifiersAssignedToHostNameResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IdentifierCollection); err != nil {
		return SiteManagementClientListSiteIdentifiersAssignedToHostNameResponse{}, err
	}
	return result, nil
}

// NewListSourceControlsPager - Gets the source controls available for Azure websites.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// options - SiteManagementClientListSourceControlsOptions contains the optional parameters for the SiteManagementClient.ListSourceControls
// method.
func (client *SiteManagementClient) NewListSourceControlsPager(options *SiteManagementClientListSourceControlsOptions) *runtime.Pager[SiteManagementClientListSourceControlsResponse] {
	return runtime.NewPager(runtime.PagingHandler[SiteManagementClientListSourceControlsResponse]{
		More: func(page SiteManagementClientListSourceControlsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *SiteManagementClientListSourceControlsResponse) (SiteManagementClientListSourceControlsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listSourceControlsCreateRequest(ctx, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return SiteManagementClientListSourceControlsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return SiteManagementClientListSourceControlsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return SiteManagementClientListSourceControlsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listSourceControlsHandleResponse(resp)
		},
	})
}

// listSourceControlsCreateRequest creates the ListSourceControls request.
func (client *SiteManagementClient) listSourceControlsCreateRequest(ctx context.Context, options *SiteManagementClientListSourceControlsOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Web/sourcecontrols"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSourceControlsHandleResponse handles the ListSourceControls response.
func (client *SiteManagementClient) listSourceControlsHandleResponse(resp *http.Response) (SiteManagementClientListSourceControlsResponse, error) {
	result := SiteManagementClientListSourceControlsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SourceControlCollection); err != nil {
		return SiteManagementClientListSourceControlsResponse{}, err
	}
	return result, nil
}

// Move - Move resources between resource groups.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// moveResourceEnvelope - Object that represents the resource to move.
// options - SiteManagementClientMoveOptions contains the optional parameters for the SiteManagementClient.Move method.
func (client *SiteManagementClient) Move(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, options *SiteManagementClientMoveOptions) (SiteManagementClientMoveResponse, error) {
	req, err := client.moveCreateRequest(ctx, resourceGroupName, moveResourceEnvelope, options)
	if err != nil {
		return SiteManagementClientMoveResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return SiteManagementClientMoveResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return SiteManagementClientMoveResponse{}, runtime.NewResponseError(resp)
	}
	return SiteManagementClientMoveResponse{}, nil
}

// moveCreateRequest creates the Move request.
func (client *SiteManagementClient) moveCreateRequest(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, options *SiteManagementClientMoveOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/moveResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, moveResourceEnvelope)
}

// UpdatePublishingUser - Updates publishing user
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// userDetails - Details of publishing user
// options - SiteManagementClientUpdatePublishingUserOptions contains the optional parameters for the SiteManagementClient.UpdatePublishingUser
// method.
func (client *SiteManagementClient) UpdatePublishingUser(ctx context.Context, userDetails User, options *SiteManagementClientUpdatePublishingUserOptions) (SiteManagementClientUpdatePublishingUserResponse, error) {
	req, err := client.updatePublishingUserCreateRequest(ctx, userDetails, options)
	if err != nil {
		return SiteManagementClientUpdatePublishingUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return SiteManagementClientUpdatePublishingUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return SiteManagementClientUpdatePublishingUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.updatePublishingUserHandleResponse(resp)
}

// updatePublishingUserCreateRequest creates the UpdatePublishingUser request.
func (client *SiteManagementClient) updatePublishingUserCreateRequest(ctx context.Context, userDetails User, options *SiteManagementClientUpdatePublishingUserOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Web/publishingUsers/web"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, userDetails)
}

// updatePublishingUserHandleResponse handles the UpdatePublishingUser response.
func (client *SiteManagementClient) updatePublishingUserHandleResponse(resp *http.Response) (SiteManagementClientUpdatePublishingUserResponse, error) {
	result := SiteManagementClientUpdatePublishingUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.User); err != nil {
		return SiteManagementClientUpdatePublishingUserResponse{}, err
	}
	return result, nil
}

// UpdateSourceControl - Updates source control token
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// sourceControlType - Type of source control
// requestMessage - Source control token information
// options - SiteManagementClientUpdateSourceControlOptions contains the optional parameters for the SiteManagementClient.UpdateSourceControl
// method.
func (client *SiteManagementClient) UpdateSourceControl(ctx context.Context, sourceControlType string, requestMessage SourceControl, options *SiteManagementClientUpdateSourceControlOptions) (SiteManagementClientUpdateSourceControlResponse, error) {
	req, err := client.updateSourceControlCreateRequest(ctx, sourceControlType, requestMessage, options)
	if err != nil {
		return SiteManagementClientUpdateSourceControlResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return SiteManagementClientUpdateSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return SiteManagementClientUpdateSourceControlResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateSourceControlHandleResponse(resp)
}

// updateSourceControlCreateRequest creates the UpdateSourceControl request.
func (client *SiteManagementClient) updateSourceControlCreateRequest(ctx context.Context, sourceControlType string, requestMessage SourceControl, options *SiteManagementClientUpdateSourceControlOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Web/sourcecontrols/{sourceControlType}"
	if sourceControlType == "" {
		return nil, errors.New("parameter sourceControlType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sourceControlType}", url.PathEscape(sourceControlType))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, requestMessage)
}

// updateSourceControlHandleResponse handles the UpdateSourceControl response.
func (client *SiteManagementClient) updateSourceControlHandleResponse(resp *http.Response) (SiteManagementClientUpdateSourceControlResponse, error) {
	result := SiteManagementClientUpdateSourceControlResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SourceControl); err != nil {
		return SiteManagementClientUpdateSourceControlResponse{}, err
	}
	return result, nil
}

// Validate - Validate if a resource can be created.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// validateRequest - Request with the resources to validate.
// options - SiteManagementClientValidateOptions contains the optional parameters for the SiteManagementClient.Validate method.
func (client *SiteManagementClient) Validate(ctx context.Context, resourceGroupName string, validateRequest ValidateRequest, options *SiteManagementClientValidateOptions) (SiteManagementClientValidateResponse, error) {
	req, err := client.validateCreateRequest(ctx, resourceGroupName, validateRequest, options)
	if err != nil {
		return SiteManagementClientValidateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return SiteManagementClientValidateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return SiteManagementClientValidateResponse{}, runtime.NewResponseError(resp)
	}
	return client.validateHandleResponse(resp)
}

// validateCreateRequest creates the Validate request.
func (client *SiteManagementClient) validateCreateRequest(ctx context.Context, resourceGroupName string, validateRequest ValidateRequest, options *SiteManagementClientValidateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/validate"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, validateRequest)
}

// validateHandleResponse handles the Validate response.
func (client *SiteManagementClient) validateHandleResponse(resp *http.Response) (SiteManagementClientValidateResponse, error) {
	result := SiteManagementClientValidateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ValidateResponse); err != nil {
		return SiteManagementClientValidateResponse{}, err
	}
	return result, nil
}

// ValidateContainerSettings - Validate if the container settings are correct.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// options - SiteManagementClientValidateContainerSettingsOptions contains the optional parameters for the SiteManagementClient.ValidateContainerSettings
// method.
func (client *SiteManagementClient) ValidateContainerSettings(ctx context.Context, resourceGroupName string, validateContainerSettingsRequest ValidateContainerSettingsRequest, options *SiteManagementClientValidateContainerSettingsOptions) (SiteManagementClientValidateContainerSettingsResponse, error) {
	req, err := client.validateContainerSettingsCreateRequest(ctx, resourceGroupName, validateContainerSettingsRequest, options)
	if err != nil {
		return SiteManagementClientValidateContainerSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return SiteManagementClientValidateContainerSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return SiteManagementClientValidateContainerSettingsResponse{}, runtime.NewResponseError(resp)
	}
	return client.validateContainerSettingsHandleResponse(resp)
}

// validateContainerSettingsCreateRequest creates the ValidateContainerSettings request.
func (client *SiteManagementClient) validateContainerSettingsCreateRequest(ctx context.Context, resourceGroupName string, validateContainerSettingsRequest ValidateContainerSettingsRequest, options *SiteManagementClientValidateContainerSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/validateContainerSettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, validateContainerSettingsRequest)
}

// validateContainerSettingsHandleResponse handles the ValidateContainerSettings response.
func (client *SiteManagementClient) validateContainerSettingsHandleResponse(resp *http.Response) (SiteManagementClientValidateContainerSettingsResponse, error) {
	result := SiteManagementClientValidateContainerSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return SiteManagementClientValidateContainerSettingsResponse{}, err
	}
	return result, nil
}

// ValidateMove - Validate whether a resource can be moved.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// resourceGroupName - Name of the resource group to which the resource belongs.
// moveResourceEnvelope - Object that represents the resource to move.
// options - SiteManagementClientValidateMoveOptions contains the optional parameters for the SiteManagementClient.ValidateMove
// method.
func (client *SiteManagementClient) ValidateMove(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, options *SiteManagementClientValidateMoveOptions) (SiteManagementClientValidateMoveResponse, error) {
	req, err := client.validateMoveCreateRequest(ctx, resourceGroupName, moveResourceEnvelope, options)
	if err != nil {
		return SiteManagementClientValidateMoveResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return SiteManagementClientValidateMoveResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return SiteManagementClientValidateMoveResponse{}, runtime.NewResponseError(resp)
	}
	return SiteManagementClientValidateMoveResponse{}, nil
}

// validateMoveCreateRequest creates the ValidateMove request.
func (client *SiteManagementClient) validateMoveCreateRequest(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, options *SiteManagementClientValidateMoveOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/validateMoveResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, moveResourceEnvelope)
}

// VerifyHostingEnvironmentVnet - Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
// Security Group rules.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-02-01
// parameters - VNET information
// options - SiteManagementClientVerifyHostingEnvironmentVnetOptions contains the optional parameters for the SiteManagementClient.VerifyHostingEnvironmentVnet
// method.
func (client *SiteManagementClient) VerifyHostingEnvironmentVnet(ctx context.Context, parameters VnetParameters, options *SiteManagementClientVerifyHostingEnvironmentVnetOptions) (SiteManagementClientVerifyHostingEnvironmentVnetResponse, error) {
	req, err := client.verifyHostingEnvironmentVnetCreateRequest(ctx, parameters, options)
	if err != nil {
		return SiteManagementClientVerifyHostingEnvironmentVnetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return SiteManagementClientVerifyHostingEnvironmentVnetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return SiteManagementClientVerifyHostingEnvironmentVnetResponse{}, runtime.NewResponseError(resp)
	}
	return client.verifyHostingEnvironmentVnetHandleResponse(resp)
}

// verifyHostingEnvironmentVnetCreateRequest creates the VerifyHostingEnvironmentVnet request.
func (client *SiteManagementClient) verifyHostingEnvironmentVnetCreateRequest(ctx context.Context, parameters VnetParameters, options *SiteManagementClientVerifyHostingEnvironmentVnetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/verifyHostingEnvironmentVnet"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// verifyHostingEnvironmentVnetHandleResponse handles the VerifyHostingEnvironmentVnet response.
func (client *SiteManagementClient) verifyHostingEnvironmentVnetHandleResponse(resp *http.Response) (SiteManagementClientVerifyHostingEnvironmentVnetResponse, error) {
	result := SiteManagementClientVerifyHostingEnvironmentVnetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetValidationFailureDetails); err != nil {
		return SiteManagementClientVerifyHostingEnvironmentVnetResponse{}, err
	}
	return result, nil
}
