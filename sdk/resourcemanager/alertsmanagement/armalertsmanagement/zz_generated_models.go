//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armalertsmanagement

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// ActionGroup - Action rule with action group configuration
type ActionGroup struct {
	ActionRuleProperties
	// REQUIRED; Action group to trigger if action rule matches
	ActionGroupID *string `json:"actionGroupId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ActionGroup.
func (a ActionGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ActionRuleProperties.marshalInternal(objectMap, ActionRuleTypeActionGroup)
	populate(objectMap, "actionGroupId", a.ActionGroupID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActionGroup.
func (a *ActionGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionGroupId":
			err = unpopulate(val, &a.ActionGroupID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ActionRuleProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ActionGroupsInformation - The Action Groups information, used by the alert rule.
type ActionGroupsInformation struct {
	// REQUIRED; The Action Group resource IDs.
	GroupIDs []*string `json:"groupIds,omitempty"`

	// An optional custom email subject to use in email notifications.
	CustomEmailSubject *string `json:"customEmailSubject,omitempty"`

	// An optional custom web-hook payload to use in web-hook notifications.
	CustomWebhookPayload *string `json:"customWebhookPayload,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ActionGroupsInformation.
func (a ActionGroupsInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customEmailSubject", a.CustomEmailSubject)
	populate(objectMap, "customWebhookPayload", a.CustomWebhookPayload)
	populate(objectMap, "groupIds", a.GroupIDs)
	return json.Marshal(objectMap)
}

// ActionRule - Action rule object containing target scope, conditions and suppression logic
type ActionRule struct {
	ManagedResource
	// action rule properties
	Properties ActionRulePropertiesClassification `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ActionRule.
func (a ActionRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ManagedResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActionRule.
func (a *ActionRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			a.Properties, err = unmarshalActionRulePropertiesClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ManagedResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ActionRulePropertiesClassification provides polymorphic access to related types.
// Call the interface's GetActionRuleProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ActionGroup, *ActionRuleProperties, *Diagnostics, *Suppression
type ActionRulePropertiesClassification interface {
	// GetActionRuleProperties returns the ActionRuleProperties content of the underlying type.
	GetActionRuleProperties() *ActionRuleProperties
}

// ActionRuleProperties - Action rule properties defining scope, conditions, suppression logic for action rule
type ActionRuleProperties struct {
	// REQUIRED; Indicates type of action rule
	Type *ActionRuleType `json:"type,omitempty"`

	// conditions on which alerts will be filtered
	Conditions *Conditions `json:"conditions,omitempty"`

	// Description of action rule
	Description *string `json:"description,omitempty"`

	// scope on which action rule will apply
	Scope *Scope `json:"scope,omitempty"`

	// Indicates if the given action rule is enabled or disabled
	Status *ActionRuleStatus `json:"status,omitempty"`

	// READ-ONLY; Creation time of action rule. Date-Time in ISO-8601 format.
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; Created by user name.
	CreatedBy *string `json:"createdBy,omitempty" azure:"ro"`

	// READ-ONLY; Last updated time of action rule. Date-Time in ISO-8601 format.
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty" azure:"ro"`

	// READ-ONLY; Last modified by user name.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty" azure:"ro"`
}

// GetActionRuleProperties implements the ActionRulePropertiesClassification interface for type ActionRuleProperties.
func (a *ActionRuleProperties) GetActionRuleProperties() *ActionRuleProperties { return a }

// UnmarshalJSON implements the json.Unmarshaller interface for type ActionRuleProperties.
func (a *ActionRuleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a ActionRuleProperties) marshalInternal(objectMap map[string]interface{}, discValue ActionRuleType) {
	populate(objectMap, "conditions", a.Conditions)
	populate(objectMap, "createdAt", (*timeRFC3339)(a.CreatedAt))
	populate(objectMap, "createdBy", a.CreatedBy)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "lastModifiedAt", (*timeRFC3339)(a.LastModifiedAt))
	populate(objectMap, "lastModifiedBy", a.LastModifiedBy)
	populate(objectMap, "scope", a.Scope)
	populate(objectMap, "status", a.Status)
	a.Type = &discValue
	objectMap["type"] = a.Type
}

func (a *ActionRuleProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "conditions":
			err = unpopulate(val, &a.Conditions)
			delete(rawMsg, key)
		case "createdAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.CreatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &a.CreatedBy)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "lastModifiedAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.LastModifiedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &a.LastModifiedBy)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &a.Scope)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &a.Status)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ActionRulesCreateUpdateOptions contains the optional parameters for the ActionRules.CreateUpdate method.
type ActionRulesCreateUpdateOptions struct {
	// placeholder for future optional parameters
}

// ActionRulesDeleteOptions contains the optional parameters for the ActionRules.Delete method.
type ActionRulesDeleteOptions struct {
	// placeholder for future optional parameters
}

// ActionRulesGetByNameOptions contains the optional parameters for the ActionRules.GetByName method.
type ActionRulesGetByNameOptions struct {
	// placeholder for future optional parameters
}

// ActionRulesList - List of action rules
type ActionRulesList struct {
	// URL to fetch the next set of action rules
	NextLink *string `json:"nextLink,omitempty"`

	// List of action rules
	Value []*ActionRule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ActionRulesList.
func (a ActionRulesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// ActionRulesListByResourceGroupOptions contains the optional parameters for the ActionRules.ListByResourceGroup method.
type ActionRulesListByResourceGroupOptions struct {
	// filter by action group configured as part of action rule
	ActionGroup *string
	// filter by alert rule id
	AlertRuleID *string
	// filter by alert rule description
	Description *string
	// filter by impacted/target scope (provide comma separated list for multiple scopes). The value should be an well constructed ARM id of the scope.
	ImpactedScope *string
	// Filter by monitor service which generates the alert instance. Default value is select all.
	MonitorService *MonitorService
	// filter by action rule name
	Name *string
	// Filter by severity. Default value is select all.
	Severity *Severity
	// Filter by target resource( which is full ARM ID) Default value is select all.
	TargetResource *string
	// Filter by target resource group name. Default value is select all.
	TargetResourceGroup *string
	// Filter by target resource type. Default value is select all.
	TargetResourceType *string
}

// ActionRulesListBySubscriptionOptions contains the optional parameters for the ActionRules.ListBySubscription method.
type ActionRulesListBySubscriptionOptions struct {
	// filter by action group configured as part of action rule
	ActionGroup *string
	// filter by alert rule id
	AlertRuleID *string
	// filter by alert rule description
	Description *string
	// filter by impacted/target scope (provide comma separated list for multiple scopes). The value should be an well constructed ARM id of the scope.
	ImpactedScope *string
	// Filter by monitor service which generates the alert instance. Default value is select all.
	MonitorService *MonitorService
	// filter by action rule name
	Name *string
	// Filter by severity. Default value is select all.
	Severity *Severity
	// Filter by target resource( which is full ARM ID) Default value is select all.
	TargetResource *string
	// Filter by target resource group name. Default value is select all.
	TargetResourceGroup *string
	// Filter by target resource type. Default value is select all.
	TargetResourceType *string
}

// ActionRulesUpdateOptions contains the optional parameters for the ActionRules.Update method.
type ActionRulesUpdateOptions struct {
	// placeholder for future optional parameters
}

// Alert - An alert created in alert management service.
type Alert struct {
	Resource
	// Alert property bag
	Properties *AlertProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Alert.
func (a Alert) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Alert.
func (a *Alert) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AlertModification - Alert Modification details
type AlertModification struct {
	Resource
	// Properties of the alert modification item.
	Properties *AlertModificationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertModification.
func (a AlertModification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertModification.
func (a *AlertModification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AlertModificationItem - Alert modification item.
type AlertModificationItem struct {
	// Modification comments
	Comments *string `json:"comments,omitempty"`

	// Description of the modification
	Description *string `json:"description,omitempty"`

	// Reason for the modification
	ModificationEvent *AlertModificationEvent `json:"modificationEvent,omitempty"`

	// Modified date and time
	ModifiedAt *string `json:"modifiedAt,omitempty"`

	// Modified user details (Principal client name)
	ModifiedBy *string `json:"modifiedBy,omitempty"`

	// New value
	NewValue *string `json:"newValue,omitempty"`

	// Old value
	OldValue *string `json:"oldValue,omitempty"`
}

// AlertModificationProperties - Properties of the alert modification item.
type AlertModificationProperties struct {
	// Modification details
	Modifications []*AlertModificationItem `json:"modifications,omitempty"`

	// READ-ONLY; Unique Id of the alert for which the history is being retrieved
	AlertID *string `json:"alertId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertModificationProperties.
func (a AlertModificationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertId", a.AlertID)
	populate(objectMap, "modifications", a.Modifications)
	return json.Marshal(objectMap)
}

// AlertProperties - Alert property bag
type AlertProperties struct {
	// This object contains consistent fields across different monitor services.
	Essentials *Essentials `json:"essentials,omitempty"`

	// READ-ONLY; Any object
	Context map[string]interface{} `json:"context,omitempty" azure:"ro"`

	// READ-ONLY; Any object
	EgressConfig map[string]interface{} `json:"egressConfig,omitempty" azure:"ro"`
}

// AlertRule - The alert rule information
type AlertRule struct {
	AzureResource
	// The properties of the alert rule.
	Properties *AlertRuleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertRule.
func (a AlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.AzureResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// AlertRulePatchObject - The alert rule patch information
type AlertRulePatchObject struct {
	// The properties of the alert rule.
	Properties *AlertRulePatchProperties `json:"properties,omitempty"`

	// The resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertRulePatchObject.
func (a AlertRulePatchObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// AlertRulePatchProperties - The alert rule properties.
type AlertRulePatchProperties struct {
	// The alert rule actions.
	ActionGroups *ActionGroupsInformation `json:"actionGroups,omitempty"`

	// The alert rule description.
	Description *string `json:"description,omitempty"`

	// The alert rule frequency in ISO8601 format. The time granularity must be in minutes and minimum value is 5 minutes.
	Frequency *string `json:"frequency,omitempty"`

	// The alert rule severity.
	Severity *Severity `json:"severity,omitempty"`

	// The alert rule state.
	State *AlertRuleState `json:"state,omitempty"`

	// The alert rule throttling information.
	Throttling *ThrottlingInformation `json:"throttling,omitempty"`
}

// AlertRuleProperties - The alert rule properties.
type AlertRuleProperties struct {
	// REQUIRED; The alert rule actions.
	ActionGroups *ActionGroupsInformation `json:"actionGroups,omitempty"`

	// REQUIRED; The alert rule's detector.
	Detector *Detector `json:"detector,omitempty"`

	// REQUIRED; The alert rule frequency in ISO8601 format. The time granularity must be in minutes and minimum value is 5 minutes.
	Frequency *string `json:"frequency,omitempty"`

	// REQUIRED; The alert rule resources scope.
	Scope []*string `json:"scope,omitempty"`

	// REQUIRED; The alert rule severity.
	Severity *Severity `json:"severity,omitempty"`

	// REQUIRED; The alert rule state.
	State *AlertRuleState `json:"state,omitempty"`

	// The alert rule description.
	Description *string `json:"description,omitempty"`

	// The alert rule throttling information.
	Throttling *ThrottlingInformation `json:"throttling,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertRuleProperties.
func (a AlertRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actionGroups", a.ActionGroups)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "detector", a.Detector)
	populate(objectMap, "frequency", a.Frequency)
	populate(objectMap, "scope", a.Scope)
	populate(objectMap, "severity", a.Severity)
	populate(objectMap, "state", a.State)
	populate(objectMap, "throttling", a.Throttling)
	return json.Marshal(objectMap)
}

// AlertRulesList - List of Smart Detector alert rules.
type AlertRulesList struct {
	// The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// List of Smart Detector alert rules.
	Value []*AlertRule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertRulesList.
func (a AlertRulesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AlertsChangeStateOptions contains the optional parameters for the Alerts.ChangeState method.
type AlertsChangeStateOptions struct {
	// placeholder for future optional parameters
}

// AlertsGetAllOptions contains the optional parameters for the Alerts.GetAll method.
type AlertsGetAllOptions struct {
	// Filter by specific alert rule. Default value is to select all.
	AlertRule *string
	// Filter by state of the alert instance. Default value is to select all.
	AlertState *AlertState
	// Filter by custom time range in the format <start-time>/<end-time> where time is in (ISO-8601 format)'. Permissible values is within 30 days from query
	// time. Either timeRange or customTimeRange could be used but not both. Default is none.
	CustomTimeRange *string
	// Include context which has contextual data specific to the monitor service. Default value is false'
	IncludeContext *bool
	// Include egress config which would be used for displaying the content in portal. Default value is 'false'.
	IncludeEgressConfig *bool
	// Filter by monitor condition which is either 'Fired' or 'Resolved'. Default value is to select all.
	MonitorCondition *MonitorCondition
	// Filter by monitor service which generates the alert instance. Default value is select all.
	MonitorService *MonitorService
	// Determines number of alerts returned per page in response. Permissible value is between 1 to 250. When the "includeContent" filter is selected, maximum
	// value allowed is 25. Default value is 25.
	PageCount *int32
	// This filter allows to selection of the fields(comma separated) which would be part of the essential section. This would allow to project only the required
	// fields rather than getting entire content. Default is to fetch all the fields in the essentials section.
	Select *string
	// Filter by severity. Default value is select all.
	Severity *Severity
	// Filter the alerts list by the Smart Group Id. Default value is none.
	SmartGroupID *string
	// Sort the query results by input field, Default value is 'lastModifiedDateTime'.
	SortBy *AlertsSortByFields
	// Sort the query results order in either ascending or descending. Default value is 'desc' for time fields and 'asc' for others.
	SortOrder *Enum11
	// Filter by target resource( which is full ARM ID) Default value is select all.
	TargetResource *string
	// Filter by target resource group name. Default value is select all.
	TargetResourceGroup *string
	// Filter by target resource type. Default value is select all.
	TargetResourceType *string
	// Filter by time range by below listed values. Default value is 1 day.
	TimeRange *TimeRange
}

// AlertsGetByIDOptions contains the optional parameters for the Alerts.GetByID method.
type AlertsGetByIDOptions struct {
	// placeholder for future optional parameters
}

// AlertsGetHistoryOptions contains the optional parameters for the Alerts.GetHistory method.
type AlertsGetHistoryOptions struct {
	// placeholder for future optional parameters
}

// AlertsGetSummaryOptions contains the optional parameters for the Alerts.GetSummary method.
type AlertsGetSummaryOptions struct {
	// Filter by specific alert rule. Default value is to select all.
	AlertRule *string
	// Filter by state of the alert instance. Default value is to select all.
	AlertState *AlertState
	// Filter by custom time range in the format <start-time>/<end-time> where time is in (ISO-8601 format)'. Permissible values is within 30 days from query
	// time. Either timeRange or customTimeRange could be used but not both. Default is none.
	CustomTimeRange *string
	// Include count of the SmartGroups as part of the summary. Default value is 'false'.
	IncludeSmartGroupsCount *bool
	// Filter by monitor condition which is either 'Fired' or 'Resolved'. Default value is to select all.
	MonitorCondition *MonitorCondition
	// Filter by monitor service which generates the alert instance. Default value is select all.
	MonitorService *MonitorService
	// Filter by severity. Default value is select all.
	Severity *Severity
	// Filter by target resource( which is full ARM ID) Default value is select all.
	TargetResource *string
	// Filter by target resource group name. Default value is select all.
	TargetResourceGroup *string
	// Filter by target resource type. Default value is select all.
	TargetResourceType *string
	// Filter by time range by below listed values. Default value is 1 day.
	TimeRange *TimeRange
}

// AlertsList - List the alerts.
type AlertsList struct {
	// URL to fetch the next set of alerts.
	NextLink *string `json:"nextLink,omitempty"`

	// List of alerts
	Value []*Alert `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertsList.
func (a AlertsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AlertsMetaData - alert meta data information.
type AlertsMetaData struct {
	// alert meta data property bag
	Properties AlertsMetaDataPropertiesClassification `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertsMetaData.
func (a AlertsMetaData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertsMetaData.
func (a *AlertsMetaData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			a.Properties, err = unmarshalAlertsMetaDataPropertiesClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AlertsMetaDataOptions contains the optional parameters for the Alerts.MetaData method.
type AlertsMetaDataOptions struct {
	// placeholder for future optional parameters
}

// AlertsMetaDataPropertiesClassification provides polymorphic access to related types.
// Call the interface's GetAlertsMetaDataProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AlertsMetaDataProperties, *MonitorServiceList
type AlertsMetaDataPropertiesClassification interface {
	// GetAlertsMetaDataProperties returns the AlertsMetaDataProperties content of the underlying type.
	GetAlertsMetaDataProperties() *AlertsMetaDataProperties
}

// AlertsMetaDataProperties - alert meta data property bag
type AlertsMetaDataProperties struct {
	// REQUIRED; Identification of the information to be retrieved by API call
	MetadataIdentifier *MetadataIdentifier `json:"metadataIdentifier,omitempty"`
}

// GetAlertsMetaDataProperties implements the AlertsMetaDataPropertiesClassification interface for type AlertsMetaDataProperties.
func (a *AlertsMetaDataProperties) GetAlertsMetaDataProperties() *AlertsMetaDataProperties { return a }

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertsMetaDataProperties.
func (a *AlertsMetaDataProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AlertsMetaDataProperties) marshalInternal(objectMap map[string]interface{}, discValue MetadataIdentifier) {
	a.MetadataIdentifier = &discValue
	objectMap["metadataIdentifier"] = a.MetadataIdentifier
}

func (a *AlertsMetaDataProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "metadataIdentifier":
			err = unpopulate(val, &a.MetadataIdentifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AlertsSummary - Summary of alerts based on the input filters and 'groupby' parameters.
type AlertsSummary struct {
	Resource
	// Group the result set.
	Properties *AlertsSummaryGroup `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertsSummary.
func (a AlertsSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertsSummary.
func (a *AlertsSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AlertsSummaryGroup - Group the result set.
type AlertsSummaryGroup struct {
	// Name of the field aggregated
	Groupedby *string `json:"groupedby,omitempty"`

	// Total count of the smart groups.
	SmartGroupsCount *int32 `json:"smartGroupsCount,omitempty"`

	// Total count of the result set.
	Total *int32 `json:"total,omitempty"`

	// List of the items
	Values []*AlertsSummaryGroupItem `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertsSummaryGroup.
func (a AlertsSummaryGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupedby", a.Groupedby)
	populate(objectMap, "smartGroupsCount", a.SmartGroupsCount)
	populate(objectMap, "total", a.Total)
	populate(objectMap, "values", a.Values)
	return json.Marshal(objectMap)
}

// AlertsSummaryGroupItem - Alerts summary group item
type AlertsSummaryGroupItem struct {
	// Count of the aggregated field
	Count *int32 `json:"count,omitempty"`

	// Name of the field aggregated
	Groupedby *string `json:"groupedby,omitempty"`

	// Value of the aggregated field
	Name *string `json:"name,omitempty"`

	// List of the items
	Values []*AlertsSummaryGroupItem `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertsSummaryGroupItem.
func (a AlertsSummaryGroupItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "count", a.Count)
	populate(objectMap, "groupedby", a.Groupedby)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "values", a.Values)
	return json.Marshal(objectMap)
}

// AzureResource - An Azure resource object
type AzureResource struct {
	// The resource location.
	Location *string `json:"location,omitempty"`

	// The resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureResource.
func (a AzureResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (a AzureResource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
}

// Condition - condition to trigger an action rule
type Condition struct {
	// operator for a given condition
	Operator *Operator `json:"operator,omitempty"`

	// list of values to match for a given condition.
	Values []*string `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Condition.
func (c Condition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "operator", c.Operator)
	populate(objectMap, "values", c.Values)
	return json.Marshal(objectMap)
}

// Conditions in alert instance to be matched for a given action rule. Default value is all. Multiple values could be provided with comma separation.
type Conditions struct {
	// filter alerts by alert context (payload)
	AlertContext *Condition `json:"alertContext,omitempty"`

	// filter alerts by alert rule id
	AlertRuleID *Condition `json:"alertRuleId,omitempty"`

	// filter alerts by alert rule description
	Description *Condition `json:"description,omitempty"`

	// filter alerts by monitor condition
	MonitorCondition *Condition `json:"monitorCondition,omitempty"`

	// filter alerts by monitor service
	MonitorService *Condition `json:"monitorService,omitempty"`

	// filter alerts by severity
	Severity *Condition `json:"severity,omitempty"`

	// filter alerts by target resource type
	TargetResourceType *Condition `json:"targetResourceType,omitempty"`
}

// Detector - The detector information. By default this is not populated, unless it's specified in expandDetector
type Detector struct {
	// REQUIRED; The detector id.
	ID *string `json:"id,omitempty"`

	// The Smart Detector description. By default this is not populated, unless it's specified in expandDetector
	Description *string `json:"description,omitempty"`

	// The Smart Detector image path. By default this is not populated, unless it's specified in expandDetector
	ImagePaths []*string `json:"imagePaths,omitempty"`

	// The Smart Detector name. By default this is not populated, unless it's specified in expandDetector
	Name *string `json:"name,omitempty"`

	// The detector's parameters.'
	Parameters map[string]map[string]interface{} `json:"parameters,omitempty"`

	// The Smart Detector supported resource types. By default this is not populated, unless it's specified in expandDetector
	SupportedResourceTypes []*string `json:"supportedResourceTypes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Detector.
func (d Detector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", d.Description)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "imagePaths", d.ImagePaths)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "parameters", d.Parameters)
	populate(objectMap, "supportedResourceTypes", d.SupportedResourceTypes)
	return json.Marshal(objectMap)
}

// Diagnostics - Action rule with diagnostics configuration
type Diagnostics struct {
	ActionRuleProperties
}

// MarshalJSON implements the json.Marshaller interface for type Diagnostics.
func (d Diagnostics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ActionRuleProperties.marshalInternal(objectMap, ActionRuleTypeDiagnostics)
	return json.Marshal(objectMap)
}

// ErrorResponse - An error response from the service.
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// Details of error response.
	InnerError *ErrorResponseBody `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// ErrorResponseAutoGenerated - An error response from the service.
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponseAutoGenerated struct {
	raw string
	// Details of error response.
	InnerError *ErrorResponseBodyAutoGenerated `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponseAutoGenerated.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponseAutoGenerated) Error() string {
	return e.raw
}

// ErrorResponseAutoGenerated2 - An error response from the service.
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponseAutoGenerated2 struct {
	raw string
	// Details of error response.
	InnerError *ErrorResponseBodyAutoGenerated2 `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponseAutoGenerated2.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponseAutoGenerated2) Error() string {
	return e.raw
}

// ErrorResponseBody - Details of error response.
type ErrorResponseBody struct {
	// Error code, intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// A list of additional details about the error.
	Details []*ErrorResponseBody `json:"details,omitempty"`

	// Description of the error, intended for display in user interface.
	Message *string `json:"message,omitempty"`

	// Target of the particular error, for example name of the property.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponseBody.
func (e ErrorResponseBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ErrorResponseBodyAutoGenerated - Details of error response.
type ErrorResponseBodyAutoGenerated struct {
	// Error code, intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// A list of additional details about the error.
	Details []*ErrorResponseBodyAutoGenerated `json:"details,omitempty"`

	// Description of the error, intended for display in user interface.
	Message *string `json:"message,omitempty"`

	// Target of the particular error, for example name of the property.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponseBodyAutoGenerated.
func (e ErrorResponseBodyAutoGenerated) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ErrorResponseBodyAutoGenerated2 - Details of error response.
type ErrorResponseBodyAutoGenerated2 struct {
	// Error code, intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// A list of additional details about the error.
	Details []*ErrorResponseBodyAutoGenerated2 `json:"details,omitempty"`

	// Description of the error, intended for display in user interface.
	Message *string `json:"message,omitempty"`

	// Target of the particular error, for example name of the property.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponseBodyAutoGenerated2.
func (e ErrorResponseBodyAutoGenerated2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// Essentials - This object contains consistent fields across different monitor services.
type Essentials struct {
	// Target ARM resource, on which alert got created.
	TargetResource *string `json:"targetResource,omitempty"`

	// Resource group of target ARM resource, on which alert got created.
	TargetResourceGroup *string `json:"targetResourceGroup,omitempty"`

	// Name of the target ARM resource name, on which alert got created.
	TargetResourceName *string `json:"targetResourceName,omitempty"`

	// Resource type of target ARM resource, on which alert got created.
	TargetResourceType *string `json:"targetResourceType,omitempty"`

	// READ-ONLY; Rule(monitor) which fired alert instance. Depending on the monitor service, this would be ARM id or name of the rule.
	AlertRule *string `json:"alertRule,omitempty" azure:"ro"`

	// READ-ONLY; Alert object state, which can be modified by the user.
	AlertState *AlertState `json:"alertState,omitempty" azure:"ro"`

	// READ-ONLY; Last modification time(ISO-8601 format) of alert instance.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty" azure:"ro"`

	// READ-ONLY; User who last modified the alert, in case of monitor service updates user would be 'system', otherwise name of the user.
	LastModifiedUserName *string `json:"lastModifiedUserName,omitempty" azure:"ro"`

	// READ-ONLY; Condition of the rule at the monitor service. It represents whether the underlying conditions have crossed the defined alert rule thresholds.
	MonitorCondition *MonitorCondition `json:"monitorCondition,omitempty" azure:"ro"`

	// READ-ONLY; Resolved time(ISO-8601 format) of alert instance. This will be updated when monitor service resolves the alert instance because the rule condition
	// is no longer met.
	MonitorConditionResolvedDateTime *time.Time `json:"monitorConditionResolvedDateTime,omitempty" azure:"ro"`

	// READ-ONLY; Monitor service on which the rule(monitor) is set.
	MonitorService *MonitorService `json:"monitorService,omitempty" azure:"ro"`

	// READ-ONLY; Severity of alert Sev0 being highest and Sev4 being lowest.
	Severity *Severity `json:"severity,omitempty" azure:"ro"`

	// READ-ONLY; The type of signal the alert is based on, which could be metrics, logs or activity logs.
	SignalType *SignalType `json:"signalType,omitempty" azure:"ro"`

	// READ-ONLY; Unique Id of the smart group
	SmartGroupID *string `json:"smartGroupId,omitempty" azure:"ro"`

	// READ-ONLY; Verbose reason describing the reason why this alert instance is added to a smart group
	SmartGroupingReason *string `json:"smartGroupingReason,omitempty" azure:"ro"`

	// READ-ONLY; Unique Id created by monitor service for each alert instance. This could be used to track the issue at the monitor service, in case of Nagios,
	// Zabbix, SCOM etc.
	SourceCreatedID *string `json:"sourceCreatedId,omitempty" azure:"ro"`

	// READ-ONLY; Creation time(ISO-8601 format) of alert instance.
	StartDateTime *time.Time `json:"startDateTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Essentials.
func (e Essentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertRule", e.AlertRule)
	populate(objectMap, "alertState", e.AlertState)
	populate(objectMap, "lastModifiedDateTime", (*timeRFC3339)(e.LastModifiedDateTime))
	populate(objectMap, "lastModifiedUserName", e.LastModifiedUserName)
	populate(objectMap, "monitorCondition", e.MonitorCondition)
	populate(objectMap, "monitorConditionResolvedDateTime", (*timeRFC3339)(e.MonitorConditionResolvedDateTime))
	populate(objectMap, "monitorService", e.MonitorService)
	populate(objectMap, "severity", e.Severity)
	populate(objectMap, "signalType", e.SignalType)
	populate(objectMap, "smartGroupId", e.SmartGroupID)
	populate(objectMap, "smartGroupingReason", e.SmartGroupingReason)
	populate(objectMap, "sourceCreatedId", e.SourceCreatedID)
	populate(objectMap, "startDateTime", (*timeRFC3339)(e.StartDateTime))
	populate(objectMap, "targetResource", e.TargetResource)
	populate(objectMap, "targetResourceGroup", e.TargetResourceGroup)
	populate(objectMap, "targetResourceName", e.TargetResourceName)
	populate(objectMap, "targetResourceType", e.TargetResourceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Essentials.
func (e *Essentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertRule":
			err = unpopulate(val, &e.AlertRule)
			delete(rawMsg, key)
		case "alertState":
			err = unpopulate(val, &e.AlertState)
			delete(rawMsg, key)
		case "lastModifiedDateTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			e.LastModifiedDateTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "lastModifiedUserName":
			err = unpopulate(val, &e.LastModifiedUserName)
			delete(rawMsg, key)
		case "monitorCondition":
			err = unpopulate(val, &e.MonitorCondition)
			delete(rawMsg, key)
		case "monitorConditionResolvedDateTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			e.MonitorConditionResolvedDateTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "monitorService":
			err = unpopulate(val, &e.MonitorService)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &e.Severity)
			delete(rawMsg, key)
		case "signalType":
			err = unpopulate(val, &e.SignalType)
			delete(rawMsg, key)
		case "smartGroupId":
			err = unpopulate(val, &e.SmartGroupID)
			delete(rawMsg, key)
		case "smartGroupingReason":
			err = unpopulate(val, &e.SmartGroupingReason)
			delete(rawMsg, key)
		case "sourceCreatedId":
			err = unpopulate(val, &e.SourceCreatedID)
			delete(rawMsg, key)
		case "startDateTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			e.StartDateTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "targetResource":
			err = unpopulate(val, &e.TargetResource)
			delete(rawMsg, key)
		case "targetResourceGroup":
			err = unpopulate(val, &e.TargetResourceGroup)
			delete(rawMsg, key)
		case "targetResourceName":
			err = unpopulate(val, &e.TargetResourceName)
			delete(rawMsg, key)
		case "targetResourceType":
			err = unpopulate(val, &e.TargetResourceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedResource - An azure managed resource object
type ManagedResource struct {
	Resource
	// REQUIRED; Resource location
	Location *string `json:"location,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedResource.
func (m ManagedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedResource.
func (m *ManagedResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m ManagedResource) marshalInternal(objectMap map[string]interface{}) {
	m.Resource.marshalInternal(objectMap)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "tags", m.Tags)
}

func (m *ManagedResource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			err = unpopulate(val, &m.Location)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &m.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MonitorServiceDetails - Details of a monitor service
type MonitorServiceDetails struct {
	// Monitor service display name
	DisplayName *string `json:"displayName,omitempty"`

	// Monitor service name
	Name *string `json:"name,omitempty"`
}

// MonitorServiceList - Monitor service details
type MonitorServiceList struct {
	AlertsMetaDataProperties
	// REQUIRED; Array of operations
	Data []*MonitorServiceDetails `json:"data,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MonitorServiceList.
func (m MonitorServiceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.AlertsMetaDataProperties.marshalInternal(objectMap, MetadataIdentifierMonitorServiceList)
	populate(objectMap, "data", m.Data)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MonitorServiceList.
func (m *MonitorServiceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "data":
			err = unpopulate(val, &m.Data)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.AlertsMetaDataProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// Operation provided by provider
type Operation struct {
	// Properties of the operation
	Display *OperationDisplay `json:"display,omitempty"`

	// Name of the operation
	Name *string `json:"name,omitempty"`
}

// OperationDisplay - Properties of the operation
type OperationDisplay struct {
	// Description of the operation
	Description *string `json:"description,omitempty"`

	// Operation name
	Operation *string `json:"operation,omitempty"`

	// Provider name
	Provider *string `json:"provider,omitempty"`

	// Resource name
	Resource *string `json:"resource,omitempty"`
}

// OperationsList - Lists the operations available in the AlertsManagement RP.
type OperationsList struct {
	// REQUIRED; Array of operations
	Value []*Operation `json:"value,omitempty"`

	// URL to fetch the next set of alerts.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationsList.
func (o OperationsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// PatchObject - Data contract for patch
type PatchObject struct {
	// properties supported by patch operation
	Properties *PatchProperties `json:"properties,omitempty"`

	// tags to be updated
	Tags map[string]interface{} `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PatchObject.
func (p PatchObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// PatchProperties - Action rule properties supported by patch
type PatchProperties struct {
	// Indicates if the given action rule is enabled or disabled
	Status *ActionRuleStatus `json:"status,omitempty"`
}

// Resource - An azure resource object
type Resource struct {
	// READ-ONLY; Azure resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Azure resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Azure resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Resource.
func (r *Resource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "type", r.Type)
}

func (r *Resource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &r.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &r.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Scope - Target scope for a given action rule. By default scope will be the subscription. User can also provide list of resource groups or list of resources
// from the scope subscription as well.
type Scope struct {
	// type of target scope
	ScopeType *ScopeType `json:"scopeType,omitempty"`

	// list of ARM IDs of the given scope type which will be the target of the given action rule.
	Values []*string `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Scope.
func (s Scope) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "scopeType", s.ScopeType)
	populate(objectMap, "values", s.Values)
	return json.Marshal(objectMap)
}

// SmartDetectorAlertRulesCreateOrUpdateOptions contains the optional parameters for the SmartDetectorAlertRules.CreateOrUpdate method.
type SmartDetectorAlertRulesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SmartDetectorAlertRulesDeleteOptions contains the optional parameters for the SmartDetectorAlertRules.Delete method.
type SmartDetectorAlertRulesDeleteOptions struct {
	// placeholder for future optional parameters
}

// SmartDetectorAlertRulesGetOptions contains the optional parameters for the SmartDetectorAlertRules.Get method.
type SmartDetectorAlertRulesGetOptions struct {
	// Indicates if Smart Detector should be expanded.
	ExpandDetector *bool
}

// SmartDetectorAlertRulesListByResourceGroupOptions contains the optional parameters for the SmartDetectorAlertRules.ListByResourceGroup method.
type SmartDetectorAlertRulesListByResourceGroupOptions struct {
	// Indicates if Smart Detector should be expanded.
	ExpandDetector *bool
}

// SmartDetectorAlertRulesListOptions contains the optional parameters for the SmartDetectorAlertRules.List method.
type SmartDetectorAlertRulesListOptions struct {
	// Indicates if Smart Detector should be expanded.
	ExpandDetector *bool
}

// SmartDetectorAlertRulesPatchOptions contains the optional parameters for the SmartDetectorAlertRules.Patch method.
type SmartDetectorAlertRulesPatchOptions struct {
	// placeholder for future optional parameters
}

// SmartDetectorErrorResponse - Describe the format of an Error response.
// Implements the error and azcore.HTTPResponse interfaces.
type SmartDetectorErrorResponse struct {
	raw string
	// Error code
	Code *string `json:"code,omitempty"`

	// Error message indicating why the operation failed.
	Message *string `json:"message,omitempty"`
}

// Error implements the error interface for type SmartDetectorErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e SmartDetectorErrorResponse) Error() string {
	return e.raw
}

// SmartGroup - Set of related alerts grouped together smartly by AMS.
type SmartGroup struct {
	Resource
	// Properties of smart group.
	Properties *SmartGroupProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SmartGroup.
func (s SmartGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SmartGroup.
func (s *SmartGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SmartGroupAggregatedProperty - Aggregated property of each type
type SmartGroupAggregatedProperty struct {
	// Total number of items of type.
	Count *int32 `json:"count,omitempty"`

	// Name of the type.
	Name *string `json:"name,omitempty"`
}

// SmartGroupModification - Alert Modification details
type SmartGroupModification struct {
	Resource
	// Properties of the smartGroup modification item.
	Properties *SmartGroupModificationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SmartGroupModification.
func (s SmartGroupModification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SmartGroupModification.
func (s *SmartGroupModification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SmartGroupModificationItem - smartGroup modification item.
type SmartGroupModificationItem struct {
	// Modification comments
	Comments *string `json:"comments,omitempty"`

	// Description of the modification
	Description *string `json:"description,omitempty"`

	// Reason for the modification
	ModificationEvent *SmartGroupModificationEvent `json:"modificationEvent,omitempty"`

	// Modified date and time
	ModifiedAt *string `json:"modifiedAt,omitempty"`

	// Modified user details (Principal client name)
	ModifiedBy *string `json:"modifiedBy,omitempty"`

	// New value
	NewValue *string `json:"newValue,omitempty"`

	// Old value
	OldValue *string `json:"oldValue,omitempty"`
}

// SmartGroupModificationProperties - Properties of the smartGroup modification item.
type SmartGroupModificationProperties struct {
	// Modification details
	Modifications []*SmartGroupModificationItem `json:"modifications,omitempty"`

	// URL to fetch the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; Unique Id of the smartGroup for which the history is being retrieved
	SmartGroupID *string `json:"smartGroupId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SmartGroupModificationProperties.
func (s SmartGroupModificationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "modifications", s.Modifications)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "smartGroupId", s.SmartGroupID)
	return json.Marshal(objectMap)
}

// SmartGroupProperties - Properties of smart group.
type SmartGroupProperties struct {
	// Summary of alertSeverities in the smart group
	AlertSeverities []*SmartGroupAggregatedProperty `json:"alertSeverities,omitempty"`

	// Summary of alertStates in the smart group
	AlertStates []*SmartGroupAggregatedProperty `json:"alertStates,omitempty"`

	// Total number of alerts in smart group
	AlertsCount *int32 `json:"alertsCount,omitempty"`

	// Summary of monitorConditions in the smart group
	MonitorConditions []*SmartGroupAggregatedProperty `json:"monitorConditions,omitempty"`

	// Summary of monitorServices in the smart group
	MonitorServices []*SmartGroupAggregatedProperty `json:"monitorServices,omitempty"`

	// The URI to fetch the next page of alerts. Call ListNext() with this URI to fetch the next page alerts.
	NextLink *string `json:"nextLink,omitempty"`

	// Summary of target resource groups in the smart group
	ResourceGroups []*SmartGroupAggregatedProperty `json:"resourceGroups,omitempty"`

	// Summary of target resource types in the smart group
	ResourceTypes []*SmartGroupAggregatedProperty `json:"resourceTypes,omitempty"`

	// Summary of target resources in the smart group
	Resources []*SmartGroupAggregatedProperty `json:"resources,omitempty"`

	// READ-ONLY; Last updated time of smart group. Date-Time in ISO-8601 format.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty" azure:"ro"`

	// READ-ONLY; Last modified by user name.
	LastModifiedUserName *string `json:"lastModifiedUserName,omitempty" azure:"ro"`

	// READ-ONLY; Severity of smart group is the highest(Sev0 >… > Sev4) severity of all the alerts in the group.
	Severity *Severity `json:"severity,omitempty" azure:"ro"`

	// READ-ONLY; Smart group state
	SmartGroupState *State `json:"smartGroupState,omitempty" azure:"ro"`

	// READ-ONLY; Creation time of smart group. Date-Time in ISO-8601 format.
	StartDateTime *time.Time `json:"startDateTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SmartGroupProperties.
func (s SmartGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertSeverities", s.AlertSeverities)
	populate(objectMap, "alertStates", s.AlertStates)
	populate(objectMap, "alertsCount", s.AlertsCount)
	populate(objectMap, "lastModifiedDateTime", (*timeRFC3339)(s.LastModifiedDateTime))
	populate(objectMap, "lastModifiedUserName", s.LastModifiedUserName)
	populate(objectMap, "monitorConditions", s.MonitorConditions)
	populate(objectMap, "monitorServices", s.MonitorServices)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "resourceGroups", s.ResourceGroups)
	populate(objectMap, "resourceTypes", s.ResourceTypes)
	populate(objectMap, "resources", s.Resources)
	populate(objectMap, "severity", s.Severity)
	populate(objectMap, "smartGroupState", s.SmartGroupState)
	populate(objectMap, "startDateTime", (*timeRFC3339)(s.StartDateTime))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SmartGroupProperties.
func (s *SmartGroupProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertSeverities":
			err = unpopulate(val, &s.AlertSeverities)
			delete(rawMsg, key)
		case "alertStates":
			err = unpopulate(val, &s.AlertStates)
			delete(rawMsg, key)
		case "alertsCount":
			err = unpopulate(val, &s.AlertsCount)
			delete(rawMsg, key)
		case "lastModifiedDateTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.LastModifiedDateTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "lastModifiedUserName":
			err = unpopulate(val, &s.LastModifiedUserName)
			delete(rawMsg, key)
		case "monitorConditions":
			err = unpopulate(val, &s.MonitorConditions)
			delete(rawMsg, key)
		case "monitorServices":
			err = unpopulate(val, &s.MonitorServices)
			delete(rawMsg, key)
		case "nextLink":
			err = unpopulate(val, &s.NextLink)
			delete(rawMsg, key)
		case "resourceGroups":
			err = unpopulate(val, &s.ResourceGroups)
			delete(rawMsg, key)
		case "resourceTypes":
			err = unpopulate(val, &s.ResourceTypes)
			delete(rawMsg, key)
		case "resources":
			err = unpopulate(val, &s.Resources)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &s.Severity)
			delete(rawMsg, key)
		case "smartGroupState":
			err = unpopulate(val, &s.SmartGroupState)
			delete(rawMsg, key)
		case "startDateTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.StartDateTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SmartGroupsChangeStateOptions contains the optional parameters for the SmartGroups.ChangeState method.
type SmartGroupsChangeStateOptions struct {
	// placeholder for future optional parameters
}

// SmartGroupsGetAllOptions contains the optional parameters for the SmartGroups.GetAll method.
type SmartGroupsGetAllOptions struct {
	// Filter by monitor condition which is either 'Fired' or 'Resolved'. Default value is to select all.
	MonitorCondition *MonitorCondition
	// Filter by monitor service which generates the alert instance. Default value is select all.
	MonitorService *MonitorService
	// Determines number of alerts returned per page in response. Permissible value is between 1 to 250. When the "includeContent" filter is selected, maximum
	// value allowed is 25. Default value is 25.
	PageCount *int32
	// Filter by severity. Default value is select all.
	Severity *Severity
	// Filter by state of the smart group. Default value is to select all.
	SmartGroupState *AlertState
	// Sort the query results by input field. Default value is sort by 'lastModifiedDateTime'.
	SortBy *SmartGroupsSortByFields
	// Sort the query results order in either ascending or descending. Default value is 'desc' for time fields and 'asc' for others.
	SortOrder *Enum11
	// Filter by target resource( which is full ARM ID) Default value is select all.
	TargetResource *string
	// Filter by target resource group name. Default value is select all.
	TargetResourceGroup *string
	// Filter by target resource type. Default value is select all.
	TargetResourceType *string
	// Filter by time range by below listed values. Default value is 1 day.
	TimeRange *TimeRange
}

// SmartGroupsGetByIDOptions contains the optional parameters for the SmartGroups.GetByID method.
type SmartGroupsGetByIDOptions struct {
	// placeholder for future optional parameters
}

// SmartGroupsGetHistoryOptions contains the optional parameters for the SmartGroups.GetHistory method.
type SmartGroupsGetHistoryOptions struct {
	// placeholder for future optional parameters
}

// SmartGroupsList - List the alerts.
type SmartGroupsList struct {
	// URL to fetch the next set of alerts.
	NextLink *string `json:"nextLink,omitempty"`

	// List of alerts
	Value []*SmartGroup `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SmartGroupsList.
func (s SmartGroupsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// Suppression - Action rule with suppression configuration
type Suppression struct {
	ActionRuleProperties
	// REQUIRED; suppression configuration for the action rule
	SuppressionConfig *SuppressionConfig `json:"suppressionConfig,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Suppression.
func (s Suppression) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ActionRuleProperties.marshalInternal(objectMap, ActionRuleTypeSuppression)
	populate(objectMap, "suppressionConfig", s.SuppressionConfig)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Suppression.
func (s *Suppression) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "suppressionConfig":
			err = unpopulate(val, &s.SuppressionConfig)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ActionRuleProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SuppressionConfig - Suppression logic for a given action rule
type SuppressionConfig struct {
	// REQUIRED; Specifies when the suppression should be applied
	RecurrenceType *SuppressionType `json:"recurrenceType,omitempty"`

	// suppression schedule configuration
	Schedule *SuppressionSchedule `json:"schedule,omitempty"`
}

// SuppressionSchedule - Schedule for a given suppression configuration.
type SuppressionSchedule struct {
	// End date for suppression
	EndDate *string `json:"endDate,omitempty"`

	// End date for suppression
	EndTime *string `json:"endTime,omitempty"`

	// Specifies the values for recurrence pattern
	RecurrenceValues []*int32 `json:"recurrenceValues,omitempty"`

	// Start date for suppression
	StartDate *string `json:"startDate,omitempty"`

	// Start time for suppression
	StartTime *string `json:"startTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SuppressionSchedule.
func (s SuppressionSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "endDate", s.EndDate)
	populate(objectMap, "endTime", s.EndTime)
	populate(objectMap, "recurrenceValues", s.RecurrenceValues)
	populate(objectMap, "startDate", s.StartDate)
	populate(objectMap, "startTime", s.StartTime)
	return json.Marshal(objectMap)
}

// ThrottlingInformation - Optional throttling information for the alert rule.
type ThrottlingInformation struct {
	// The required duration (in ISO8601 format) to wait before notifying on the alert rule again. The time granularity must be in minutes and minimum value
	// is 0 minutes
	Duration *string `json:"duration,omitempty"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
