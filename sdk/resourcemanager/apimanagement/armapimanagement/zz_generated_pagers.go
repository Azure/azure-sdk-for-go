//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armapimanagement

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// APIClientListByServicePager provides operations for iterating over paged responses.
type APIClientListByServicePager struct {
	client    *APIClient
	current   APIClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APICollection.NextLink == nil || len(*p.current.APICollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIClientListByServiceResponse page.
func (p *APIClientListByServicePager) PageResponse() APIClientListByServiceResponse {
	return p.current
}

// APIClientListByTagsPager provides operations for iterating over paged responses.
type APIClientListByTagsPager struct {
	client    *APIClient
	current   APIClientListByTagsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIClientListByTagsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIClientListByTagsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIClientListByTagsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagResourceCollection.NextLink == nil || len(*p.current.TagResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByTagsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIClientListByTagsResponse page.
func (p *APIClientListByTagsPager) PageResponse() APIClientListByTagsResponse {
	return p.current
}

// APIDiagnosticClientListByServicePager provides operations for iterating over paged responses.
type APIDiagnosticClientListByServicePager struct {
	client    *APIDiagnosticClient
	current   APIDiagnosticClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIDiagnosticClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIDiagnosticClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIDiagnosticClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticCollection.NextLink == nil || len(*p.current.DiagnosticCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIDiagnosticClientListByServiceResponse page.
func (p *APIDiagnosticClientListByServicePager) PageResponse() APIDiagnosticClientListByServiceResponse {
	return p.current
}

// APIIssueAttachmentClientListByServicePager provides operations for iterating over paged responses.
type APIIssueAttachmentClientListByServicePager struct {
	client    *APIIssueAttachmentClient
	current   APIIssueAttachmentClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIIssueAttachmentClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIIssueAttachmentClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIIssueAttachmentClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IssueAttachmentCollection.NextLink == nil || len(*p.current.IssueAttachmentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIIssueAttachmentClientListByServiceResponse page.
func (p *APIIssueAttachmentClientListByServicePager) PageResponse() APIIssueAttachmentClientListByServiceResponse {
	return p.current
}

// APIIssueClientListByServicePager provides operations for iterating over paged responses.
type APIIssueClientListByServicePager struct {
	client    *APIIssueClient
	current   APIIssueClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIIssueClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIIssueClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIIssueClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IssueCollection.NextLink == nil || len(*p.current.IssueCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIIssueClientListByServiceResponse page.
func (p *APIIssueClientListByServicePager) PageResponse() APIIssueClientListByServiceResponse {
	return p.current
}

// APIIssueCommentClientListByServicePager provides operations for iterating over paged responses.
type APIIssueCommentClientListByServicePager struct {
	client    *APIIssueCommentClient
	current   APIIssueCommentClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIIssueCommentClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIIssueCommentClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIIssueCommentClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IssueCommentCollection.NextLink == nil || len(*p.current.IssueCommentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIIssueCommentClientListByServiceResponse page.
func (p *APIIssueCommentClientListByServicePager) PageResponse() APIIssueCommentClientListByServiceResponse {
	return p.current
}

// APIOperationClientListByAPIPager provides operations for iterating over paged responses.
type APIOperationClientListByAPIPager struct {
	client    *APIOperationClient
	current   APIOperationClientListByAPIResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIOperationClientListByAPIResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIOperationClientListByAPIPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIOperationClientListByAPIPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationCollection.NextLink == nil || len(*p.current.OperationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAPIHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIOperationClientListByAPIResponse page.
func (p *APIOperationClientListByAPIPager) PageResponse() APIOperationClientListByAPIResponse {
	return p.current
}

// APIProductClientListByApisPager provides operations for iterating over paged responses.
type APIProductClientListByApisPager struct {
	client    *APIProductClient
	current   APIProductClientListByApisResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIProductClientListByApisResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIProductClientListByApisPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIProductClientListByApisPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductCollection.NextLink == nil || len(*p.current.ProductCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByApisHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIProductClientListByApisResponse page.
func (p *APIProductClientListByApisPager) PageResponse() APIProductClientListByApisResponse {
	return p.current
}

// APIReleaseClientListByServicePager provides operations for iterating over paged responses.
type APIReleaseClientListByServicePager struct {
	client    *APIReleaseClient
	current   APIReleaseClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIReleaseClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIReleaseClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIReleaseClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIReleaseCollection.NextLink == nil || len(*p.current.APIReleaseCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIReleaseClientListByServiceResponse page.
func (p *APIReleaseClientListByServicePager) PageResponse() APIReleaseClientListByServiceResponse {
	return p.current
}

// APIRevisionClientListByServicePager provides operations for iterating over paged responses.
type APIRevisionClientListByServicePager struct {
	client    *APIRevisionClient
	current   APIRevisionClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIRevisionClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIRevisionClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIRevisionClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIRevisionCollection.NextLink == nil || len(*p.current.APIRevisionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIRevisionClientListByServiceResponse page.
func (p *APIRevisionClientListByServicePager) PageResponse() APIRevisionClientListByServiceResponse {
	return p.current
}

// APISchemaClientListByAPIPager provides operations for iterating over paged responses.
type APISchemaClientListByAPIPager struct {
	client    *APISchemaClient
	current   APISchemaClientListByAPIResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APISchemaClientListByAPIResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APISchemaClientListByAPIPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APISchemaClientListByAPIPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SchemaCollection.NextLink == nil || len(*p.current.SchemaCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAPIHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APISchemaClientListByAPIResponse page.
func (p *APISchemaClientListByAPIPager) PageResponse() APISchemaClientListByAPIResponse {
	return p.current
}

// APITagDescriptionClientListByServicePager provides operations for iterating over paged responses.
type APITagDescriptionClientListByServicePager struct {
	client    *APITagDescriptionClient
	current   APITagDescriptionClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APITagDescriptionClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APITagDescriptionClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APITagDescriptionClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagDescriptionCollection.NextLink == nil || len(*p.current.TagDescriptionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APITagDescriptionClientListByServiceResponse page.
func (p *APITagDescriptionClientListByServicePager) PageResponse() APITagDescriptionClientListByServiceResponse {
	return p.current
}

// APIVersionSetClientListByServicePager provides operations for iterating over paged responses.
type APIVersionSetClientListByServicePager struct {
	client    *APIVersionSetClient
	current   APIVersionSetClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIVersionSetClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIVersionSetClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIVersionSetClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIVersionSetCollection.NextLink == nil || len(*p.current.APIVersionSetCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIVersionSetClientListByServiceResponse page.
func (p *APIVersionSetClientListByServicePager) PageResponse() APIVersionSetClientListByServiceResponse {
	return p.current
}

// AuthorizationServerClientListByServicePager provides operations for iterating over paged responses.
type AuthorizationServerClientListByServicePager struct {
	client    *AuthorizationServerClient
	current   AuthorizationServerClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AuthorizationServerClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AuthorizationServerClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AuthorizationServerClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AuthorizationServerCollection.NextLink == nil || len(*p.current.AuthorizationServerCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AuthorizationServerClientListByServiceResponse page.
func (p *AuthorizationServerClientListByServicePager) PageResponse() AuthorizationServerClientListByServiceResponse {
	return p.current
}

// BackendClientListByServicePager provides operations for iterating over paged responses.
type BackendClientListByServicePager struct {
	client    *BackendClient
	current   BackendClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackendClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BackendClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BackendClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackendCollection.NextLink == nil || len(*p.current.BackendCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BackendClientListByServiceResponse page.
func (p *BackendClientListByServicePager) PageResponse() BackendClientListByServiceResponse {
	return p.current
}

// CacheClientListByServicePager provides operations for iterating over paged responses.
type CacheClientListByServicePager struct {
	client    *CacheClient
	current   CacheClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CacheClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CacheClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CacheClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CacheCollection.NextLink == nil || len(*p.current.CacheCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CacheClientListByServiceResponse page.
func (p *CacheClientListByServicePager) PageResponse() CacheClientListByServiceResponse {
	return p.current
}

// CertificateClientListByServicePager provides operations for iterating over paged responses.
type CertificateClientListByServicePager struct {
	client    *CertificateClient
	current   CertificateClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CertificateClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CertificateClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CertificateClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CertificateCollection.NextLink == nil || len(*p.current.CertificateCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CertificateClientListByServiceResponse page.
func (p *CertificateClientListByServicePager) PageResponse() CertificateClientListByServiceResponse {
	return p.current
}

// ContentItemClientListByServicePager provides operations for iterating over paged responses.
type ContentItemClientListByServicePager struct {
	client    *ContentItemClient
	current   ContentItemClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContentItemClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ContentItemClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ContentItemClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContentItemCollection.NextLink == nil || len(*p.current.ContentItemCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ContentItemClientListByServiceResponse page.
func (p *ContentItemClientListByServicePager) PageResponse() ContentItemClientListByServiceResponse {
	return p.current
}

// ContentTypeClientListByServicePager provides operations for iterating over paged responses.
type ContentTypeClientListByServicePager struct {
	client    *ContentTypeClient
	current   ContentTypeClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContentTypeClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ContentTypeClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ContentTypeClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContentTypeCollection.NextLink == nil || len(*p.current.ContentTypeCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ContentTypeClientListByServiceResponse page.
func (p *ContentTypeClientListByServicePager) PageResponse() ContentTypeClientListByServiceResponse {
	return p.current
}

// DeletedServicesClientListBySubscriptionPager provides operations for iterating over paged responses.
type DeletedServicesClientListBySubscriptionPager struct {
	client    *DeletedServicesClient
	current   DeletedServicesClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeletedServicesClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DeletedServicesClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DeletedServicesClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeletedServicesCollection.NextLink == nil || len(*p.current.DeletedServicesCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DeletedServicesClientListBySubscriptionResponse page.
func (p *DeletedServicesClientListBySubscriptionPager) PageResponse() DeletedServicesClientListBySubscriptionResponse {
	return p.current
}

// DiagnosticClientListByServicePager provides operations for iterating over paged responses.
type DiagnosticClientListByServicePager struct {
	client    *DiagnosticClient
	current   DiagnosticClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiagnosticClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiagnosticClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiagnosticClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticCollection.NextLink == nil || len(*p.current.DiagnosticCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiagnosticClientListByServiceResponse page.
func (p *DiagnosticClientListByServicePager) PageResponse() DiagnosticClientListByServiceResponse {
	return p.current
}

// EmailTemplateClientListByServicePager provides operations for iterating over paged responses.
type EmailTemplateClientListByServicePager struct {
	client    *EmailTemplateClient
	current   EmailTemplateClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EmailTemplateClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EmailTemplateClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EmailTemplateClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EmailTemplateCollection.NextLink == nil || len(*p.current.EmailTemplateCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EmailTemplateClientListByServiceResponse page.
func (p *EmailTemplateClientListByServicePager) PageResponse() EmailTemplateClientListByServiceResponse {
	return p.current
}

// GatewayAPIClientListByServicePager provides operations for iterating over paged responses.
type GatewayAPIClientListByServicePager struct {
	client    *GatewayAPIClient
	current   GatewayAPIClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GatewayAPIClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GatewayAPIClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GatewayAPIClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APICollection.NextLink == nil || len(*p.current.APICollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GatewayAPIClientListByServiceResponse page.
func (p *GatewayAPIClientListByServicePager) PageResponse() GatewayAPIClientListByServiceResponse {
	return p.current
}

// GatewayCertificateAuthorityClientListByServicePager provides operations for iterating over paged responses.
type GatewayCertificateAuthorityClientListByServicePager struct {
	client    *GatewayCertificateAuthorityClient
	current   GatewayCertificateAuthorityClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GatewayCertificateAuthorityClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GatewayCertificateAuthorityClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GatewayCertificateAuthorityClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GatewayCertificateAuthorityCollection.NextLink == nil || len(*p.current.GatewayCertificateAuthorityCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GatewayCertificateAuthorityClientListByServiceResponse page.
func (p *GatewayCertificateAuthorityClientListByServicePager) PageResponse() GatewayCertificateAuthorityClientListByServiceResponse {
	return p.current
}

// GatewayClientListByServicePager provides operations for iterating over paged responses.
type GatewayClientListByServicePager struct {
	client    *GatewayClient
	current   GatewayClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GatewayClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GatewayClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GatewayClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GatewayCollection.NextLink == nil || len(*p.current.GatewayCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GatewayClientListByServiceResponse page.
func (p *GatewayClientListByServicePager) PageResponse() GatewayClientListByServiceResponse {
	return p.current
}

// GatewayHostnameConfigurationClientListByServicePager provides operations for iterating over paged responses.
type GatewayHostnameConfigurationClientListByServicePager struct {
	client    *GatewayHostnameConfigurationClient
	current   GatewayHostnameConfigurationClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GatewayHostnameConfigurationClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GatewayHostnameConfigurationClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GatewayHostnameConfigurationClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GatewayHostnameConfigurationCollection.NextLink == nil || len(*p.current.GatewayHostnameConfigurationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GatewayHostnameConfigurationClientListByServiceResponse page.
func (p *GatewayHostnameConfigurationClientListByServicePager) PageResponse() GatewayHostnameConfigurationClientListByServiceResponse {
	return p.current
}

// GlobalSchemaClientListByServicePager provides operations for iterating over paged responses.
type GlobalSchemaClientListByServicePager struct {
	client    *GlobalSchemaClient
	current   GlobalSchemaClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GlobalSchemaClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GlobalSchemaClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GlobalSchemaClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GlobalSchemaCollection.NextLink == nil || len(*p.current.GlobalSchemaCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GlobalSchemaClientListByServiceResponse page.
func (p *GlobalSchemaClientListByServicePager) PageResponse() GlobalSchemaClientListByServiceResponse {
	return p.current
}

// GroupClientListByServicePager provides operations for iterating over paged responses.
type GroupClientListByServicePager struct {
	client    *GroupClient
	current   GroupClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GroupClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GroupClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GroupClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GroupCollection.NextLink == nil || len(*p.current.GroupCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GroupClientListByServiceResponse page.
func (p *GroupClientListByServicePager) PageResponse() GroupClientListByServiceResponse {
	return p.current
}

// GroupUserClientListPager provides operations for iterating over paged responses.
type GroupUserClientListPager struct {
	client    *GroupUserClient
	current   GroupUserClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GroupUserClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GroupUserClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GroupUserClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UserCollection.NextLink == nil || len(*p.current.UserCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GroupUserClientListResponse page.
func (p *GroupUserClientListPager) PageResponse() GroupUserClientListResponse {
	return p.current
}

// IdentityProviderClientListByServicePager provides operations for iterating over paged responses.
type IdentityProviderClientListByServicePager struct {
	client    *IdentityProviderClient
	current   IdentityProviderClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IdentityProviderClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IdentityProviderClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IdentityProviderClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IdentityProviderList.NextLink == nil || len(*p.current.IdentityProviderList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IdentityProviderClientListByServiceResponse page.
func (p *IdentityProviderClientListByServicePager) PageResponse() IdentityProviderClientListByServiceResponse {
	return p.current
}

// IssueClientListByServicePager provides operations for iterating over paged responses.
type IssueClientListByServicePager struct {
	client    *IssueClient
	current   IssueClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IssueClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IssueClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IssueClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IssueCollection.NextLink == nil || len(*p.current.IssueCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IssueClientListByServiceResponse page.
func (p *IssueClientListByServicePager) PageResponse() IssueClientListByServiceResponse {
	return p.current
}

// LoggerClientListByServicePager provides operations for iterating over paged responses.
type LoggerClientListByServicePager struct {
	client    *LoggerClient
	current   LoggerClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoggerClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoggerClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoggerClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoggerCollection.NextLink == nil || len(*p.current.LoggerCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoggerClientListByServiceResponse page.
func (p *LoggerClientListByServicePager) PageResponse() LoggerClientListByServiceResponse {
	return p.current
}

// NamedValueClientListByServicePager provides operations for iterating over paged responses.
type NamedValueClientListByServicePager struct {
	client    *NamedValueClient
	current   NamedValueClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NamedValueClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NamedValueClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NamedValueClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NamedValueCollection.NextLink == nil || len(*p.current.NamedValueCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NamedValueClientListByServiceResponse page.
func (p *NamedValueClientListByServicePager) PageResponse() NamedValueClientListByServiceResponse {
	return p.current
}

// NotificationClientListByServicePager provides operations for iterating over paged responses.
type NotificationClientListByServicePager struct {
	client    *NotificationClient
	current   NotificationClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NotificationClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NotificationClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NotificationClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NotificationCollection.NextLink == nil || len(*p.current.NotificationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NotificationClientListByServiceResponse page.
func (p *NotificationClientListByServicePager) PageResponse() NotificationClientListByServiceResponse {
	return p.current
}

// OpenIDConnectProviderClientListByServicePager provides operations for iterating over paged responses.
type OpenIDConnectProviderClientListByServicePager struct {
	client    *OpenIDConnectProviderClient
	current   OpenIDConnectProviderClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OpenIDConnectProviderClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OpenIDConnectProviderClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OpenIDConnectProviderClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OpenIDConnectProviderCollection.NextLink == nil || len(*p.current.OpenIDConnectProviderCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OpenIDConnectProviderClientListByServiceResponse page.
func (p *OpenIDConnectProviderClientListByServicePager) PageResponse() OpenIDConnectProviderClientListByServiceResponse {
	return p.current
}

// OperationClientListByTagsPager provides operations for iterating over paged responses.
type OperationClientListByTagsPager struct {
	client    *OperationClient
	current   OperationClientListByTagsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationClientListByTagsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationClientListByTagsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationClientListByTagsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagResourceCollection.NextLink == nil || len(*p.current.TagResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByTagsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationClientListByTagsResponse page.
func (p *OperationClientListByTagsPager) PageResponse() OperationClientListByTagsResponse {
	return p.current
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsClientListResponse page.
func (p *OperationsClientListPager) PageResponse() OperationsClientListResponse {
	return p.current
}

// PortalRevisionClientListByServicePager provides operations for iterating over paged responses.
type PortalRevisionClientListByServicePager struct {
	client    *PortalRevisionClient
	current   PortalRevisionClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PortalRevisionClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PortalRevisionClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PortalRevisionClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PortalRevisionCollection.NextLink == nil || len(*p.current.PortalRevisionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PortalRevisionClientListByServiceResponse page.
func (p *PortalRevisionClientListByServicePager) PageResponse() PortalRevisionClientListByServiceResponse {
	return p.current
}

// ProductAPIClientListByProductPager provides operations for iterating over paged responses.
type ProductAPIClientListByProductPager struct {
	client    *ProductAPIClient
	current   ProductAPIClientListByProductResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductAPIClientListByProductResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductAPIClientListByProductPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductAPIClientListByProductPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APICollection.NextLink == nil || len(*p.current.APICollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByProductHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductAPIClientListByProductResponse page.
func (p *ProductAPIClientListByProductPager) PageResponse() ProductAPIClientListByProductResponse {
	return p.current
}

// ProductClientListByServicePager provides operations for iterating over paged responses.
type ProductClientListByServicePager struct {
	client    *ProductClient
	current   ProductClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductCollection.NextLink == nil || len(*p.current.ProductCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductClientListByServiceResponse page.
func (p *ProductClientListByServicePager) PageResponse() ProductClientListByServiceResponse {
	return p.current
}

// ProductClientListByTagsPager provides operations for iterating over paged responses.
type ProductClientListByTagsPager struct {
	client    *ProductClient
	current   ProductClientListByTagsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductClientListByTagsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductClientListByTagsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductClientListByTagsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagResourceCollection.NextLink == nil || len(*p.current.TagResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByTagsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductClientListByTagsResponse page.
func (p *ProductClientListByTagsPager) PageResponse() ProductClientListByTagsResponse {
	return p.current
}

// ProductGroupClientListByProductPager provides operations for iterating over paged responses.
type ProductGroupClientListByProductPager struct {
	client    *ProductGroupClient
	current   ProductGroupClientListByProductResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductGroupClientListByProductResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductGroupClientListByProductPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductGroupClientListByProductPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GroupCollection.NextLink == nil || len(*p.current.GroupCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByProductHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductGroupClientListByProductResponse page.
func (p *ProductGroupClientListByProductPager) PageResponse() ProductGroupClientListByProductResponse {
	return p.current
}

// ProductSubscriptionsClientListPager provides operations for iterating over paged responses.
type ProductSubscriptionsClientListPager struct {
	client    *ProductSubscriptionsClient
	current   ProductSubscriptionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductSubscriptionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductSubscriptionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductSubscriptionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionCollection.NextLink == nil || len(*p.current.SubscriptionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductSubscriptionsClientListResponse page.
func (p *ProductSubscriptionsClientListPager) PageResponse() ProductSubscriptionsClientListResponse {
	return p.current
}

// RegionClientListByServicePager provides operations for iterating over paged responses.
type RegionClientListByServicePager struct {
	client    *RegionClient
	current   RegionClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegionClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RegionClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RegionClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegionListResult.NextLink == nil || len(*p.current.RegionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RegionClientListByServiceResponse page.
func (p *RegionClientListByServicePager) PageResponse() RegionClientListByServiceResponse {
	return p.current
}

// ReportsClientListByAPIPager provides operations for iterating over paged responses.
type ReportsClientListByAPIPager struct {
	client    *ReportsClient
	current   ReportsClientListByAPIResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListByAPIResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsClientListByAPIPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsClientListByAPIPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAPIHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsClientListByAPIResponse page.
func (p *ReportsClientListByAPIPager) PageResponse() ReportsClientListByAPIResponse {
	return p.current
}

// ReportsClientListByGeoPager provides operations for iterating over paged responses.
type ReportsClientListByGeoPager struct {
	client    *ReportsClient
	current   ReportsClientListByGeoResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListByGeoResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsClientListByGeoPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsClientListByGeoPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByGeoHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsClientListByGeoResponse page.
func (p *ReportsClientListByGeoPager) PageResponse() ReportsClientListByGeoResponse {
	return p.current
}

// ReportsClientListByOperationPager provides operations for iterating over paged responses.
type ReportsClientListByOperationPager struct {
	client    *ReportsClient
	current   ReportsClientListByOperationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListByOperationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsClientListByOperationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsClientListByOperationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByOperationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsClientListByOperationResponse page.
func (p *ReportsClientListByOperationPager) PageResponse() ReportsClientListByOperationResponse {
	return p.current
}

// ReportsClientListByProductPager provides operations for iterating over paged responses.
type ReportsClientListByProductPager struct {
	client    *ReportsClient
	current   ReportsClientListByProductResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListByProductResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsClientListByProductPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsClientListByProductPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByProductHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsClientListByProductResponse page.
func (p *ReportsClientListByProductPager) PageResponse() ReportsClientListByProductResponse {
	return p.current
}

// ReportsClientListBySubscriptionPager provides operations for iterating over paged responses.
type ReportsClientListBySubscriptionPager struct {
	client    *ReportsClient
	current   ReportsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsClientListBySubscriptionResponse page.
func (p *ReportsClientListBySubscriptionPager) PageResponse() ReportsClientListBySubscriptionResponse {
	return p.current
}

// ReportsClientListByTimePager provides operations for iterating over paged responses.
type ReportsClientListByTimePager struct {
	client    *ReportsClient
	current   ReportsClientListByTimeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListByTimeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsClientListByTimePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsClientListByTimePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByTimeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsClientListByTimeResponse page.
func (p *ReportsClientListByTimePager) PageResponse() ReportsClientListByTimeResponse {
	return p.current
}

// ReportsClientListByUserPager provides operations for iterating over paged responses.
type ReportsClientListByUserPager struct {
	client    *ReportsClient
	current   ReportsClientListByUserResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListByUserResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsClientListByUserPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsClientListByUserPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByUserHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsClientListByUserResponse page.
func (p *ReportsClientListByUserPager) PageResponse() ReportsClientListByUserResponse {
	return p.current
}

// SKUsClientListPager provides operations for iterating over paged responses.
type SKUsClientListPager struct {
	client    *SKUsClient
	current   SKUsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SKUsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SKUsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SKUsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SKUsResult.NextLink == nil || len(*p.current.SKUsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SKUsClientListResponse page.
func (p *SKUsClientListPager) PageResponse() SKUsClientListResponse {
	return p.current
}

// ServiceClientListByResourceGroupPager provides operations for iterating over paged responses.
type ServiceClientListByResourceGroupPager struct {
	client    *ServiceClient
	current   ServiceClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceListResult.NextLink == nil || len(*p.current.ServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceClientListByResourceGroupResponse page.
func (p *ServiceClientListByResourceGroupPager) PageResponse() ServiceClientListByResourceGroupResponse {
	return p.current
}

// ServiceClientListPager provides operations for iterating over paged responses.
type ServiceClientListPager struct {
	client    *ServiceClient
	current   ServiceClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceListResult.NextLink == nil || len(*p.current.ServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceClientListResponse page.
func (p *ServiceClientListPager) PageResponse() ServiceClientListResponse {
	return p.current
}

// ServiceSKUsClientListAvailableServiceSKUsPager provides operations for iterating over paged responses.
type ServiceSKUsClientListAvailableServiceSKUsPager struct {
	client    *ServiceSKUsClient
	current   ServiceSKUsClientListAvailableServiceSKUsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceSKUsClientListAvailableServiceSKUsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceSKUsClientListAvailableServiceSKUsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceSKUsClientListAvailableServiceSKUsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceSKUResults.NextLink == nil || len(*p.current.ResourceSKUResults.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAvailableServiceSKUsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceSKUsClientListAvailableServiceSKUsResponse page.
func (p *ServiceSKUsClientListAvailableServiceSKUsPager) PageResponse() ServiceSKUsClientListAvailableServiceSKUsResponse {
	return p.current
}

// SubscriptionClientListPager provides operations for iterating over paged responses.
type SubscriptionClientListPager struct {
	client    *SubscriptionClient
	current   SubscriptionClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubscriptionClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubscriptionClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionCollection.NextLink == nil || len(*p.current.SubscriptionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubscriptionClientListResponse page.
func (p *SubscriptionClientListPager) PageResponse() SubscriptionClientListResponse {
	return p.current
}

// TagClientListByAPIPager provides operations for iterating over paged responses.
type TagClientListByAPIPager struct {
	client    *TagClient
	current   TagClientListByAPIResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagClientListByAPIResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TagClientListByAPIPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TagClientListByAPIPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagCollection.NextLink == nil || len(*p.current.TagCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAPIHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TagClientListByAPIResponse page.
func (p *TagClientListByAPIPager) PageResponse() TagClientListByAPIResponse {
	return p.current
}

// TagClientListByOperationPager provides operations for iterating over paged responses.
type TagClientListByOperationPager struct {
	client    *TagClient
	current   TagClientListByOperationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagClientListByOperationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TagClientListByOperationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TagClientListByOperationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagCollection.NextLink == nil || len(*p.current.TagCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByOperationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TagClientListByOperationResponse page.
func (p *TagClientListByOperationPager) PageResponse() TagClientListByOperationResponse {
	return p.current
}

// TagClientListByProductPager provides operations for iterating over paged responses.
type TagClientListByProductPager struct {
	client    *TagClient
	current   TagClientListByProductResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagClientListByProductResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TagClientListByProductPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TagClientListByProductPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagCollection.NextLink == nil || len(*p.current.TagCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByProductHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TagClientListByProductResponse page.
func (p *TagClientListByProductPager) PageResponse() TagClientListByProductResponse {
	return p.current
}

// TagClientListByServicePager provides operations for iterating over paged responses.
type TagClientListByServicePager struct {
	client    *TagClient
	current   TagClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TagClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TagClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagCollection.NextLink == nil || len(*p.current.TagCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TagClientListByServiceResponse page.
func (p *TagClientListByServicePager) PageResponse() TagClientListByServiceResponse {
	return p.current
}

// TagResourceClientListByServicePager provides operations for iterating over paged responses.
type TagResourceClientListByServicePager struct {
	client    *TagResourceClient
	current   TagResourceClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagResourceClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TagResourceClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TagResourceClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagResourceCollection.NextLink == nil || len(*p.current.TagResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TagResourceClientListByServiceResponse page.
func (p *TagResourceClientListByServicePager) PageResponse() TagResourceClientListByServiceResponse {
	return p.current
}

// TenantAccessClientListByServicePager provides operations for iterating over paged responses.
type TenantAccessClientListByServicePager struct {
	client    *TenantAccessClient
	current   TenantAccessClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TenantAccessClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TenantAccessClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TenantAccessClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccessInformationCollection.NextLink == nil || len(*p.current.AccessInformationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TenantAccessClientListByServiceResponse page.
func (p *TenantAccessClientListByServicePager) PageResponse() TenantAccessClientListByServiceResponse {
	return p.current
}

// TenantSettingsClientListByServicePager provides operations for iterating over paged responses.
type TenantSettingsClientListByServicePager struct {
	client    *TenantSettingsClient
	current   TenantSettingsClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TenantSettingsClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TenantSettingsClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TenantSettingsClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TenantSettingsCollection.NextLink == nil || len(*p.current.TenantSettingsCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TenantSettingsClientListByServiceResponse page.
func (p *TenantSettingsClientListByServicePager) PageResponse() TenantSettingsClientListByServiceResponse {
	return p.current
}

// UserClientListByServicePager provides operations for iterating over paged responses.
type UserClientListByServicePager struct {
	client    *UserClient
	current   UserClientListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UserClientListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UserClientListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UserClientListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UserCollection.NextLink == nil || len(*p.current.UserCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UserClientListByServiceResponse page.
func (p *UserClientListByServicePager) PageResponse() UserClientListByServiceResponse {
	return p.current
}

// UserGroupClientListPager provides operations for iterating over paged responses.
type UserGroupClientListPager struct {
	client    *UserGroupClient
	current   UserGroupClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UserGroupClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UserGroupClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UserGroupClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GroupCollection.NextLink == nil || len(*p.current.GroupCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UserGroupClientListResponse page.
func (p *UserGroupClientListPager) PageResponse() UserGroupClientListResponse {
	return p.current
}

// UserIdentitiesClientListPager provides operations for iterating over paged responses.
type UserIdentitiesClientListPager struct {
	client    *UserIdentitiesClient
	current   UserIdentitiesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UserIdentitiesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UserIdentitiesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UserIdentitiesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UserIdentityCollection.NextLink == nil || len(*p.current.UserIdentityCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UserIdentitiesClientListResponse page.
func (p *UserIdentitiesClientListPager) PageResponse() UserIdentitiesClientListResponse {
	return p.current
}

// UserSubscriptionClientListPager provides operations for iterating over paged responses.
type UserSubscriptionClientListPager struct {
	client    *UserSubscriptionClient
	current   UserSubscriptionClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UserSubscriptionClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UserSubscriptionClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UserSubscriptionClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionCollection.NextLink == nil || len(*p.current.SubscriptionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UserSubscriptionClientListResponse page.
func (p *UserSubscriptionClientListPager) PageResponse() UserSubscriptionClientListResponse {
	return p.current
}
