//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armapimanagement

import (
	"context"
	"net/http"
	"reflect"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// APIDiagnosticListByServicePager provides operations for iterating over paged responses.
type APIDiagnosticListByServicePager struct {
	client    *APIDiagnosticClient
	current   APIDiagnosticListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIDiagnosticListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIDiagnosticListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIDiagnosticListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticCollection.NextLink == nil || len(*p.current.DiagnosticCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIDiagnosticListByServiceResponse page.
func (p *APIDiagnosticListByServicePager) PageResponse() APIDiagnosticListByServiceResponse {
	return p.current
}

// APIIssueAttachmentListByServicePager provides operations for iterating over paged responses.
type APIIssueAttachmentListByServicePager struct {
	client    *APIIssueAttachmentClient
	current   APIIssueAttachmentListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIIssueAttachmentListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIIssueAttachmentListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIIssueAttachmentListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IssueAttachmentCollection.NextLink == nil || len(*p.current.IssueAttachmentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIIssueAttachmentListByServiceResponse page.
func (p *APIIssueAttachmentListByServicePager) PageResponse() APIIssueAttachmentListByServiceResponse {
	return p.current
}

// APIIssueCommentListByServicePager provides operations for iterating over paged responses.
type APIIssueCommentListByServicePager struct {
	client    *APIIssueCommentClient
	current   APIIssueCommentListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIIssueCommentListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIIssueCommentListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIIssueCommentListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IssueCommentCollection.NextLink == nil || len(*p.current.IssueCommentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIIssueCommentListByServiceResponse page.
func (p *APIIssueCommentListByServicePager) PageResponse() APIIssueCommentListByServiceResponse {
	return p.current
}

// APIIssueListByServicePager provides operations for iterating over paged responses.
type APIIssueListByServicePager struct {
	client    *APIIssueClient
	current   APIIssueListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIIssueListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIIssueListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIIssueListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IssueCollection.NextLink == nil || len(*p.current.IssueCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIIssueListByServiceResponse page.
func (p *APIIssueListByServicePager) PageResponse() APIIssueListByServiceResponse {
	return p.current
}

// APIListByServicePager provides operations for iterating over paged responses.
type APIListByServicePager struct {
	client    *APIClient
	current   APIListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APICollection.NextLink == nil || len(*p.current.APICollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIListByServiceResponse page.
func (p *APIListByServicePager) PageResponse() APIListByServiceResponse {
	return p.current
}

// APIListByTagsPager provides operations for iterating over paged responses.
type APIListByTagsPager struct {
	client    *APIClient
	current   APIListByTagsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIListByTagsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIListByTagsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIListByTagsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagResourceCollection.NextLink == nil || len(*p.current.TagResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByTagsHandleError(resp)
		return false
	}
	result, err := p.client.listByTagsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIListByTagsResponse page.
func (p *APIListByTagsPager) PageResponse() APIListByTagsResponse {
	return p.current
}

// APIManagementOperationsListPager provides operations for iterating over paged responses.
type APIManagementOperationsListPager struct {
	client    *APIManagementOperationsClient
	current   APIManagementOperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIManagementOperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIManagementOperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIManagementOperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIManagementOperationsListResponse page.
func (p *APIManagementOperationsListPager) PageResponse() APIManagementOperationsListResponse {
	return p.current
}

// APIManagementSKUsListPager provides operations for iterating over paged responses.
type APIManagementSKUsListPager struct {
	client    *APIManagementSKUsClient
	current   APIManagementSKUsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIManagementSKUsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIManagementSKUsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIManagementSKUsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIManagementSKUsResult.NextLink == nil || len(*p.current.APIManagementSKUsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIManagementSKUsListResponse page.
func (p *APIManagementSKUsListPager) PageResponse() APIManagementSKUsListResponse {
	return p.current
}

// APIManagementServiceListByResourceGroupPager provides operations for iterating over paged responses.
type APIManagementServiceListByResourceGroupPager struct {
	client    *APIManagementServiceClient
	current   APIManagementServiceListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIManagementServiceListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIManagementServiceListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIManagementServiceListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIManagementServiceListResult.NextLink == nil || len(*p.current.APIManagementServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIManagementServiceListByResourceGroupResponse page.
func (p *APIManagementServiceListByResourceGroupPager) PageResponse() APIManagementServiceListByResourceGroupResponse {
	return p.current
}

// APIManagementServiceListPager provides operations for iterating over paged responses.
type APIManagementServiceListPager struct {
	client    *APIManagementServiceClient
	current   APIManagementServiceListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIManagementServiceListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIManagementServiceListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIManagementServiceListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIManagementServiceListResult.NextLink == nil || len(*p.current.APIManagementServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIManagementServiceListResponse page.
func (p *APIManagementServiceListPager) PageResponse() APIManagementServiceListResponse {
	return p.current
}

// APIManagementServiceSKUsListAvailableServiceSKUsPager provides operations for iterating over paged responses.
type APIManagementServiceSKUsListAvailableServiceSKUsPager struct {
	client    *APIManagementServiceSKUsClient
	current   APIManagementServiceSKUsListAvailableServiceSKUsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIManagementServiceSKUsListAvailableServiceSKUsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIManagementServiceSKUsListAvailableServiceSKUsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIManagementServiceSKUsListAvailableServiceSKUsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceSKUResults.NextLink == nil || len(*p.current.ResourceSKUResults.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAvailableServiceSKUsHandleError(resp)
		return false
	}
	result, err := p.client.listAvailableServiceSKUsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIManagementServiceSKUsListAvailableServiceSKUsResponse page.
func (p *APIManagementServiceSKUsListAvailableServiceSKUsPager) PageResponse() APIManagementServiceSKUsListAvailableServiceSKUsResponse {
	return p.current
}

// APIOperationListByAPIPager provides operations for iterating over paged responses.
type APIOperationListByAPIPager struct {
	client    *APIOperationClient
	current   APIOperationListByAPIResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIOperationListByAPIResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIOperationListByAPIPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIOperationListByAPIPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationCollection.NextLink == nil || len(*p.current.OperationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAPIHandleError(resp)
		return false
	}
	result, err := p.client.listByAPIHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIOperationListByAPIResponse page.
func (p *APIOperationListByAPIPager) PageResponse() APIOperationListByAPIResponse {
	return p.current
}

// APIProductListByApisPager provides operations for iterating over paged responses.
type APIProductListByApisPager struct {
	client    *APIProductClient
	current   APIProductListByApisResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIProductListByApisResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIProductListByApisPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIProductListByApisPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductCollection.NextLink == nil || len(*p.current.ProductCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByApisHandleError(resp)
		return false
	}
	result, err := p.client.listByApisHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIProductListByApisResponse page.
func (p *APIProductListByApisPager) PageResponse() APIProductListByApisResponse {
	return p.current
}

// APIReleaseListByServicePager provides operations for iterating over paged responses.
type APIReleaseListByServicePager struct {
	client    *APIReleaseClient
	current   APIReleaseListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIReleaseListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIReleaseListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIReleaseListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIReleaseCollection.NextLink == nil || len(*p.current.APIReleaseCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIReleaseListByServiceResponse page.
func (p *APIReleaseListByServicePager) PageResponse() APIReleaseListByServiceResponse {
	return p.current
}

// APIRevisionListByServicePager provides operations for iterating over paged responses.
type APIRevisionListByServicePager struct {
	client    *APIRevisionClient
	current   APIRevisionListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIRevisionListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIRevisionListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIRevisionListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIRevisionCollection.NextLink == nil || len(*p.current.APIRevisionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIRevisionListByServiceResponse page.
func (p *APIRevisionListByServicePager) PageResponse() APIRevisionListByServiceResponse {
	return p.current
}

// APISchemaListByAPIPager provides operations for iterating over paged responses.
type APISchemaListByAPIPager struct {
	client    *APISchemaClient
	current   APISchemaListByAPIResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APISchemaListByAPIResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APISchemaListByAPIPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APISchemaListByAPIPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SchemaCollection.NextLink == nil || len(*p.current.SchemaCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAPIHandleError(resp)
		return false
	}
	result, err := p.client.listByAPIHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APISchemaListByAPIResponse page.
func (p *APISchemaListByAPIPager) PageResponse() APISchemaListByAPIResponse {
	return p.current
}

// APITagDescriptionListByServicePager provides operations for iterating over paged responses.
type APITagDescriptionListByServicePager struct {
	client    *APITagDescriptionClient
	current   APITagDescriptionListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APITagDescriptionListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APITagDescriptionListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APITagDescriptionListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagDescriptionCollection.NextLink == nil || len(*p.current.TagDescriptionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APITagDescriptionListByServiceResponse page.
func (p *APITagDescriptionListByServicePager) PageResponse() APITagDescriptionListByServiceResponse {
	return p.current
}

// APIVersionSetListByServicePager provides operations for iterating over paged responses.
type APIVersionSetListByServicePager struct {
	client    *APIVersionSetClient
	current   APIVersionSetListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIVersionSetListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *APIVersionSetListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *APIVersionSetListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIVersionSetCollection.NextLink == nil || len(*p.current.APIVersionSetCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current APIVersionSetListByServiceResponse page.
func (p *APIVersionSetListByServicePager) PageResponse() APIVersionSetListByServiceResponse {
	return p.current
}

// AuthorizationServerListByServicePager provides operations for iterating over paged responses.
type AuthorizationServerListByServicePager struct {
	client    *AuthorizationServerClient
	current   AuthorizationServerListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AuthorizationServerListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AuthorizationServerListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AuthorizationServerListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AuthorizationServerCollection.NextLink == nil || len(*p.current.AuthorizationServerCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AuthorizationServerListByServiceResponse page.
func (p *AuthorizationServerListByServicePager) PageResponse() AuthorizationServerListByServiceResponse {
	return p.current
}

// BackendListByServicePager provides operations for iterating over paged responses.
type BackendListByServicePager struct {
	client    *BackendClient
	current   BackendListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackendListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BackendListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BackendListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackendCollection.NextLink == nil || len(*p.current.BackendCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BackendListByServiceResponse page.
func (p *BackendListByServicePager) PageResponse() BackendListByServiceResponse {
	return p.current
}

// CacheListByServicePager provides operations for iterating over paged responses.
type CacheListByServicePager struct {
	client    *CacheClient
	current   CacheListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CacheListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CacheListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CacheListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CacheCollection.NextLink == nil || len(*p.current.CacheCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CacheListByServiceResponse page.
func (p *CacheListByServicePager) PageResponse() CacheListByServiceResponse {
	return p.current
}

// CertificateListByServicePager provides operations for iterating over paged responses.
type CertificateListByServicePager struct {
	client    *CertificateClient
	current   CertificateListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CertificateListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CertificateListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CertificateListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CertificateCollection.NextLink == nil || len(*p.current.CertificateCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CertificateListByServiceResponse page.
func (p *CertificateListByServicePager) PageResponse() CertificateListByServiceResponse {
	return p.current
}

// ContentItemListByServicePager provides operations for iterating over paged responses.
type ContentItemListByServicePager struct {
	client    *ContentItemClient
	current   ContentItemListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContentItemListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ContentItemListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ContentItemListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContentItemCollection.NextLink == nil || len(*p.current.ContentItemCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ContentItemListByServiceResponse page.
func (p *ContentItemListByServicePager) PageResponse() ContentItemListByServiceResponse {
	return p.current
}

// ContentTypeListByServicePager provides operations for iterating over paged responses.
type ContentTypeListByServicePager struct {
	client    *ContentTypeClient
	current   ContentTypeListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContentTypeListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ContentTypeListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ContentTypeListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContentTypeCollection.NextLink == nil || len(*p.current.ContentTypeCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ContentTypeListByServiceResponse page.
func (p *ContentTypeListByServicePager) PageResponse() ContentTypeListByServiceResponse {
	return p.current
}

// DeletedServicesListBySubscriptionPager provides operations for iterating over paged responses.
type DeletedServicesListBySubscriptionPager struct {
	client    *DeletedServicesClient
	current   DeletedServicesListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeletedServicesListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DeletedServicesListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DeletedServicesListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeletedServicesCollection.NextLink == nil || len(*p.current.DeletedServicesCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DeletedServicesListBySubscriptionResponse page.
func (p *DeletedServicesListBySubscriptionPager) PageResponse() DeletedServicesListBySubscriptionResponse {
	return p.current
}

// DiagnosticListByServicePager provides operations for iterating over paged responses.
type DiagnosticListByServicePager struct {
	client    *DiagnosticClient
	current   DiagnosticListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiagnosticListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiagnosticListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiagnosticListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticCollection.NextLink == nil || len(*p.current.DiagnosticCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiagnosticListByServiceResponse page.
func (p *DiagnosticListByServicePager) PageResponse() DiagnosticListByServiceResponse {
	return p.current
}

// EmailTemplateListByServicePager provides operations for iterating over paged responses.
type EmailTemplateListByServicePager struct {
	client    *EmailTemplateClient
	current   EmailTemplateListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EmailTemplateListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EmailTemplateListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EmailTemplateListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EmailTemplateCollection.NextLink == nil || len(*p.current.EmailTemplateCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EmailTemplateListByServiceResponse page.
func (p *EmailTemplateListByServicePager) PageResponse() EmailTemplateListByServiceResponse {
	return p.current
}

// GatewayAPIListByServicePager provides operations for iterating over paged responses.
type GatewayAPIListByServicePager struct {
	client    *GatewayAPIClient
	current   GatewayAPIListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GatewayAPIListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GatewayAPIListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GatewayAPIListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APICollection.NextLink == nil || len(*p.current.APICollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GatewayAPIListByServiceResponse page.
func (p *GatewayAPIListByServicePager) PageResponse() GatewayAPIListByServiceResponse {
	return p.current
}

// GatewayCertificateAuthorityListByServicePager provides operations for iterating over paged responses.
type GatewayCertificateAuthorityListByServicePager struct {
	client    *GatewayCertificateAuthorityClient
	current   GatewayCertificateAuthorityListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GatewayCertificateAuthorityListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GatewayCertificateAuthorityListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GatewayCertificateAuthorityListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GatewayCertificateAuthorityCollection.NextLink == nil || len(*p.current.GatewayCertificateAuthorityCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GatewayCertificateAuthorityListByServiceResponse page.
func (p *GatewayCertificateAuthorityListByServicePager) PageResponse() GatewayCertificateAuthorityListByServiceResponse {
	return p.current
}

// GatewayHostnameConfigurationListByServicePager provides operations for iterating over paged responses.
type GatewayHostnameConfigurationListByServicePager struct {
	client    *GatewayHostnameConfigurationClient
	current   GatewayHostnameConfigurationListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GatewayHostnameConfigurationListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GatewayHostnameConfigurationListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GatewayHostnameConfigurationListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GatewayHostnameConfigurationCollection.NextLink == nil || len(*p.current.GatewayHostnameConfigurationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GatewayHostnameConfigurationListByServiceResponse page.
func (p *GatewayHostnameConfigurationListByServicePager) PageResponse() GatewayHostnameConfigurationListByServiceResponse {
	return p.current
}

// GatewayListByServicePager provides operations for iterating over paged responses.
type GatewayListByServicePager struct {
	client    *GatewayClient
	current   GatewayListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GatewayListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GatewayListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GatewayListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GatewayCollection.NextLink == nil || len(*p.current.GatewayCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GatewayListByServiceResponse page.
func (p *GatewayListByServicePager) PageResponse() GatewayListByServiceResponse {
	return p.current
}

// GroupListByServicePager provides operations for iterating over paged responses.
type GroupListByServicePager struct {
	client    *GroupClient
	current   GroupListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GroupListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GroupListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GroupListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GroupCollection.NextLink == nil || len(*p.current.GroupCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GroupListByServiceResponse page.
func (p *GroupListByServicePager) PageResponse() GroupListByServiceResponse {
	return p.current
}

// GroupUserListPager provides operations for iterating over paged responses.
type GroupUserListPager struct {
	client    *GroupUserClient
	current   GroupUserListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GroupUserListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GroupUserListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GroupUserListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UserCollection.NextLink == nil || len(*p.current.UserCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GroupUserListResponse page.
func (p *GroupUserListPager) PageResponse() GroupUserListResponse {
	return p.current
}

// IdentityProviderListByServicePager provides operations for iterating over paged responses.
type IdentityProviderListByServicePager struct {
	client    *IdentityProviderClient
	current   IdentityProviderListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IdentityProviderListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IdentityProviderListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IdentityProviderListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IdentityProviderList.NextLink == nil || len(*p.current.IdentityProviderList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IdentityProviderListByServiceResponse page.
func (p *IdentityProviderListByServicePager) PageResponse() IdentityProviderListByServiceResponse {
	return p.current
}

// IssueListByServicePager provides operations for iterating over paged responses.
type IssueListByServicePager struct {
	client    *IssueClient
	current   IssueListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IssueListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IssueListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IssueListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IssueCollection.NextLink == nil || len(*p.current.IssueCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IssueListByServiceResponse page.
func (p *IssueListByServicePager) PageResponse() IssueListByServiceResponse {
	return p.current
}

// LoggerListByServicePager provides operations for iterating over paged responses.
type LoggerListByServicePager struct {
	client    *LoggerClient
	current   LoggerListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoggerListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoggerListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoggerListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoggerCollection.NextLink == nil || len(*p.current.LoggerCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoggerListByServiceResponse page.
func (p *LoggerListByServicePager) PageResponse() LoggerListByServiceResponse {
	return p.current
}

// NamedValueListByServicePager provides operations for iterating over paged responses.
type NamedValueListByServicePager struct {
	client    *NamedValueClient
	current   NamedValueListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NamedValueListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NamedValueListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NamedValueListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NamedValueCollection.NextLink == nil || len(*p.current.NamedValueCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NamedValueListByServiceResponse page.
func (p *NamedValueListByServicePager) PageResponse() NamedValueListByServiceResponse {
	return p.current
}

// NotificationListByServicePager provides operations for iterating over paged responses.
type NotificationListByServicePager struct {
	client    *NotificationClient
	current   NotificationListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NotificationListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NotificationListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NotificationListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NotificationCollection.NextLink == nil || len(*p.current.NotificationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NotificationListByServiceResponse page.
func (p *NotificationListByServicePager) PageResponse() NotificationListByServiceResponse {
	return p.current
}

// OpenIDConnectProviderListByServicePager provides operations for iterating over paged responses.
type OpenIDConnectProviderListByServicePager struct {
	client    *OpenIDConnectProviderClient
	current   OpenIDConnectProviderListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OpenIDConnectProviderListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OpenIDConnectProviderListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OpenIDConnectProviderListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OpenIDConnectProviderCollection.NextLink == nil || len(*p.current.OpenIDConnectProviderCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OpenIDConnectProviderListByServiceResponse page.
func (p *OpenIDConnectProviderListByServicePager) PageResponse() OpenIDConnectProviderListByServiceResponse {
	return p.current
}

// OperationListByTagsPager provides operations for iterating over paged responses.
type OperationListByTagsPager struct {
	client    *OperationClient
	current   OperationListByTagsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationListByTagsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationListByTagsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationListByTagsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagResourceCollection.NextLink == nil || len(*p.current.TagResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByTagsHandleError(resp)
		return false
	}
	result, err := p.client.listByTagsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationListByTagsResponse page.
func (p *OperationListByTagsPager) PageResponse() OperationListByTagsResponse {
	return p.current
}

// PortalRevisionListByServicePager provides operations for iterating over paged responses.
type PortalRevisionListByServicePager struct {
	client    *PortalRevisionClient
	current   PortalRevisionListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PortalRevisionListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PortalRevisionListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PortalRevisionListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PortalRevisionCollection.NextLink == nil || len(*p.current.PortalRevisionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PortalRevisionListByServiceResponse page.
func (p *PortalRevisionListByServicePager) PageResponse() PortalRevisionListByServiceResponse {
	return p.current
}

// ProductAPIListByProductPager provides operations for iterating over paged responses.
type ProductAPIListByProductPager struct {
	client    *ProductAPIClient
	current   ProductAPIListByProductResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductAPIListByProductResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductAPIListByProductPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductAPIListByProductPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APICollection.NextLink == nil || len(*p.current.APICollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByProductHandleError(resp)
		return false
	}
	result, err := p.client.listByProductHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductAPIListByProductResponse page.
func (p *ProductAPIListByProductPager) PageResponse() ProductAPIListByProductResponse {
	return p.current
}

// ProductGroupListByProductPager provides operations for iterating over paged responses.
type ProductGroupListByProductPager struct {
	client    *ProductGroupClient
	current   ProductGroupListByProductResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductGroupListByProductResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductGroupListByProductPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductGroupListByProductPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GroupCollection.NextLink == nil || len(*p.current.GroupCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByProductHandleError(resp)
		return false
	}
	result, err := p.client.listByProductHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductGroupListByProductResponse page.
func (p *ProductGroupListByProductPager) PageResponse() ProductGroupListByProductResponse {
	return p.current
}

// ProductListByServicePager provides operations for iterating over paged responses.
type ProductListByServicePager struct {
	client    *ProductClient
	current   ProductListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductCollection.NextLink == nil || len(*p.current.ProductCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductListByServiceResponse page.
func (p *ProductListByServicePager) PageResponse() ProductListByServiceResponse {
	return p.current
}

// ProductListByTagsPager provides operations for iterating over paged responses.
type ProductListByTagsPager struct {
	client    *ProductClient
	current   ProductListByTagsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductListByTagsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductListByTagsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductListByTagsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagResourceCollection.NextLink == nil || len(*p.current.TagResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByTagsHandleError(resp)
		return false
	}
	result, err := p.client.listByTagsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductListByTagsResponse page.
func (p *ProductListByTagsPager) PageResponse() ProductListByTagsResponse {
	return p.current
}

// ProductSubscriptionsListPager provides operations for iterating over paged responses.
type ProductSubscriptionsListPager struct {
	client    *ProductSubscriptionsClient
	current   ProductSubscriptionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductSubscriptionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductSubscriptionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductSubscriptionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionCollection.NextLink == nil || len(*p.current.SubscriptionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductSubscriptionsListResponse page.
func (p *ProductSubscriptionsListPager) PageResponse() ProductSubscriptionsListResponse {
	return p.current
}

// RegionListByServicePager provides operations for iterating over paged responses.
type RegionListByServicePager struct {
	client    *RegionClient
	current   RegionListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegionListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RegionListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RegionListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegionListResult.NextLink == nil || len(*p.current.RegionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RegionListByServiceResponse page.
func (p *RegionListByServicePager) PageResponse() RegionListByServiceResponse {
	return p.current
}

// ReportsListByAPIPager provides operations for iterating over paged responses.
type ReportsListByAPIPager struct {
	client    *ReportsClient
	current   ReportsListByAPIResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsListByAPIResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsListByAPIPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsListByAPIPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAPIHandleError(resp)
		return false
	}
	result, err := p.client.listByAPIHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsListByAPIResponse page.
func (p *ReportsListByAPIPager) PageResponse() ReportsListByAPIResponse {
	return p.current
}

// ReportsListByGeoPager provides operations for iterating over paged responses.
type ReportsListByGeoPager struct {
	client    *ReportsClient
	current   ReportsListByGeoResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsListByGeoResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsListByGeoPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsListByGeoPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByGeoHandleError(resp)
		return false
	}
	result, err := p.client.listByGeoHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsListByGeoResponse page.
func (p *ReportsListByGeoPager) PageResponse() ReportsListByGeoResponse {
	return p.current
}

// ReportsListByOperationPager provides operations for iterating over paged responses.
type ReportsListByOperationPager struct {
	client    *ReportsClient
	current   ReportsListByOperationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsListByOperationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsListByOperationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsListByOperationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByOperationHandleError(resp)
		return false
	}
	result, err := p.client.listByOperationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsListByOperationResponse page.
func (p *ReportsListByOperationPager) PageResponse() ReportsListByOperationResponse {
	return p.current
}

// ReportsListByProductPager provides operations for iterating over paged responses.
type ReportsListByProductPager struct {
	client    *ReportsClient
	current   ReportsListByProductResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsListByProductResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsListByProductPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsListByProductPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByProductHandleError(resp)
		return false
	}
	result, err := p.client.listByProductHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsListByProductResponse page.
func (p *ReportsListByProductPager) PageResponse() ReportsListByProductResponse {
	return p.current
}

// ReportsListBySubscriptionPager provides operations for iterating over paged responses.
type ReportsListBySubscriptionPager struct {
	client    *ReportsClient
	current   ReportsListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsListBySubscriptionResponse page.
func (p *ReportsListBySubscriptionPager) PageResponse() ReportsListBySubscriptionResponse {
	return p.current
}

// ReportsListByTimePager provides operations for iterating over paged responses.
type ReportsListByTimePager struct {
	client    *ReportsClient
	current   ReportsListByTimeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsListByTimeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsListByTimePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsListByTimePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByTimeHandleError(resp)
		return false
	}
	result, err := p.client.listByTimeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsListByTimeResponse page.
func (p *ReportsListByTimePager) PageResponse() ReportsListByTimeResponse {
	return p.current
}

// ReportsListByUserPager provides operations for iterating over paged responses.
type ReportsListByUserPager struct {
	client    *ReportsClient
	current   ReportsListByUserResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsListByUserResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReportsListByUserPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReportsListByUserPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByUserHandleError(resp)
		return false
	}
	result, err := p.client.listByUserHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReportsListByUserResponse page.
func (p *ReportsListByUserPager) PageResponse() ReportsListByUserResponse {
	return p.current
}

// SubscriptionListPager provides operations for iterating over paged responses.
type SubscriptionListPager struct {
	client    *SubscriptionClient
	current   SubscriptionListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubscriptionListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubscriptionListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionCollection.NextLink == nil || len(*p.current.SubscriptionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubscriptionListResponse page.
func (p *SubscriptionListPager) PageResponse() SubscriptionListResponse {
	return p.current
}

// TagListByAPIPager provides operations for iterating over paged responses.
type TagListByAPIPager struct {
	client    *TagClient
	current   TagListByAPIResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagListByAPIResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TagListByAPIPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TagListByAPIPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagCollection.NextLink == nil || len(*p.current.TagCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAPIHandleError(resp)
		return false
	}
	result, err := p.client.listByAPIHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TagListByAPIResponse page.
func (p *TagListByAPIPager) PageResponse() TagListByAPIResponse {
	return p.current
}

// TagListByOperationPager provides operations for iterating over paged responses.
type TagListByOperationPager struct {
	client    *TagClient
	current   TagListByOperationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagListByOperationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TagListByOperationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TagListByOperationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagCollection.NextLink == nil || len(*p.current.TagCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByOperationHandleError(resp)
		return false
	}
	result, err := p.client.listByOperationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TagListByOperationResponse page.
func (p *TagListByOperationPager) PageResponse() TagListByOperationResponse {
	return p.current
}

// TagListByProductPager provides operations for iterating over paged responses.
type TagListByProductPager struct {
	client    *TagClient
	current   TagListByProductResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagListByProductResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TagListByProductPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TagListByProductPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagCollection.NextLink == nil || len(*p.current.TagCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByProductHandleError(resp)
		return false
	}
	result, err := p.client.listByProductHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TagListByProductResponse page.
func (p *TagListByProductPager) PageResponse() TagListByProductResponse {
	return p.current
}

// TagListByServicePager provides operations for iterating over paged responses.
type TagListByServicePager struct {
	client    *TagClient
	current   TagListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TagListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TagListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagCollection.NextLink == nil || len(*p.current.TagCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TagListByServiceResponse page.
func (p *TagListByServicePager) PageResponse() TagListByServiceResponse {
	return p.current
}

// TagResourceListByServicePager provides operations for iterating over paged responses.
type TagResourceListByServicePager struct {
	client    *TagResourceClient
	current   TagResourceListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagResourceListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TagResourceListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TagResourceListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagResourceCollection.NextLink == nil || len(*p.current.TagResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TagResourceListByServiceResponse page.
func (p *TagResourceListByServicePager) PageResponse() TagResourceListByServiceResponse {
	return p.current
}

// TenantAccessListByServicePager provides operations for iterating over paged responses.
type TenantAccessListByServicePager struct {
	client    *TenantAccessClient
	current   TenantAccessListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TenantAccessListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TenantAccessListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TenantAccessListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccessInformationCollection.NextLink == nil || len(*p.current.AccessInformationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TenantAccessListByServiceResponse page.
func (p *TenantAccessListByServicePager) PageResponse() TenantAccessListByServiceResponse {
	return p.current
}

// TenantSettingsListByServicePager provides operations for iterating over paged responses.
type TenantSettingsListByServicePager struct {
	client    *TenantSettingsClient
	current   TenantSettingsListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TenantSettingsListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TenantSettingsListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TenantSettingsListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TenantSettingsCollection.NextLink == nil || len(*p.current.TenantSettingsCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TenantSettingsListByServiceResponse page.
func (p *TenantSettingsListByServicePager) PageResponse() TenantSettingsListByServiceResponse {
	return p.current
}

// UserGroupListPager provides operations for iterating over paged responses.
type UserGroupListPager struct {
	client    *UserGroupClient
	current   UserGroupListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UserGroupListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UserGroupListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UserGroupListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GroupCollection.NextLink == nil || len(*p.current.GroupCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UserGroupListResponse page.
func (p *UserGroupListPager) PageResponse() UserGroupListResponse {
	return p.current
}

// UserIdentitiesListPager provides operations for iterating over paged responses.
type UserIdentitiesListPager struct {
	client    *UserIdentitiesClient
	current   UserIdentitiesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UserIdentitiesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UserIdentitiesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UserIdentitiesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UserIdentityCollection.NextLink == nil || len(*p.current.UserIdentityCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UserIdentitiesListResponse page.
func (p *UserIdentitiesListPager) PageResponse() UserIdentitiesListResponse {
	return p.current
}

// UserListByServicePager provides operations for iterating over paged responses.
type UserListByServicePager struct {
	client    *UserClient
	current   UserListByServiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UserListByServiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UserListByServicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UserListByServicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UserCollection.NextLink == nil || len(*p.current.UserCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServiceHandleError(resp)
		return false
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UserListByServiceResponse page.
func (p *UserListByServicePager) PageResponse() UserListByServiceResponse {
	return p.current
}

// UserSubscriptionListPager provides operations for iterating over paged responses.
type UserSubscriptionListPager struct {
	client    *UserSubscriptionClient
	current   UserSubscriptionListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UserSubscriptionListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UserSubscriptionListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UserSubscriptionListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionCollection.NextLink == nil || len(*p.current.SubscriptionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UserSubscriptionListResponse page.
func (p *UserSubscriptionListPager) PageResponse() UserSubscriptionListResponse {
	return p.current
}
