//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armappplatform

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// APIPortalCustomDomainsClientCreateOrUpdatePollerResponse contains the response from method APIPortalCustomDomainsClient.CreateOrUpdate.
type APIPortalCustomDomainsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *APIPortalCustomDomainsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l APIPortalCustomDomainsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (APIPortalCustomDomainsClientCreateOrUpdateResponse, error) {
	respType := APIPortalCustomDomainsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.APIPortalCustomDomainResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a APIPortalCustomDomainsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *APIPortalCustomDomainsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *APIPortalCustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("APIPortalCustomDomainsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &APIPortalCustomDomainsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// APIPortalCustomDomainsClientCreateOrUpdateResponse contains the response from method APIPortalCustomDomainsClient.CreateOrUpdate.
type APIPortalCustomDomainsClientCreateOrUpdateResponse struct {
	APIPortalCustomDomainsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// APIPortalCustomDomainsClientCreateOrUpdateResult contains the result from method APIPortalCustomDomainsClient.CreateOrUpdate.
type APIPortalCustomDomainsClientCreateOrUpdateResult struct {
	APIPortalCustomDomainResource
}

// APIPortalCustomDomainsClientDeletePollerResponse contains the response from method APIPortalCustomDomainsClient.Delete.
type APIPortalCustomDomainsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *APIPortalCustomDomainsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l APIPortalCustomDomainsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (APIPortalCustomDomainsClientDeleteResponse, error) {
	respType := APIPortalCustomDomainsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a APIPortalCustomDomainsClientDeletePollerResponse from the provided client and resume token.
func (l *APIPortalCustomDomainsClientDeletePollerResponse) Resume(ctx context.Context, client *APIPortalCustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("APIPortalCustomDomainsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &APIPortalCustomDomainsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// APIPortalCustomDomainsClientDeleteResponse contains the response from method APIPortalCustomDomainsClient.Delete.
type APIPortalCustomDomainsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// APIPortalCustomDomainsClientGetResponse contains the response from method APIPortalCustomDomainsClient.Get.
type APIPortalCustomDomainsClientGetResponse struct {
	APIPortalCustomDomainsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// APIPortalCustomDomainsClientGetResult contains the result from method APIPortalCustomDomainsClient.Get.
type APIPortalCustomDomainsClientGetResult struct {
	APIPortalCustomDomainResource
}

// APIPortalCustomDomainsClientListResponse contains the response from method APIPortalCustomDomainsClient.List.
type APIPortalCustomDomainsClientListResponse struct {
	APIPortalCustomDomainsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// APIPortalCustomDomainsClientListResult contains the result from method APIPortalCustomDomainsClient.List.
type APIPortalCustomDomainsClientListResult struct {
	APIPortalCustomDomainResourceCollection
}

// APIPortalsClientCreateOrUpdatePollerResponse contains the response from method APIPortalsClient.CreateOrUpdate.
type APIPortalsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *APIPortalsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l APIPortalsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (APIPortalsClientCreateOrUpdateResponse, error) {
	respType := APIPortalsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.APIPortalResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a APIPortalsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *APIPortalsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *APIPortalsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("APIPortalsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &APIPortalsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// APIPortalsClientCreateOrUpdateResponse contains the response from method APIPortalsClient.CreateOrUpdate.
type APIPortalsClientCreateOrUpdateResponse struct {
	APIPortalsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// APIPortalsClientCreateOrUpdateResult contains the result from method APIPortalsClient.CreateOrUpdate.
type APIPortalsClientCreateOrUpdateResult struct {
	APIPortalResource
}

// APIPortalsClientDeletePollerResponse contains the response from method APIPortalsClient.Delete.
type APIPortalsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *APIPortalsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l APIPortalsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (APIPortalsClientDeleteResponse, error) {
	respType := APIPortalsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a APIPortalsClientDeletePollerResponse from the provided client and resume token.
func (l *APIPortalsClientDeletePollerResponse) Resume(ctx context.Context, client *APIPortalsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("APIPortalsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &APIPortalsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// APIPortalsClientDeleteResponse contains the response from method APIPortalsClient.Delete.
type APIPortalsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// APIPortalsClientGetResponse contains the response from method APIPortalsClient.Get.
type APIPortalsClientGetResponse struct {
	APIPortalsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// APIPortalsClientGetResult contains the result from method APIPortalsClient.Get.
type APIPortalsClientGetResult struct {
	APIPortalResource
}

// APIPortalsClientListResponse contains the response from method APIPortalsClient.List.
type APIPortalsClientListResponse struct {
	APIPortalsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// APIPortalsClientListResult contains the result from method APIPortalsClient.List.
type APIPortalsClientListResult struct {
	APIPortalResourceCollection
}

// APIPortalsClientValidateDomainResponse contains the response from method APIPortalsClient.ValidateDomain.
type APIPortalsClientValidateDomainResponse struct {
	APIPortalsClientValidateDomainResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// APIPortalsClientValidateDomainResult contains the result from method APIPortalsClient.ValidateDomain.
type APIPortalsClientValidateDomainResult struct {
	CustomDomainValidateResult
}

// AppsClientCreateOrUpdatePollerResponse contains the response from method AppsClient.CreateOrUpdate.
type AppsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AppsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AppsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AppsClientCreateOrUpdateResponse, error) {
	respType := AppsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AppResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AppsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AppsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AppsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AppsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AppsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AppsClientCreateOrUpdateResponse contains the response from method AppsClient.CreateOrUpdate.
type AppsClientCreateOrUpdateResponse struct {
	AppsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsClientCreateOrUpdateResult contains the result from method AppsClient.CreateOrUpdate.
type AppsClientCreateOrUpdateResult struct {
	AppResource
}

// AppsClientDeletePollerResponse contains the response from method AppsClient.Delete.
type AppsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AppsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AppsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AppsClientDeleteResponse, error) {
	respType := AppsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AppsClientDeletePollerResponse from the provided client and resume token.
func (l *AppsClientDeletePollerResponse) Resume(ctx context.Context, client *AppsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AppsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AppsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AppsClientDeleteResponse contains the response from method AppsClient.Delete.
type AppsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsClientGetResourceUploadURLResponse contains the response from method AppsClient.GetResourceUploadURL.
type AppsClientGetResourceUploadURLResponse struct {
	AppsClientGetResourceUploadURLResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsClientGetResourceUploadURLResult contains the result from method AppsClient.GetResourceUploadURL.
type AppsClientGetResourceUploadURLResult struct {
	ResourceUploadDefinition
}

// AppsClientGetResponse contains the response from method AppsClient.Get.
type AppsClientGetResponse struct {
	AppsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsClientGetResult contains the result from method AppsClient.Get.
type AppsClientGetResult struct {
	AppResource
}

// AppsClientListResponse contains the response from method AppsClient.List.
type AppsClientListResponse struct {
	AppsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsClientListResult contains the result from method AppsClient.List.
type AppsClientListResult struct {
	AppResourceCollection
}

// AppsClientSetActiveDeploymentsPollerResponse contains the response from method AppsClient.SetActiveDeployments.
type AppsClientSetActiveDeploymentsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AppsClientSetActiveDeploymentsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AppsClientSetActiveDeploymentsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AppsClientSetActiveDeploymentsResponse, error) {
	respType := AppsClientSetActiveDeploymentsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AppResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AppsClientSetActiveDeploymentsPollerResponse from the provided client and resume token.
func (l *AppsClientSetActiveDeploymentsPollerResponse) Resume(ctx context.Context, client *AppsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AppsClient.SetActiveDeployments", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AppsClientSetActiveDeploymentsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AppsClientSetActiveDeploymentsResponse contains the response from method AppsClient.SetActiveDeployments.
type AppsClientSetActiveDeploymentsResponse struct {
	AppsClientSetActiveDeploymentsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsClientSetActiveDeploymentsResult contains the result from method AppsClient.SetActiveDeployments.
type AppsClientSetActiveDeploymentsResult struct {
	AppResource
}

// AppsClientUpdatePollerResponse contains the response from method AppsClient.Update.
type AppsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AppsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AppsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AppsClientUpdateResponse, error) {
	respType := AppsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AppResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AppsClientUpdatePollerResponse from the provided client and resume token.
func (l *AppsClientUpdatePollerResponse) Resume(ctx context.Context, client *AppsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AppsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AppsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AppsClientUpdateResponse contains the response from method AppsClient.Update.
type AppsClientUpdateResponse struct {
	AppsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsClientUpdateResult contains the result from method AppsClient.Update.
type AppsClientUpdateResult struct {
	AppResource
}

// AppsClientValidateDomainResponse contains the response from method AppsClient.ValidateDomain.
type AppsClientValidateDomainResponse struct {
	AppsClientValidateDomainResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsClientValidateDomainResult contains the result from method AppsClient.ValidateDomain.
type AppsClientValidateDomainResult struct {
	CustomDomainValidateResult
}

// BindingsClientCreateOrUpdatePollerResponse contains the response from method BindingsClient.CreateOrUpdate.
type BindingsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BindingsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BindingsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BindingsClientCreateOrUpdateResponse, error) {
	respType := BindingsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BindingResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BindingsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *BindingsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *BindingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BindingsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &BindingsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BindingsClientCreateOrUpdateResponse contains the response from method BindingsClient.CreateOrUpdate.
type BindingsClientCreateOrUpdateResponse struct {
	BindingsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BindingsClientCreateOrUpdateResult contains the result from method BindingsClient.CreateOrUpdate.
type BindingsClientCreateOrUpdateResult struct {
	BindingResource
}

// BindingsClientDeletePollerResponse contains the response from method BindingsClient.Delete.
type BindingsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BindingsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BindingsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BindingsClientDeleteResponse, error) {
	respType := BindingsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BindingsClientDeletePollerResponse from the provided client and resume token.
func (l *BindingsClientDeletePollerResponse) Resume(ctx context.Context, client *BindingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BindingsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &BindingsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BindingsClientDeleteResponse contains the response from method BindingsClient.Delete.
type BindingsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BindingsClientGetResponse contains the response from method BindingsClient.Get.
type BindingsClientGetResponse struct {
	BindingsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BindingsClientGetResult contains the result from method BindingsClient.Get.
type BindingsClientGetResult struct {
	BindingResource
}

// BindingsClientListResponse contains the response from method BindingsClient.List.
type BindingsClientListResponse struct {
	BindingsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BindingsClientListResult contains the result from method BindingsClient.List.
type BindingsClientListResult struct {
	BindingResourceCollection
}

// BindingsClientUpdatePollerResponse contains the response from method BindingsClient.Update.
type BindingsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BindingsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BindingsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BindingsClientUpdateResponse, error) {
	respType := BindingsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BindingResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BindingsClientUpdatePollerResponse from the provided client and resume token.
func (l *BindingsClientUpdatePollerResponse) Resume(ctx context.Context, client *BindingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BindingsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &BindingsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BindingsClientUpdateResponse contains the response from method BindingsClient.Update.
type BindingsClientUpdateResponse struct {
	BindingsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BindingsClientUpdateResult contains the result from method BindingsClient.Update.
type BindingsClientUpdateResult struct {
	BindingResource
}

// BuildServiceAgentPoolClientGetResponse contains the response from method BuildServiceAgentPoolClient.Get.
type BuildServiceAgentPoolClientGetResponse struct {
	BuildServiceAgentPoolClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceAgentPoolClientGetResult contains the result from method BuildServiceAgentPoolClient.Get.
type BuildServiceAgentPoolClientGetResult struct {
	BuildServiceAgentPoolResource
}

// BuildServiceAgentPoolClientListResponse contains the response from method BuildServiceAgentPoolClient.List.
type BuildServiceAgentPoolClientListResponse struct {
	BuildServiceAgentPoolClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceAgentPoolClientListResult contains the result from method BuildServiceAgentPoolClient.List.
type BuildServiceAgentPoolClientListResult struct {
	BuildServiceAgentPoolResourceCollection
}

// BuildServiceAgentPoolClientUpdatePutPollerResponse contains the response from method BuildServiceAgentPoolClient.UpdatePut.
type BuildServiceAgentPoolClientUpdatePutPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BuildServiceAgentPoolClientUpdatePutPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BuildServiceAgentPoolClientUpdatePutPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BuildServiceAgentPoolClientUpdatePutResponse, error) {
	respType := BuildServiceAgentPoolClientUpdatePutResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BuildServiceAgentPoolResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BuildServiceAgentPoolClientUpdatePutPollerResponse from the provided client and resume token.
func (l *BuildServiceAgentPoolClientUpdatePutPollerResponse) Resume(ctx context.Context, client *BuildServiceAgentPoolClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BuildServiceAgentPoolClient.UpdatePut", token, client.pl)
	if err != nil {
		return err
	}
	poller := &BuildServiceAgentPoolClientUpdatePutPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BuildServiceAgentPoolClientUpdatePutResponse contains the response from method BuildServiceAgentPoolClient.UpdatePut.
type BuildServiceAgentPoolClientUpdatePutResponse struct {
	BuildServiceAgentPoolClientUpdatePutResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceAgentPoolClientUpdatePutResult contains the result from method BuildServiceAgentPoolClient.UpdatePut.
type BuildServiceAgentPoolClientUpdatePutResult struct {
	BuildServiceAgentPoolResource
}

// BuildServiceBuilderClientCreateOrUpdatePollerResponse contains the response from method BuildServiceBuilderClient.CreateOrUpdate.
type BuildServiceBuilderClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BuildServiceBuilderClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BuildServiceBuilderClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BuildServiceBuilderClientCreateOrUpdateResponse, error) {
	respType := BuildServiceBuilderClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BuilderResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BuildServiceBuilderClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *BuildServiceBuilderClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *BuildServiceBuilderClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BuildServiceBuilderClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &BuildServiceBuilderClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BuildServiceBuilderClientCreateOrUpdateResponse contains the response from method BuildServiceBuilderClient.CreateOrUpdate.
type BuildServiceBuilderClientCreateOrUpdateResponse struct {
	BuildServiceBuilderClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceBuilderClientCreateOrUpdateResult contains the result from method BuildServiceBuilderClient.CreateOrUpdate.
type BuildServiceBuilderClientCreateOrUpdateResult struct {
	BuilderResource
}

// BuildServiceBuilderClientDeletePollerResponse contains the response from method BuildServiceBuilderClient.Delete.
type BuildServiceBuilderClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BuildServiceBuilderClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BuildServiceBuilderClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BuildServiceBuilderClientDeleteResponse, error) {
	respType := BuildServiceBuilderClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BuildServiceBuilderClientDeletePollerResponse from the provided client and resume token.
func (l *BuildServiceBuilderClientDeletePollerResponse) Resume(ctx context.Context, client *BuildServiceBuilderClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BuildServiceBuilderClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &BuildServiceBuilderClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BuildServiceBuilderClientDeleteResponse contains the response from method BuildServiceBuilderClient.Delete.
type BuildServiceBuilderClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceBuilderClientGetResponse contains the response from method BuildServiceBuilderClient.Get.
type BuildServiceBuilderClientGetResponse struct {
	BuildServiceBuilderClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceBuilderClientGetResult contains the result from method BuildServiceBuilderClient.Get.
type BuildServiceBuilderClientGetResult struct {
	BuilderResource
}

// BuildServiceBuilderClientListResponse contains the response from method BuildServiceBuilderClient.List.
type BuildServiceBuilderClientListResponse struct {
	BuildServiceBuilderClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceBuilderClientListResult contains the result from method BuildServiceBuilderClient.List.
type BuildServiceBuilderClientListResult struct {
	BuilderResourceCollection
}

// BuildServiceClientCreateOrUpdateBuildResponse contains the response from method BuildServiceClient.CreateOrUpdateBuild.
type BuildServiceClientCreateOrUpdateBuildResponse struct {
	BuildServiceClientCreateOrUpdateBuildResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientCreateOrUpdateBuildResult contains the result from method BuildServiceClient.CreateOrUpdateBuild.
type BuildServiceClientCreateOrUpdateBuildResult struct {
	Build
}

// BuildServiceClientGetBuildResponse contains the response from method BuildServiceClient.GetBuild.
type BuildServiceClientGetBuildResponse struct {
	BuildServiceClientGetBuildResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientGetBuildResult contains the result from method BuildServiceClient.GetBuild.
type BuildServiceClientGetBuildResult struct {
	Build
}

// BuildServiceClientGetBuildResultLogResponse contains the response from method BuildServiceClient.GetBuildResultLog.
type BuildServiceClientGetBuildResultLogResponse struct {
	BuildServiceClientGetBuildResultLogResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientGetBuildResultLogResult contains the result from method BuildServiceClient.GetBuildResultLog.
type BuildServiceClientGetBuildResultLogResult struct {
	BuildResultLog
}

// BuildServiceClientGetBuildResultResponse contains the response from method BuildServiceClient.GetBuildResult.
type BuildServiceClientGetBuildResultResponse struct {
	BuildServiceClientGetBuildResultResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientGetBuildResultResult contains the result from method BuildServiceClient.GetBuildResult.
type BuildServiceClientGetBuildResultResult struct {
	BuildResult
}

// BuildServiceClientGetBuildServiceResponse contains the response from method BuildServiceClient.GetBuildService.
type BuildServiceClientGetBuildServiceResponse struct {
	BuildServiceClientGetBuildServiceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientGetBuildServiceResult contains the result from method BuildServiceClient.GetBuildService.
type BuildServiceClientGetBuildServiceResult struct {
	BuildService
}

// BuildServiceClientGetResourceUploadURLResponse contains the response from method BuildServiceClient.GetResourceUploadURL.
type BuildServiceClientGetResourceUploadURLResponse struct {
	BuildServiceClientGetResourceUploadURLResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientGetResourceUploadURLResult contains the result from method BuildServiceClient.GetResourceUploadURL.
type BuildServiceClientGetResourceUploadURLResult struct {
	ResourceUploadDefinition
}

// BuildServiceClientGetSupportedBuildpackResponse contains the response from method BuildServiceClient.GetSupportedBuildpack.
type BuildServiceClientGetSupportedBuildpackResponse struct {
	BuildServiceClientGetSupportedBuildpackResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientGetSupportedBuildpackResult contains the result from method BuildServiceClient.GetSupportedBuildpack.
type BuildServiceClientGetSupportedBuildpackResult struct {
	SupportedBuildpackResource
}

// BuildServiceClientGetSupportedStackResponse contains the response from method BuildServiceClient.GetSupportedStack.
type BuildServiceClientGetSupportedStackResponse struct {
	BuildServiceClientGetSupportedStackResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientGetSupportedStackResult contains the result from method BuildServiceClient.GetSupportedStack.
type BuildServiceClientGetSupportedStackResult struct {
	SupportedStackResource
}

// BuildServiceClientListBuildResultsResponse contains the response from method BuildServiceClient.ListBuildResults.
type BuildServiceClientListBuildResultsResponse struct {
	BuildServiceClientListBuildResultsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientListBuildResultsResult contains the result from method BuildServiceClient.ListBuildResults.
type BuildServiceClientListBuildResultsResult struct {
	BuildResultCollection
}

// BuildServiceClientListBuildServicesResponse contains the response from method BuildServiceClient.ListBuildServices.
type BuildServiceClientListBuildServicesResponse struct {
	BuildServiceClientListBuildServicesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientListBuildServicesResult contains the result from method BuildServiceClient.ListBuildServices.
type BuildServiceClientListBuildServicesResult struct {
	BuildServiceCollection
}

// BuildServiceClientListBuildsResponse contains the response from method BuildServiceClient.ListBuilds.
type BuildServiceClientListBuildsResponse struct {
	BuildServiceClientListBuildsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientListBuildsResult contains the result from method BuildServiceClient.ListBuilds.
type BuildServiceClientListBuildsResult struct {
	BuildCollection
}

// BuildServiceClientListSupportedBuildpacksResponse contains the response from method BuildServiceClient.ListSupportedBuildpacks.
type BuildServiceClientListSupportedBuildpacksResponse struct {
	BuildServiceClientListSupportedBuildpacksResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientListSupportedBuildpacksResult contains the result from method BuildServiceClient.ListSupportedBuildpacks.
type BuildServiceClientListSupportedBuildpacksResult struct {
	SupportedBuildpacksCollection
}

// BuildServiceClientListSupportedStacksResponse contains the response from method BuildServiceClient.ListSupportedStacks.
type BuildServiceClientListSupportedStacksResponse struct {
	BuildServiceClientListSupportedStacksResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildServiceClientListSupportedStacksResult contains the result from method BuildServiceClient.ListSupportedStacks.
type BuildServiceClientListSupportedStacksResult struct {
	SupportedStacksCollection
}

// BuildpackBindingClientCreateOrUpdatePollerResponse contains the response from method BuildpackBindingClient.CreateOrUpdate.
type BuildpackBindingClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BuildpackBindingClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BuildpackBindingClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BuildpackBindingClientCreateOrUpdateResponse, error) {
	respType := BuildpackBindingClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BuildpackBindingResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BuildpackBindingClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *BuildpackBindingClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *BuildpackBindingClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BuildpackBindingClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &BuildpackBindingClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BuildpackBindingClientCreateOrUpdateResponse contains the response from method BuildpackBindingClient.CreateOrUpdate.
type BuildpackBindingClientCreateOrUpdateResponse struct {
	BuildpackBindingClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildpackBindingClientCreateOrUpdateResult contains the result from method BuildpackBindingClient.CreateOrUpdate.
type BuildpackBindingClientCreateOrUpdateResult struct {
	BuildpackBindingResource
}

// BuildpackBindingClientDeletePollerResponse contains the response from method BuildpackBindingClient.Delete.
type BuildpackBindingClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BuildpackBindingClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BuildpackBindingClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BuildpackBindingClientDeleteResponse, error) {
	respType := BuildpackBindingClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BuildpackBindingClientDeletePollerResponse from the provided client and resume token.
func (l *BuildpackBindingClientDeletePollerResponse) Resume(ctx context.Context, client *BuildpackBindingClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BuildpackBindingClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &BuildpackBindingClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BuildpackBindingClientDeleteResponse contains the response from method BuildpackBindingClient.Delete.
type BuildpackBindingClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildpackBindingClientGetResponse contains the response from method BuildpackBindingClient.Get.
type BuildpackBindingClientGetResponse struct {
	BuildpackBindingClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildpackBindingClientGetResult contains the result from method BuildpackBindingClient.Get.
type BuildpackBindingClientGetResult struct {
	BuildpackBindingResource
}

// BuildpackBindingClientListResponse contains the response from method BuildpackBindingClient.List.
type BuildpackBindingClientListResponse struct {
	BuildpackBindingClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BuildpackBindingClientListResult contains the result from method BuildpackBindingClient.List.
type BuildpackBindingClientListResult struct {
	BuildpackBindingResourceCollection
}

// CertificatesClientCreateOrUpdatePollerResponse contains the response from method CertificatesClient.CreateOrUpdate.
type CertificatesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CertificatesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CertificatesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CertificatesClientCreateOrUpdateResponse, error) {
	respType := CertificatesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CertificateResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CertificatesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *CertificatesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *CertificatesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CertificatesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &CertificatesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CertificatesClientCreateOrUpdateResponse contains the response from method CertificatesClient.CreateOrUpdate.
type CertificatesClientCreateOrUpdateResponse struct {
	CertificatesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CertificatesClientCreateOrUpdateResult contains the result from method CertificatesClient.CreateOrUpdate.
type CertificatesClientCreateOrUpdateResult struct {
	CertificateResource
}

// CertificatesClientDeletePollerResponse contains the response from method CertificatesClient.Delete.
type CertificatesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CertificatesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CertificatesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CertificatesClientDeleteResponse, error) {
	respType := CertificatesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CertificatesClientDeletePollerResponse from the provided client and resume token.
func (l *CertificatesClientDeletePollerResponse) Resume(ctx context.Context, client *CertificatesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CertificatesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &CertificatesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CertificatesClientDeleteResponse contains the response from method CertificatesClient.Delete.
type CertificatesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CertificatesClientGetResponse contains the response from method CertificatesClient.Get.
type CertificatesClientGetResponse struct {
	CertificatesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CertificatesClientGetResult contains the result from method CertificatesClient.Get.
type CertificatesClientGetResult struct {
	CertificateResource
}

// CertificatesClientListResponse contains the response from method CertificatesClient.List.
type CertificatesClientListResponse struct {
	CertificatesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CertificatesClientListResult contains the result from method CertificatesClient.List.
type CertificatesClientListResult struct {
	CertificateResourceCollection
}

// ConfigServersClientGetResponse contains the response from method ConfigServersClient.Get.
type ConfigServersClientGetResponse struct {
	ConfigServersClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigServersClientGetResult contains the result from method ConfigServersClient.Get.
type ConfigServersClientGetResult struct {
	ConfigServerResource
}

// ConfigServersClientUpdatePatchPollerResponse contains the response from method ConfigServersClient.UpdatePatch.
type ConfigServersClientUpdatePatchPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConfigServersClientUpdatePatchPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConfigServersClientUpdatePatchPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConfigServersClientUpdatePatchResponse, error) {
	respType := ConfigServersClientUpdatePatchResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConfigServerResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConfigServersClientUpdatePatchPollerResponse from the provided client and resume token.
func (l *ConfigServersClientUpdatePatchPollerResponse) Resume(ctx context.Context, client *ConfigServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConfigServersClient.UpdatePatch", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ConfigServersClientUpdatePatchPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConfigServersClientUpdatePatchResponse contains the response from method ConfigServersClient.UpdatePatch.
type ConfigServersClientUpdatePatchResponse struct {
	ConfigServersClientUpdatePatchResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigServersClientUpdatePatchResult contains the result from method ConfigServersClient.UpdatePatch.
type ConfigServersClientUpdatePatchResult struct {
	ConfigServerResource
}

// ConfigServersClientUpdatePutPollerResponse contains the response from method ConfigServersClient.UpdatePut.
type ConfigServersClientUpdatePutPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConfigServersClientUpdatePutPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConfigServersClientUpdatePutPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConfigServersClientUpdatePutResponse, error) {
	respType := ConfigServersClientUpdatePutResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConfigServerResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConfigServersClientUpdatePutPollerResponse from the provided client and resume token.
func (l *ConfigServersClientUpdatePutPollerResponse) Resume(ctx context.Context, client *ConfigServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConfigServersClient.UpdatePut", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ConfigServersClientUpdatePutPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConfigServersClientUpdatePutResponse contains the response from method ConfigServersClient.UpdatePut.
type ConfigServersClientUpdatePutResponse struct {
	ConfigServersClientUpdatePutResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigServersClientUpdatePutResult contains the result from method ConfigServersClient.UpdatePut.
type ConfigServersClientUpdatePutResult struct {
	ConfigServerResource
}

// ConfigServersClientValidatePollerResponse contains the response from method ConfigServersClient.Validate.
type ConfigServersClientValidatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConfigServersClientValidatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConfigServersClientValidatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConfigServersClientValidateResponse, error) {
	respType := ConfigServersClientValidateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConfigServerSettingsValidateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConfigServersClientValidatePollerResponse from the provided client and resume token.
func (l *ConfigServersClientValidatePollerResponse) Resume(ctx context.Context, client *ConfigServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConfigServersClient.Validate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ConfigServersClientValidatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConfigServersClientValidateResponse contains the response from method ConfigServersClient.Validate.
type ConfigServersClientValidateResponse struct {
	ConfigServersClientValidateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigServersClientValidateResult contains the result from method ConfigServersClient.Validate.
type ConfigServersClientValidateResult struct {
	ConfigServerSettingsValidateResult
}

// ConfigurationServicesClientCreateOrUpdatePollerResponse contains the response from method ConfigurationServicesClient.CreateOrUpdate.
type ConfigurationServicesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConfigurationServicesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConfigurationServicesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConfigurationServicesClientCreateOrUpdateResponse, error) {
	respType := ConfigurationServicesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConfigurationServiceResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConfigurationServicesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ConfigurationServicesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ConfigurationServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConfigurationServicesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ConfigurationServicesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConfigurationServicesClientCreateOrUpdateResponse contains the response from method ConfigurationServicesClient.CreateOrUpdate.
type ConfigurationServicesClientCreateOrUpdateResponse struct {
	ConfigurationServicesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationServicesClientCreateOrUpdateResult contains the result from method ConfigurationServicesClient.CreateOrUpdate.
type ConfigurationServicesClientCreateOrUpdateResult struct {
	ConfigurationServiceResource
}

// ConfigurationServicesClientDeletePollerResponse contains the response from method ConfigurationServicesClient.Delete.
type ConfigurationServicesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConfigurationServicesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConfigurationServicesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConfigurationServicesClientDeleteResponse, error) {
	respType := ConfigurationServicesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConfigurationServicesClientDeletePollerResponse from the provided client and resume token.
func (l *ConfigurationServicesClientDeletePollerResponse) Resume(ctx context.Context, client *ConfigurationServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConfigurationServicesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ConfigurationServicesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConfigurationServicesClientDeleteResponse contains the response from method ConfigurationServicesClient.Delete.
type ConfigurationServicesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationServicesClientGetResponse contains the response from method ConfigurationServicesClient.Get.
type ConfigurationServicesClientGetResponse struct {
	ConfigurationServicesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationServicesClientGetResult contains the result from method ConfigurationServicesClient.Get.
type ConfigurationServicesClientGetResult struct {
	ConfigurationServiceResource
}

// ConfigurationServicesClientListResponse contains the response from method ConfigurationServicesClient.List.
type ConfigurationServicesClientListResponse struct {
	ConfigurationServicesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationServicesClientListResult contains the result from method ConfigurationServicesClient.List.
type ConfigurationServicesClientListResult struct {
	ConfigurationServiceResourceCollection
}

// ConfigurationServicesClientValidatePollerResponse contains the response from method ConfigurationServicesClient.Validate.
type ConfigurationServicesClientValidatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConfigurationServicesClientValidatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConfigurationServicesClientValidatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConfigurationServicesClientValidateResponse, error) {
	respType := ConfigurationServicesClientValidateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConfigurationServiceSettingsValidateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConfigurationServicesClientValidatePollerResponse from the provided client and resume token.
func (l *ConfigurationServicesClientValidatePollerResponse) Resume(ctx context.Context, client *ConfigurationServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConfigurationServicesClient.Validate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ConfigurationServicesClientValidatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConfigurationServicesClientValidateResponse contains the response from method ConfigurationServicesClient.Validate.
type ConfigurationServicesClientValidateResponse struct {
	ConfigurationServicesClientValidateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationServicesClientValidateResult contains the result from method ConfigurationServicesClient.Validate.
type ConfigurationServicesClientValidateResult struct {
	ConfigurationServiceSettingsValidateResult
}

// CustomDomainsClientCreateOrUpdatePollerResponse contains the response from method CustomDomainsClient.CreateOrUpdate.
type CustomDomainsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomDomainsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomDomainsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsClientCreateOrUpdateResponse, error) {
	respType := CustomDomainsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomDomainResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomDomainsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *CustomDomainsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *CustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomDomainsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &CustomDomainsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomDomainsClientCreateOrUpdateResponse contains the response from method CustomDomainsClient.CreateOrUpdate.
type CustomDomainsClientCreateOrUpdateResponse struct {
	CustomDomainsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsClientCreateOrUpdateResult contains the result from method CustomDomainsClient.CreateOrUpdate.
type CustomDomainsClientCreateOrUpdateResult struct {
	CustomDomainResource
}

// CustomDomainsClientDeletePollerResponse contains the response from method CustomDomainsClient.Delete.
type CustomDomainsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomDomainsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomDomainsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsClientDeleteResponse, error) {
	respType := CustomDomainsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomDomainsClientDeletePollerResponse from the provided client and resume token.
func (l *CustomDomainsClientDeletePollerResponse) Resume(ctx context.Context, client *CustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomDomainsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &CustomDomainsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomDomainsClientDeleteResponse contains the response from method CustomDomainsClient.Delete.
type CustomDomainsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsClientGetResponse contains the response from method CustomDomainsClient.Get.
type CustomDomainsClientGetResponse struct {
	CustomDomainsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsClientGetResult contains the result from method CustomDomainsClient.Get.
type CustomDomainsClientGetResult struct {
	CustomDomainResource
}

// CustomDomainsClientListResponse contains the response from method CustomDomainsClient.List.
type CustomDomainsClientListResponse struct {
	CustomDomainsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsClientListResult contains the result from method CustomDomainsClient.List.
type CustomDomainsClientListResult struct {
	CustomDomainResourceCollection
}

// CustomDomainsClientUpdatePollerResponse contains the response from method CustomDomainsClient.Update.
type CustomDomainsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomDomainsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomDomainsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsClientUpdateResponse, error) {
	respType := CustomDomainsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomDomainResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomDomainsClientUpdatePollerResponse from the provided client and resume token.
func (l *CustomDomainsClientUpdatePollerResponse) Resume(ctx context.Context, client *CustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomDomainsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &CustomDomainsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomDomainsClientUpdateResponse contains the response from method CustomDomainsClient.Update.
type CustomDomainsClientUpdateResponse struct {
	CustomDomainsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsClientUpdateResult contains the result from method CustomDomainsClient.Update.
type CustomDomainsClientUpdateResult struct {
	CustomDomainResource
}

// DeploymentsClientCreateOrUpdatePollerResponse contains the response from method DeploymentsClient.CreateOrUpdate.
type DeploymentsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsClientCreateOrUpdateResponse, error) {
	respType := DeploymentsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DeploymentsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DeploymentsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsClientCreateOrUpdateResponse contains the response from method DeploymentsClient.CreateOrUpdate.
type DeploymentsClientCreateOrUpdateResponse struct {
	DeploymentsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientCreateOrUpdateResult contains the result from method DeploymentsClient.CreateOrUpdate.
type DeploymentsClientCreateOrUpdateResult struct {
	DeploymentResource
}

// DeploymentsClientDeletePollerResponse contains the response from method DeploymentsClient.Delete.
type DeploymentsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsClientDeleteResponse, error) {
	respType := DeploymentsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsClientDeletePollerResponse from the provided client and resume token.
func (l *DeploymentsClientDeletePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DeploymentsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsClientDeleteResponse contains the response from method DeploymentsClient.Delete.
type DeploymentsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientGenerateHeapDumpPollerResponse contains the response from method DeploymentsClient.GenerateHeapDump.
type DeploymentsClientGenerateHeapDumpPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsClientGenerateHeapDumpPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsClientGenerateHeapDumpPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsClientGenerateHeapDumpResponse, error) {
	respType := DeploymentsClientGenerateHeapDumpResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsClientGenerateHeapDumpPollerResponse from the provided client and resume token.
func (l *DeploymentsClientGenerateHeapDumpPollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.GenerateHeapDump", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DeploymentsClientGenerateHeapDumpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsClientGenerateHeapDumpResponse contains the response from method DeploymentsClient.GenerateHeapDump.
type DeploymentsClientGenerateHeapDumpResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientGenerateThreadDumpPollerResponse contains the response from method DeploymentsClient.GenerateThreadDump.
type DeploymentsClientGenerateThreadDumpPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsClientGenerateThreadDumpPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsClientGenerateThreadDumpPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsClientGenerateThreadDumpResponse, error) {
	respType := DeploymentsClientGenerateThreadDumpResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsClientGenerateThreadDumpPollerResponse from the provided client and resume token.
func (l *DeploymentsClientGenerateThreadDumpPollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.GenerateThreadDump", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DeploymentsClientGenerateThreadDumpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsClientGenerateThreadDumpResponse contains the response from method DeploymentsClient.GenerateThreadDump.
type DeploymentsClientGenerateThreadDumpResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientGetLogFileURLResponse contains the response from method DeploymentsClient.GetLogFileURL.
type DeploymentsClientGetLogFileURLResponse struct {
	DeploymentsClientGetLogFileURLResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientGetLogFileURLResult contains the result from method DeploymentsClient.GetLogFileURL.
type DeploymentsClientGetLogFileURLResult struct {
	LogFileURLResponse
}

// DeploymentsClientGetResponse contains the response from method DeploymentsClient.Get.
type DeploymentsClientGetResponse struct {
	DeploymentsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientGetResult contains the result from method DeploymentsClient.Get.
type DeploymentsClientGetResult struct {
	DeploymentResource
}

// DeploymentsClientListForClusterResponse contains the response from method DeploymentsClient.ListForCluster.
type DeploymentsClientListForClusterResponse struct {
	DeploymentsClientListForClusterResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientListForClusterResult contains the result from method DeploymentsClient.ListForCluster.
type DeploymentsClientListForClusterResult struct {
	DeploymentResourceCollection
}

// DeploymentsClientListResponse contains the response from method DeploymentsClient.List.
type DeploymentsClientListResponse struct {
	DeploymentsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientListResult contains the result from method DeploymentsClient.List.
type DeploymentsClientListResult struct {
	DeploymentResourceCollection
}

// DeploymentsClientRestartPollerResponse contains the response from method DeploymentsClient.Restart.
type DeploymentsClientRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsClientRestartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsClientRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsClientRestartResponse, error) {
	respType := DeploymentsClientRestartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsClientRestartPollerResponse from the provided client and resume token.
func (l *DeploymentsClientRestartPollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.Restart", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DeploymentsClientRestartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsClientRestartResponse contains the response from method DeploymentsClient.Restart.
type DeploymentsClientRestartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientStartJFRPollerResponse contains the response from method DeploymentsClient.StartJFR.
type DeploymentsClientStartJFRPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsClientStartJFRPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsClientStartJFRPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsClientStartJFRResponse, error) {
	respType := DeploymentsClientStartJFRResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsClientStartJFRPollerResponse from the provided client and resume token.
func (l *DeploymentsClientStartJFRPollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.StartJFR", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DeploymentsClientStartJFRPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsClientStartJFRResponse contains the response from method DeploymentsClient.StartJFR.
type DeploymentsClientStartJFRResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientStartPollerResponse contains the response from method DeploymentsClient.Start.
type DeploymentsClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsClientStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsClientStartResponse, error) {
	respType := DeploymentsClientStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsClientStartPollerResponse from the provided client and resume token.
func (l *DeploymentsClientStartPollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DeploymentsClientStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsClientStartResponse contains the response from method DeploymentsClient.Start.
type DeploymentsClientStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientStopPollerResponse contains the response from method DeploymentsClient.Stop.
type DeploymentsClientStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsClientStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsClientStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsClientStopResponse, error) {
	respType := DeploymentsClientStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsClientStopPollerResponse from the provided client and resume token.
func (l *DeploymentsClientStopPollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.Stop", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DeploymentsClientStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsClientStopResponse contains the response from method DeploymentsClient.Stop.
type DeploymentsClientStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientUpdatePollerResponse contains the response from method DeploymentsClient.Update.
type DeploymentsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsClientUpdateResponse, error) {
	respType := DeploymentsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsClientUpdatePollerResponse from the provided client and resume token.
func (l *DeploymentsClientUpdatePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DeploymentsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsClientUpdateResponse contains the response from method DeploymentsClient.Update.
type DeploymentsClientUpdateResponse struct {
	DeploymentsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsClientUpdateResult contains the result from method DeploymentsClient.Update.
type DeploymentsClientUpdateResult struct {
	DeploymentResource
}

// GatewayCustomDomainsClientCreateOrUpdatePollerResponse contains the response from method GatewayCustomDomainsClient.CreateOrUpdate.
type GatewayCustomDomainsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GatewayCustomDomainsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GatewayCustomDomainsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GatewayCustomDomainsClientCreateOrUpdateResponse, error) {
	respType := GatewayCustomDomainsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GatewayCustomDomainResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GatewayCustomDomainsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *GatewayCustomDomainsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *GatewayCustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GatewayCustomDomainsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GatewayCustomDomainsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GatewayCustomDomainsClientCreateOrUpdateResponse contains the response from method GatewayCustomDomainsClient.CreateOrUpdate.
type GatewayCustomDomainsClientCreateOrUpdateResponse struct {
	GatewayCustomDomainsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewayCustomDomainsClientCreateOrUpdateResult contains the result from method GatewayCustomDomainsClient.CreateOrUpdate.
type GatewayCustomDomainsClientCreateOrUpdateResult struct {
	GatewayCustomDomainResource
}

// GatewayCustomDomainsClientDeletePollerResponse contains the response from method GatewayCustomDomainsClient.Delete.
type GatewayCustomDomainsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GatewayCustomDomainsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GatewayCustomDomainsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GatewayCustomDomainsClientDeleteResponse, error) {
	respType := GatewayCustomDomainsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GatewayCustomDomainsClientDeletePollerResponse from the provided client and resume token.
func (l *GatewayCustomDomainsClientDeletePollerResponse) Resume(ctx context.Context, client *GatewayCustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GatewayCustomDomainsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GatewayCustomDomainsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GatewayCustomDomainsClientDeleteResponse contains the response from method GatewayCustomDomainsClient.Delete.
type GatewayCustomDomainsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewayCustomDomainsClientGetResponse contains the response from method GatewayCustomDomainsClient.Get.
type GatewayCustomDomainsClientGetResponse struct {
	GatewayCustomDomainsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewayCustomDomainsClientGetResult contains the result from method GatewayCustomDomainsClient.Get.
type GatewayCustomDomainsClientGetResult struct {
	GatewayCustomDomainResource
}

// GatewayCustomDomainsClientListResponse contains the response from method GatewayCustomDomainsClient.List.
type GatewayCustomDomainsClientListResponse struct {
	GatewayCustomDomainsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewayCustomDomainsClientListResult contains the result from method GatewayCustomDomainsClient.List.
type GatewayCustomDomainsClientListResult struct {
	GatewayCustomDomainResourceCollection
}

// GatewayRouteConfigsClientCreateOrUpdatePollerResponse contains the response from method GatewayRouteConfigsClient.CreateOrUpdate.
type GatewayRouteConfigsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GatewayRouteConfigsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GatewayRouteConfigsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GatewayRouteConfigsClientCreateOrUpdateResponse, error) {
	respType := GatewayRouteConfigsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GatewayRouteConfigResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GatewayRouteConfigsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *GatewayRouteConfigsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *GatewayRouteConfigsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GatewayRouteConfigsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GatewayRouteConfigsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GatewayRouteConfigsClientCreateOrUpdateResponse contains the response from method GatewayRouteConfigsClient.CreateOrUpdate.
type GatewayRouteConfigsClientCreateOrUpdateResponse struct {
	GatewayRouteConfigsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewayRouteConfigsClientCreateOrUpdateResult contains the result from method GatewayRouteConfigsClient.CreateOrUpdate.
type GatewayRouteConfigsClientCreateOrUpdateResult struct {
	GatewayRouteConfigResource
}

// GatewayRouteConfigsClientDeletePollerResponse contains the response from method GatewayRouteConfigsClient.Delete.
type GatewayRouteConfigsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GatewayRouteConfigsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GatewayRouteConfigsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GatewayRouteConfigsClientDeleteResponse, error) {
	respType := GatewayRouteConfigsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GatewayRouteConfigsClientDeletePollerResponse from the provided client and resume token.
func (l *GatewayRouteConfigsClientDeletePollerResponse) Resume(ctx context.Context, client *GatewayRouteConfigsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GatewayRouteConfigsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GatewayRouteConfigsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GatewayRouteConfigsClientDeleteResponse contains the response from method GatewayRouteConfigsClient.Delete.
type GatewayRouteConfigsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewayRouteConfigsClientGetResponse contains the response from method GatewayRouteConfigsClient.Get.
type GatewayRouteConfigsClientGetResponse struct {
	GatewayRouteConfigsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewayRouteConfigsClientGetResult contains the result from method GatewayRouteConfigsClient.Get.
type GatewayRouteConfigsClientGetResult struct {
	GatewayRouteConfigResource
}

// GatewayRouteConfigsClientListResponse contains the response from method GatewayRouteConfigsClient.List.
type GatewayRouteConfigsClientListResponse struct {
	GatewayRouteConfigsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewayRouteConfigsClientListResult contains the result from method GatewayRouteConfigsClient.List.
type GatewayRouteConfigsClientListResult struct {
	GatewayRouteConfigResourceCollection
}

// GatewaysClientCreateOrUpdatePollerResponse contains the response from method GatewaysClient.CreateOrUpdate.
type GatewaysClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GatewaysClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GatewaysClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GatewaysClientCreateOrUpdateResponse, error) {
	respType := GatewaysClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GatewayResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GatewaysClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *GatewaysClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *GatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GatewaysClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GatewaysClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GatewaysClientCreateOrUpdateResponse contains the response from method GatewaysClient.CreateOrUpdate.
type GatewaysClientCreateOrUpdateResponse struct {
	GatewaysClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewaysClientCreateOrUpdateResult contains the result from method GatewaysClient.CreateOrUpdate.
type GatewaysClientCreateOrUpdateResult struct {
	GatewayResource
}

// GatewaysClientDeletePollerResponse contains the response from method GatewaysClient.Delete.
type GatewaysClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GatewaysClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GatewaysClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GatewaysClientDeleteResponse, error) {
	respType := GatewaysClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GatewaysClientDeletePollerResponse from the provided client and resume token.
func (l *GatewaysClientDeletePollerResponse) Resume(ctx context.Context, client *GatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GatewaysClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GatewaysClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GatewaysClientDeleteResponse contains the response from method GatewaysClient.Delete.
type GatewaysClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewaysClientGetResponse contains the response from method GatewaysClient.Get.
type GatewaysClientGetResponse struct {
	GatewaysClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewaysClientGetResult contains the result from method GatewaysClient.Get.
type GatewaysClientGetResult struct {
	GatewayResource
}

// GatewaysClientListResponse contains the response from method GatewaysClient.List.
type GatewaysClientListResponse struct {
	GatewaysClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewaysClientListResult contains the result from method GatewaysClient.List.
type GatewaysClientListResult struct {
	GatewayResourceCollection
}

// GatewaysClientValidateDomainResponse contains the response from method GatewaysClient.ValidateDomain.
type GatewaysClientValidateDomainResponse struct {
	GatewaysClientValidateDomainResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewaysClientValidateDomainResult contains the result from method GatewaysClient.ValidateDomain.
type GatewaysClientValidateDomainResult struct {
	CustomDomainValidateResult
}

// MonitoringSettingsClientGetResponse contains the response from method MonitoringSettingsClient.Get.
type MonitoringSettingsClientGetResponse struct {
	MonitoringSettingsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringSettingsClientGetResult contains the result from method MonitoringSettingsClient.Get.
type MonitoringSettingsClientGetResult struct {
	MonitoringSettingResource
}

// MonitoringSettingsClientUpdatePatchPollerResponse contains the response from method MonitoringSettingsClient.UpdatePatch.
type MonitoringSettingsClientUpdatePatchPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MonitoringSettingsClientUpdatePatchPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MonitoringSettingsClientUpdatePatchPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MonitoringSettingsClientUpdatePatchResponse, error) {
	respType := MonitoringSettingsClientUpdatePatchResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MonitoringSettingResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MonitoringSettingsClientUpdatePatchPollerResponse from the provided client and resume token.
func (l *MonitoringSettingsClientUpdatePatchPollerResponse) Resume(ctx context.Context, client *MonitoringSettingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MonitoringSettingsClient.UpdatePatch", token, client.pl)
	if err != nil {
		return err
	}
	poller := &MonitoringSettingsClientUpdatePatchPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MonitoringSettingsClientUpdatePatchResponse contains the response from method MonitoringSettingsClient.UpdatePatch.
type MonitoringSettingsClientUpdatePatchResponse struct {
	MonitoringSettingsClientUpdatePatchResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringSettingsClientUpdatePatchResult contains the result from method MonitoringSettingsClient.UpdatePatch.
type MonitoringSettingsClientUpdatePatchResult struct {
	MonitoringSettingResource
}

// MonitoringSettingsClientUpdatePutPollerResponse contains the response from method MonitoringSettingsClient.UpdatePut.
type MonitoringSettingsClientUpdatePutPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MonitoringSettingsClientUpdatePutPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MonitoringSettingsClientUpdatePutPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MonitoringSettingsClientUpdatePutResponse, error) {
	respType := MonitoringSettingsClientUpdatePutResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MonitoringSettingResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MonitoringSettingsClientUpdatePutPollerResponse from the provided client and resume token.
func (l *MonitoringSettingsClientUpdatePutPollerResponse) Resume(ctx context.Context, client *MonitoringSettingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MonitoringSettingsClient.UpdatePut", token, client.pl)
	if err != nil {
		return err
	}
	poller := &MonitoringSettingsClientUpdatePutPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MonitoringSettingsClientUpdatePutResponse contains the response from method MonitoringSettingsClient.UpdatePut.
type MonitoringSettingsClientUpdatePutResponse struct {
	MonitoringSettingsClientUpdatePutResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringSettingsClientUpdatePutResult contains the result from method MonitoringSettingsClient.UpdatePut.
type MonitoringSettingsClientUpdatePutResult struct {
	MonitoringSettingResource
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsClientListResult contains the result from method OperationsClient.List.
type OperationsClientListResult struct {
	AvailableOperations
}

// RuntimeVersionsClientListRuntimeVersionsResponse contains the response from method RuntimeVersionsClient.ListRuntimeVersions.
type RuntimeVersionsClientListRuntimeVersionsResponse struct {
	RuntimeVersionsClientListRuntimeVersionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RuntimeVersionsClientListRuntimeVersionsResult contains the result from method RuntimeVersionsClient.ListRuntimeVersions.
type RuntimeVersionsClientListRuntimeVersionsResult struct {
	AvailableRuntimeVersions
}

// SKUsClientListResponse contains the response from method SKUsClient.List.
type SKUsClientListResponse struct {
	SKUsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SKUsClientListResult contains the result from method SKUsClient.List.
type SKUsClientListResult struct {
	ResourceSKUCollection
}

// ServiceRegistriesClientCreateOrUpdatePollerResponse contains the response from method ServiceRegistriesClient.CreateOrUpdate.
type ServiceRegistriesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceRegistriesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceRegistriesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceRegistriesClientCreateOrUpdateResponse, error) {
	respType := ServiceRegistriesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServiceRegistryResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceRegistriesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServiceRegistriesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServiceRegistriesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceRegistriesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServiceRegistriesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceRegistriesClientCreateOrUpdateResponse contains the response from method ServiceRegistriesClient.CreateOrUpdate.
type ServiceRegistriesClientCreateOrUpdateResponse struct {
	ServiceRegistriesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceRegistriesClientCreateOrUpdateResult contains the result from method ServiceRegistriesClient.CreateOrUpdate.
type ServiceRegistriesClientCreateOrUpdateResult struct {
	ServiceRegistryResource
}

// ServiceRegistriesClientDeletePollerResponse contains the response from method ServiceRegistriesClient.Delete.
type ServiceRegistriesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceRegistriesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceRegistriesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceRegistriesClientDeleteResponse, error) {
	respType := ServiceRegistriesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceRegistriesClientDeletePollerResponse from the provided client and resume token.
func (l *ServiceRegistriesClientDeletePollerResponse) Resume(ctx context.Context, client *ServiceRegistriesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceRegistriesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServiceRegistriesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceRegistriesClientDeleteResponse contains the response from method ServiceRegistriesClient.Delete.
type ServiceRegistriesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceRegistriesClientGetResponse contains the response from method ServiceRegistriesClient.Get.
type ServiceRegistriesClientGetResponse struct {
	ServiceRegistriesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceRegistriesClientGetResult contains the result from method ServiceRegistriesClient.Get.
type ServiceRegistriesClientGetResult struct {
	ServiceRegistryResource
}

// ServiceRegistriesClientListResponse contains the response from method ServiceRegistriesClient.List.
type ServiceRegistriesClientListResponse struct {
	ServiceRegistriesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceRegistriesClientListResult contains the result from method ServiceRegistriesClient.List.
type ServiceRegistriesClientListResult struct {
	ServiceRegistryResourceCollection
}

// ServicesClientCheckNameAvailabilityResponse contains the response from method ServicesClient.CheckNameAvailability.
type ServicesClientCheckNameAvailabilityResponse struct {
	ServicesClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientCheckNameAvailabilityResult contains the result from method ServicesClient.CheckNameAvailability.
type ServicesClientCheckNameAvailabilityResult struct {
	NameAvailability
}

// ServicesClientCreateOrUpdatePollerResponse contains the response from method ServicesClient.CreateOrUpdate.
type ServicesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientCreateOrUpdateResponse, error) {
	respType := ServicesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServiceResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServicesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientCreateOrUpdateResponse contains the response from method ServicesClient.CreateOrUpdate.
type ServicesClientCreateOrUpdateResponse struct {
	ServicesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientCreateOrUpdateResult contains the result from method ServicesClient.CreateOrUpdate.
type ServicesClientCreateOrUpdateResult struct {
	ServiceResource
}

// ServicesClientDeletePollerResponse contains the response from method ServicesClient.Delete.
type ServicesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientDeleteResponse, error) {
	respType := ServicesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientDeletePollerResponse from the provided client and resume token.
func (l *ServicesClientDeletePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientDeleteResponse contains the response from method ServicesClient.Delete.
type ServicesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientDisableTestEndpointResponse contains the response from method ServicesClient.DisableTestEndpoint.
type ServicesClientDisableTestEndpointResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientEnableTestEndpointResponse contains the response from method ServicesClient.EnableTestEndpoint.
type ServicesClientEnableTestEndpointResponse struct {
	ServicesClientEnableTestEndpointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientEnableTestEndpointResult contains the result from method ServicesClient.EnableTestEndpoint.
type ServicesClientEnableTestEndpointResult struct {
	TestKeys
}

// ServicesClientGetResponse contains the response from method ServicesClient.Get.
type ServicesClientGetResponse struct {
	ServicesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientGetResult contains the result from method ServicesClient.Get.
type ServicesClientGetResult struct {
	ServiceResource
}

// ServicesClientListBySubscriptionResponse contains the response from method ServicesClient.ListBySubscription.
type ServicesClientListBySubscriptionResponse struct {
	ServicesClientListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientListBySubscriptionResult contains the result from method ServicesClient.ListBySubscription.
type ServicesClientListBySubscriptionResult struct {
	ServiceResourceList
}

// ServicesClientListResponse contains the response from method ServicesClient.List.
type ServicesClientListResponse struct {
	ServicesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientListResult contains the result from method ServicesClient.List.
type ServicesClientListResult struct {
	ServiceResourceList
}

// ServicesClientListTestKeysResponse contains the response from method ServicesClient.ListTestKeys.
type ServicesClientListTestKeysResponse struct {
	ServicesClientListTestKeysResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientListTestKeysResult contains the result from method ServicesClient.ListTestKeys.
type ServicesClientListTestKeysResult struct {
	TestKeys
}

// ServicesClientRegenerateTestKeyResponse contains the response from method ServicesClient.RegenerateTestKey.
type ServicesClientRegenerateTestKeyResponse struct {
	ServicesClientRegenerateTestKeyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientRegenerateTestKeyResult contains the result from method ServicesClient.RegenerateTestKey.
type ServicesClientRegenerateTestKeyResult struct {
	TestKeys
}

// ServicesClientStartPollerResponse contains the response from method ServicesClient.Start.
type ServicesClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientStartResponse, error) {
	respType := ServicesClientStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientStartPollerResponse from the provided client and resume token.
func (l *ServicesClientStartPollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientStartResponse contains the response from method ServicesClient.Start.
type ServicesClientStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientStopPollerResponse contains the response from method ServicesClient.Stop.
type ServicesClientStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientStopResponse, error) {
	respType := ServicesClientStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientStopPollerResponse from the provided client and resume token.
func (l *ServicesClientStopPollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Stop", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientStopResponse contains the response from method ServicesClient.Stop.
type ServicesClientStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientUpdatePollerResponse contains the response from method ServicesClient.Update.
type ServicesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientUpdateResponse, error) {
	respType := ServicesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServiceResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientUpdatePollerResponse from the provided client and resume token.
func (l *ServicesClientUpdatePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientUpdateResponse contains the response from method ServicesClient.Update.
type ServicesClientUpdateResponse struct {
	ServicesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientUpdateResult contains the result from method ServicesClient.Update.
type ServicesClientUpdateResult struct {
	ServiceResource
}

// StoragesClientCreateOrUpdatePollerResponse contains the response from method StoragesClient.CreateOrUpdate.
type StoragesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StoragesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StoragesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StoragesClientCreateOrUpdateResponse, error) {
	respType := StoragesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.StorageResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StoragesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *StoragesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *StoragesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StoragesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &StoragesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StoragesClientCreateOrUpdateResponse contains the response from method StoragesClient.CreateOrUpdate.
type StoragesClientCreateOrUpdateResponse struct {
	StoragesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StoragesClientCreateOrUpdateResult contains the result from method StoragesClient.CreateOrUpdate.
type StoragesClientCreateOrUpdateResult struct {
	StorageResource
}

// StoragesClientDeletePollerResponse contains the response from method StoragesClient.Delete.
type StoragesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StoragesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StoragesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StoragesClientDeleteResponse, error) {
	respType := StoragesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StoragesClientDeletePollerResponse from the provided client and resume token.
func (l *StoragesClientDeletePollerResponse) Resume(ctx context.Context, client *StoragesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StoragesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &StoragesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StoragesClientDeleteResponse contains the response from method StoragesClient.Delete.
type StoragesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StoragesClientGetResponse contains the response from method StoragesClient.Get.
type StoragesClientGetResponse struct {
	StoragesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StoragesClientGetResult contains the result from method StoragesClient.Get.
type StoragesClientGetResult struct {
	StorageResource
}

// StoragesClientListResponse contains the response from method StoragesClient.List.
type StoragesClientListResponse struct {
	StoragesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StoragesClientListResult contains the result from method StoragesClient.List.
type StoragesClientListResult struct {
	StorageResourceCollection
}
