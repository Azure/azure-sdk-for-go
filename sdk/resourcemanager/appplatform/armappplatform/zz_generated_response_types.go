//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armappplatform

import (
	"context"
	"net/http"
	"time"

	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
)

// AppsCreateOrUpdatePollerResponse contains the response from method Apps.CreateOrUpdate.
type AppsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AppsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l AppsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AppsCreateOrUpdateResponse, error) {
	respType := AppsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AppResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AppsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AppsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AppsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AppsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &AppsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AppsCreateOrUpdateResponse contains the response from method Apps.CreateOrUpdate.
type AppsCreateOrUpdateResponse struct {
	AppsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsCreateOrUpdateResult contains the result from method Apps.CreateOrUpdate.
type AppsCreateOrUpdateResult struct {
	AppResource
}

// AppsDeletePollerResponse contains the response from method Apps.Delete.
type AppsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AppsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l AppsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AppsDeleteResponse, error) {
	respType := AppsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AppsDeletePollerResponse from the provided client and resume token.
func (l *AppsDeletePollerResponse) Resume(ctx context.Context, client *AppsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AppsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AppsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AppsDeleteResponse contains the response from method Apps.Delete.
type AppsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsGetResourceUploadURLResponse contains the response from method Apps.GetResourceUploadURL.
type AppsGetResourceUploadURLResponse struct {
	AppsGetResourceUploadURLResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsGetResourceUploadURLResult contains the result from method Apps.GetResourceUploadURL.
type AppsGetResourceUploadURLResult struct {
	ResourceUploadDefinition
}

// AppsGetResponse contains the response from method Apps.Get.
type AppsGetResponse struct {
	AppsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsGetResult contains the result from method Apps.Get.
type AppsGetResult struct {
	AppResource
}

// AppsListResponse contains the response from method Apps.List.
type AppsListResponse struct {
	AppsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsListResult contains the result from method Apps.List.
type AppsListResult struct {
	AppResourceCollection
}

// AppsUpdatePollerResponse contains the response from method Apps.Update.
type AppsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AppsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l AppsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AppsUpdateResponse, error) {
	respType := AppsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AppResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AppsUpdatePollerResponse from the provided client and resume token.
func (l *AppsUpdatePollerResponse) Resume(ctx context.Context, client *AppsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AppsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &AppsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AppsUpdateResponse contains the response from method Apps.Update.
type AppsUpdateResponse struct {
	AppsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsUpdateResult contains the result from method Apps.Update.
type AppsUpdateResult struct {
	AppResource
}

// AppsValidateDomainResponse contains the response from method Apps.ValidateDomain.
type AppsValidateDomainResponse struct {
	AppsValidateDomainResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AppsValidateDomainResult contains the result from method Apps.ValidateDomain.
type AppsValidateDomainResult struct {
	CustomDomainValidateResult
}

// BindingsCreateOrUpdatePollerResponse contains the response from method Bindings.CreateOrUpdate.
type BindingsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BindingsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l BindingsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BindingsCreateOrUpdateResponse, error) {
	respType := BindingsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BindingResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BindingsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *BindingsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *BindingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BindingsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &BindingsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BindingsCreateOrUpdateResponse contains the response from method Bindings.CreateOrUpdate.
type BindingsCreateOrUpdateResponse struct {
	BindingsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BindingsCreateOrUpdateResult contains the result from method Bindings.CreateOrUpdate.
type BindingsCreateOrUpdateResult struct {
	BindingResource
}

// BindingsDeletePollerResponse contains the response from method Bindings.Delete.
type BindingsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BindingsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l BindingsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BindingsDeleteResponse, error) {
	respType := BindingsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BindingsDeletePollerResponse from the provided client and resume token.
func (l *BindingsDeletePollerResponse) Resume(ctx context.Context, client *BindingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BindingsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &BindingsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BindingsDeleteResponse contains the response from method Bindings.Delete.
type BindingsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BindingsGetResponse contains the response from method Bindings.Get.
type BindingsGetResponse struct {
	BindingsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BindingsGetResult contains the result from method Bindings.Get.
type BindingsGetResult struct {
	BindingResource
}

// BindingsListResponse contains the response from method Bindings.List.
type BindingsListResponse struct {
	BindingsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BindingsListResult contains the result from method Bindings.List.
type BindingsListResult struct {
	BindingResourceCollection
}

// BindingsUpdatePollerResponse contains the response from method Bindings.Update.
type BindingsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BindingsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l BindingsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BindingsUpdateResponse, error) {
	respType := BindingsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BindingResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BindingsUpdatePollerResponse from the provided client and resume token.
func (l *BindingsUpdatePollerResponse) Resume(ctx context.Context, client *BindingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BindingsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &BindingsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BindingsUpdateResponse contains the response from method Bindings.Update.
type BindingsUpdateResponse struct {
	BindingsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BindingsUpdateResult contains the result from method Bindings.Update.
type BindingsUpdateResult struct {
	BindingResource
}

// CertificatesCreateOrUpdatePollerResponse contains the response from method Certificates.CreateOrUpdate.
type CertificatesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CertificatesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l CertificatesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CertificatesCreateOrUpdateResponse, error) {
	respType := CertificatesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CertificateResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CertificatesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *CertificatesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *CertificatesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CertificatesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &CertificatesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CertificatesCreateOrUpdateResponse contains the response from method Certificates.CreateOrUpdate.
type CertificatesCreateOrUpdateResponse struct {
	CertificatesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CertificatesCreateOrUpdateResult contains the result from method Certificates.CreateOrUpdate.
type CertificatesCreateOrUpdateResult struct {
	CertificateResource
}

// CertificatesDeletePollerResponse contains the response from method Certificates.Delete.
type CertificatesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CertificatesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l CertificatesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CertificatesDeleteResponse, error) {
	respType := CertificatesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CertificatesDeletePollerResponse from the provided client and resume token.
func (l *CertificatesDeletePollerResponse) Resume(ctx context.Context, client *CertificatesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CertificatesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &CertificatesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CertificatesDeleteResponse contains the response from method Certificates.Delete.
type CertificatesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CertificatesGetResponse contains the response from method Certificates.Get.
type CertificatesGetResponse struct {
	CertificatesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CertificatesGetResult contains the result from method Certificates.Get.
type CertificatesGetResult struct {
	CertificateResource
}

// CertificatesListResponse contains the response from method Certificates.List.
type CertificatesListResponse struct {
	CertificatesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CertificatesListResult contains the result from method Certificates.List.
type CertificatesListResult struct {
	CertificateResourceCollection
}

// ConfigServersGetResponse contains the response from method ConfigServers.Get.
type ConfigServersGetResponse struct {
	ConfigServersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigServersGetResult contains the result from method ConfigServers.Get.
type ConfigServersGetResult struct {
	ConfigServerResource
}

// ConfigServersUpdatePatchPollerResponse contains the response from method ConfigServers.UpdatePatch.
type ConfigServersUpdatePatchPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConfigServersUpdatePatchPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l ConfigServersUpdatePatchPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConfigServersUpdatePatchResponse, error) {
	respType := ConfigServersUpdatePatchResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConfigServerResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConfigServersUpdatePatchPollerResponse from the provided client and resume token.
func (l *ConfigServersUpdatePatchPollerResponse) Resume(ctx context.Context, client *ConfigServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConfigServersClient.UpdatePatch", token, client.pl, client.updatePatchHandleError)
	if err != nil {
		return err
	}
	poller := &ConfigServersUpdatePatchPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConfigServersUpdatePatchResponse contains the response from method ConfigServers.UpdatePatch.
type ConfigServersUpdatePatchResponse struct {
	ConfigServersUpdatePatchResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigServersUpdatePatchResult contains the result from method ConfigServers.UpdatePatch.
type ConfigServersUpdatePatchResult struct {
	ConfigServerResource
}

// ConfigServersUpdatePutPollerResponse contains the response from method ConfigServers.UpdatePut.
type ConfigServersUpdatePutPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConfigServersUpdatePutPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l ConfigServersUpdatePutPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConfigServersUpdatePutResponse, error) {
	respType := ConfigServersUpdatePutResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConfigServerResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConfigServersUpdatePutPollerResponse from the provided client and resume token.
func (l *ConfigServersUpdatePutPollerResponse) Resume(ctx context.Context, client *ConfigServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConfigServersClient.UpdatePut", token, client.pl, client.updatePutHandleError)
	if err != nil {
		return err
	}
	poller := &ConfigServersUpdatePutPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConfigServersUpdatePutResponse contains the response from method ConfigServers.UpdatePut.
type ConfigServersUpdatePutResponse struct {
	ConfigServersUpdatePutResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigServersUpdatePutResult contains the result from method ConfigServers.UpdatePut.
type ConfigServersUpdatePutResult struct {
	ConfigServerResource
}

// ConfigServersValidatePollerResponse contains the response from method ConfigServers.Validate.
type ConfigServersValidatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConfigServersValidatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l ConfigServersValidatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConfigServersValidateResponse, error) {
	respType := ConfigServersValidateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConfigServerSettingsValidateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConfigServersValidatePollerResponse from the provided client and resume token.
func (l *ConfigServersValidatePollerResponse) Resume(ctx context.Context, client *ConfigServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConfigServersClient.Validate", token, client.pl, client.validateHandleError)
	if err != nil {
		return err
	}
	poller := &ConfigServersValidatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConfigServersValidateResponse contains the response from method ConfigServers.Validate.
type ConfigServersValidateResponse struct {
	ConfigServersValidateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigServersValidateResult contains the result from method ConfigServers.Validate.
type ConfigServersValidateResult struct {
	ConfigServerSettingsValidateResult
}

// CustomDomainsCreateOrUpdatePollerResponse contains the response from method CustomDomains.CreateOrUpdate.
type CustomDomainsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomDomainsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l CustomDomainsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsCreateOrUpdateResponse, error) {
	respType := CustomDomainsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomDomainResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomDomainsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *CustomDomainsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *CustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomDomainsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &CustomDomainsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomDomainsCreateOrUpdateResponse contains the response from method CustomDomains.CreateOrUpdate.
type CustomDomainsCreateOrUpdateResponse struct {
	CustomDomainsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsCreateOrUpdateResult contains the result from method CustomDomains.CreateOrUpdate.
type CustomDomainsCreateOrUpdateResult struct {
	CustomDomainResource
}

// CustomDomainsDeletePollerResponse contains the response from method CustomDomains.Delete.
type CustomDomainsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomDomainsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l CustomDomainsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsDeleteResponse, error) {
	respType := CustomDomainsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomDomainsDeletePollerResponse from the provided client and resume token.
func (l *CustomDomainsDeletePollerResponse) Resume(ctx context.Context, client *CustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomDomainsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &CustomDomainsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomDomainsDeleteResponse contains the response from method CustomDomains.Delete.
type CustomDomainsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsGetResponse contains the response from method CustomDomains.Get.
type CustomDomainsGetResponse struct {
	CustomDomainsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsGetResult contains the result from method CustomDomains.Get.
type CustomDomainsGetResult struct {
	CustomDomainResource
}

// CustomDomainsListResponse contains the response from method CustomDomains.List.
type CustomDomainsListResponse struct {
	CustomDomainsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsListResult contains the result from method CustomDomains.List.
type CustomDomainsListResult struct {
	CustomDomainResourceCollection
}

// CustomDomainsUpdatePollerResponse contains the response from method CustomDomains.Update.
type CustomDomainsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomDomainsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l CustomDomainsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsUpdateResponse, error) {
	respType := CustomDomainsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomDomainResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomDomainsUpdatePollerResponse from the provided client and resume token.
func (l *CustomDomainsUpdatePollerResponse) Resume(ctx context.Context, client *CustomDomainsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomDomainsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &CustomDomainsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomDomainsUpdateResponse contains the response from method CustomDomains.Update.
type CustomDomainsUpdateResponse struct {
	CustomDomainsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomDomainsUpdateResult contains the result from method CustomDomains.Update.
type CustomDomainsUpdateResult struct {
	CustomDomainResource
}

// DeploymentsCreateOrUpdatePollerResponse contains the response from method Deployments.CreateOrUpdate.
type DeploymentsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DeploymentsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsCreateOrUpdateResponse, error) {
	respType := DeploymentsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DeploymentsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsCreateOrUpdateResponse contains the response from method Deployments.CreateOrUpdate.
type DeploymentsCreateOrUpdateResponse struct {
	DeploymentsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCreateOrUpdateResult contains the result from method Deployments.CreateOrUpdate.
type DeploymentsCreateOrUpdateResult struct {
	DeploymentResource
}

// DeploymentsDeletePollerResponse contains the response from method Deployments.Delete.
type DeploymentsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DeploymentsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsDeleteResponse, error) {
	respType := DeploymentsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsDeletePollerResponse from the provided client and resume token.
func (l *DeploymentsDeletePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsDeleteResponse contains the response from method Deployments.Delete.
type DeploymentsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsGetLogFileURLResponse contains the response from method Deployments.GetLogFileURL.
type DeploymentsGetLogFileURLResponse struct {
	DeploymentsGetLogFileURLResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsGetLogFileURLResult contains the result from method Deployments.GetLogFileURL.
type DeploymentsGetLogFileURLResult struct {
	LogFileURLResponse
}

// DeploymentsGetResponse contains the response from method Deployments.Get.
type DeploymentsGetResponse struct {
	DeploymentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsGetResult contains the result from method Deployments.Get.
type DeploymentsGetResult struct {
	DeploymentResource
}

// DeploymentsListForClusterResponse contains the response from method Deployments.ListForCluster.
type DeploymentsListForClusterResponse struct {
	DeploymentsListForClusterResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsListForClusterResult contains the result from method Deployments.ListForCluster.
type DeploymentsListForClusterResult struct {
	DeploymentResourceCollection
}

// DeploymentsListResponse contains the response from method Deployments.List.
type DeploymentsListResponse struct {
	DeploymentsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsListResult contains the result from method Deployments.List.
type DeploymentsListResult struct {
	DeploymentResourceCollection
}

// DeploymentsRestartPollerResponse contains the response from method Deployments.Restart.
type DeploymentsRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsRestartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DeploymentsRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsRestartResponse, error) {
	respType := DeploymentsRestartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsRestartPollerResponse from the provided client and resume token.
func (l *DeploymentsRestartPollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.Restart", token, client.pl, client.restartHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsRestartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsRestartResponse contains the response from method Deployments.Restart.
type DeploymentsRestartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsStartPollerResponse contains the response from method Deployments.Start.
type DeploymentsStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DeploymentsStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsStartResponse, error) {
	respType := DeploymentsStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsStartPollerResponse from the provided client and resume token.
func (l *DeploymentsStartPollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.Start", token, client.pl, client.startHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsStartResponse contains the response from method Deployments.Start.
type DeploymentsStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsStopPollerResponse contains the response from method Deployments.Stop.
type DeploymentsStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DeploymentsStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsStopResponse, error) {
	respType := DeploymentsStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsStopPollerResponse from the provided client and resume token.
func (l *DeploymentsStopPollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.Stop", token, client.pl, client.stopHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsStopResponse contains the response from method Deployments.Stop.
type DeploymentsStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsUpdatePollerResponse contains the response from method Deployments.Update.
type DeploymentsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DeploymentsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsUpdateResponse, error) {
	respType := DeploymentsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsUpdatePollerResponse from the provided client and resume token.
func (l *DeploymentsUpdatePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsUpdateResponse contains the response from method Deployments.Update.
type DeploymentsUpdateResponse struct {
	DeploymentsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsUpdateResult contains the result from method Deployments.Update.
type DeploymentsUpdateResult struct {
	DeploymentResource
}

// MonitoringSettingsGetResponse contains the response from method MonitoringSettings.Get.
type MonitoringSettingsGetResponse struct {
	MonitoringSettingsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringSettingsGetResult contains the result from method MonitoringSettings.Get.
type MonitoringSettingsGetResult struct {
	MonitoringSettingResource
}

// MonitoringSettingsUpdatePatchPollerResponse contains the response from method MonitoringSettings.UpdatePatch.
type MonitoringSettingsUpdatePatchPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MonitoringSettingsUpdatePatchPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l MonitoringSettingsUpdatePatchPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MonitoringSettingsUpdatePatchResponse, error) {
	respType := MonitoringSettingsUpdatePatchResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MonitoringSettingResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MonitoringSettingsUpdatePatchPollerResponse from the provided client and resume token.
func (l *MonitoringSettingsUpdatePatchPollerResponse) Resume(ctx context.Context, client *MonitoringSettingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MonitoringSettingsClient.UpdatePatch", token, client.pl, client.updatePatchHandleError)
	if err != nil {
		return err
	}
	poller := &MonitoringSettingsUpdatePatchPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MonitoringSettingsUpdatePatchResponse contains the response from method MonitoringSettings.UpdatePatch.
type MonitoringSettingsUpdatePatchResponse struct {
	MonitoringSettingsUpdatePatchResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringSettingsUpdatePatchResult contains the result from method MonitoringSettings.UpdatePatch.
type MonitoringSettingsUpdatePatchResult struct {
	MonitoringSettingResource
}

// MonitoringSettingsUpdatePutPollerResponse contains the response from method MonitoringSettings.UpdatePut.
type MonitoringSettingsUpdatePutPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MonitoringSettingsUpdatePutPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l MonitoringSettingsUpdatePutPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MonitoringSettingsUpdatePutResponse, error) {
	respType := MonitoringSettingsUpdatePutResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MonitoringSettingResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MonitoringSettingsUpdatePutPollerResponse from the provided client and resume token.
func (l *MonitoringSettingsUpdatePutPollerResponse) Resume(ctx context.Context, client *MonitoringSettingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MonitoringSettingsClient.UpdatePut", token, client.pl, client.updatePutHandleError)
	if err != nil {
		return err
	}
	poller := &MonitoringSettingsUpdatePutPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MonitoringSettingsUpdatePutResponse contains the response from method MonitoringSettings.UpdatePut.
type MonitoringSettingsUpdatePutResponse struct {
	MonitoringSettingsUpdatePutResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MonitoringSettingsUpdatePutResult contains the result from method MonitoringSettings.UpdatePut.
type MonitoringSettingsUpdatePutResult struct {
	MonitoringSettingResource
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	AvailableOperations
}

// RuntimeVersionsListRuntimeVersionsResponse contains the response from method RuntimeVersions.ListRuntimeVersions.
type RuntimeVersionsListRuntimeVersionsResponse struct {
	RuntimeVersionsListRuntimeVersionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RuntimeVersionsListRuntimeVersionsResult contains the result from method RuntimeVersions.ListRuntimeVersions.
type RuntimeVersionsListRuntimeVersionsResult struct {
	AvailableRuntimeVersions
}

// SKUsListResponse contains the response from method SKUs.List.
type SKUsListResponse struct {
	SKUsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SKUsListResult contains the result from method SKUs.List.
type SKUsListResult struct {
	ResourceSKUCollection
}

// ServicesCheckNameAvailabilityResponse contains the response from method Services.CheckNameAvailability.
type ServicesCheckNameAvailabilityResponse struct {
	ServicesCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesCheckNameAvailabilityResult contains the result from method Services.CheckNameAvailability.
type ServicesCheckNameAvailabilityResult struct {
	NameAvailability
}

// ServicesCreateOrUpdatePollerResponse contains the response from method Services.CreateOrUpdate.
type ServicesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l ServicesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesCreateOrUpdateResponse, error) {
	respType := ServicesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServiceResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServicesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServicesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesCreateOrUpdateResponse contains the response from method Services.CreateOrUpdate.
type ServicesCreateOrUpdateResponse struct {
	ServicesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesCreateOrUpdateResult contains the result from method Services.CreateOrUpdate.
type ServicesCreateOrUpdateResult struct {
	ServiceResource
}

// ServicesDeletePollerResponse contains the response from method Services.Delete.
type ServicesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l ServicesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesDeleteResponse, error) {
	respType := ServicesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesDeletePollerResponse from the provided client and resume token.
func (l *ServicesDeletePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ServicesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesDeleteResponse contains the response from method Services.Delete.
type ServicesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesDisableTestEndpointResponse contains the response from method Services.DisableTestEndpoint.
type ServicesDisableTestEndpointResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesEnableTestEndpointResponse contains the response from method Services.EnableTestEndpoint.
type ServicesEnableTestEndpointResponse struct {
	ServicesEnableTestEndpointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesEnableTestEndpointResult contains the result from method Services.EnableTestEndpoint.
type ServicesEnableTestEndpointResult struct {
	TestKeys
}

// ServicesGetResponse contains the response from method Services.Get.
type ServicesGetResponse struct {
	ServicesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesGetResult contains the result from method Services.Get.
type ServicesGetResult struct {
	ServiceResource
}

// ServicesListBySubscriptionResponse contains the response from method Services.ListBySubscription.
type ServicesListBySubscriptionResponse struct {
	ServicesListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesListBySubscriptionResult contains the result from method Services.ListBySubscription.
type ServicesListBySubscriptionResult struct {
	ServiceResourceList
}

// ServicesListResponse contains the response from method Services.List.
type ServicesListResponse struct {
	ServicesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesListResult contains the result from method Services.List.
type ServicesListResult struct {
	ServiceResourceList
}

// ServicesListTestKeysResponse contains the response from method Services.ListTestKeys.
type ServicesListTestKeysResponse struct {
	ServicesListTestKeysResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesListTestKeysResult contains the result from method Services.ListTestKeys.
type ServicesListTestKeysResult struct {
	TestKeys
}

// ServicesRegenerateTestKeyResponse contains the response from method Services.RegenerateTestKey.
type ServicesRegenerateTestKeyResponse struct {
	ServicesRegenerateTestKeyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesRegenerateTestKeyResult contains the result from method Services.RegenerateTestKey.
type ServicesRegenerateTestKeyResult struct {
	TestKeys
}

// ServicesUpdatePollerResponse contains the response from method Services.Update.
type ServicesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l ServicesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesUpdateResponse, error) {
	respType := ServicesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServiceResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesUpdatePollerResponse from the provided client and resume token.
func (l *ServicesUpdatePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ServicesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesUpdateResponse contains the response from method Services.Update.
type ServicesUpdateResponse struct {
	ServicesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesUpdateResult contains the result from method Services.Update.
type ServicesUpdateResult struct {
	ServiceResource
}
