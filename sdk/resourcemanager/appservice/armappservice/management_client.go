// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armappservice

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// ManagementClient contains the methods for the AppServiceManagementClient group.
// Don't use this type directly, use NewManagementClient() instead.
type ManagementClient struct {
	internal       *arm.Client
	subscriptionID string
}

// NewManagementClient creates a new instance of ManagementClient with the specified values.
//   - subscriptionID - Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
//   - credential - used to authorize requests. Usually a credential from azidentity.
//   - options - Contains optional client configuration. Pass nil to accept the default values.
func NewManagementClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*ManagementClient, error) {
	cl, err := arm.NewClient(moduleName, moduleVersion, credential, options)
	if err != nil {
		return nil, err
	}
	client := &ManagementClient{
		subscriptionID: subscriptionID,
		internal:       cl,
	}
	return client, nil
}

// CheckNameAvailability - Description for Check if a resource name is available.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - request - Name availability request.
//   - options - ManagementClientCheckNameAvailabilityOptions contains the optional parameters for the ManagementClient.CheckNameAvailability
//     method.
func (client *ManagementClient) CheckNameAvailability(ctx context.Context, request ResourceNameAvailabilityRequest, options *ManagementClientCheckNameAvailabilityOptions) (ManagementClientCheckNameAvailabilityResponse, error) {
	var err error
	const operationName = "ManagementClient.CheckNameAvailability"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.checkNameAvailabilityCreateRequest(ctx, request, options)
	if err != nil {
		return ManagementClientCheckNameAvailabilityResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ManagementClientCheckNameAvailabilityResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ManagementClientCheckNameAvailabilityResponse{}, err
	}
	resp, err := client.checkNameAvailabilityHandleResponse(httpResp)
	return resp, err
}

// checkNameAvailabilityCreateRequest creates the CheckNameAvailability request.
func (client *ManagementClient) checkNameAvailabilityCreateRequest(ctx context.Context, request ResourceNameAvailabilityRequest, _ *ManagementClientCheckNameAvailabilityOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/checknameavailability"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// checkNameAvailabilityHandleResponse handles the CheckNameAvailability response.
func (client *ManagementClient) checkNameAvailabilityHandleResponse(resp *http.Response) (ManagementClientCheckNameAvailabilityResponse, error) {
	result := ManagementClientCheckNameAvailabilityResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceNameAvailability); err != nil {
		return ManagementClientCheckNameAvailabilityResponse{}, err
	}
	return result, nil
}

// GetPublishingUser - Description for Gets publishing user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - options - ManagementClientGetPublishingUserOptions contains the optional parameters for the ManagementClient.GetPublishingUser
//     method.
func (client *ManagementClient) GetPublishingUser(ctx context.Context, options *ManagementClientGetPublishingUserOptions) (ManagementClientGetPublishingUserResponse, error) {
	var err error
	const operationName = "ManagementClient.GetPublishingUser"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getPublishingUserCreateRequest(ctx, options)
	if err != nil {
		return ManagementClientGetPublishingUserResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ManagementClientGetPublishingUserResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ManagementClientGetPublishingUserResponse{}, err
	}
	resp, err := client.getPublishingUserHandleResponse(httpResp)
	return resp, err
}

// getPublishingUserCreateRequest creates the GetPublishingUser request.
func (client *ManagementClient) getPublishingUserCreateRequest(ctx context.Context, _ *ManagementClientGetPublishingUserOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Web/publishingUsers/web"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPublishingUserHandleResponse handles the GetPublishingUser response.
func (client *ManagementClient) getPublishingUserHandleResponse(resp *http.Response) (ManagementClientGetPublishingUserResponse, error) {
	result := ManagementClientGetPublishingUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.User); err != nil {
		return ManagementClientGetPublishingUserResponse{}, err
	}
	return result, nil
}

// GetSourceControl - Description for Gets source control token
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - sourceControlType - Type of source control
//   - options - ManagementClientGetSourceControlOptions contains the optional parameters for the ManagementClient.GetSourceControl
//     method.
func (client *ManagementClient) GetSourceControl(ctx context.Context, sourceControlType string, options *ManagementClientGetSourceControlOptions) (ManagementClientGetSourceControlResponse, error) {
	var err error
	const operationName = "ManagementClient.GetSourceControl"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSourceControlCreateRequest(ctx, sourceControlType, options)
	if err != nil {
		return ManagementClientGetSourceControlResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ManagementClientGetSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ManagementClientGetSourceControlResponse{}, err
	}
	resp, err := client.getSourceControlHandleResponse(httpResp)
	return resp, err
}

// getSourceControlCreateRequest creates the GetSourceControl request.
func (client *ManagementClient) getSourceControlCreateRequest(ctx context.Context, sourceControlType string, _ *ManagementClientGetSourceControlOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Web/sourcecontrols/{sourceControlType}"
	if sourceControlType == "" {
		return nil, errors.New("parameter sourceControlType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sourceControlType}", url.PathEscape(sourceControlType))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSourceControlHandleResponse handles the GetSourceControl response.
func (client *ManagementClient) getSourceControlHandleResponse(resp *http.Response) (ManagementClientGetSourceControlResponse, error) {
	result := ManagementClientGetSourceControlResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SourceControl); err != nil {
		return ManagementClientGetSourceControlResponse{}, err
	}
	return result, nil
}

// GetSubscriptionDeploymentLocations - Description for Gets list of available geo regions plus ministamps
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - options - ManagementClientGetSubscriptionDeploymentLocationsOptions contains the optional parameters for the ManagementClient.GetSubscriptionDeploymentLocations
//     method.
func (client *ManagementClient) GetSubscriptionDeploymentLocations(ctx context.Context, options *ManagementClientGetSubscriptionDeploymentLocationsOptions) (ManagementClientGetSubscriptionDeploymentLocationsResponse, error) {
	var err error
	const operationName = "ManagementClient.GetSubscriptionDeploymentLocations"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSubscriptionDeploymentLocationsCreateRequest(ctx, options)
	if err != nil {
		return ManagementClientGetSubscriptionDeploymentLocationsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ManagementClientGetSubscriptionDeploymentLocationsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ManagementClientGetSubscriptionDeploymentLocationsResponse{}, err
	}
	resp, err := client.getSubscriptionDeploymentLocationsHandleResponse(httpResp)
	return resp, err
}

// getSubscriptionDeploymentLocationsCreateRequest creates the GetSubscriptionDeploymentLocations request.
func (client *ManagementClient) getSubscriptionDeploymentLocationsCreateRequest(ctx context.Context, _ *ManagementClientGetSubscriptionDeploymentLocationsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deploymentLocations"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSubscriptionDeploymentLocationsHandleResponse handles the GetSubscriptionDeploymentLocations response.
func (client *ManagementClient) getSubscriptionDeploymentLocationsHandleResponse(resp *http.Response) (ManagementClientGetSubscriptionDeploymentLocationsResponse, error) {
	result := ManagementClientGetSubscriptionDeploymentLocationsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentLocations); err != nil {
		return ManagementClientGetSubscriptionDeploymentLocationsResponse{}, err
	}
	return result, nil
}

// NewListAseRegionsPager - Description for get a list of available ASE regions and its supported Skus.
//
// Generated from API version 2025-03-01
//   - options - ManagementClientListAseRegionsOptions contains the optional parameters for the ManagementClient.NewListAseRegionsPager
//     method.
func (client *ManagementClient) NewListAseRegionsPager(options *ManagementClientListAseRegionsOptions) *runtime.Pager[ManagementClientListAseRegionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ManagementClientListAseRegionsResponse]{
		More: func(page ManagementClientListAseRegionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ManagementClientListAseRegionsResponse) (ManagementClientListAseRegionsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "ManagementClient.NewListAseRegionsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listAseRegionsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ManagementClientListAseRegionsResponse{}, err
			}
			return client.listAseRegionsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listAseRegionsCreateRequest creates the ListAseRegions request.
func (client *ManagementClient) listAseRegionsCreateRequest(ctx context.Context, _ *ManagementClientListAseRegionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/aseRegions"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAseRegionsHandleResponse handles the ListAseRegions response.
func (client *ManagementClient) listAseRegionsHandleResponse(resp *http.Response) (ManagementClientListAseRegionsResponse, error) {
	result := ManagementClientListAseRegionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AseRegionCollection); err != nil {
		return ManagementClientListAseRegionsResponse{}, err
	}
	return result, nil
}

// NewListBillingMetersPager - Description for Gets a list of meters for a given location.
//
// Generated from API version 2025-03-01
//   - options - ManagementClientListBillingMetersOptions contains the optional parameters for the ManagementClient.NewListBillingMetersPager
//     method.
func (client *ManagementClient) NewListBillingMetersPager(options *ManagementClientListBillingMetersOptions) *runtime.Pager[ManagementClientListBillingMetersResponse] {
	return runtime.NewPager(runtime.PagingHandler[ManagementClientListBillingMetersResponse]{
		More: func(page ManagementClientListBillingMetersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ManagementClientListBillingMetersResponse) (ManagementClientListBillingMetersResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "ManagementClient.NewListBillingMetersPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listBillingMetersCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ManagementClientListBillingMetersResponse{}, err
			}
			return client.listBillingMetersHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listBillingMetersCreateRequest creates the ListBillingMeters request.
func (client *ManagementClient) listBillingMetersCreateRequest(ctx context.Context, options *ManagementClientListBillingMetersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/billingMeters"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	if options != nil && options.BillingLocation != nil {
		reqQP.Set("billingLocation", *options.BillingLocation)
	}
	if options != nil && options.OSType != nil {
		reqQP.Set("osType", *options.OSType)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listBillingMetersHandleResponse handles the ListBillingMeters response.
func (client *ManagementClient) listBillingMetersHandleResponse(resp *http.Response) (ManagementClientListBillingMetersResponse, error) {
	result := ManagementClientListBillingMetersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingMeterCollection); err != nil {
		return ManagementClientListBillingMetersResponse{}, err
	}
	return result, nil
}

// NewListCustomHostNameSitesPager - Get custom hostnames under this subscription
//
// Generated from API version 2025-03-01
//   - options - ManagementClientListCustomHostNameSitesOptions contains the optional parameters for the ManagementClient.NewListCustomHostNameSitesPager
//     method.
func (client *ManagementClient) NewListCustomHostNameSitesPager(options *ManagementClientListCustomHostNameSitesOptions) *runtime.Pager[ManagementClientListCustomHostNameSitesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ManagementClientListCustomHostNameSitesResponse]{
		More: func(page ManagementClientListCustomHostNameSitesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ManagementClientListCustomHostNameSitesResponse) (ManagementClientListCustomHostNameSitesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "ManagementClient.NewListCustomHostNameSitesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listCustomHostNameSitesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ManagementClientListCustomHostNameSitesResponse{}, err
			}
			return client.listCustomHostNameSitesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listCustomHostNameSitesCreateRequest creates the ListCustomHostNameSites request.
func (client *ManagementClient) listCustomHostNameSitesCreateRequest(ctx context.Context, options *ManagementClientListCustomHostNameSitesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/customhostnameSites"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	if options != nil && options.Hostname != nil {
		reqQP.Set("hostname", *options.Hostname)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listCustomHostNameSitesHandleResponse handles the ListCustomHostNameSites response.
func (client *ManagementClient) listCustomHostNameSitesHandleResponse(resp *http.Response) (ManagementClientListCustomHostNameSitesResponse, error) {
	result := ManagementClientListCustomHostNameSitesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CustomHostnameSitesCollection); err != nil {
		return ManagementClientListCustomHostNameSitesResponse{}, err
	}
	return result, nil
}

// NewListGeoRegionsPager - Description for Get a list of available geographical regions.
//
// Generated from API version 2025-03-01
//   - options - ManagementClientListGeoRegionsOptions contains the optional parameters for the ManagementClient.NewListGeoRegionsPager
//     method.
func (client *ManagementClient) NewListGeoRegionsPager(options *ManagementClientListGeoRegionsOptions) *runtime.Pager[ManagementClientListGeoRegionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ManagementClientListGeoRegionsResponse]{
		More: func(page ManagementClientListGeoRegionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ManagementClientListGeoRegionsResponse) (ManagementClientListGeoRegionsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "ManagementClient.NewListGeoRegionsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listGeoRegionsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ManagementClientListGeoRegionsResponse{}, err
			}
			return client.listGeoRegionsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listGeoRegionsCreateRequest creates the ListGeoRegions request.
func (client *ManagementClient) listGeoRegionsCreateRequest(ctx context.Context, options *ManagementClientListGeoRegionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/geoRegions"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	if options != nil && options.CustomModeWorkersEnabled != nil {
		reqQP.Set("customModeWorkersEnabled ", strconv.FormatBool(*options.CustomModeWorkersEnabled))
	}
	if options != nil && options.LinuxDynamicWorkersEnabled != nil {
		reqQP.Set("linuxDynamicWorkersEnabled", strconv.FormatBool(*options.LinuxDynamicWorkersEnabled))
	}
	if options != nil && options.LinuxWorkersEnabled != nil {
		reqQP.Set("linuxWorkersEnabled", strconv.FormatBool(*options.LinuxWorkersEnabled))
	}
	if options != nil && options.SKU != nil {
		reqQP.Set("sku", string(*options.SKU))
	}
	if options != nil && options.XenonWorkersEnabled != nil {
		reqQP.Set("xenonWorkersEnabled", strconv.FormatBool(*options.XenonWorkersEnabled))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listGeoRegionsHandleResponse handles the ListGeoRegions response.
func (client *ManagementClient) listGeoRegionsHandleResponse(resp *http.Response) (ManagementClientListGeoRegionsResponse, error) {
	result := ManagementClientListGeoRegionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.GeoRegionCollection); err != nil {
		return ManagementClientListGeoRegionsResponse{}, err
	}
	return result, nil
}

// NewListPremierAddOnOffersPager - Description for List all premier add-on offers.
//
// Generated from API version 2025-03-01
//   - options - ManagementClientListPremierAddOnOffersOptions contains the optional parameters for the ManagementClient.NewListPremierAddOnOffersPager
//     method.
func (client *ManagementClient) NewListPremierAddOnOffersPager(options *ManagementClientListPremierAddOnOffersOptions) *runtime.Pager[ManagementClientListPremierAddOnOffersResponse] {
	return runtime.NewPager(runtime.PagingHandler[ManagementClientListPremierAddOnOffersResponse]{
		More: func(page ManagementClientListPremierAddOnOffersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ManagementClientListPremierAddOnOffersResponse) (ManagementClientListPremierAddOnOffersResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "ManagementClient.NewListPremierAddOnOffersPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listPremierAddOnOffersCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ManagementClientListPremierAddOnOffersResponse{}, err
			}
			return client.listPremierAddOnOffersHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listPremierAddOnOffersCreateRequest creates the ListPremierAddOnOffers request.
func (client *ManagementClient) listPremierAddOnOffersCreateRequest(ctx context.Context, _ *ManagementClientListPremierAddOnOffersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/premieraddonoffers"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPremierAddOnOffersHandleResponse handles the ListPremierAddOnOffers response.
func (client *ManagementClient) listPremierAddOnOffersHandleResponse(resp *http.Response) (ManagementClientListPremierAddOnOffersResponse, error) {
	result := ManagementClientListPremierAddOnOffersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOnOfferCollection); err != nil {
		return ManagementClientListPremierAddOnOffersResponse{}, err
	}
	return result, nil
}

// ListSKUs - Description for List all SKUs.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - options - ManagementClientListSKUsOptions contains the optional parameters for the ManagementClient.ListSKUs method.
func (client *ManagementClient) ListSKUs(ctx context.Context, options *ManagementClientListSKUsOptions) (ManagementClientListSKUsResponse, error) {
	var err error
	const operationName = "ManagementClient.ListSKUs"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listSKUsCreateRequest(ctx, options)
	if err != nil {
		return ManagementClientListSKUsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ManagementClientListSKUsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ManagementClientListSKUsResponse{}, err
	}
	resp, err := client.listSKUsHandleResponse(httpResp)
	return resp, err
}

// listSKUsCreateRequest creates the ListSKUs request.
func (client *ManagementClient) listSKUsCreateRequest(ctx context.Context, _ *ManagementClientListSKUsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/skus"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSKUsHandleResponse handles the ListSKUs response.
func (client *ManagementClient) listSKUsHandleResponse(resp *http.Response) (ManagementClientListSKUsResponse, error) {
	result := ManagementClientListSKUsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SKUInfos); err != nil {
		return ManagementClientListSKUsResponse{}, err
	}
	return result, nil
}

// NewListSiteIdentifiersAssignedToHostNamePager - Description for List all apps that are assigned to a hostname.
//
// Generated from API version 2025-03-01
//   - nameIdentifier - Hostname information.
//   - options - ManagementClientListSiteIdentifiersAssignedToHostNameOptions contains the optional parameters for the ManagementClient.NewListSiteIdentifiersAssignedToHostNamePager
//     method.
func (client *ManagementClient) NewListSiteIdentifiersAssignedToHostNamePager(nameIdentifier NameIdentifier, options *ManagementClientListSiteIdentifiersAssignedToHostNameOptions) *runtime.Pager[ManagementClientListSiteIdentifiersAssignedToHostNameResponse] {
	return runtime.NewPager(runtime.PagingHandler[ManagementClientListSiteIdentifiersAssignedToHostNameResponse]{
		More: func(page ManagementClientListSiteIdentifiersAssignedToHostNameResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ManagementClientListSiteIdentifiersAssignedToHostNameResponse) (ManagementClientListSiteIdentifiersAssignedToHostNameResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "ManagementClient.NewListSiteIdentifiersAssignedToHostNamePager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSiteIdentifiersAssignedToHostNameCreateRequest(ctx, nameIdentifier, options)
			}, nil)
			if err != nil {
				return ManagementClientListSiteIdentifiersAssignedToHostNameResponse{}, err
			}
			return client.listSiteIdentifiersAssignedToHostNameHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSiteIdentifiersAssignedToHostNameCreateRequest creates the ListSiteIdentifiersAssignedToHostName request.
func (client *ManagementClient) listSiteIdentifiersAssignedToHostNameCreateRequest(ctx context.Context, nameIdentifier NameIdentifier, _ *ManagementClientListSiteIdentifiersAssignedToHostNameOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/listSitesAssignedToHostName"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, nameIdentifier); err != nil {
		return nil, err
	}
	return req, nil
}

// listSiteIdentifiersAssignedToHostNameHandleResponse handles the ListSiteIdentifiersAssignedToHostName response.
func (client *ManagementClient) listSiteIdentifiersAssignedToHostNameHandleResponse(resp *http.Response) (ManagementClientListSiteIdentifiersAssignedToHostNameResponse, error) {
	result := ManagementClientListSiteIdentifiersAssignedToHostNameResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IdentifierCollection); err != nil {
		return ManagementClientListSiteIdentifiersAssignedToHostNameResponse{}, err
	}
	return result, nil
}

// NewListSourceControlsPager - Description for Gets the source controls available for Azure websites.
//
// Generated from API version 2025-03-01
//   - options - ManagementClientListSourceControlsOptions contains the optional parameters for the ManagementClient.NewListSourceControlsPager
//     method.
func (client *ManagementClient) NewListSourceControlsPager(options *ManagementClientListSourceControlsOptions) *runtime.Pager[ManagementClientListSourceControlsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ManagementClientListSourceControlsResponse]{
		More: func(page ManagementClientListSourceControlsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ManagementClientListSourceControlsResponse) (ManagementClientListSourceControlsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "ManagementClient.NewListSourceControlsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSourceControlsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ManagementClientListSourceControlsResponse{}, err
			}
			return client.listSourceControlsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSourceControlsCreateRequest creates the ListSourceControls request.
func (client *ManagementClient) listSourceControlsCreateRequest(ctx context.Context, _ *ManagementClientListSourceControlsOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Web/sourcecontrols"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSourceControlsHandleResponse handles the ListSourceControls response.
func (client *ManagementClient) listSourceControlsHandleResponse(resp *http.Response) (ManagementClientListSourceControlsResponse, error) {
	result := ManagementClientListSourceControlsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SourceControlCollection); err != nil {
		return ManagementClientListSourceControlsResponse{}, err
	}
	return result, nil
}

// Move - Description for Move resources between resource groups.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - moveResourceEnvelope - Object that represents the resource to move.
//   - options - ManagementClientMoveOptions contains the optional parameters for the ManagementClient.Move method.
func (client *ManagementClient) Move(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, options *ManagementClientMoveOptions) (ManagementClientMoveResponse, error) {
	var err error
	const operationName = "ManagementClient.Move"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.moveCreateRequest(ctx, resourceGroupName, moveResourceEnvelope, options)
	if err != nil {
		return ManagementClientMoveResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ManagementClientMoveResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ManagementClientMoveResponse{}, err
	}
	return ManagementClientMoveResponse{}, nil
}

// moveCreateRequest creates the Move request.
func (client *ManagementClient) moveCreateRequest(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, _ *ManagementClientMoveOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/moveResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, moveResourceEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// RegionalCheckNameAvailability - Check if a resource name is available for DNL sites.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - request - Name availability request.
//   - options - ManagementClientRegionalCheckNameAvailabilityOptions contains the optional parameters for the ManagementClient.RegionalCheckNameAvailability
//     method.
func (client *ManagementClient) RegionalCheckNameAvailability(ctx context.Context, location string, request DnlResourceNameAvailabilityRequest, options *ManagementClientRegionalCheckNameAvailabilityOptions) (ManagementClientRegionalCheckNameAvailabilityResponse, error) {
	var err error
	const operationName = "ManagementClient.RegionalCheckNameAvailability"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.regionalCheckNameAvailabilityCreateRequest(ctx, location, request, options)
	if err != nil {
		return ManagementClientRegionalCheckNameAvailabilityResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ManagementClientRegionalCheckNameAvailabilityResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ManagementClientRegionalCheckNameAvailabilityResponse{}, err
	}
	resp, err := client.regionalCheckNameAvailabilityHandleResponse(httpResp)
	return resp, err
}

// regionalCheckNameAvailabilityCreateRequest creates the RegionalCheckNameAvailability request.
func (client *ManagementClient) regionalCheckNameAvailabilityCreateRequest(ctx context.Context, location string, request DnlResourceNameAvailabilityRequest, _ *ManagementClientRegionalCheckNameAvailabilityOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/locations/{location}/checknameavailability"
	if location == "" {
		return nil, errors.New("parameter location cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{location}", url.PathEscape(location))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// regionalCheckNameAvailabilityHandleResponse handles the RegionalCheckNameAvailability response.
func (client *ManagementClient) regionalCheckNameAvailabilityHandleResponse(resp *http.Response) (ManagementClientRegionalCheckNameAvailabilityResponse, error) {
	result := ManagementClientRegionalCheckNameAvailabilityResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DnlResourceNameAvailability); err != nil {
		return ManagementClientRegionalCheckNameAvailabilityResponse{}, err
	}
	return result, nil
}

// UpdatePublishingUser - Description for Updates publishing user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - userDetails - Details of publishing user
//   - options - ManagementClientUpdatePublishingUserOptions contains the optional parameters for the ManagementClient.UpdatePublishingUser
//     method.
func (client *ManagementClient) UpdatePublishingUser(ctx context.Context, userDetails User, options *ManagementClientUpdatePublishingUserOptions) (ManagementClientUpdatePublishingUserResponse, error) {
	var err error
	const operationName = "ManagementClient.UpdatePublishingUser"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updatePublishingUserCreateRequest(ctx, userDetails, options)
	if err != nil {
		return ManagementClientUpdatePublishingUserResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ManagementClientUpdatePublishingUserResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ManagementClientUpdatePublishingUserResponse{}, err
	}
	resp, err := client.updatePublishingUserHandleResponse(httpResp)
	return resp, err
}

// updatePublishingUserCreateRequest creates the UpdatePublishingUser request.
func (client *ManagementClient) updatePublishingUserCreateRequest(ctx context.Context, userDetails User, _ *ManagementClientUpdatePublishingUserOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Web/publishingUsers/web"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, userDetails); err != nil {
		return nil, err
	}
	return req, nil
}

// updatePublishingUserHandleResponse handles the UpdatePublishingUser response.
func (client *ManagementClient) updatePublishingUserHandleResponse(resp *http.Response) (ManagementClientUpdatePublishingUserResponse, error) {
	result := ManagementClientUpdatePublishingUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.User); err != nil {
		return ManagementClientUpdatePublishingUserResponse{}, err
	}
	return result, nil
}

// UpdateSourceControl - Description for Updates source control token
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - sourceControlType - Type of source control
//   - requestMessage - Source control token information
//   - options - ManagementClientUpdateSourceControlOptions contains the optional parameters for the ManagementClient.UpdateSourceControl
//     method.
func (client *ManagementClient) UpdateSourceControl(ctx context.Context, sourceControlType string, requestMessage SourceControl, options *ManagementClientUpdateSourceControlOptions) (ManagementClientUpdateSourceControlResponse, error) {
	var err error
	const operationName = "ManagementClient.UpdateSourceControl"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateSourceControlCreateRequest(ctx, sourceControlType, requestMessage, options)
	if err != nil {
		return ManagementClientUpdateSourceControlResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ManagementClientUpdateSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ManagementClientUpdateSourceControlResponse{}, err
	}
	resp, err := client.updateSourceControlHandleResponse(httpResp)
	return resp, err
}

// updateSourceControlCreateRequest creates the UpdateSourceControl request.
func (client *ManagementClient) updateSourceControlCreateRequest(ctx context.Context, sourceControlType string, requestMessage SourceControl, _ *ManagementClientUpdateSourceControlOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Web/sourcecontrols/{sourceControlType}"
	if sourceControlType == "" {
		return nil, errors.New("parameter sourceControlType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sourceControlType}", url.PathEscape(sourceControlType))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, requestMessage); err != nil {
		return nil, err
	}
	return req, nil
}

// updateSourceControlHandleResponse handles the UpdateSourceControl response.
func (client *ManagementClient) updateSourceControlHandleResponse(resp *http.Response) (ManagementClientUpdateSourceControlResponse, error) {
	result := ManagementClientUpdateSourceControlResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SourceControl); err != nil {
		return ManagementClientUpdateSourceControlResponse{}, err
	}
	return result, nil
}

// Validate - Description for Validate if a resource can be created.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - validateRequest - Request with the resources to validate.
//   - options - ManagementClientValidateOptions contains the optional parameters for the ManagementClient.Validate method.
func (client *ManagementClient) Validate(ctx context.Context, resourceGroupName string, validateRequest ValidateRequest, options *ManagementClientValidateOptions) (ManagementClientValidateResponse, error) {
	var err error
	const operationName = "ManagementClient.Validate"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateCreateRequest(ctx, resourceGroupName, validateRequest, options)
	if err != nil {
		return ManagementClientValidateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ManagementClientValidateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ManagementClientValidateResponse{}, err
	}
	resp, err := client.validateHandleResponse(httpResp)
	return resp, err
}

// validateCreateRequest creates the Validate request.
func (client *ManagementClient) validateCreateRequest(ctx context.Context, resourceGroupName string, validateRequest ValidateRequest, _ *ManagementClientValidateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/validate"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, validateRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// validateHandleResponse handles the Validate response.
func (client *ManagementClient) validateHandleResponse(resp *http.Response) (ManagementClientValidateResponse, error) {
	result := ManagementClientValidateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ValidateResponse); err != nil {
		return ManagementClientValidateResponse{}, err
	}
	return result, nil
}

// ValidateMove - Description for Validate whether a resource can be moved.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - moveResourceEnvelope - Object that represents the resource to move.
//   - options - ManagementClientValidateMoveOptions contains the optional parameters for the ManagementClient.ValidateMove method.
func (client *ManagementClient) ValidateMove(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, options *ManagementClientValidateMoveOptions) (ManagementClientValidateMoveResponse, error) {
	var err error
	const operationName = "ManagementClient.ValidateMove"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateMoveCreateRequest(ctx, resourceGroupName, moveResourceEnvelope, options)
	if err != nil {
		return ManagementClientValidateMoveResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ManagementClientValidateMoveResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ManagementClientValidateMoveResponse{}, err
	}
	return ManagementClientValidateMoveResponse{}, nil
}

// validateMoveCreateRequest creates the ValidateMove request.
func (client *ManagementClient) validateMoveCreateRequest(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, _ *ManagementClientValidateMoveOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/validateMoveResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, moveResourceEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// VerifyHostingEnvironmentVnet - Description for Verifies if this VNET is compatible with an App Service Environment by analyzing
// the Network Security Group rules.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - parameters - VNET information
//   - options - ManagementClientVerifyHostingEnvironmentVnetOptions contains the optional parameters for the ManagementClient.VerifyHostingEnvironmentVnet
//     method.
func (client *ManagementClient) VerifyHostingEnvironmentVnet(ctx context.Context, parameters VnetParameters, options *ManagementClientVerifyHostingEnvironmentVnetOptions) (ManagementClientVerifyHostingEnvironmentVnetResponse, error) {
	var err error
	const operationName = "ManagementClient.VerifyHostingEnvironmentVnet"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.verifyHostingEnvironmentVnetCreateRequest(ctx, parameters, options)
	if err != nil {
		return ManagementClientVerifyHostingEnvironmentVnetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ManagementClientVerifyHostingEnvironmentVnetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ManagementClientVerifyHostingEnvironmentVnetResponse{}, err
	}
	resp, err := client.verifyHostingEnvironmentVnetHandleResponse(httpResp)
	return resp, err
}

// verifyHostingEnvironmentVnetCreateRequest creates the VerifyHostingEnvironmentVnet request.
func (client *ManagementClient) verifyHostingEnvironmentVnetCreateRequest(ctx context.Context, parameters VnetParameters, _ *ManagementClientVerifyHostingEnvironmentVnetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/verifyHostingEnvironmentVnet"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// verifyHostingEnvironmentVnetHandleResponse handles the VerifyHostingEnvironmentVnet response.
func (client *ManagementClient) verifyHostingEnvironmentVnetHandleResponse(resp *http.Response) (ManagementClientVerifyHostingEnvironmentVnetResponse, error) {
	result := ManagementClientVerifyHostingEnvironmentVnetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetValidationFailureDetails); err != nil {
		return ManagementClientVerifyHostingEnvironmentVnetResponse{}, err
	}
	return result, nil
}
