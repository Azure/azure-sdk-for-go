//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armappservice

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// WebAppsClient contains the methods for the WebApps group.
// Don't use this type directly, use NewWebAppsClient() instead.
type WebAppsClient struct {
	internal       *arm.Client
	subscriptionID string
}

// NewWebAppsClient creates a new instance of WebAppsClient with the specified values.
//   - subscriptionID - Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
//   - credential - used to authorize requests. Usually a credential from azidentity.
//   - options - pass nil to accept the default values.
func NewWebAppsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*WebAppsClient, error) {
	cl, err := arm.NewClient(moduleName, moduleVersion, credential, options)
	if err != nil {
		return nil, err
	}
	client := &WebAppsClient{
		subscriptionID: subscriptionID,
		internal:       cl,
	}
	return client, nil
}

// AddPremierAddOn - Description for Updates a named add-on of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - premierAddOnName - Add-on name.
//   - premierAddOn - A JSON representation of the edited premier add-on.
//   - options - WebAppsClientAddPremierAddOnOptions contains the optional parameters for the WebAppsClient.AddPremierAddOn method.
func (client *WebAppsClient) AddPremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOn, options *WebAppsClientAddPremierAddOnOptions) (WebAppsClientAddPremierAddOnResponse, error) {
	var err error
	const operationName = "WebAppsClient.AddPremierAddOn"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.addPremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, premierAddOn, options)
	if err != nil {
		return WebAppsClientAddPremierAddOnResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientAddPremierAddOnResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientAddPremierAddOnResponse{}, err
	}
	resp, err := client.addPremierAddOnHandleResponse(httpResp)
	return resp, err
}

// addPremierAddOnCreateRequest creates the AddPremierAddOn request.
func (client *WebAppsClient) addPremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOn, options *WebAppsClientAddPremierAddOnOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, premierAddOn); err != nil {
		return nil, err
	}
	return req, nil
}

// addPremierAddOnHandleResponse handles the AddPremierAddOn response.
func (client *WebAppsClient) addPremierAddOnHandleResponse(resp *http.Response) (WebAppsClientAddPremierAddOnResponse, error) {
	result := WebAppsClientAddPremierAddOnResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsClientAddPremierAddOnResponse{}, err
	}
	return result, nil
}

// AddPremierAddOnSlot - Description for Updates a named add-on of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - premierAddOnName - Add-on name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update the named add-on for the production
//     slot.
//   - premierAddOn - A JSON representation of the edited premier add-on.
//   - options - WebAppsClientAddPremierAddOnSlotOptions contains the optional parameters for the WebAppsClient.AddPremierAddOnSlot
//     method.
func (client *WebAppsClient) AddPremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOn, options *WebAppsClientAddPremierAddOnSlotOptions) (WebAppsClientAddPremierAddOnSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.AddPremierAddOnSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.addPremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, premierAddOn, options)
	if err != nil {
		return WebAppsClientAddPremierAddOnSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientAddPremierAddOnSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientAddPremierAddOnSlotResponse{}, err
	}
	resp, err := client.addPremierAddOnSlotHandleResponse(httpResp)
	return resp, err
}

// addPremierAddOnSlotCreateRequest creates the AddPremierAddOnSlot request.
func (client *WebAppsClient) addPremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOn, options *WebAppsClientAddPremierAddOnSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, premierAddOn); err != nil {
		return nil, err
	}
	return req, nil
}

// addPremierAddOnSlotHandleResponse handles the AddPremierAddOnSlot response.
func (client *WebAppsClient) addPremierAddOnSlotHandleResponse(resp *http.Response) (WebAppsClientAddPremierAddOnSlotResponse, error) {
	result := WebAppsClientAddPremierAddOnSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsClientAddPremierAddOnSlotResponse{}, err
	}
	return result, nil
}

// AnalyzeCustomHostname - Description for Analyze a custom hostname.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientAnalyzeCustomHostnameOptions contains the optional parameters for the WebAppsClient.AnalyzeCustomHostname
//     method.
func (client *WebAppsClient) AnalyzeCustomHostname(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientAnalyzeCustomHostnameOptions) (WebAppsClientAnalyzeCustomHostnameResponse, error) {
	var err error
	const operationName = "WebAppsClient.AnalyzeCustomHostname"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.analyzeCustomHostnameCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientAnalyzeCustomHostnameResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientAnalyzeCustomHostnameResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientAnalyzeCustomHostnameResponse{}, err
	}
	resp, err := client.analyzeCustomHostnameHandleResponse(httpResp)
	return resp, err
}

// analyzeCustomHostnameCreateRequest creates the AnalyzeCustomHostname request.
func (client *WebAppsClient) analyzeCustomHostnameCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientAnalyzeCustomHostnameOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/analyzeCustomHostname"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.HostName != nil {
		reqQP.Set("hostName", *options.HostName)
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// analyzeCustomHostnameHandleResponse handles the AnalyzeCustomHostname response.
func (client *WebAppsClient) analyzeCustomHostnameHandleResponse(resp *http.Response) (WebAppsClientAnalyzeCustomHostnameResponse, error) {
	result := WebAppsClientAnalyzeCustomHostnameResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CustomHostnameAnalysisResult); err != nil {
		return WebAppsClientAnalyzeCustomHostnameResponse{}, err
	}
	return result, nil
}

// AnalyzeCustomHostnameSlot - Description for Analyze a custom hostname.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - options - WebAppsClientAnalyzeCustomHostnameSlotOptions contains the optional parameters for the WebAppsClient.AnalyzeCustomHostnameSlot
//     method.
func (client *WebAppsClient) AnalyzeCustomHostnameSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientAnalyzeCustomHostnameSlotOptions) (WebAppsClientAnalyzeCustomHostnameSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.AnalyzeCustomHostnameSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.analyzeCustomHostnameSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientAnalyzeCustomHostnameSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientAnalyzeCustomHostnameSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientAnalyzeCustomHostnameSlotResponse{}, err
	}
	resp, err := client.analyzeCustomHostnameSlotHandleResponse(httpResp)
	return resp, err
}

// analyzeCustomHostnameSlotCreateRequest creates the AnalyzeCustomHostnameSlot request.
func (client *WebAppsClient) analyzeCustomHostnameSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientAnalyzeCustomHostnameSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/analyzeCustomHostname"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.HostName != nil {
		reqQP.Set("hostName", *options.HostName)
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// analyzeCustomHostnameSlotHandleResponse handles the AnalyzeCustomHostnameSlot response.
func (client *WebAppsClient) analyzeCustomHostnameSlotHandleResponse(resp *http.Response) (WebAppsClientAnalyzeCustomHostnameSlotResponse, error) {
	result := WebAppsClientAnalyzeCustomHostnameSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CustomHostnameAnalysisResult); err != nil {
		return WebAppsClientAnalyzeCustomHostnameSlotResponse{}, err
	}
	return result, nil
}

// ApplySlotConfigToProduction - Description for Applies the configuration settings from the target slot onto the current
// slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slotSwapEntity - JSON object that contains the target slot name. See example.
//   - options - WebAppsClientApplySlotConfigToProductionOptions contains the optional parameters for the WebAppsClient.ApplySlotConfigToProduction
//     method.
func (client *WebAppsClient) ApplySlotConfigToProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsClientApplySlotConfigToProductionOptions) (WebAppsClientApplySlotConfigToProductionResponse, error) {
	var err error
	const operationName = "WebAppsClient.ApplySlotConfigToProduction"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.applySlotConfigToProductionCreateRequest(ctx, resourceGroupName, name, slotSwapEntity, options)
	if err != nil {
		return WebAppsClientApplySlotConfigToProductionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientApplySlotConfigToProductionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientApplySlotConfigToProductionResponse{}, err
	}
	return WebAppsClientApplySlotConfigToProductionResponse{}, nil
}

// applySlotConfigToProductionCreateRequest creates the ApplySlotConfigToProduction request.
func (client *WebAppsClient) applySlotConfigToProductionCreateRequest(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsClientApplySlotConfigToProductionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, slotSwapEntity); err != nil {
		return nil, err
	}
	return req, nil
}

// ApplySlotConfigurationSlot - Description for Applies the configuration settings from the target slot onto the current slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
//   - slotSwapEntity - JSON object that contains the target slot name. See example.
//   - options - WebAppsClientApplySlotConfigurationSlotOptions contains the optional parameters for the WebAppsClient.ApplySlotConfigurationSlot
//     method.
func (client *WebAppsClient) ApplySlotConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsClientApplySlotConfigurationSlotOptions) (WebAppsClientApplySlotConfigurationSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ApplySlotConfigurationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.applySlotConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
	if err != nil {
		return WebAppsClientApplySlotConfigurationSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientApplySlotConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientApplySlotConfigurationSlotResponse{}, err
	}
	return WebAppsClientApplySlotConfigurationSlotResponse{}, nil
}

// applySlotConfigurationSlotCreateRequest creates the ApplySlotConfigurationSlot request.
func (client *WebAppsClient) applySlotConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsClientApplySlotConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, slotSwapEntity); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginApproveOrRejectPrivateEndpointConnection - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the site.
//   - options - WebAppsClientBeginApproveOrRejectPrivateEndpointConnectionOptions contains the optional parameters for the WebAppsClient.BeginApproveOrRejectPrivateEndpointConnection
//     method.
func (client *WebAppsClient) BeginApproveOrRejectPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsClientBeginApproveOrRejectPrivateEndpointConnectionOptions) (*runtime.Poller[WebAppsClientApproveOrRejectPrivateEndpointConnectionResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.approveOrRejectPrivateEndpointConnection(ctx, resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientApproveOrRejectPrivateEndpointConnectionResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientApproveOrRejectPrivateEndpointConnectionResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ApproveOrRejectPrivateEndpointConnection - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsClientBeginApproveOrRejectPrivateEndpointConnectionOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginApproveOrRejectPrivateEndpointConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.approveOrRejectPrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// approveOrRejectPrivateEndpointConnectionCreateRequest creates the ApproveOrRejectPrivateEndpointConnection request.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsClientBeginApproveOrRejectPrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, privateEndpointWrapper); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginApproveOrRejectPrivateEndpointConnectionSlot - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the site.
//   - options - WebAppsClientBeginApproveOrRejectPrivateEndpointConnectionSlotOptions contains the optional parameters for the
//     WebAppsClient.BeginApproveOrRejectPrivateEndpointConnectionSlot method.
func (client *WebAppsClient) BeginApproveOrRejectPrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsClientBeginApproveOrRejectPrivateEndpointConnectionSlotOptions) (*runtime.Poller[WebAppsClientApproveOrRejectPrivateEndpointConnectionSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.approveOrRejectPrivateEndpointConnectionSlot(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, privateEndpointWrapper, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientApproveOrRejectPrivateEndpointConnectionSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientApproveOrRejectPrivateEndpointConnectionSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ApproveOrRejectPrivateEndpointConnectionSlot - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsClientBeginApproveOrRejectPrivateEndpointConnectionSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginApproveOrRejectPrivateEndpointConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.approveOrRejectPrivateEndpointConnectionSlotCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, privateEndpointWrapper, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// approveOrRejectPrivateEndpointConnectionSlotCreateRequest creates the ApproveOrRejectPrivateEndpointConnectionSlot request.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsClientBeginApproveOrRejectPrivateEndpointConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, privateEndpointWrapper); err != nil {
		return nil, err
	}
	return req, nil
}

// Backup - Description for Creates a backup of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - request - Backup configuration. You can use the JSON response from the POST action as input here.
//   - options - WebAppsClientBackupOptions contains the optional parameters for the WebAppsClient.Backup method.
func (client *WebAppsClient) Backup(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *WebAppsClientBackupOptions) (WebAppsClientBackupResponse, error) {
	var err error
	const operationName = "WebAppsClient.Backup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.backupCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return WebAppsClientBackupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientBackupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientBackupResponse{}, err
	}
	resp, err := client.backupHandleResponse(httpResp)
	return resp, err
}

// backupCreateRequest creates the Backup request.
func (client *WebAppsClient) backupCreateRequest(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *WebAppsClientBackupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// backupHandleResponse handles the Backup response.
func (client *WebAppsClient) backupHandleResponse(resp *http.Response) (WebAppsClientBackupResponse, error) {
	result := WebAppsClientBackupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return WebAppsClientBackupResponse{}, err
	}
	return result, nil
}

// BackupSlot - Description for Creates a backup of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will create a backup for the production slot.
//   - request - Backup configuration. You can use the JSON response from the POST action as input here.
//   - options - WebAppsClientBackupSlotOptions contains the optional parameters for the WebAppsClient.BackupSlot method.
func (client *WebAppsClient) BackupSlot(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *WebAppsClientBackupSlotOptions) (WebAppsClientBackupSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.BackupSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.backupSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return WebAppsClientBackupSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientBackupSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientBackupSlotResponse{}, err
	}
	resp, err := client.backupSlotHandleResponse(httpResp)
	return resp, err
}

// backupSlotCreateRequest creates the BackupSlot request.
func (client *WebAppsClient) backupSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *WebAppsClientBackupSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// backupSlotHandleResponse handles the BackupSlot response.
func (client *WebAppsClient) backupSlotHandleResponse(resp *http.Response) (WebAppsClientBackupSlotResponse, error) {
	result := WebAppsClientBackupSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return WebAppsClientBackupSlotResponse{}, err
	}
	return result, nil
}

// CreateDeployment - Description for Create a deployment for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - id - ID of an existing deployment.
//   - deployment - Deployment details.
//   - options - WebAppsClientCreateDeploymentOptions contains the optional parameters for the WebAppsClient.CreateDeployment
//     method.
func (client *WebAppsClient) CreateDeployment(ctx context.Context, resourceGroupName string, name string, id string, deployment Deployment, options *WebAppsClientCreateDeploymentOptions) (WebAppsClientCreateDeploymentResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateDeployment"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createDeploymentCreateRequest(ctx, resourceGroupName, name, id, deployment, options)
	if err != nil {
		return WebAppsClientCreateDeploymentResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateDeploymentResponse{}, err
	}
	resp, err := client.createDeploymentHandleResponse(httpResp)
	return resp, err
}

// createDeploymentCreateRequest creates the CreateDeployment request.
func (client *WebAppsClient) createDeploymentCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, deployment Deployment, options *WebAppsClientCreateDeploymentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, deployment); err != nil {
		return nil, err
	}
	return req, nil
}

// createDeploymentHandleResponse handles the CreateDeployment response.
func (client *WebAppsClient) createDeploymentHandleResponse(resp *http.Response) (WebAppsClientCreateDeploymentResponse, error) {
	result := WebAppsClientCreateDeploymentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return WebAppsClientCreateDeploymentResponse{}, err
	}
	return result, nil
}

// CreateDeploymentSlot - Description for Create a deployment for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - id - ID of an existing deployment.
//   - slot - Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
//   - deployment - Deployment details.
//   - options - WebAppsClientCreateDeploymentSlotOptions contains the optional parameters for the WebAppsClient.CreateDeploymentSlot
//     method.
func (client *WebAppsClient) CreateDeploymentSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, deployment Deployment, options *WebAppsClientCreateDeploymentSlotOptions) (WebAppsClientCreateDeploymentSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateDeploymentSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createDeploymentSlotCreateRequest(ctx, resourceGroupName, name, id, slot, deployment, options)
	if err != nil {
		return WebAppsClientCreateDeploymentSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateDeploymentSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateDeploymentSlotResponse{}, err
	}
	resp, err := client.createDeploymentSlotHandleResponse(httpResp)
	return resp, err
}

// createDeploymentSlotCreateRequest creates the CreateDeploymentSlot request.
func (client *WebAppsClient) createDeploymentSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, deployment Deployment, options *WebAppsClientCreateDeploymentSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, deployment); err != nil {
		return nil, err
	}
	return req, nil
}

// createDeploymentSlotHandleResponse handles the CreateDeploymentSlot response.
func (client *WebAppsClient) createDeploymentSlotHandleResponse(resp *http.Response) (WebAppsClientCreateDeploymentSlotResponse, error) {
	result := WebAppsClientCreateDeploymentSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return WebAppsClientCreateDeploymentSlotResponse{}, err
	}
	return result, nil
}

// BeginCreateFunction - Description for Create function for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - Function name.
//   - functionEnvelope - Function details.
//   - options - WebAppsClientBeginCreateFunctionOptions contains the optional parameters for the WebAppsClient.BeginCreateFunction
//     method.
func (client *WebAppsClient) BeginCreateFunction(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope, options *WebAppsClientBeginCreateFunctionOptions) (*runtime.Poller[WebAppsClientCreateFunctionResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createFunction(ctx, resourceGroupName, name, functionName, functionEnvelope, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientCreateFunctionResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientCreateFunctionResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateFunction - Description for Create function for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) createFunction(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope, options *WebAppsClientBeginCreateFunctionOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginCreateFunction"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createFunctionCreateRequest(ctx, resourceGroupName, name, functionName, functionEnvelope, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createFunctionCreateRequest creates the CreateFunction request.
func (client *WebAppsClient) createFunctionCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope, options *WebAppsClientBeginCreateFunctionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, functionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateInstanceFunctionSlot - Description for Create function for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - Function name.
//   - slot - Name of the deployment slot.
//   - functionEnvelope - Function details.
//   - options - WebAppsClientBeginCreateInstanceFunctionSlotOptions contains the optional parameters for the WebAppsClient.BeginCreateInstanceFunctionSlot
//     method.
func (client *WebAppsClient) BeginCreateInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope, options *WebAppsClientBeginCreateInstanceFunctionSlotOptions) (*runtime.Poller[WebAppsClientCreateInstanceFunctionSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createInstanceFunctionSlot(ctx, resourceGroupName, name, functionName, slot, functionEnvelope, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientCreateInstanceFunctionSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientCreateInstanceFunctionSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateInstanceFunctionSlot - Description for Create function for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) createInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope, options *WebAppsClientBeginCreateInstanceFunctionSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginCreateInstanceFunctionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createInstanceFunctionSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, functionEnvelope, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createInstanceFunctionSlotCreateRequest creates the CreateInstanceFunctionSlot request.
func (client *WebAppsClient) createInstanceFunctionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope, options *WebAppsClientBeginCreateInstanceFunctionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, functionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateInstanceMSDeployOperation - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - instanceID - ID of web app instance.
//   - msDeploy - Details of MSDeploy operation
//   - options - WebAppsClientBeginCreateInstanceMSDeployOperationOptions contains the optional parameters for the WebAppsClient.BeginCreateInstanceMSDeployOperation
//     method.
func (client *WebAppsClient) BeginCreateInstanceMSDeployOperation(ctx context.Context, resourceGroupName string, name string, instanceID string, msDeploy MSDeploy, options *WebAppsClientBeginCreateInstanceMSDeployOperationOptions) (*runtime.Poller[WebAppsClientCreateInstanceMSDeployOperationResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createInstanceMSDeployOperation(ctx, resourceGroupName, name, instanceID, msDeploy, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientCreateInstanceMSDeployOperationResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientCreateInstanceMSDeployOperationResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateInstanceMSDeployOperation - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) createInstanceMSDeployOperation(ctx context.Context, resourceGroupName string, name string, instanceID string, msDeploy MSDeploy, options *WebAppsClientBeginCreateInstanceMSDeployOperationOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginCreateInstanceMSDeployOperation"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createInstanceMSDeployOperationCreateRequest(ctx, resourceGroupName, name, instanceID, msDeploy, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createInstanceMSDeployOperationCreateRequest creates the CreateInstanceMSDeployOperation request.
func (client *WebAppsClient) createInstanceMSDeployOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, msDeploy MSDeploy, options *WebAppsClientBeginCreateInstanceMSDeployOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, msDeploy); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateInstanceMSDeployOperationSlot - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - instanceID - ID of web app instance.
//   - msDeploy - Details of MSDeploy operation
//   - options - WebAppsClientBeginCreateInstanceMSDeployOperationSlotOptions contains the optional parameters for the WebAppsClient.BeginCreateInstanceMSDeployOperationSlot
//     method.
func (client *WebAppsClient) BeginCreateInstanceMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, msDeploy MSDeploy, options *WebAppsClientBeginCreateInstanceMSDeployOperationSlotOptions) (*runtime.Poller[WebAppsClientCreateInstanceMSDeployOperationSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createInstanceMSDeployOperationSlot(ctx, resourceGroupName, name, slot, instanceID, msDeploy, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientCreateInstanceMSDeployOperationSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientCreateInstanceMSDeployOperationSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateInstanceMSDeployOperationSlot - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) createInstanceMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, msDeploy MSDeploy, options *WebAppsClientBeginCreateInstanceMSDeployOperationSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginCreateInstanceMSDeployOperationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createInstanceMSDeployOperationSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, msDeploy, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createInstanceMSDeployOperationSlotCreateRequest creates the CreateInstanceMSDeployOperationSlot request.
func (client *WebAppsClient) createInstanceMSDeployOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, msDeploy MSDeploy, options *WebAppsClientBeginCreateInstanceMSDeployOperationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, msDeploy); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateMSDeployOperation - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - msDeploy - Details of MSDeploy operation
//   - options - WebAppsClientBeginCreateMSDeployOperationOptions contains the optional parameters for the WebAppsClient.BeginCreateMSDeployOperation
//     method.
func (client *WebAppsClient) BeginCreateMSDeployOperation(ctx context.Context, resourceGroupName string, name string, msDeploy MSDeploy, options *WebAppsClientBeginCreateMSDeployOperationOptions) (*runtime.Poller[WebAppsClientCreateMSDeployOperationResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createMSDeployOperation(ctx, resourceGroupName, name, msDeploy, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientCreateMSDeployOperationResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientCreateMSDeployOperationResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateMSDeployOperation - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) createMSDeployOperation(ctx context.Context, resourceGroupName string, name string, msDeploy MSDeploy, options *WebAppsClientBeginCreateMSDeployOperationOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginCreateMSDeployOperation"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createMSDeployOperationCreateRequest(ctx, resourceGroupName, name, msDeploy, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createMSDeployOperationCreateRequest creates the CreateMSDeployOperation request.
func (client *WebAppsClient) createMSDeployOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, msDeploy MSDeploy, options *WebAppsClientBeginCreateMSDeployOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, msDeploy); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateMSDeployOperationSlot - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - msDeploy - Details of MSDeploy operation
//   - options - WebAppsClientBeginCreateMSDeployOperationSlotOptions contains the optional parameters for the WebAppsClient.BeginCreateMSDeployOperationSlot
//     method.
func (client *WebAppsClient) BeginCreateMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, msDeploy MSDeploy, options *WebAppsClientBeginCreateMSDeployOperationSlotOptions) (*runtime.Poller[WebAppsClientCreateMSDeployOperationSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createMSDeployOperationSlot(ctx, resourceGroupName, name, slot, msDeploy, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientCreateMSDeployOperationSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientCreateMSDeployOperationSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateMSDeployOperationSlot - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) createMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, msDeploy MSDeploy, options *WebAppsClientBeginCreateMSDeployOperationSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginCreateMSDeployOperationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createMSDeployOperationSlotCreateRequest(ctx, resourceGroupName, name, slot, msDeploy, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createMSDeployOperationSlotCreateRequest creates the CreateMSDeployOperationSlot request.
func (client *WebAppsClient) createMSDeployOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, msDeploy MSDeploy, options *WebAppsClientBeginCreateMSDeployOperationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, msDeploy); err != nil {
		return nil, err
	}
	return req, nil
}

// CreateOneDeployOperation - Description for Invoke the OneDeploy publish web app extension.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientCreateOneDeployOperationOptions contains the optional parameters for the WebAppsClient.CreateOneDeployOperation
//     method.
func (client *WebAppsClient) CreateOneDeployOperation(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientCreateOneDeployOperationOptions) (WebAppsClientCreateOneDeployOperationResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOneDeployOperation"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOneDeployOperationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientCreateOneDeployOperationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOneDeployOperationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOneDeployOperationResponse{}, err
	}
	resp, err := client.createOneDeployOperationHandleResponse(httpResp)
	return resp, err
}

// createOneDeployOperationCreateRequest creates the CreateOneDeployOperation request.
func (client *WebAppsClient) createOneDeployOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientCreateOneDeployOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/onedeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// createOneDeployOperationHandleResponse handles the CreateOneDeployOperation response.
func (client *WebAppsClient) createOneDeployOperationHandleResponse(resp *http.Response) (WebAppsClientCreateOneDeployOperationResponse, error) {
	result := WebAppsClientCreateOneDeployOperationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return WebAppsClientCreateOneDeployOperationResponse{}, err
	}
	return result, nil
}

// BeginCreateOrUpdate - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
// existing app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
//   - siteEnvelope - A JSON representation of the app properties. See example.
//   - options - WebAppsClientBeginCreateOrUpdateOptions contains the optional parameters for the WebAppsClient.BeginCreateOrUpdate
//     method.
func (client *WebAppsClient) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, options *WebAppsClientBeginCreateOrUpdateOptions) (*runtime.Poller[WebAppsClientCreateOrUpdateResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdate(ctx, resourceGroupName, name, siteEnvelope, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientCreateOrUpdateResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientCreateOrUpdateResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateOrUpdate - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing
// app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) createOrUpdate(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, options *WebAppsClientBeginCreateOrUpdateOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginCreateOrUpdate"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateCreateRequest(ctx, resourceGroupName, name, siteEnvelope, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *WebAppsClient) createOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, options *WebAppsClientBeginCreateOrUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// CreateOrUpdateConfiguration - Description for Updates the configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - siteConfig - JSON representation of a SiteConfig object. See example.
//   - options - WebAppsClientCreateOrUpdateConfigurationOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateConfiguration
//     method.
func (client *WebAppsClient) CreateOrUpdateConfiguration(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *WebAppsClientCreateOrUpdateConfigurationOptions) (WebAppsClientCreateOrUpdateConfigurationResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateConfiguration"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateConfigurationCreateRequest(ctx, resourceGroupName, name, siteConfig, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateConfigurationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateConfigurationResponse{}, err
	}
	resp, err := client.createOrUpdateConfigurationHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateConfigurationCreateRequest creates the CreateOrUpdateConfiguration request.
func (client *WebAppsClient) createOrUpdateConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *WebAppsClientCreateOrUpdateConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteConfig); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateConfigurationHandleResponse handles the CreateOrUpdateConfiguration response.
func (client *WebAppsClient) createOrUpdateConfigurationHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateConfigurationResponse, error) {
	result := WebAppsClientCreateOrUpdateConfigurationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsClientCreateOrUpdateConfigurationResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateConfigurationSlot - Description for Updates the configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
//   - siteConfig - JSON representation of a SiteConfig object. See example.
//   - options - WebAppsClientCreateOrUpdateConfigurationSlotOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateConfigurationSlot
//     method.
func (client *WebAppsClient) CreateOrUpdateConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *WebAppsClientCreateOrUpdateConfigurationSlotOptions) (WebAppsClientCreateOrUpdateConfigurationSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateConfigurationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, siteConfig, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateConfigurationSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateConfigurationSlotResponse{}, err
	}
	resp, err := client.createOrUpdateConfigurationSlotHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateConfigurationSlotCreateRequest creates the CreateOrUpdateConfigurationSlot request.
func (client *WebAppsClient) createOrUpdateConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *WebAppsClientCreateOrUpdateConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteConfig); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateConfigurationSlotHandleResponse handles the CreateOrUpdateConfigurationSlot response.
func (client *WebAppsClient) createOrUpdateConfigurationSlotHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateConfigurationSlotResponse, error) {
	result := WebAppsClientCreateOrUpdateConfigurationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsClientCreateOrUpdateConfigurationSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateDomainOwnershipIdentifier - Description for Creates a domain ownership identifier for web app, or updates
// an existing ownership identifier.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - domainOwnershipIdentifierName - Name of domain ownership identifier.
//   - domainOwnershipIdentifier - A JSON representation of the domain ownership properties.
//   - options - WebAppsClientCreateOrUpdateDomainOwnershipIdentifierOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateDomainOwnershipIdentifier
//     method.
func (client *WebAppsClient) CreateOrUpdateDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *WebAppsClientCreateOrUpdateDomainOwnershipIdentifierOptions) (WebAppsClientCreateOrUpdateDomainOwnershipIdentifierResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateDomainOwnershipIdentifier"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateDomainOwnershipIdentifierResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateDomainOwnershipIdentifierResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateDomainOwnershipIdentifierResponse{}, err
	}
	resp, err := client.createOrUpdateDomainOwnershipIdentifierHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateDomainOwnershipIdentifierCreateRequest creates the CreateOrUpdateDomainOwnershipIdentifier request.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *WebAppsClientCreateOrUpdateDomainOwnershipIdentifierOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, domainOwnershipIdentifier); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateDomainOwnershipIdentifierHandleResponse handles the CreateOrUpdateDomainOwnershipIdentifier response.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateDomainOwnershipIdentifierResponse, error) {
	result := WebAppsClientCreateOrUpdateDomainOwnershipIdentifierResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return WebAppsClientCreateOrUpdateDomainOwnershipIdentifierResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateDomainOwnershipIdentifierSlot - Description for Creates a domain ownership identifier for web app, or updates
// an existing ownership identifier.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - domainOwnershipIdentifierName - Name of domain ownership identifier.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
//   - domainOwnershipIdentifier - A JSON representation of the domain ownership properties.
//   - options - WebAppsClientCreateOrUpdateDomainOwnershipIdentifierSlotOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateDomainOwnershipIdentifierSlot
//     method.
func (client *WebAppsClient) CreateOrUpdateDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *WebAppsClientCreateOrUpdateDomainOwnershipIdentifierSlotOptions) (WebAppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateDomainOwnershipIdentifierSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	resp, err := client.createOrUpdateDomainOwnershipIdentifierSlotHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateDomainOwnershipIdentifierSlotCreateRequest creates the CreateOrUpdateDomainOwnershipIdentifierSlot request.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *WebAppsClientCreateOrUpdateDomainOwnershipIdentifierSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, domainOwnershipIdentifier); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateDomainOwnershipIdentifierSlotHandleResponse handles the CreateOrUpdateDomainOwnershipIdentifierSlot response.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierSlotHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse, error) {
	result := WebAppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return WebAppsClientCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateFunctionSecret - Description for Add or update a function secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - The name of the function.
//   - keyName - The name of the key.
//   - key - The key to create or update
//   - options - WebAppsClientCreateOrUpdateFunctionSecretOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateFunctionSecret
//     method.
func (client *WebAppsClient) CreateOrUpdateFunctionSecret(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, key KeyInfo, options *WebAppsClientCreateOrUpdateFunctionSecretOptions) (WebAppsClientCreateOrUpdateFunctionSecretResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateFunctionSecret"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateFunctionSecretCreateRequest(ctx, resourceGroupName, name, functionName, keyName, key, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateFunctionSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateFunctionSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateFunctionSecretResponse{}, err
	}
	resp, err := client.createOrUpdateFunctionSecretHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateFunctionSecretCreateRequest creates the CreateOrUpdateFunctionSecret request.
func (client *WebAppsClient) createOrUpdateFunctionSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, key KeyInfo, options *WebAppsClientCreateOrUpdateFunctionSecretOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, key); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateFunctionSecretHandleResponse handles the CreateOrUpdateFunctionSecret response.
func (client *WebAppsClient) createOrUpdateFunctionSecretHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateFunctionSecretResponse, error) {
	result := WebAppsClientCreateOrUpdateFunctionSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyInfo); err != nil {
		return WebAppsClientCreateOrUpdateFunctionSecretResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateFunctionSecretSlot - Description for Add or update a function secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - The name of the function.
//   - keyName - The name of the key.
//   - slot - Name of the deployment slot.
//   - key - The key to create or update
//   - options - WebAppsClientCreateOrUpdateFunctionSecretSlotOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateFunctionSecretSlot
//     method.
func (client *WebAppsClient) CreateOrUpdateFunctionSecretSlot(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, key KeyInfo, options *WebAppsClientCreateOrUpdateFunctionSecretSlotOptions) (WebAppsClientCreateOrUpdateFunctionSecretSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateFunctionSecretSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateFunctionSecretSlotCreateRequest(ctx, resourceGroupName, name, functionName, keyName, slot, key, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateFunctionSecretSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateFunctionSecretSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateFunctionSecretSlotResponse{}, err
	}
	resp, err := client.createOrUpdateFunctionSecretSlotHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateFunctionSecretSlotCreateRequest creates the CreateOrUpdateFunctionSecretSlot request.
func (client *WebAppsClient) createOrUpdateFunctionSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, key KeyInfo, options *WebAppsClientCreateOrUpdateFunctionSecretSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, key); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateFunctionSecretSlotHandleResponse handles the CreateOrUpdateFunctionSecretSlot response.
func (client *WebAppsClient) createOrUpdateFunctionSecretSlotHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateFunctionSecretSlotResponse, error) {
	result := WebAppsClientCreateOrUpdateFunctionSecretSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyInfo); err != nil {
		return WebAppsClientCreateOrUpdateFunctionSecretSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateHostNameBinding - Description for Creates a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - hostName - Hostname in the hostname binding.
//   - hostNameBinding - Binding details. This is the JSON representation of a HostNameBinding object.
//   - options - WebAppsClientCreateOrUpdateHostNameBindingOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateHostNameBinding
//     method.
func (client *WebAppsClient) CreateOrUpdateHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, hostNameBinding HostNameBinding, options *WebAppsClientCreateOrUpdateHostNameBindingOptions) (WebAppsClientCreateOrUpdateHostNameBindingResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateHostNameBinding"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateHostNameBindingCreateRequest(ctx, resourceGroupName, name, hostName, hostNameBinding, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateHostNameBindingResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateHostNameBindingResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateHostNameBindingResponse{}, err
	}
	resp, err := client.createOrUpdateHostNameBindingHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateHostNameBindingCreateRequest creates the CreateOrUpdateHostNameBinding request.
func (client *WebAppsClient) createOrUpdateHostNameBindingCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, hostNameBinding HostNameBinding, options *WebAppsClientCreateOrUpdateHostNameBindingOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, hostNameBinding); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateHostNameBindingHandleResponse handles the CreateOrUpdateHostNameBinding response.
func (client *WebAppsClient) createOrUpdateHostNameBindingHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateHostNameBindingResponse, error) {
	result := WebAppsClientCreateOrUpdateHostNameBindingResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBinding); err != nil {
		return WebAppsClientCreateOrUpdateHostNameBindingResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateHostNameBindingSlot - Description for Creates a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - hostName - Hostname in the hostname binding.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
//   - hostNameBinding - Binding details. This is the JSON representation of a HostNameBinding object.
//   - options - WebAppsClientCreateOrUpdateHostNameBindingSlotOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateHostNameBindingSlot
//     method.
func (client *WebAppsClient) CreateOrUpdateHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, hostName string, slot string, hostNameBinding HostNameBinding, options *WebAppsClientCreateOrUpdateHostNameBindingSlotOptions) (WebAppsClientCreateOrUpdateHostNameBindingSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateHostNameBindingSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateHostNameBindingSlotCreateRequest(ctx, resourceGroupName, name, hostName, slot, hostNameBinding, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateHostNameBindingSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateHostNameBindingSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateHostNameBindingSlotResponse{}, err
	}
	resp, err := client.createOrUpdateHostNameBindingSlotHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateHostNameBindingSlotCreateRequest creates the CreateOrUpdateHostNameBindingSlot request.
func (client *WebAppsClient) createOrUpdateHostNameBindingSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, slot string, hostNameBinding HostNameBinding, options *WebAppsClientCreateOrUpdateHostNameBindingSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, hostNameBinding); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateHostNameBindingSlotHandleResponse handles the CreateOrUpdateHostNameBindingSlot response.
func (client *WebAppsClient) createOrUpdateHostNameBindingSlotHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateHostNameBindingSlotResponse, error) {
	result := WebAppsClientCreateOrUpdateHostNameBindingSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBinding); err != nil {
		return WebAppsClientCreateOrUpdateHostNameBindingSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateHostSecret - Description for Add or update a host level secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - keyType - The type of host key.
//   - keyName - The name of the key.
//   - key - The key to create or update
//   - options - WebAppsClientCreateOrUpdateHostSecretOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateHostSecret
//     method.
func (client *WebAppsClient) CreateOrUpdateHostSecret(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, key KeyInfo, options *WebAppsClientCreateOrUpdateHostSecretOptions) (WebAppsClientCreateOrUpdateHostSecretResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateHostSecret"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateHostSecretCreateRequest(ctx, resourceGroupName, name, keyType, keyName, key, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateHostSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateHostSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateHostSecretResponse{}, err
	}
	resp, err := client.createOrUpdateHostSecretHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateHostSecretCreateRequest creates the CreateOrUpdateHostSecret request.
func (client *WebAppsClient) createOrUpdateHostSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, key KeyInfo, options *WebAppsClientCreateOrUpdateHostSecretOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, key); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateHostSecretHandleResponse handles the CreateOrUpdateHostSecret response.
func (client *WebAppsClient) createOrUpdateHostSecretHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateHostSecretResponse, error) {
	result := WebAppsClientCreateOrUpdateHostSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyInfo); err != nil {
		return WebAppsClientCreateOrUpdateHostSecretResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateHostSecretSlot - Description for Add or update a host level secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - keyType - The type of host key.
//   - keyName - The name of the key.
//   - slot - Name of the deployment slot.
//   - key - The key to create or update
//   - options - WebAppsClientCreateOrUpdateHostSecretSlotOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateHostSecretSlot
//     method.
func (client *WebAppsClient) CreateOrUpdateHostSecretSlot(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, key KeyInfo, options *WebAppsClientCreateOrUpdateHostSecretSlotOptions) (WebAppsClientCreateOrUpdateHostSecretSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateHostSecretSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateHostSecretSlotCreateRequest(ctx, resourceGroupName, name, keyType, keyName, slot, key, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateHostSecretSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateHostSecretSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateHostSecretSlotResponse{}, err
	}
	resp, err := client.createOrUpdateHostSecretSlotHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateHostSecretSlotCreateRequest creates the CreateOrUpdateHostSecretSlot request.
func (client *WebAppsClient) createOrUpdateHostSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, key KeyInfo, options *WebAppsClientCreateOrUpdateHostSecretSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, key); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateHostSecretSlotHandleResponse handles the CreateOrUpdateHostSecretSlot response.
func (client *WebAppsClient) createOrUpdateHostSecretSlotHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateHostSecretSlotResponse, error) {
	result := WebAppsClientCreateOrUpdateHostSecretSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyInfo); err != nil {
		return WebAppsClientCreateOrUpdateHostSecretSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateHybridConnection - Description for Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - namespaceName - The namespace for this hybrid connection.
//   - relayName - The relay name for this hybrid connection.
//   - connectionEnvelope - The details of the hybrid connection.
//   - options - WebAppsClientCreateOrUpdateHybridConnectionOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateHybridConnection
//     method.
func (client *WebAppsClient) CreateOrUpdateHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *WebAppsClientCreateOrUpdateHybridConnectionOptions) (WebAppsClientCreateOrUpdateHybridConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateHybridConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateHybridConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateHybridConnectionResponse{}, err
	}
	resp, err := client.createOrUpdateHybridConnectionHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateHybridConnectionCreateRequest creates the CreateOrUpdateHybridConnection request.
func (client *WebAppsClient) createOrUpdateHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *WebAppsClientCreateOrUpdateHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateHybridConnectionHandleResponse handles the CreateOrUpdateHybridConnection response.
func (client *WebAppsClient) createOrUpdateHybridConnectionHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateHybridConnectionResponse, error) {
	result := WebAppsClientCreateOrUpdateHybridConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsClientCreateOrUpdateHybridConnectionResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateHybridConnectionSlot - Description for Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - namespaceName - The namespace for this hybrid connection.
//   - relayName - The relay name for this hybrid connection.
//   - slot - The name of the slot for the web app.
//   - connectionEnvelope - The details of the hybrid connection.
//   - options - WebAppsClientCreateOrUpdateHybridConnectionSlotOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateHybridConnectionSlot
//     method.
func (client *WebAppsClient) CreateOrUpdateHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *WebAppsClientCreateOrUpdateHybridConnectionSlotOptions) (WebAppsClientCreateOrUpdateHybridConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateHybridConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateHybridConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateHybridConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateHybridConnectionSlotResponse{}, err
	}
	resp, err := client.createOrUpdateHybridConnectionSlotHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateHybridConnectionSlotCreateRequest creates the CreateOrUpdateHybridConnectionSlot request.
func (client *WebAppsClient) createOrUpdateHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *WebAppsClientCreateOrUpdateHybridConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateHybridConnectionSlotHandleResponse handles the CreateOrUpdateHybridConnectionSlot response.
func (client *WebAppsClient) createOrUpdateHybridConnectionSlotHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateHybridConnectionSlotResponse, error) {
	result := WebAppsClientCreateOrUpdateHybridConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsClientCreateOrUpdateHybridConnectionSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdatePublicCertificate - Description for Creates a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - publicCertificateName - Public certificate name.
//   - publicCertificate - Public certificate details. This is the JSON representation of a PublicCertificate object.
//   - options - WebAppsClientCreateOrUpdatePublicCertificateOptions contains the optional parameters for the WebAppsClient.CreateOrUpdatePublicCertificate
//     method.
func (client *WebAppsClient) CreateOrUpdatePublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, publicCertificate PublicCertificate, options *WebAppsClientCreateOrUpdatePublicCertificateOptions) (WebAppsClientCreateOrUpdatePublicCertificateResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdatePublicCertificate"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdatePublicCertificateCreateRequest(ctx, resourceGroupName, name, publicCertificateName, publicCertificate, options)
	if err != nil {
		return WebAppsClientCreateOrUpdatePublicCertificateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdatePublicCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdatePublicCertificateResponse{}, err
	}
	resp, err := client.createOrUpdatePublicCertificateHandleResponse(httpResp)
	return resp, err
}

// createOrUpdatePublicCertificateCreateRequest creates the CreateOrUpdatePublicCertificate request.
func (client *WebAppsClient) createOrUpdatePublicCertificateCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, publicCertificate PublicCertificate, options *WebAppsClientCreateOrUpdatePublicCertificateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, publicCertificate); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdatePublicCertificateHandleResponse handles the CreateOrUpdatePublicCertificate response.
func (client *WebAppsClient) createOrUpdatePublicCertificateHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdatePublicCertificateResponse, error) {
	result := WebAppsClientCreateOrUpdatePublicCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificate); err != nil {
		return WebAppsClientCreateOrUpdatePublicCertificateResponse{}, err
	}
	return result, nil
}

// CreateOrUpdatePublicCertificateSlot - Description for Creates a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - publicCertificateName - Public certificate name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
//   - publicCertificate - Public certificate details. This is the JSON representation of a PublicCertificate object.
//   - options - WebAppsClientCreateOrUpdatePublicCertificateSlotOptions contains the optional parameters for the WebAppsClient.CreateOrUpdatePublicCertificateSlot
//     method.
func (client *WebAppsClient) CreateOrUpdatePublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, slot string, publicCertificate PublicCertificate, options *WebAppsClientCreateOrUpdatePublicCertificateSlotOptions) (WebAppsClientCreateOrUpdatePublicCertificateSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdatePublicCertificateSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdatePublicCertificateSlotCreateRequest(ctx, resourceGroupName, name, publicCertificateName, slot, publicCertificate, options)
	if err != nil {
		return WebAppsClientCreateOrUpdatePublicCertificateSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdatePublicCertificateSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdatePublicCertificateSlotResponse{}, err
	}
	resp, err := client.createOrUpdatePublicCertificateSlotHandleResponse(httpResp)
	return resp, err
}

// createOrUpdatePublicCertificateSlotCreateRequest creates the CreateOrUpdatePublicCertificateSlot request.
func (client *WebAppsClient) createOrUpdatePublicCertificateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, slot string, publicCertificate PublicCertificate, options *WebAppsClientCreateOrUpdatePublicCertificateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, publicCertificate); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdatePublicCertificateSlotHandleResponse handles the CreateOrUpdatePublicCertificateSlot response.
func (client *WebAppsClient) createOrUpdatePublicCertificateSlotHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdatePublicCertificateSlotResponse, error) {
	result := WebAppsClientCreateOrUpdatePublicCertificateSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificate); err != nil {
		return WebAppsClientCreateOrUpdatePublicCertificateSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateRelayServiceConnection - Description for Creates a new hybrid connection configuration (PUT), or updates
// an existing one (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - entityName - Name of the hybrid connection configuration.
//   - connectionEnvelope - Details of the hybrid connection configuration.
//   - options - WebAppsClientCreateOrUpdateRelayServiceConnectionOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateRelayServiceConnection
//     method.
func (client *WebAppsClient) CreateOrUpdateRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsClientCreateOrUpdateRelayServiceConnectionOptions) (WebAppsClientCreateOrUpdateRelayServiceConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateRelayServiceConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateRelayServiceConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateRelayServiceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateRelayServiceConnectionResponse{}, err
	}
	resp, err := client.createOrUpdateRelayServiceConnectionHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateRelayServiceConnectionCreateRequest creates the CreateOrUpdateRelayServiceConnection request.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsClientCreateOrUpdateRelayServiceConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateRelayServiceConnectionHandleResponse handles the CreateOrUpdateRelayServiceConnection response.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateRelayServiceConnectionResponse, error) {
	result := WebAppsClientCreateOrUpdateRelayServiceConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsClientCreateOrUpdateRelayServiceConnectionResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateRelayServiceConnectionSlot - Description for Creates a new hybrid connection configuration (PUT), or updates
// an existing one (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - entityName - Name of the hybrid connection configuration.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the
//     production slot.
//   - connectionEnvelope - Details of the hybrid connection configuration.
//   - options - WebAppsClientCreateOrUpdateRelayServiceConnectionSlotOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateRelayServiceConnectionSlot
//     method.
func (client *WebAppsClient) CreateOrUpdateRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsClientCreateOrUpdateRelayServiceConnectionSlotOptions) (WebAppsClientCreateOrUpdateRelayServiceConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateRelayServiceConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateRelayServiceConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateRelayServiceConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateRelayServiceConnectionSlotResponse{}, err
	}
	resp, err := client.createOrUpdateRelayServiceConnectionSlotHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateRelayServiceConnectionSlotCreateRequest creates the CreateOrUpdateRelayServiceConnectionSlot request.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsClientCreateOrUpdateRelayServiceConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateRelayServiceConnectionSlotHandleResponse handles the CreateOrUpdateRelayServiceConnectionSlot response.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionSlotHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateRelayServiceConnectionSlotResponse, error) {
	result := WebAppsClientCreateOrUpdateRelayServiceConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsClientCreateOrUpdateRelayServiceConnectionSlotResponse{}, err
	}
	return result, nil
}

// BeginCreateOrUpdateSlot - Description for Creates a new web, mobile, or API app in an existing resource group, or updates
// an existing app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
//   - slot - Name of the deployment slot to create or update. By default, this API attempts to create or modify the production
//     slot.
//   - siteEnvelope - A JSON representation of the app properties. See example.
//   - options - WebAppsClientBeginCreateOrUpdateSlotOptions contains the optional parameters for the WebAppsClient.BeginCreateOrUpdateSlot
//     method.
func (client *WebAppsClient) BeginCreateOrUpdateSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope Site, options *WebAppsClientBeginCreateOrUpdateSlotOptions) (*runtime.Poller[WebAppsClientCreateOrUpdateSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateSlot(ctx, resourceGroupName, name, slot, siteEnvelope, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientCreateOrUpdateSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientCreateOrUpdateSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateOrUpdateSlot - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
// existing app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) createOrUpdateSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope Site, options *WebAppsClientBeginCreateOrUpdateSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginCreateOrUpdateSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateSlotCreateRequest(ctx, resourceGroupName, name, slot, siteEnvelope, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createOrUpdateSlotCreateRequest creates the CreateOrUpdateSlot request.
func (client *WebAppsClient) createOrUpdateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope Site, options *WebAppsClientBeginCreateOrUpdateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateOrUpdateSourceControl - Description for Updates the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - siteSourceControl - JSON representation of a SiteSourceControl object. See example.
//   - options - WebAppsClientBeginCreateOrUpdateSourceControlOptions contains the optional parameters for the WebAppsClient.BeginCreateOrUpdateSourceControl
//     method.
func (client *WebAppsClient) BeginCreateOrUpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsClientBeginCreateOrUpdateSourceControlOptions) (*runtime.Poller[WebAppsClientCreateOrUpdateSourceControlResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateSourceControl(ctx, resourceGroupName, name, siteSourceControl, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientCreateOrUpdateSourceControlResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientCreateOrUpdateSourceControlResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateOrUpdateSourceControl - Description for Updates the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) createOrUpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsClientBeginCreateOrUpdateSourceControlOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginCreateOrUpdateSourceControl"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateSourceControlCreateRequest(ctx, resourceGroupName, name, siteSourceControl, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createOrUpdateSourceControlCreateRequest creates the CreateOrUpdateSourceControl request.
func (client *WebAppsClient) createOrUpdateSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsClientBeginCreateOrUpdateSourceControlOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteSourceControl); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateOrUpdateSourceControlSlot - Description for Updates the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for
//     the production slot.
//   - siteSourceControl - JSON representation of a SiteSourceControl object. See example.
//   - options - WebAppsClientBeginCreateOrUpdateSourceControlSlotOptions contains the optional parameters for the WebAppsClient.BeginCreateOrUpdateSourceControlSlot
//     method.
func (client *WebAppsClient) BeginCreateOrUpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsClientBeginCreateOrUpdateSourceControlSlotOptions) (*runtime.Poller[WebAppsClientCreateOrUpdateSourceControlSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateSourceControlSlot(ctx, resourceGroupName, name, slot, siteSourceControl, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientCreateOrUpdateSourceControlSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientCreateOrUpdateSourceControlSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateOrUpdateSourceControlSlot - Description for Updates the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) createOrUpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsClientBeginCreateOrUpdateSourceControlSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginCreateOrUpdateSourceControlSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, siteSourceControl, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createOrUpdateSourceControlSlotCreateRequest creates the CreateOrUpdateSourceControlSlot request.
func (client *WebAppsClient) createOrUpdateSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsClientBeginCreateOrUpdateSourceControlSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteSourceControl); err != nil {
		return nil, err
	}
	return req, nil
}

// CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck - Description for Integrates this Web App with a Virtual Network.
// This requires that 1) "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has
// already been
// delegated, and is not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - connectionEnvelope - Properties of the Virtual Network connection. See example.
//   - options - WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckOptions contains the optional parameters for
//     the WebAppsClient.CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck method.
func (client *WebAppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckOptions) (WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckCreateRequest(ctx, resourceGroupName, name, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, err
	}
	resp, err := client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckCreateRequest creates the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck request.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleResponse handles the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck response.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse, error) {
	result := WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot - Description for Integrates this Web App with a Virtual Network.
// This requires that 1) "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has
// already been
// delegated, and is not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production
//     slot.
//   - connectionEnvelope - Properties of the Virtual Network connection. See example.
//   - options - WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions contains the optional parameters
//     for the WebAppsClient.CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot method.
func (client *WebAppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions) (WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest(ctx, resourceGroupName, name, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, err
	}
	resp, err := client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest creates the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot request.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse handles the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot response.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse, error) {
	result := WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return WebAppsClientCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateVnetConnection - Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the
// connection properties (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of an existing Virtual Network.
//   - connectionEnvelope - Properties of the Virtual Network connection. See example.
//   - options - WebAppsClientCreateOrUpdateVnetConnectionOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateVnetConnection
//     method.
func (client *WebAppsClient) CreateOrUpdateVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfoResource, options *WebAppsClientCreateOrUpdateVnetConnectionOptions) (WebAppsClientCreateOrUpdateVnetConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateVnetConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateVnetConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateVnetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateVnetConnectionResponse{}, err
	}
	resp, err := client.createOrUpdateVnetConnectionHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateVnetConnectionCreateRequest creates the CreateOrUpdateVnetConnection request.
func (client *WebAppsClient) createOrUpdateVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfoResource, options *WebAppsClientCreateOrUpdateVnetConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateVnetConnectionHandleResponse handles the CreateOrUpdateVnetConnection response.
func (client *WebAppsClient) createOrUpdateVnetConnectionHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateVnetConnectionResponse, error) {
	result := WebAppsClientCreateOrUpdateVnetConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResource); err != nil {
		return WebAppsClientCreateOrUpdateVnetConnectionResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateVnetConnectionGateway - Description for Adds a gateway to a connected Virtual Network (PUT) or updates it
// (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of the Virtual Network.
//   - gatewayName - Name of the gateway. Currently, the only supported string is "primary".
//   - connectionEnvelope - The properties to update this gateway with.
//   - options - WebAppsClientCreateOrUpdateVnetConnectionGatewayOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateVnetConnectionGateway
//     method.
func (client *WebAppsClient) CreateOrUpdateVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *WebAppsClientCreateOrUpdateVnetConnectionGatewayOptions) (WebAppsClientCreateOrUpdateVnetConnectionGatewayResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateVnetConnectionGateway"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateVnetConnectionGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateVnetConnectionGatewayResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateVnetConnectionGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateVnetConnectionGatewayResponse{}, err
	}
	resp, err := client.createOrUpdateVnetConnectionGatewayHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateVnetConnectionGatewayCreateRequest creates the CreateOrUpdateVnetConnectionGateway request.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *WebAppsClientCreateOrUpdateVnetConnectionGatewayOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateVnetConnectionGatewayHandleResponse handles the CreateOrUpdateVnetConnectionGateway response.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewayHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateVnetConnectionGatewayResponse, error) {
	result := WebAppsClientCreateOrUpdateVnetConnectionGatewayResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return WebAppsClientCreateOrUpdateVnetConnectionGatewayResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateVnetConnectionGatewaySlot - Description for Adds a gateway to a connected Virtual Network (PUT) or updates
// it (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of the Virtual Network.
//   - gatewayName - Name of the gateway. Currently, the only supported string is "primary".
//   - slot - Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production
//     slot's Virtual Network.
//   - connectionEnvelope - The properties to update this gateway with.
//   - options - WebAppsClientCreateOrUpdateVnetConnectionGatewaySlotOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateVnetConnectionGatewaySlot
//     method.
func (client *WebAppsClient) CreateOrUpdateVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *WebAppsClientCreateOrUpdateVnetConnectionGatewaySlotOptions) (WebAppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateVnetConnectionGatewaySlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateVnetConnectionGatewaySlotCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	resp, err := client.createOrUpdateVnetConnectionGatewaySlotHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateVnetConnectionGatewaySlotCreateRequest creates the CreateOrUpdateVnetConnectionGatewaySlot request.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewaySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *WebAppsClientCreateOrUpdateVnetConnectionGatewaySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateVnetConnectionGatewaySlotHandleResponse handles the CreateOrUpdateVnetConnectionGatewaySlot response.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewaySlotHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse, error) {
	result := WebAppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return WebAppsClientCreateOrUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateVnetConnectionSlot - Description for Adds a Virtual Network connection to an app or slot (PUT) or updates
// the connection properties (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of an existing Virtual Network.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production
//     slot.
//   - connectionEnvelope - Properties of the Virtual Network connection. See example.
//   - options - WebAppsClientCreateOrUpdateVnetConnectionSlotOptions contains the optional parameters for the WebAppsClient.CreateOrUpdateVnetConnectionSlot
//     method.
func (client *WebAppsClient) CreateOrUpdateVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfoResource, options *WebAppsClientCreateOrUpdateVnetConnectionSlotOptions) (WebAppsClientCreateOrUpdateVnetConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.CreateOrUpdateVnetConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientCreateOrUpdateVnetConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientCreateOrUpdateVnetConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientCreateOrUpdateVnetConnectionSlotResponse{}, err
	}
	resp, err := client.createOrUpdateVnetConnectionSlotHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateVnetConnectionSlotCreateRequest creates the CreateOrUpdateVnetConnectionSlot request.
func (client *WebAppsClient) createOrUpdateVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfoResource, options *WebAppsClientCreateOrUpdateVnetConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateVnetConnectionSlotHandleResponse handles the CreateOrUpdateVnetConnectionSlot response.
func (client *WebAppsClient) createOrUpdateVnetConnectionSlotHandleResponse(resp *http.Response) (WebAppsClientCreateOrUpdateVnetConnectionSlotResponse, error) {
	result := WebAppsClientCreateOrUpdateVnetConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResource); err != nil {
		return WebAppsClientCreateOrUpdateVnetConnectionSlotResponse{}, err
	}
	return result, nil
}

// Delete - Description for Deletes a web, mobile, or API app, or one of the deployment slots.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app to delete.
//   - options - WebAppsClientDeleteOptions contains the optional parameters for the WebAppsClient.Delete method.
func (client *WebAppsClient) Delete(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientDeleteOptions) (WebAppsClientDeleteResponse, error) {
	var err error
	const operationName = "WebAppsClient.Delete"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientDeleteResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteResponse{}, err
	}
	return WebAppsClientDeleteResponse{}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *WebAppsClient) deleteCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientDeleteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DeleteMetrics != nil {
		reqQP.Set("deleteMetrics", strconv.FormatBool(*options.DeleteMetrics))
	}
	if options != nil && options.DeleteEmptyServerFarm != nil {
		reqQP.Set("deleteEmptyServerFarm", strconv.FormatBool(*options.DeleteEmptyServerFarm))
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteBackup - Description for Deletes a backup of an app by its ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - backupID - ID of the backup.
//   - options - WebAppsClientDeleteBackupOptions contains the optional parameters for the WebAppsClient.DeleteBackup method.
func (client *WebAppsClient) DeleteBackup(ctx context.Context, resourceGroupName string, name string, backupID string, options *WebAppsClientDeleteBackupOptions) (WebAppsClientDeleteBackupResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteBackup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteBackupCreateRequest(ctx, resourceGroupName, name, backupID, options)
	if err != nil {
		return WebAppsClientDeleteBackupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteBackupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteBackupResponse{}, err
	}
	return WebAppsClientDeleteBackupResponse{}, nil
}

// deleteBackupCreateRequest creates the DeleteBackup request.
func (client *WebAppsClient) deleteBackupCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, options *WebAppsClientDeleteBackupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteBackupConfiguration - Description for Deletes the backup configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientDeleteBackupConfigurationOptions contains the optional parameters for the WebAppsClient.DeleteBackupConfiguration
//     method.
func (client *WebAppsClient) DeleteBackupConfiguration(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientDeleteBackupConfigurationOptions) (WebAppsClientDeleteBackupConfigurationResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteBackupConfiguration"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteBackupConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientDeleteBackupConfigurationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteBackupConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteBackupConfigurationResponse{}, err
	}
	return WebAppsClientDeleteBackupConfigurationResponse{}, nil
}

// deleteBackupConfigurationCreateRequest creates the DeleteBackupConfiguration request.
func (client *WebAppsClient) deleteBackupConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientDeleteBackupConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteBackupConfigurationSlot - Description for Deletes the backup configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete the backup configuration for the production
//     slot.
//   - options - WebAppsClientDeleteBackupConfigurationSlotOptions contains the optional parameters for the WebAppsClient.DeleteBackupConfigurationSlot
//     method.
func (client *WebAppsClient) DeleteBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientDeleteBackupConfigurationSlotOptions) (WebAppsClientDeleteBackupConfigurationSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteBackupConfigurationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteBackupConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientDeleteBackupConfigurationSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteBackupConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteBackupConfigurationSlotResponse{}, err
	}
	return WebAppsClientDeleteBackupConfigurationSlotResponse{}, nil
}

// deleteBackupConfigurationSlotCreateRequest creates the DeleteBackupConfigurationSlot request.
func (client *WebAppsClient) deleteBackupConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientDeleteBackupConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteBackupSlot - Description for Deletes a backup of an app by its ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - backupID - ID of the backup.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete a backup of the production slot.
//   - options - WebAppsClientDeleteBackupSlotOptions contains the optional parameters for the WebAppsClient.DeleteBackupSlot
//     method.
func (client *WebAppsClient) DeleteBackupSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *WebAppsClientDeleteBackupSlotOptions) (WebAppsClientDeleteBackupSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteBackupSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteBackupSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, options)
	if err != nil {
		return WebAppsClientDeleteBackupSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteBackupSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteBackupSlotResponse{}, err
	}
	return WebAppsClientDeleteBackupSlotResponse{}, nil
}

// deleteBackupSlotCreateRequest creates the DeleteBackupSlot request.
func (client *WebAppsClient) deleteBackupSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *WebAppsClientDeleteBackupSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteContinuousWebJob - Description for Delete a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - options - WebAppsClientDeleteContinuousWebJobOptions contains the optional parameters for the WebAppsClient.DeleteContinuousWebJob
//     method.
func (client *WebAppsClient) DeleteContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientDeleteContinuousWebJobOptions) (WebAppsClientDeleteContinuousWebJobResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteContinuousWebJob"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsClientDeleteContinuousWebJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteContinuousWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteContinuousWebJobResponse{}, err
	}
	return WebAppsClientDeleteContinuousWebJobResponse{}, nil
}

// deleteContinuousWebJobCreateRequest creates the DeleteContinuousWebJob request.
func (client *WebAppsClient) deleteContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientDeleteContinuousWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteContinuousWebJobSlot - Description for Delete a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
//   - options - WebAppsClientDeleteContinuousWebJobSlotOptions contains the optional parameters for the WebAppsClient.DeleteContinuousWebJobSlot
//     method.
func (client *WebAppsClient) DeleteContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientDeleteContinuousWebJobSlotOptions) (WebAppsClientDeleteContinuousWebJobSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteContinuousWebJobSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsClientDeleteContinuousWebJobSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteContinuousWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteContinuousWebJobSlotResponse{}, err
	}
	return WebAppsClientDeleteContinuousWebJobSlotResponse{}, nil
}

// deleteContinuousWebJobSlotCreateRequest creates the DeleteContinuousWebJobSlot request.
func (client *WebAppsClient) deleteContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientDeleteContinuousWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteDeployment - Description for Delete a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - id - Deployment ID.
//   - options - WebAppsClientDeleteDeploymentOptions contains the optional parameters for the WebAppsClient.DeleteDeployment
//     method.
func (client *WebAppsClient) DeleteDeployment(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsClientDeleteDeploymentOptions) (WebAppsClientDeleteDeploymentResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteDeployment"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteDeploymentCreateRequest(ctx, resourceGroupName, name, id, options)
	if err != nil {
		return WebAppsClientDeleteDeploymentResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteDeploymentResponse{}, err
	}
	return WebAppsClientDeleteDeploymentResponse{}, nil
}

// deleteDeploymentCreateRequest creates the DeleteDeployment request.
func (client *WebAppsClient) deleteDeploymentCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsClientDeleteDeploymentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteDeploymentSlot - Description for Delete a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - id - Deployment ID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
//   - options - WebAppsClientDeleteDeploymentSlotOptions contains the optional parameters for the WebAppsClient.DeleteDeploymentSlot
//     method.
func (client *WebAppsClient) DeleteDeploymentSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsClientDeleteDeploymentSlotOptions) (WebAppsClientDeleteDeploymentSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteDeploymentSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteDeploymentSlotCreateRequest(ctx, resourceGroupName, name, id, slot, options)
	if err != nil {
		return WebAppsClientDeleteDeploymentSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteDeploymentSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteDeploymentSlotResponse{}, err
	}
	return WebAppsClientDeleteDeploymentSlotResponse{}, nil
}

// deleteDeploymentSlotCreateRequest creates the DeleteDeploymentSlot request.
func (client *WebAppsClient) deleteDeploymentSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsClientDeleteDeploymentSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteDomainOwnershipIdentifier - Description for Deletes a domain ownership identifier for a web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - domainOwnershipIdentifierName - Name of domain ownership identifier.
//   - options - WebAppsClientDeleteDomainOwnershipIdentifierOptions contains the optional parameters for the WebAppsClient.DeleteDomainOwnershipIdentifier
//     method.
func (client *WebAppsClient) DeleteDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *WebAppsClientDeleteDomainOwnershipIdentifierOptions) (WebAppsClientDeleteDomainOwnershipIdentifierResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteDomainOwnershipIdentifier"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, options)
	if err != nil {
		return WebAppsClientDeleteDomainOwnershipIdentifierResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteDomainOwnershipIdentifierResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteDomainOwnershipIdentifierResponse{}, err
	}
	return WebAppsClientDeleteDomainOwnershipIdentifierResponse{}, nil
}

// deleteDomainOwnershipIdentifierCreateRequest creates the DeleteDomainOwnershipIdentifier request.
func (client *WebAppsClient) deleteDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *WebAppsClientDeleteDomainOwnershipIdentifierOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteDomainOwnershipIdentifierSlot - Description for Deletes a domain ownership identifier for a web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - domainOwnershipIdentifierName - Name of domain ownership identifier.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
//   - options - WebAppsClientDeleteDomainOwnershipIdentifierSlotOptions contains the optional parameters for the WebAppsClient.DeleteDomainOwnershipIdentifierSlot
//     method.
func (client *WebAppsClient) DeleteDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *WebAppsClientDeleteDomainOwnershipIdentifierSlotOptions) (WebAppsClientDeleteDomainOwnershipIdentifierSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteDomainOwnershipIdentifierSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, options)
	if err != nil {
		return WebAppsClientDeleteDomainOwnershipIdentifierSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteDomainOwnershipIdentifierSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteDomainOwnershipIdentifierSlotResponse{}, err
	}
	return WebAppsClientDeleteDomainOwnershipIdentifierSlotResponse{}, nil
}

// deleteDomainOwnershipIdentifierSlotCreateRequest creates the DeleteDomainOwnershipIdentifierSlot request.
func (client *WebAppsClient) deleteDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *WebAppsClientDeleteDomainOwnershipIdentifierSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteFunction - Description for Delete a function for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - Function name.
//   - options - WebAppsClientDeleteFunctionOptions contains the optional parameters for the WebAppsClient.DeleteFunction method.
func (client *WebAppsClient) DeleteFunction(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsClientDeleteFunctionOptions) (WebAppsClientDeleteFunctionResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteFunction"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteFunctionCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return WebAppsClientDeleteFunctionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteFunctionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteFunctionResponse{}, err
	}
	return WebAppsClientDeleteFunctionResponse{}, nil
}

// deleteFunctionCreateRequest creates the DeleteFunction request.
func (client *WebAppsClient) deleteFunctionCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsClientDeleteFunctionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteFunctionSecret - Description for Delete a function secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - The name of the function.
//   - keyName - The name of the key.
//   - options - WebAppsClientDeleteFunctionSecretOptions contains the optional parameters for the WebAppsClient.DeleteFunctionSecret
//     method.
func (client *WebAppsClient) DeleteFunctionSecret(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, options *WebAppsClientDeleteFunctionSecretOptions) (WebAppsClientDeleteFunctionSecretResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteFunctionSecret"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteFunctionSecretCreateRequest(ctx, resourceGroupName, name, functionName, keyName, options)
	if err != nil {
		return WebAppsClientDeleteFunctionSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteFunctionSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteFunctionSecretResponse{}, err
	}
	return WebAppsClientDeleteFunctionSecretResponse{}, nil
}

// deleteFunctionSecretCreateRequest creates the DeleteFunctionSecret request.
func (client *WebAppsClient) deleteFunctionSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, options *WebAppsClientDeleteFunctionSecretOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteFunctionSecretSlot - Description for Delete a function secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - The name of the function.
//   - keyName - The name of the key.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientDeleteFunctionSecretSlotOptions contains the optional parameters for the WebAppsClient.DeleteFunctionSecretSlot
//     method.
func (client *WebAppsClient) DeleteFunctionSecretSlot(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, options *WebAppsClientDeleteFunctionSecretSlotOptions) (WebAppsClientDeleteFunctionSecretSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteFunctionSecretSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteFunctionSecretSlotCreateRequest(ctx, resourceGroupName, name, functionName, keyName, slot, options)
	if err != nil {
		return WebAppsClientDeleteFunctionSecretSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteFunctionSecretSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteFunctionSecretSlotResponse{}, err
	}
	return WebAppsClientDeleteFunctionSecretSlotResponse{}, nil
}

// deleteFunctionSecretSlotCreateRequest creates the DeleteFunctionSecretSlot request.
func (client *WebAppsClient) deleteFunctionSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, options *WebAppsClientDeleteFunctionSecretSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteHostNameBinding - Description for Deletes a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - hostName - Hostname in the hostname binding.
//   - options - WebAppsClientDeleteHostNameBindingOptions contains the optional parameters for the WebAppsClient.DeleteHostNameBinding
//     method.
func (client *WebAppsClient) DeleteHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, options *WebAppsClientDeleteHostNameBindingOptions) (WebAppsClientDeleteHostNameBindingResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteHostNameBinding"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteHostNameBindingCreateRequest(ctx, resourceGroupName, name, hostName, options)
	if err != nil {
		return WebAppsClientDeleteHostNameBindingResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteHostNameBindingResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteHostNameBindingResponse{}, err
	}
	return WebAppsClientDeleteHostNameBindingResponse{}, nil
}

// deleteHostNameBindingCreateRequest creates the DeleteHostNameBinding request.
func (client *WebAppsClient) deleteHostNameBindingCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, options *WebAppsClientDeleteHostNameBindingOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteHostNameBindingSlot - Description for Deletes a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
//   - hostName - Hostname in the hostname binding.
//   - options - WebAppsClientDeleteHostNameBindingSlotOptions contains the optional parameters for the WebAppsClient.DeleteHostNameBindingSlot
//     method.
func (client *WebAppsClient) DeleteHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *WebAppsClientDeleteHostNameBindingSlotOptions) (WebAppsClientDeleteHostNameBindingSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteHostNameBindingSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteHostNameBindingSlotCreateRequest(ctx, resourceGroupName, name, slot, hostName, options)
	if err != nil {
		return WebAppsClientDeleteHostNameBindingSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteHostNameBindingSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteHostNameBindingSlotResponse{}, err
	}
	return WebAppsClientDeleteHostNameBindingSlotResponse{}, nil
}

// deleteHostNameBindingSlotCreateRequest creates the DeleteHostNameBindingSlot request.
func (client *WebAppsClient) deleteHostNameBindingSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *WebAppsClientDeleteHostNameBindingSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteHostSecret - Description for Delete a host level secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - keyType - The type of host key.
//   - keyName - The name of the key.
//   - options - WebAppsClientDeleteHostSecretOptions contains the optional parameters for the WebAppsClient.DeleteHostSecret
//     method.
func (client *WebAppsClient) DeleteHostSecret(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, options *WebAppsClientDeleteHostSecretOptions) (WebAppsClientDeleteHostSecretResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteHostSecret"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteHostSecretCreateRequest(ctx, resourceGroupName, name, keyType, keyName, options)
	if err != nil {
		return WebAppsClientDeleteHostSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteHostSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteHostSecretResponse{}, err
	}
	return WebAppsClientDeleteHostSecretResponse{}, nil
}

// deleteHostSecretCreateRequest creates the DeleteHostSecret request.
func (client *WebAppsClient) deleteHostSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, options *WebAppsClientDeleteHostSecretOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteHostSecretSlot - Description for Delete a host level secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - keyType - The type of host key.
//   - keyName - The name of the key.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientDeleteHostSecretSlotOptions contains the optional parameters for the WebAppsClient.DeleteHostSecretSlot
//     method.
func (client *WebAppsClient) DeleteHostSecretSlot(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, options *WebAppsClientDeleteHostSecretSlotOptions) (WebAppsClientDeleteHostSecretSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteHostSecretSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteHostSecretSlotCreateRequest(ctx, resourceGroupName, name, keyType, keyName, slot, options)
	if err != nil {
		return WebAppsClientDeleteHostSecretSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteHostSecretSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteHostSecretSlotResponse{}, err
	}
	return WebAppsClientDeleteHostSecretSlotResponse{}, nil
}

// deleteHostSecretSlotCreateRequest creates the DeleteHostSecretSlot request.
func (client *WebAppsClient) deleteHostSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, options *WebAppsClientDeleteHostSecretSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteHybridConnection - Description for Removes a Hybrid Connection from this site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - namespaceName - The namespace for this hybrid connection.
//   - relayName - The relay name for this hybrid connection.
//   - options - WebAppsClientDeleteHybridConnectionOptions contains the optional parameters for the WebAppsClient.DeleteHybridConnection
//     method.
func (client *WebAppsClient) DeleteHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *WebAppsClientDeleteHybridConnectionOptions) (WebAppsClientDeleteHybridConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteHybridConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
	if err != nil {
		return WebAppsClientDeleteHybridConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteHybridConnectionResponse{}, err
	}
	return WebAppsClientDeleteHybridConnectionResponse{}, nil
}

// deleteHybridConnectionCreateRequest creates the DeleteHybridConnection request.
func (client *WebAppsClient) deleteHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *WebAppsClientDeleteHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteHybridConnectionSlot - Description for Removes a Hybrid Connection from this site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - namespaceName - The namespace for this hybrid connection.
//   - relayName - The relay name for this hybrid connection.
//   - slot - The name of the slot for the web app.
//   - options - WebAppsClientDeleteHybridConnectionSlotOptions contains the optional parameters for the WebAppsClient.DeleteHybridConnectionSlot
//     method.
func (client *WebAppsClient) DeleteHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *WebAppsClientDeleteHybridConnectionSlotOptions) (WebAppsClientDeleteHybridConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteHybridConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, options)
	if err != nil {
		return WebAppsClientDeleteHybridConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteHybridConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteHybridConnectionSlotResponse{}, err
	}
	return WebAppsClientDeleteHybridConnectionSlotResponse{}, nil
}

// deleteHybridConnectionSlotCreateRequest creates the DeleteHybridConnectionSlot request.
func (client *WebAppsClient) deleteHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *WebAppsClientDeleteHybridConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteInstanceFunctionSlot - Description for Delete a function for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - Function name.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientDeleteInstanceFunctionSlotOptions contains the optional parameters for the WebAppsClient.DeleteInstanceFunctionSlot
//     method.
func (client *WebAppsClient) DeleteInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsClientDeleteInstanceFunctionSlotOptions) (WebAppsClientDeleteInstanceFunctionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteInstanceFunctionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteInstanceFunctionSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return WebAppsClientDeleteInstanceFunctionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteInstanceFunctionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteInstanceFunctionSlotResponse{}, err
	}
	return WebAppsClientDeleteInstanceFunctionSlotResponse{}, nil
}

// deleteInstanceFunctionSlotCreateRequest creates the DeleteInstanceFunctionSlot request.
func (client *WebAppsClient) deleteInstanceFunctionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsClientDeleteInstanceFunctionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteInstanceProcess - Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
// scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientDeleteInstanceProcessOptions contains the optional parameters for the WebAppsClient.DeleteInstanceProcess
//     method.
func (client *WebAppsClient) DeleteInstanceProcess(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsClientDeleteInstanceProcessOptions) (WebAppsClientDeleteInstanceProcessResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteInstanceProcess"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteInstanceProcessCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
	if err != nil {
		return WebAppsClientDeleteInstanceProcessResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteInstanceProcessResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteInstanceProcessResponse{}, err
	}
	return WebAppsClientDeleteInstanceProcessResponse{}, nil
}

// deleteInstanceProcessCreateRequest creates the DeleteInstanceProcess request.
func (client *WebAppsClient) deleteInstanceProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsClientDeleteInstanceProcessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteInstanceProcessSlot - Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
// scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientDeleteInstanceProcessSlotOptions contains the optional parameters for the WebAppsClient.DeleteInstanceProcessSlot
//     method.
func (client *WebAppsClient) DeleteInstanceProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsClientDeleteInstanceProcessSlotOptions) (WebAppsClientDeleteInstanceProcessSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteInstanceProcessSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteInstanceProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
	if err != nil {
		return WebAppsClientDeleteInstanceProcessSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteInstanceProcessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteInstanceProcessSlotResponse{}, err
	}
	return WebAppsClientDeleteInstanceProcessSlotResponse{}, nil
}

// deleteInstanceProcessSlotCreateRequest creates the DeleteInstanceProcessSlot request.
func (client *WebAppsClient) deleteInstanceProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsClientDeleteInstanceProcessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeletePremierAddOn - Description for Delete a premier add-on from an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - premierAddOnName - Add-on name.
//   - options - WebAppsClientDeletePremierAddOnOptions contains the optional parameters for the WebAppsClient.DeletePremierAddOn
//     method.
func (client *WebAppsClient) DeletePremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *WebAppsClientDeletePremierAddOnOptions) (WebAppsClientDeletePremierAddOnResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeletePremierAddOn"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deletePremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, options)
	if err != nil {
		return WebAppsClientDeletePremierAddOnResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeletePremierAddOnResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeletePremierAddOnResponse{}, err
	}
	return WebAppsClientDeletePremierAddOnResponse{}, nil
}

// deletePremierAddOnCreateRequest creates the DeletePremierAddOn request.
func (client *WebAppsClient) deletePremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *WebAppsClientDeletePremierAddOnOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeletePremierAddOnSlot - Description for Delete a premier add-on from an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - premierAddOnName - Add-on name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete the named add-on for the production
//     slot.
//   - options - WebAppsClientDeletePremierAddOnSlotOptions contains the optional parameters for the WebAppsClient.DeletePremierAddOnSlot
//     method.
func (client *WebAppsClient) DeletePremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *WebAppsClientDeletePremierAddOnSlotOptions) (WebAppsClientDeletePremierAddOnSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeletePremierAddOnSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deletePremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, options)
	if err != nil {
		return WebAppsClientDeletePremierAddOnSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeletePremierAddOnSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeletePremierAddOnSlotResponse{}, err
	}
	return WebAppsClientDeletePremierAddOnSlotResponse{}, nil
}

// deletePremierAddOnSlotCreateRequest creates the DeletePremierAddOnSlot request.
func (client *WebAppsClient) deletePremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *WebAppsClientDeletePremierAddOnSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeletePrivateEndpointConnection - Description for Deletes a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the site.
//   - options - WebAppsClientBeginDeletePrivateEndpointConnectionOptions contains the optional parameters for the WebAppsClient.BeginDeletePrivateEndpointConnection
//     method.
func (client *WebAppsClient) BeginDeletePrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsClientBeginDeletePrivateEndpointConnectionOptions) (*runtime.Poller[WebAppsClientDeletePrivateEndpointConnectionResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deletePrivateEndpointConnection(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientDeletePrivateEndpointConnectionResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientDeletePrivateEndpointConnectionResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeletePrivateEndpointConnection - Description for Deletes a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) deletePrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsClientBeginDeletePrivateEndpointConnectionOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginDeletePrivateEndpointConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deletePrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// deletePrivateEndpointConnectionCreateRequest creates the DeletePrivateEndpointConnection request.
func (client *WebAppsClient) deletePrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsClientBeginDeletePrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeletePrivateEndpointConnectionSlot - Description for Deletes a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the site.
//   - options - WebAppsClientBeginDeletePrivateEndpointConnectionSlotOptions contains the optional parameters for the WebAppsClient.BeginDeletePrivateEndpointConnectionSlot
//     method.
func (client *WebAppsClient) BeginDeletePrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsClientBeginDeletePrivateEndpointConnectionSlotOptions) (*runtime.Poller[WebAppsClientDeletePrivateEndpointConnectionSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deletePrivateEndpointConnectionSlot(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientDeletePrivateEndpointConnectionSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientDeletePrivateEndpointConnectionSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeletePrivateEndpointConnectionSlot - Description for Deletes a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) deletePrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsClientBeginDeletePrivateEndpointConnectionSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginDeletePrivateEndpointConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deletePrivateEndpointConnectionSlotCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// deletePrivateEndpointConnectionSlotCreateRequest creates the DeletePrivateEndpointConnectionSlot request.
func (client *WebAppsClient) deletePrivateEndpointConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsClientBeginDeletePrivateEndpointConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteProcess - Description for Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out
// instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - options - WebAppsClientDeleteProcessOptions contains the optional parameters for the WebAppsClient.DeleteProcess method.
func (client *WebAppsClient) DeleteProcess(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsClientDeleteProcessOptions) (WebAppsClientDeleteProcessResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteProcess"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteProcessCreateRequest(ctx, resourceGroupName, name, processID, options)
	if err != nil {
		return WebAppsClientDeleteProcessResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteProcessResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteProcessResponse{}, err
	}
	return WebAppsClientDeleteProcessResponse{}, nil
}

// deleteProcessCreateRequest creates the DeleteProcess request.
func (client *WebAppsClient) deleteProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsClientDeleteProcessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteProcessSlot - Description for Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out
// instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - options - WebAppsClientDeleteProcessSlotOptions contains the optional parameters for the WebAppsClient.DeleteProcessSlot
//     method.
func (client *WebAppsClient) DeleteProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsClientDeleteProcessSlotOptions) (WebAppsClientDeleteProcessSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteProcessSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
	if err != nil {
		return WebAppsClientDeleteProcessSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteProcessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteProcessSlotResponse{}, err
	}
	return WebAppsClientDeleteProcessSlotResponse{}, nil
}

// deleteProcessSlotCreateRequest creates the DeleteProcessSlot request.
func (client *WebAppsClient) deleteProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsClientDeleteProcessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeletePublicCertificate - Description for Deletes a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - publicCertificateName - Public certificate name.
//   - options - WebAppsClientDeletePublicCertificateOptions contains the optional parameters for the WebAppsClient.DeletePublicCertificate
//     method.
func (client *WebAppsClient) DeletePublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *WebAppsClientDeletePublicCertificateOptions) (WebAppsClientDeletePublicCertificateResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeletePublicCertificate"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deletePublicCertificateCreateRequest(ctx, resourceGroupName, name, publicCertificateName, options)
	if err != nil {
		return WebAppsClientDeletePublicCertificateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeletePublicCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeletePublicCertificateResponse{}, err
	}
	return WebAppsClientDeletePublicCertificateResponse{}, nil
}

// deletePublicCertificateCreateRequest creates the DeletePublicCertificate request.
func (client *WebAppsClient) deletePublicCertificateCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *WebAppsClientDeletePublicCertificateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeletePublicCertificateSlot - Description for Deletes a hostname binding for an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
//   - publicCertificateName - Public certificate name.
//   - options - WebAppsClientDeletePublicCertificateSlotOptions contains the optional parameters for the WebAppsClient.DeletePublicCertificateSlot
//     method.
func (client *WebAppsClient) DeletePublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *WebAppsClientDeletePublicCertificateSlotOptions) (WebAppsClientDeletePublicCertificateSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeletePublicCertificateSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deletePublicCertificateSlotCreateRequest(ctx, resourceGroupName, name, slot, publicCertificateName, options)
	if err != nil {
		return WebAppsClientDeletePublicCertificateSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeletePublicCertificateSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeletePublicCertificateSlotResponse{}, err
	}
	return WebAppsClientDeletePublicCertificateSlotResponse{}, nil
}

// deletePublicCertificateSlotCreateRequest creates the DeletePublicCertificateSlot request.
func (client *WebAppsClient) deletePublicCertificateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *WebAppsClientDeletePublicCertificateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteRelayServiceConnection - Description for Deletes a relay service connection by its name.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - entityName - Name of the hybrid connection configuration.
//   - options - WebAppsClientDeleteRelayServiceConnectionOptions contains the optional parameters for the WebAppsClient.DeleteRelayServiceConnection
//     method.
func (client *WebAppsClient) DeleteRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, options *WebAppsClientDeleteRelayServiceConnectionOptions) (WebAppsClientDeleteRelayServiceConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteRelayServiceConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, options)
	if err != nil {
		return WebAppsClientDeleteRelayServiceConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteRelayServiceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteRelayServiceConnectionResponse{}, err
	}
	return WebAppsClientDeleteRelayServiceConnectionResponse{}, nil
}

// deleteRelayServiceConnectionCreateRequest creates the DeleteRelayServiceConnection request.
func (client *WebAppsClient) deleteRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, options *WebAppsClientDeleteRelayServiceConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteRelayServiceConnectionSlot - Description for Deletes a relay service connection by its name.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - entityName - Name of the hybrid connection configuration.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete a hybrid connection for the production
//     slot.
//   - options - WebAppsClientDeleteRelayServiceConnectionSlotOptions contains the optional parameters for the WebAppsClient.DeleteRelayServiceConnectionSlot
//     method.
func (client *WebAppsClient) DeleteRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *WebAppsClientDeleteRelayServiceConnectionSlotOptions) (WebAppsClientDeleteRelayServiceConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteRelayServiceConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, options)
	if err != nil {
		return WebAppsClientDeleteRelayServiceConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteRelayServiceConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteRelayServiceConnectionSlotResponse{}, err
	}
	return WebAppsClientDeleteRelayServiceConnectionSlotResponse{}, nil
}

// deleteRelayServiceConnectionSlotCreateRequest creates the DeleteRelayServiceConnectionSlot request.
func (client *WebAppsClient) deleteRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *WebAppsClientDeleteRelayServiceConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteSiteExtension - Description for Remove a site extension from a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - siteExtensionID - Site extension name.
//   - options - WebAppsClientDeleteSiteExtensionOptions contains the optional parameters for the WebAppsClient.DeleteSiteExtension
//     method.
func (client *WebAppsClient) DeleteSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsClientDeleteSiteExtensionOptions) (WebAppsClientDeleteSiteExtensionResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteSiteExtension"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteSiteExtensionCreateRequest(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return WebAppsClientDeleteSiteExtensionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteSiteExtensionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteSiteExtensionResponse{}, err
	}
	return WebAppsClientDeleteSiteExtensionResponse{}, nil
}

// deleteSiteExtensionCreateRequest creates the DeleteSiteExtension request.
func (client *WebAppsClient) deleteSiteExtensionCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsClientDeleteSiteExtensionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteSiteExtensionSlot - Description for Remove a site extension from a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - siteExtensionID - Site extension name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
//   - options - WebAppsClientDeleteSiteExtensionSlotOptions contains the optional parameters for the WebAppsClient.DeleteSiteExtensionSlot
//     method.
func (client *WebAppsClient) DeleteSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsClientDeleteSiteExtensionSlotOptions) (WebAppsClientDeleteSiteExtensionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteSiteExtensionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteSiteExtensionSlotCreateRequest(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return WebAppsClientDeleteSiteExtensionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteSiteExtensionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteSiteExtensionSlotResponse{}, err
	}
	return WebAppsClientDeleteSiteExtensionSlotResponse{}, nil
}

// deleteSiteExtensionSlotCreateRequest creates the DeleteSiteExtensionSlot request.
func (client *WebAppsClient) deleteSiteExtensionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsClientDeleteSiteExtensionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteSlot - Description for Deletes a web, mobile, or API app, or one of the deployment slots.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app to delete.
//   - slot - Name of the deployment slot to delete. By default, the API deletes the production slot.
//   - options - WebAppsClientDeleteSlotOptions contains the optional parameters for the WebAppsClient.DeleteSlot method.
func (client *WebAppsClient) DeleteSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientDeleteSlotOptions) (WebAppsClientDeleteSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientDeleteSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteSlotResponse{}, err
	}
	return WebAppsClientDeleteSlotResponse{}, nil
}

// deleteSlotCreateRequest creates the DeleteSlot request.
func (client *WebAppsClient) deleteSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientDeleteSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DeleteMetrics != nil {
		reqQP.Set("deleteMetrics", strconv.FormatBool(*options.DeleteMetrics))
	}
	if options != nil && options.DeleteEmptyServerFarm != nil {
		reqQP.Set("deleteEmptyServerFarm", strconv.FormatBool(*options.DeleteEmptyServerFarm))
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteSourceControl - Description for Deletes the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientDeleteSourceControlOptions contains the optional parameters for the WebAppsClient.DeleteSourceControl
//     method.
func (client *WebAppsClient) DeleteSourceControl(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientDeleteSourceControlOptions) (WebAppsClientDeleteSourceControlResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteSourceControl"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteSourceControlCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientDeleteSourceControlResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteSourceControlResponse{}, err
	}
	return WebAppsClientDeleteSourceControlResponse{}, nil
}

// deleteSourceControlCreateRequest creates the DeleteSourceControl request.
func (client *WebAppsClient) deleteSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientDeleteSourceControlOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.AdditionalFlags != nil {
		reqQP.Set("additionalFlags", *options.AdditionalFlags)
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteSourceControlSlot - Description for Deletes the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete the source control configuration for
//     the production slot.
//   - options - WebAppsClientDeleteSourceControlSlotOptions contains the optional parameters for the WebAppsClient.DeleteSourceControlSlot
//     method.
func (client *WebAppsClient) DeleteSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientDeleteSourceControlSlotOptions) (WebAppsClientDeleteSourceControlSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteSourceControlSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientDeleteSourceControlSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteSourceControlSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteSourceControlSlotResponse{}, err
	}
	return WebAppsClientDeleteSourceControlSlotResponse{}, nil
}

// deleteSourceControlSlotCreateRequest creates the DeleteSourceControlSlot request.
func (client *WebAppsClient) deleteSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientDeleteSourceControlSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.AdditionalFlags != nil {
		reqQP.Set("additionalFlags", *options.AdditionalFlags)
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteSwiftVirtualNetwork - Description for Deletes a Swift Virtual Network connection from an app (or deployment slot).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientDeleteSwiftVirtualNetworkOptions contains the optional parameters for the WebAppsClient.DeleteSwiftVirtualNetwork
//     method.
func (client *WebAppsClient) DeleteSwiftVirtualNetwork(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientDeleteSwiftVirtualNetworkOptions) (WebAppsClientDeleteSwiftVirtualNetworkResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteSwiftVirtualNetwork"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteSwiftVirtualNetworkCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientDeleteSwiftVirtualNetworkResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteSwiftVirtualNetworkResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteSwiftVirtualNetworkResponse{}, err
	}
	return WebAppsClientDeleteSwiftVirtualNetworkResponse{}, nil
}

// deleteSwiftVirtualNetworkCreateRequest creates the DeleteSwiftVirtualNetwork request.
func (client *WebAppsClient) deleteSwiftVirtualNetworkCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientDeleteSwiftVirtualNetworkOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteSwiftVirtualNetworkSlot - Description for Deletes a Swift Virtual Network connection from an app (or deployment slot).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete the connection for the production slot.
//   - options - WebAppsClientDeleteSwiftVirtualNetworkSlotOptions contains the optional parameters for the WebAppsClient.DeleteSwiftVirtualNetworkSlot
//     method.
func (client *WebAppsClient) DeleteSwiftVirtualNetworkSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientDeleteSwiftVirtualNetworkSlotOptions) (WebAppsClientDeleteSwiftVirtualNetworkSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteSwiftVirtualNetworkSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteSwiftVirtualNetworkSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientDeleteSwiftVirtualNetworkSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteSwiftVirtualNetworkSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteSwiftVirtualNetworkSlotResponse{}, err
	}
	return WebAppsClientDeleteSwiftVirtualNetworkSlotResponse{}, nil
}

// deleteSwiftVirtualNetworkSlotCreateRequest creates the DeleteSwiftVirtualNetworkSlot request.
func (client *WebAppsClient) deleteSwiftVirtualNetworkSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientDeleteSwiftVirtualNetworkSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteTriggeredWebJob - Description for Delete a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - options - WebAppsClientDeleteTriggeredWebJobOptions contains the optional parameters for the WebAppsClient.DeleteTriggeredWebJob
//     method.
func (client *WebAppsClient) DeleteTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientDeleteTriggeredWebJobOptions) (WebAppsClientDeleteTriggeredWebJobResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteTriggeredWebJob"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteTriggeredWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsClientDeleteTriggeredWebJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteTriggeredWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteTriggeredWebJobResponse{}, err
	}
	return WebAppsClientDeleteTriggeredWebJobResponse{}, nil
}

// deleteTriggeredWebJobCreateRequest creates the DeleteTriggeredWebJob request.
func (client *WebAppsClient) deleteTriggeredWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientDeleteTriggeredWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteTriggeredWebJobSlot - Description for Delete a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - slot - Name of the deployment slot. If a slot is not specified, the API deletes web job for the production slot.
//   - options - WebAppsClientDeleteTriggeredWebJobSlotOptions contains the optional parameters for the WebAppsClient.DeleteTriggeredWebJobSlot
//     method.
func (client *WebAppsClient) DeleteTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientDeleteTriggeredWebJobSlotOptions) (WebAppsClientDeleteTriggeredWebJobSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteTriggeredWebJobSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteTriggeredWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsClientDeleteTriggeredWebJobSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteTriggeredWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteTriggeredWebJobSlotResponse{}, err
	}
	return WebAppsClientDeleteTriggeredWebJobSlotResponse{}, nil
}

// deleteTriggeredWebJobSlotCreateRequest creates the DeleteTriggeredWebJobSlot request.
func (client *WebAppsClient) deleteTriggeredWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientDeleteTriggeredWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteVnetConnection - Description for Deletes a connection from an app (or deployment slot to a named virtual network.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of the virtual network.
//   - options - WebAppsClientDeleteVnetConnectionOptions contains the optional parameters for the WebAppsClient.DeleteVnetConnection
//     method.
func (client *WebAppsClient) DeleteVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, options *WebAppsClientDeleteVnetConnectionOptions) (WebAppsClientDeleteVnetConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteVnetConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, options)
	if err != nil {
		return WebAppsClientDeleteVnetConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteVnetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteVnetConnectionResponse{}, err
	}
	return WebAppsClientDeleteVnetConnectionResponse{}, nil
}

// deleteVnetConnectionCreateRequest creates the DeleteVnetConnection request.
func (client *WebAppsClient) deleteVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, options *WebAppsClientDeleteVnetConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteVnetConnectionSlot - Description for Deletes a connection from an app (or deployment slot to a named virtual network.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of the virtual network.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete the connection for the production slot.
//   - options - WebAppsClientDeleteVnetConnectionSlotOptions contains the optional parameters for the WebAppsClient.DeleteVnetConnectionSlot
//     method.
func (client *WebAppsClient) DeleteVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *WebAppsClientDeleteVnetConnectionSlotOptions) (WebAppsClientDeleteVnetConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeleteVnetConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, options)
	if err != nil {
		return WebAppsClientDeleteVnetConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeleteVnetConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeleteVnetConnectionSlotResponse{}, err
	}
	return WebAppsClientDeleteVnetConnectionSlotResponse{}, nil
}

// deleteVnetConnectionSlotCreateRequest creates the DeleteVnetConnectionSlot request.
func (client *WebAppsClient) deleteVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *WebAppsClientDeleteVnetConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeployWorkflowArtifacts - Description for Creates the artifacts for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - options - WebAppsClientDeployWorkflowArtifactsOptions contains the optional parameters for the WebAppsClient.DeployWorkflowArtifacts
//     method.
func (client *WebAppsClient) DeployWorkflowArtifacts(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientDeployWorkflowArtifactsOptions) (WebAppsClientDeployWorkflowArtifactsResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeployWorkflowArtifacts"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deployWorkflowArtifactsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientDeployWorkflowArtifactsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeployWorkflowArtifactsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeployWorkflowArtifactsResponse{}, err
	}
	return WebAppsClientDeployWorkflowArtifactsResponse{}, nil
}

// deployWorkflowArtifactsCreateRequest creates the DeployWorkflowArtifacts request.
func (client *WebAppsClient) deployWorkflowArtifactsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientDeployWorkflowArtifactsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployWorkflowArtifacts"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.WorkflowArtifacts != nil {
		if err := runtime.MarshalAsJSON(req, *options.WorkflowArtifacts); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// DeployWorkflowArtifactsSlot - Description for Creates the artifacts for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientDeployWorkflowArtifactsSlotOptions contains the optional parameters for the WebAppsClient.DeployWorkflowArtifactsSlot
//     method.
func (client *WebAppsClient) DeployWorkflowArtifactsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientDeployWorkflowArtifactsSlotOptions) (WebAppsClientDeployWorkflowArtifactsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DeployWorkflowArtifactsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deployWorkflowArtifactsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientDeployWorkflowArtifactsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDeployWorkflowArtifactsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDeployWorkflowArtifactsSlotResponse{}, err
	}
	return WebAppsClientDeployWorkflowArtifactsSlotResponse{}, nil
}

// deployWorkflowArtifactsSlotCreateRequest creates the DeployWorkflowArtifactsSlot request.
func (client *WebAppsClient) deployWorkflowArtifactsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientDeployWorkflowArtifactsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployWorkflowArtifacts"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.WorkflowArtifacts != nil {
		if err := runtime.MarshalAsJSON(req, *options.WorkflowArtifacts); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// DiscoverBackup - Description for Discovers an existing app backup that can be restored from a blob in Azure storage. Use
// this to get information about the databases stored in a backup.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - request - A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
//   - options - WebAppsClientDiscoverBackupOptions contains the optional parameters for the WebAppsClient.DiscoverBackup method.
func (client *WebAppsClient) DiscoverBackup(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsClientDiscoverBackupOptions) (WebAppsClientDiscoverBackupResponse, error) {
	var err error
	const operationName = "WebAppsClient.DiscoverBackup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.discoverBackupCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return WebAppsClientDiscoverBackupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDiscoverBackupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDiscoverBackupResponse{}, err
	}
	resp, err := client.discoverBackupHandleResponse(httpResp)
	return resp, err
}

// discoverBackupCreateRequest creates the DiscoverBackup request.
func (client *WebAppsClient) discoverBackupCreateRequest(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsClientDiscoverBackupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/discoverbackup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// discoverBackupHandleResponse handles the DiscoverBackup response.
func (client *WebAppsClient) discoverBackupHandleResponse(resp *http.Response) (WebAppsClientDiscoverBackupResponse, error) {
	result := WebAppsClientDiscoverBackupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RestoreRequest); err != nil {
		return WebAppsClientDiscoverBackupResponse{}, err
	}
	return result, nil
}

// DiscoverBackupSlot - Description for Discovers an existing app backup that can be restored from a blob in Azure storage.
// Use this to get information about the databases stored in a backup.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will perform discovery for the production slot.
//   - request - A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
//   - options - WebAppsClientDiscoverBackupSlotOptions contains the optional parameters for the WebAppsClient.DiscoverBackupSlot
//     method.
func (client *WebAppsClient) DiscoverBackupSlot(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsClientDiscoverBackupSlotOptions) (WebAppsClientDiscoverBackupSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.DiscoverBackupSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.discoverBackupSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return WebAppsClientDiscoverBackupSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientDiscoverBackupSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientDiscoverBackupSlotResponse{}, err
	}
	resp, err := client.discoverBackupSlotHandleResponse(httpResp)
	return resp, err
}

// discoverBackupSlotCreateRequest creates the DiscoverBackupSlot request.
func (client *WebAppsClient) discoverBackupSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsClientDiscoverBackupSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/discoverbackup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// discoverBackupSlotHandleResponse handles the DiscoverBackupSlot response.
func (client *WebAppsClient) discoverBackupSlotHandleResponse(resp *http.Response) (WebAppsClientDiscoverBackupSlotResponse, error) {
	result := WebAppsClientDiscoverBackupSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RestoreRequest); err != nil {
		return WebAppsClientDiscoverBackupSlotResponse{}, err
	}
	return result, nil
}

// GenerateNewSitePublishingPassword - Description for Generates a new publishing password for an app (or deployment slot,
// if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGenerateNewSitePublishingPasswordOptions contains the optional parameters for the WebAppsClient.GenerateNewSitePublishingPassword
//     method.
func (client *WebAppsClient) GenerateNewSitePublishingPassword(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGenerateNewSitePublishingPasswordOptions) (WebAppsClientGenerateNewSitePublishingPasswordResponse, error) {
	var err error
	const operationName = "WebAppsClient.GenerateNewSitePublishingPassword"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.generateNewSitePublishingPasswordCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGenerateNewSitePublishingPasswordResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGenerateNewSitePublishingPasswordResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGenerateNewSitePublishingPasswordResponse{}, err
	}
	return WebAppsClientGenerateNewSitePublishingPasswordResponse{}, nil
}

// generateNewSitePublishingPasswordCreateRequest creates the GenerateNewSitePublishingPassword request.
func (client *WebAppsClient) generateNewSitePublishingPasswordCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGenerateNewSitePublishingPasswordOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GenerateNewSitePublishingPasswordSlot - Description for Generates a new publishing password for an app (or deployment slot,
// if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API generate a new publishing password for the production
//     slot.
//   - options - WebAppsClientGenerateNewSitePublishingPasswordSlotOptions contains the optional parameters for the WebAppsClient.GenerateNewSitePublishingPasswordSlot
//     method.
func (client *WebAppsClient) GenerateNewSitePublishingPasswordSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGenerateNewSitePublishingPasswordSlotOptions) (WebAppsClientGenerateNewSitePublishingPasswordSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GenerateNewSitePublishingPasswordSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.generateNewSitePublishingPasswordSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGenerateNewSitePublishingPasswordSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGenerateNewSitePublishingPasswordSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGenerateNewSitePublishingPasswordSlotResponse{}, err
	}
	return WebAppsClientGenerateNewSitePublishingPasswordSlotResponse{}, nil
}

// generateNewSitePublishingPasswordSlotCreateRequest creates the GenerateNewSitePublishingPasswordSlot request.
func (client *WebAppsClient) generateNewSitePublishingPasswordSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGenerateNewSitePublishingPasswordSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// Get - Description for Gets the details of a web, mobile, or API app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetOptions contains the optional parameters for the WebAppsClient.Get method.
func (client *WebAppsClient) Get(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetOptions) (WebAppsClientGetResponse, error) {
	var err error
	const operationName = "WebAppsClient.Get"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetResponse{}, err
	}
	resp, err := client.getHandleResponse(httpResp)
	return resp, err
}

// getCreateRequest creates the Get request.
func (client *WebAppsClient) getCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *WebAppsClient) getHandleResponse(resp *http.Response) (WebAppsClientGetResponse, error) {
	result := WebAppsClientGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Site); err != nil {
		return WebAppsClientGetResponse{}, err
	}
	return result, nil
}

// GetAppSettingKeyVaultReference - Description for Gets the config reference and status of an app
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - appSettingKey - App Setting key name.
//   - options - WebAppsClientGetAppSettingKeyVaultReferenceOptions contains the optional parameters for the WebAppsClient.GetAppSettingKeyVaultReference
//     method.
func (client *WebAppsClient) GetAppSettingKeyVaultReference(ctx context.Context, resourceGroupName string, name string, appSettingKey string, options *WebAppsClientGetAppSettingKeyVaultReferenceOptions) (WebAppsClientGetAppSettingKeyVaultReferenceResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetAppSettingKeyVaultReference"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAppSettingKeyVaultReferenceCreateRequest(ctx, resourceGroupName, name, appSettingKey, options)
	if err != nil {
		return WebAppsClientGetAppSettingKeyVaultReferenceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetAppSettingKeyVaultReferenceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetAppSettingKeyVaultReferenceResponse{}, err
	}
	resp, err := client.getAppSettingKeyVaultReferenceHandleResponse(httpResp)
	return resp, err
}

// getAppSettingKeyVaultReferenceCreateRequest creates the GetAppSettingKeyVaultReference request.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceCreateRequest(ctx context.Context, resourceGroupName string, name string, appSettingKey string, options *WebAppsClientGetAppSettingKeyVaultReferenceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/appsettings/{appSettingKey}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if appSettingKey == "" {
		return nil, errors.New("parameter appSettingKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{appSettingKey}", url.PathEscape(appSettingKey))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAppSettingKeyVaultReferenceHandleResponse handles the GetAppSettingKeyVaultReference response.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceHandleResponse(resp *http.Response) (WebAppsClientGetAppSettingKeyVaultReferenceResponse, error) {
	result := WebAppsClientGetAppSettingKeyVaultReferenceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReference); err != nil {
		return WebAppsClientGetAppSettingKeyVaultReferenceResponse{}, err
	}
	return result, nil
}

// GetAppSettingKeyVaultReferenceSlot - Description for Gets the config reference and status of an app
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - appSettingKey - App Setting key name.
//   - options - WebAppsClientGetAppSettingKeyVaultReferenceSlotOptions contains the optional parameters for the WebAppsClient.GetAppSettingKeyVaultReferenceSlot
//     method.
func (client *WebAppsClient) GetAppSettingKeyVaultReferenceSlot(ctx context.Context, resourceGroupName string, name string, appSettingKey string, slot string, options *WebAppsClientGetAppSettingKeyVaultReferenceSlotOptions) (WebAppsClientGetAppSettingKeyVaultReferenceSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetAppSettingKeyVaultReferenceSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAppSettingKeyVaultReferenceSlotCreateRequest(ctx, resourceGroupName, name, appSettingKey, slot, options)
	if err != nil {
		return WebAppsClientGetAppSettingKeyVaultReferenceSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetAppSettingKeyVaultReferenceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetAppSettingKeyVaultReferenceSlotResponse{}, err
	}
	resp, err := client.getAppSettingKeyVaultReferenceSlotHandleResponse(httpResp)
	return resp, err
}

// getAppSettingKeyVaultReferenceSlotCreateRequest creates the GetAppSettingKeyVaultReferenceSlot request.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, appSettingKey string, slot string, options *WebAppsClientGetAppSettingKeyVaultReferenceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/appsettings/{appSettingKey}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if appSettingKey == "" {
		return nil, errors.New("parameter appSettingKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{appSettingKey}", url.PathEscape(appSettingKey))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAppSettingKeyVaultReferenceSlotHandleResponse handles the GetAppSettingKeyVaultReferenceSlot response.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceSlotHandleResponse(resp *http.Response) (WebAppsClientGetAppSettingKeyVaultReferenceSlotResponse, error) {
	result := WebAppsClientGetAppSettingKeyVaultReferenceSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReference); err != nil {
		return WebAppsClientGetAppSettingKeyVaultReferenceSlotResponse{}, err
	}
	return result, nil
}

// NewGetAppSettingsKeyVaultReferencesPager - Description for Gets the config reference app settings and status of an app
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetAppSettingsKeyVaultReferencesOptions contains the optional parameters for the WebAppsClient.NewGetAppSettingsKeyVaultReferencesPager
//     method.
func (client *WebAppsClient) NewGetAppSettingsKeyVaultReferencesPager(resourceGroupName string, name string, options *WebAppsClientGetAppSettingsKeyVaultReferencesOptions) *runtime.Pager[WebAppsClientGetAppSettingsKeyVaultReferencesResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientGetAppSettingsKeyVaultReferencesResponse]{
		More: func(page WebAppsClientGetAppSettingsKeyVaultReferencesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientGetAppSettingsKeyVaultReferencesResponse) (WebAppsClientGetAppSettingsKeyVaultReferencesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewGetAppSettingsKeyVaultReferencesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getAppSettingsKeyVaultReferencesCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientGetAppSettingsKeyVaultReferencesResponse{}, err
			}
			return client.getAppSettingsKeyVaultReferencesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getAppSettingsKeyVaultReferencesCreateRequest creates the GetAppSettingsKeyVaultReferences request.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetAppSettingsKeyVaultReferencesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAppSettingsKeyVaultReferencesHandleResponse handles the GetAppSettingsKeyVaultReferences response.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesHandleResponse(resp *http.Response) (WebAppsClientGetAppSettingsKeyVaultReferencesResponse, error) {
	result := WebAppsClientGetAppSettingsKeyVaultReferencesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReferenceCollection); err != nil {
		return WebAppsClientGetAppSettingsKeyVaultReferencesResponse{}, err
	}
	return result, nil
}

// NewGetAppSettingsKeyVaultReferencesSlotPager - Description for Gets the config reference app settings and status of an
// app
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetAppSettingsKeyVaultReferencesSlotOptions contains the optional parameters for the WebAppsClient.NewGetAppSettingsKeyVaultReferencesSlotPager
//     method.
func (client *WebAppsClient) NewGetAppSettingsKeyVaultReferencesSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientGetAppSettingsKeyVaultReferencesSlotOptions) *runtime.Pager[WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse]{
		More: func(page WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse) (WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewGetAppSettingsKeyVaultReferencesSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getAppSettingsKeyVaultReferencesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse{}, err
			}
			return client.getAppSettingsKeyVaultReferencesSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getAppSettingsKeyVaultReferencesSlotCreateRequest creates the GetAppSettingsKeyVaultReferencesSlot request.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetAppSettingsKeyVaultReferencesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAppSettingsKeyVaultReferencesSlotHandleResponse handles the GetAppSettingsKeyVaultReferencesSlot response.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesSlotHandleResponse(resp *http.Response) (WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse, error) {
	result := WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReferenceCollection); err != nil {
		return WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse{}, err
	}
	return result, nil
}

// GetAuthSettings - Description for Gets the Authentication/Authorization settings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetAuthSettingsOptions contains the optional parameters for the WebAppsClient.GetAuthSettings method.
func (client *WebAppsClient) GetAuthSettings(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetAuthSettingsOptions) (WebAppsClientGetAuthSettingsResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetAuthSettings"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAuthSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetAuthSettingsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetAuthSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetAuthSettingsResponse{}, err
	}
	resp, err := client.getAuthSettingsHandleResponse(httpResp)
	return resp, err
}

// getAuthSettingsCreateRequest creates the GetAuthSettings request.
func (client *WebAppsClient) getAuthSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetAuthSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAuthSettingsHandleResponse handles the GetAuthSettings response.
func (client *WebAppsClient) getAuthSettingsHandleResponse(resp *http.Response) (WebAppsClientGetAuthSettingsResponse, error) {
	result := WebAppsClientGetAuthSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettings); err != nil {
		return WebAppsClientGetAuthSettingsResponse{}, err
	}
	return result, nil
}

// GetAuthSettingsSlot - Description for Gets the Authentication/Authorization settings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the settings for the production slot.
//   - options - WebAppsClientGetAuthSettingsSlotOptions contains the optional parameters for the WebAppsClient.GetAuthSettingsSlot
//     method.
func (client *WebAppsClient) GetAuthSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetAuthSettingsSlotOptions) (WebAppsClientGetAuthSettingsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetAuthSettingsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAuthSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetAuthSettingsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetAuthSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetAuthSettingsSlotResponse{}, err
	}
	resp, err := client.getAuthSettingsSlotHandleResponse(httpResp)
	return resp, err
}

// getAuthSettingsSlotCreateRequest creates the GetAuthSettingsSlot request.
func (client *WebAppsClient) getAuthSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetAuthSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAuthSettingsSlotHandleResponse handles the GetAuthSettingsSlot response.
func (client *WebAppsClient) getAuthSettingsSlotHandleResponse(resp *http.Response) (WebAppsClientGetAuthSettingsSlotResponse, error) {
	result := WebAppsClientGetAuthSettingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettings); err != nil {
		return WebAppsClientGetAuthSettingsSlotResponse{}, err
	}
	return result, nil
}

// GetAuthSettingsV2 - Description for Gets site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetAuthSettingsV2Options contains the optional parameters for the WebAppsClient.GetAuthSettingsV2
//     method.
func (client *WebAppsClient) GetAuthSettingsV2(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetAuthSettingsV2Options) (WebAppsClientGetAuthSettingsV2Response, error) {
	var err error
	const operationName = "WebAppsClient.GetAuthSettingsV2"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAuthSettingsV2CreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetAuthSettingsV2Response{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetAuthSettingsV2Response{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetAuthSettingsV2Response{}, err
	}
	resp, err := client.getAuthSettingsV2HandleResponse(httpResp)
	return resp, err
}

// getAuthSettingsV2CreateRequest creates the GetAuthSettingsV2 request.
func (client *WebAppsClient) getAuthSettingsV2CreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetAuthSettingsV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAuthSettingsV2HandleResponse handles the GetAuthSettingsV2 response.
func (client *WebAppsClient) getAuthSettingsV2HandleResponse(resp *http.Response) (WebAppsClientGetAuthSettingsV2Response, error) {
	result := WebAppsClientGetAuthSettingsV2Response{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettingsV2); err != nil {
		return WebAppsClientGetAuthSettingsV2Response{}, err
	}
	return result, nil
}

// GetAuthSettingsV2Slot - Description for Gets site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the settings for the production slot.
//   - options - WebAppsClientGetAuthSettingsV2SlotOptions contains the optional parameters for the WebAppsClient.GetAuthSettingsV2Slot
//     method.
func (client *WebAppsClient) GetAuthSettingsV2Slot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetAuthSettingsV2SlotOptions) (WebAppsClientGetAuthSettingsV2SlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetAuthSettingsV2Slot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAuthSettingsV2SlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetAuthSettingsV2SlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetAuthSettingsV2SlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetAuthSettingsV2SlotResponse{}, err
	}
	resp, err := client.getAuthSettingsV2SlotHandleResponse(httpResp)
	return resp, err
}

// getAuthSettingsV2SlotCreateRequest creates the GetAuthSettingsV2Slot request.
func (client *WebAppsClient) getAuthSettingsV2SlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetAuthSettingsV2SlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAuthSettingsV2SlotHandleResponse handles the GetAuthSettingsV2Slot response.
func (client *WebAppsClient) getAuthSettingsV2SlotHandleResponse(resp *http.Response) (WebAppsClientGetAuthSettingsV2SlotResponse, error) {
	result := WebAppsClientGetAuthSettingsV2SlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettingsV2); err != nil {
		return WebAppsClientGetAuthSettingsV2SlotResponse{}, err
	}
	return result, nil
}

// GetAuthSettingsV2WithoutSecrets - Description for Gets site's Authentication / Authorization settings for apps via the
// V2 format
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetAuthSettingsV2WithoutSecretsOptions contains the optional parameters for the WebAppsClient.GetAuthSettingsV2WithoutSecrets
//     method.
func (client *WebAppsClient) GetAuthSettingsV2WithoutSecrets(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetAuthSettingsV2WithoutSecretsOptions) (WebAppsClientGetAuthSettingsV2WithoutSecretsResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetAuthSettingsV2WithoutSecrets"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAuthSettingsV2WithoutSecretsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetAuthSettingsV2WithoutSecretsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetAuthSettingsV2WithoutSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetAuthSettingsV2WithoutSecretsResponse{}, err
	}
	resp, err := client.getAuthSettingsV2WithoutSecretsHandleResponse(httpResp)
	return resp, err
}

// getAuthSettingsV2WithoutSecretsCreateRequest creates the GetAuthSettingsV2WithoutSecrets request.
func (client *WebAppsClient) getAuthSettingsV2WithoutSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetAuthSettingsV2WithoutSecretsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAuthSettingsV2WithoutSecretsHandleResponse handles the GetAuthSettingsV2WithoutSecrets response.
func (client *WebAppsClient) getAuthSettingsV2WithoutSecretsHandleResponse(resp *http.Response) (WebAppsClientGetAuthSettingsV2WithoutSecretsResponse, error) {
	result := WebAppsClientGetAuthSettingsV2WithoutSecretsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettingsV2); err != nil {
		return WebAppsClientGetAuthSettingsV2WithoutSecretsResponse{}, err
	}
	return result, nil
}

// GetAuthSettingsV2WithoutSecretsSlot - Gets site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the settings for the production slot.
//   - options - WebAppsClientGetAuthSettingsV2WithoutSecretsSlotOptions contains the optional parameters for the WebAppsClient.GetAuthSettingsV2WithoutSecretsSlot
//     method.
func (client *WebAppsClient) GetAuthSettingsV2WithoutSecretsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetAuthSettingsV2WithoutSecretsSlotOptions) (WebAppsClientGetAuthSettingsV2WithoutSecretsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetAuthSettingsV2WithoutSecretsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAuthSettingsV2WithoutSecretsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetAuthSettingsV2WithoutSecretsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetAuthSettingsV2WithoutSecretsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetAuthSettingsV2WithoutSecretsSlotResponse{}, err
	}
	resp, err := client.getAuthSettingsV2WithoutSecretsSlotHandleResponse(httpResp)
	return resp, err
}

// getAuthSettingsV2WithoutSecretsSlotCreateRequest creates the GetAuthSettingsV2WithoutSecretsSlot request.
func (client *WebAppsClient) getAuthSettingsV2WithoutSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetAuthSettingsV2WithoutSecretsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAuthSettingsV2WithoutSecretsSlotHandleResponse handles the GetAuthSettingsV2WithoutSecretsSlot response.
func (client *WebAppsClient) getAuthSettingsV2WithoutSecretsSlotHandleResponse(resp *http.Response) (WebAppsClientGetAuthSettingsV2WithoutSecretsSlotResponse, error) {
	result := WebAppsClientGetAuthSettingsV2WithoutSecretsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettingsV2); err != nil {
		return WebAppsClientGetAuthSettingsV2WithoutSecretsSlotResponse{}, err
	}
	return result, nil
}

// GetBackupConfiguration - Description for Gets the backup configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetBackupConfigurationOptions contains the optional parameters for the WebAppsClient.GetBackupConfiguration
//     method.
func (client *WebAppsClient) GetBackupConfiguration(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetBackupConfigurationOptions) (WebAppsClientGetBackupConfigurationResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetBackupConfiguration"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getBackupConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetBackupConfigurationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetBackupConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetBackupConfigurationResponse{}, err
	}
	resp, err := client.getBackupConfigurationHandleResponse(httpResp)
	return resp, err
}

// getBackupConfigurationCreateRequest creates the GetBackupConfiguration request.
func (client *WebAppsClient) getBackupConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetBackupConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getBackupConfigurationHandleResponse handles the GetBackupConfiguration response.
func (client *WebAppsClient) getBackupConfigurationHandleResponse(resp *http.Response) (WebAppsClientGetBackupConfigurationResponse, error) {
	result := WebAppsClientGetBackupConfigurationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupRequest); err != nil {
		return WebAppsClientGetBackupConfigurationResponse{}, err
	}
	return result, nil
}

// GetBackupConfigurationSlot - Description for Gets the backup configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the backup configuration for the production
//     slot.
//   - options - WebAppsClientGetBackupConfigurationSlotOptions contains the optional parameters for the WebAppsClient.GetBackupConfigurationSlot
//     method.
func (client *WebAppsClient) GetBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetBackupConfigurationSlotOptions) (WebAppsClientGetBackupConfigurationSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetBackupConfigurationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getBackupConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetBackupConfigurationSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetBackupConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetBackupConfigurationSlotResponse{}, err
	}
	resp, err := client.getBackupConfigurationSlotHandleResponse(httpResp)
	return resp, err
}

// getBackupConfigurationSlotCreateRequest creates the GetBackupConfigurationSlot request.
func (client *WebAppsClient) getBackupConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetBackupConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getBackupConfigurationSlotHandleResponse handles the GetBackupConfigurationSlot response.
func (client *WebAppsClient) getBackupConfigurationSlotHandleResponse(resp *http.Response) (WebAppsClientGetBackupConfigurationSlotResponse, error) {
	result := WebAppsClientGetBackupConfigurationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupRequest); err != nil {
		return WebAppsClientGetBackupConfigurationSlotResponse{}, err
	}
	return result, nil
}

// GetBackupStatus - Description for Gets a backup of an app by its ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - backupID - ID of the backup.
//   - options - WebAppsClientGetBackupStatusOptions contains the optional parameters for the WebAppsClient.GetBackupStatus method.
func (client *WebAppsClient) GetBackupStatus(ctx context.Context, resourceGroupName string, name string, backupID string, options *WebAppsClientGetBackupStatusOptions) (WebAppsClientGetBackupStatusResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetBackupStatus"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getBackupStatusCreateRequest(ctx, resourceGroupName, name, backupID, options)
	if err != nil {
		return WebAppsClientGetBackupStatusResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetBackupStatusResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetBackupStatusResponse{}, err
	}
	resp, err := client.getBackupStatusHandleResponse(httpResp)
	return resp, err
}

// getBackupStatusCreateRequest creates the GetBackupStatus request.
func (client *WebAppsClient) getBackupStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, options *WebAppsClientGetBackupStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getBackupStatusHandleResponse handles the GetBackupStatus response.
func (client *WebAppsClient) getBackupStatusHandleResponse(resp *http.Response) (WebAppsClientGetBackupStatusResponse, error) {
	result := WebAppsClientGetBackupStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return WebAppsClientGetBackupStatusResponse{}, err
	}
	return result, nil
}

// GetBackupStatusSlot - Description for Gets a backup of an app by its ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - backupID - ID of the backup.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get a backup of the production slot.
//   - options - WebAppsClientGetBackupStatusSlotOptions contains the optional parameters for the WebAppsClient.GetBackupStatusSlot
//     method.
func (client *WebAppsClient) GetBackupStatusSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *WebAppsClientGetBackupStatusSlotOptions) (WebAppsClientGetBackupStatusSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetBackupStatusSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getBackupStatusSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, options)
	if err != nil {
		return WebAppsClientGetBackupStatusSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetBackupStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetBackupStatusSlotResponse{}, err
	}
	resp, err := client.getBackupStatusSlotHandleResponse(httpResp)
	return resp, err
}

// getBackupStatusSlotCreateRequest creates the GetBackupStatusSlot request.
func (client *WebAppsClient) getBackupStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *WebAppsClientGetBackupStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getBackupStatusSlotHandleResponse handles the GetBackupStatusSlot response.
func (client *WebAppsClient) getBackupStatusSlotHandleResponse(resp *http.Response) (WebAppsClientGetBackupStatusSlotResponse, error) {
	result := WebAppsClientGetBackupStatusSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return WebAppsClientGetBackupStatusSlotResponse{}, err
	}
	return result, nil
}

// GetConfiguration - Description for Gets the configuration of an app, such as platform version and bitness, default documents,
// virtual applications, Always On, etc.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetConfigurationOptions contains the optional parameters for the WebAppsClient.GetConfiguration
//     method.
func (client *WebAppsClient) GetConfiguration(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetConfigurationOptions) (WebAppsClientGetConfigurationResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetConfiguration"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetConfigurationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetConfigurationResponse{}, err
	}
	resp, err := client.getConfigurationHandleResponse(httpResp)
	return resp, err
}

// getConfigurationCreateRequest creates the GetConfiguration request.
func (client *WebAppsClient) getConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getConfigurationHandleResponse handles the GetConfiguration response.
func (client *WebAppsClient) getConfigurationHandleResponse(resp *http.Response) (WebAppsClientGetConfigurationResponse, error) {
	result := WebAppsClientGetConfigurationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsClientGetConfigurationResponse{}, err
	}
	return result, nil
}

// GetConfigurationSlot - Description for Gets the configuration of an app, such as platform version and bitness, default
// documents, virtual applications, Always On, etc.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
//   - options - WebAppsClientGetConfigurationSlotOptions contains the optional parameters for the WebAppsClient.GetConfigurationSlot
//     method.
func (client *WebAppsClient) GetConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetConfigurationSlotOptions) (WebAppsClientGetConfigurationSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetConfigurationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetConfigurationSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetConfigurationSlotResponse{}, err
	}
	resp, err := client.getConfigurationSlotHandleResponse(httpResp)
	return resp, err
}

// getConfigurationSlotCreateRequest creates the GetConfigurationSlot request.
func (client *WebAppsClient) getConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getConfigurationSlotHandleResponse handles the GetConfigurationSlot response.
func (client *WebAppsClient) getConfigurationSlotHandleResponse(resp *http.Response) (WebAppsClientGetConfigurationSlotResponse, error) {
	result := WebAppsClientGetConfigurationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsClientGetConfigurationSlotResponse{}, err
	}
	return result, nil
}

// GetConfigurationSnapshot - Description for Gets a snapshot of the configuration of an app at a previous point in time.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - snapshotID - The ID of the snapshot to read.
//   - options - WebAppsClientGetConfigurationSnapshotOptions contains the optional parameters for the WebAppsClient.GetConfigurationSnapshot
//     method.
func (client *WebAppsClient) GetConfigurationSnapshot(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *WebAppsClientGetConfigurationSnapshotOptions) (WebAppsClientGetConfigurationSnapshotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetConfigurationSnapshot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getConfigurationSnapshotCreateRequest(ctx, resourceGroupName, name, snapshotID, options)
	if err != nil {
		return WebAppsClientGetConfigurationSnapshotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetConfigurationSnapshotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetConfigurationSnapshotResponse{}, err
	}
	resp, err := client.getConfigurationSnapshotHandleResponse(httpResp)
	return resp, err
}

// getConfigurationSnapshotCreateRequest creates the GetConfigurationSnapshot request.
func (client *WebAppsClient) getConfigurationSnapshotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *WebAppsClientGetConfigurationSnapshotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getConfigurationSnapshotHandleResponse handles the GetConfigurationSnapshot response.
func (client *WebAppsClient) getConfigurationSnapshotHandleResponse(resp *http.Response) (WebAppsClientGetConfigurationSnapshotResponse, error) {
	result := WebAppsClientGetConfigurationSnapshotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsClientGetConfigurationSnapshotResponse{}, err
	}
	return result, nil
}

// GetConfigurationSnapshotSlot - Description for Gets a snapshot of the configuration of an app at a previous point in time.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - snapshotID - The ID of the snapshot to read.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
//   - options - WebAppsClientGetConfigurationSnapshotSlotOptions contains the optional parameters for the WebAppsClient.GetConfigurationSnapshotSlot
//     method.
func (client *WebAppsClient) GetConfigurationSnapshotSlot(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *WebAppsClientGetConfigurationSnapshotSlotOptions) (WebAppsClientGetConfigurationSnapshotSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetConfigurationSnapshotSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getConfigurationSnapshotSlotCreateRequest(ctx, resourceGroupName, name, snapshotID, slot, options)
	if err != nil {
		return WebAppsClientGetConfigurationSnapshotSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetConfigurationSnapshotSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetConfigurationSnapshotSlotResponse{}, err
	}
	resp, err := client.getConfigurationSnapshotSlotHandleResponse(httpResp)
	return resp, err
}

// getConfigurationSnapshotSlotCreateRequest creates the GetConfigurationSnapshotSlot request.
func (client *WebAppsClient) getConfigurationSnapshotSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *WebAppsClientGetConfigurationSnapshotSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getConfigurationSnapshotSlotHandleResponse handles the GetConfigurationSnapshotSlot response.
func (client *WebAppsClient) getConfigurationSnapshotSlotHandleResponse(resp *http.Response) (WebAppsClientGetConfigurationSnapshotSlotResponse, error) {
	result := WebAppsClientGetConfigurationSnapshotSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsClientGetConfigurationSnapshotSlotResponse{}, err
	}
	return result, nil
}

// GetContainerLogsZip - Description for Gets the ZIP archived docker log files for the given site
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientGetContainerLogsZipOptions contains the optional parameters for the WebAppsClient.GetContainerLogsZip
//     method.
func (client *WebAppsClient) GetContainerLogsZip(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetContainerLogsZipOptions) (WebAppsClientGetContainerLogsZipResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetContainerLogsZip"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getContainerLogsZipCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetContainerLogsZipResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetContainerLogsZipResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetContainerLogsZipResponse{}, err
	}
	return WebAppsClientGetContainerLogsZipResponse{Body: httpResp.Body}, nil
}

// getContainerLogsZipCreateRequest creates the GetContainerLogsZip request.
func (client *WebAppsClient) getContainerLogsZipCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetContainerLogsZipOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs/zip/download"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/zip"}
	return req, nil
}

// GetContainerLogsZipSlot - Description for Gets the ZIP archived docker log files for the given site
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - options - WebAppsClientGetContainerLogsZipSlotOptions contains the optional parameters for the WebAppsClient.GetContainerLogsZipSlot
//     method.
func (client *WebAppsClient) GetContainerLogsZipSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetContainerLogsZipSlotOptions) (WebAppsClientGetContainerLogsZipSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetContainerLogsZipSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getContainerLogsZipSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetContainerLogsZipSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetContainerLogsZipSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetContainerLogsZipSlotResponse{}, err
	}
	return WebAppsClientGetContainerLogsZipSlotResponse{Body: httpResp.Body}, nil
}

// getContainerLogsZipSlotCreateRequest creates the GetContainerLogsZipSlot request.
func (client *WebAppsClient) getContainerLogsZipSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetContainerLogsZipSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs/zip/download"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/zip"}
	return req, nil
}

// GetContinuousWebJob - Description for Gets a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - options - WebAppsClientGetContinuousWebJobOptions contains the optional parameters for the WebAppsClient.GetContinuousWebJob
//     method.
func (client *WebAppsClient) GetContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientGetContinuousWebJobOptions) (WebAppsClientGetContinuousWebJobResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetContinuousWebJob"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsClientGetContinuousWebJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetContinuousWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetContinuousWebJobResponse{}, err
	}
	resp, err := client.getContinuousWebJobHandleResponse(httpResp)
	return resp, err
}

// getContinuousWebJobCreateRequest creates the GetContinuousWebJob request.
func (client *WebAppsClient) getContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientGetContinuousWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getContinuousWebJobHandleResponse handles the GetContinuousWebJob response.
func (client *WebAppsClient) getContinuousWebJobHandleResponse(resp *http.Response) (WebAppsClientGetContinuousWebJobResponse, error) {
	result := WebAppsClientGetContinuousWebJobResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContinuousWebJob); err != nil {
		return WebAppsClientGetContinuousWebJobResponse{}, err
	}
	return result, nil
}

// GetContinuousWebJobSlot - Description for Gets a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
//   - options - WebAppsClientGetContinuousWebJobSlotOptions contains the optional parameters for the WebAppsClient.GetContinuousWebJobSlot
//     method.
func (client *WebAppsClient) GetContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientGetContinuousWebJobSlotOptions) (WebAppsClientGetContinuousWebJobSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetContinuousWebJobSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsClientGetContinuousWebJobSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetContinuousWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetContinuousWebJobSlotResponse{}, err
	}
	resp, err := client.getContinuousWebJobSlotHandleResponse(httpResp)
	return resp, err
}

// getContinuousWebJobSlotCreateRequest creates the GetContinuousWebJobSlot request.
func (client *WebAppsClient) getContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientGetContinuousWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getContinuousWebJobSlotHandleResponse handles the GetContinuousWebJobSlot response.
func (client *WebAppsClient) getContinuousWebJobSlotHandleResponse(resp *http.Response) (WebAppsClientGetContinuousWebJobSlotResponse, error) {
	result := WebAppsClientGetContinuousWebJobSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContinuousWebJob); err != nil {
		return WebAppsClientGetContinuousWebJobSlotResponse{}, err
	}
	return result, nil
}

// GetDeployment - Description for Get a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - id - Deployment ID.
//   - options - WebAppsClientGetDeploymentOptions contains the optional parameters for the WebAppsClient.GetDeployment method.
func (client *WebAppsClient) GetDeployment(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsClientGetDeploymentOptions) (WebAppsClientGetDeploymentResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetDeployment"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDeploymentCreateRequest(ctx, resourceGroupName, name, id, options)
	if err != nil {
		return WebAppsClientGetDeploymentResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetDeploymentResponse{}, err
	}
	resp, err := client.getDeploymentHandleResponse(httpResp)
	return resp, err
}

// getDeploymentCreateRequest creates the GetDeployment request.
func (client *WebAppsClient) getDeploymentCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsClientGetDeploymentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeploymentHandleResponse handles the GetDeployment response.
func (client *WebAppsClient) getDeploymentHandleResponse(resp *http.Response) (WebAppsClientGetDeploymentResponse, error) {
	result := WebAppsClientGetDeploymentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return WebAppsClientGetDeploymentResponse{}, err
	}
	return result, nil
}

// GetDeploymentSlot - Description for Get a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - id - Deployment ID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
//   - options - WebAppsClientGetDeploymentSlotOptions contains the optional parameters for the WebAppsClient.GetDeploymentSlot
//     method.
func (client *WebAppsClient) GetDeploymentSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsClientGetDeploymentSlotOptions) (WebAppsClientGetDeploymentSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetDeploymentSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDeploymentSlotCreateRequest(ctx, resourceGroupName, name, id, slot, options)
	if err != nil {
		return WebAppsClientGetDeploymentSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetDeploymentSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetDeploymentSlotResponse{}, err
	}
	resp, err := client.getDeploymentSlotHandleResponse(httpResp)
	return resp, err
}

// getDeploymentSlotCreateRequest creates the GetDeploymentSlot request.
func (client *WebAppsClient) getDeploymentSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsClientGetDeploymentSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeploymentSlotHandleResponse handles the GetDeploymentSlot response.
func (client *WebAppsClient) getDeploymentSlotHandleResponse(resp *http.Response) (WebAppsClientGetDeploymentSlotResponse, error) {
	result := WebAppsClientGetDeploymentSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return WebAppsClientGetDeploymentSlotResponse{}, err
	}
	return result, nil
}

// GetDiagnosticLogsConfiguration - Description for Gets the logging configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetDiagnosticLogsConfigurationOptions contains the optional parameters for the WebAppsClient.GetDiagnosticLogsConfiguration
//     method.
func (client *WebAppsClient) GetDiagnosticLogsConfiguration(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetDiagnosticLogsConfigurationOptions) (WebAppsClientGetDiagnosticLogsConfigurationResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetDiagnosticLogsConfiguration"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDiagnosticLogsConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetDiagnosticLogsConfigurationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetDiagnosticLogsConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetDiagnosticLogsConfigurationResponse{}, err
	}
	resp, err := client.getDiagnosticLogsConfigurationHandleResponse(httpResp)
	return resp, err
}

// getDiagnosticLogsConfigurationCreateRequest creates the GetDiagnosticLogsConfiguration request.
func (client *WebAppsClient) getDiagnosticLogsConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetDiagnosticLogsConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDiagnosticLogsConfigurationHandleResponse handles the GetDiagnosticLogsConfiguration response.
func (client *WebAppsClient) getDiagnosticLogsConfigurationHandleResponse(resp *http.Response) (WebAppsClientGetDiagnosticLogsConfigurationResponse, error) {
	result := WebAppsClientGetDiagnosticLogsConfigurationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteLogsConfig); err != nil {
		return WebAppsClientGetDiagnosticLogsConfigurationResponse{}, err
	}
	return result, nil
}

// GetDiagnosticLogsConfigurationSlot - Description for Gets the logging configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the logging configuration for the production
//     slot.
//   - options - WebAppsClientGetDiagnosticLogsConfigurationSlotOptions contains the optional parameters for the WebAppsClient.GetDiagnosticLogsConfigurationSlot
//     method.
func (client *WebAppsClient) GetDiagnosticLogsConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetDiagnosticLogsConfigurationSlotOptions) (WebAppsClientGetDiagnosticLogsConfigurationSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetDiagnosticLogsConfigurationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDiagnosticLogsConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetDiagnosticLogsConfigurationSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetDiagnosticLogsConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetDiagnosticLogsConfigurationSlotResponse{}, err
	}
	resp, err := client.getDiagnosticLogsConfigurationSlotHandleResponse(httpResp)
	return resp, err
}

// getDiagnosticLogsConfigurationSlotCreateRequest creates the GetDiagnosticLogsConfigurationSlot request.
func (client *WebAppsClient) getDiagnosticLogsConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetDiagnosticLogsConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDiagnosticLogsConfigurationSlotHandleResponse handles the GetDiagnosticLogsConfigurationSlot response.
func (client *WebAppsClient) getDiagnosticLogsConfigurationSlotHandleResponse(resp *http.Response) (WebAppsClientGetDiagnosticLogsConfigurationSlotResponse, error) {
	result := WebAppsClientGetDiagnosticLogsConfigurationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteLogsConfig); err != nil {
		return WebAppsClientGetDiagnosticLogsConfigurationSlotResponse{}, err
	}
	return result, nil
}

// GetDomainOwnershipIdentifier - Description for Get domain ownership identifier for web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - domainOwnershipIdentifierName - Name of domain ownership identifier.
//   - options - WebAppsClientGetDomainOwnershipIdentifierOptions contains the optional parameters for the WebAppsClient.GetDomainOwnershipIdentifier
//     method.
func (client *WebAppsClient) GetDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *WebAppsClientGetDomainOwnershipIdentifierOptions) (WebAppsClientGetDomainOwnershipIdentifierResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetDomainOwnershipIdentifier"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, options)
	if err != nil {
		return WebAppsClientGetDomainOwnershipIdentifierResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetDomainOwnershipIdentifierResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetDomainOwnershipIdentifierResponse{}, err
	}
	resp, err := client.getDomainOwnershipIdentifierHandleResponse(httpResp)
	return resp, err
}

// getDomainOwnershipIdentifierCreateRequest creates the GetDomainOwnershipIdentifier request.
func (client *WebAppsClient) getDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *WebAppsClientGetDomainOwnershipIdentifierOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDomainOwnershipIdentifierHandleResponse handles the GetDomainOwnershipIdentifier response.
func (client *WebAppsClient) getDomainOwnershipIdentifierHandleResponse(resp *http.Response) (WebAppsClientGetDomainOwnershipIdentifierResponse, error) {
	result := WebAppsClientGetDomainOwnershipIdentifierResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return WebAppsClientGetDomainOwnershipIdentifierResponse{}, err
	}
	return result, nil
}

// GetDomainOwnershipIdentifierSlot - Description for Get domain ownership identifier for web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - domainOwnershipIdentifierName - Name of domain ownership identifier.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
//   - options - WebAppsClientGetDomainOwnershipIdentifierSlotOptions contains the optional parameters for the WebAppsClient.GetDomainOwnershipIdentifierSlot
//     method.
func (client *WebAppsClient) GetDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *WebAppsClientGetDomainOwnershipIdentifierSlotOptions) (WebAppsClientGetDomainOwnershipIdentifierSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetDomainOwnershipIdentifierSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, options)
	if err != nil {
		return WebAppsClientGetDomainOwnershipIdentifierSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetDomainOwnershipIdentifierSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetDomainOwnershipIdentifierSlotResponse{}, err
	}
	resp, err := client.getDomainOwnershipIdentifierSlotHandleResponse(httpResp)
	return resp, err
}

// getDomainOwnershipIdentifierSlotCreateRequest creates the GetDomainOwnershipIdentifierSlot request.
func (client *WebAppsClient) getDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *WebAppsClientGetDomainOwnershipIdentifierSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDomainOwnershipIdentifierSlotHandleResponse handles the GetDomainOwnershipIdentifierSlot response.
func (client *WebAppsClient) getDomainOwnershipIdentifierSlotHandleResponse(resp *http.Response) (WebAppsClientGetDomainOwnershipIdentifierSlotResponse, error) {
	result := WebAppsClientGetDomainOwnershipIdentifierSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return WebAppsClientGetDomainOwnershipIdentifierSlotResponse{}, err
	}
	return result, nil
}

// GetFtpAllowed - Description for Returns whether FTP is allowed on the site or not.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetFtpAllowedOptions contains the optional parameters for the WebAppsClient.GetFtpAllowed method.
func (client *WebAppsClient) GetFtpAllowed(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetFtpAllowedOptions) (WebAppsClientGetFtpAllowedResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetFtpAllowed"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getFtpAllowedCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetFtpAllowedResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetFtpAllowedResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetFtpAllowedResponse{}, err
	}
	resp, err := client.getFtpAllowedHandleResponse(httpResp)
	return resp, err
}

// getFtpAllowedCreateRequest creates the GetFtpAllowed request.
func (client *WebAppsClient) getFtpAllowedCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetFtpAllowedOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/ftp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFtpAllowedHandleResponse handles the GetFtpAllowed response.
func (client *WebAppsClient) getFtpAllowedHandleResponse(resp *http.Response) (WebAppsClientGetFtpAllowedResponse, error) {
	result := WebAppsClientGetFtpAllowedResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsClientGetFtpAllowedResponse{}, err
	}
	return result, nil
}

// GetFtpAllowedSlot - Description for Returns whether FTP is allowed on the site or not.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetFtpAllowedSlotOptions contains the optional parameters for the WebAppsClient.GetFtpAllowedSlot
//     method.
func (client *WebAppsClient) GetFtpAllowedSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetFtpAllowedSlotOptions) (WebAppsClientGetFtpAllowedSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetFtpAllowedSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getFtpAllowedSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetFtpAllowedSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetFtpAllowedSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetFtpAllowedSlotResponse{}, err
	}
	resp, err := client.getFtpAllowedSlotHandleResponse(httpResp)
	return resp, err
}

// getFtpAllowedSlotCreateRequest creates the GetFtpAllowedSlot request.
func (client *WebAppsClient) getFtpAllowedSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetFtpAllowedSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/ftp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFtpAllowedSlotHandleResponse handles the GetFtpAllowedSlot response.
func (client *WebAppsClient) getFtpAllowedSlotHandleResponse(resp *http.Response) (WebAppsClientGetFtpAllowedSlotResponse, error) {
	result := WebAppsClientGetFtpAllowedSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsClientGetFtpAllowedSlotResponse{}, err
	}
	return result, nil
}

// GetFunction - Description for Get function information by its ID for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - Function name.
//   - options - WebAppsClientGetFunctionOptions contains the optional parameters for the WebAppsClient.GetFunction method.
func (client *WebAppsClient) GetFunction(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsClientGetFunctionOptions) (WebAppsClientGetFunctionResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetFunction"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getFunctionCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return WebAppsClientGetFunctionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetFunctionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetFunctionResponse{}, err
	}
	resp, err := client.getFunctionHandleResponse(httpResp)
	return resp, err
}

// getFunctionCreateRequest creates the GetFunction request.
func (client *WebAppsClient) getFunctionCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsClientGetFunctionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFunctionHandleResponse handles the GetFunction response.
func (client *WebAppsClient) getFunctionHandleResponse(resp *http.Response) (WebAppsClientGetFunctionResponse, error) {
	result := WebAppsClientGetFunctionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionEnvelope); err != nil {
		return WebAppsClientGetFunctionResponse{}, err
	}
	return result, nil
}

// GetFunctionsAdminToken - Description for Fetch a short lived token that can be exchanged for a master key.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientGetFunctionsAdminTokenOptions contains the optional parameters for the WebAppsClient.GetFunctionsAdminToken
//     method.
func (client *WebAppsClient) GetFunctionsAdminToken(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetFunctionsAdminTokenOptions) (WebAppsClientGetFunctionsAdminTokenResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetFunctionsAdminToken"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getFunctionsAdminTokenCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetFunctionsAdminTokenResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetFunctionsAdminTokenResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetFunctionsAdminTokenResponse{}, err
	}
	resp, err := client.getFunctionsAdminTokenHandleResponse(httpResp)
	return resp, err
}

// getFunctionsAdminTokenCreateRequest creates the GetFunctionsAdminToken request.
func (client *WebAppsClient) getFunctionsAdminTokenCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetFunctionsAdminTokenOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/admin/token"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFunctionsAdminTokenHandleResponse handles the GetFunctionsAdminToken response.
func (client *WebAppsClient) getFunctionsAdminTokenHandleResponse(resp *http.Response) (WebAppsClientGetFunctionsAdminTokenResponse, error) {
	result := WebAppsClientGetFunctionsAdminTokenResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return WebAppsClientGetFunctionsAdminTokenResponse{}, err
	}
	return result, nil
}

// GetFunctionsAdminTokenSlot - Description for Fetch a short lived token that can be exchanged for a master key.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - options - WebAppsClientGetFunctionsAdminTokenSlotOptions contains the optional parameters for the WebAppsClient.GetFunctionsAdminTokenSlot
//     method.
func (client *WebAppsClient) GetFunctionsAdminTokenSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetFunctionsAdminTokenSlotOptions) (WebAppsClientGetFunctionsAdminTokenSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetFunctionsAdminTokenSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getFunctionsAdminTokenSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetFunctionsAdminTokenSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetFunctionsAdminTokenSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetFunctionsAdminTokenSlotResponse{}, err
	}
	resp, err := client.getFunctionsAdminTokenSlotHandleResponse(httpResp)
	return resp, err
}

// getFunctionsAdminTokenSlotCreateRequest creates the GetFunctionsAdminTokenSlot request.
func (client *WebAppsClient) getFunctionsAdminTokenSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetFunctionsAdminTokenSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/admin/token"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFunctionsAdminTokenSlotHandleResponse handles the GetFunctionsAdminTokenSlot response.
func (client *WebAppsClient) getFunctionsAdminTokenSlotHandleResponse(resp *http.Response) (WebAppsClientGetFunctionsAdminTokenSlotResponse, error) {
	result := WebAppsClientGetFunctionsAdminTokenSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return WebAppsClientGetFunctionsAdminTokenSlotResponse{}, err
	}
	return result, nil
}

// GetHostNameBinding - Description for Get the named hostname binding for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - hostName - Hostname in the hostname binding.
//   - options - WebAppsClientGetHostNameBindingOptions contains the optional parameters for the WebAppsClient.GetHostNameBinding
//     method.
func (client *WebAppsClient) GetHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, options *WebAppsClientGetHostNameBindingOptions) (WebAppsClientGetHostNameBindingResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetHostNameBinding"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getHostNameBindingCreateRequest(ctx, resourceGroupName, name, hostName, options)
	if err != nil {
		return WebAppsClientGetHostNameBindingResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetHostNameBindingResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetHostNameBindingResponse{}, err
	}
	resp, err := client.getHostNameBindingHandleResponse(httpResp)
	return resp, err
}

// getHostNameBindingCreateRequest creates the GetHostNameBinding request.
func (client *WebAppsClient) getHostNameBindingCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, options *WebAppsClientGetHostNameBindingOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHostNameBindingHandleResponse handles the GetHostNameBinding response.
func (client *WebAppsClient) getHostNameBindingHandleResponse(resp *http.Response) (WebAppsClientGetHostNameBindingResponse, error) {
	result := WebAppsClientGetHostNameBindingResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBinding); err != nil {
		return WebAppsClientGetHostNameBindingResponse{}, err
	}
	return result, nil
}

// GetHostNameBindingSlot - Description for Get the named hostname binding for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
//   - hostName - Hostname in the hostname binding.
//   - options - WebAppsClientGetHostNameBindingSlotOptions contains the optional parameters for the WebAppsClient.GetHostNameBindingSlot
//     method.
func (client *WebAppsClient) GetHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *WebAppsClientGetHostNameBindingSlotOptions) (WebAppsClientGetHostNameBindingSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetHostNameBindingSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getHostNameBindingSlotCreateRequest(ctx, resourceGroupName, name, slot, hostName, options)
	if err != nil {
		return WebAppsClientGetHostNameBindingSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetHostNameBindingSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetHostNameBindingSlotResponse{}, err
	}
	resp, err := client.getHostNameBindingSlotHandleResponse(httpResp)
	return resp, err
}

// getHostNameBindingSlotCreateRequest creates the GetHostNameBindingSlot request.
func (client *WebAppsClient) getHostNameBindingSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *WebAppsClientGetHostNameBindingSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHostNameBindingSlotHandleResponse handles the GetHostNameBindingSlot response.
func (client *WebAppsClient) getHostNameBindingSlotHandleResponse(resp *http.Response) (WebAppsClientGetHostNameBindingSlotResponse, error) {
	result := WebAppsClientGetHostNameBindingSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBinding); err != nil {
		return WebAppsClientGetHostNameBindingSlotResponse{}, err
	}
	return result, nil
}

// GetHybridConnection - Description for Retrieves a specific Service Bus Hybrid Connection used by this Web App.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - namespaceName - The namespace for this hybrid connection.
//   - relayName - The relay name for this hybrid connection.
//   - options - WebAppsClientGetHybridConnectionOptions contains the optional parameters for the WebAppsClient.GetHybridConnection
//     method.
func (client *WebAppsClient) GetHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *WebAppsClientGetHybridConnectionOptions) (WebAppsClientGetHybridConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetHybridConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
	if err != nil {
		return WebAppsClientGetHybridConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetHybridConnectionResponse{}, err
	}
	resp, err := client.getHybridConnectionHandleResponse(httpResp)
	return resp, err
}

// getHybridConnectionCreateRequest creates the GetHybridConnection request.
func (client *WebAppsClient) getHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *WebAppsClientGetHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHybridConnectionHandleResponse handles the GetHybridConnection response.
func (client *WebAppsClient) getHybridConnectionHandleResponse(resp *http.Response) (WebAppsClientGetHybridConnectionResponse, error) {
	result := WebAppsClientGetHybridConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsClientGetHybridConnectionResponse{}, err
	}
	return result, nil
}

// GetHybridConnectionSlot - Description for Retrieves a specific Service Bus Hybrid Connection used by this Web App.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - namespaceName - The namespace for this hybrid connection.
//   - relayName - The relay name for this hybrid connection.
//   - slot - The name of the slot for the web app.
//   - options - WebAppsClientGetHybridConnectionSlotOptions contains the optional parameters for the WebAppsClient.GetHybridConnectionSlot
//     method.
func (client *WebAppsClient) GetHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *WebAppsClientGetHybridConnectionSlotOptions) (WebAppsClientGetHybridConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetHybridConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, options)
	if err != nil {
		return WebAppsClientGetHybridConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetHybridConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetHybridConnectionSlotResponse{}, err
	}
	resp, err := client.getHybridConnectionSlotHandleResponse(httpResp)
	return resp, err
}

// getHybridConnectionSlotCreateRequest creates the GetHybridConnectionSlot request.
func (client *WebAppsClient) getHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *WebAppsClientGetHybridConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHybridConnectionSlotHandleResponse handles the GetHybridConnectionSlot response.
func (client *WebAppsClient) getHybridConnectionSlotHandleResponse(resp *http.Response) (WebAppsClientGetHybridConnectionSlotResponse, error) {
	result := WebAppsClientGetHybridConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsClientGetHybridConnectionSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceFunctionSlot - Description for Get function information by its ID for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - Function name.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientGetInstanceFunctionSlotOptions contains the optional parameters for the WebAppsClient.GetInstanceFunctionSlot
//     method.
func (client *WebAppsClient) GetInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsClientGetInstanceFunctionSlotOptions) (WebAppsClientGetInstanceFunctionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceFunctionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceFunctionSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return WebAppsClientGetInstanceFunctionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceFunctionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceFunctionSlotResponse{}, err
	}
	resp, err := client.getInstanceFunctionSlotHandleResponse(httpResp)
	return resp, err
}

// getInstanceFunctionSlotCreateRequest creates the GetInstanceFunctionSlot request.
func (client *WebAppsClient) getInstanceFunctionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsClientGetInstanceFunctionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceFunctionSlotHandleResponse handles the GetInstanceFunctionSlot response.
func (client *WebAppsClient) getInstanceFunctionSlotHandleResponse(resp *http.Response) (WebAppsClientGetInstanceFunctionSlotResponse, error) {
	result := WebAppsClientGetInstanceFunctionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionEnvelope); err != nil {
		return WebAppsClientGetInstanceFunctionSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceInfo - Description for Gets all scale-out instances of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetInstanceInfoOptions contains the optional parameters for the WebAppsClient.GetInstanceInfo method.
func (client *WebAppsClient) GetInstanceInfo(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsClientGetInstanceInfoOptions) (WebAppsClientGetInstanceInfoResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceInfo"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceInfoCreateRequest(ctx, resourceGroupName, name, instanceID, options)
	if err != nil {
		return WebAppsClientGetInstanceInfoResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceInfoResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceInfoResponse{}, err
	}
	resp, err := client.getInstanceInfoHandleResponse(httpResp)
	return resp, err
}

// getInstanceInfoCreateRequest creates the GetInstanceInfo request.
func (client *WebAppsClient) getInstanceInfoCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsClientGetInstanceInfoOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceInfoHandleResponse handles the GetInstanceInfo response.
func (client *WebAppsClient) getInstanceInfoHandleResponse(resp *http.Response) (WebAppsClientGetInstanceInfoResponse, error) {
	result := WebAppsClientGetInstanceInfoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebSiteInstanceStatus); err != nil {
		return WebAppsClientGetInstanceInfoResponse{}, err
	}
	return result, nil
}

// GetInstanceInfoSlot - Description for Gets all scale-out instances of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
//   - options - WebAppsClientGetInstanceInfoSlotOptions contains the optional parameters for the WebAppsClient.GetInstanceInfoSlot
//     method.
func (client *WebAppsClient) GetInstanceInfoSlot(ctx context.Context, resourceGroupName string, name string, instanceID string, slot string, options *WebAppsClientGetInstanceInfoSlotOptions) (WebAppsClientGetInstanceInfoSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceInfoSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceInfoSlotCreateRequest(ctx, resourceGroupName, name, instanceID, slot, options)
	if err != nil {
		return WebAppsClientGetInstanceInfoSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceInfoSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceInfoSlotResponse{}, err
	}
	resp, err := client.getInstanceInfoSlotHandleResponse(httpResp)
	return resp, err
}

// getInstanceInfoSlotCreateRequest creates the GetInstanceInfoSlot request.
func (client *WebAppsClient) getInstanceInfoSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, slot string, options *WebAppsClientGetInstanceInfoSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceInfoSlotHandleResponse handles the GetInstanceInfoSlot response.
func (client *WebAppsClient) getInstanceInfoSlotHandleResponse(resp *http.Response) (WebAppsClientGetInstanceInfoSlotResponse, error) {
	result := WebAppsClientGetInstanceInfoSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebSiteInstanceStatus); err != nil {
		return WebAppsClientGetInstanceInfoSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceMSDeployLog - Description for Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - instanceID - ID of web app instance.
//   - options - WebAppsClientGetInstanceMSDeployLogOptions contains the optional parameters for the WebAppsClient.GetInstanceMSDeployLog
//     method.
func (client *WebAppsClient) GetInstanceMSDeployLog(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsClientGetInstanceMSDeployLogOptions) (WebAppsClientGetInstanceMSDeployLogResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceMSDeployLog"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceMSDeployLogCreateRequest(ctx, resourceGroupName, name, instanceID, options)
	if err != nil {
		return WebAppsClientGetInstanceMSDeployLogResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceMSDeployLogResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceMSDeployLogResponse{}, err
	}
	resp, err := client.getInstanceMSDeployLogHandleResponse(httpResp)
	return resp, err
}

// getInstanceMSDeployLogCreateRequest creates the GetInstanceMSDeployLog request.
func (client *WebAppsClient) getInstanceMSDeployLogCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsClientGetInstanceMSDeployLogOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceMSDeployLogHandleResponse handles the GetInstanceMSDeployLog response.
func (client *WebAppsClient) getInstanceMSDeployLogHandleResponse(resp *http.Response) (WebAppsClientGetInstanceMSDeployLogResponse, error) {
	result := WebAppsClientGetInstanceMSDeployLogResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployLog); err != nil {
		return WebAppsClientGetInstanceMSDeployLogResponse{}, err
	}
	return result, nil
}

// GetInstanceMSDeployLogSlot - Description for Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - instanceID - ID of web app instance.
//   - options - WebAppsClientGetInstanceMSDeployLogSlotOptions contains the optional parameters for the WebAppsClient.GetInstanceMSDeployLogSlot
//     method.
func (client *WebAppsClient) GetInstanceMSDeployLogSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsClientGetInstanceMSDeployLogSlotOptions) (WebAppsClientGetInstanceMSDeployLogSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceMSDeployLogSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceMSDeployLogSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, options)
	if err != nil {
		return WebAppsClientGetInstanceMSDeployLogSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceMSDeployLogSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceMSDeployLogSlotResponse{}, err
	}
	resp, err := client.getInstanceMSDeployLogSlotHandleResponse(httpResp)
	return resp, err
}

// getInstanceMSDeployLogSlotCreateRequest creates the GetInstanceMSDeployLogSlot request.
func (client *WebAppsClient) getInstanceMSDeployLogSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsClientGetInstanceMSDeployLogSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceMSDeployLogSlotHandleResponse handles the GetInstanceMSDeployLogSlot response.
func (client *WebAppsClient) getInstanceMSDeployLogSlotHandleResponse(resp *http.Response) (WebAppsClientGetInstanceMSDeployLogSlotResponse, error) {
	result := WebAppsClientGetInstanceMSDeployLogSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployLog); err != nil {
		return WebAppsClientGetInstanceMSDeployLogSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceMsDeployStatus - Description for Get the status of the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - instanceID - ID of web app instance.
//   - options - WebAppsClientGetInstanceMsDeployStatusOptions contains the optional parameters for the WebAppsClient.GetInstanceMsDeployStatus
//     method.
func (client *WebAppsClient) GetInstanceMsDeployStatus(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsClientGetInstanceMsDeployStatusOptions) (WebAppsClientGetInstanceMsDeployStatusResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceMsDeployStatus"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceMsDeployStatusCreateRequest(ctx, resourceGroupName, name, instanceID, options)
	if err != nil {
		return WebAppsClientGetInstanceMsDeployStatusResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceMsDeployStatusResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceMsDeployStatusResponse{}, err
	}
	resp, err := client.getInstanceMsDeployStatusHandleResponse(httpResp)
	return resp, err
}

// getInstanceMsDeployStatusCreateRequest creates the GetInstanceMsDeployStatus request.
func (client *WebAppsClient) getInstanceMsDeployStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsClientGetInstanceMsDeployStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceMsDeployStatusHandleResponse handles the GetInstanceMsDeployStatus response.
func (client *WebAppsClient) getInstanceMsDeployStatusHandleResponse(resp *http.Response) (WebAppsClientGetInstanceMsDeployStatusResponse, error) {
	result := WebAppsClientGetInstanceMsDeployStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployStatus); err != nil {
		return WebAppsClientGetInstanceMsDeployStatusResponse{}, err
	}
	return result, nil
}

// GetInstanceMsDeployStatusSlot - Description for Get the status of the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - instanceID - ID of web app instance.
//   - options - WebAppsClientGetInstanceMsDeployStatusSlotOptions contains the optional parameters for the WebAppsClient.GetInstanceMsDeployStatusSlot
//     method.
func (client *WebAppsClient) GetInstanceMsDeployStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsClientGetInstanceMsDeployStatusSlotOptions) (WebAppsClientGetInstanceMsDeployStatusSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceMsDeployStatusSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceMsDeployStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, options)
	if err != nil {
		return WebAppsClientGetInstanceMsDeployStatusSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceMsDeployStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceMsDeployStatusSlotResponse{}, err
	}
	resp, err := client.getInstanceMsDeployStatusSlotHandleResponse(httpResp)
	return resp, err
}

// getInstanceMsDeployStatusSlotCreateRequest creates the GetInstanceMsDeployStatusSlot request.
func (client *WebAppsClient) getInstanceMsDeployStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsClientGetInstanceMsDeployStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceMsDeployStatusSlotHandleResponse handles the GetInstanceMsDeployStatusSlot response.
func (client *WebAppsClient) getInstanceMsDeployStatusSlotHandleResponse(resp *http.Response) (WebAppsClientGetInstanceMsDeployStatusSlotResponse, error) {
	result := WebAppsClientGetInstanceMsDeployStatusSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployStatus); err != nil {
		return WebAppsClientGetInstanceMsDeployStatusSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceProcess - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientGetInstanceProcessOptions contains the optional parameters for the WebAppsClient.GetInstanceProcess
//     method.
func (client *WebAppsClient) GetInstanceProcess(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsClientGetInstanceProcessOptions) (WebAppsClientGetInstanceProcessResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceProcess"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceProcessCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
	if err != nil {
		return WebAppsClientGetInstanceProcessResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceProcessResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceProcessResponse{}, err
	}
	resp, err := client.getInstanceProcessHandleResponse(httpResp)
	return resp, err
}

// getInstanceProcessCreateRequest creates the GetInstanceProcess request.
func (client *WebAppsClient) getInstanceProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsClientGetInstanceProcessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceProcessHandleResponse handles the GetInstanceProcess response.
func (client *WebAppsClient) getInstanceProcessHandleResponse(resp *http.Response) (WebAppsClientGetInstanceProcessResponse, error) {
	result := WebAppsClientGetInstanceProcessResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfo); err != nil {
		return WebAppsClientGetInstanceProcessResponse{}, err
	}
	return result, nil
}

// GetInstanceProcessDump - Description for Get a memory dump of a process by its ID for a specific scaled-out instance in
// a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientGetInstanceProcessDumpOptions contains the optional parameters for the WebAppsClient.GetInstanceProcessDump
//     method.
func (client *WebAppsClient) GetInstanceProcessDump(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsClientGetInstanceProcessDumpOptions) (WebAppsClientGetInstanceProcessDumpResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceProcessDump"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceProcessDumpCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
	if err != nil {
		return WebAppsClientGetInstanceProcessDumpResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceProcessDumpResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceProcessDumpResponse{}, err
	}
	return WebAppsClientGetInstanceProcessDumpResponse{Body: httpResp.Body}, nil
}

// getInstanceProcessDumpCreateRequest creates the GetInstanceProcessDump request.
func (client *WebAppsClient) getInstanceProcessDumpCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsClientGetInstanceProcessDumpOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetInstanceProcessDumpSlot - Description for Get a memory dump of a process by its ID for a specific scaled-out instance
// in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientGetInstanceProcessDumpSlotOptions contains the optional parameters for the WebAppsClient.GetInstanceProcessDumpSlot
//     method.
func (client *WebAppsClient) GetInstanceProcessDumpSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsClientGetInstanceProcessDumpSlotOptions) (WebAppsClientGetInstanceProcessDumpSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceProcessDumpSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceProcessDumpSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
	if err != nil {
		return WebAppsClientGetInstanceProcessDumpSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceProcessDumpSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceProcessDumpSlotResponse{}, err
	}
	return WebAppsClientGetInstanceProcessDumpSlotResponse{Body: httpResp.Body}, nil
}

// getInstanceProcessDumpSlotCreateRequest creates the GetInstanceProcessDumpSlot request.
func (client *WebAppsClient) getInstanceProcessDumpSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsClientGetInstanceProcessDumpSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetInstanceProcessModule - Description for Get process information by its ID for a specific scaled-out instance in a web
// site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - baseAddress - Module base address.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientGetInstanceProcessModuleOptions contains the optional parameters for the WebAppsClient.GetInstanceProcessModule
//     method.
func (client *WebAppsClient) GetInstanceProcessModule(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, instanceID string, options *WebAppsClientGetInstanceProcessModuleOptions) (WebAppsClientGetInstanceProcessModuleResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceProcessModule"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceProcessModuleCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, instanceID, options)
	if err != nil {
		return WebAppsClientGetInstanceProcessModuleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceProcessModuleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceProcessModuleResponse{}, err
	}
	resp, err := client.getInstanceProcessModuleHandleResponse(httpResp)
	return resp, err
}

// getInstanceProcessModuleCreateRequest creates the GetInstanceProcessModule request.
func (client *WebAppsClient) getInstanceProcessModuleCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, instanceID string, options *WebAppsClientGetInstanceProcessModuleOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceProcessModuleHandleResponse handles the GetInstanceProcessModule response.
func (client *WebAppsClient) getInstanceProcessModuleHandleResponse(resp *http.Response) (WebAppsClientGetInstanceProcessModuleResponse, error) {
	result := WebAppsClientGetInstanceProcessModuleResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfo); err != nil {
		return WebAppsClientGetInstanceProcessModuleResponse{}, err
	}
	return result, nil
}

// GetInstanceProcessModuleSlot - Description for Get process information by its ID for a specific scaled-out instance in
// a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - baseAddress - Module base address.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientGetInstanceProcessModuleSlotOptions contains the optional parameters for the WebAppsClient.GetInstanceProcessModuleSlot
//     method.
func (client *WebAppsClient) GetInstanceProcessModuleSlot(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, instanceID string, options *WebAppsClientGetInstanceProcessModuleSlotOptions) (WebAppsClientGetInstanceProcessModuleSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceProcessModuleSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceProcessModuleSlotCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, slot, instanceID, options)
	if err != nil {
		return WebAppsClientGetInstanceProcessModuleSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceProcessModuleSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceProcessModuleSlotResponse{}, err
	}
	resp, err := client.getInstanceProcessModuleSlotHandleResponse(httpResp)
	return resp, err
}

// getInstanceProcessModuleSlotCreateRequest creates the GetInstanceProcessModuleSlot request.
func (client *WebAppsClient) getInstanceProcessModuleSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, instanceID string, options *WebAppsClientGetInstanceProcessModuleSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceProcessModuleSlotHandleResponse handles the GetInstanceProcessModuleSlot response.
func (client *WebAppsClient) getInstanceProcessModuleSlotHandleResponse(resp *http.Response) (WebAppsClientGetInstanceProcessModuleSlotResponse, error) {
	result := WebAppsClientGetInstanceProcessModuleSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfo); err != nil {
		return WebAppsClientGetInstanceProcessModuleSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceProcessSlot - Description for Get process information by its ID for a specific scaled-out instance in a web
// site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientGetInstanceProcessSlotOptions contains the optional parameters for the WebAppsClient.GetInstanceProcessSlot
//     method.
func (client *WebAppsClient) GetInstanceProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsClientGetInstanceProcessSlotOptions) (WebAppsClientGetInstanceProcessSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceProcessSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
	if err != nil {
		return WebAppsClientGetInstanceProcessSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceProcessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceProcessSlotResponse{}, err
	}
	resp, err := client.getInstanceProcessSlotHandleResponse(httpResp)
	return resp, err
}

// getInstanceProcessSlotCreateRequest creates the GetInstanceProcessSlot request.
func (client *WebAppsClient) getInstanceProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsClientGetInstanceProcessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceProcessSlotHandleResponse handles the GetInstanceProcessSlot response.
func (client *WebAppsClient) getInstanceProcessSlotHandleResponse(resp *http.Response) (WebAppsClientGetInstanceProcessSlotResponse, error) {
	result := WebAppsClientGetInstanceProcessSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfo); err != nil {
		return WebAppsClientGetInstanceProcessSlotResponse{}, err
	}
	return result, nil
}

// GetInstanceWorkflowSlot - Get workflow information by its ID for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - slot - Name of the deployment slot.
//   - workflowName - Workflow name.
//   - options - WebAppsClientGetInstanceWorkflowSlotOptions contains the optional parameters for the WebAppsClient.GetInstanceWorkflowSlot
//     method.
func (client *WebAppsClient) GetInstanceWorkflowSlot(ctx context.Context, resourceGroupName string, name string, slot string, workflowName string, options *WebAppsClientGetInstanceWorkflowSlotOptions) (WebAppsClientGetInstanceWorkflowSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetInstanceWorkflowSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInstanceWorkflowSlotCreateRequest(ctx, resourceGroupName, name, slot, workflowName, options)
	if err != nil {
		return WebAppsClientGetInstanceWorkflowSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetInstanceWorkflowSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetInstanceWorkflowSlotResponse{}, err
	}
	resp, err := client.getInstanceWorkflowSlotHandleResponse(httpResp)
	return resp, err
}

// getInstanceWorkflowSlotCreateRequest creates the GetInstanceWorkflowSlot request.
func (client *WebAppsClient) getInstanceWorkflowSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, workflowName string, options *WebAppsClientGetInstanceWorkflowSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/workflows/{workflowName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if workflowName == "" {
		return nil, errors.New("parameter workflowName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workflowName}", url.PathEscape(workflowName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInstanceWorkflowSlotHandleResponse handles the GetInstanceWorkflowSlot response.
func (client *WebAppsClient) getInstanceWorkflowSlotHandleResponse(resp *http.Response) (WebAppsClientGetInstanceWorkflowSlotResponse, error) {
	result := WebAppsClientGetInstanceWorkflowSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkflowEnvelope); err != nil {
		return WebAppsClientGetInstanceWorkflowSlotResponse{}, err
	}
	return result, nil
}

// GetMSDeployLog - Description for Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientGetMSDeployLogOptions contains the optional parameters for the WebAppsClient.GetMSDeployLog method.
func (client *WebAppsClient) GetMSDeployLog(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetMSDeployLogOptions) (WebAppsClientGetMSDeployLogResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetMSDeployLog"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getMSDeployLogCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetMSDeployLogResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetMSDeployLogResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetMSDeployLogResponse{}, err
	}
	resp, err := client.getMSDeployLogHandleResponse(httpResp)
	return resp, err
}

// getMSDeployLogCreateRequest creates the GetMSDeployLog request.
func (client *WebAppsClient) getMSDeployLogCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetMSDeployLogOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMSDeployLogHandleResponse handles the GetMSDeployLog response.
func (client *WebAppsClient) getMSDeployLogHandleResponse(resp *http.Response) (WebAppsClientGetMSDeployLogResponse, error) {
	result := WebAppsClientGetMSDeployLogResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployLog); err != nil {
		return WebAppsClientGetMSDeployLogResponse{}, err
	}
	return result, nil
}

// GetMSDeployLogSlot - Description for Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - options - WebAppsClientGetMSDeployLogSlotOptions contains the optional parameters for the WebAppsClient.GetMSDeployLogSlot
//     method.
func (client *WebAppsClient) GetMSDeployLogSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetMSDeployLogSlotOptions) (WebAppsClientGetMSDeployLogSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetMSDeployLogSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getMSDeployLogSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetMSDeployLogSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetMSDeployLogSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetMSDeployLogSlotResponse{}, err
	}
	resp, err := client.getMSDeployLogSlotHandleResponse(httpResp)
	return resp, err
}

// getMSDeployLogSlotCreateRequest creates the GetMSDeployLogSlot request.
func (client *WebAppsClient) getMSDeployLogSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetMSDeployLogSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMSDeployLogSlotHandleResponse handles the GetMSDeployLogSlot response.
func (client *WebAppsClient) getMSDeployLogSlotHandleResponse(resp *http.Response) (WebAppsClientGetMSDeployLogSlotResponse, error) {
	result := WebAppsClientGetMSDeployLogSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployLog); err != nil {
		return WebAppsClientGetMSDeployLogSlotResponse{}, err
	}
	return result, nil
}

// GetMSDeployStatus - Description for Get the status of the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientGetMSDeployStatusOptions contains the optional parameters for the WebAppsClient.GetMSDeployStatus
//     method.
func (client *WebAppsClient) GetMSDeployStatus(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetMSDeployStatusOptions) (WebAppsClientGetMSDeployStatusResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetMSDeployStatus"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getMSDeployStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetMSDeployStatusResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetMSDeployStatusResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetMSDeployStatusResponse{}, err
	}
	resp, err := client.getMSDeployStatusHandleResponse(httpResp)
	return resp, err
}

// getMSDeployStatusCreateRequest creates the GetMSDeployStatus request.
func (client *WebAppsClient) getMSDeployStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetMSDeployStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMSDeployStatusHandleResponse handles the GetMSDeployStatus response.
func (client *WebAppsClient) getMSDeployStatusHandleResponse(resp *http.Response) (WebAppsClientGetMSDeployStatusResponse, error) {
	result := WebAppsClientGetMSDeployStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployStatus); err != nil {
		return WebAppsClientGetMSDeployStatusResponse{}, err
	}
	return result, nil
}

// GetMSDeployStatusSlot - Description for Get the status of the last MSDeploy operation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - options - WebAppsClientGetMSDeployStatusSlotOptions contains the optional parameters for the WebAppsClient.GetMSDeployStatusSlot
//     method.
func (client *WebAppsClient) GetMSDeployStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetMSDeployStatusSlotOptions) (WebAppsClientGetMSDeployStatusSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetMSDeployStatusSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getMSDeployStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetMSDeployStatusSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetMSDeployStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetMSDeployStatusSlotResponse{}, err
	}
	resp, err := client.getMSDeployStatusSlotHandleResponse(httpResp)
	return resp, err
}

// getMSDeployStatusSlotCreateRequest creates the GetMSDeployStatusSlot request.
func (client *WebAppsClient) getMSDeployStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetMSDeployStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMSDeployStatusSlotHandleResponse handles the GetMSDeployStatusSlot response.
func (client *WebAppsClient) getMSDeployStatusSlotHandleResponse(resp *http.Response) (WebAppsClientGetMSDeployStatusSlotResponse, error) {
	result := WebAppsClientGetMSDeployStatusSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployStatus); err != nil {
		return WebAppsClientGetMSDeployStatusSlotResponse{}, err
	}
	return result, nil
}

// GetMigrateMySQLStatus - Description for Returns the status of MySql in app migration, if one is active, and whether or
// not MySql in app is enabled
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientGetMigrateMySQLStatusOptions contains the optional parameters for the WebAppsClient.GetMigrateMySQLStatus
//     method.
func (client *WebAppsClient) GetMigrateMySQLStatus(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetMigrateMySQLStatusOptions) (WebAppsClientGetMigrateMySQLStatusResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetMigrateMySQLStatus"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getMigrateMySQLStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetMigrateMySQLStatusResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetMigrateMySQLStatusResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetMigrateMySQLStatusResponse{}, err
	}
	resp, err := client.getMigrateMySQLStatusHandleResponse(httpResp)
	return resp, err
}

// getMigrateMySQLStatusCreateRequest creates the GetMigrateMySQLStatus request.
func (client *WebAppsClient) getMigrateMySQLStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetMigrateMySQLStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql/status"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMigrateMySQLStatusHandleResponse handles the GetMigrateMySQLStatus response.
func (client *WebAppsClient) getMigrateMySQLStatusHandleResponse(resp *http.Response) (WebAppsClientGetMigrateMySQLStatusResponse, error) {
	result := WebAppsClientGetMigrateMySQLStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MigrateMySQLStatus); err != nil {
		return WebAppsClientGetMigrateMySQLStatusResponse{}, err
	}
	return result, nil
}

// GetMigrateMySQLStatusSlot - Description for Returns the status of MySql in app migration, if one is active, and whether
// or not MySql in app is enabled
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientGetMigrateMySQLStatusSlotOptions contains the optional parameters for the WebAppsClient.GetMigrateMySQLStatusSlot
//     method.
func (client *WebAppsClient) GetMigrateMySQLStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetMigrateMySQLStatusSlotOptions) (WebAppsClientGetMigrateMySQLStatusSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetMigrateMySQLStatusSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getMigrateMySQLStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetMigrateMySQLStatusSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetMigrateMySQLStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetMigrateMySQLStatusSlotResponse{}, err
	}
	resp, err := client.getMigrateMySQLStatusSlotHandleResponse(httpResp)
	return resp, err
}

// getMigrateMySQLStatusSlotCreateRequest creates the GetMigrateMySQLStatusSlot request.
func (client *WebAppsClient) getMigrateMySQLStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetMigrateMySQLStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/migratemysql/status"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMigrateMySQLStatusSlotHandleResponse handles the GetMigrateMySQLStatusSlot response.
func (client *WebAppsClient) getMigrateMySQLStatusSlotHandleResponse(resp *http.Response) (WebAppsClientGetMigrateMySQLStatusSlotResponse, error) {
	result := WebAppsClientGetMigrateMySQLStatusSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MigrateMySQLStatus); err != nil {
		return WebAppsClientGetMigrateMySQLStatusSlotResponse{}, err
	}
	return result, nil
}

// GetNetworkTraceOperation - Description for Gets a named operation for a network trace capturing (or deployment slot, if
// specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - operationID - GUID of the operation.
//   - options - WebAppsClientGetNetworkTraceOperationOptions contains the optional parameters for the WebAppsClient.GetNetworkTraceOperation
//     method.
func (client *WebAppsClient) GetNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsClientGetNetworkTraceOperationOptions) (WebAppsClientGetNetworkTraceOperationResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetNetworkTraceOperation"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNetworkTraceOperationCreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return WebAppsClientGetNetworkTraceOperationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetNetworkTraceOperationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetNetworkTraceOperationResponse{}, err
	}
	resp, err := client.getNetworkTraceOperationHandleResponse(httpResp)
	return resp, err
}

// getNetworkTraceOperationCreateRequest creates the GetNetworkTraceOperation request.
func (client *WebAppsClient) getNetworkTraceOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsClientGetNetworkTraceOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTraceOperationHandleResponse handles the GetNetworkTraceOperation response.
func (client *WebAppsClient) getNetworkTraceOperationHandleResponse(resp *http.Response) (WebAppsClientGetNetworkTraceOperationResponse, error) {
	result := WebAppsClientGetNetworkTraceOperationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsClientGetNetworkTraceOperationResponse{}, err
	}
	return result, nil
}

// GetNetworkTraceOperationSlot - Description for Gets a named operation for a network trace capturing (or deployment slot,
// if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - operationID - GUID of the operation.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get an operation for the production slot.
//   - options - WebAppsClientGetNetworkTraceOperationSlotOptions contains the optional parameters for the WebAppsClient.GetNetworkTraceOperationSlot
//     method.
func (client *WebAppsClient) GetNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsClientGetNetworkTraceOperationSlotOptions) (WebAppsClientGetNetworkTraceOperationSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetNetworkTraceOperationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNetworkTraceOperationSlotCreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return WebAppsClientGetNetworkTraceOperationSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetNetworkTraceOperationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetNetworkTraceOperationSlotResponse{}, err
	}
	resp, err := client.getNetworkTraceOperationSlotHandleResponse(httpResp)
	return resp, err
}

// getNetworkTraceOperationSlotCreateRequest creates the GetNetworkTraceOperationSlot request.
func (client *WebAppsClient) getNetworkTraceOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsClientGetNetworkTraceOperationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTraceOperationSlotHandleResponse handles the GetNetworkTraceOperationSlot response.
func (client *WebAppsClient) getNetworkTraceOperationSlotHandleResponse(resp *http.Response) (WebAppsClientGetNetworkTraceOperationSlotResponse, error) {
	result := WebAppsClientGetNetworkTraceOperationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsClientGetNetworkTraceOperationSlotResponse{}, err
	}
	return result, nil
}

// GetNetworkTraceOperationSlotV2 - Description for Gets a named operation for a network trace capturing (or deployment slot,
// if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - operationID - GUID of the operation.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get an operation for the production slot.
//   - options - WebAppsClientGetNetworkTraceOperationSlotV2Options contains the optional parameters for the WebAppsClient.GetNetworkTraceOperationSlotV2
//     method.
func (client *WebAppsClient) GetNetworkTraceOperationSlotV2(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsClientGetNetworkTraceOperationSlotV2Options) (WebAppsClientGetNetworkTraceOperationSlotV2Response, error) {
	var err error
	const operationName = "WebAppsClient.GetNetworkTraceOperationSlotV2"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNetworkTraceOperationSlotV2CreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return WebAppsClientGetNetworkTraceOperationSlotV2Response{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetNetworkTraceOperationSlotV2Response{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetNetworkTraceOperationSlotV2Response{}, err
	}
	resp, err := client.getNetworkTraceOperationSlotV2HandleResponse(httpResp)
	return resp, err
}

// getNetworkTraceOperationSlotV2CreateRequest creates the GetNetworkTraceOperationSlotV2 request.
func (client *WebAppsClient) getNetworkTraceOperationSlotV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsClientGetNetworkTraceOperationSlotV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/current/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTraceOperationSlotV2HandleResponse handles the GetNetworkTraceOperationSlotV2 response.
func (client *WebAppsClient) getNetworkTraceOperationSlotV2HandleResponse(resp *http.Response) (WebAppsClientGetNetworkTraceOperationSlotV2Response, error) {
	result := WebAppsClientGetNetworkTraceOperationSlotV2Response{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsClientGetNetworkTraceOperationSlotV2Response{}, err
	}
	return result, nil
}

// GetNetworkTraceOperationV2 - Description for Gets a named operation for a network trace capturing (or deployment slot,
// if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - operationID - GUID of the operation.
//   - options - WebAppsClientGetNetworkTraceOperationV2Options contains the optional parameters for the WebAppsClient.GetNetworkTraceOperationV2
//     method.
func (client *WebAppsClient) GetNetworkTraceOperationV2(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsClientGetNetworkTraceOperationV2Options) (WebAppsClientGetNetworkTraceOperationV2Response, error) {
	var err error
	const operationName = "WebAppsClient.GetNetworkTraceOperationV2"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNetworkTraceOperationV2CreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return WebAppsClientGetNetworkTraceOperationV2Response{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetNetworkTraceOperationV2Response{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetNetworkTraceOperationV2Response{}, err
	}
	resp, err := client.getNetworkTraceOperationV2HandleResponse(httpResp)
	return resp, err
}

// getNetworkTraceOperationV2CreateRequest creates the GetNetworkTraceOperationV2 request.
func (client *WebAppsClient) getNetworkTraceOperationV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsClientGetNetworkTraceOperationV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/current/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTraceOperationV2HandleResponse handles the GetNetworkTraceOperationV2 response.
func (client *WebAppsClient) getNetworkTraceOperationV2HandleResponse(resp *http.Response) (WebAppsClientGetNetworkTraceOperationV2Response, error) {
	result := WebAppsClientGetNetworkTraceOperationV2Response{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsClientGetNetworkTraceOperationV2Response{}, err
	}
	return result, nil
}

// GetNetworkTraces - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - operationID - GUID of the operation.
//   - options - WebAppsClientGetNetworkTracesOptions contains the optional parameters for the WebAppsClient.GetNetworkTraces
//     method.
func (client *WebAppsClient) GetNetworkTraces(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsClientGetNetworkTracesOptions) (WebAppsClientGetNetworkTracesResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetNetworkTraces"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNetworkTracesCreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return WebAppsClientGetNetworkTracesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetNetworkTracesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetNetworkTracesResponse{}, err
	}
	resp, err := client.getNetworkTracesHandleResponse(httpResp)
	return resp, err
}

// getNetworkTracesCreateRequest creates the GetNetworkTraces request.
func (client *WebAppsClient) getNetworkTracesCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsClientGetNetworkTracesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTracesHandleResponse handles the GetNetworkTraces response.
func (client *WebAppsClient) getNetworkTracesHandleResponse(resp *http.Response) (WebAppsClientGetNetworkTracesResponse, error) {
	result := WebAppsClientGetNetworkTracesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsClientGetNetworkTracesResponse{}, err
	}
	return result, nil
}

// GetNetworkTracesSlot - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - operationID - GUID of the operation.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get an operation for the production slot.
//   - options - WebAppsClientGetNetworkTracesSlotOptions contains the optional parameters for the WebAppsClient.GetNetworkTracesSlot
//     method.
func (client *WebAppsClient) GetNetworkTracesSlot(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsClientGetNetworkTracesSlotOptions) (WebAppsClientGetNetworkTracesSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetNetworkTracesSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNetworkTracesSlotCreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return WebAppsClientGetNetworkTracesSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetNetworkTracesSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetNetworkTracesSlotResponse{}, err
	}
	resp, err := client.getNetworkTracesSlotHandleResponse(httpResp)
	return resp, err
}

// getNetworkTracesSlotCreateRequest creates the GetNetworkTracesSlot request.
func (client *WebAppsClient) getNetworkTracesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsClientGetNetworkTracesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTracesSlotHandleResponse handles the GetNetworkTracesSlot response.
func (client *WebAppsClient) getNetworkTracesSlotHandleResponse(resp *http.Response) (WebAppsClientGetNetworkTracesSlotResponse, error) {
	result := WebAppsClientGetNetworkTracesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsClientGetNetworkTracesSlotResponse{}, err
	}
	return result, nil
}

// GetNetworkTracesSlotV2 - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - operationID - GUID of the operation.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get an operation for the production slot.
//   - options - WebAppsClientGetNetworkTracesSlotV2Options contains the optional parameters for the WebAppsClient.GetNetworkTracesSlotV2
//     method.
func (client *WebAppsClient) GetNetworkTracesSlotV2(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsClientGetNetworkTracesSlotV2Options) (WebAppsClientGetNetworkTracesSlotV2Response, error) {
	var err error
	const operationName = "WebAppsClient.GetNetworkTracesSlotV2"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNetworkTracesSlotV2CreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return WebAppsClientGetNetworkTracesSlotV2Response{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetNetworkTracesSlotV2Response{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetNetworkTracesSlotV2Response{}, err
	}
	resp, err := client.getNetworkTracesSlotV2HandleResponse(httpResp)
	return resp, err
}

// getNetworkTracesSlotV2CreateRequest creates the GetNetworkTracesSlotV2 request.
func (client *WebAppsClient) getNetworkTracesSlotV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsClientGetNetworkTracesSlotV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTracesSlotV2HandleResponse handles the GetNetworkTracesSlotV2 response.
func (client *WebAppsClient) getNetworkTracesSlotV2HandleResponse(resp *http.Response) (WebAppsClientGetNetworkTracesSlotV2Response, error) {
	result := WebAppsClientGetNetworkTracesSlotV2Response{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsClientGetNetworkTracesSlotV2Response{}, err
	}
	return result, nil
}

// GetNetworkTracesV2 - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - operationID - GUID of the operation.
//   - options - WebAppsClientGetNetworkTracesV2Options contains the optional parameters for the WebAppsClient.GetNetworkTracesV2
//     method.
func (client *WebAppsClient) GetNetworkTracesV2(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsClientGetNetworkTracesV2Options) (WebAppsClientGetNetworkTracesV2Response, error) {
	var err error
	const operationName = "WebAppsClient.GetNetworkTracesV2"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNetworkTracesV2CreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return WebAppsClientGetNetworkTracesV2Response{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetNetworkTracesV2Response{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetNetworkTracesV2Response{}, err
	}
	resp, err := client.getNetworkTracesV2HandleResponse(httpResp)
	return resp, err
}

// getNetworkTracesV2CreateRequest creates the GetNetworkTracesV2 request.
func (client *WebAppsClient) getNetworkTracesV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsClientGetNetworkTracesV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNetworkTracesV2HandleResponse handles the GetNetworkTracesV2 response.
func (client *WebAppsClient) getNetworkTracesV2HandleResponse(resp *http.Response) (WebAppsClientGetNetworkTracesV2Response, error) {
	result := WebAppsClientGetNetworkTracesV2Response{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsClientGetNetworkTracesV2Response{}, err
	}
	return result, nil
}

// GetOneDeployStatus - Description for Invoke onedeploy status API /api/deployments and gets the deployment status for the
// site
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientGetOneDeployStatusOptions contains the optional parameters for the WebAppsClient.GetOneDeployStatus
//     method.
func (client *WebAppsClient) GetOneDeployStatus(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetOneDeployStatusOptions) (WebAppsClientGetOneDeployStatusResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetOneDeployStatus"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getOneDeployStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetOneDeployStatusResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetOneDeployStatusResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetOneDeployStatusResponse{}, err
	}
	resp, err := client.getOneDeployStatusHandleResponse(httpResp)
	return resp, err
}

// getOneDeployStatusCreateRequest creates the GetOneDeployStatus request.
func (client *WebAppsClient) getOneDeployStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetOneDeployStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/onedeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getOneDeployStatusHandleResponse handles the GetOneDeployStatus response.
func (client *WebAppsClient) getOneDeployStatusHandleResponse(resp *http.Response) (WebAppsClientGetOneDeployStatusResponse, error) {
	result := WebAppsClientGetOneDeployStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return WebAppsClientGetOneDeployStatusResponse{}, err
	}
	return result, nil
}

// GetPremierAddOn - Description for Gets a named add-on of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - premierAddOnName - Add-on name.
//   - options - WebAppsClientGetPremierAddOnOptions contains the optional parameters for the WebAppsClient.GetPremierAddOn method.
func (client *WebAppsClient) GetPremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *WebAppsClientGetPremierAddOnOptions) (WebAppsClientGetPremierAddOnResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetPremierAddOn"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getPremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, options)
	if err != nil {
		return WebAppsClientGetPremierAddOnResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetPremierAddOnResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetPremierAddOnResponse{}, err
	}
	resp, err := client.getPremierAddOnHandleResponse(httpResp)
	return resp, err
}

// getPremierAddOnCreateRequest creates the GetPremierAddOn request.
func (client *WebAppsClient) getPremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *WebAppsClientGetPremierAddOnOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPremierAddOnHandleResponse handles the GetPremierAddOn response.
func (client *WebAppsClient) getPremierAddOnHandleResponse(resp *http.Response) (WebAppsClientGetPremierAddOnResponse, error) {
	result := WebAppsClientGetPremierAddOnResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsClientGetPremierAddOnResponse{}, err
	}
	return result, nil
}

// GetPremierAddOnSlot - Description for Gets a named add-on of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - premierAddOnName - Add-on name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the named add-on for the production slot.
//   - options - WebAppsClientGetPremierAddOnSlotOptions contains the optional parameters for the WebAppsClient.GetPremierAddOnSlot
//     method.
func (client *WebAppsClient) GetPremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *WebAppsClientGetPremierAddOnSlotOptions) (WebAppsClientGetPremierAddOnSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetPremierAddOnSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getPremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, options)
	if err != nil {
		return WebAppsClientGetPremierAddOnSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetPremierAddOnSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetPremierAddOnSlotResponse{}, err
	}
	resp, err := client.getPremierAddOnSlotHandleResponse(httpResp)
	return resp, err
}

// getPremierAddOnSlotCreateRequest creates the GetPremierAddOnSlot request.
func (client *WebAppsClient) getPremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *WebAppsClientGetPremierAddOnSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPremierAddOnSlotHandleResponse handles the GetPremierAddOnSlot response.
func (client *WebAppsClient) getPremierAddOnSlotHandleResponse(resp *http.Response) (WebAppsClientGetPremierAddOnSlotResponse, error) {
	result := WebAppsClientGetPremierAddOnSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsClientGetPremierAddOnSlotResponse{}, err
	}
	return result, nil
}

// GetPrivateAccess - Description for Gets data around private site access enablement and authorized Virtual Networks that
// can access the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - options - WebAppsClientGetPrivateAccessOptions contains the optional parameters for the WebAppsClient.GetPrivateAccess
//     method.
func (client *WebAppsClient) GetPrivateAccess(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetPrivateAccessOptions) (WebAppsClientGetPrivateAccessResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetPrivateAccess"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getPrivateAccessCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetPrivateAccessResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetPrivateAccessResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetPrivateAccessResponse{}, err
	}
	resp, err := client.getPrivateAccessHandleResponse(httpResp)
	return resp, err
}

// getPrivateAccessCreateRequest creates the GetPrivateAccess request.
func (client *WebAppsClient) getPrivateAccessCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetPrivateAccessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPrivateAccessHandleResponse handles the GetPrivateAccess response.
func (client *WebAppsClient) getPrivateAccessHandleResponse(resp *http.Response) (WebAppsClientGetPrivateAccessResponse, error) {
	result := WebAppsClientGetPrivateAccessResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateAccess); err != nil {
		return WebAppsClientGetPrivateAccessResponse{}, err
	}
	return result, nil
}

// GetPrivateAccessSlot - Description for Gets data around private site access enablement and authorized Virtual Networks
// that can access the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - slot - The name of the slot for the web app.
//   - options - WebAppsClientGetPrivateAccessSlotOptions contains the optional parameters for the WebAppsClient.GetPrivateAccessSlot
//     method.
func (client *WebAppsClient) GetPrivateAccessSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetPrivateAccessSlotOptions) (WebAppsClientGetPrivateAccessSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetPrivateAccessSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getPrivateAccessSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetPrivateAccessSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetPrivateAccessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetPrivateAccessSlotResponse{}, err
	}
	resp, err := client.getPrivateAccessSlotHandleResponse(httpResp)
	return resp, err
}

// getPrivateAccessSlotCreateRequest creates the GetPrivateAccessSlot request.
func (client *WebAppsClient) getPrivateAccessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetPrivateAccessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPrivateAccessSlotHandleResponse handles the GetPrivateAccessSlot response.
func (client *WebAppsClient) getPrivateAccessSlotHandleResponse(resp *http.Response) (WebAppsClientGetPrivateAccessSlotResponse, error) {
	result := WebAppsClientGetPrivateAccessSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateAccess); err != nil {
		return WebAppsClientGetPrivateAccessSlotResponse{}, err
	}
	return result, nil
}

// GetPrivateEndpointConnection - Description for Gets a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the site.
//   - privateEndpointConnectionName - Name of the private endpoint connection.
//   - options - WebAppsClientGetPrivateEndpointConnectionOptions contains the optional parameters for the WebAppsClient.GetPrivateEndpointConnection
//     method.
func (client *WebAppsClient) GetPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsClientGetPrivateEndpointConnectionOptions) (WebAppsClientGetPrivateEndpointConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetPrivateEndpointConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getPrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return WebAppsClientGetPrivateEndpointConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetPrivateEndpointConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetPrivateEndpointConnectionResponse{}, err
	}
	resp, err := client.getPrivateEndpointConnectionHandleResponse(httpResp)
	return resp, err
}

// getPrivateEndpointConnectionCreateRequest creates the GetPrivateEndpointConnection request.
func (client *WebAppsClient) getPrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsClientGetPrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPrivateEndpointConnectionHandleResponse handles the GetPrivateEndpointConnection response.
func (client *WebAppsClient) getPrivateEndpointConnectionHandleResponse(resp *http.Response) (WebAppsClientGetPrivateEndpointConnectionResponse, error) {
	result := WebAppsClientGetPrivateEndpointConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemotePrivateEndpointConnectionARMResource); err != nil {
		return WebAppsClientGetPrivateEndpointConnectionResponse{}, err
	}
	return result, nil
}

// NewGetPrivateEndpointConnectionListPager - Description for Gets the list of private endpoint connections associated with
// a site
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the site.
//   - options - WebAppsClientGetPrivateEndpointConnectionListOptions contains the optional parameters for the WebAppsClient.NewGetPrivateEndpointConnectionListPager
//     method.
func (client *WebAppsClient) NewGetPrivateEndpointConnectionListPager(resourceGroupName string, name string, options *WebAppsClientGetPrivateEndpointConnectionListOptions) *runtime.Pager[WebAppsClientGetPrivateEndpointConnectionListResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientGetPrivateEndpointConnectionListResponse]{
		More: func(page WebAppsClientGetPrivateEndpointConnectionListResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientGetPrivateEndpointConnectionListResponse) (WebAppsClientGetPrivateEndpointConnectionListResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewGetPrivateEndpointConnectionListPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getPrivateEndpointConnectionListCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientGetPrivateEndpointConnectionListResponse{}, err
			}
			return client.getPrivateEndpointConnectionListHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getPrivateEndpointConnectionListCreateRequest creates the GetPrivateEndpointConnectionList request.
func (client *WebAppsClient) getPrivateEndpointConnectionListCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetPrivateEndpointConnectionListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPrivateEndpointConnectionListHandleResponse handles the GetPrivateEndpointConnectionList response.
func (client *WebAppsClient) getPrivateEndpointConnectionListHandleResponse(resp *http.Response) (WebAppsClientGetPrivateEndpointConnectionListResponse, error) {
	result := WebAppsClientGetPrivateEndpointConnectionListResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateEndpointConnectionCollection); err != nil {
		return WebAppsClientGetPrivateEndpointConnectionListResponse{}, err
	}
	return result, nil
}

// NewGetPrivateEndpointConnectionListSlotPager - Description for Gets the list of private endpoint connections associated
// with a site
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the site.
//   - slot - Name of the site deployment slot.
//   - options - WebAppsClientGetPrivateEndpointConnectionListSlotOptions contains the optional parameters for the WebAppsClient.NewGetPrivateEndpointConnectionListSlotPager
//     method.
func (client *WebAppsClient) NewGetPrivateEndpointConnectionListSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientGetPrivateEndpointConnectionListSlotOptions) *runtime.Pager[WebAppsClientGetPrivateEndpointConnectionListSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientGetPrivateEndpointConnectionListSlotResponse]{
		More: func(page WebAppsClientGetPrivateEndpointConnectionListSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientGetPrivateEndpointConnectionListSlotResponse) (WebAppsClientGetPrivateEndpointConnectionListSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewGetPrivateEndpointConnectionListSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getPrivateEndpointConnectionListSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientGetPrivateEndpointConnectionListSlotResponse{}, err
			}
			return client.getPrivateEndpointConnectionListSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getPrivateEndpointConnectionListSlotCreateRequest creates the GetPrivateEndpointConnectionListSlot request.
func (client *WebAppsClient) getPrivateEndpointConnectionListSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetPrivateEndpointConnectionListSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPrivateEndpointConnectionListSlotHandleResponse handles the GetPrivateEndpointConnectionListSlot response.
func (client *WebAppsClient) getPrivateEndpointConnectionListSlotHandleResponse(resp *http.Response) (WebAppsClientGetPrivateEndpointConnectionListSlotResponse, error) {
	result := WebAppsClientGetPrivateEndpointConnectionListSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateEndpointConnectionCollection); err != nil {
		return WebAppsClientGetPrivateEndpointConnectionListSlotResponse{}, err
	}
	return result, nil
}

// GetPrivateEndpointConnectionSlot - Description for Gets a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the site.
//   - privateEndpointConnectionName - Name of the private endpoint connection.
//   - slot - Name of the site deployment slot.
//   - options - WebAppsClientGetPrivateEndpointConnectionSlotOptions contains the optional parameters for the WebAppsClient.GetPrivateEndpointConnectionSlot
//     method.
func (client *WebAppsClient) GetPrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsClientGetPrivateEndpointConnectionSlotOptions) (WebAppsClientGetPrivateEndpointConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetPrivateEndpointConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getPrivateEndpointConnectionSlotCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, options)
	if err != nil {
		return WebAppsClientGetPrivateEndpointConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetPrivateEndpointConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetPrivateEndpointConnectionSlotResponse{}, err
	}
	resp, err := client.getPrivateEndpointConnectionSlotHandleResponse(httpResp)
	return resp, err
}

// getPrivateEndpointConnectionSlotCreateRequest creates the GetPrivateEndpointConnectionSlot request.
func (client *WebAppsClient) getPrivateEndpointConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsClientGetPrivateEndpointConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPrivateEndpointConnectionSlotHandleResponse handles the GetPrivateEndpointConnectionSlot response.
func (client *WebAppsClient) getPrivateEndpointConnectionSlotHandleResponse(resp *http.Response) (WebAppsClientGetPrivateEndpointConnectionSlotResponse, error) {
	result := WebAppsClientGetPrivateEndpointConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemotePrivateEndpointConnectionARMResource); err != nil {
		return WebAppsClientGetPrivateEndpointConnectionSlotResponse{}, err
	}
	return result, nil
}

// GetPrivateLinkResources - Description for Gets the private link resources
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the site.
//   - options - WebAppsClientGetPrivateLinkResourcesOptions contains the optional parameters for the WebAppsClient.GetPrivateLinkResources
//     method.
func (client *WebAppsClient) GetPrivateLinkResources(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetPrivateLinkResourcesOptions) (WebAppsClientGetPrivateLinkResourcesResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetPrivateLinkResources"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getPrivateLinkResourcesCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetPrivateLinkResourcesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetPrivateLinkResourcesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetPrivateLinkResourcesResponse{}, err
	}
	resp, err := client.getPrivateLinkResourcesHandleResponse(httpResp)
	return resp, err
}

// getPrivateLinkResourcesCreateRequest creates the GetPrivateLinkResources request.
func (client *WebAppsClient) getPrivateLinkResourcesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetPrivateLinkResourcesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateLinkResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPrivateLinkResourcesHandleResponse handles the GetPrivateLinkResources response.
func (client *WebAppsClient) getPrivateLinkResourcesHandleResponse(resp *http.Response) (WebAppsClientGetPrivateLinkResourcesResponse, error) {
	result := WebAppsClientGetPrivateLinkResourcesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateLinkResourcesWrapper); err != nil {
		return WebAppsClientGetPrivateLinkResourcesResponse{}, err
	}
	return result, nil
}

// GetPrivateLinkResourcesSlot - Description for Gets the private link resources
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the site.
//   - options - WebAppsClientGetPrivateLinkResourcesSlotOptions contains the optional parameters for the WebAppsClient.GetPrivateLinkResourcesSlot
//     method.
func (client *WebAppsClient) GetPrivateLinkResourcesSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetPrivateLinkResourcesSlotOptions) (WebAppsClientGetPrivateLinkResourcesSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetPrivateLinkResourcesSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getPrivateLinkResourcesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetPrivateLinkResourcesSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetPrivateLinkResourcesSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetPrivateLinkResourcesSlotResponse{}, err
	}
	resp, err := client.getPrivateLinkResourcesSlotHandleResponse(httpResp)
	return resp, err
}

// getPrivateLinkResourcesSlotCreateRequest creates the GetPrivateLinkResourcesSlot request.
func (client *WebAppsClient) getPrivateLinkResourcesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetPrivateLinkResourcesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateLinkResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPrivateLinkResourcesSlotHandleResponse handles the GetPrivateLinkResourcesSlot response.
func (client *WebAppsClient) getPrivateLinkResourcesSlotHandleResponse(resp *http.Response) (WebAppsClientGetPrivateLinkResourcesSlotResponse, error) {
	result := WebAppsClientGetPrivateLinkResourcesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateLinkResourcesWrapper); err != nil {
		return WebAppsClientGetPrivateLinkResourcesSlotResponse{}, err
	}
	return result, nil
}

// GetProcess - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - options - WebAppsClientGetProcessOptions contains the optional parameters for the WebAppsClient.GetProcess method.
func (client *WebAppsClient) GetProcess(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsClientGetProcessOptions) (WebAppsClientGetProcessResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetProcess"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getProcessCreateRequest(ctx, resourceGroupName, name, processID, options)
	if err != nil {
		return WebAppsClientGetProcessResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetProcessResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetProcessResponse{}, err
	}
	resp, err := client.getProcessHandleResponse(httpResp)
	return resp, err
}

// getProcessCreateRequest creates the GetProcess request.
func (client *WebAppsClient) getProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsClientGetProcessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getProcessHandleResponse handles the GetProcess response.
func (client *WebAppsClient) getProcessHandleResponse(resp *http.Response) (WebAppsClientGetProcessResponse, error) {
	result := WebAppsClientGetProcessResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfo); err != nil {
		return WebAppsClientGetProcessResponse{}, err
	}
	return result, nil
}

// GetProcessDump - Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - options - WebAppsClientGetProcessDumpOptions contains the optional parameters for the WebAppsClient.GetProcessDump method.
func (client *WebAppsClient) GetProcessDump(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsClientGetProcessDumpOptions) (WebAppsClientGetProcessDumpResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetProcessDump"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getProcessDumpCreateRequest(ctx, resourceGroupName, name, processID, options)
	if err != nil {
		return WebAppsClientGetProcessDumpResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetProcessDumpResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetProcessDumpResponse{}, err
	}
	return WebAppsClientGetProcessDumpResponse{Body: httpResp.Body}, nil
}

// getProcessDumpCreateRequest creates the GetProcessDump request.
func (client *WebAppsClient) getProcessDumpCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsClientGetProcessDumpOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetProcessDumpSlot - Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web
// site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - options - WebAppsClientGetProcessDumpSlotOptions contains the optional parameters for the WebAppsClient.GetProcessDumpSlot
//     method.
func (client *WebAppsClient) GetProcessDumpSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsClientGetProcessDumpSlotOptions) (WebAppsClientGetProcessDumpSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetProcessDumpSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getProcessDumpSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
	if err != nil {
		return WebAppsClientGetProcessDumpSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetProcessDumpSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetProcessDumpSlotResponse{}, err
	}
	return WebAppsClientGetProcessDumpSlotResponse{Body: httpResp.Body}, nil
}

// getProcessDumpSlotCreateRequest creates the GetProcessDumpSlot request.
func (client *WebAppsClient) getProcessDumpSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsClientGetProcessDumpSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetProcessModule - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - baseAddress - Module base address.
//   - options - WebAppsClientGetProcessModuleOptions contains the optional parameters for the WebAppsClient.GetProcessModule
//     method.
func (client *WebAppsClient) GetProcessModule(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, options *WebAppsClientGetProcessModuleOptions) (WebAppsClientGetProcessModuleResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetProcessModule"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getProcessModuleCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, options)
	if err != nil {
		return WebAppsClientGetProcessModuleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetProcessModuleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetProcessModuleResponse{}, err
	}
	resp, err := client.getProcessModuleHandleResponse(httpResp)
	return resp, err
}

// getProcessModuleCreateRequest creates the GetProcessModule request.
func (client *WebAppsClient) getProcessModuleCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, options *WebAppsClientGetProcessModuleOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getProcessModuleHandleResponse handles the GetProcessModule response.
func (client *WebAppsClient) getProcessModuleHandleResponse(resp *http.Response) (WebAppsClientGetProcessModuleResponse, error) {
	result := WebAppsClientGetProcessModuleResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfo); err != nil {
		return WebAppsClientGetProcessModuleResponse{}, err
	}
	return result, nil
}

// GetProcessModuleSlot - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - baseAddress - Module base address.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - options - WebAppsClientGetProcessModuleSlotOptions contains the optional parameters for the WebAppsClient.GetProcessModuleSlot
//     method.
func (client *WebAppsClient) GetProcessModuleSlot(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, options *WebAppsClientGetProcessModuleSlotOptions) (WebAppsClientGetProcessModuleSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetProcessModuleSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getProcessModuleSlotCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, slot, options)
	if err != nil {
		return WebAppsClientGetProcessModuleSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetProcessModuleSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetProcessModuleSlotResponse{}, err
	}
	resp, err := client.getProcessModuleSlotHandleResponse(httpResp)
	return resp, err
}

// getProcessModuleSlotCreateRequest creates the GetProcessModuleSlot request.
func (client *WebAppsClient) getProcessModuleSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, options *WebAppsClientGetProcessModuleSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getProcessModuleSlotHandleResponse handles the GetProcessModuleSlot response.
func (client *WebAppsClient) getProcessModuleSlotHandleResponse(resp *http.Response) (WebAppsClientGetProcessModuleSlotResponse, error) {
	result := WebAppsClientGetProcessModuleSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfo); err != nil {
		return WebAppsClientGetProcessModuleSlotResponse{}, err
	}
	return result, nil
}

// GetProcessSlot - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - options - WebAppsClientGetProcessSlotOptions contains the optional parameters for the WebAppsClient.GetProcessSlot method.
func (client *WebAppsClient) GetProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsClientGetProcessSlotOptions) (WebAppsClientGetProcessSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetProcessSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
	if err != nil {
		return WebAppsClientGetProcessSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetProcessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetProcessSlotResponse{}, err
	}
	resp, err := client.getProcessSlotHandleResponse(httpResp)
	return resp, err
}

// getProcessSlotCreateRequest creates the GetProcessSlot request.
func (client *WebAppsClient) getProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsClientGetProcessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getProcessSlotHandleResponse handles the GetProcessSlot response.
func (client *WebAppsClient) getProcessSlotHandleResponse(resp *http.Response) (WebAppsClientGetProcessSlotResponse, error) {
	result := WebAppsClientGetProcessSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfo); err != nil {
		return WebAppsClientGetProcessSlotResponse{}, err
	}
	return result, nil
}

// BeginGetProductionSiteDeploymentStatus - Gets the deployment status for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - deploymentStatusID - GUID of the deployment operation.
//   - options - WebAppsClientBeginGetProductionSiteDeploymentStatusOptions contains the optional parameters for the WebAppsClient.BeginGetProductionSiteDeploymentStatus
//     method.
func (client *WebAppsClient) BeginGetProductionSiteDeploymentStatus(ctx context.Context, resourceGroupName string, name string, deploymentStatusID string, options *WebAppsClientBeginGetProductionSiteDeploymentStatusOptions) (*runtime.Poller[WebAppsClientGetProductionSiteDeploymentStatusResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.getProductionSiteDeploymentStatus(ctx, resourceGroupName, name, deploymentStatusID, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientGetProductionSiteDeploymentStatusResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientGetProductionSiteDeploymentStatusResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// GetProductionSiteDeploymentStatus - Gets the deployment status for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) getProductionSiteDeploymentStatus(ctx context.Context, resourceGroupName string, name string, deploymentStatusID string, options *WebAppsClientBeginGetProductionSiteDeploymentStatusOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginGetProductionSiteDeploymentStatus"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getProductionSiteDeploymentStatusCreateRequest(ctx, resourceGroupName, name, deploymentStatusID, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// getProductionSiteDeploymentStatusCreateRequest creates the GetProductionSiteDeploymentStatus request.
func (client *WebAppsClient) getProductionSiteDeploymentStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, deploymentStatusID string, options *WebAppsClientBeginGetProductionSiteDeploymentStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deploymentStatus/{deploymentStatusId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if deploymentStatusID == "" {
		return nil, errors.New("parameter deploymentStatusID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStatusId}", url.PathEscape(deploymentStatusID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetPublicCertificate - Description for Get the named public certificate for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - publicCertificateName - Public certificate name.
//   - options - WebAppsClientGetPublicCertificateOptions contains the optional parameters for the WebAppsClient.GetPublicCertificate
//     method.
func (client *WebAppsClient) GetPublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *WebAppsClientGetPublicCertificateOptions) (WebAppsClientGetPublicCertificateResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetPublicCertificate"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getPublicCertificateCreateRequest(ctx, resourceGroupName, name, publicCertificateName, options)
	if err != nil {
		return WebAppsClientGetPublicCertificateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetPublicCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetPublicCertificateResponse{}, err
	}
	resp, err := client.getPublicCertificateHandleResponse(httpResp)
	return resp, err
}

// getPublicCertificateCreateRequest creates the GetPublicCertificate request.
func (client *WebAppsClient) getPublicCertificateCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *WebAppsClientGetPublicCertificateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPublicCertificateHandleResponse handles the GetPublicCertificate response.
func (client *WebAppsClient) getPublicCertificateHandleResponse(resp *http.Response) (WebAppsClientGetPublicCertificateResponse, error) {
	result := WebAppsClientGetPublicCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificate); err != nil {
		return WebAppsClientGetPublicCertificateResponse{}, err
	}
	return result, nil
}

// GetPublicCertificateSlot - Description for Get the named public certificate for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
//   - publicCertificateName - Public certificate name.
//   - options - WebAppsClientGetPublicCertificateSlotOptions contains the optional parameters for the WebAppsClient.GetPublicCertificateSlot
//     method.
func (client *WebAppsClient) GetPublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *WebAppsClientGetPublicCertificateSlotOptions) (WebAppsClientGetPublicCertificateSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetPublicCertificateSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getPublicCertificateSlotCreateRequest(ctx, resourceGroupName, name, slot, publicCertificateName, options)
	if err != nil {
		return WebAppsClientGetPublicCertificateSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetPublicCertificateSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetPublicCertificateSlotResponse{}, err
	}
	resp, err := client.getPublicCertificateSlotHandleResponse(httpResp)
	return resp, err
}

// getPublicCertificateSlotCreateRequest creates the GetPublicCertificateSlot request.
func (client *WebAppsClient) getPublicCertificateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *WebAppsClientGetPublicCertificateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPublicCertificateSlotHandleResponse handles the GetPublicCertificateSlot response.
func (client *WebAppsClient) getPublicCertificateSlotHandleResponse(resp *http.Response) (WebAppsClientGetPublicCertificateSlotResponse, error) {
	result := WebAppsClientGetPublicCertificateSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificate); err != nil {
		return WebAppsClientGetPublicCertificateSlotResponse{}, err
	}
	return result, nil
}

// GetRelayServiceConnection - Description for Gets a hybrid connection configuration by its name.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - entityName - Name of the hybrid connection.
//   - options - WebAppsClientGetRelayServiceConnectionOptions contains the optional parameters for the WebAppsClient.GetRelayServiceConnection
//     method.
func (client *WebAppsClient) GetRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, options *WebAppsClientGetRelayServiceConnectionOptions) (WebAppsClientGetRelayServiceConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetRelayServiceConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, options)
	if err != nil {
		return WebAppsClientGetRelayServiceConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetRelayServiceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetRelayServiceConnectionResponse{}, err
	}
	resp, err := client.getRelayServiceConnectionHandleResponse(httpResp)
	return resp, err
}

// getRelayServiceConnectionCreateRequest creates the GetRelayServiceConnection request.
func (client *WebAppsClient) getRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, options *WebAppsClientGetRelayServiceConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getRelayServiceConnectionHandleResponse handles the GetRelayServiceConnection response.
func (client *WebAppsClient) getRelayServiceConnectionHandleResponse(resp *http.Response) (WebAppsClientGetRelayServiceConnectionResponse, error) {
	result := WebAppsClientGetRelayServiceConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsClientGetRelayServiceConnectionResponse{}, err
	}
	return result, nil
}

// GetRelayServiceConnectionSlot - Description for Gets a hybrid connection configuration by its name.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - entityName - Name of the hybrid connection.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get a hybrid connection for the production
//     slot.
//   - options - WebAppsClientGetRelayServiceConnectionSlotOptions contains the optional parameters for the WebAppsClient.GetRelayServiceConnectionSlot
//     method.
func (client *WebAppsClient) GetRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *WebAppsClientGetRelayServiceConnectionSlotOptions) (WebAppsClientGetRelayServiceConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetRelayServiceConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, options)
	if err != nil {
		return WebAppsClientGetRelayServiceConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetRelayServiceConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetRelayServiceConnectionSlotResponse{}, err
	}
	resp, err := client.getRelayServiceConnectionSlotHandleResponse(httpResp)
	return resp, err
}

// getRelayServiceConnectionSlotCreateRequest creates the GetRelayServiceConnectionSlot request.
func (client *WebAppsClient) getRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *WebAppsClientGetRelayServiceConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getRelayServiceConnectionSlotHandleResponse handles the GetRelayServiceConnectionSlot response.
func (client *WebAppsClient) getRelayServiceConnectionSlotHandleResponse(resp *http.Response) (WebAppsClientGetRelayServiceConnectionSlotResponse, error) {
	result := WebAppsClientGetRelayServiceConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsClientGetRelayServiceConnectionSlotResponse{}, err
	}
	return result, nil
}

// GetScmAllowed - Description for Returns whether Scm basic auth is allowed on the site or not.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetScmAllowedOptions contains the optional parameters for the WebAppsClient.GetScmAllowed method.
func (client *WebAppsClient) GetScmAllowed(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetScmAllowedOptions) (WebAppsClientGetScmAllowedResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetScmAllowed"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getScmAllowedCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetScmAllowedResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetScmAllowedResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetScmAllowedResponse{}, err
	}
	resp, err := client.getScmAllowedHandleResponse(httpResp)
	return resp, err
}

// getScmAllowedCreateRequest creates the GetScmAllowed request.
func (client *WebAppsClient) getScmAllowedCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetScmAllowedOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/scm"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getScmAllowedHandleResponse handles the GetScmAllowed response.
func (client *WebAppsClient) getScmAllowedHandleResponse(resp *http.Response) (WebAppsClientGetScmAllowedResponse, error) {
	result := WebAppsClientGetScmAllowedResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsClientGetScmAllowedResponse{}, err
	}
	return result, nil
}

// GetScmAllowedSlot - Description for Returns whether Scm basic auth is allowed on the site or not.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetScmAllowedSlotOptions contains the optional parameters for the WebAppsClient.GetScmAllowedSlot
//     method.
func (client *WebAppsClient) GetScmAllowedSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetScmAllowedSlotOptions) (WebAppsClientGetScmAllowedSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetScmAllowedSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getScmAllowedSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetScmAllowedSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetScmAllowedSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetScmAllowedSlotResponse{}, err
	}
	resp, err := client.getScmAllowedSlotHandleResponse(httpResp)
	return resp, err
}

// getScmAllowedSlotCreateRequest creates the GetScmAllowedSlot request.
func (client *WebAppsClient) getScmAllowedSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetScmAllowedSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/scm"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getScmAllowedSlotHandleResponse handles the GetScmAllowedSlot response.
func (client *WebAppsClient) getScmAllowedSlotHandleResponse(resp *http.Response) (WebAppsClientGetScmAllowedSlotResponse, error) {
	result := WebAppsClientGetScmAllowedSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsClientGetScmAllowedSlotResponse{}, err
	}
	return result, nil
}

// GetSiteConnectionStringKeyVaultReference - Description for Gets the config reference and status of an app
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetSiteConnectionStringKeyVaultReferenceOptions contains the optional parameters for the WebAppsClient.GetSiteConnectionStringKeyVaultReference
//     method.
func (client *WebAppsClient) GetSiteConnectionStringKeyVaultReference(ctx context.Context, resourceGroupName string, name string, connectionStringKey string, options *WebAppsClientGetSiteConnectionStringKeyVaultReferenceOptions) (WebAppsClientGetSiteConnectionStringKeyVaultReferenceResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetSiteConnectionStringKeyVaultReference"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSiteConnectionStringKeyVaultReferenceCreateRequest(ctx, resourceGroupName, name, connectionStringKey, options)
	if err != nil {
		return WebAppsClientGetSiteConnectionStringKeyVaultReferenceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetSiteConnectionStringKeyVaultReferenceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetSiteConnectionStringKeyVaultReferenceResponse{}, err
	}
	resp, err := client.getSiteConnectionStringKeyVaultReferenceHandleResponse(httpResp)
	return resp, err
}

// getSiteConnectionStringKeyVaultReferenceCreateRequest creates the GetSiteConnectionStringKeyVaultReference request.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionStringKey string, options *WebAppsClientGetSiteConnectionStringKeyVaultReferenceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/connectionstrings/{connectionStringKey}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if connectionStringKey == "" {
		return nil, errors.New("parameter connectionStringKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionStringKey}", url.PathEscape(connectionStringKey))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSiteConnectionStringKeyVaultReferenceHandleResponse handles the GetSiteConnectionStringKeyVaultReference response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceHandleResponse(resp *http.Response) (WebAppsClientGetSiteConnectionStringKeyVaultReferenceResponse, error) {
	result := WebAppsClientGetSiteConnectionStringKeyVaultReferenceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReference); err != nil {
		return WebAppsClientGetSiteConnectionStringKeyVaultReferenceResponse{}, err
	}
	return result, nil
}

// GetSiteConnectionStringKeyVaultReferenceSlot - Description for Gets the config reference and status of an app
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetSiteConnectionStringKeyVaultReferenceSlotOptions contains the optional parameters for the WebAppsClient.GetSiteConnectionStringKeyVaultReferenceSlot
//     method.
func (client *WebAppsClient) GetSiteConnectionStringKeyVaultReferenceSlot(ctx context.Context, resourceGroupName string, name string, connectionStringKey string, slot string, options *WebAppsClientGetSiteConnectionStringKeyVaultReferenceSlotOptions) (WebAppsClientGetSiteConnectionStringKeyVaultReferenceSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetSiteConnectionStringKeyVaultReferenceSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSiteConnectionStringKeyVaultReferenceSlotCreateRequest(ctx, resourceGroupName, name, connectionStringKey, slot, options)
	if err != nil {
		return WebAppsClientGetSiteConnectionStringKeyVaultReferenceSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetSiteConnectionStringKeyVaultReferenceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetSiteConnectionStringKeyVaultReferenceSlotResponse{}, err
	}
	resp, err := client.getSiteConnectionStringKeyVaultReferenceSlotHandleResponse(httpResp)
	return resp, err
}

// getSiteConnectionStringKeyVaultReferenceSlotCreateRequest creates the GetSiteConnectionStringKeyVaultReferenceSlot request.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionStringKey string, slot string, options *WebAppsClientGetSiteConnectionStringKeyVaultReferenceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/connectionstrings/{connectionStringKey}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if connectionStringKey == "" {
		return nil, errors.New("parameter connectionStringKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionStringKey}", url.PathEscape(connectionStringKey))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSiteConnectionStringKeyVaultReferenceSlotHandleResponse handles the GetSiteConnectionStringKeyVaultReferenceSlot response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceSlotHandleResponse(resp *http.Response) (WebAppsClientGetSiteConnectionStringKeyVaultReferenceSlotResponse, error) {
	result := WebAppsClientGetSiteConnectionStringKeyVaultReferenceSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReference); err != nil {
		return WebAppsClientGetSiteConnectionStringKeyVaultReferenceSlotResponse{}, err
	}
	return result, nil
}

// NewGetSiteConnectionStringKeyVaultReferencesPager - Description for Gets the config reference app settings and status of
// an app
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetSiteConnectionStringKeyVaultReferencesOptions contains the optional parameters for the WebAppsClient.NewGetSiteConnectionStringKeyVaultReferencesPager
//     method.
func (client *WebAppsClient) NewGetSiteConnectionStringKeyVaultReferencesPager(resourceGroupName string, name string, options *WebAppsClientGetSiteConnectionStringKeyVaultReferencesOptions) *runtime.Pager[WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse]{
		More: func(page WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse) (WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewGetSiteConnectionStringKeyVaultReferencesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getSiteConnectionStringKeyVaultReferencesCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse{}, err
			}
			return client.getSiteConnectionStringKeyVaultReferencesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getSiteConnectionStringKeyVaultReferencesCreateRequest creates the GetSiteConnectionStringKeyVaultReferences request.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetSiteConnectionStringKeyVaultReferencesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSiteConnectionStringKeyVaultReferencesHandleResponse handles the GetSiteConnectionStringKeyVaultReferences response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesHandleResponse(resp *http.Response) (WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse, error) {
	result := WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReferenceCollection); err != nil {
		return WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse{}, err
	}
	return result, nil
}

// NewGetSiteConnectionStringKeyVaultReferencesSlotPager - Description for Gets the config reference app settings and status
// of an app
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotOptions contains the optional parameters for the WebAppsClient.NewGetSiteConnectionStringKeyVaultReferencesSlotPager
//     method.
func (client *WebAppsClient) NewGetSiteConnectionStringKeyVaultReferencesSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotOptions) *runtime.Pager[WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse]{
		More: func(page WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse) (WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewGetSiteConnectionStringKeyVaultReferencesSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getSiteConnectionStringKeyVaultReferencesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse{}, err
			}
			return client.getSiteConnectionStringKeyVaultReferencesSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getSiteConnectionStringKeyVaultReferencesSlotCreateRequest creates the GetSiteConnectionStringKeyVaultReferencesSlot request.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSiteConnectionStringKeyVaultReferencesSlotHandleResponse handles the GetSiteConnectionStringKeyVaultReferencesSlot response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesSlotHandleResponse(resp *http.Response) (WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse, error) {
	result := WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReferenceCollection); err != nil {
		return WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse{}, err
	}
	return result, nil
}

// GetSiteExtension - Description for Get site extension information by its ID for a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - siteExtensionID - Site extension name.
//   - options - WebAppsClientGetSiteExtensionOptions contains the optional parameters for the WebAppsClient.GetSiteExtension
//     method.
func (client *WebAppsClient) GetSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsClientGetSiteExtensionOptions) (WebAppsClientGetSiteExtensionResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetSiteExtension"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSiteExtensionCreateRequest(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return WebAppsClientGetSiteExtensionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetSiteExtensionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetSiteExtensionResponse{}, err
	}
	resp, err := client.getSiteExtensionHandleResponse(httpResp)
	return resp, err
}

// getSiteExtensionCreateRequest creates the GetSiteExtension request.
func (client *WebAppsClient) getSiteExtensionCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsClientGetSiteExtensionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSiteExtensionHandleResponse handles the GetSiteExtension response.
func (client *WebAppsClient) getSiteExtensionHandleResponse(resp *http.Response) (WebAppsClientGetSiteExtensionResponse, error) {
	result := WebAppsClientGetSiteExtensionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteExtensionInfo); err != nil {
		return WebAppsClientGetSiteExtensionResponse{}, err
	}
	return result, nil
}

// GetSiteExtensionSlot - Description for Get site extension information by its ID for a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - siteExtensionID - Site extension name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API uses the production slot.
//   - options - WebAppsClientGetSiteExtensionSlotOptions contains the optional parameters for the WebAppsClient.GetSiteExtensionSlot
//     method.
func (client *WebAppsClient) GetSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsClientGetSiteExtensionSlotOptions) (WebAppsClientGetSiteExtensionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetSiteExtensionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSiteExtensionSlotCreateRequest(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return WebAppsClientGetSiteExtensionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetSiteExtensionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetSiteExtensionSlotResponse{}, err
	}
	resp, err := client.getSiteExtensionSlotHandleResponse(httpResp)
	return resp, err
}

// getSiteExtensionSlotCreateRequest creates the GetSiteExtensionSlot request.
func (client *WebAppsClient) getSiteExtensionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsClientGetSiteExtensionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSiteExtensionSlotHandleResponse handles the GetSiteExtensionSlot response.
func (client *WebAppsClient) getSiteExtensionSlotHandleResponse(resp *http.Response) (WebAppsClientGetSiteExtensionSlotResponse, error) {
	result := WebAppsClientGetSiteExtensionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteExtensionInfo); err != nil {
		return WebAppsClientGetSiteExtensionSlotResponse{}, err
	}
	return result, nil
}

// GetSitePhpErrorLogFlag - Description for Gets web app's event logs.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientGetSitePhpErrorLogFlagOptions contains the optional parameters for the WebAppsClient.GetSitePhpErrorLogFlag
//     method.
func (client *WebAppsClient) GetSitePhpErrorLogFlag(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetSitePhpErrorLogFlagOptions) (WebAppsClientGetSitePhpErrorLogFlagResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetSitePhpErrorLogFlag"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSitePhpErrorLogFlagCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetSitePhpErrorLogFlagResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetSitePhpErrorLogFlagResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetSitePhpErrorLogFlagResponse{}, err
	}
	resp, err := client.getSitePhpErrorLogFlagHandleResponse(httpResp)
	return resp, err
}

// getSitePhpErrorLogFlagCreateRequest creates the GetSitePhpErrorLogFlag request.
func (client *WebAppsClient) getSitePhpErrorLogFlagCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetSitePhpErrorLogFlagOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/phplogging"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSitePhpErrorLogFlagHandleResponse handles the GetSitePhpErrorLogFlag response.
func (client *WebAppsClient) getSitePhpErrorLogFlagHandleResponse(resp *http.Response) (WebAppsClientGetSitePhpErrorLogFlagResponse, error) {
	result := WebAppsClientGetSitePhpErrorLogFlagResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SitePhpErrorLogFlag); err != nil {
		return WebAppsClientGetSitePhpErrorLogFlagResponse{}, err
	}
	return result, nil
}

// GetSitePhpErrorLogFlagSlot - Description for Gets web app's event logs.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - options - WebAppsClientGetSitePhpErrorLogFlagSlotOptions contains the optional parameters for the WebAppsClient.GetSitePhpErrorLogFlagSlot
//     method.
func (client *WebAppsClient) GetSitePhpErrorLogFlagSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetSitePhpErrorLogFlagSlotOptions) (WebAppsClientGetSitePhpErrorLogFlagSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetSitePhpErrorLogFlagSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSitePhpErrorLogFlagSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetSitePhpErrorLogFlagSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetSitePhpErrorLogFlagSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetSitePhpErrorLogFlagSlotResponse{}, err
	}
	resp, err := client.getSitePhpErrorLogFlagSlotHandleResponse(httpResp)
	return resp, err
}

// getSitePhpErrorLogFlagSlotCreateRequest creates the GetSitePhpErrorLogFlagSlot request.
func (client *WebAppsClient) getSitePhpErrorLogFlagSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetSitePhpErrorLogFlagSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/phplogging"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSitePhpErrorLogFlagSlotHandleResponse handles the GetSitePhpErrorLogFlagSlot response.
func (client *WebAppsClient) getSitePhpErrorLogFlagSlotHandleResponse(resp *http.Response) (WebAppsClientGetSitePhpErrorLogFlagSlotResponse, error) {
	result := WebAppsClientGetSitePhpErrorLogFlagSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SitePhpErrorLogFlag); err != nil {
		return WebAppsClientGetSitePhpErrorLogFlagSlotResponse{}, err
	}
	return result, nil
}

// GetSlot - Description for Gets the details of a web, mobile, or API app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. By default, this API returns the production slot.
//   - options - WebAppsClientGetSlotOptions contains the optional parameters for the WebAppsClient.GetSlot method.
func (client *WebAppsClient) GetSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetSlotOptions) (WebAppsClientGetSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetSlotResponse{}, err
	}
	resp, err := client.getSlotHandleResponse(httpResp)
	return resp, err
}

// getSlotCreateRequest creates the GetSlot request.
func (client *WebAppsClient) getSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSlotHandleResponse handles the GetSlot response.
func (client *WebAppsClient) getSlotHandleResponse(resp *http.Response) (WebAppsClientGetSlotResponse, error) {
	result := WebAppsClientGetSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Site); err != nil {
		return WebAppsClientGetSlotResponse{}, err
	}
	return result, nil
}

// BeginGetSlotSiteDeploymentStatusSlot - Gets the deployment status for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the deployment status for the production
//     slot.
//   - deploymentStatusID - GUID of the deployment operation.
//   - options - WebAppsClientBeginGetSlotSiteDeploymentStatusSlotOptions contains the optional parameters for the WebAppsClient.BeginGetSlotSiteDeploymentStatusSlot
//     method.
func (client *WebAppsClient) BeginGetSlotSiteDeploymentStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, deploymentStatusID string, options *WebAppsClientBeginGetSlotSiteDeploymentStatusSlotOptions) (*runtime.Poller[WebAppsClientGetSlotSiteDeploymentStatusSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.getSlotSiteDeploymentStatusSlot(ctx, resourceGroupName, name, slot, deploymentStatusID, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientGetSlotSiteDeploymentStatusSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientGetSlotSiteDeploymentStatusSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// GetSlotSiteDeploymentStatusSlot - Gets the deployment status for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) getSlotSiteDeploymentStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, deploymentStatusID string, options *WebAppsClientBeginGetSlotSiteDeploymentStatusSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginGetSlotSiteDeploymentStatusSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSlotSiteDeploymentStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, deploymentStatusID, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// getSlotSiteDeploymentStatusSlotCreateRequest creates the GetSlotSiteDeploymentStatusSlot request.
func (client *WebAppsClient) getSlotSiteDeploymentStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, deploymentStatusID string, options *WebAppsClientBeginGetSlotSiteDeploymentStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deploymentStatus/{deploymentStatusId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if deploymentStatusID == "" {
		return nil, errors.New("parameter deploymentStatusID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStatusId}", url.PathEscape(deploymentStatusID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetSourceControl - Description for Gets the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetSourceControlOptions contains the optional parameters for the WebAppsClient.GetSourceControl
//     method.
func (client *WebAppsClient) GetSourceControl(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetSourceControlOptions) (WebAppsClientGetSourceControlResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetSourceControl"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSourceControlCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetSourceControlResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetSourceControlResponse{}, err
	}
	resp, err := client.getSourceControlHandleResponse(httpResp)
	return resp, err
}

// getSourceControlCreateRequest creates the GetSourceControl request.
func (client *WebAppsClient) getSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetSourceControlOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSourceControlHandleResponse handles the GetSourceControl response.
func (client *WebAppsClient) getSourceControlHandleResponse(resp *http.Response) (WebAppsClientGetSourceControlResponse, error) {
	result := WebAppsClientGetSourceControlResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteSourceControl); err != nil {
		return WebAppsClientGetSourceControlResponse{}, err
	}
	return result, nil
}

// GetSourceControlSlot - Description for Gets the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the source control configuration for the
//     production slot.
//   - options - WebAppsClientGetSourceControlSlotOptions contains the optional parameters for the WebAppsClient.GetSourceControlSlot
//     method.
func (client *WebAppsClient) GetSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetSourceControlSlotOptions) (WebAppsClientGetSourceControlSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetSourceControlSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetSourceControlSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetSourceControlSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetSourceControlSlotResponse{}, err
	}
	resp, err := client.getSourceControlSlotHandleResponse(httpResp)
	return resp, err
}

// getSourceControlSlotCreateRequest creates the GetSourceControlSlot request.
func (client *WebAppsClient) getSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetSourceControlSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSourceControlSlotHandleResponse handles the GetSourceControlSlot response.
func (client *WebAppsClient) getSourceControlSlotHandleResponse(resp *http.Response) (WebAppsClientGetSourceControlSlotResponse, error) {
	result := WebAppsClientGetSourceControlSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteSourceControl); err != nil {
		return WebAppsClientGetSourceControlSlotResponse{}, err
	}
	return result, nil
}

// GetSwiftVirtualNetworkConnection - Description for Gets a Swift Virtual Network connection.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientGetSwiftVirtualNetworkConnectionOptions contains the optional parameters for the WebAppsClient.GetSwiftVirtualNetworkConnection
//     method.
func (client *WebAppsClient) GetSwiftVirtualNetworkConnection(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetSwiftVirtualNetworkConnectionOptions) (WebAppsClientGetSwiftVirtualNetworkConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetSwiftVirtualNetworkConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSwiftVirtualNetworkConnectionCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetSwiftVirtualNetworkConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetSwiftVirtualNetworkConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetSwiftVirtualNetworkConnectionResponse{}, err
	}
	resp, err := client.getSwiftVirtualNetworkConnectionHandleResponse(httpResp)
	return resp, err
}

// getSwiftVirtualNetworkConnectionCreateRequest creates the GetSwiftVirtualNetworkConnection request.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetSwiftVirtualNetworkConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSwiftVirtualNetworkConnectionHandleResponse handles the GetSwiftVirtualNetworkConnection response.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionHandleResponse(resp *http.Response) (WebAppsClientGetSwiftVirtualNetworkConnectionResponse, error) {
	result := WebAppsClientGetSwiftVirtualNetworkConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return WebAppsClientGetSwiftVirtualNetworkConnectionResponse{}, err
	}
	return result, nil
}

// GetSwiftVirtualNetworkConnectionSlot - Description for Gets a Swift Virtual Network connection.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get a gateway for the production slot's Virtual
//     Network.
//   - options - WebAppsClientGetSwiftVirtualNetworkConnectionSlotOptions contains the optional parameters for the WebAppsClient.GetSwiftVirtualNetworkConnectionSlot
//     method.
func (client *WebAppsClient) GetSwiftVirtualNetworkConnectionSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetSwiftVirtualNetworkConnectionSlotOptions) (WebAppsClientGetSwiftVirtualNetworkConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetSwiftVirtualNetworkConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSwiftVirtualNetworkConnectionSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	resp, err := client.getSwiftVirtualNetworkConnectionSlotHandleResponse(httpResp)
	return resp, err
}

// getSwiftVirtualNetworkConnectionSlotCreateRequest creates the GetSwiftVirtualNetworkConnectionSlot request.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetSwiftVirtualNetworkConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSwiftVirtualNetworkConnectionSlotHandleResponse handles the GetSwiftVirtualNetworkConnectionSlot response.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionSlotHandleResponse(resp *http.Response) (WebAppsClientGetSwiftVirtualNetworkConnectionSlotResponse, error) {
	result := WebAppsClientGetSwiftVirtualNetworkConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return WebAppsClientGetSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	return result, nil
}

// GetTriggeredWebJob - Description for Gets a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - options - WebAppsClientGetTriggeredWebJobOptions contains the optional parameters for the WebAppsClient.GetTriggeredWebJob
//     method.
func (client *WebAppsClient) GetTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientGetTriggeredWebJobOptions) (WebAppsClientGetTriggeredWebJobResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetTriggeredWebJob"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getTriggeredWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsClientGetTriggeredWebJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetTriggeredWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetTriggeredWebJobResponse{}, err
	}
	resp, err := client.getTriggeredWebJobHandleResponse(httpResp)
	return resp, err
}

// getTriggeredWebJobCreateRequest creates the GetTriggeredWebJob request.
func (client *WebAppsClient) getTriggeredWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientGetTriggeredWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTriggeredWebJobHandleResponse handles the GetTriggeredWebJob response.
func (client *WebAppsClient) getTriggeredWebJobHandleResponse(resp *http.Response) (WebAppsClientGetTriggeredWebJobResponse, error) {
	result := WebAppsClientGetTriggeredWebJobResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredWebJob); err != nil {
		return WebAppsClientGetTriggeredWebJobResponse{}, err
	}
	return result, nil
}

// GetTriggeredWebJobHistory - Description for Gets a triggered web job's history by its ID for an app, , or a deployment
// slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - id - History ID.
//   - options - WebAppsClientGetTriggeredWebJobHistoryOptions contains the optional parameters for the WebAppsClient.GetTriggeredWebJobHistory
//     method.
func (client *WebAppsClient) GetTriggeredWebJobHistory(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, options *WebAppsClientGetTriggeredWebJobHistoryOptions) (WebAppsClientGetTriggeredWebJobHistoryResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetTriggeredWebJobHistory"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getTriggeredWebJobHistoryCreateRequest(ctx, resourceGroupName, name, webJobName, id, options)
	if err != nil {
		return WebAppsClientGetTriggeredWebJobHistoryResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetTriggeredWebJobHistoryResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetTriggeredWebJobHistoryResponse{}, err
	}
	resp, err := client.getTriggeredWebJobHistoryHandleResponse(httpResp)
	return resp, err
}

// getTriggeredWebJobHistoryCreateRequest creates the GetTriggeredWebJobHistory request.
func (client *WebAppsClient) getTriggeredWebJobHistoryCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, options *WebAppsClientGetTriggeredWebJobHistoryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTriggeredWebJobHistoryHandleResponse handles the GetTriggeredWebJobHistory response.
func (client *WebAppsClient) getTriggeredWebJobHistoryHandleResponse(resp *http.Response) (WebAppsClientGetTriggeredWebJobHistoryResponse, error) {
	result := WebAppsClientGetTriggeredWebJobHistoryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredJobHistory); err != nil {
		return WebAppsClientGetTriggeredWebJobHistoryResponse{}, err
	}
	return result, nil
}

// GetTriggeredWebJobHistorySlot - Description for Gets a triggered web job's history by its ID for an app, , or a deployment
// slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - id - History ID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API uses the production slot.
//   - options - WebAppsClientGetTriggeredWebJobHistorySlotOptions contains the optional parameters for the WebAppsClient.GetTriggeredWebJobHistorySlot
//     method.
func (client *WebAppsClient) GetTriggeredWebJobHistorySlot(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, slot string, options *WebAppsClientGetTriggeredWebJobHistorySlotOptions) (WebAppsClientGetTriggeredWebJobHistorySlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetTriggeredWebJobHistorySlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getTriggeredWebJobHistorySlotCreateRequest(ctx, resourceGroupName, name, webJobName, id, slot, options)
	if err != nil {
		return WebAppsClientGetTriggeredWebJobHistorySlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetTriggeredWebJobHistorySlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetTriggeredWebJobHistorySlotResponse{}, err
	}
	resp, err := client.getTriggeredWebJobHistorySlotHandleResponse(httpResp)
	return resp, err
}

// getTriggeredWebJobHistorySlotCreateRequest creates the GetTriggeredWebJobHistorySlot request.
func (client *WebAppsClient) getTriggeredWebJobHistorySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, slot string, options *WebAppsClientGetTriggeredWebJobHistorySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTriggeredWebJobHistorySlotHandleResponse handles the GetTriggeredWebJobHistorySlot response.
func (client *WebAppsClient) getTriggeredWebJobHistorySlotHandleResponse(resp *http.Response) (WebAppsClientGetTriggeredWebJobHistorySlotResponse, error) {
	result := WebAppsClientGetTriggeredWebJobHistorySlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredJobHistory); err != nil {
		return WebAppsClientGetTriggeredWebJobHistorySlotResponse{}, err
	}
	return result, nil
}

// GetTriggeredWebJobSlot - Description for Gets a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - slot - Name of the deployment slot. If a slot is not specified, the API uses the production slot.
//   - options - WebAppsClientGetTriggeredWebJobSlotOptions contains the optional parameters for the WebAppsClient.GetTriggeredWebJobSlot
//     method.
func (client *WebAppsClient) GetTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientGetTriggeredWebJobSlotOptions) (WebAppsClientGetTriggeredWebJobSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetTriggeredWebJobSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getTriggeredWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsClientGetTriggeredWebJobSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetTriggeredWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetTriggeredWebJobSlotResponse{}, err
	}
	resp, err := client.getTriggeredWebJobSlotHandleResponse(httpResp)
	return resp, err
}

// getTriggeredWebJobSlotCreateRequest creates the GetTriggeredWebJobSlot request.
func (client *WebAppsClient) getTriggeredWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientGetTriggeredWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTriggeredWebJobSlotHandleResponse handles the GetTriggeredWebJobSlot response.
func (client *WebAppsClient) getTriggeredWebJobSlotHandleResponse(resp *http.Response) (WebAppsClientGetTriggeredWebJobSlotResponse, error) {
	result := WebAppsClientGetTriggeredWebJobSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredWebJob); err != nil {
		return WebAppsClientGetTriggeredWebJobSlotResponse{}, err
	}
	return result, nil
}

// GetVnetConnection - Description for Gets a virtual network the app (or deployment slot) is connected to by name.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of the virtual network.
//   - options - WebAppsClientGetVnetConnectionOptions contains the optional parameters for the WebAppsClient.GetVnetConnection
//     method.
func (client *WebAppsClient) GetVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, options *WebAppsClientGetVnetConnectionOptions) (WebAppsClientGetVnetConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetVnetConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, options)
	if err != nil {
		return WebAppsClientGetVnetConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetVnetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetVnetConnectionResponse{}, err
	}
	resp, err := client.getVnetConnectionHandleResponse(httpResp)
	return resp, err
}

// getVnetConnectionCreateRequest creates the GetVnetConnection request.
func (client *WebAppsClient) getVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, options *WebAppsClientGetVnetConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVnetConnectionHandleResponse handles the GetVnetConnection response.
func (client *WebAppsClient) getVnetConnectionHandleResponse(resp *http.Response) (WebAppsClientGetVnetConnectionResponse, error) {
	result := WebAppsClientGetVnetConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResource); err != nil {
		return WebAppsClientGetVnetConnectionResponse{}, err
	}
	return result, nil
}

// GetVnetConnectionGateway - Description for Gets an app's Virtual Network gateway.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of the Virtual Network.
//   - gatewayName - Name of the gateway. Currently, the only supported string is "primary".
//   - options - WebAppsClientGetVnetConnectionGatewayOptions contains the optional parameters for the WebAppsClient.GetVnetConnectionGateway
//     method.
func (client *WebAppsClient) GetVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, options *WebAppsClientGetVnetConnectionGatewayOptions) (WebAppsClientGetVnetConnectionGatewayResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetVnetConnectionGateway"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getVnetConnectionGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, options)
	if err != nil {
		return WebAppsClientGetVnetConnectionGatewayResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetVnetConnectionGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetVnetConnectionGatewayResponse{}, err
	}
	resp, err := client.getVnetConnectionGatewayHandleResponse(httpResp)
	return resp, err
}

// getVnetConnectionGatewayCreateRequest creates the GetVnetConnectionGateway request.
func (client *WebAppsClient) getVnetConnectionGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, options *WebAppsClientGetVnetConnectionGatewayOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVnetConnectionGatewayHandleResponse handles the GetVnetConnectionGateway response.
func (client *WebAppsClient) getVnetConnectionGatewayHandleResponse(resp *http.Response) (WebAppsClientGetVnetConnectionGatewayResponse, error) {
	result := WebAppsClientGetVnetConnectionGatewayResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return WebAppsClientGetVnetConnectionGatewayResponse{}, err
	}
	return result, nil
}

// GetVnetConnectionGatewaySlot - Description for Gets an app's Virtual Network gateway.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of the Virtual Network.
//   - gatewayName - Name of the gateway. Currently, the only supported string is "primary".
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get a gateway for the production slot's Virtual
//     Network.
//   - options - WebAppsClientGetVnetConnectionGatewaySlotOptions contains the optional parameters for the WebAppsClient.GetVnetConnectionGatewaySlot
//     method.
func (client *WebAppsClient) GetVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, options *WebAppsClientGetVnetConnectionGatewaySlotOptions) (WebAppsClientGetVnetConnectionGatewaySlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetVnetConnectionGatewaySlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getVnetConnectionGatewaySlotCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, slot, options)
	if err != nil {
		return WebAppsClientGetVnetConnectionGatewaySlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetVnetConnectionGatewaySlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetVnetConnectionGatewaySlotResponse{}, err
	}
	resp, err := client.getVnetConnectionGatewaySlotHandleResponse(httpResp)
	return resp, err
}

// getVnetConnectionGatewaySlotCreateRequest creates the GetVnetConnectionGatewaySlot request.
func (client *WebAppsClient) getVnetConnectionGatewaySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, options *WebAppsClientGetVnetConnectionGatewaySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVnetConnectionGatewaySlotHandleResponse handles the GetVnetConnectionGatewaySlot response.
func (client *WebAppsClient) getVnetConnectionGatewaySlotHandleResponse(resp *http.Response) (WebAppsClientGetVnetConnectionGatewaySlotResponse, error) {
	result := WebAppsClientGetVnetConnectionGatewaySlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return WebAppsClientGetVnetConnectionGatewaySlotResponse{}, err
	}
	return result, nil
}

// GetVnetConnectionSlot - Description for Gets a virtual network the app (or deployment slot) is connected to by name.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of the virtual network.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the named virtual network for the production
//     slot.
//   - options - WebAppsClientGetVnetConnectionSlotOptions contains the optional parameters for the WebAppsClient.GetVnetConnectionSlot
//     method.
func (client *WebAppsClient) GetVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *WebAppsClientGetVnetConnectionSlotOptions) (WebAppsClientGetVnetConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetVnetConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, options)
	if err != nil {
		return WebAppsClientGetVnetConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetVnetConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetVnetConnectionSlotResponse{}, err
	}
	resp, err := client.getVnetConnectionSlotHandleResponse(httpResp)
	return resp, err
}

// getVnetConnectionSlotCreateRequest creates the GetVnetConnectionSlot request.
func (client *WebAppsClient) getVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *WebAppsClientGetVnetConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getVnetConnectionSlotHandleResponse handles the GetVnetConnectionSlot response.
func (client *WebAppsClient) getVnetConnectionSlotHandleResponse(resp *http.Response) (WebAppsClientGetVnetConnectionSlotResponse, error) {
	result := WebAppsClientGetVnetConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResource); err != nil {
		return WebAppsClientGetVnetConnectionSlotResponse{}, err
	}
	return result, nil
}

// GetWebJob - Description for Get webjob information for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of the web job.
//   - options - WebAppsClientGetWebJobOptions contains the optional parameters for the WebAppsClient.GetWebJob method.
func (client *WebAppsClient) GetWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientGetWebJobOptions) (WebAppsClientGetWebJobResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetWebJob"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsClientGetWebJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetWebJobResponse{}, err
	}
	resp, err := client.getWebJobHandleResponse(httpResp)
	return resp, err
}

// getWebJobCreateRequest creates the GetWebJob request.
func (client *WebAppsClient) getWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientGetWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getWebJobHandleResponse handles the GetWebJob response.
func (client *WebAppsClient) getWebJobHandleResponse(resp *http.Response) (WebAppsClientGetWebJobResponse, error) {
	result := WebAppsClientGetWebJobResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebJob); err != nil {
		return WebAppsClientGetWebJobResponse{}, err
	}
	return result, nil
}

// GetWebJobSlot - Description for Get webjob information for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of the web job.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - options - WebAppsClientGetWebJobSlotOptions contains the optional parameters for the WebAppsClient.GetWebJobSlot method.
func (client *WebAppsClient) GetWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientGetWebJobSlotOptions) (WebAppsClientGetWebJobSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetWebJobSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsClientGetWebJobSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetWebJobSlotResponse{}, err
	}
	resp, err := client.getWebJobSlotHandleResponse(httpResp)
	return resp, err
}

// getWebJobSlotCreateRequest creates the GetWebJobSlot request.
func (client *WebAppsClient) getWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientGetWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getWebJobSlotHandleResponse handles the GetWebJobSlot response.
func (client *WebAppsClient) getWebJobSlotHandleResponse(resp *http.Response) (WebAppsClientGetWebJobSlotResponse, error) {
	result := WebAppsClientGetWebJobSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebJob); err != nil {
		return WebAppsClientGetWebJobSlotResponse{}, err
	}
	return result, nil
}

// GetWebSiteContainerLogs - Description for Gets the last lines of docker logs for the given site
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientGetWebSiteContainerLogsOptions contains the optional parameters for the WebAppsClient.GetWebSiteContainerLogs
//     method.
func (client *WebAppsClient) GetWebSiteContainerLogs(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetWebSiteContainerLogsOptions) (WebAppsClientGetWebSiteContainerLogsResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetWebSiteContainerLogs"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getWebSiteContainerLogsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientGetWebSiteContainerLogsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetWebSiteContainerLogsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetWebSiteContainerLogsResponse{}, err
	}
	return WebAppsClientGetWebSiteContainerLogsResponse{Body: httpResp.Body}, nil
}

// getWebSiteContainerLogsCreateRequest creates the GetWebSiteContainerLogs request.
func (client *WebAppsClient) getWebSiteContainerLogsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientGetWebSiteContainerLogsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/octet-stream"}
	return req, nil
}

// GetWebSiteContainerLogsSlot - Description for Gets the last lines of docker logs for the given site
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - options - WebAppsClientGetWebSiteContainerLogsSlotOptions contains the optional parameters for the WebAppsClient.GetWebSiteContainerLogsSlot
//     method.
func (client *WebAppsClient) GetWebSiteContainerLogsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetWebSiteContainerLogsSlotOptions) (WebAppsClientGetWebSiteContainerLogsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetWebSiteContainerLogsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getWebSiteContainerLogsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientGetWebSiteContainerLogsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetWebSiteContainerLogsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetWebSiteContainerLogsSlotResponse{}, err
	}
	return WebAppsClientGetWebSiteContainerLogsSlotResponse{Body: httpResp.Body}, nil
}

// getWebSiteContainerLogsSlotCreateRequest creates the GetWebSiteContainerLogsSlot request.
func (client *WebAppsClient) getWebSiteContainerLogsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientGetWebSiteContainerLogsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/octet-stream"}
	return req, nil
}

// GetWorkflow - Get workflow information by its ID for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - workflowName - Workflow name.
//   - options - WebAppsClientGetWorkflowOptions contains the optional parameters for the WebAppsClient.GetWorkflow method.
func (client *WebAppsClient) GetWorkflow(ctx context.Context, resourceGroupName string, name string, workflowName string, options *WebAppsClientGetWorkflowOptions) (WebAppsClientGetWorkflowResponse, error) {
	var err error
	const operationName = "WebAppsClient.GetWorkflow"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getWorkflowCreateRequest(ctx, resourceGroupName, name, workflowName, options)
	if err != nil {
		return WebAppsClientGetWorkflowResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientGetWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientGetWorkflowResponse{}, err
	}
	resp, err := client.getWorkflowHandleResponse(httpResp)
	return resp, err
}

// getWorkflowCreateRequest creates the GetWorkflow request.
func (client *WebAppsClient) getWorkflowCreateRequest(ctx context.Context, resourceGroupName string, name string, workflowName string, options *WebAppsClientGetWorkflowOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/workflows/{workflowName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workflowName == "" {
		return nil, errors.New("parameter workflowName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workflowName}", url.PathEscape(workflowName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getWorkflowHandleResponse handles the GetWorkflow response.
func (client *WebAppsClient) getWorkflowHandleResponse(resp *http.Response) (WebAppsClientGetWorkflowResponse, error) {
	result := WebAppsClientGetWorkflowResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkflowEnvelope); err != nil {
		return WebAppsClientGetWorkflowResponse{}, err
	}
	return result, nil
}

// BeginInstallSiteExtension - Description for Install site extension on a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - siteExtensionID - Site extension name.
//   - options - WebAppsClientBeginInstallSiteExtensionOptions contains the optional parameters for the WebAppsClient.BeginInstallSiteExtension
//     method.
func (client *WebAppsClient) BeginInstallSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsClientBeginInstallSiteExtensionOptions) (*runtime.Poller[WebAppsClientInstallSiteExtensionResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.installSiteExtension(ctx, resourceGroupName, name, siteExtensionID, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientInstallSiteExtensionResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientInstallSiteExtensionResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// InstallSiteExtension - Description for Install site extension on a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) installSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsClientBeginInstallSiteExtensionOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginInstallSiteExtension"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.installSiteExtensionCreateRequest(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// installSiteExtensionCreateRequest creates the InstallSiteExtension request.
func (client *WebAppsClient) installSiteExtensionCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsClientBeginInstallSiteExtensionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginInstallSiteExtensionSlot - Description for Install site extension on a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - siteExtensionID - Site extension name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API uses the production slot.
//   - options - WebAppsClientBeginInstallSiteExtensionSlotOptions contains the optional parameters for the WebAppsClient.BeginInstallSiteExtensionSlot
//     method.
func (client *WebAppsClient) BeginInstallSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsClientBeginInstallSiteExtensionSlotOptions) (*runtime.Poller[WebAppsClientInstallSiteExtensionSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.installSiteExtensionSlot(ctx, resourceGroupName, name, siteExtensionID, slot, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientInstallSiteExtensionSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientInstallSiteExtensionSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// InstallSiteExtensionSlot - Description for Install site extension on a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) installSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsClientBeginInstallSiteExtensionSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginInstallSiteExtensionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.installSiteExtensionSlotCreateRequest(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// installSiteExtensionSlotCreateRequest creates the InstallSiteExtensionSlot request.
func (client *WebAppsClient) installSiteExtensionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsClientBeginInstallSiteExtensionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// IsCloneable - Description for Shows whether an app can be cloned to another resource group or subscription.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientIsCloneableOptions contains the optional parameters for the WebAppsClient.IsCloneable method.
func (client *WebAppsClient) IsCloneable(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientIsCloneableOptions) (WebAppsClientIsCloneableResponse, error) {
	var err error
	const operationName = "WebAppsClient.IsCloneable"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.isCloneableCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientIsCloneableResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientIsCloneableResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientIsCloneableResponse{}, err
	}
	resp, err := client.isCloneableHandleResponse(httpResp)
	return resp, err
}

// isCloneableCreateRequest creates the IsCloneable request.
func (client *WebAppsClient) isCloneableCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientIsCloneableOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// isCloneableHandleResponse handles the IsCloneable response.
func (client *WebAppsClient) isCloneableHandleResponse(resp *http.Response) (WebAppsClientIsCloneableResponse, error) {
	result := WebAppsClientIsCloneableResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteCloneability); err != nil {
		return WebAppsClientIsCloneableResponse{}, err
	}
	return result, nil
}

// IsCloneableSlot - Description for Shows whether an app can be cloned to another resource group or subscription.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. By default, this API returns information on the production slot.
//   - options - WebAppsClientIsCloneableSlotOptions contains the optional parameters for the WebAppsClient.IsCloneableSlot method.
func (client *WebAppsClient) IsCloneableSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientIsCloneableSlotOptions) (WebAppsClientIsCloneableSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.IsCloneableSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.isCloneableSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientIsCloneableSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientIsCloneableSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientIsCloneableSlotResponse{}, err
	}
	resp, err := client.isCloneableSlotHandleResponse(httpResp)
	return resp, err
}

// isCloneableSlotCreateRequest creates the IsCloneableSlot request.
func (client *WebAppsClient) isCloneableSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientIsCloneableSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// isCloneableSlotHandleResponse handles the IsCloneableSlot response.
func (client *WebAppsClient) isCloneableSlotHandleResponse(resp *http.Response) (WebAppsClientIsCloneableSlotResponse, error) {
	result := WebAppsClientIsCloneableSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteCloneability); err != nil {
		return WebAppsClientIsCloneableSlotResponse{}, err
	}
	return result, nil
}

// NewListPager - Description for Get all apps for a subscription.
//
// Generated from API version 2023-01-01
//   - options - WebAppsClientListOptions contains the optional parameters for the WebAppsClient.NewListPager method.
func (client *WebAppsClient) NewListPager(options *WebAppsClientListOptions) *runtime.Pager[WebAppsClientListResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListResponse]{
		More: func(page WebAppsClientListResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListResponse) (WebAppsClientListResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return WebAppsClientListResponse{}, err
			}
			return client.listHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listCreateRequest creates the List request.
func (client *WebAppsClient) listCreateRequest(ctx context.Context, options *WebAppsClientListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/sites"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHandleResponse handles the List response.
func (client *WebAppsClient) listHandleResponse(resp *http.Response) (WebAppsClientListResponse, error) {
	result := WebAppsClientListResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return WebAppsClientListResponse{}, err
	}
	return result, nil
}

// ListApplicationSettings - Description for Gets the application settings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListApplicationSettingsOptions contains the optional parameters for the WebAppsClient.ListApplicationSettings
//     method.
func (client *WebAppsClient) ListApplicationSettings(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListApplicationSettingsOptions) (WebAppsClientListApplicationSettingsResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListApplicationSettings"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listApplicationSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListApplicationSettingsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListApplicationSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListApplicationSettingsResponse{}, err
	}
	resp, err := client.listApplicationSettingsHandleResponse(httpResp)
	return resp, err
}

// listApplicationSettingsCreateRequest creates the ListApplicationSettings request.
func (client *WebAppsClient) listApplicationSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListApplicationSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listApplicationSettingsHandleResponse handles the ListApplicationSettings response.
func (client *WebAppsClient) listApplicationSettingsHandleResponse(resp *http.Response) (WebAppsClientListApplicationSettingsResponse, error) {
	result := WebAppsClientListApplicationSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsClientListApplicationSettingsResponse{}, err
	}
	return result, nil
}

// ListApplicationSettingsSlot - Description for Gets the application settings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the application settings for the production
//     slot.
//   - options - WebAppsClientListApplicationSettingsSlotOptions contains the optional parameters for the WebAppsClient.ListApplicationSettingsSlot
//     method.
func (client *WebAppsClient) ListApplicationSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListApplicationSettingsSlotOptions) (WebAppsClientListApplicationSettingsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListApplicationSettingsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listApplicationSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListApplicationSettingsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListApplicationSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListApplicationSettingsSlotResponse{}, err
	}
	resp, err := client.listApplicationSettingsSlotHandleResponse(httpResp)
	return resp, err
}

// listApplicationSettingsSlotCreateRequest creates the ListApplicationSettingsSlot request.
func (client *WebAppsClient) listApplicationSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListApplicationSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listApplicationSettingsSlotHandleResponse handles the ListApplicationSettingsSlot response.
func (client *WebAppsClient) listApplicationSettingsSlotHandleResponse(resp *http.Response) (WebAppsClientListApplicationSettingsSlotResponse, error) {
	result := WebAppsClientListApplicationSettingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsClientListApplicationSettingsSlotResponse{}, err
	}
	return result, nil
}

// ListAzureStorageAccounts - Description for Gets the Azure storage account configurations of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListAzureStorageAccountsOptions contains the optional parameters for the WebAppsClient.ListAzureStorageAccounts
//     method.
func (client *WebAppsClient) ListAzureStorageAccounts(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListAzureStorageAccountsOptions) (WebAppsClientListAzureStorageAccountsResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListAzureStorageAccounts"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listAzureStorageAccountsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListAzureStorageAccountsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListAzureStorageAccountsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListAzureStorageAccountsResponse{}, err
	}
	resp, err := client.listAzureStorageAccountsHandleResponse(httpResp)
	return resp, err
}

// listAzureStorageAccountsCreateRequest creates the ListAzureStorageAccounts request.
func (client *WebAppsClient) listAzureStorageAccountsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListAzureStorageAccountsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAzureStorageAccountsHandleResponse handles the ListAzureStorageAccounts response.
func (client *WebAppsClient) listAzureStorageAccountsHandleResponse(resp *http.Response) (WebAppsClientListAzureStorageAccountsResponse, error) {
	result := WebAppsClientListAzureStorageAccountsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AzureStoragePropertyDictionaryResource); err != nil {
		return WebAppsClientListAzureStorageAccountsResponse{}, err
	}
	return result, nil
}

// ListAzureStorageAccountsSlot - Description for Gets the Azure storage account configurations of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update the Azure storage account configurations
//     for the production slot.
//   - options - WebAppsClientListAzureStorageAccountsSlotOptions contains the optional parameters for the WebAppsClient.ListAzureStorageAccountsSlot
//     method.
func (client *WebAppsClient) ListAzureStorageAccountsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListAzureStorageAccountsSlotOptions) (WebAppsClientListAzureStorageAccountsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListAzureStorageAccountsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listAzureStorageAccountsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListAzureStorageAccountsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListAzureStorageAccountsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListAzureStorageAccountsSlotResponse{}, err
	}
	resp, err := client.listAzureStorageAccountsSlotHandleResponse(httpResp)
	return resp, err
}

// listAzureStorageAccountsSlotCreateRequest creates the ListAzureStorageAccountsSlot request.
func (client *WebAppsClient) listAzureStorageAccountsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListAzureStorageAccountsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAzureStorageAccountsSlotHandleResponse handles the ListAzureStorageAccountsSlot response.
func (client *WebAppsClient) listAzureStorageAccountsSlotHandleResponse(resp *http.Response) (WebAppsClientListAzureStorageAccountsSlotResponse, error) {
	result := WebAppsClientListAzureStorageAccountsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AzureStoragePropertyDictionaryResource); err != nil {
		return WebAppsClientListAzureStorageAccountsSlotResponse{}, err
	}
	return result, nil
}

// ListBackupStatusSecrets - Description for Gets status of a web app backup that may be in progress, including secrets associated
// with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
// backup if a new URL is passed in the request body.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - backupID - ID of backup.
//   - request - Information on backup request.
//   - options - WebAppsClientListBackupStatusSecretsOptions contains the optional parameters for the WebAppsClient.ListBackupStatusSecrets
//     method.
func (client *WebAppsClient) ListBackupStatusSecrets(ctx context.Context, resourceGroupName string, name string, backupID string, request BackupRequest, options *WebAppsClientListBackupStatusSecretsOptions) (WebAppsClientListBackupStatusSecretsResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListBackupStatusSecrets"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listBackupStatusSecretsCreateRequest(ctx, resourceGroupName, name, backupID, request, options)
	if err != nil {
		return WebAppsClientListBackupStatusSecretsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListBackupStatusSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListBackupStatusSecretsResponse{}, err
	}
	resp, err := client.listBackupStatusSecretsHandleResponse(httpResp)
	return resp, err
}

// listBackupStatusSecretsCreateRequest creates the ListBackupStatusSecrets request.
func (client *WebAppsClient) listBackupStatusSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, request BackupRequest, options *WebAppsClientListBackupStatusSecretsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// listBackupStatusSecretsHandleResponse handles the ListBackupStatusSecrets response.
func (client *WebAppsClient) listBackupStatusSecretsHandleResponse(resp *http.Response) (WebAppsClientListBackupStatusSecretsResponse, error) {
	result := WebAppsClientListBackupStatusSecretsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return WebAppsClientListBackupStatusSecretsResponse{}, err
	}
	return result, nil
}

// ListBackupStatusSecretsSlot - Description for Gets status of a web app backup that may be in progress, including secrets
// associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
// backup if a new URL is passed in the request body.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - backupID - ID of backup.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - request - Information on backup request.
//   - options - WebAppsClientListBackupStatusSecretsSlotOptions contains the optional parameters for the WebAppsClient.ListBackupStatusSecretsSlot
//     method.
func (client *WebAppsClient) ListBackupStatusSecretsSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request BackupRequest, options *WebAppsClientListBackupStatusSecretsSlotOptions) (WebAppsClientListBackupStatusSecretsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListBackupStatusSecretsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listBackupStatusSecretsSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, request, options)
	if err != nil {
		return WebAppsClientListBackupStatusSecretsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListBackupStatusSecretsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListBackupStatusSecretsSlotResponse{}, err
	}
	resp, err := client.listBackupStatusSecretsSlotHandleResponse(httpResp)
	return resp, err
}

// listBackupStatusSecretsSlotCreateRequest creates the ListBackupStatusSecretsSlot request.
func (client *WebAppsClient) listBackupStatusSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request BackupRequest, options *WebAppsClientListBackupStatusSecretsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// listBackupStatusSecretsSlotHandleResponse handles the ListBackupStatusSecretsSlot response.
func (client *WebAppsClient) listBackupStatusSecretsSlotHandleResponse(resp *http.Response) (WebAppsClientListBackupStatusSecretsSlotResponse, error) {
	result := WebAppsClientListBackupStatusSecretsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return WebAppsClientListBackupStatusSecretsSlotResponse{}, err
	}
	return result, nil
}

// NewListBackupsPager - Description for Gets existing backups of an app.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListBackupsOptions contains the optional parameters for the WebAppsClient.NewListBackupsPager method.
func (client *WebAppsClient) NewListBackupsPager(resourceGroupName string, name string, options *WebAppsClientListBackupsOptions) *runtime.Pager[WebAppsClientListBackupsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListBackupsResponse]{
		More: func(page WebAppsClientListBackupsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListBackupsResponse) (WebAppsClientListBackupsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListBackupsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listBackupsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListBackupsResponse{}, err
			}
			return client.listBackupsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listBackupsCreateRequest creates the ListBackups request.
func (client *WebAppsClient) listBackupsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListBackupsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listBackupsHandleResponse handles the ListBackups response.
func (client *WebAppsClient) listBackupsHandleResponse(resp *http.Response) (WebAppsClientListBackupsResponse, error) {
	result := WebAppsClientListBackupsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItemCollection); err != nil {
		return WebAppsClientListBackupsResponse{}, err
	}
	return result, nil
}

// NewListBackupsSlotPager - Description for Gets existing backups of an app.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
//   - options - WebAppsClientListBackupsSlotOptions contains the optional parameters for the WebAppsClient.NewListBackupsSlotPager
//     method.
func (client *WebAppsClient) NewListBackupsSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListBackupsSlotOptions) *runtime.Pager[WebAppsClientListBackupsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListBackupsSlotResponse]{
		More: func(page WebAppsClientListBackupsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListBackupsSlotResponse) (WebAppsClientListBackupsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListBackupsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listBackupsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListBackupsSlotResponse{}, err
			}
			return client.listBackupsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listBackupsSlotCreateRequest creates the ListBackupsSlot request.
func (client *WebAppsClient) listBackupsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListBackupsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listBackupsSlotHandleResponse handles the ListBackupsSlot response.
func (client *WebAppsClient) listBackupsSlotHandleResponse(resp *http.Response) (WebAppsClientListBackupsSlotResponse, error) {
	result := WebAppsClientListBackupsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItemCollection); err != nil {
		return WebAppsClientListBackupsSlotResponse{}, err
	}
	return result, nil
}

// NewListBasicPublishingCredentialsPoliciesPager - Description for Returns whether Scm basic auth is allowed and whether
// Ftp is allowed for a given site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListBasicPublishingCredentialsPoliciesOptions contains the optional parameters for the WebAppsClient.NewListBasicPublishingCredentialsPoliciesPager
//     method.
func (client *WebAppsClient) NewListBasicPublishingCredentialsPoliciesPager(resourceGroupName string, name string, options *WebAppsClientListBasicPublishingCredentialsPoliciesOptions) *runtime.Pager[WebAppsClientListBasicPublishingCredentialsPoliciesResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListBasicPublishingCredentialsPoliciesResponse]{
		More: func(page WebAppsClientListBasicPublishingCredentialsPoliciesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListBasicPublishingCredentialsPoliciesResponse) (WebAppsClientListBasicPublishingCredentialsPoliciesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListBasicPublishingCredentialsPoliciesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listBasicPublishingCredentialsPoliciesCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListBasicPublishingCredentialsPoliciesResponse{}, err
			}
			return client.listBasicPublishingCredentialsPoliciesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listBasicPublishingCredentialsPoliciesCreateRequest creates the ListBasicPublishingCredentialsPolicies request.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListBasicPublishingCredentialsPoliciesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listBasicPublishingCredentialsPoliciesHandleResponse handles the ListBasicPublishingCredentialsPolicies response.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesHandleResponse(resp *http.Response) (WebAppsClientListBasicPublishingCredentialsPoliciesResponse, error) {
	result := WebAppsClientListBasicPublishingCredentialsPoliciesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublishingCredentialsPoliciesCollection); err != nil {
		return WebAppsClientListBasicPublishingCredentialsPoliciesResponse{}, err
	}
	return result, nil
}

// NewListBasicPublishingCredentialsPoliciesSlotPager - Description for Returns whether Scm basic auth is allowed and whether
// Ftp is allowed for a given site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListBasicPublishingCredentialsPoliciesSlotOptions contains the optional parameters for the WebAppsClient.NewListBasicPublishingCredentialsPoliciesSlotPager
//     method.
func (client *WebAppsClient) NewListBasicPublishingCredentialsPoliciesSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListBasicPublishingCredentialsPoliciesSlotOptions) *runtime.Pager[WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse]{
		More: func(page WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse) (WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListBasicPublishingCredentialsPoliciesSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listBasicPublishingCredentialsPoliciesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse{}, err
			}
			return client.listBasicPublishingCredentialsPoliciesSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listBasicPublishingCredentialsPoliciesSlotCreateRequest creates the ListBasicPublishingCredentialsPoliciesSlot request.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListBasicPublishingCredentialsPoliciesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listBasicPublishingCredentialsPoliciesSlotHandleResponse handles the ListBasicPublishingCredentialsPoliciesSlot response.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesSlotHandleResponse(resp *http.Response) (WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse, error) {
	result := WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublishingCredentialsPoliciesCollection); err != nil {
		return WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse{}, err
	}
	return result, nil
}

// NewListByResourceGroupPager - Description for Gets all web, mobile, and API apps in the specified resource group.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - options - WebAppsClientListByResourceGroupOptions contains the optional parameters for the WebAppsClient.NewListByResourceGroupPager
//     method.
func (client *WebAppsClient) NewListByResourceGroupPager(resourceGroupName string, options *WebAppsClientListByResourceGroupOptions) *runtime.Pager[WebAppsClientListByResourceGroupResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListByResourceGroupResponse]{
		More: func(page WebAppsClientListByResourceGroupResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListByResourceGroupResponse) (WebAppsClientListByResourceGroupResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListByResourceGroupPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listByResourceGroupCreateRequest(ctx, resourceGroupName, options)
			}, nil)
			if err != nil {
				return WebAppsClientListByResourceGroupResponse{}, err
			}
			return client.listByResourceGroupHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *WebAppsClient) listByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *WebAppsClientListByResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.IncludeSlots != nil {
		reqQP.Set("includeSlots", strconv.FormatBool(*options.IncludeSlots))
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *WebAppsClient) listByResourceGroupHandleResponse(resp *http.Response) (WebAppsClientListByResourceGroupResponse, error) {
	result := WebAppsClientListByResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return WebAppsClientListByResourceGroupResponse{}, err
	}
	return result, nil
}

// NewListConfigurationSnapshotInfoPager - Description for Gets a list of web app configuration snapshots identifiers. Each
// element of the list contains a timestamp and the ID of the snapshot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListConfigurationSnapshotInfoOptions contains the optional parameters for the WebAppsClient.NewListConfigurationSnapshotInfoPager
//     method.
func (client *WebAppsClient) NewListConfigurationSnapshotInfoPager(resourceGroupName string, name string, options *WebAppsClientListConfigurationSnapshotInfoOptions) *runtime.Pager[WebAppsClientListConfigurationSnapshotInfoResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListConfigurationSnapshotInfoResponse]{
		More: func(page WebAppsClientListConfigurationSnapshotInfoResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListConfigurationSnapshotInfoResponse) (WebAppsClientListConfigurationSnapshotInfoResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListConfigurationSnapshotInfoPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listConfigurationSnapshotInfoCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListConfigurationSnapshotInfoResponse{}, err
			}
			return client.listConfigurationSnapshotInfoHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listConfigurationSnapshotInfoCreateRequest creates the ListConfigurationSnapshotInfo request.
func (client *WebAppsClient) listConfigurationSnapshotInfoCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListConfigurationSnapshotInfoOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConfigurationSnapshotInfoHandleResponse handles the ListConfigurationSnapshotInfo response.
func (client *WebAppsClient) listConfigurationSnapshotInfoHandleResponse(resp *http.Response) (WebAppsClientListConfigurationSnapshotInfoResponse, error) {
	result := WebAppsClientListConfigurationSnapshotInfoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigurationSnapshotInfoCollection); err != nil {
		return WebAppsClientListConfigurationSnapshotInfoResponse{}, err
	}
	return result, nil
}

// NewListConfigurationSnapshotInfoSlotPager - Description for Gets a list of web app configuration snapshots identifiers.
// Each element of the list contains a timestamp and the ID of the snapshot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
//   - options - WebAppsClientListConfigurationSnapshotInfoSlotOptions contains the optional parameters for the WebAppsClient.NewListConfigurationSnapshotInfoSlotPager
//     method.
func (client *WebAppsClient) NewListConfigurationSnapshotInfoSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListConfigurationSnapshotInfoSlotOptions) *runtime.Pager[WebAppsClientListConfigurationSnapshotInfoSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListConfigurationSnapshotInfoSlotResponse]{
		More: func(page WebAppsClientListConfigurationSnapshotInfoSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListConfigurationSnapshotInfoSlotResponse) (WebAppsClientListConfigurationSnapshotInfoSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListConfigurationSnapshotInfoSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listConfigurationSnapshotInfoSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListConfigurationSnapshotInfoSlotResponse{}, err
			}
			return client.listConfigurationSnapshotInfoSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listConfigurationSnapshotInfoSlotCreateRequest creates the ListConfigurationSnapshotInfoSlot request.
func (client *WebAppsClient) listConfigurationSnapshotInfoSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListConfigurationSnapshotInfoSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConfigurationSnapshotInfoSlotHandleResponse handles the ListConfigurationSnapshotInfoSlot response.
func (client *WebAppsClient) listConfigurationSnapshotInfoSlotHandleResponse(resp *http.Response) (WebAppsClientListConfigurationSnapshotInfoSlotResponse, error) {
	result := WebAppsClientListConfigurationSnapshotInfoSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigurationSnapshotInfoCollection); err != nil {
		return WebAppsClientListConfigurationSnapshotInfoSlotResponse{}, err
	}
	return result, nil
}

// NewListConfigurationsPager - Description for List the configurations of an app
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListConfigurationsOptions contains the optional parameters for the WebAppsClient.NewListConfigurationsPager
//     method.
func (client *WebAppsClient) NewListConfigurationsPager(resourceGroupName string, name string, options *WebAppsClientListConfigurationsOptions) *runtime.Pager[WebAppsClientListConfigurationsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListConfigurationsResponse]{
		More: func(page WebAppsClientListConfigurationsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListConfigurationsResponse) (WebAppsClientListConfigurationsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListConfigurationsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listConfigurationsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListConfigurationsResponse{}, err
			}
			return client.listConfigurationsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listConfigurationsCreateRequest creates the ListConfigurations request.
func (client *WebAppsClient) listConfigurationsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListConfigurationsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConfigurationsHandleResponse handles the ListConfigurations response.
func (client *WebAppsClient) listConfigurationsHandleResponse(resp *http.Response) (WebAppsClientListConfigurationsResponse, error) {
	result := WebAppsClientListConfigurationsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResourceCollection); err != nil {
		return WebAppsClientListConfigurationsResponse{}, err
	}
	return result, nil
}

// NewListConfigurationsSlotPager - Description for List the configurations of an app
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
//   - options - WebAppsClientListConfigurationsSlotOptions contains the optional parameters for the WebAppsClient.NewListConfigurationsSlotPager
//     method.
func (client *WebAppsClient) NewListConfigurationsSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListConfigurationsSlotOptions) *runtime.Pager[WebAppsClientListConfigurationsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListConfigurationsSlotResponse]{
		More: func(page WebAppsClientListConfigurationsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListConfigurationsSlotResponse) (WebAppsClientListConfigurationsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListConfigurationsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listConfigurationsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListConfigurationsSlotResponse{}, err
			}
			return client.listConfigurationsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listConfigurationsSlotCreateRequest creates the ListConfigurationsSlot request.
func (client *WebAppsClient) listConfigurationsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListConfigurationsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConfigurationsSlotHandleResponse handles the ListConfigurationsSlot response.
func (client *WebAppsClient) listConfigurationsSlotHandleResponse(resp *http.Response) (WebAppsClientListConfigurationsSlotResponse, error) {
	result := WebAppsClientListConfigurationsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResourceCollection); err != nil {
		return WebAppsClientListConfigurationsSlotResponse{}, err
	}
	return result, nil
}

// ListConnectionStrings - Description for Gets the connection strings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListConnectionStringsOptions contains the optional parameters for the WebAppsClient.ListConnectionStrings
//     method.
func (client *WebAppsClient) ListConnectionStrings(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListConnectionStringsOptions) (WebAppsClientListConnectionStringsResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListConnectionStrings"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listConnectionStringsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListConnectionStringsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListConnectionStringsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListConnectionStringsResponse{}, err
	}
	resp, err := client.listConnectionStringsHandleResponse(httpResp)
	return resp, err
}

// listConnectionStringsCreateRequest creates the ListConnectionStrings request.
func (client *WebAppsClient) listConnectionStringsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListConnectionStringsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConnectionStringsHandleResponse handles the ListConnectionStrings response.
func (client *WebAppsClient) listConnectionStringsHandleResponse(resp *http.Response) (WebAppsClientListConnectionStringsResponse, error) {
	result := WebAppsClientListConnectionStringsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionStringDictionary); err != nil {
		return WebAppsClientListConnectionStringsResponse{}, err
	}
	return result, nil
}

// ListConnectionStringsSlot - Description for Gets the connection strings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the connection settings for the production
//     slot.
//   - options - WebAppsClientListConnectionStringsSlotOptions contains the optional parameters for the WebAppsClient.ListConnectionStringsSlot
//     method.
func (client *WebAppsClient) ListConnectionStringsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListConnectionStringsSlotOptions) (WebAppsClientListConnectionStringsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListConnectionStringsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listConnectionStringsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListConnectionStringsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListConnectionStringsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListConnectionStringsSlotResponse{}, err
	}
	resp, err := client.listConnectionStringsSlotHandleResponse(httpResp)
	return resp, err
}

// listConnectionStringsSlotCreateRequest creates the ListConnectionStringsSlot request.
func (client *WebAppsClient) listConnectionStringsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListConnectionStringsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConnectionStringsSlotHandleResponse handles the ListConnectionStringsSlot response.
func (client *WebAppsClient) listConnectionStringsSlotHandleResponse(resp *http.Response) (WebAppsClientListConnectionStringsSlotResponse, error) {
	result := WebAppsClientListConnectionStringsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionStringDictionary); err != nil {
		return WebAppsClientListConnectionStringsSlotResponse{}, err
	}
	return result, nil
}

// NewListContinuousWebJobsPager - Description for List continuous web jobs for an app, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - options - WebAppsClientListContinuousWebJobsOptions contains the optional parameters for the WebAppsClient.NewListContinuousWebJobsPager
//     method.
func (client *WebAppsClient) NewListContinuousWebJobsPager(resourceGroupName string, name string, options *WebAppsClientListContinuousWebJobsOptions) *runtime.Pager[WebAppsClientListContinuousWebJobsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListContinuousWebJobsResponse]{
		More: func(page WebAppsClientListContinuousWebJobsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListContinuousWebJobsResponse) (WebAppsClientListContinuousWebJobsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListContinuousWebJobsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listContinuousWebJobsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListContinuousWebJobsResponse{}, err
			}
			return client.listContinuousWebJobsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listContinuousWebJobsCreateRequest creates the ListContinuousWebJobs request.
func (client *WebAppsClient) listContinuousWebJobsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListContinuousWebJobsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listContinuousWebJobsHandleResponse handles the ListContinuousWebJobs response.
func (client *WebAppsClient) listContinuousWebJobsHandleResponse(resp *http.Response) (WebAppsClientListContinuousWebJobsResponse, error) {
	result := WebAppsClientListContinuousWebJobsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContinuousWebJobCollection); err != nil {
		return WebAppsClientListContinuousWebJobsResponse{}, err
	}
	return result, nil
}

// NewListContinuousWebJobsSlotPager - Description for List continuous web jobs for an app, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
//   - options - WebAppsClientListContinuousWebJobsSlotOptions contains the optional parameters for the WebAppsClient.NewListContinuousWebJobsSlotPager
//     method.
func (client *WebAppsClient) NewListContinuousWebJobsSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListContinuousWebJobsSlotOptions) *runtime.Pager[WebAppsClientListContinuousWebJobsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListContinuousWebJobsSlotResponse]{
		More: func(page WebAppsClientListContinuousWebJobsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListContinuousWebJobsSlotResponse) (WebAppsClientListContinuousWebJobsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListContinuousWebJobsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listContinuousWebJobsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListContinuousWebJobsSlotResponse{}, err
			}
			return client.listContinuousWebJobsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listContinuousWebJobsSlotCreateRequest creates the ListContinuousWebJobsSlot request.
func (client *WebAppsClient) listContinuousWebJobsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListContinuousWebJobsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listContinuousWebJobsSlotHandleResponse handles the ListContinuousWebJobsSlot response.
func (client *WebAppsClient) listContinuousWebJobsSlotHandleResponse(resp *http.Response) (WebAppsClientListContinuousWebJobsSlotResponse, error) {
	result := WebAppsClientListContinuousWebJobsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContinuousWebJobCollection); err != nil {
		return WebAppsClientListContinuousWebJobsSlotResponse{}, err
	}
	return result, nil
}

// ListDeploymentLog - Description for List deployment log for specific deployment for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - id - The ID of a specific deployment. This is the value of the name property in the JSON response from "GET /api/sites/{siteName}/deployments".
//   - options - WebAppsClientListDeploymentLogOptions contains the optional parameters for the WebAppsClient.ListDeploymentLog
//     method.
func (client *WebAppsClient) ListDeploymentLog(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsClientListDeploymentLogOptions) (WebAppsClientListDeploymentLogResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListDeploymentLog"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listDeploymentLogCreateRequest(ctx, resourceGroupName, name, id, options)
	if err != nil {
		return WebAppsClientListDeploymentLogResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListDeploymentLogResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListDeploymentLogResponse{}, err
	}
	resp, err := client.listDeploymentLogHandleResponse(httpResp)
	return resp, err
}

// listDeploymentLogCreateRequest creates the ListDeploymentLog request.
func (client *WebAppsClient) listDeploymentLogCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsClientListDeploymentLogOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDeploymentLogHandleResponse handles the ListDeploymentLog response.
func (client *WebAppsClient) listDeploymentLogHandleResponse(resp *http.Response) (WebAppsClientListDeploymentLogResponse, error) {
	result := WebAppsClientListDeploymentLogResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return WebAppsClientListDeploymentLogResponse{}, err
	}
	return result, nil
}

// ListDeploymentLogSlot - Description for List deployment log for specific deployment for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - id - The ID of a specific deployment. This is the value of the name property in the JSON response from "GET /api/sites/{siteName}/deployments".
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - options - WebAppsClientListDeploymentLogSlotOptions contains the optional parameters for the WebAppsClient.ListDeploymentLogSlot
//     method.
func (client *WebAppsClient) ListDeploymentLogSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsClientListDeploymentLogSlotOptions) (WebAppsClientListDeploymentLogSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListDeploymentLogSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listDeploymentLogSlotCreateRequest(ctx, resourceGroupName, name, id, slot, options)
	if err != nil {
		return WebAppsClientListDeploymentLogSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListDeploymentLogSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListDeploymentLogSlotResponse{}, err
	}
	resp, err := client.listDeploymentLogSlotHandleResponse(httpResp)
	return resp, err
}

// listDeploymentLogSlotCreateRequest creates the ListDeploymentLogSlot request.
func (client *WebAppsClient) listDeploymentLogSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsClientListDeploymentLogSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDeploymentLogSlotHandleResponse handles the ListDeploymentLogSlot response.
func (client *WebAppsClient) listDeploymentLogSlotHandleResponse(resp *http.Response) (WebAppsClientListDeploymentLogSlotResponse, error) {
	result := WebAppsClientListDeploymentLogSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return WebAppsClientListDeploymentLogSlotResponse{}, err
	}
	return result, nil
}

// NewListDeploymentsPager - Description for List deployments for an app, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListDeploymentsOptions contains the optional parameters for the WebAppsClient.NewListDeploymentsPager
//     method.
func (client *WebAppsClient) NewListDeploymentsPager(resourceGroupName string, name string, options *WebAppsClientListDeploymentsOptions) *runtime.Pager[WebAppsClientListDeploymentsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListDeploymentsResponse]{
		More: func(page WebAppsClientListDeploymentsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListDeploymentsResponse) (WebAppsClientListDeploymentsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListDeploymentsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listDeploymentsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListDeploymentsResponse{}, err
			}
			return client.listDeploymentsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listDeploymentsCreateRequest creates the ListDeployments request.
func (client *WebAppsClient) listDeploymentsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListDeploymentsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDeploymentsHandleResponse handles the ListDeployments response.
func (client *WebAppsClient) listDeploymentsHandleResponse(resp *http.Response) (WebAppsClientListDeploymentsResponse, error) {
	result := WebAppsClientListDeploymentsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentCollection); err != nil {
		return WebAppsClientListDeploymentsResponse{}, err
	}
	return result, nil
}

// NewListDeploymentsSlotPager - Description for List deployments for an app, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - options - WebAppsClientListDeploymentsSlotOptions contains the optional parameters for the WebAppsClient.NewListDeploymentsSlotPager
//     method.
func (client *WebAppsClient) NewListDeploymentsSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListDeploymentsSlotOptions) *runtime.Pager[WebAppsClientListDeploymentsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListDeploymentsSlotResponse]{
		More: func(page WebAppsClientListDeploymentsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListDeploymentsSlotResponse) (WebAppsClientListDeploymentsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListDeploymentsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listDeploymentsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListDeploymentsSlotResponse{}, err
			}
			return client.listDeploymentsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listDeploymentsSlotCreateRequest creates the ListDeploymentsSlot request.
func (client *WebAppsClient) listDeploymentsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListDeploymentsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDeploymentsSlotHandleResponse handles the ListDeploymentsSlot response.
func (client *WebAppsClient) listDeploymentsSlotHandleResponse(resp *http.Response) (WebAppsClientListDeploymentsSlotResponse, error) {
	result := WebAppsClientListDeploymentsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentCollection); err != nil {
		return WebAppsClientListDeploymentsSlotResponse{}, err
	}
	return result, nil
}

// NewListDomainOwnershipIdentifiersPager - Description for Lists ownership identifiers for domain associated with web app.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListDomainOwnershipIdentifiersOptions contains the optional parameters for the WebAppsClient.NewListDomainOwnershipIdentifiersPager
//     method.
func (client *WebAppsClient) NewListDomainOwnershipIdentifiersPager(resourceGroupName string, name string, options *WebAppsClientListDomainOwnershipIdentifiersOptions) *runtime.Pager[WebAppsClientListDomainOwnershipIdentifiersResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListDomainOwnershipIdentifiersResponse]{
		More: func(page WebAppsClientListDomainOwnershipIdentifiersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListDomainOwnershipIdentifiersResponse) (WebAppsClientListDomainOwnershipIdentifiersResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListDomainOwnershipIdentifiersPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listDomainOwnershipIdentifiersCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListDomainOwnershipIdentifiersResponse{}, err
			}
			return client.listDomainOwnershipIdentifiersHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listDomainOwnershipIdentifiersCreateRequest creates the ListDomainOwnershipIdentifiers request.
func (client *WebAppsClient) listDomainOwnershipIdentifiersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListDomainOwnershipIdentifiersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDomainOwnershipIdentifiersHandleResponse handles the ListDomainOwnershipIdentifiers response.
func (client *WebAppsClient) listDomainOwnershipIdentifiersHandleResponse(resp *http.Response) (WebAppsClientListDomainOwnershipIdentifiersResponse, error) {
	result := WebAppsClientListDomainOwnershipIdentifiersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IdentifierCollection); err != nil {
		return WebAppsClientListDomainOwnershipIdentifiersResponse{}, err
	}
	return result, nil
}

// NewListDomainOwnershipIdentifiersSlotPager - Description for Lists ownership identifiers for domain associated with web
// app.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
//   - options - WebAppsClientListDomainOwnershipIdentifiersSlotOptions contains the optional parameters for the WebAppsClient.NewListDomainOwnershipIdentifiersSlotPager
//     method.
func (client *WebAppsClient) NewListDomainOwnershipIdentifiersSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListDomainOwnershipIdentifiersSlotOptions) *runtime.Pager[WebAppsClientListDomainOwnershipIdentifiersSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListDomainOwnershipIdentifiersSlotResponse]{
		More: func(page WebAppsClientListDomainOwnershipIdentifiersSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListDomainOwnershipIdentifiersSlotResponse) (WebAppsClientListDomainOwnershipIdentifiersSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListDomainOwnershipIdentifiersSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listDomainOwnershipIdentifiersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListDomainOwnershipIdentifiersSlotResponse{}, err
			}
			return client.listDomainOwnershipIdentifiersSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listDomainOwnershipIdentifiersSlotCreateRequest creates the ListDomainOwnershipIdentifiersSlot request.
func (client *WebAppsClient) listDomainOwnershipIdentifiersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListDomainOwnershipIdentifiersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDomainOwnershipIdentifiersSlotHandleResponse handles the ListDomainOwnershipIdentifiersSlot response.
func (client *WebAppsClient) listDomainOwnershipIdentifiersSlotHandleResponse(resp *http.Response) (WebAppsClientListDomainOwnershipIdentifiersSlotResponse, error) {
	result := WebAppsClientListDomainOwnershipIdentifiersSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IdentifierCollection); err != nil {
		return WebAppsClientListDomainOwnershipIdentifiersSlotResponse{}, err
	}
	return result, nil
}

// ListFunctionKeys - Description for Get function keys for a function in a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - Function name.
//   - options - WebAppsClientListFunctionKeysOptions contains the optional parameters for the WebAppsClient.ListFunctionKeys
//     method.
func (client *WebAppsClient) ListFunctionKeys(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsClientListFunctionKeysOptions) (WebAppsClientListFunctionKeysResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListFunctionKeys"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listFunctionKeysCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return WebAppsClientListFunctionKeysResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListFunctionKeysResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListFunctionKeysResponse{}, err
	}
	resp, err := client.listFunctionKeysHandleResponse(httpResp)
	return resp, err
}

// listFunctionKeysCreateRequest creates the ListFunctionKeys request.
func (client *WebAppsClient) listFunctionKeysCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsClientListFunctionKeysOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFunctionKeysHandleResponse handles the ListFunctionKeys response.
func (client *WebAppsClient) listFunctionKeysHandleResponse(resp *http.Response) (WebAppsClientListFunctionKeysResponse, error) {
	result := WebAppsClientListFunctionKeysResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsClientListFunctionKeysResponse{}, err
	}
	return result, nil
}

// ListFunctionKeysSlot - Description for Get function keys for a function in a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - Function name.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientListFunctionKeysSlotOptions contains the optional parameters for the WebAppsClient.ListFunctionKeysSlot
//     method.
func (client *WebAppsClient) ListFunctionKeysSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsClientListFunctionKeysSlotOptions) (WebAppsClientListFunctionKeysSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListFunctionKeysSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listFunctionKeysSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return WebAppsClientListFunctionKeysSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListFunctionKeysSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListFunctionKeysSlotResponse{}, err
	}
	resp, err := client.listFunctionKeysSlotHandleResponse(httpResp)
	return resp, err
}

// listFunctionKeysSlotCreateRequest creates the ListFunctionKeysSlot request.
func (client *WebAppsClient) listFunctionKeysSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsClientListFunctionKeysSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFunctionKeysSlotHandleResponse handles the ListFunctionKeysSlot response.
func (client *WebAppsClient) listFunctionKeysSlotHandleResponse(resp *http.Response) (WebAppsClientListFunctionKeysSlotResponse, error) {
	result := WebAppsClientListFunctionKeysSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsClientListFunctionKeysSlotResponse{}, err
	}
	return result, nil
}

// ListFunctionSecrets - Description for Get function secrets for a function in a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - Function name.
//   - options - WebAppsClientListFunctionSecretsOptions contains the optional parameters for the WebAppsClient.ListFunctionSecrets
//     method.
func (client *WebAppsClient) ListFunctionSecrets(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsClientListFunctionSecretsOptions) (WebAppsClientListFunctionSecretsResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListFunctionSecrets"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listFunctionSecretsCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return WebAppsClientListFunctionSecretsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListFunctionSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListFunctionSecretsResponse{}, err
	}
	resp, err := client.listFunctionSecretsHandleResponse(httpResp)
	return resp, err
}

// listFunctionSecretsCreateRequest creates the ListFunctionSecrets request.
func (client *WebAppsClient) listFunctionSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsClientListFunctionSecretsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listsecrets"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFunctionSecretsHandleResponse handles the ListFunctionSecrets response.
func (client *WebAppsClient) listFunctionSecretsHandleResponse(resp *http.Response) (WebAppsClientListFunctionSecretsResponse, error) {
	result := WebAppsClientListFunctionSecretsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionSecrets); err != nil {
		return WebAppsClientListFunctionSecretsResponse{}, err
	}
	return result, nil
}

// ListFunctionSecretsSlot - Description for Get function secrets for a function in a web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - functionName - Function name.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientListFunctionSecretsSlotOptions contains the optional parameters for the WebAppsClient.ListFunctionSecretsSlot
//     method.
func (client *WebAppsClient) ListFunctionSecretsSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsClientListFunctionSecretsSlotOptions) (WebAppsClientListFunctionSecretsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListFunctionSecretsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listFunctionSecretsSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return WebAppsClientListFunctionSecretsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListFunctionSecretsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListFunctionSecretsSlotResponse{}, err
	}
	resp, err := client.listFunctionSecretsSlotHandleResponse(httpResp)
	return resp, err
}

// listFunctionSecretsSlotCreateRequest creates the ListFunctionSecretsSlot request.
func (client *WebAppsClient) listFunctionSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsClientListFunctionSecretsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listsecrets"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFunctionSecretsSlotHandleResponse handles the ListFunctionSecretsSlot response.
func (client *WebAppsClient) listFunctionSecretsSlotHandleResponse(resp *http.Response) (WebAppsClientListFunctionSecretsSlotResponse, error) {
	result := WebAppsClientListFunctionSecretsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionSecrets); err != nil {
		return WebAppsClientListFunctionSecretsSlotResponse{}, err
	}
	return result, nil
}

// NewListFunctionsPager - Description for List the functions for a web site, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - options - WebAppsClientListFunctionsOptions contains the optional parameters for the WebAppsClient.NewListFunctionsPager
//     method.
func (client *WebAppsClient) NewListFunctionsPager(resourceGroupName string, name string, options *WebAppsClientListFunctionsOptions) *runtime.Pager[WebAppsClientListFunctionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListFunctionsResponse]{
		More: func(page WebAppsClientListFunctionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListFunctionsResponse) (WebAppsClientListFunctionsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListFunctionsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listFunctionsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListFunctionsResponse{}, err
			}
			return client.listFunctionsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listFunctionsCreateRequest creates the ListFunctions request.
func (client *WebAppsClient) listFunctionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListFunctionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFunctionsHandleResponse handles the ListFunctions response.
func (client *WebAppsClient) listFunctionsHandleResponse(resp *http.Response) (WebAppsClientListFunctionsResponse, error) {
	result := WebAppsClientListFunctionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionEnvelopeCollection); err != nil {
		return WebAppsClientListFunctionsResponse{}, err
	}
	return result, nil
}

// ListHostKeys - Description for Get host secrets for a function app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - options - WebAppsClientListHostKeysOptions contains the optional parameters for the WebAppsClient.ListHostKeys method.
func (client *WebAppsClient) ListHostKeys(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListHostKeysOptions) (WebAppsClientListHostKeysResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListHostKeys"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listHostKeysCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListHostKeysResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListHostKeysResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListHostKeysResponse{}, err
	}
	resp, err := client.listHostKeysHandleResponse(httpResp)
	return resp, err
}

// listHostKeysCreateRequest creates the ListHostKeys request.
func (client *WebAppsClient) listHostKeysCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListHostKeysOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHostKeysHandleResponse handles the ListHostKeys response.
func (client *WebAppsClient) listHostKeysHandleResponse(resp *http.Response) (WebAppsClientListHostKeysResponse, error) {
	result := WebAppsClientListHostKeysResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostKeys); err != nil {
		return WebAppsClientListHostKeysResponse{}, err
	}
	return result, nil
}

// ListHostKeysSlot - Description for Get host secrets for a function app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientListHostKeysSlotOptions contains the optional parameters for the WebAppsClient.ListHostKeysSlot
//     method.
func (client *WebAppsClient) ListHostKeysSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListHostKeysSlotOptions) (WebAppsClientListHostKeysSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListHostKeysSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listHostKeysSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListHostKeysSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListHostKeysSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListHostKeysSlotResponse{}, err
	}
	resp, err := client.listHostKeysSlotHandleResponse(httpResp)
	return resp, err
}

// listHostKeysSlotCreateRequest creates the ListHostKeysSlot request.
func (client *WebAppsClient) listHostKeysSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListHostKeysSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHostKeysSlotHandleResponse handles the ListHostKeysSlot response.
func (client *WebAppsClient) listHostKeysSlotHandleResponse(resp *http.Response) (WebAppsClientListHostKeysSlotResponse, error) {
	result := WebAppsClientListHostKeysSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostKeys); err != nil {
		return WebAppsClientListHostKeysSlotResponse{}, err
	}
	return result, nil
}

// NewListHostNameBindingsPager - Description for Get hostname bindings for an app or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListHostNameBindingsOptions contains the optional parameters for the WebAppsClient.NewListHostNameBindingsPager
//     method.
func (client *WebAppsClient) NewListHostNameBindingsPager(resourceGroupName string, name string, options *WebAppsClientListHostNameBindingsOptions) *runtime.Pager[WebAppsClientListHostNameBindingsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListHostNameBindingsResponse]{
		More: func(page WebAppsClientListHostNameBindingsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListHostNameBindingsResponse) (WebAppsClientListHostNameBindingsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListHostNameBindingsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listHostNameBindingsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListHostNameBindingsResponse{}, err
			}
			return client.listHostNameBindingsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listHostNameBindingsCreateRequest creates the ListHostNameBindings request.
func (client *WebAppsClient) listHostNameBindingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListHostNameBindingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHostNameBindingsHandleResponse handles the ListHostNameBindings response.
func (client *WebAppsClient) listHostNameBindingsHandleResponse(resp *http.Response) (WebAppsClientListHostNameBindingsResponse, error) {
	result := WebAppsClientListHostNameBindingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBindingCollection); err != nil {
		return WebAppsClientListHostNameBindingsResponse{}, err
	}
	return result, nil
}

// NewListHostNameBindingsSlotPager - Description for Get hostname bindings for an app or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
//   - options - WebAppsClientListHostNameBindingsSlotOptions contains the optional parameters for the WebAppsClient.NewListHostNameBindingsSlotPager
//     method.
func (client *WebAppsClient) NewListHostNameBindingsSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListHostNameBindingsSlotOptions) *runtime.Pager[WebAppsClientListHostNameBindingsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListHostNameBindingsSlotResponse]{
		More: func(page WebAppsClientListHostNameBindingsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListHostNameBindingsSlotResponse) (WebAppsClientListHostNameBindingsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListHostNameBindingsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listHostNameBindingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListHostNameBindingsSlotResponse{}, err
			}
			return client.listHostNameBindingsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listHostNameBindingsSlotCreateRequest creates the ListHostNameBindingsSlot request.
func (client *WebAppsClient) listHostNameBindingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListHostNameBindingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHostNameBindingsSlotHandleResponse handles the ListHostNameBindingsSlot response.
func (client *WebAppsClient) listHostNameBindingsSlotHandleResponse(resp *http.Response) (WebAppsClientListHostNameBindingsSlotResponse, error) {
	result := WebAppsClientListHostNameBindingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBindingCollection); err != nil {
		return WebAppsClientListHostNameBindingsSlotResponse{}, err
	}
	return result, nil
}

// ListHybridConnections - Description for Retrieves all Service Bus Hybrid Connections used by this Web App.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - options - WebAppsClientListHybridConnectionsOptions contains the optional parameters for the WebAppsClient.ListHybridConnections
//     method.
func (client *WebAppsClient) ListHybridConnections(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListHybridConnectionsOptions) (WebAppsClientListHybridConnectionsResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListHybridConnections"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listHybridConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListHybridConnectionsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListHybridConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListHybridConnectionsResponse{}, err
	}
	resp, err := client.listHybridConnectionsHandleResponse(httpResp)
	return resp, err
}

// listHybridConnectionsCreateRequest creates the ListHybridConnections request.
func (client *WebAppsClient) listHybridConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListHybridConnectionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionRelays"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHybridConnectionsHandleResponse handles the ListHybridConnections response.
func (client *WebAppsClient) listHybridConnectionsHandleResponse(resp *http.Response) (WebAppsClientListHybridConnectionsResponse, error) {
	result := WebAppsClientListHybridConnectionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsClientListHybridConnectionsResponse{}, err
	}
	return result, nil
}

// ListHybridConnectionsSlot - Description for Retrieves all Service Bus Hybrid Connections used by this Web App.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - slot - The name of the slot for the web app.
//   - options - WebAppsClientListHybridConnectionsSlotOptions contains the optional parameters for the WebAppsClient.ListHybridConnectionsSlot
//     method.
func (client *WebAppsClient) ListHybridConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListHybridConnectionsSlotOptions) (WebAppsClientListHybridConnectionsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListHybridConnectionsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listHybridConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListHybridConnectionsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListHybridConnectionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListHybridConnectionsSlotResponse{}, err
	}
	resp, err := client.listHybridConnectionsSlotHandleResponse(httpResp)
	return resp, err
}

// listHybridConnectionsSlotCreateRequest creates the ListHybridConnectionsSlot request.
func (client *WebAppsClient) listHybridConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListHybridConnectionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionRelays"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHybridConnectionsSlotHandleResponse handles the ListHybridConnectionsSlot response.
func (client *WebAppsClient) listHybridConnectionsSlotHandleResponse(resp *http.Response) (WebAppsClientListHybridConnectionsSlotResponse, error) {
	result := WebAppsClientListHybridConnectionsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsClientListHybridConnectionsSlotResponse{}, err
	}
	return result, nil
}

// NewListInstanceFunctionsSlotPager - Description for List the functions for a web site, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientListInstanceFunctionsSlotOptions contains the optional parameters for the WebAppsClient.NewListInstanceFunctionsSlotPager
//     method.
func (client *WebAppsClient) NewListInstanceFunctionsSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListInstanceFunctionsSlotOptions) *runtime.Pager[WebAppsClientListInstanceFunctionsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListInstanceFunctionsSlotResponse]{
		More: func(page WebAppsClientListInstanceFunctionsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListInstanceFunctionsSlotResponse) (WebAppsClientListInstanceFunctionsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListInstanceFunctionsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listInstanceFunctionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListInstanceFunctionsSlotResponse{}, err
			}
			return client.listInstanceFunctionsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listInstanceFunctionsSlotCreateRequest creates the ListInstanceFunctionsSlot request.
func (client *WebAppsClient) listInstanceFunctionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListInstanceFunctionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceFunctionsSlotHandleResponse handles the ListInstanceFunctionsSlot response.
func (client *WebAppsClient) listInstanceFunctionsSlotHandleResponse(resp *http.Response) (WebAppsClientListInstanceFunctionsSlotResponse, error) {
	result := WebAppsClientListInstanceFunctionsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionEnvelopeCollection); err != nil {
		return WebAppsClientListInstanceFunctionsSlotResponse{}, err
	}
	return result, nil
}

// NewListInstanceIdentifiersPager - Description for Gets all scale-out instances of an app.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListInstanceIdentifiersOptions contains the optional parameters for the WebAppsClient.NewListInstanceIdentifiersPager
//     method.
func (client *WebAppsClient) NewListInstanceIdentifiersPager(resourceGroupName string, name string, options *WebAppsClientListInstanceIdentifiersOptions) *runtime.Pager[WebAppsClientListInstanceIdentifiersResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListInstanceIdentifiersResponse]{
		More: func(page WebAppsClientListInstanceIdentifiersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListInstanceIdentifiersResponse) (WebAppsClientListInstanceIdentifiersResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListInstanceIdentifiersPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listInstanceIdentifiersCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListInstanceIdentifiersResponse{}, err
			}
			return client.listInstanceIdentifiersHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listInstanceIdentifiersCreateRequest creates the ListInstanceIdentifiers request.
func (client *WebAppsClient) listInstanceIdentifiersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListInstanceIdentifiersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceIdentifiersHandleResponse handles the ListInstanceIdentifiers response.
func (client *WebAppsClient) listInstanceIdentifiersHandleResponse(resp *http.Response) (WebAppsClientListInstanceIdentifiersResponse, error) {
	result := WebAppsClientListInstanceIdentifiersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppInstanceStatusCollection); err != nil {
		return WebAppsClientListInstanceIdentifiersResponse{}, err
	}
	return result, nil
}

// NewListInstanceIdentifiersSlotPager - Description for Gets all scale-out instances of an app.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
//   - options - WebAppsClientListInstanceIdentifiersSlotOptions contains the optional parameters for the WebAppsClient.NewListInstanceIdentifiersSlotPager
//     method.
func (client *WebAppsClient) NewListInstanceIdentifiersSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListInstanceIdentifiersSlotOptions) *runtime.Pager[WebAppsClientListInstanceIdentifiersSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListInstanceIdentifiersSlotResponse]{
		More: func(page WebAppsClientListInstanceIdentifiersSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListInstanceIdentifiersSlotResponse) (WebAppsClientListInstanceIdentifiersSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListInstanceIdentifiersSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listInstanceIdentifiersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListInstanceIdentifiersSlotResponse{}, err
			}
			return client.listInstanceIdentifiersSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listInstanceIdentifiersSlotCreateRequest creates the ListInstanceIdentifiersSlot request.
func (client *WebAppsClient) listInstanceIdentifiersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListInstanceIdentifiersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceIdentifiersSlotHandleResponse handles the ListInstanceIdentifiersSlot response.
func (client *WebAppsClient) listInstanceIdentifiersSlotHandleResponse(resp *http.Response) (WebAppsClientListInstanceIdentifiersSlotResponse, error) {
	result := WebAppsClientListInstanceIdentifiersSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppInstanceStatusCollection); err != nil {
		return WebAppsClientListInstanceIdentifiersSlotResponse{}, err
	}
	return result, nil
}

// NewListInstanceProcessModulesPager - Description for List module information for a process by its ID for a specific scaled-out
// instance in a web site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientListInstanceProcessModulesOptions contains the optional parameters for the WebAppsClient.NewListInstanceProcessModulesPager
//     method.
func (client *WebAppsClient) NewListInstanceProcessModulesPager(resourceGroupName string, name string, processID string, instanceID string, options *WebAppsClientListInstanceProcessModulesOptions) *runtime.Pager[WebAppsClientListInstanceProcessModulesResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListInstanceProcessModulesResponse]{
		More: func(page WebAppsClientListInstanceProcessModulesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListInstanceProcessModulesResponse) (WebAppsClientListInstanceProcessModulesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListInstanceProcessModulesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listInstanceProcessModulesCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
			}, nil)
			if err != nil {
				return WebAppsClientListInstanceProcessModulesResponse{}, err
			}
			return client.listInstanceProcessModulesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listInstanceProcessModulesCreateRequest creates the ListInstanceProcessModules request.
func (client *WebAppsClient) listInstanceProcessModulesCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsClientListInstanceProcessModulesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceProcessModulesHandleResponse handles the ListInstanceProcessModules response.
func (client *WebAppsClient) listInstanceProcessModulesHandleResponse(resp *http.Response) (WebAppsClientListInstanceProcessModulesResponse, error) {
	result := WebAppsClientListInstanceProcessModulesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfoCollection); err != nil {
		return WebAppsClientListInstanceProcessModulesResponse{}, err
	}
	return result, nil
}

// NewListInstanceProcessModulesSlotPager - Description for List module information for a process by its ID for a specific
// scaled-out instance in a web site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientListInstanceProcessModulesSlotOptions contains the optional parameters for the WebAppsClient.NewListInstanceProcessModulesSlotPager
//     method.
func (client *WebAppsClient) NewListInstanceProcessModulesSlotPager(resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsClientListInstanceProcessModulesSlotOptions) *runtime.Pager[WebAppsClientListInstanceProcessModulesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListInstanceProcessModulesSlotResponse]{
		More: func(page WebAppsClientListInstanceProcessModulesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListInstanceProcessModulesSlotResponse) (WebAppsClientListInstanceProcessModulesSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListInstanceProcessModulesSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listInstanceProcessModulesSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
			}, nil)
			if err != nil {
				return WebAppsClientListInstanceProcessModulesSlotResponse{}, err
			}
			return client.listInstanceProcessModulesSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listInstanceProcessModulesSlotCreateRequest creates the ListInstanceProcessModulesSlot request.
func (client *WebAppsClient) listInstanceProcessModulesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsClientListInstanceProcessModulesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceProcessModulesSlotHandleResponse handles the ListInstanceProcessModulesSlot response.
func (client *WebAppsClient) listInstanceProcessModulesSlotHandleResponse(resp *http.Response) (WebAppsClientListInstanceProcessModulesSlotResponse, error) {
	result := WebAppsClientListInstanceProcessModulesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfoCollection); err != nil {
		return WebAppsClientListInstanceProcessModulesSlotResponse{}, err
	}
	return result, nil
}

// NewListInstanceProcessThreadsPager - Description for List the threads in a process by its ID for a specific scaled-out
// instance in a web site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientListInstanceProcessThreadsOptions contains the optional parameters for the WebAppsClient.NewListInstanceProcessThreadsPager
//     method.
func (client *WebAppsClient) NewListInstanceProcessThreadsPager(resourceGroupName string, name string, processID string, instanceID string, options *WebAppsClientListInstanceProcessThreadsOptions) *runtime.Pager[WebAppsClientListInstanceProcessThreadsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListInstanceProcessThreadsResponse]{
		More: func(page WebAppsClientListInstanceProcessThreadsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListInstanceProcessThreadsResponse) (WebAppsClientListInstanceProcessThreadsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListInstanceProcessThreadsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listInstanceProcessThreadsCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
			}, nil)
			if err != nil {
				return WebAppsClientListInstanceProcessThreadsResponse{}, err
			}
			return client.listInstanceProcessThreadsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listInstanceProcessThreadsCreateRequest creates the ListInstanceProcessThreads request.
func (client *WebAppsClient) listInstanceProcessThreadsCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsClientListInstanceProcessThreadsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceProcessThreadsHandleResponse handles the ListInstanceProcessThreads response.
func (client *WebAppsClient) listInstanceProcessThreadsHandleResponse(resp *http.Response) (WebAppsClientListInstanceProcessThreadsResponse, error) {
	result := WebAppsClientListInstanceProcessThreadsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfoCollection); err != nil {
		return WebAppsClientListInstanceProcessThreadsResponse{}, err
	}
	return result, nil
}

// NewListInstanceProcessThreadsSlotPager - Description for List the threads in a process by its ID for a specific scaled-out
// instance in a web site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientListInstanceProcessThreadsSlotOptions contains the optional parameters for the WebAppsClient.NewListInstanceProcessThreadsSlotPager
//     method.
func (client *WebAppsClient) NewListInstanceProcessThreadsSlotPager(resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsClientListInstanceProcessThreadsSlotOptions) *runtime.Pager[WebAppsClientListInstanceProcessThreadsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListInstanceProcessThreadsSlotResponse]{
		More: func(page WebAppsClientListInstanceProcessThreadsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListInstanceProcessThreadsSlotResponse) (WebAppsClientListInstanceProcessThreadsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListInstanceProcessThreadsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listInstanceProcessThreadsSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
			}, nil)
			if err != nil {
				return WebAppsClientListInstanceProcessThreadsSlotResponse{}, err
			}
			return client.listInstanceProcessThreadsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listInstanceProcessThreadsSlotCreateRequest creates the ListInstanceProcessThreadsSlot request.
func (client *WebAppsClient) listInstanceProcessThreadsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsClientListInstanceProcessThreadsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceProcessThreadsSlotHandleResponse handles the ListInstanceProcessThreadsSlot response.
func (client *WebAppsClient) listInstanceProcessThreadsSlotHandleResponse(resp *http.Response) (WebAppsClientListInstanceProcessThreadsSlotResponse, error) {
	result := WebAppsClientListInstanceProcessThreadsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfoCollection); err != nil {
		return WebAppsClientListInstanceProcessThreadsSlotResponse{}, err
	}
	return result, nil
}

// NewListInstanceProcessesPager - Description for Get list of processes for a web site, or a deployment slot, or for a specific
// scaled-out instance in a web site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientListInstanceProcessesOptions contains the optional parameters for the WebAppsClient.NewListInstanceProcessesPager
//     method.
func (client *WebAppsClient) NewListInstanceProcessesPager(resourceGroupName string, name string, instanceID string, options *WebAppsClientListInstanceProcessesOptions) *runtime.Pager[WebAppsClientListInstanceProcessesResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListInstanceProcessesResponse]{
		More: func(page WebAppsClientListInstanceProcessesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListInstanceProcessesResponse) (WebAppsClientListInstanceProcessesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListInstanceProcessesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listInstanceProcessesCreateRequest(ctx, resourceGroupName, name, instanceID, options)
			}, nil)
			if err != nil {
				return WebAppsClientListInstanceProcessesResponse{}, err
			}
			return client.listInstanceProcessesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listInstanceProcessesCreateRequest creates the ListInstanceProcesses request.
func (client *WebAppsClient) listInstanceProcessesCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsClientListInstanceProcessesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceProcessesHandleResponse handles the ListInstanceProcesses response.
func (client *WebAppsClient) listInstanceProcessesHandleResponse(resp *http.Response) (WebAppsClientListInstanceProcessesResponse, error) {
	result := WebAppsClientListInstanceProcessesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfoCollection); err != nil {
		return WebAppsClientListInstanceProcessesResponse{}, err
	}
	return result, nil
}

// NewListInstanceProcessesSlotPager - Description for Get list of processes for a web site, or a deployment slot, or for
// a specific scaled-out instance in a web site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET
//     api/sites/{siteName}/instances".
//   - options - WebAppsClientListInstanceProcessesSlotOptions contains the optional parameters for the WebAppsClient.NewListInstanceProcessesSlotPager
//     method.
func (client *WebAppsClient) NewListInstanceProcessesSlotPager(resourceGroupName string, name string, slot string, instanceID string, options *WebAppsClientListInstanceProcessesSlotOptions) *runtime.Pager[WebAppsClientListInstanceProcessesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListInstanceProcessesSlotResponse]{
		More: func(page WebAppsClientListInstanceProcessesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListInstanceProcessesSlotResponse) (WebAppsClientListInstanceProcessesSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListInstanceProcessesSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listInstanceProcessesSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, options)
			}, nil)
			if err != nil {
				return WebAppsClientListInstanceProcessesSlotResponse{}, err
			}
			return client.listInstanceProcessesSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listInstanceProcessesSlotCreateRequest creates the ListInstanceProcessesSlot request.
func (client *WebAppsClient) listInstanceProcessesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsClientListInstanceProcessesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceProcessesSlotHandleResponse handles the ListInstanceProcessesSlot response.
func (client *WebAppsClient) listInstanceProcessesSlotHandleResponse(resp *http.Response) (WebAppsClientListInstanceProcessesSlotResponse, error) {
	result := WebAppsClientListInstanceProcessesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfoCollection); err != nil {
		return WebAppsClientListInstanceProcessesSlotResponse{}, err
	}
	return result, nil
}

// NewListInstanceWorkflowsSlotPager - List the workflows for a web site, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientListInstanceWorkflowsSlotOptions contains the optional parameters for the WebAppsClient.NewListInstanceWorkflowsSlotPager
//     method.
func (client *WebAppsClient) NewListInstanceWorkflowsSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListInstanceWorkflowsSlotOptions) *runtime.Pager[WebAppsClientListInstanceWorkflowsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListInstanceWorkflowsSlotResponse]{
		More: func(page WebAppsClientListInstanceWorkflowsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListInstanceWorkflowsSlotResponse) (WebAppsClientListInstanceWorkflowsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListInstanceWorkflowsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listInstanceWorkflowsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListInstanceWorkflowsSlotResponse{}, err
			}
			return client.listInstanceWorkflowsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listInstanceWorkflowsSlotCreateRequest creates the ListInstanceWorkflowsSlot request.
func (client *WebAppsClient) listInstanceWorkflowsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListInstanceWorkflowsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/workflows"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInstanceWorkflowsSlotHandleResponse handles the ListInstanceWorkflowsSlot response.
func (client *WebAppsClient) listInstanceWorkflowsSlotHandleResponse(resp *http.Response) (WebAppsClientListInstanceWorkflowsSlotResponse, error) {
	result := WebAppsClientListInstanceWorkflowsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkflowEnvelopeCollection); err != nil {
		return WebAppsClientListInstanceWorkflowsSlotResponse{}, err
	}
	return result, nil
}

// ListMetadata - Description for Gets the metadata of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListMetadataOptions contains the optional parameters for the WebAppsClient.ListMetadata method.
func (client *WebAppsClient) ListMetadata(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListMetadataOptions) (WebAppsClientListMetadataResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListMetadata"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listMetadataCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListMetadataResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListMetadataResponse{}, err
	}
	resp, err := client.listMetadataHandleResponse(httpResp)
	return resp, err
}

// listMetadataCreateRequest creates the ListMetadata request.
func (client *WebAppsClient) listMetadataCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListMetadataOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listMetadataHandleResponse handles the ListMetadata response.
func (client *WebAppsClient) listMetadataHandleResponse(resp *http.Response) (WebAppsClientListMetadataResponse, error) {
	result := WebAppsClientListMetadataResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsClientListMetadataResponse{}, err
	}
	return result, nil
}

// ListMetadataSlot - Description for Gets the metadata of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the metadata for the production slot.
//   - options - WebAppsClientListMetadataSlotOptions contains the optional parameters for the WebAppsClient.ListMetadataSlot
//     method.
func (client *WebAppsClient) ListMetadataSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListMetadataSlotOptions) (WebAppsClientListMetadataSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListMetadataSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listMetadataSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListMetadataSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListMetadataSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListMetadataSlotResponse{}, err
	}
	resp, err := client.listMetadataSlotHandleResponse(httpResp)
	return resp, err
}

// listMetadataSlotCreateRequest creates the ListMetadataSlot request.
func (client *WebAppsClient) listMetadataSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListMetadataSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listMetadataSlotHandleResponse handles the ListMetadataSlot response.
func (client *WebAppsClient) listMetadataSlotHandleResponse(resp *http.Response) (WebAppsClientListMetadataSlotResponse, error) {
	result := WebAppsClientListMetadataSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsClientListMetadataSlotResponse{}, err
	}
	return result, nil
}

// ListNetworkFeatures - Description for Gets all network features used by the app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - view - The type of view. Only "summary" is supported at this time.
//   - options - WebAppsClientListNetworkFeaturesOptions contains the optional parameters for the WebAppsClient.ListNetworkFeatures
//     method.
func (client *WebAppsClient) ListNetworkFeatures(ctx context.Context, resourceGroupName string, name string, view string, options *WebAppsClientListNetworkFeaturesOptions) (WebAppsClientListNetworkFeaturesResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListNetworkFeatures"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listNetworkFeaturesCreateRequest(ctx, resourceGroupName, name, view, options)
	if err != nil {
		return WebAppsClientListNetworkFeaturesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListNetworkFeaturesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListNetworkFeaturesResponse{}, err
	}
	resp, err := client.listNetworkFeaturesHandleResponse(httpResp)
	return resp, err
}

// listNetworkFeaturesCreateRequest creates the ListNetworkFeatures request.
func (client *WebAppsClient) listNetworkFeaturesCreateRequest(ctx context.Context, resourceGroupName string, name string, view string, options *WebAppsClientListNetworkFeaturesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if view == "" {
		return nil, errors.New("parameter view cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{view}", url.PathEscape(view))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listNetworkFeaturesHandleResponse handles the ListNetworkFeatures response.
func (client *WebAppsClient) listNetworkFeaturesHandleResponse(resp *http.Response) (WebAppsClientListNetworkFeaturesResponse, error) {
	result := WebAppsClientListNetworkFeaturesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkFeatures); err != nil {
		return WebAppsClientListNetworkFeaturesResponse{}, err
	}
	return result, nil
}

// ListNetworkFeaturesSlot - Description for Gets all network features used by the app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - view - The type of view. Only "summary" is supported at this time.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get network features for the production slot.
//   - options - WebAppsClientListNetworkFeaturesSlotOptions contains the optional parameters for the WebAppsClient.ListNetworkFeaturesSlot
//     method.
func (client *WebAppsClient) ListNetworkFeaturesSlot(ctx context.Context, resourceGroupName string, name string, view string, slot string, options *WebAppsClientListNetworkFeaturesSlotOptions) (WebAppsClientListNetworkFeaturesSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListNetworkFeaturesSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listNetworkFeaturesSlotCreateRequest(ctx, resourceGroupName, name, view, slot, options)
	if err != nil {
		return WebAppsClientListNetworkFeaturesSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListNetworkFeaturesSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListNetworkFeaturesSlotResponse{}, err
	}
	resp, err := client.listNetworkFeaturesSlotHandleResponse(httpResp)
	return resp, err
}

// listNetworkFeaturesSlotCreateRequest creates the ListNetworkFeaturesSlot request.
func (client *WebAppsClient) listNetworkFeaturesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, view string, slot string, options *WebAppsClientListNetworkFeaturesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if view == "" {
		return nil, errors.New("parameter view cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{view}", url.PathEscape(view))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listNetworkFeaturesSlotHandleResponse handles the ListNetworkFeaturesSlot response.
func (client *WebAppsClient) listNetworkFeaturesSlotHandleResponse(resp *http.Response) (WebAppsClientListNetworkFeaturesSlotResponse, error) {
	result := WebAppsClientListNetworkFeaturesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkFeatures); err != nil {
		return WebAppsClientListNetworkFeaturesSlotResponse{}, err
	}
	return result, nil
}

// NewListPerfMonCountersPager - Description for Gets perfmon counters for web app.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientListPerfMonCountersOptions contains the optional parameters for the WebAppsClient.NewListPerfMonCountersPager
//     method.
func (client *WebAppsClient) NewListPerfMonCountersPager(resourceGroupName string, name string, options *WebAppsClientListPerfMonCountersOptions) *runtime.Pager[WebAppsClientListPerfMonCountersResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListPerfMonCountersResponse]{
		More: func(page WebAppsClientListPerfMonCountersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListPerfMonCountersResponse) (WebAppsClientListPerfMonCountersResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListPerfMonCountersPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listPerfMonCountersCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListPerfMonCountersResponse{}, err
			}
			return client.listPerfMonCountersHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listPerfMonCountersCreateRequest creates the ListPerfMonCounters request.
func (client *WebAppsClient) listPerfMonCountersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListPerfMonCountersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/perfcounters"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPerfMonCountersHandleResponse handles the ListPerfMonCounters response.
func (client *WebAppsClient) listPerfMonCountersHandleResponse(resp *http.Response) (WebAppsClientListPerfMonCountersResponse, error) {
	result := WebAppsClientListPerfMonCountersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PerfMonCounterCollection); err != nil {
		return WebAppsClientListPerfMonCountersResponse{}, err
	}
	return result, nil
}

// NewListPerfMonCountersSlotPager - Description for Gets perfmon counters for web app.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - options - WebAppsClientListPerfMonCountersSlotOptions contains the optional parameters for the WebAppsClient.NewListPerfMonCountersSlotPager
//     method.
func (client *WebAppsClient) NewListPerfMonCountersSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListPerfMonCountersSlotOptions) *runtime.Pager[WebAppsClientListPerfMonCountersSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListPerfMonCountersSlotResponse]{
		More: func(page WebAppsClientListPerfMonCountersSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListPerfMonCountersSlotResponse) (WebAppsClientListPerfMonCountersSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListPerfMonCountersSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listPerfMonCountersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListPerfMonCountersSlotResponse{}, err
			}
			return client.listPerfMonCountersSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listPerfMonCountersSlotCreateRequest creates the ListPerfMonCountersSlot request.
func (client *WebAppsClient) listPerfMonCountersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListPerfMonCountersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/perfcounters"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPerfMonCountersSlotHandleResponse handles the ListPerfMonCountersSlot response.
func (client *WebAppsClient) listPerfMonCountersSlotHandleResponse(resp *http.Response) (WebAppsClientListPerfMonCountersSlotResponse, error) {
	result := WebAppsClientListPerfMonCountersSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PerfMonCounterCollection); err != nil {
		return WebAppsClientListPerfMonCountersSlotResponse{}, err
	}
	return result, nil
}

// ListPremierAddOns - Description for Gets the premier add-ons of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListPremierAddOnsOptions contains the optional parameters for the WebAppsClient.ListPremierAddOns
//     method.
func (client *WebAppsClient) ListPremierAddOns(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListPremierAddOnsOptions) (WebAppsClientListPremierAddOnsResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListPremierAddOns"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listPremierAddOnsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListPremierAddOnsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListPremierAddOnsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListPremierAddOnsResponse{}, err
	}
	resp, err := client.listPremierAddOnsHandleResponse(httpResp)
	return resp, err
}

// listPremierAddOnsCreateRequest creates the ListPremierAddOns request.
func (client *WebAppsClient) listPremierAddOnsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListPremierAddOnsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPremierAddOnsHandleResponse handles the ListPremierAddOns response.
func (client *WebAppsClient) listPremierAddOnsHandleResponse(resp *http.Response) (WebAppsClientListPremierAddOnsResponse, error) {
	result := WebAppsClientListPremierAddOnsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsClientListPremierAddOnsResponse{}, err
	}
	return result, nil
}

// ListPremierAddOnsSlot - Description for Gets the premier add-ons of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the premier add-ons for the production
//     slot.
//   - options - WebAppsClientListPremierAddOnsSlotOptions contains the optional parameters for the WebAppsClient.ListPremierAddOnsSlot
//     method.
func (client *WebAppsClient) ListPremierAddOnsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListPremierAddOnsSlotOptions) (WebAppsClientListPremierAddOnsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListPremierAddOnsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listPremierAddOnsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListPremierAddOnsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListPremierAddOnsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListPremierAddOnsSlotResponse{}, err
	}
	resp, err := client.listPremierAddOnsSlotHandleResponse(httpResp)
	return resp, err
}

// listPremierAddOnsSlotCreateRequest creates the ListPremierAddOnsSlot request.
func (client *WebAppsClient) listPremierAddOnsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListPremierAddOnsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPremierAddOnsSlotHandleResponse handles the ListPremierAddOnsSlot response.
func (client *WebAppsClient) listPremierAddOnsSlotHandleResponse(resp *http.Response) (WebAppsClientListPremierAddOnsSlotResponse, error) {
	result := WebAppsClientListPremierAddOnsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsClientListPremierAddOnsSlotResponse{}, err
	}
	return result, nil
}

// NewListProcessModulesPager - Description for List module information for a process by its ID for a specific scaled-out
// instance in a web site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - options - WebAppsClientListProcessModulesOptions contains the optional parameters for the WebAppsClient.NewListProcessModulesPager
//     method.
func (client *WebAppsClient) NewListProcessModulesPager(resourceGroupName string, name string, processID string, options *WebAppsClientListProcessModulesOptions) *runtime.Pager[WebAppsClientListProcessModulesResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListProcessModulesResponse]{
		More: func(page WebAppsClientListProcessModulesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListProcessModulesResponse) (WebAppsClientListProcessModulesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListProcessModulesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listProcessModulesCreateRequest(ctx, resourceGroupName, name, processID, options)
			}, nil)
			if err != nil {
				return WebAppsClientListProcessModulesResponse{}, err
			}
			return client.listProcessModulesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listProcessModulesCreateRequest creates the ListProcessModules request.
func (client *WebAppsClient) listProcessModulesCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsClientListProcessModulesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProcessModulesHandleResponse handles the ListProcessModules response.
func (client *WebAppsClient) listProcessModulesHandleResponse(resp *http.Response) (WebAppsClientListProcessModulesResponse, error) {
	result := WebAppsClientListProcessModulesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfoCollection); err != nil {
		return WebAppsClientListProcessModulesResponse{}, err
	}
	return result, nil
}

// NewListProcessModulesSlotPager - Description for List module information for a process by its ID for a specific scaled-out
// instance in a web site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - options - WebAppsClientListProcessModulesSlotOptions contains the optional parameters for the WebAppsClient.NewListProcessModulesSlotPager
//     method.
func (client *WebAppsClient) NewListProcessModulesSlotPager(resourceGroupName string, name string, processID string, slot string, options *WebAppsClientListProcessModulesSlotOptions) *runtime.Pager[WebAppsClientListProcessModulesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListProcessModulesSlotResponse]{
		More: func(page WebAppsClientListProcessModulesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListProcessModulesSlotResponse) (WebAppsClientListProcessModulesSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListProcessModulesSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listProcessModulesSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListProcessModulesSlotResponse{}, err
			}
			return client.listProcessModulesSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listProcessModulesSlotCreateRequest creates the ListProcessModulesSlot request.
func (client *WebAppsClient) listProcessModulesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsClientListProcessModulesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProcessModulesSlotHandleResponse handles the ListProcessModulesSlot response.
func (client *WebAppsClient) listProcessModulesSlotHandleResponse(resp *http.Response) (WebAppsClientListProcessModulesSlotResponse, error) {
	result := WebAppsClientListProcessModulesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfoCollection); err != nil {
		return WebAppsClientListProcessModulesSlotResponse{}, err
	}
	return result, nil
}

// NewListProcessThreadsPager - Description for List the threads in a process by its ID for a specific scaled-out instance
// in a web site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - options - WebAppsClientListProcessThreadsOptions contains the optional parameters for the WebAppsClient.NewListProcessThreadsPager
//     method.
func (client *WebAppsClient) NewListProcessThreadsPager(resourceGroupName string, name string, processID string, options *WebAppsClientListProcessThreadsOptions) *runtime.Pager[WebAppsClientListProcessThreadsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListProcessThreadsResponse]{
		More: func(page WebAppsClientListProcessThreadsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListProcessThreadsResponse) (WebAppsClientListProcessThreadsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListProcessThreadsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listProcessThreadsCreateRequest(ctx, resourceGroupName, name, processID, options)
			}, nil)
			if err != nil {
				return WebAppsClientListProcessThreadsResponse{}, err
			}
			return client.listProcessThreadsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listProcessThreadsCreateRequest creates the ListProcessThreads request.
func (client *WebAppsClient) listProcessThreadsCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsClientListProcessThreadsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProcessThreadsHandleResponse handles the ListProcessThreads response.
func (client *WebAppsClient) listProcessThreadsHandleResponse(resp *http.Response) (WebAppsClientListProcessThreadsResponse, error) {
	result := WebAppsClientListProcessThreadsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfoCollection); err != nil {
		return WebAppsClientListProcessThreadsResponse{}, err
	}
	return result, nil
}

// NewListProcessThreadsSlotPager - Description for List the threads in a process by its ID for a specific scaled-out instance
// in a web site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - processID - PID.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - options - WebAppsClientListProcessThreadsSlotOptions contains the optional parameters for the WebAppsClient.NewListProcessThreadsSlotPager
//     method.
func (client *WebAppsClient) NewListProcessThreadsSlotPager(resourceGroupName string, name string, processID string, slot string, options *WebAppsClientListProcessThreadsSlotOptions) *runtime.Pager[WebAppsClientListProcessThreadsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListProcessThreadsSlotResponse]{
		More: func(page WebAppsClientListProcessThreadsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListProcessThreadsSlotResponse) (WebAppsClientListProcessThreadsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListProcessThreadsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listProcessThreadsSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListProcessThreadsSlotResponse{}, err
			}
			return client.listProcessThreadsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listProcessThreadsSlotCreateRequest creates the ListProcessThreadsSlot request.
func (client *WebAppsClient) listProcessThreadsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsClientListProcessThreadsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProcessThreadsSlotHandleResponse handles the ListProcessThreadsSlot response.
func (client *WebAppsClient) listProcessThreadsSlotHandleResponse(resp *http.Response) (WebAppsClientListProcessThreadsSlotResponse, error) {
	result := WebAppsClientListProcessThreadsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfoCollection); err != nil {
		return WebAppsClientListProcessThreadsSlotResponse{}, err
	}
	return result, nil
}

// NewListProcessesPager - Description for Get list of processes for a web site, or a deployment slot, or for a specific scaled-out
// instance in a web site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - options - WebAppsClientListProcessesOptions contains the optional parameters for the WebAppsClient.NewListProcessesPager
//     method.
func (client *WebAppsClient) NewListProcessesPager(resourceGroupName string, name string, options *WebAppsClientListProcessesOptions) *runtime.Pager[WebAppsClientListProcessesResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListProcessesResponse]{
		More: func(page WebAppsClientListProcessesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListProcessesResponse) (WebAppsClientListProcessesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListProcessesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listProcessesCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListProcessesResponse{}, err
			}
			return client.listProcessesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listProcessesCreateRequest creates the ListProcesses request.
func (client *WebAppsClient) listProcessesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListProcessesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProcessesHandleResponse handles the ListProcesses response.
func (client *WebAppsClient) listProcessesHandleResponse(resp *http.Response) (WebAppsClientListProcessesResponse, error) {
	result := WebAppsClientListProcessesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfoCollection); err != nil {
		return WebAppsClientListProcessesResponse{}, err
	}
	return result, nil
}

// NewListProcessesSlotPager - Description for Get list of processes for a web site, or a deployment slot, or for a specific
// scaled-out instance in a web site.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - options - WebAppsClientListProcessesSlotOptions contains the optional parameters for the WebAppsClient.NewListProcessesSlotPager
//     method.
func (client *WebAppsClient) NewListProcessesSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListProcessesSlotOptions) *runtime.Pager[WebAppsClientListProcessesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListProcessesSlotResponse]{
		More: func(page WebAppsClientListProcessesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListProcessesSlotResponse) (WebAppsClientListProcessesSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListProcessesSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listProcessesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListProcessesSlotResponse{}, err
			}
			return client.listProcessesSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listProcessesSlotCreateRequest creates the ListProcessesSlot request.
func (client *WebAppsClient) listProcessesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListProcessesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProcessesSlotHandleResponse handles the ListProcessesSlot response.
func (client *WebAppsClient) listProcessesSlotHandleResponse(resp *http.Response) (WebAppsClientListProcessesSlotResponse, error) {
	result := WebAppsClientListProcessesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfoCollection); err != nil {
		return WebAppsClientListProcessesSlotResponse{}, err
	}
	return result, nil
}

// NewListProductionSiteDeploymentStatusesPager - List deployment statuses for an app (or deployment slot, if specified).
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListProductionSiteDeploymentStatusesOptions contains the optional parameters for the WebAppsClient.NewListProductionSiteDeploymentStatusesPager
//     method.
func (client *WebAppsClient) NewListProductionSiteDeploymentStatusesPager(resourceGroupName string, name string, options *WebAppsClientListProductionSiteDeploymentStatusesOptions) *runtime.Pager[WebAppsClientListProductionSiteDeploymentStatusesResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListProductionSiteDeploymentStatusesResponse]{
		More: func(page WebAppsClientListProductionSiteDeploymentStatusesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListProductionSiteDeploymentStatusesResponse) (WebAppsClientListProductionSiteDeploymentStatusesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListProductionSiteDeploymentStatusesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listProductionSiteDeploymentStatusesCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListProductionSiteDeploymentStatusesResponse{}, err
			}
			return client.listProductionSiteDeploymentStatusesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listProductionSiteDeploymentStatusesCreateRequest creates the ListProductionSiteDeploymentStatuses request.
func (client *WebAppsClient) listProductionSiteDeploymentStatusesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListProductionSiteDeploymentStatusesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deploymentStatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listProductionSiteDeploymentStatusesHandleResponse handles the ListProductionSiteDeploymentStatuses response.
func (client *WebAppsClient) listProductionSiteDeploymentStatusesHandleResponse(resp *http.Response) (WebAppsClientListProductionSiteDeploymentStatusesResponse, error) {
	result := WebAppsClientListProductionSiteDeploymentStatusesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmDeploymentStatusCollection); err != nil {
		return WebAppsClientListProductionSiteDeploymentStatusesResponse{}, err
	}
	return result, nil
}

// NewListPublicCertificatesPager - Description for Get public certificates for an app or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListPublicCertificatesOptions contains the optional parameters for the WebAppsClient.NewListPublicCertificatesPager
//     method.
func (client *WebAppsClient) NewListPublicCertificatesPager(resourceGroupName string, name string, options *WebAppsClientListPublicCertificatesOptions) *runtime.Pager[WebAppsClientListPublicCertificatesResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListPublicCertificatesResponse]{
		More: func(page WebAppsClientListPublicCertificatesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListPublicCertificatesResponse) (WebAppsClientListPublicCertificatesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListPublicCertificatesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listPublicCertificatesCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListPublicCertificatesResponse{}, err
			}
			return client.listPublicCertificatesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listPublicCertificatesCreateRequest creates the ListPublicCertificates request.
func (client *WebAppsClient) listPublicCertificatesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListPublicCertificatesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPublicCertificatesHandleResponse handles the ListPublicCertificates response.
func (client *WebAppsClient) listPublicCertificatesHandleResponse(resp *http.Response) (WebAppsClientListPublicCertificatesResponse, error) {
	result := WebAppsClientListPublicCertificatesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificateCollection); err != nil {
		return WebAppsClientListPublicCertificatesResponse{}, err
	}
	return result, nil
}

// NewListPublicCertificatesSlotPager - Description for Get public certificates for an app or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
//   - options - WebAppsClientListPublicCertificatesSlotOptions contains the optional parameters for the WebAppsClient.NewListPublicCertificatesSlotPager
//     method.
func (client *WebAppsClient) NewListPublicCertificatesSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListPublicCertificatesSlotOptions) *runtime.Pager[WebAppsClientListPublicCertificatesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListPublicCertificatesSlotResponse]{
		More: func(page WebAppsClientListPublicCertificatesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListPublicCertificatesSlotResponse) (WebAppsClientListPublicCertificatesSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListPublicCertificatesSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listPublicCertificatesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListPublicCertificatesSlotResponse{}, err
			}
			return client.listPublicCertificatesSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listPublicCertificatesSlotCreateRequest creates the ListPublicCertificatesSlot request.
func (client *WebAppsClient) listPublicCertificatesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListPublicCertificatesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPublicCertificatesSlotHandleResponse handles the ListPublicCertificatesSlot response.
func (client *WebAppsClient) listPublicCertificatesSlotHandleResponse(resp *http.Response) (WebAppsClientListPublicCertificatesSlotResponse, error) {
	result := WebAppsClientListPublicCertificatesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificateCollection); err != nil {
		return WebAppsClientListPublicCertificatesSlotResponse{}, err
	}
	return result, nil
}

// BeginListPublishingCredentials - Description for Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientBeginListPublishingCredentialsOptions contains the optional parameters for the WebAppsClient.BeginListPublishingCredentials
//     method.
func (client *WebAppsClient) BeginListPublishingCredentials(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientBeginListPublishingCredentialsOptions) (*runtime.Poller[WebAppsClientListPublishingCredentialsResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.listPublishingCredentials(ctx, resourceGroupName, name, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientListPublishingCredentialsResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientListPublishingCredentialsResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ListPublishingCredentials - Description for Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) listPublishingCredentials(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientBeginListPublishingCredentialsOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginListPublishingCredentials"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listPublishingCredentialsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// listPublishingCredentialsCreateRequest creates the ListPublishingCredentials request.
func (client *WebAppsClient) listPublishingCredentialsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientBeginListPublishingCredentialsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginListPublishingCredentialsSlot - Description for Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production
//     slot.
//   - options - WebAppsClientBeginListPublishingCredentialsSlotOptions contains the optional parameters for the WebAppsClient.BeginListPublishingCredentialsSlot
//     method.
func (client *WebAppsClient) BeginListPublishingCredentialsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientBeginListPublishingCredentialsSlotOptions) (*runtime.Poller[WebAppsClientListPublishingCredentialsSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.listPublishingCredentialsSlot(ctx, resourceGroupName, name, slot, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientListPublishingCredentialsSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientListPublishingCredentialsSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ListPublishingCredentialsSlot - Description for Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) listPublishingCredentialsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientBeginListPublishingCredentialsSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginListPublishingCredentialsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listPublishingCredentialsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// listPublishingCredentialsSlotCreateRequest creates the ListPublishingCredentialsSlot request.
func (client *WebAppsClient) listPublishingCredentialsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientBeginListPublishingCredentialsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ListPublishingProfileXMLWithSecrets - Description for Gets the publishing profile for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - publishingProfileOptions - Specifies publishingProfileOptions for publishing profile. For example, use {"format": "FileZilla3"}
//     to get a FileZilla publishing profile.
//   - options - WebAppsClientListPublishingProfileXMLWithSecretsOptions contains the optional parameters for the WebAppsClient.ListPublishingProfileXMLWithSecrets
//     method.
func (client *WebAppsClient) ListPublishingProfileXMLWithSecrets(ctx context.Context, resourceGroupName string, name string, publishingProfileOptions CsmPublishingProfileOptions, options *WebAppsClientListPublishingProfileXMLWithSecretsOptions) (WebAppsClientListPublishingProfileXMLWithSecretsResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListPublishingProfileXMLWithSecrets"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listPublishingProfileXMLWithSecretsCreateRequest(ctx, resourceGroupName, name, publishingProfileOptions, options)
	if err != nil {
		return WebAppsClientListPublishingProfileXMLWithSecretsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListPublishingProfileXMLWithSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListPublishingProfileXMLWithSecretsResponse{}, err
	}
	return WebAppsClientListPublishingProfileXMLWithSecretsResponse{Body: httpResp.Body}, nil
}

// listPublishingProfileXMLWithSecretsCreateRequest creates the ListPublishingProfileXMLWithSecrets request.
func (client *WebAppsClient) listPublishingProfileXMLWithSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, publishingProfileOptions CsmPublishingProfileOptions, options *WebAppsClientListPublishingProfileXMLWithSecretsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/xml"}
	if err := runtime.MarshalAsJSON(req, publishingProfileOptions); err != nil {
		return nil, err
	}
	return req, nil
}

// ListPublishingProfileXMLWithSecretsSlot - Description for Gets the publishing profile for an app (or deployment slot, if
// specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production
//     slot.
//   - publishingProfileOptions - Specifies publishingProfileOptions for publishing profile. For example, use {"format": "FileZilla3"}
//     to get a FileZilla publishing profile.
//   - options - WebAppsClientListPublishingProfileXMLWithSecretsSlotOptions contains the optional parameters for the WebAppsClient.ListPublishingProfileXMLWithSecretsSlot
//     method.
func (client *WebAppsClient) ListPublishingProfileXMLWithSecretsSlot(ctx context.Context, resourceGroupName string, name string, slot string, publishingProfileOptions CsmPublishingProfileOptions, options *WebAppsClientListPublishingProfileXMLWithSecretsSlotOptions) (WebAppsClientListPublishingProfileXMLWithSecretsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListPublishingProfileXMLWithSecretsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listPublishingProfileXMLWithSecretsSlotCreateRequest(ctx, resourceGroupName, name, slot, publishingProfileOptions, options)
	if err != nil {
		return WebAppsClientListPublishingProfileXMLWithSecretsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListPublishingProfileXMLWithSecretsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListPublishingProfileXMLWithSecretsSlotResponse{}, err
	}
	return WebAppsClientListPublishingProfileXMLWithSecretsSlotResponse{Body: httpResp.Body}, nil
}

// listPublishingProfileXMLWithSecretsSlotCreateRequest creates the ListPublishingProfileXMLWithSecretsSlot request.
func (client *WebAppsClient) listPublishingProfileXMLWithSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, publishingProfileOptions CsmPublishingProfileOptions, options *WebAppsClientListPublishingProfileXMLWithSecretsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["Accept"] = []string{"application/xml"}
	if err := runtime.MarshalAsJSON(req, publishingProfileOptions); err != nil {
		return nil, err
	}
	return req, nil
}

// ListRelayServiceConnections - Description for Gets hybrid connections configured for an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListRelayServiceConnectionsOptions contains the optional parameters for the WebAppsClient.ListRelayServiceConnections
//     method.
func (client *WebAppsClient) ListRelayServiceConnections(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListRelayServiceConnectionsOptions) (WebAppsClientListRelayServiceConnectionsResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListRelayServiceConnections"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listRelayServiceConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListRelayServiceConnectionsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListRelayServiceConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListRelayServiceConnectionsResponse{}, err
	}
	resp, err := client.listRelayServiceConnectionsHandleResponse(httpResp)
	return resp, err
}

// listRelayServiceConnectionsCreateRequest creates the ListRelayServiceConnections request.
func (client *WebAppsClient) listRelayServiceConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListRelayServiceConnectionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listRelayServiceConnectionsHandleResponse handles the ListRelayServiceConnections response.
func (client *WebAppsClient) listRelayServiceConnectionsHandleResponse(resp *http.Response) (WebAppsClientListRelayServiceConnectionsResponse, error) {
	result := WebAppsClientListRelayServiceConnectionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsClientListRelayServiceConnectionsResponse{}, err
	}
	return result, nil
}

// ListRelayServiceConnectionsSlot - Description for Gets hybrid connections configured for an app (or deployment slot, if
// specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get hybrid connections for the production
//     slot.
//   - options - WebAppsClientListRelayServiceConnectionsSlotOptions contains the optional parameters for the WebAppsClient.ListRelayServiceConnectionsSlot
//     method.
func (client *WebAppsClient) ListRelayServiceConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListRelayServiceConnectionsSlotOptions) (WebAppsClientListRelayServiceConnectionsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListRelayServiceConnectionsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listRelayServiceConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListRelayServiceConnectionsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListRelayServiceConnectionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListRelayServiceConnectionsSlotResponse{}, err
	}
	resp, err := client.listRelayServiceConnectionsSlotHandleResponse(httpResp)
	return resp, err
}

// listRelayServiceConnectionsSlotCreateRequest creates the ListRelayServiceConnectionsSlot request.
func (client *WebAppsClient) listRelayServiceConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListRelayServiceConnectionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listRelayServiceConnectionsSlotHandleResponse handles the ListRelayServiceConnectionsSlot response.
func (client *WebAppsClient) listRelayServiceConnectionsSlotHandleResponse(resp *http.Response) (WebAppsClientListRelayServiceConnectionsSlotResponse, error) {
	result := WebAppsClientListRelayServiceConnectionsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsClientListRelayServiceConnectionsSlotResponse{}, err
	}
	return result, nil
}

// NewListSiteBackupsPager - Description for Gets existing backups of an app.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListSiteBackupsOptions contains the optional parameters for the WebAppsClient.NewListSiteBackupsPager
//     method.
func (client *WebAppsClient) NewListSiteBackupsPager(resourceGroupName string, name string, options *WebAppsClientListSiteBackupsOptions) *runtime.Pager[WebAppsClientListSiteBackupsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListSiteBackupsResponse]{
		More: func(page WebAppsClientListSiteBackupsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListSiteBackupsResponse) (WebAppsClientListSiteBackupsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListSiteBackupsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSiteBackupsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListSiteBackupsResponse{}, err
			}
			return client.listSiteBackupsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSiteBackupsCreateRequest creates the ListSiteBackups request.
func (client *WebAppsClient) listSiteBackupsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSiteBackupsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listbackups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSiteBackupsHandleResponse handles the ListSiteBackups response.
func (client *WebAppsClient) listSiteBackupsHandleResponse(resp *http.Response) (WebAppsClientListSiteBackupsResponse, error) {
	result := WebAppsClientListSiteBackupsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItemCollection); err != nil {
		return WebAppsClientListSiteBackupsResponse{}, err
	}
	return result, nil
}

// NewListSiteBackupsSlotPager - Description for Gets existing backups of an app.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
//   - options - WebAppsClientListSiteBackupsSlotOptions contains the optional parameters for the WebAppsClient.NewListSiteBackupsSlotPager
//     method.
func (client *WebAppsClient) NewListSiteBackupsSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListSiteBackupsSlotOptions) *runtime.Pager[WebAppsClientListSiteBackupsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListSiteBackupsSlotResponse]{
		More: func(page WebAppsClientListSiteBackupsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListSiteBackupsSlotResponse) (WebAppsClientListSiteBackupsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListSiteBackupsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSiteBackupsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListSiteBackupsSlotResponse{}, err
			}
			return client.listSiteBackupsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSiteBackupsSlotCreateRequest creates the ListSiteBackupsSlot request.
func (client *WebAppsClient) listSiteBackupsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListSiteBackupsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listbackups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSiteBackupsSlotHandleResponse handles the ListSiteBackupsSlot response.
func (client *WebAppsClient) listSiteBackupsSlotHandleResponse(resp *http.Response) (WebAppsClientListSiteBackupsSlotResponse, error) {
	result := WebAppsClientListSiteBackupsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItemCollection); err != nil {
		return WebAppsClientListSiteBackupsSlotResponse{}, err
	}
	return result, nil
}

// NewListSiteExtensionsPager - Description for Get list of siteextensions for a web site, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - options - WebAppsClientListSiteExtensionsOptions contains the optional parameters for the WebAppsClient.NewListSiteExtensionsPager
//     method.
func (client *WebAppsClient) NewListSiteExtensionsPager(resourceGroupName string, name string, options *WebAppsClientListSiteExtensionsOptions) *runtime.Pager[WebAppsClientListSiteExtensionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListSiteExtensionsResponse]{
		More: func(page WebAppsClientListSiteExtensionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListSiteExtensionsResponse) (WebAppsClientListSiteExtensionsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListSiteExtensionsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSiteExtensionsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListSiteExtensionsResponse{}, err
			}
			return client.listSiteExtensionsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSiteExtensionsCreateRequest creates the ListSiteExtensions request.
func (client *WebAppsClient) listSiteExtensionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSiteExtensionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSiteExtensionsHandleResponse handles the ListSiteExtensions response.
func (client *WebAppsClient) listSiteExtensionsHandleResponse(resp *http.Response) (WebAppsClientListSiteExtensionsResponse, error) {
	result := WebAppsClientListSiteExtensionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteExtensionInfoCollection); err != nil {
		return WebAppsClientListSiteExtensionsResponse{}, err
	}
	return result, nil
}

// NewListSiteExtensionsSlotPager - Description for Get list of siteextensions for a web site, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API uses the production slot.
//   - options - WebAppsClientListSiteExtensionsSlotOptions contains the optional parameters for the WebAppsClient.NewListSiteExtensionsSlotPager
//     method.
func (client *WebAppsClient) NewListSiteExtensionsSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListSiteExtensionsSlotOptions) *runtime.Pager[WebAppsClientListSiteExtensionsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListSiteExtensionsSlotResponse]{
		More: func(page WebAppsClientListSiteExtensionsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListSiteExtensionsSlotResponse) (WebAppsClientListSiteExtensionsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListSiteExtensionsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSiteExtensionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListSiteExtensionsSlotResponse{}, err
			}
			return client.listSiteExtensionsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSiteExtensionsSlotCreateRequest creates the ListSiteExtensionsSlot request.
func (client *WebAppsClient) listSiteExtensionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListSiteExtensionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSiteExtensionsSlotHandleResponse handles the ListSiteExtensionsSlot response.
func (client *WebAppsClient) listSiteExtensionsSlotHandleResponse(resp *http.Response) (WebAppsClientListSiteExtensionsSlotResponse, error) {
	result := WebAppsClientListSiteExtensionsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteExtensionInfoCollection); err != nil {
		return WebAppsClientListSiteExtensionsSlotResponse{}, err
	}
	return result, nil
}

// ListSitePushSettings - Description for Gets the Push settings associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientListSitePushSettingsOptions contains the optional parameters for the WebAppsClient.ListSitePushSettings
//     method.
func (client *WebAppsClient) ListSitePushSettings(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSitePushSettingsOptions) (WebAppsClientListSitePushSettingsResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListSitePushSettings"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listSitePushSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListSitePushSettingsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListSitePushSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListSitePushSettingsResponse{}, err
	}
	resp, err := client.listSitePushSettingsHandleResponse(httpResp)
	return resp, err
}

// listSitePushSettingsCreateRequest creates the ListSitePushSettings request.
func (client *WebAppsClient) listSitePushSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSitePushSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSitePushSettingsHandleResponse handles the ListSitePushSettings response.
func (client *WebAppsClient) listSitePushSettingsHandleResponse(resp *http.Response) (WebAppsClientListSitePushSettingsResponse, error) {
	result := WebAppsClientListSitePushSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PushSettings); err != nil {
		return WebAppsClientListSitePushSettingsResponse{}, err
	}
	return result, nil
}

// ListSitePushSettingsSlot - Description for Gets the Push settings associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - options - WebAppsClientListSitePushSettingsSlotOptions contains the optional parameters for the WebAppsClient.ListSitePushSettingsSlot
//     method.
func (client *WebAppsClient) ListSitePushSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListSitePushSettingsSlotOptions) (WebAppsClientListSitePushSettingsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListSitePushSettingsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listSitePushSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListSitePushSettingsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListSitePushSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListSitePushSettingsSlotResponse{}, err
	}
	resp, err := client.listSitePushSettingsSlotHandleResponse(httpResp)
	return resp, err
}

// listSitePushSettingsSlotCreateRequest creates the ListSitePushSettingsSlot request.
func (client *WebAppsClient) listSitePushSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListSitePushSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSitePushSettingsSlotHandleResponse handles the ListSitePushSettingsSlot response.
func (client *WebAppsClient) listSitePushSettingsSlotHandleResponse(resp *http.Response) (WebAppsClientListSitePushSettingsSlotResponse, error) {
	result := WebAppsClientListSitePushSettingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PushSettings); err != nil {
		return WebAppsClientListSitePushSettingsSlotResponse{}, err
	}
	return result, nil
}

// ListSlotConfigurationNames - Description for Gets the names of app settings and connection strings that stick to the slot
// (not swapped).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListSlotConfigurationNamesOptions contains the optional parameters for the WebAppsClient.ListSlotConfigurationNames
//     method.
func (client *WebAppsClient) ListSlotConfigurationNames(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSlotConfigurationNamesOptions) (WebAppsClientListSlotConfigurationNamesResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListSlotConfigurationNames"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listSlotConfigurationNamesCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListSlotConfigurationNamesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListSlotConfigurationNamesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListSlotConfigurationNamesResponse{}, err
	}
	resp, err := client.listSlotConfigurationNamesHandleResponse(httpResp)
	return resp, err
}

// listSlotConfigurationNamesCreateRequest creates the ListSlotConfigurationNames request.
func (client *WebAppsClient) listSlotConfigurationNamesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSlotConfigurationNamesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSlotConfigurationNamesHandleResponse handles the ListSlotConfigurationNames response.
func (client *WebAppsClient) listSlotConfigurationNamesHandleResponse(resp *http.Response) (WebAppsClientListSlotConfigurationNamesResponse, error) {
	result := WebAppsClientListSlotConfigurationNamesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SlotConfigNamesResource); err != nil {
		return WebAppsClientListSlotConfigurationNamesResponse{}, err
	}
	return result, nil
}

// NewListSlotDifferencesFromProductionPager - Description for Get the difference in configuration settings between two web
// app slots.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slotSwapEntity - JSON object that contains the target slot name. See example.
//   - options - WebAppsClientListSlotDifferencesFromProductionOptions contains the optional parameters for the WebAppsClient.NewListSlotDifferencesFromProductionPager
//     method.
func (client *WebAppsClient) NewListSlotDifferencesFromProductionPager(resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsClientListSlotDifferencesFromProductionOptions) *runtime.Pager[WebAppsClientListSlotDifferencesFromProductionResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListSlotDifferencesFromProductionResponse]{
		More: func(page WebAppsClientListSlotDifferencesFromProductionResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListSlotDifferencesFromProductionResponse) (WebAppsClientListSlotDifferencesFromProductionResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListSlotDifferencesFromProductionPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSlotDifferencesFromProductionCreateRequest(ctx, resourceGroupName, name, slotSwapEntity, options)
			}, nil)
			if err != nil {
				return WebAppsClientListSlotDifferencesFromProductionResponse{}, err
			}
			return client.listSlotDifferencesFromProductionHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSlotDifferencesFromProductionCreateRequest creates the ListSlotDifferencesFromProduction request.
func (client *WebAppsClient) listSlotDifferencesFromProductionCreateRequest(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsClientListSlotDifferencesFromProductionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, slotSwapEntity); err != nil {
		return nil, err
	}
	return req, nil
}

// listSlotDifferencesFromProductionHandleResponse handles the ListSlotDifferencesFromProduction response.
func (client *WebAppsClient) listSlotDifferencesFromProductionHandleResponse(resp *http.Response) (WebAppsClientListSlotDifferencesFromProductionResponse, error) {
	result := WebAppsClientListSlotDifferencesFromProductionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SlotDifferenceCollection); err != nil {
		return WebAppsClientListSlotDifferencesFromProductionResponse{}, err
	}
	return result, nil
}

// NewListSlotDifferencesSlotPager - Description for Get the difference in configuration settings between two web app slots.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
//   - slotSwapEntity - JSON object that contains the target slot name. See example.
//   - options - WebAppsClientListSlotDifferencesSlotOptions contains the optional parameters for the WebAppsClient.NewListSlotDifferencesSlotPager
//     method.
func (client *WebAppsClient) NewListSlotDifferencesSlotPager(resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsClientListSlotDifferencesSlotOptions) *runtime.Pager[WebAppsClientListSlotDifferencesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListSlotDifferencesSlotResponse]{
		More: func(page WebAppsClientListSlotDifferencesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListSlotDifferencesSlotResponse) (WebAppsClientListSlotDifferencesSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListSlotDifferencesSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSlotDifferencesSlotCreateRequest(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
			}, nil)
			if err != nil {
				return WebAppsClientListSlotDifferencesSlotResponse{}, err
			}
			return client.listSlotDifferencesSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSlotDifferencesSlotCreateRequest creates the ListSlotDifferencesSlot request.
func (client *WebAppsClient) listSlotDifferencesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsClientListSlotDifferencesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, slotSwapEntity); err != nil {
		return nil, err
	}
	return req, nil
}

// listSlotDifferencesSlotHandleResponse handles the ListSlotDifferencesSlot response.
func (client *WebAppsClient) listSlotDifferencesSlotHandleResponse(resp *http.Response) (WebAppsClientListSlotDifferencesSlotResponse, error) {
	result := WebAppsClientListSlotDifferencesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SlotDifferenceCollection); err != nil {
		return WebAppsClientListSlotDifferencesSlotResponse{}, err
	}
	return result, nil
}

// NewListSlotSiteDeploymentStatusesSlotPager - List deployment statuses for an app (or deployment slot, if specified).
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get the deployment status for the production
//     slot.
//   - options - WebAppsClientListSlotSiteDeploymentStatusesSlotOptions contains the optional parameters for the WebAppsClient.NewListSlotSiteDeploymentStatusesSlotPager
//     method.
func (client *WebAppsClient) NewListSlotSiteDeploymentStatusesSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListSlotSiteDeploymentStatusesSlotOptions) *runtime.Pager[WebAppsClientListSlotSiteDeploymentStatusesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListSlotSiteDeploymentStatusesSlotResponse]{
		More: func(page WebAppsClientListSlotSiteDeploymentStatusesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListSlotSiteDeploymentStatusesSlotResponse) (WebAppsClientListSlotSiteDeploymentStatusesSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListSlotSiteDeploymentStatusesSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSlotSiteDeploymentStatusesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListSlotSiteDeploymentStatusesSlotResponse{}, err
			}
			return client.listSlotSiteDeploymentStatusesSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSlotSiteDeploymentStatusesSlotCreateRequest creates the ListSlotSiteDeploymentStatusesSlot request.
func (client *WebAppsClient) listSlotSiteDeploymentStatusesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListSlotSiteDeploymentStatusesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deploymentStatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSlotSiteDeploymentStatusesSlotHandleResponse handles the ListSlotSiteDeploymentStatusesSlot response.
func (client *WebAppsClient) listSlotSiteDeploymentStatusesSlotHandleResponse(resp *http.Response) (WebAppsClientListSlotSiteDeploymentStatusesSlotResponse, error) {
	result := WebAppsClientListSlotSiteDeploymentStatusesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmDeploymentStatusCollection); err != nil {
		return WebAppsClientListSlotSiteDeploymentStatusesSlotResponse{}, err
	}
	return result, nil
}

// NewListSlotsPager - Description for Gets an app's deployment slots.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListSlotsOptions contains the optional parameters for the WebAppsClient.NewListSlotsPager method.
func (client *WebAppsClient) NewListSlotsPager(resourceGroupName string, name string, options *WebAppsClientListSlotsOptions) *runtime.Pager[WebAppsClientListSlotsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListSlotsResponse]{
		More: func(page WebAppsClientListSlotsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListSlotsResponse) (WebAppsClientListSlotsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListSlotsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSlotsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListSlotsResponse{}, err
			}
			return client.listSlotsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSlotsCreateRequest creates the ListSlots request.
func (client *WebAppsClient) listSlotsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSlotsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSlotsHandleResponse handles the ListSlots response.
func (client *WebAppsClient) listSlotsHandleResponse(resp *http.Response) (WebAppsClientListSlotsResponse, error) {
	result := WebAppsClientListSlotsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return WebAppsClientListSlotsResponse{}, err
	}
	return result, nil
}

// NewListSnapshotsPager - Description for Returns all Snapshots to the user.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Website Name.
//   - options - WebAppsClientListSnapshotsOptions contains the optional parameters for the WebAppsClient.NewListSnapshotsPager
//     method.
func (client *WebAppsClient) NewListSnapshotsPager(resourceGroupName string, name string, options *WebAppsClientListSnapshotsOptions) *runtime.Pager[WebAppsClientListSnapshotsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListSnapshotsResponse]{
		More: func(page WebAppsClientListSnapshotsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListSnapshotsResponse) (WebAppsClientListSnapshotsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListSnapshotsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSnapshotsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListSnapshotsResponse{}, err
			}
			return client.listSnapshotsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSnapshotsCreateRequest creates the ListSnapshots request.
func (client *WebAppsClient) listSnapshotsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSnapshotsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSnapshotsHandleResponse handles the ListSnapshots response.
func (client *WebAppsClient) listSnapshotsHandleResponse(resp *http.Response) (WebAppsClientListSnapshotsResponse, error) {
	result := WebAppsClientListSnapshotsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SnapshotCollection); err != nil {
		return WebAppsClientListSnapshotsResponse{}, err
	}
	return result, nil
}

// NewListSnapshotsFromDRSecondaryPager - Description for Returns all Snapshots to the user from DRSecondary endpoint.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Website Name.
//   - options - WebAppsClientListSnapshotsFromDRSecondaryOptions contains the optional parameters for the WebAppsClient.NewListSnapshotsFromDRSecondaryPager
//     method.
func (client *WebAppsClient) NewListSnapshotsFromDRSecondaryPager(resourceGroupName string, name string, options *WebAppsClientListSnapshotsFromDRSecondaryOptions) *runtime.Pager[WebAppsClientListSnapshotsFromDRSecondaryResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListSnapshotsFromDRSecondaryResponse]{
		More: func(page WebAppsClientListSnapshotsFromDRSecondaryResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListSnapshotsFromDRSecondaryResponse) (WebAppsClientListSnapshotsFromDRSecondaryResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListSnapshotsFromDRSecondaryPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSnapshotsFromDRSecondaryCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListSnapshotsFromDRSecondaryResponse{}, err
			}
			return client.listSnapshotsFromDRSecondaryHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSnapshotsFromDRSecondaryCreateRequest creates the ListSnapshotsFromDRSecondary request.
func (client *WebAppsClient) listSnapshotsFromDRSecondaryCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSnapshotsFromDRSecondaryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshotsdr"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSnapshotsFromDRSecondaryHandleResponse handles the ListSnapshotsFromDRSecondary response.
func (client *WebAppsClient) listSnapshotsFromDRSecondaryHandleResponse(resp *http.Response) (WebAppsClientListSnapshotsFromDRSecondaryResponse, error) {
	result := WebAppsClientListSnapshotsFromDRSecondaryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SnapshotCollection); err != nil {
		return WebAppsClientListSnapshotsFromDRSecondaryResponse{}, err
	}
	return result, nil
}

// NewListSnapshotsFromDRSecondarySlotPager - Description for Returns all Snapshots to the user from DRSecondary endpoint.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Website Name.
//   - slot - Website Slot.
//   - options - WebAppsClientListSnapshotsFromDRSecondarySlotOptions contains the optional parameters for the WebAppsClient.NewListSnapshotsFromDRSecondarySlotPager
//     method.
func (client *WebAppsClient) NewListSnapshotsFromDRSecondarySlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListSnapshotsFromDRSecondarySlotOptions) *runtime.Pager[WebAppsClientListSnapshotsFromDRSecondarySlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListSnapshotsFromDRSecondarySlotResponse]{
		More: func(page WebAppsClientListSnapshotsFromDRSecondarySlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListSnapshotsFromDRSecondarySlotResponse) (WebAppsClientListSnapshotsFromDRSecondarySlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListSnapshotsFromDRSecondarySlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSnapshotsFromDRSecondarySlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListSnapshotsFromDRSecondarySlotResponse{}, err
			}
			return client.listSnapshotsFromDRSecondarySlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSnapshotsFromDRSecondarySlotCreateRequest creates the ListSnapshotsFromDRSecondarySlot request.
func (client *WebAppsClient) listSnapshotsFromDRSecondarySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListSnapshotsFromDRSecondarySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshotsdr"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSnapshotsFromDRSecondarySlotHandleResponse handles the ListSnapshotsFromDRSecondarySlot response.
func (client *WebAppsClient) listSnapshotsFromDRSecondarySlotHandleResponse(resp *http.Response) (WebAppsClientListSnapshotsFromDRSecondarySlotResponse, error) {
	result := WebAppsClientListSnapshotsFromDRSecondarySlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SnapshotCollection); err != nil {
		return WebAppsClientListSnapshotsFromDRSecondarySlotResponse{}, err
	}
	return result, nil
}

// NewListSnapshotsSlotPager - Description for Returns all Snapshots to the user.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Website Name.
//   - slot - Website Slot.
//   - options - WebAppsClientListSnapshotsSlotOptions contains the optional parameters for the WebAppsClient.NewListSnapshotsSlotPager
//     method.
func (client *WebAppsClient) NewListSnapshotsSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListSnapshotsSlotOptions) *runtime.Pager[WebAppsClientListSnapshotsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListSnapshotsSlotResponse]{
		More: func(page WebAppsClientListSnapshotsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListSnapshotsSlotResponse) (WebAppsClientListSnapshotsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListSnapshotsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSnapshotsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListSnapshotsSlotResponse{}, err
			}
			return client.listSnapshotsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSnapshotsSlotCreateRequest creates the ListSnapshotsSlot request.
func (client *WebAppsClient) listSnapshotsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListSnapshotsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSnapshotsSlotHandleResponse handles the ListSnapshotsSlot response.
func (client *WebAppsClient) listSnapshotsSlotHandleResponse(resp *http.Response) (WebAppsClientListSnapshotsSlotResponse, error) {
	result := WebAppsClientListSnapshotsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SnapshotCollection); err != nil {
		return WebAppsClientListSnapshotsSlotResponse{}, err
	}
	return result, nil
}

// ListSyncFunctionTriggers - Description for This is to allow calling via powershell and ARM template.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListSyncFunctionTriggersOptions contains the optional parameters for the WebAppsClient.ListSyncFunctionTriggers
//     method.
func (client *WebAppsClient) ListSyncFunctionTriggers(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSyncFunctionTriggersOptions) (WebAppsClientListSyncFunctionTriggersResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListSyncFunctionTriggers"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listSyncFunctionTriggersCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListSyncFunctionTriggersResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListSyncFunctionTriggersResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListSyncFunctionTriggersResponse{}, err
	}
	resp, err := client.listSyncFunctionTriggersHandleResponse(httpResp)
	return resp, err
}

// listSyncFunctionTriggersCreateRequest creates the ListSyncFunctionTriggers request.
func (client *WebAppsClient) listSyncFunctionTriggersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSyncFunctionTriggersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listsyncfunctiontriggerstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSyncFunctionTriggersHandleResponse handles the ListSyncFunctionTriggers response.
func (client *WebAppsClient) listSyncFunctionTriggersHandleResponse(resp *http.Response) (WebAppsClientListSyncFunctionTriggersResponse, error) {
	result := WebAppsClientListSyncFunctionTriggersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionSecrets); err != nil {
		return WebAppsClientListSyncFunctionTriggersResponse{}, err
	}
	return result, nil
}

// ListSyncFunctionTriggersSlot - Description for This is to allow calling via powershell and ARM template.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientListSyncFunctionTriggersSlotOptions contains the optional parameters for the WebAppsClient.ListSyncFunctionTriggersSlot
//     method.
func (client *WebAppsClient) ListSyncFunctionTriggersSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListSyncFunctionTriggersSlotOptions) (WebAppsClientListSyncFunctionTriggersSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListSyncFunctionTriggersSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listSyncFunctionTriggersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListSyncFunctionTriggersSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListSyncFunctionTriggersSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListSyncFunctionTriggersSlotResponse{}, err
	}
	resp, err := client.listSyncFunctionTriggersSlotHandleResponse(httpResp)
	return resp, err
}

// listSyncFunctionTriggersSlotCreateRequest creates the ListSyncFunctionTriggersSlot request.
func (client *WebAppsClient) listSyncFunctionTriggersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListSyncFunctionTriggersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listsyncfunctiontriggerstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSyncFunctionTriggersSlotHandleResponse handles the ListSyncFunctionTriggersSlot response.
func (client *WebAppsClient) listSyncFunctionTriggersSlotHandleResponse(resp *http.Response) (WebAppsClientListSyncFunctionTriggersSlotResponse, error) {
	result := WebAppsClientListSyncFunctionTriggersSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionSecrets); err != nil {
		return WebAppsClientListSyncFunctionTriggersSlotResponse{}, err
	}
	return result, nil
}

// ListSyncStatus - Description for This is to allow calling via powershell and ARM template.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListSyncStatusOptions contains the optional parameters for the WebAppsClient.ListSyncStatus method.
func (client *WebAppsClient) ListSyncStatus(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSyncStatusOptions) (WebAppsClientListSyncStatusResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListSyncStatus"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listSyncStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListSyncStatusResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListSyncStatusResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListSyncStatusResponse{}, err
	}
	return WebAppsClientListSyncStatusResponse{}, nil
}

// listSyncStatusCreateRequest creates the ListSyncStatus request.
func (client *WebAppsClient) listSyncStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListSyncStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/listsyncstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ListSyncStatusSlot - Description for This is to allow calling via powershell and ARM template.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientListSyncStatusSlotOptions contains the optional parameters for the WebAppsClient.ListSyncStatusSlot
//     method.
func (client *WebAppsClient) ListSyncStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListSyncStatusSlotOptions) (WebAppsClientListSyncStatusSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListSyncStatusSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listSyncStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListSyncStatusSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListSyncStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListSyncStatusSlotResponse{}, err
	}
	return WebAppsClientListSyncStatusSlotResponse{}, nil
}

// listSyncStatusSlotCreateRequest creates the ListSyncStatusSlot request.
func (client *WebAppsClient) listSyncStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListSyncStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/listsyncstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// NewListTriggeredWebJobHistoryPager - Description for List a triggered web job's history for an app, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - options - WebAppsClientListTriggeredWebJobHistoryOptions contains the optional parameters for the WebAppsClient.NewListTriggeredWebJobHistoryPager
//     method.
func (client *WebAppsClient) NewListTriggeredWebJobHistoryPager(resourceGroupName string, name string, webJobName string, options *WebAppsClientListTriggeredWebJobHistoryOptions) *runtime.Pager[WebAppsClientListTriggeredWebJobHistoryResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListTriggeredWebJobHistoryResponse]{
		More: func(page WebAppsClientListTriggeredWebJobHistoryResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListTriggeredWebJobHistoryResponse) (WebAppsClientListTriggeredWebJobHistoryResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListTriggeredWebJobHistoryPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listTriggeredWebJobHistoryCreateRequest(ctx, resourceGroupName, name, webJobName, options)
			}, nil)
			if err != nil {
				return WebAppsClientListTriggeredWebJobHistoryResponse{}, err
			}
			return client.listTriggeredWebJobHistoryHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listTriggeredWebJobHistoryCreateRequest creates the ListTriggeredWebJobHistory request.
func (client *WebAppsClient) listTriggeredWebJobHistoryCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientListTriggeredWebJobHistoryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listTriggeredWebJobHistoryHandleResponse handles the ListTriggeredWebJobHistory response.
func (client *WebAppsClient) listTriggeredWebJobHistoryHandleResponse(resp *http.Response) (WebAppsClientListTriggeredWebJobHistoryResponse, error) {
	result := WebAppsClientListTriggeredWebJobHistoryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredJobHistoryCollection); err != nil {
		return WebAppsClientListTriggeredWebJobHistoryResponse{}, err
	}
	return result, nil
}

// NewListTriggeredWebJobHistorySlotPager - Description for List a triggered web job's history for an app, or a deployment
// slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - slot - Name of the deployment slot. If a slot is not specified, the API uses the production slot.
//   - options - WebAppsClientListTriggeredWebJobHistorySlotOptions contains the optional parameters for the WebAppsClient.NewListTriggeredWebJobHistorySlotPager
//     method.
func (client *WebAppsClient) NewListTriggeredWebJobHistorySlotPager(resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientListTriggeredWebJobHistorySlotOptions) *runtime.Pager[WebAppsClientListTriggeredWebJobHistorySlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListTriggeredWebJobHistorySlotResponse]{
		More: func(page WebAppsClientListTriggeredWebJobHistorySlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListTriggeredWebJobHistorySlotResponse) (WebAppsClientListTriggeredWebJobHistorySlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListTriggeredWebJobHistorySlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listTriggeredWebJobHistorySlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListTriggeredWebJobHistorySlotResponse{}, err
			}
			return client.listTriggeredWebJobHistorySlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listTriggeredWebJobHistorySlotCreateRequest creates the ListTriggeredWebJobHistorySlot request.
func (client *WebAppsClient) listTriggeredWebJobHistorySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientListTriggeredWebJobHistorySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listTriggeredWebJobHistorySlotHandleResponse handles the ListTriggeredWebJobHistorySlot response.
func (client *WebAppsClient) listTriggeredWebJobHistorySlotHandleResponse(resp *http.Response) (WebAppsClientListTriggeredWebJobHistorySlotResponse, error) {
	result := WebAppsClientListTriggeredWebJobHistorySlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredJobHistoryCollection); err != nil {
		return WebAppsClientListTriggeredWebJobHistorySlotResponse{}, err
	}
	return result, nil
}

// NewListTriggeredWebJobsPager - Description for List triggered web jobs for an app, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - options - WebAppsClientListTriggeredWebJobsOptions contains the optional parameters for the WebAppsClient.NewListTriggeredWebJobsPager
//     method.
func (client *WebAppsClient) NewListTriggeredWebJobsPager(resourceGroupName string, name string, options *WebAppsClientListTriggeredWebJobsOptions) *runtime.Pager[WebAppsClientListTriggeredWebJobsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListTriggeredWebJobsResponse]{
		More: func(page WebAppsClientListTriggeredWebJobsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListTriggeredWebJobsResponse) (WebAppsClientListTriggeredWebJobsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListTriggeredWebJobsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listTriggeredWebJobsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListTriggeredWebJobsResponse{}, err
			}
			return client.listTriggeredWebJobsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listTriggeredWebJobsCreateRequest creates the ListTriggeredWebJobs request.
func (client *WebAppsClient) listTriggeredWebJobsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListTriggeredWebJobsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listTriggeredWebJobsHandleResponse handles the ListTriggeredWebJobs response.
func (client *WebAppsClient) listTriggeredWebJobsHandleResponse(resp *http.Response) (WebAppsClientListTriggeredWebJobsResponse, error) {
	result := WebAppsClientListTriggeredWebJobsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredWebJobCollection); err != nil {
		return WebAppsClientListTriggeredWebJobsResponse{}, err
	}
	return result, nil
}

// NewListTriggeredWebJobsSlotPager - Description for List triggered web jobs for an app, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
//   - options - WebAppsClientListTriggeredWebJobsSlotOptions contains the optional parameters for the WebAppsClient.NewListTriggeredWebJobsSlotPager
//     method.
func (client *WebAppsClient) NewListTriggeredWebJobsSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListTriggeredWebJobsSlotOptions) *runtime.Pager[WebAppsClientListTriggeredWebJobsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListTriggeredWebJobsSlotResponse]{
		More: func(page WebAppsClientListTriggeredWebJobsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListTriggeredWebJobsSlotResponse) (WebAppsClientListTriggeredWebJobsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListTriggeredWebJobsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listTriggeredWebJobsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListTriggeredWebJobsSlotResponse{}, err
			}
			return client.listTriggeredWebJobsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listTriggeredWebJobsSlotCreateRequest creates the ListTriggeredWebJobsSlot request.
func (client *WebAppsClient) listTriggeredWebJobsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListTriggeredWebJobsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listTriggeredWebJobsSlotHandleResponse handles the ListTriggeredWebJobsSlot response.
func (client *WebAppsClient) listTriggeredWebJobsSlotHandleResponse(resp *http.Response) (WebAppsClientListTriggeredWebJobsSlotResponse, error) {
	result := WebAppsClientListTriggeredWebJobsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredWebJobCollection); err != nil {
		return WebAppsClientListTriggeredWebJobsSlotResponse{}, err
	}
	return result, nil
}

// NewListUsagesPager - Description for Gets the quota usage information of an app (or deployment slot, if specified).
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListUsagesOptions contains the optional parameters for the WebAppsClient.NewListUsagesPager method.
func (client *WebAppsClient) NewListUsagesPager(resourceGroupName string, name string, options *WebAppsClientListUsagesOptions) *runtime.Pager[WebAppsClientListUsagesResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListUsagesResponse]{
		More: func(page WebAppsClientListUsagesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListUsagesResponse) (WebAppsClientListUsagesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListUsagesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listUsagesCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListUsagesResponse{}, err
			}
			return client.listUsagesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listUsagesCreateRequest creates the ListUsages request.
func (client *WebAppsClient) listUsagesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListUsagesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listUsagesHandleResponse handles the ListUsages response.
func (client *WebAppsClient) listUsagesHandleResponse(resp *http.Response) (WebAppsClientListUsagesResponse, error) {
	result := WebAppsClientListUsagesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmUsageQuotaCollection); err != nil {
		return WebAppsClientListUsagesResponse{}, err
	}
	return result, nil
}

// NewListUsagesSlotPager - Description for Gets the quota usage information of an app (or deployment slot, if specified).
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
//   - options - WebAppsClientListUsagesSlotOptions contains the optional parameters for the WebAppsClient.NewListUsagesSlotPager
//     method.
func (client *WebAppsClient) NewListUsagesSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListUsagesSlotOptions) *runtime.Pager[WebAppsClientListUsagesSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListUsagesSlotResponse]{
		More: func(page WebAppsClientListUsagesSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListUsagesSlotResponse) (WebAppsClientListUsagesSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListUsagesSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listUsagesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListUsagesSlotResponse{}, err
			}
			return client.listUsagesSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listUsagesSlotCreateRequest creates the ListUsagesSlot request.
func (client *WebAppsClient) listUsagesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListUsagesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listUsagesSlotHandleResponse handles the ListUsagesSlot response.
func (client *WebAppsClient) listUsagesSlotHandleResponse(resp *http.Response) (WebAppsClientListUsagesSlotResponse, error) {
	result := WebAppsClientListUsagesSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmUsageQuotaCollection); err != nil {
		return WebAppsClientListUsagesSlotResponse{}, err
	}
	return result, nil
}

// ListVnetConnections - Description for Gets the virtual networks the app (or deployment slot) is connected to.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientListVnetConnectionsOptions contains the optional parameters for the WebAppsClient.ListVnetConnections
//     method.
func (client *WebAppsClient) ListVnetConnections(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListVnetConnectionsOptions) (WebAppsClientListVnetConnectionsResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListVnetConnections"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listVnetConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListVnetConnectionsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListVnetConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListVnetConnectionsResponse{}, err
	}
	resp, err := client.listVnetConnectionsHandleResponse(httpResp)
	return resp, err
}

// listVnetConnectionsCreateRequest creates the ListVnetConnections request.
func (client *WebAppsClient) listVnetConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListVnetConnectionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listVnetConnectionsHandleResponse handles the ListVnetConnections response.
func (client *WebAppsClient) listVnetConnectionsHandleResponse(resp *http.Response) (WebAppsClientListVnetConnectionsResponse, error) {
	result := WebAppsClientListVnetConnectionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResourceArray); err != nil {
		return WebAppsClientListVnetConnectionsResponse{}, err
	}
	return result, nil
}

// ListVnetConnectionsSlot - Description for Gets the virtual networks the app (or deployment slot) is connected to.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will get virtual network connections for the production
//     slot.
//   - options - WebAppsClientListVnetConnectionsSlotOptions contains the optional parameters for the WebAppsClient.ListVnetConnectionsSlot
//     method.
func (client *WebAppsClient) ListVnetConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListVnetConnectionsSlotOptions) (WebAppsClientListVnetConnectionsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListVnetConnectionsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listVnetConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListVnetConnectionsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListVnetConnectionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListVnetConnectionsSlotResponse{}, err
	}
	resp, err := client.listVnetConnectionsSlotHandleResponse(httpResp)
	return resp, err
}

// listVnetConnectionsSlotCreateRequest creates the ListVnetConnectionsSlot request.
func (client *WebAppsClient) listVnetConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListVnetConnectionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listVnetConnectionsSlotHandleResponse handles the ListVnetConnectionsSlot response.
func (client *WebAppsClient) listVnetConnectionsSlotHandleResponse(resp *http.Response) (WebAppsClientListVnetConnectionsSlotResponse, error) {
	result := WebAppsClientListVnetConnectionsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResourceArray); err != nil {
		return WebAppsClientListVnetConnectionsSlotResponse{}, err
	}
	return result, nil
}

// NewListWebJobsPager - Description for List webjobs for an app, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - options - WebAppsClientListWebJobsOptions contains the optional parameters for the WebAppsClient.NewListWebJobsPager method.
func (client *WebAppsClient) NewListWebJobsPager(resourceGroupName string, name string, options *WebAppsClientListWebJobsOptions) *runtime.Pager[WebAppsClientListWebJobsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListWebJobsResponse]{
		More: func(page WebAppsClientListWebJobsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListWebJobsResponse) (WebAppsClientListWebJobsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListWebJobsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listWebJobsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListWebJobsResponse{}, err
			}
			return client.listWebJobsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listWebJobsCreateRequest creates the ListWebJobs request.
func (client *WebAppsClient) listWebJobsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListWebJobsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listWebJobsHandleResponse handles the ListWebJobs response.
func (client *WebAppsClient) listWebJobsHandleResponse(resp *http.Response) (WebAppsClientListWebJobsResponse, error) {
	result := WebAppsClientListWebJobsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebJobCollection); err != nil {
		return WebAppsClientListWebJobsResponse{}, err
	}
	return result, nil
}

// NewListWebJobsSlotPager - Description for List webjobs for an app, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
//   - options - WebAppsClientListWebJobsSlotOptions contains the optional parameters for the WebAppsClient.NewListWebJobsSlotPager
//     method.
func (client *WebAppsClient) NewListWebJobsSlotPager(resourceGroupName string, name string, slot string, options *WebAppsClientListWebJobsSlotOptions) *runtime.Pager[WebAppsClientListWebJobsSlotResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListWebJobsSlotResponse]{
		More: func(page WebAppsClientListWebJobsSlotResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListWebJobsSlotResponse) (WebAppsClientListWebJobsSlotResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListWebJobsSlotPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listWebJobsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
			}, nil)
			if err != nil {
				return WebAppsClientListWebJobsSlotResponse{}, err
			}
			return client.listWebJobsSlotHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listWebJobsSlotCreateRequest creates the ListWebJobsSlot request.
func (client *WebAppsClient) listWebJobsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListWebJobsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listWebJobsSlotHandleResponse handles the ListWebJobsSlot response.
func (client *WebAppsClient) listWebJobsSlotHandleResponse(resp *http.Response) (WebAppsClientListWebJobsSlotResponse, error) {
	result := WebAppsClientListWebJobsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebJobCollection); err != nil {
		return WebAppsClientListWebJobsSlotResponse{}, err
	}
	return result, nil
}

// NewListWorkflowsPager - List the workflows for a web site, or a deployment slot.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - options - WebAppsClientListWorkflowsOptions contains the optional parameters for the WebAppsClient.NewListWorkflowsPager
//     method.
func (client *WebAppsClient) NewListWorkflowsPager(resourceGroupName string, name string, options *WebAppsClientListWorkflowsOptions) *runtime.Pager[WebAppsClientListWorkflowsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebAppsClientListWorkflowsResponse]{
		More: func(page WebAppsClientListWorkflowsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebAppsClientListWorkflowsResponse) (WebAppsClientListWorkflowsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebAppsClient.NewListWorkflowsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listWorkflowsCreateRequest(ctx, resourceGroupName, name, options)
			}, nil)
			if err != nil {
				return WebAppsClientListWorkflowsResponse{}, err
			}
			return client.listWorkflowsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listWorkflowsCreateRequest creates the ListWorkflows request.
func (client *WebAppsClient) listWorkflowsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListWorkflowsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/workflows"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listWorkflowsHandleResponse handles the ListWorkflows response.
func (client *WebAppsClient) listWorkflowsHandleResponse(resp *http.Response) (WebAppsClientListWorkflowsResponse, error) {
	result := WebAppsClientListWorkflowsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkflowEnvelopeCollection); err != nil {
		return WebAppsClientListWorkflowsResponse{}, err
	}
	return result, nil
}

// ListWorkflowsConnections - Lists logic app's connections for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - options - WebAppsClientListWorkflowsConnectionsOptions contains the optional parameters for the WebAppsClient.ListWorkflowsConnections
//     method.
func (client *WebAppsClient) ListWorkflowsConnections(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListWorkflowsConnectionsOptions) (WebAppsClientListWorkflowsConnectionsResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListWorkflowsConnections"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listWorkflowsConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientListWorkflowsConnectionsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListWorkflowsConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListWorkflowsConnectionsResponse{}, err
	}
	resp, err := client.listWorkflowsConnectionsHandleResponse(httpResp)
	return resp, err
}

// listWorkflowsConnectionsCreateRequest creates the ListWorkflowsConnections request.
func (client *WebAppsClient) listWorkflowsConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientListWorkflowsConnectionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listWorkflowsConnections"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listWorkflowsConnectionsHandleResponse handles the ListWorkflowsConnections response.
func (client *WebAppsClient) listWorkflowsConnectionsHandleResponse(resp *http.Response) (WebAppsClientListWorkflowsConnectionsResponse, error) {
	result := WebAppsClientListWorkflowsConnectionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkflowEnvelope); err != nil {
		return WebAppsClientListWorkflowsConnectionsResponse{}, err
	}
	return result, nil
}

// ListWorkflowsConnectionsSlot - Lists logic app's connections for web site, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientListWorkflowsConnectionsSlotOptions contains the optional parameters for the WebAppsClient.ListWorkflowsConnectionsSlot
//     method.
func (client *WebAppsClient) ListWorkflowsConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListWorkflowsConnectionsSlotOptions) (WebAppsClientListWorkflowsConnectionsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ListWorkflowsConnectionsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listWorkflowsConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientListWorkflowsConnectionsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientListWorkflowsConnectionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientListWorkflowsConnectionsSlotResponse{}, err
	}
	resp, err := client.listWorkflowsConnectionsSlotHandleResponse(httpResp)
	return resp, err
}

// listWorkflowsConnectionsSlotCreateRequest creates the ListWorkflowsConnectionsSlot request.
func (client *WebAppsClient) listWorkflowsConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientListWorkflowsConnectionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listWorkflowsConnections"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listWorkflowsConnectionsSlotHandleResponse handles the ListWorkflowsConnectionsSlot response.
func (client *WebAppsClient) listWorkflowsConnectionsSlotHandleResponse(resp *http.Response) (WebAppsClientListWorkflowsConnectionsSlotResponse, error) {
	result := WebAppsClientListWorkflowsConnectionsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkflowEnvelope); err != nil {
		return WebAppsClientListWorkflowsConnectionsSlotResponse{}, err
	}
	return result, nil
}

// BeginMigrateMySQL - Description for Migrates a local (in-app) MySql database to a remote MySql database.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - migrationRequestEnvelope - MySql migration options.
//   - options - WebAppsClientBeginMigrateMySQLOptions contains the optional parameters for the WebAppsClient.BeginMigrateMySQL
//     method.
func (client *WebAppsClient) BeginMigrateMySQL(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest, options *WebAppsClientBeginMigrateMySQLOptions) (*runtime.Poller[WebAppsClientMigrateMySQLResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.migrateMySQL(ctx, resourceGroupName, name, migrationRequestEnvelope, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientMigrateMySQLResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientMigrateMySQLResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// MigrateMySQL - Description for Migrates a local (in-app) MySql database to a remote MySql database.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) migrateMySQL(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest, options *WebAppsClientBeginMigrateMySQLOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginMigrateMySQL"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.migrateMySQLCreateRequest(ctx, resourceGroupName, name, migrationRequestEnvelope, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// migrateMySQLCreateRequest creates the MigrateMySQL request.
func (client *WebAppsClient) migrateMySQLCreateRequest(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest, options *WebAppsClientBeginMigrateMySQLOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, migrationRequestEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginMigrateStorage - Description for Restores a web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - subscriptionName - Azure subscription.
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - migrationOptions - Migration migrationOptions.
//   - options - WebAppsClientBeginMigrateStorageOptions contains the optional parameters for the WebAppsClient.BeginMigrateStorage
//     method.
func (client *WebAppsClient) BeginMigrateStorage(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions, options *WebAppsClientBeginMigrateStorageOptions) (*runtime.Poller[WebAppsClientMigrateStorageResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.migrateStorage(ctx, subscriptionName, resourceGroupName, name, migrationOptions, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientMigrateStorageResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientMigrateStorageResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// MigrateStorage - Description for Restores a web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) migrateStorage(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions, options *WebAppsClientBeginMigrateStorageOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginMigrateStorage"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.migrateStorageCreateRequest(ctx, subscriptionName, resourceGroupName, name, migrationOptions, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// migrateStorageCreateRequest creates the MigrateStorage request.
func (client *WebAppsClient) migrateStorageCreateRequest(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions, options *WebAppsClientBeginMigrateStorageOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("subscriptionName", subscriptionName)
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, migrationOptions); err != nil {
		return nil, err
	}
	return req, nil
}

// PutPrivateAccessVnet - Description for Sets data around private site access enablement and authorized Virtual Networks
// that can access the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - access - The information for the private access
//   - options - WebAppsClientPutPrivateAccessVnetOptions contains the optional parameters for the WebAppsClient.PutPrivateAccessVnet
//     method.
func (client *WebAppsClient) PutPrivateAccessVnet(ctx context.Context, resourceGroupName string, name string, access PrivateAccess, options *WebAppsClientPutPrivateAccessVnetOptions) (WebAppsClientPutPrivateAccessVnetResponse, error) {
	var err error
	const operationName = "WebAppsClient.PutPrivateAccessVnet"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putPrivateAccessVnetCreateRequest(ctx, resourceGroupName, name, access, options)
	if err != nil {
		return WebAppsClientPutPrivateAccessVnetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientPutPrivateAccessVnetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientPutPrivateAccessVnetResponse{}, err
	}
	resp, err := client.putPrivateAccessVnetHandleResponse(httpResp)
	return resp, err
}

// putPrivateAccessVnetCreateRequest creates the PutPrivateAccessVnet request.
func (client *WebAppsClient) putPrivateAccessVnetCreateRequest(ctx context.Context, resourceGroupName string, name string, access PrivateAccess, options *WebAppsClientPutPrivateAccessVnetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, access); err != nil {
		return nil, err
	}
	return req, nil
}

// putPrivateAccessVnetHandleResponse handles the PutPrivateAccessVnet response.
func (client *WebAppsClient) putPrivateAccessVnetHandleResponse(resp *http.Response) (WebAppsClientPutPrivateAccessVnetResponse, error) {
	result := WebAppsClientPutPrivateAccessVnetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateAccess); err != nil {
		return WebAppsClientPutPrivateAccessVnetResponse{}, err
	}
	return result, nil
}

// PutPrivateAccessVnetSlot - Description for Sets data around private site access enablement and authorized Virtual Networks
// that can access the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - slot - The name of the slot for the web app.
//   - access - The information for the private access
//   - options - WebAppsClientPutPrivateAccessVnetSlotOptions contains the optional parameters for the WebAppsClient.PutPrivateAccessVnetSlot
//     method.
func (client *WebAppsClient) PutPrivateAccessVnetSlot(ctx context.Context, resourceGroupName string, name string, slot string, access PrivateAccess, options *WebAppsClientPutPrivateAccessVnetSlotOptions) (WebAppsClientPutPrivateAccessVnetSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.PutPrivateAccessVnetSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putPrivateAccessVnetSlotCreateRequest(ctx, resourceGroupName, name, slot, access, options)
	if err != nil {
		return WebAppsClientPutPrivateAccessVnetSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientPutPrivateAccessVnetSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientPutPrivateAccessVnetSlotResponse{}, err
	}
	resp, err := client.putPrivateAccessVnetSlotHandleResponse(httpResp)
	return resp, err
}

// putPrivateAccessVnetSlotCreateRequest creates the PutPrivateAccessVnetSlot request.
func (client *WebAppsClient) putPrivateAccessVnetSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, access PrivateAccess, options *WebAppsClientPutPrivateAccessVnetSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, access); err != nil {
		return nil, err
	}
	return req, nil
}

// putPrivateAccessVnetSlotHandleResponse handles the PutPrivateAccessVnetSlot response.
func (client *WebAppsClient) putPrivateAccessVnetSlotHandleResponse(resp *http.Response) (WebAppsClientPutPrivateAccessVnetSlotResponse, error) {
	result := WebAppsClientPutPrivateAccessVnetSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateAccess); err != nil {
		return WebAppsClientPutPrivateAccessVnetSlotResponse{}, err
	}
	return result, nil
}

// RecoverSiteConfigurationSnapshot - Description for Reverts the configuration of an app to a previous snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - snapshotID - The ID of the snapshot to read.
//   - options - WebAppsClientRecoverSiteConfigurationSnapshotOptions contains the optional parameters for the WebAppsClient.RecoverSiteConfigurationSnapshot
//     method.
func (client *WebAppsClient) RecoverSiteConfigurationSnapshot(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *WebAppsClientRecoverSiteConfigurationSnapshotOptions) (WebAppsClientRecoverSiteConfigurationSnapshotResponse, error) {
	var err error
	const operationName = "WebAppsClient.RecoverSiteConfigurationSnapshot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.recoverSiteConfigurationSnapshotCreateRequest(ctx, resourceGroupName, name, snapshotID, options)
	if err != nil {
		return WebAppsClientRecoverSiteConfigurationSnapshotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientRecoverSiteConfigurationSnapshotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientRecoverSiteConfigurationSnapshotResponse{}, err
	}
	return WebAppsClientRecoverSiteConfigurationSnapshotResponse{}, nil
}

// recoverSiteConfigurationSnapshotCreateRequest creates the RecoverSiteConfigurationSnapshot request.
func (client *WebAppsClient) recoverSiteConfigurationSnapshotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *WebAppsClientRecoverSiteConfigurationSnapshotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}/recover"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// RecoverSiteConfigurationSnapshotSlot - Description for Reverts the configuration of an app to a previous snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - snapshotID - The ID of the snapshot to read.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
//   - options - WebAppsClientRecoverSiteConfigurationSnapshotSlotOptions contains the optional parameters for the WebAppsClient.RecoverSiteConfigurationSnapshotSlot
//     method.
func (client *WebAppsClient) RecoverSiteConfigurationSnapshotSlot(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *WebAppsClientRecoverSiteConfigurationSnapshotSlotOptions) (WebAppsClientRecoverSiteConfigurationSnapshotSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.RecoverSiteConfigurationSnapshotSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.recoverSiteConfigurationSnapshotSlotCreateRequest(ctx, resourceGroupName, name, snapshotID, slot, options)
	if err != nil {
		return WebAppsClientRecoverSiteConfigurationSnapshotSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientRecoverSiteConfigurationSnapshotSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientRecoverSiteConfigurationSnapshotSlotResponse{}, err
	}
	return WebAppsClientRecoverSiteConfigurationSnapshotSlotResponse{}, nil
}

// recoverSiteConfigurationSnapshotSlotCreateRequest creates the RecoverSiteConfigurationSnapshotSlot request.
func (client *WebAppsClient) recoverSiteConfigurationSnapshotSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *WebAppsClientRecoverSiteConfigurationSnapshotSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}/recover"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ResetProductionSlotConfig - Description for Resets the configuration settings of the current slot if they were previously
// modified by calling the API with POST.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientResetProductionSlotConfigOptions contains the optional parameters for the WebAppsClient.ResetProductionSlotConfig
//     method.
func (client *WebAppsClient) ResetProductionSlotConfig(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientResetProductionSlotConfigOptions) (WebAppsClientResetProductionSlotConfigResponse, error) {
	var err error
	const operationName = "WebAppsClient.ResetProductionSlotConfig"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.resetProductionSlotConfigCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientResetProductionSlotConfigResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientResetProductionSlotConfigResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientResetProductionSlotConfigResponse{}, err
	}
	return WebAppsClientResetProductionSlotConfigResponse{}, nil
}

// resetProductionSlotConfigCreateRequest creates the ResetProductionSlotConfig request.
func (client *WebAppsClient) resetProductionSlotConfigCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientResetProductionSlotConfigOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ResetSlotConfigurationSlot - Description for Resets the configuration settings of the current slot if they were previously
// modified by calling the API with POST.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API resets configuration settings for the production
//     slot.
//   - options - WebAppsClientResetSlotConfigurationSlotOptions contains the optional parameters for the WebAppsClient.ResetSlotConfigurationSlot
//     method.
func (client *WebAppsClient) ResetSlotConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientResetSlotConfigurationSlotOptions) (WebAppsClientResetSlotConfigurationSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.ResetSlotConfigurationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.resetSlotConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientResetSlotConfigurationSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientResetSlotConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientResetSlotConfigurationSlotResponse{}, err
	}
	return WebAppsClientResetSlotConfigurationSlotResponse{}, nil
}

// resetSlotConfigurationSlotCreateRequest creates the ResetSlotConfigurationSlot request.
func (client *WebAppsClient) resetSlotConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientResetSlotConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// Restart - Description for Restarts an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientRestartOptions contains the optional parameters for the WebAppsClient.Restart method.
func (client *WebAppsClient) Restart(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientRestartOptions) (WebAppsClientRestartResponse, error) {
	var err error
	const operationName = "WebAppsClient.Restart"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.restartCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientRestartResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientRestartResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientRestartResponse{}, err
	}
	return WebAppsClientRestartResponse{}, nil
}

// restartCreateRequest creates the Restart request.
func (client *WebAppsClient) restartCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientRestartOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SoftRestart != nil {
		reqQP.Set("softRestart", strconv.FormatBool(*options.SoftRestart))
	}
	if options != nil && options.Synchronous != nil {
		reqQP.Set("synchronous", strconv.FormatBool(*options.Synchronous))
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// RestartSlot - Description for Restarts an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
//   - options - WebAppsClientRestartSlotOptions contains the optional parameters for the WebAppsClient.RestartSlot method.
func (client *WebAppsClient) RestartSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientRestartSlotOptions) (WebAppsClientRestartSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.RestartSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.restartSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientRestartSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientRestartSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientRestartSlotResponse{}, err
	}
	return WebAppsClientRestartSlotResponse{}, nil
}

// restartSlotCreateRequest creates the RestartSlot request.
func (client *WebAppsClient) restartSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientRestartSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SoftRestart != nil {
		reqQP.Set("softRestart", strconv.FormatBool(*options.SoftRestart))
	}
	if options != nil && options.Synchronous != nil {
		reqQP.Set("synchronous", strconv.FormatBool(*options.Synchronous))
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginRestore - Description for Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - backupID - ID of the backup.
//   - request - Information on restore request .
//   - options - WebAppsClientBeginRestoreOptions contains the optional parameters for the WebAppsClient.BeginRestore method.
func (client *WebAppsClient) BeginRestore(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, options *WebAppsClientBeginRestoreOptions) (*runtime.Poller[WebAppsClientRestoreResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restore(ctx, resourceGroupName, name, backupID, request, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientRestoreResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientRestoreResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Restore - Description for Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) restore(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, options *WebAppsClientBeginRestoreOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginRestore"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.restoreCreateRequest(ctx, resourceGroupName, name, backupID, request, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// restoreCreateRequest creates the Restore request.
func (client *WebAppsClient) restoreCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, options *WebAppsClientBeginRestoreOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginRestoreFromBackupBlob - Description for Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - request - Information on restore request .
//   - options - WebAppsClientBeginRestoreFromBackupBlobOptions contains the optional parameters for the WebAppsClient.BeginRestoreFromBackupBlob
//     method.
func (client *WebAppsClient) BeginRestoreFromBackupBlob(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsClientBeginRestoreFromBackupBlobOptions) (*runtime.Poller[WebAppsClientRestoreFromBackupBlobResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreFromBackupBlob(ctx, resourceGroupName, name, request, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientRestoreFromBackupBlobResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientRestoreFromBackupBlobResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// RestoreFromBackupBlob - Description for Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) restoreFromBackupBlob(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsClientBeginRestoreFromBackupBlobOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginRestoreFromBackupBlob"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.restoreFromBackupBlobCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// restoreFromBackupBlobCreateRequest creates the RestoreFromBackupBlob request.
func (client *WebAppsClient) restoreFromBackupBlobCreateRequest(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsClientBeginRestoreFromBackupBlobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromBackupBlob"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginRestoreFromBackupBlobSlot - Description for Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
//   - request - Information on restore request .
//   - options - WebAppsClientBeginRestoreFromBackupBlobSlotOptions contains the optional parameters for the WebAppsClient.BeginRestoreFromBackupBlobSlot
//     method.
func (client *WebAppsClient) BeginRestoreFromBackupBlobSlot(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsClientBeginRestoreFromBackupBlobSlotOptions) (*runtime.Poller[WebAppsClientRestoreFromBackupBlobSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreFromBackupBlobSlot(ctx, resourceGroupName, name, slot, request, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientRestoreFromBackupBlobSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientRestoreFromBackupBlobSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// RestoreFromBackupBlobSlot - Description for Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) restoreFromBackupBlobSlot(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsClientBeginRestoreFromBackupBlobSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginRestoreFromBackupBlobSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.restoreFromBackupBlobSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// restoreFromBackupBlobSlotCreateRequest creates the RestoreFromBackupBlobSlot request.
func (client *WebAppsClient) restoreFromBackupBlobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsClientBeginRestoreFromBackupBlobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromBackupBlob"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginRestoreFromDeletedApp - Description for Restores a deleted web app to this web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - restoreRequest - Deleted web app restore information.
//   - options - WebAppsClientBeginRestoreFromDeletedAppOptions contains the optional parameters for the WebAppsClient.BeginRestoreFromDeletedApp
//     method.
func (client *WebAppsClient) BeginRestoreFromDeletedApp(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, options *WebAppsClientBeginRestoreFromDeletedAppOptions) (*runtime.Poller[WebAppsClientRestoreFromDeletedAppResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreFromDeletedApp(ctx, resourceGroupName, name, restoreRequest, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientRestoreFromDeletedAppResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientRestoreFromDeletedAppResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// RestoreFromDeletedApp - Description for Restores a deleted web app to this web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) restoreFromDeletedApp(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, options *WebAppsClientBeginRestoreFromDeletedAppOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginRestoreFromDeletedApp"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.restoreFromDeletedAppCreateRequest(ctx, resourceGroupName, name, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// restoreFromDeletedAppCreateRequest creates the RestoreFromDeletedApp request.
func (client *WebAppsClient) restoreFromDeletedAppCreateRequest(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, options *WebAppsClientBeginRestoreFromDeletedAppOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromDeletedApp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, restoreRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginRestoreFromDeletedAppSlot - Description for Restores a deleted web app to this web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - restoreRequest - Deleted web app restore information.
//   - options - WebAppsClientBeginRestoreFromDeletedAppSlotOptions contains the optional parameters for the WebAppsClient.BeginRestoreFromDeletedAppSlot
//     method.
func (client *WebAppsClient) BeginRestoreFromDeletedAppSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest DeletedAppRestoreRequest, options *WebAppsClientBeginRestoreFromDeletedAppSlotOptions) (*runtime.Poller[WebAppsClientRestoreFromDeletedAppSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreFromDeletedAppSlot(ctx, resourceGroupName, name, slot, restoreRequest, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientRestoreFromDeletedAppSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientRestoreFromDeletedAppSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// RestoreFromDeletedAppSlot - Description for Restores a deleted web app to this web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) restoreFromDeletedAppSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest DeletedAppRestoreRequest, options *WebAppsClientBeginRestoreFromDeletedAppSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginRestoreFromDeletedAppSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.restoreFromDeletedAppSlotCreateRequest(ctx, resourceGroupName, name, slot, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// restoreFromDeletedAppSlotCreateRequest creates the RestoreFromDeletedAppSlot request.
func (client *WebAppsClient) restoreFromDeletedAppSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest DeletedAppRestoreRequest, options *WebAppsClientBeginRestoreFromDeletedAppSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromDeletedApp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, restoreRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginRestoreSlot - Description for Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - backupID - ID of the backup.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
//   - request - Information on restore request .
//   - options - WebAppsClientBeginRestoreSlotOptions contains the optional parameters for the WebAppsClient.BeginRestoreSlot
//     method.
func (client *WebAppsClient) BeginRestoreSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request RestoreRequest, options *WebAppsClientBeginRestoreSlotOptions) (*runtime.Poller[WebAppsClientRestoreSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreSlot(ctx, resourceGroupName, name, backupID, slot, request, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientRestoreSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientRestoreSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// RestoreSlot - Description for Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) restoreSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request RestoreRequest, options *WebAppsClientBeginRestoreSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginRestoreSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.restoreSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, request, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// restoreSlotCreateRequest creates the RestoreSlot request.
func (client *WebAppsClient) restoreSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request RestoreRequest, options *WebAppsClientBeginRestoreSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginRestoreSnapshot - Description for Restores a web app from a snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - restoreRequest - Snapshot restore settings. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots
//     API.
//   - options - WebAppsClientBeginRestoreSnapshotOptions contains the optional parameters for the WebAppsClient.BeginRestoreSnapshot
//     method.
func (client *WebAppsClient) BeginRestoreSnapshot(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, options *WebAppsClientBeginRestoreSnapshotOptions) (*runtime.Poller[WebAppsClientRestoreSnapshotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreSnapshot(ctx, resourceGroupName, name, restoreRequest, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientRestoreSnapshotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientRestoreSnapshotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// RestoreSnapshot - Description for Restores a web app from a snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) restoreSnapshot(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, options *WebAppsClientBeginRestoreSnapshotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginRestoreSnapshot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.restoreSnapshotCreateRequest(ctx, resourceGroupName, name, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// restoreSnapshotCreateRequest creates the RestoreSnapshot request.
func (client *WebAppsClient) restoreSnapshotCreateRequest(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, options *WebAppsClientBeginRestoreSnapshotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreSnapshot"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, restoreRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginRestoreSnapshotSlot - Description for Restores a web app from a snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - restoreRequest - Snapshot restore settings. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots
//     API.
//   - options - WebAppsClientBeginRestoreSnapshotSlotOptions contains the optional parameters for the WebAppsClient.BeginRestoreSnapshotSlot
//     method.
func (client *WebAppsClient) BeginRestoreSnapshotSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest SnapshotRestoreRequest, options *WebAppsClientBeginRestoreSnapshotSlotOptions) (*runtime.Poller[WebAppsClientRestoreSnapshotSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.restoreSnapshotSlot(ctx, resourceGroupName, name, slot, restoreRequest, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientRestoreSnapshotSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientRestoreSnapshotSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// RestoreSnapshotSlot - Description for Restores a web app from a snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) restoreSnapshotSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest SnapshotRestoreRequest, options *WebAppsClientBeginRestoreSnapshotSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginRestoreSnapshotSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.restoreSnapshotSlotCreateRequest(ctx, resourceGroupName, name, slot, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// restoreSnapshotSlotCreateRequest creates the RestoreSnapshotSlot request.
func (client *WebAppsClient) restoreSnapshotSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest SnapshotRestoreRequest, options *WebAppsClientBeginRestoreSnapshotSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreSnapshot"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, restoreRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// RunTriggeredWebJob - Description for Run a triggered web job for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - options - WebAppsClientRunTriggeredWebJobOptions contains the optional parameters for the WebAppsClient.RunTriggeredWebJob
//     method.
func (client *WebAppsClient) RunTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientRunTriggeredWebJobOptions) (WebAppsClientRunTriggeredWebJobResponse, error) {
	var err error
	const operationName = "WebAppsClient.RunTriggeredWebJob"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.runTriggeredWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsClientRunTriggeredWebJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientRunTriggeredWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientRunTriggeredWebJobResponse{}, err
	}
	return WebAppsClientRunTriggeredWebJobResponse{}, nil
}

// runTriggeredWebJobCreateRequest creates the RunTriggeredWebJob request.
func (client *WebAppsClient) runTriggeredWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientRunTriggeredWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/run"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// RunTriggeredWebJobSlot - Description for Run a triggered web job for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - slot - Name of the deployment slot. If a slot is not specified, the API uses the production slot.
//   - options - WebAppsClientRunTriggeredWebJobSlotOptions contains the optional parameters for the WebAppsClient.RunTriggeredWebJobSlot
//     method.
func (client *WebAppsClient) RunTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientRunTriggeredWebJobSlotOptions) (WebAppsClientRunTriggeredWebJobSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.RunTriggeredWebJobSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.runTriggeredWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsClientRunTriggeredWebJobSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientRunTriggeredWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientRunTriggeredWebJobSlotResponse{}, err
	}
	return WebAppsClientRunTriggeredWebJobSlotResponse{}, nil
}

// runTriggeredWebJobSlotCreateRequest creates the RunTriggeredWebJobSlot request.
func (client *WebAppsClient) runTriggeredWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientRunTriggeredWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/run"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// Start - Description for Starts an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientStartOptions contains the optional parameters for the WebAppsClient.Start method.
func (client *WebAppsClient) Start(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientStartOptions) (WebAppsClientStartResponse, error) {
	var err error
	const operationName = "WebAppsClient.Start"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.startCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientStartResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStartResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStartResponse{}, err
	}
	return WebAppsClientStartResponse{}, nil
}

// startCreateRequest creates the Start request.
func (client *WebAppsClient) startCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientStartOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StartContinuousWebJob - Description for Start a continuous web job for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - options - WebAppsClientStartContinuousWebJobOptions contains the optional parameters for the WebAppsClient.StartContinuousWebJob
//     method.
func (client *WebAppsClient) StartContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientStartContinuousWebJobOptions) (WebAppsClientStartContinuousWebJobResponse, error) {
	var err error
	const operationName = "WebAppsClient.StartContinuousWebJob"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.startContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsClientStartContinuousWebJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStartContinuousWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStartContinuousWebJobResponse{}, err
	}
	return WebAppsClientStartContinuousWebJobResponse{}, nil
}

// startContinuousWebJobCreateRequest creates the StartContinuousWebJob request.
func (client *WebAppsClient) startContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientStartContinuousWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StartContinuousWebJobSlot - Description for Start a continuous web job for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
//   - options - WebAppsClientStartContinuousWebJobSlotOptions contains the optional parameters for the WebAppsClient.StartContinuousWebJobSlot
//     method.
func (client *WebAppsClient) StartContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientStartContinuousWebJobSlotOptions) (WebAppsClientStartContinuousWebJobSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.StartContinuousWebJobSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.startContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsClientStartContinuousWebJobSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStartContinuousWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStartContinuousWebJobSlotResponse{}, err
	}
	return WebAppsClientStartContinuousWebJobSlotResponse{}, nil
}

// startContinuousWebJobSlotCreateRequest creates the StartContinuousWebJobSlot request.
func (client *WebAppsClient) startContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientStartContinuousWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginStartNetworkTrace - Description for Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - options - WebAppsClientBeginStartNetworkTraceOptions contains the optional parameters for the WebAppsClient.BeginStartNetworkTrace
//     method.
func (client *WebAppsClient) BeginStartNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientBeginStartNetworkTraceOptions) (*runtime.Poller[WebAppsClientStartNetworkTraceResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.startNetworkTrace(ctx, resourceGroupName, name, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientStartNetworkTraceResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientStartNetworkTraceResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// StartNetworkTrace - Description for Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) startNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientBeginStartNetworkTraceOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginStartNetworkTrace"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.startNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// startNetworkTraceCreateRequest creates the StartNetworkTrace request.
func (client *WebAppsClient) startNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientBeginStartNetworkTraceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/startNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginStartNetworkTraceSlot - Description for Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - slot - The name of the slot for this web app.
//   - options - WebAppsClientBeginStartNetworkTraceSlotOptions contains the optional parameters for the WebAppsClient.BeginStartNetworkTraceSlot
//     method.
func (client *WebAppsClient) BeginStartNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientBeginStartNetworkTraceSlotOptions) (*runtime.Poller[WebAppsClientStartNetworkTraceSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.startNetworkTraceSlot(ctx, resourceGroupName, name, slot, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientStartNetworkTraceSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientStartNetworkTraceSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// StartNetworkTraceSlot - Description for Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) startNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientBeginStartNetworkTraceSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginStartNetworkTraceSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.startNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// startNetworkTraceSlotCreateRequest creates the StartNetworkTraceSlot request.
func (client *WebAppsClient) startNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientBeginStartNetworkTraceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/startNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StartSlot - Description for Starts an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will start the production slot.
//   - options - WebAppsClientStartSlotOptions contains the optional parameters for the WebAppsClient.StartSlot method.
func (client *WebAppsClient) StartSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientStartSlotOptions) (WebAppsClientStartSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.StartSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.startSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientStartSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStartSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStartSlotResponse{}, err
	}
	return WebAppsClientStartSlotResponse{}, nil
}

// startSlotCreateRequest creates the StartSlot request.
func (client *WebAppsClient) startSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientStartSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StartWebSiteNetworkTrace - Description for Start capturing network packets for the site (To be deprecated).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - options - WebAppsClientStartWebSiteNetworkTraceOptions contains the optional parameters for the WebAppsClient.StartWebSiteNetworkTrace
//     method.
func (client *WebAppsClient) StartWebSiteNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientStartWebSiteNetworkTraceOptions) (WebAppsClientStartWebSiteNetworkTraceResponse, error) {
	var err error
	const operationName = "WebAppsClient.StartWebSiteNetworkTrace"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.startWebSiteNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientStartWebSiteNetworkTraceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStartWebSiteNetworkTraceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStartWebSiteNetworkTraceResponse{}, err
	}
	resp, err := client.startWebSiteNetworkTraceHandleResponse(httpResp)
	return resp, err
}

// startWebSiteNetworkTraceCreateRequest creates the StartWebSiteNetworkTrace request.
func (client *WebAppsClient) startWebSiteNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientStartWebSiteNetworkTraceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// startWebSiteNetworkTraceHandleResponse handles the StartWebSiteNetworkTrace response.
func (client *WebAppsClient) startWebSiteNetworkTraceHandleResponse(resp *http.Response) (WebAppsClientStartWebSiteNetworkTraceResponse, error) {
	result := WebAppsClientStartWebSiteNetworkTraceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return WebAppsClientStartWebSiteNetworkTraceResponse{}, err
	}
	return result, nil
}

// BeginStartWebSiteNetworkTraceOperation - Description for Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - options - WebAppsClientBeginStartWebSiteNetworkTraceOperationOptions contains the optional parameters for the WebAppsClient.BeginStartWebSiteNetworkTraceOperation
//     method.
func (client *WebAppsClient) BeginStartWebSiteNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientBeginStartWebSiteNetworkTraceOperationOptions) (*runtime.Poller[WebAppsClientStartWebSiteNetworkTraceOperationResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.startWebSiteNetworkTraceOperation(ctx, resourceGroupName, name, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientStartWebSiteNetworkTraceOperationResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientStartWebSiteNetworkTraceOperationResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// StartWebSiteNetworkTraceOperation - Description for Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) startWebSiteNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientBeginStartWebSiteNetworkTraceOperationOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginStartWebSiteNetworkTraceOperation"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.startWebSiteNetworkTraceOperationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// startWebSiteNetworkTraceOperationCreateRequest creates the StartWebSiteNetworkTraceOperation request.
func (client *WebAppsClient) startWebSiteNetworkTraceOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientBeginStartWebSiteNetworkTraceOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/startOperation"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginStartWebSiteNetworkTraceOperationSlot - Description for Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - slot - The name of the slot for this web app.
//   - options - WebAppsClientBeginStartWebSiteNetworkTraceOperationSlotOptions contains the optional parameters for the WebAppsClient.BeginStartWebSiteNetworkTraceOperationSlot
//     method.
func (client *WebAppsClient) BeginStartWebSiteNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientBeginStartWebSiteNetworkTraceOperationSlotOptions) (*runtime.Poller[WebAppsClientStartWebSiteNetworkTraceOperationSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.startWebSiteNetworkTraceOperationSlot(ctx, resourceGroupName, name, slot, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientStartWebSiteNetworkTraceOperationSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientStartWebSiteNetworkTraceOperationSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// StartWebSiteNetworkTraceOperationSlot - Description for Start capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) startWebSiteNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientBeginStartWebSiteNetworkTraceOperationSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginStartWebSiteNetworkTraceOperationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.startWebSiteNetworkTraceOperationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// startWebSiteNetworkTraceOperationSlotCreateRequest creates the StartWebSiteNetworkTraceOperationSlot request.
func (client *WebAppsClient) startWebSiteNetworkTraceOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientBeginStartWebSiteNetworkTraceOperationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/startOperation"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StartWebSiteNetworkTraceSlot - Description for Start capturing network packets for the site (To be deprecated).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - slot - The name of the slot for this web app.
//   - options - WebAppsClientStartWebSiteNetworkTraceSlotOptions contains the optional parameters for the WebAppsClient.StartWebSiteNetworkTraceSlot
//     method.
func (client *WebAppsClient) StartWebSiteNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientStartWebSiteNetworkTraceSlotOptions) (WebAppsClientStartWebSiteNetworkTraceSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.StartWebSiteNetworkTraceSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.startWebSiteNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientStartWebSiteNetworkTraceSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStartWebSiteNetworkTraceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStartWebSiteNetworkTraceSlotResponse{}, err
	}
	resp, err := client.startWebSiteNetworkTraceSlotHandleResponse(httpResp)
	return resp, err
}

// startWebSiteNetworkTraceSlotCreateRequest creates the StartWebSiteNetworkTraceSlot request.
func (client *WebAppsClient) startWebSiteNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientStartWebSiteNetworkTraceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// startWebSiteNetworkTraceSlotHandleResponse handles the StartWebSiteNetworkTraceSlot response.
func (client *WebAppsClient) startWebSiteNetworkTraceSlotHandleResponse(resp *http.Response) (WebAppsClientStartWebSiteNetworkTraceSlotResponse, error) {
	result := WebAppsClientStartWebSiteNetworkTraceSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return WebAppsClientStartWebSiteNetworkTraceSlotResponse{}, err
	}
	return result, nil
}

// Stop - Description for Stops an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientStopOptions contains the optional parameters for the WebAppsClient.Stop method.
func (client *WebAppsClient) Stop(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientStopOptions) (WebAppsClientStopResponse, error) {
	var err error
	const operationName = "WebAppsClient.Stop"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.stopCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientStopResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStopResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStopResponse{}, err
	}
	return WebAppsClientStopResponse{}, nil
}

// stopCreateRequest creates the Stop request.
func (client *WebAppsClient) stopCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientStopOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StopContinuousWebJob - Description for Stop a continuous web job for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - options - WebAppsClientStopContinuousWebJobOptions contains the optional parameters for the WebAppsClient.StopContinuousWebJob
//     method.
func (client *WebAppsClient) StopContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientStopContinuousWebJobOptions) (WebAppsClientStopContinuousWebJobResponse, error) {
	var err error
	const operationName = "WebAppsClient.StopContinuousWebJob"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.stopContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsClientStopContinuousWebJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStopContinuousWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStopContinuousWebJobResponse{}, err
	}
	return WebAppsClientStopContinuousWebJobResponse{}, nil
}

// stopContinuousWebJobCreateRequest creates the StopContinuousWebJob request.
func (client *WebAppsClient) stopContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsClientStopContinuousWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StopContinuousWebJobSlot - Description for Stop a continuous web job for an app, or a deployment slot.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Site name.
//   - webJobName - Name of Web Job.
//   - slot - Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
//   - options - WebAppsClientStopContinuousWebJobSlotOptions contains the optional parameters for the WebAppsClient.StopContinuousWebJobSlot
//     method.
func (client *WebAppsClient) StopContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientStopContinuousWebJobSlotOptions) (WebAppsClientStopContinuousWebJobSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.StopContinuousWebJobSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.stopContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsClientStopContinuousWebJobSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStopContinuousWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStopContinuousWebJobSlotResponse{}, err
	}
	return WebAppsClientStopContinuousWebJobSlotResponse{}, nil
}

// stopContinuousWebJobSlotCreateRequest creates the StopContinuousWebJobSlot request.
func (client *WebAppsClient) stopContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsClientStopContinuousWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StopNetworkTrace - Description for Stop ongoing capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - options - WebAppsClientStopNetworkTraceOptions contains the optional parameters for the WebAppsClient.StopNetworkTrace
//     method.
func (client *WebAppsClient) StopNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientStopNetworkTraceOptions) (WebAppsClientStopNetworkTraceResponse, error) {
	var err error
	const operationName = "WebAppsClient.StopNetworkTrace"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.stopNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientStopNetworkTraceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStopNetworkTraceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStopNetworkTraceResponse{}, err
	}
	return WebAppsClientStopNetworkTraceResponse{}, nil
}

// stopNetworkTraceCreateRequest creates the StopNetworkTrace request.
func (client *WebAppsClient) stopNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientStopNetworkTraceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stopNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StopNetworkTraceSlot - Description for Stop ongoing capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - slot - The name of the slot for this web app.
//   - options - WebAppsClientStopNetworkTraceSlotOptions contains the optional parameters for the WebAppsClient.StopNetworkTraceSlot
//     method.
func (client *WebAppsClient) StopNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientStopNetworkTraceSlotOptions) (WebAppsClientStopNetworkTraceSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.StopNetworkTraceSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.stopNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientStopNetworkTraceSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStopNetworkTraceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStopNetworkTraceSlotResponse{}, err
	}
	return WebAppsClientStopNetworkTraceSlotResponse{}, nil
}

// stopNetworkTraceSlotCreateRequest creates the StopNetworkTraceSlot request.
func (client *WebAppsClient) stopNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientStopNetworkTraceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stopNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StopSlot - Description for Stops an app (or deployment slot, if specified).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will stop the production slot.
//   - options - WebAppsClientStopSlotOptions contains the optional parameters for the WebAppsClient.StopSlot method.
func (client *WebAppsClient) StopSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientStopSlotOptions) (WebAppsClientStopSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.StopSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.stopSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientStopSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStopSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStopSlotResponse{}, err
	}
	return WebAppsClientStopSlotResponse{}, nil
}

// stopSlotCreateRequest creates the StopSlot request.
func (client *WebAppsClient) stopSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientStopSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StopWebSiteNetworkTrace - Description for Stop ongoing capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - options - WebAppsClientStopWebSiteNetworkTraceOptions contains the optional parameters for the WebAppsClient.StopWebSiteNetworkTrace
//     method.
func (client *WebAppsClient) StopWebSiteNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientStopWebSiteNetworkTraceOptions) (WebAppsClientStopWebSiteNetworkTraceResponse, error) {
	var err error
	const operationName = "WebAppsClient.StopWebSiteNetworkTrace"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.stopWebSiteNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientStopWebSiteNetworkTraceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStopWebSiteNetworkTraceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStopWebSiteNetworkTraceResponse{}, err
	}
	return WebAppsClientStopWebSiteNetworkTraceResponse{}, nil
}

// stopWebSiteNetworkTraceCreateRequest creates the StopWebSiteNetworkTrace request.
func (client *WebAppsClient) stopWebSiteNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientStopWebSiteNetworkTraceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// StopWebSiteNetworkTraceSlot - Description for Stop ongoing capturing network packets for the site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - slot - The name of the slot for this web app.
//   - options - WebAppsClientStopWebSiteNetworkTraceSlotOptions contains the optional parameters for the WebAppsClient.StopWebSiteNetworkTraceSlot
//     method.
func (client *WebAppsClient) StopWebSiteNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientStopWebSiteNetworkTraceSlotOptions) (WebAppsClientStopWebSiteNetworkTraceSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.StopWebSiteNetworkTraceSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.stopWebSiteNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientStopWebSiteNetworkTraceSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientStopWebSiteNetworkTraceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientStopWebSiteNetworkTraceSlotResponse{}, err
	}
	return WebAppsClientStopWebSiteNetworkTraceSlotResponse{}, nil
}

// stopWebSiteNetworkTraceSlotCreateRequest creates the StopWebSiteNetworkTraceSlot request.
func (client *WebAppsClient) stopWebSiteNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientStopWebSiteNetworkTraceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginSwapSlot - Description for Swaps two deployment slots of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
//   - slotSwapEntity - JSON object that contains the target slot name. See example.
//   - options - WebAppsClientBeginSwapSlotOptions contains the optional parameters for the WebAppsClient.BeginSwapSlot method.
func (client *WebAppsClient) BeginSwapSlot(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsClientBeginSwapSlotOptions) (*runtime.Poller[WebAppsClientSwapSlotResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.swapSlot(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientSwapSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientSwapSlotResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// SwapSlot - Description for Swaps two deployment slots of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) swapSlot(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsClientBeginSwapSlotOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginSwapSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.swapSlotCreateRequest(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// swapSlotCreateRequest creates the SwapSlot request.
func (client *WebAppsClient) swapSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsClientBeginSwapSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, slotSwapEntity); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginSwapSlotWithProduction - Description for Swaps two deployment slots of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slotSwapEntity - JSON object that contains the target slot name. See example.
//   - options - WebAppsClientBeginSwapSlotWithProductionOptions contains the optional parameters for the WebAppsClient.BeginSwapSlotWithProduction
//     method.
func (client *WebAppsClient) BeginSwapSlotWithProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsClientBeginSwapSlotWithProductionOptions) (*runtime.Poller[WebAppsClientSwapSlotWithProductionResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.swapSlotWithProduction(ctx, resourceGroupName, name, slotSwapEntity, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[WebAppsClientSwapSlotWithProductionResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[WebAppsClientSwapSlotWithProductionResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// SwapSlotWithProduction - Description for Swaps two deployment slots of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
func (client *WebAppsClient) swapSlotWithProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsClientBeginSwapSlotWithProductionOptions) (*http.Response, error) {
	var err error
	const operationName = "WebAppsClient.BeginSwapSlotWithProduction"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.swapSlotWithProductionCreateRequest(ctx, resourceGroupName, name, slotSwapEntity, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// swapSlotWithProductionCreateRequest creates the SwapSlotWithProduction request.
func (client *WebAppsClient) swapSlotWithProductionCreateRequest(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsClientBeginSwapSlotWithProductionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, slotSwapEntity); err != nil {
		return nil, err
	}
	return req, nil
}

// SyncFunctionTriggers - Description for Syncs function trigger metadata to the management database
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientSyncFunctionTriggersOptions contains the optional parameters for the WebAppsClient.SyncFunctionTriggers
//     method.
func (client *WebAppsClient) SyncFunctionTriggers(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientSyncFunctionTriggersOptions) (WebAppsClientSyncFunctionTriggersResponse, error) {
	var err error
	const operationName = "WebAppsClient.SyncFunctionTriggers"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.syncFunctionTriggersCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientSyncFunctionTriggersResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientSyncFunctionTriggersResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientSyncFunctionTriggersResponse{}, err
	}
	return WebAppsClientSyncFunctionTriggersResponse{}, nil
}

// syncFunctionTriggersCreateRequest creates the SyncFunctionTriggers request.
func (client *WebAppsClient) syncFunctionTriggersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientSyncFunctionTriggersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/syncfunctiontriggers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// SyncFunctionTriggersSlot - Description for Syncs function trigger metadata to the management database
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientSyncFunctionTriggersSlotOptions contains the optional parameters for the WebAppsClient.SyncFunctionTriggersSlot
//     method.
func (client *WebAppsClient) SyncFunctionTriggersSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientSyncFunctionTriggersSlotOptions) (WebAppsClientSyncFunctionTriggersSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.SyncFunctionTriggersSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.syncFunctionTriggersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientSyncFunctionTriggersSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientSyncFunctionTriggersSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientSyncFunctionTriggersSlotResponse{}, err
	}
	return WebAppsClientSyncFunctionTriggersSlotResponse{}, nil
}

// syncFunctionTriggersSlotCreateRequest creates the SyncFunctionTriggersSlot request.
func (client *WebAppsClient) syncFunctionTriggersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientSyncFunctionTriggersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/syncfunctiontriggers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// SyncFunctions - Description for Syncs function trigger metadata to the management database
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientSyncFunctionsOptions contains the optional parameters for the WebAppsClient.SyncFunctions method.
func (client *WebAppsClient) SyncFunctions(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientSyncFunctionsOptions) (WebAppsClientSyncFunctionsResponse, error) {
	var err error
	const operationName = "WebAppsClient.SyncFunctions"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.syncFunctionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientSyncFunctionsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientSyncFunctionsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientSyncFunctionsResponse{}, err
	}
	return WebAppsClientSyncFunctionsResponse{}, nil
}

// syncFunctionsCreateRequest creates the SyncFunctions request.
func (client *WebAppsClient) syncFunctionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientSyncFunctionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// SyncFunctionsSlot - Description for Syncs function trigger metadata to the management database
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot.
//   - options - WebAppsClientSyncFunctionsSlotOptions contains the optional parameters for the WebAppsClient.SyncFunctionsSlot
//     method.
func (client *WebAppsClient) SyncFunctionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientSyncFunctionsSlotOptions) (WebAppsClientSyncFunctionsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.SyncFunctionsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.syncFunctionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientSyncFunctionsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientSyncFunctionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientSyncFunctionsSlotResponse{}, err
	}
	return WebAppsClientSyncFunctionsSlotResponse{}, nil
}

// syncFunctionsSlotCreateRequest creates the SyncFunctionsSlot request.
func (client *WebAppsClient) syncFunctionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientSyncFunctionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// SyncRepository - Description for Sync web app repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - options - WebAppsClientSyncRepositoryOptions contains the optional parameters for the WebAppsClient.SyncRepository method.
func (client *WebAppsClient) SyncRepository(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientSyncRepositoryOptions) (WebAppsClientSyncRepositoryResponse, error) {
	var err error
	const operationName = "WebAppsClient.SyncRepository"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.syncRepositoryCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsClientSyncRepositoryResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientSyncRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientSyncRepositoryResponse{}, err
	}
	return WebAppsClientSyncRepositoryResponse{}, nil
}

// syncRepositoryCreateRequest creates the SyncRepository request.
func (client *WebAppsClient) syncRepositoryCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsClientSyncRepositoryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// SyncRepositorySlot - Description for Sync web app repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - options - WebAppsClientSyncRepositorySlotOptions contains the optional parameters for the WebAppsClient.SyncRepositorySlot
//     method.
func (client *WebAppsClient) SyncRepositorySlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientSyncRepositorySlotOptions) (WebAppsClientSyncRepositorySlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.SyncRepositorySlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.syncRepositorySlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsClientSyncRepositorySlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientSyncRepositorySlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientSyncRepositorySlotResponse{}, err
	}
	return WebAppsClientSyncRepositorySlotResponse{}, nil
}

// syncRepositorySlotCreateRequest creates the SyncRepositorySlot request.
func (client *WebAppsClient) syncRepositorySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsClientSyncRepositorySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// Update - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
//   - siteEnvelope - A JSON representation of the app properties. See example.
//   - options - WebAppsClientUpdateOptions contains the optional parameters for the WebAppsClient.Update method.
func (client *WebAppsClient) Update(ctx context.Context, resourceGroupName string, name string, siteEnvelope SitePatchResource, options *WebAppsClientUpdateOptions) (WebAppsClientUpdateResponse, error) {
	var err error
	const operationName = "WebAppsClient.Update"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateCreateRequest(ctx, resourceGroupName, name, siteEnvelope, options)
	if err != nil {
		return WebAppsClientUpdateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateResponse{}, err
	}
	resp, err := client.updateHandleResponse(httpResp)
	return resp, err
}

// updateCreateRequest creates the Update request.
func (client *WebAppsClient) updateCreateRequest(ctx context.Context, resourceGroupName string, name string, siteEnvelope SitePatchResource, options *WebAppsClientUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// updateHandleResponse handles the Update response.
func (client *WebAppsClient) updateHandleResponse(resp *http.Response) (WebAppsClientUpdateResponse, error) {
	result := WebAppsClientUpdateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Site); err != nil {
		return WebAppsClientUpdateResponse{}, err
	}
	return result, nil
}

// UpdateApplicationSettings - Description for Replaces the application settings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - appSettings - Application settings of the app.
//   - options - WebAppsClientUpdateApplicationSettingsOptions contains the optional parameters for the WebAppsClient.UpdateApplicationSettings
//     method.
func (client *WebAppsClient) UpdateApplicationSettings(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, options *WebAppsClientUpdateApplicationSettingsOptions) (WebAppsClientUpdateApplicationSettingsResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateApplicationSettings"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateApplicationSettingsCreateRequest(ctx, resourceGroupName, name, appSettings, options)
	if err != nil {
		return WebAppsClientUpdateApplicationSettingsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateApplicationSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateApplicationSettingsResponse{}, err
	}
	resp, err := client.updateApplicationSettingsHandleResponse(httpResp)
	return resp, err
}

// updateApplicationSettingsCreateRequest creates the UpdateApplicationSettings request.
func (client *WebAppsClient) updateApplicationSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, options *WebAppsClientUpdateApplicationSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, appSettings); err != nil {
		return nil, err
	}
	return req, nil
}

// updateApplicationSettingsHandleResponse handles the UpdateApplicationSettings response.
func (client *WebAppsClient) updateApplicationSettingsHandleResponse(resp *http.Response) (WebAppsClientUpdateApplicationSettingsResponse, error) {
	result := WebAppsClientUpdateApplicationSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsClientUpdateApplicationSettingsResponse{}, err
	}
	return result, nil
}

// UpdateApplicationSettingsSlot - Description for Replaces the application settings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update the application settings for the production
//     slot.
//   - appSettings - Application settings of the app.
//   - options - WebAppsClientUpdateApplicationSettingsSlotOptions contains the optional parameters for the WebAppsClient.UpdateApplicationSettingsSlot
//     method.
func (client *WebAppsClient) UpdateApplicationSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, appSettings StringDictionary, options *WebAppsClientUpdateApplicationSettingsSlotOptions) (WebAppsClientUpdateApplicationSettingsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateApplicationSettingsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateApplicationSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, appSettings, options)
	if err != nil {
		return WebAppsClientUpdateApplicationSettingsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateApplicationSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateApplicationSettingsSlotResponse{}, err
	}
	resp, err := client.updateApplicationSettingsSlotHandleResponse(httpResp)
	return resp, err
}

// updateApplicationSettingsSlotCreateRequest creates the UpdateApplicationSettingsSlot request.
func (client *WebAppsClient) updateApplicationSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, appSettings StringDictionary, options *WebAppsClientUpdateApplicationSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, appSettings); err != nil {
		return nil, err
	}
	return req, nil
}

// updateApplicationSettingsSlotHandleResponse handles the UpdateApplicationSettingsSlot response.
func (client *WebAppsClient) updateApplicationSettingsSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateApplicationSettingsSlotResponse, error) {
	result := WebAppsClientUpdateApplicationSettingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsClientUpdateApplicationSettingsSlotResponse{}, err
	}
	return result, nil
}

// UpdateAuthSettings - Description for Updates the Authentication / Authorization settings associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - siteAuthSettings - Auth settings associated with web app.
//   - options - WebAppsClientUpdateAuthSettingsOptions contains the optional parameters for the WebAppsClient.UpdateAuthSettings
//     method.
func (client *WebAppsClient) UpdateAuthSettings(ctx context.Context, resourceGroupName string, name string, siteAuthSettings SiteAuthSettings, options *WebAppsClientUpdateAuthSettingsOptions) (WebAppsClientUpdateAuthSettingsResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateAuthSettings"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateAuthSettingsCreateRequest(ctx, resourceGroupName, name, siteAuthSettings, options)
	if err != nil {
		return WebAppsClientUpdateAuthSettingsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateAuthSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateAuthSettingsResponse{}, err
	}
	resp, err := client.updateAuthSettingsHandleResponse(httpResp)
	return resp, err
}

// updateAuthSettingsCreateRequest creates the UpdateAuthSettings request.
func (client *WebAppsClient) updateAuthSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, siteAuthSettings SiteAuthSettings, options *WebAppsClientUpdateAuthSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteAuthSettings); err != nil {
		return nil, err
	}
	return req, nil
}

// updateAuthSettingsHandleResponse handles the UpdateAuthSettings response.
func (client *WebAppsClient) updateAuthSettingsHandleResponse(resp *http.Response) (WebAppsClientUpdateAuthSettingsResponse, error) {
	result := WebAppsClientUpdateAuthSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettings); err != nil {
		return WebAppsClientUpdateAuthSettingsResponse{}, err
	}
	return result, nil
}

// UpdateAuthSettingsSlot - Description for Updates the Authentication / Authorization settings associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - siteAuthSettings - Auth settings associated with web app.
//   - options - WebAppsClientUpdateAuthSettingsSlotOptions contains the optional parameters for the WebAppsClient.UpdateAuthSettingsSlot
//     method.
func (client *WebAppsClient) UpdateAuthSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettings SiteAuthSettings, options *WebAppsClientUpdateAuthSettingsSlotOptions) (WebAppsClientUpdateAuthSettingsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateAuthSettingsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateAuthSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, siteAuthSettings, options)
	if err != nil {
		return WebAppsClientUpdateAuthSettingsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateAuthSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateAuthSettingsSlotResponse{}, err
	}
	resp, err := client.updateAuthSettingsSlotHandleResponse(httpResp)
	return resp, err
}

// updateAuthSettingsSlotCreateRequest creates the UpdateAuthSettingsSlot request.
func (client *WebAppsClient) updateAuthSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettings SiteAuthSettings, options *WebAppsClientUpdateAuthSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteAuthSettings); err != nil {
		return nil, err
	}
	return req, nil
}

// updateAuthSettingsSlotHandleResponse handles the UpdateAuthSettingsSlot response.
func (client *WebAppsClient) updateAuthSettingsSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateAuthSettingsSlotResponse, error) {
	result := WebAppsClientUpdateAuthSettingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettings); err != nil {
		return WebAppsClientUpdateAuthSettingsSlotResponse{}, err
	}
	return result, nil
}

// UpdateAuthSettingsV2 - Description for Updates site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - siteAuthSettingsV2 - Auth settings associated with web app.
//   - options - WebAppsClientUpdateAuthSettingsV2Options contains the optional parameters for the WebAppsClient.UpdateAuthSettingsV2
//     method.
func (client *WebAppsClient) UpdateAuthSettingsV2(ctx context.Context, resourceGroupName string, name string, siteAuthSettingsV2 SiteAuthSettingsV2, options *WebAppsClientUpdateAuthSettingsV2Options) (WebAppsClientUpdateAuthSettingsV2Response, error) {
	var err error
	const operationName = "WebAppsClient.UpdateAuthSettingsV2"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateAuthSettingsV2CreateRequest(ctx, resourceGroupName, name, siteAuthSettingsV2, options)
	if err != nil {
		return WebAppsClientUpdateAuthSettingsV2Response{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateAuthSettingsV2Response{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateAuthSettingsV2Response{}, err
	}
	resp, err := client.updateAuthSettingsV2HandleResponse(httpResp)
	return resp, err
}

// updateAuthSettingsV2CreateRequest creates the UpdateAuthSettingsV2 request.
func (client *WebAppsClient) updateAuthSettingsV2CreateRequest(ctx context.Context, resourceGroupName string, name string, siteAuthSettingsV2 SiteAuthSettingsV2, options *WebAppsClientUpdateAuthSettingsV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteAuthSettingsV2); err != nil {
		return nil, err
	}
	return req, nil
}

// updateAuthSettingsV2HandleResponse handles the UpdateAuthSettingsV2 response.
func (client *WebAppsClient) updateAuthSettingsV2HandleResponse(resp *http.Response) (WebAppsClientUpdateAuthSettingsV2Response, error) {
	result := WebAppsClientUpdateAuthSettingsV2Response{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettingsV2); err != nil {
		return WebAppsClientUpdateAuthSettingsV2Response{}, err
	}
	return result, nil
}

// UpdateAuthSettingsV2Slot - Description for Updates site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - siteAuthSettingsV2 - Auth settings associated with web app.
//   - options - WebAppsClientUpdateAuthSettingsV2SlotOptions contains the optional parameters for the WebAppsClient.UpdateAuthSettingsV2Slot
//     method.
func (client *WebAppsClient) UpdateAuthSettingsV2Slot(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettingsV2 SiteAuthSettingsV2, options *WebAppsClientUpdateAuthSettingsV2SlotOptions) (WebAppsClientUpdateAuthSettingsV2SlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateAuthSettingsV2Slot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateAuthSettingsV2SlotCreateRequest(ctx, resourceGroupName, name, slot, siteAuthSettingsV2, options)
	if err != nil {
		return WebAppsClientUpdateAuthSettingsV2SlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateAuthSettingsV2SlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateAuthSettingsV2SlotResponse{}, err
	}
	resp, err := client.updateAuthSettingsV2SlotHandleResponse(httpResp)
	return resp, err
}

// updateAuthSettingsV2SlotCreateRequest creates the UpdateAuthSettingsV2Slot request.
func (client *WebAppsClient) updateAuthSettingsV2SlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettingsV2 SiteAuthSettingsV2, options *WebAppsClientUpdateAuthSettingsV2SlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteAuthSettingsV2); err != nil {
		return nil, err
	}
	return req, nil
}

// updateAuthSettingsV2SlotHandleResponse handles the UpdateAuthSettingsV2Slot response.
func (client *WebAppsClient) updateAuthSettingsV2SlotHandleResponse(resp *http.Response) (WebAppsClientUpdateAuthSettingsV2SlotResponse, error) {
	result := WebAppsClientUpdateAuthSettingsV2SlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettingsV2); err != nil {
		return WebAppsClientUpdateAuthSettingsV2SlotResponse{}, err
	}
	return result, nil
}

// UpdateAzureStorageAccounts - Description for Updates the Azure storage account configurations of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - azureStorageAccounts - Azure storage accounts of the app.
//   - options - WebAppsClientUpdateAzureStorageAccountsOptions contains the optional parameters for the WebAppsClient.UpdateAzureStorageAccounts
//     method.
func (client *WebAppsClient) UpdateAzureStorageAccounts(ctx context.Context, resourceGroupName string, name string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *WebAppsClientUpdateAzureStorageAccountsOptions) (WebAppsClientUpdateAzureStorageAccountsResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateAzureStorageAccounts"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateAzureStorageAccountsCreateRequest(ctx, resourceGroupName, name, azureStorageAccounts, options)
	if err != nil {
		return WebAppsClientUpdateAzureStorageAccountsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateAzureStorageAccountsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateAzureStorageAccountsResponse{}, err
	}
	resp, err := client.updateAzureStorageAccountsHandleResponse(httpResp)
	return resp, err
}

// updateAzureStorageAccountsCreateRequest creates the UpdateAzureStorageAccounts request.
func (client *WebAppsClient) updateAzureStorageAccountsCreateRequest(ctx context.Context, resourceGroupName string, name string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *WebAppsClientUpdateAzureStorageAccountsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, azureStorageAccounts); err != nil {
		return nil, err
	}
	return req, nil
}

// updateAzureStorageAccountsHandleResponse handles the UpdateAzureStorageAccounts response.
func (client *WebAppsClient) updateAzureStorageAccountsHandleResponse(resp *http.Response) (WebAppsClientUpdateAzureStorageAccountsResponse, error) {
	result := WebAppsClientUpdateAzureStorageAccountsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AzureStoragePropertyDictionaryResource); err != nil {
		return WebAppsClientUpdateAzureStorageAccountsResponse{}, err
	}
	return result, nil
}

// UpdateAzureStorageAccountsSlot - Description for Updates the Azure storage account configurations of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update the Azure storage account configurations
//     for the production slot.
//   - azureStorageAccounts - Azure storage accounts of the app.
//   - options - WebAppsClientUpdateAzureStorageAccountsSlotOptions contains the optional parameters for the WebAppsClient.UpdateAzureStorageAccountsSlot
//     method.
func (client *WebAppsClient) UpdateAzureStorageAccountsSlot(ctx context.Context, resourceGroupName string, name string, slot string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *WebAppsClientUpdateAzureStorageAccountsSlotOptions) (WebAppsClientUpdateAzureStorageAccountsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateAzureStorageAccountsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateAzureStorageAccountsSlotCreateRequest(ctx, resourceGroupName, name, slot, azureStorageAccounts, options)
	if err != nil {
		return WebAppsClientUpdateAzureStorageAccountsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateAzureStorageAccountsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateAzureStorageAccountsSlotResponse{}, err
	}
	resp, err := client.updateAzureStorageAccountsSlotHandleResponse(httpResp)
	return resp, err
}

// updateAzureStorageAccountsSlotCreateRequest creates the UpdateAzureStorageAccountsSlot request.
func (client *WebAppsClient) updateAzureStorageAccountsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *WebAppsClientUpdateAzureStorageAccountsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, azureStorageAccounts); err != nil {
		return nil, err
	}
	return req, nil
}

// updateAzureStorageAccountsSlotHandleResponse handles the UpdateAzureStorageAccountsSlot response.
func (client *WebAppsClient) updateAzureStorageAccountsSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateAzureStorageAccountsSlotResponse, error) {
	result := WebAppsClientUpdateAzureStorageAccountsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AzureStoragePropertyDictionaryResource); err != nil {
		return WebAppsClientUpdateAzureStorageAccountsSlotResponse{}, err
	}
	return result, nil
}

// UpdateBackupConfiguration - Description for Updates the backup configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - request - Edited backup configuration.
//   - options - WebAppsClientUpdateBackupConfigurationOptions contains the optional parameters for the WebAppsClient.UpdateBackupConfiguration
//     method.
func (client *WebAppsClient) UpdateBackupConfiguration(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *WebAppsClientUpdateBackupConfigurationOptions) (WebAppsClientUpdateBackupConfigurationResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateBackupConfiguration"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateBackupConfigurationCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return WebAppsClientUpdateBackupConfigurationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateBackupConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateBackupConfigurationResponse{}, err
	}
	resp, err := client.updateBackupConfigurationHandleResponse(httpResp)
	return resp, err
}

// updateBackupConfigurationCreateRequest creates the UpdateBackupConfiguration request.
func (client *WebAppsClient) updateBackupConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *WebAppsClientUpdateBackupConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// updateBackupConfigurationHandleResponse handles the UpdateBackupConfiguration response.
func (client *WebAppsClient) updateBackupConfigurationHandleResponse(resp *http.Response) (WebAppsClientUpdateBackupConfigurationResponse, error) {
	result := WebAppsClientUpdateBackupConfigurationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupRequest); err != nil {
		return WebAppsClientUpdateBackupConfigurationResponse{}, err
	}
	return result, nil
}

// UpdateBackupConfigurationSlot - Description for Updates the backup configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update the backup configuration for the production
//     slot.
//   - request - Edited backup configuration.
//   - options - WebAppsClientUpdateBackupConfigurationSlotOptions contains the optional parameters for the WebAppsClient.UpdateBackupConfigurationSlot
//     method.
func (client *WebAppsClient) UpdateBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *WebAppsClientUpdateBackupConfigurationSlotOptions) (WebAppsClientUpdateBackupConfigurationSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateBackupConfigurationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateBackupConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return WebAppsClientUpdateBackupConfigurationSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateBackupConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateBackupConfigurationSlotResponse{}, err
	}
	resp, err := client.updateBackupConfigurationSlotHandleResponse(httpResp)
	return resp, err
}

// updateBackupConfigurationSlotCreateRequest creates the UpdateBackupConfigurationSlot request.
func (client *WebAppsClient) updateBackupConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *WebAppsClientUpdateBackupConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// updateBackupConfigurationSlotHandleResponse handles the UpdateBackupConfigurationSlot response.
func (client *WebAppsClient) updateBackupConfigurationSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateBackupConfigurationSlotResponse, error) {
	result := WebAppsClientUpdateBackupConfigurationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupRequest); err != nil {
		return WebAppsClientUpdateBackupConfigurationSlotResponse{}, err
	}
	return result, nil
}

// UpdateConfiguration - Description for Updates the configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - siteConfig - JSON representation of a SiteConfig object. See example.
//   - options - WebAppsClientUpdateConfigurationOptions contains the optional parameters for the WebAppsClient.UpdateConfiguration
//     method.
func (client *WebAppsClient) UpdateConfiguration(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *WebAppsClientUpdateConfigurationOptions) (WebAppsClientUpdateConfigurationResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateConfiguration"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateConfigurationCreateRequest(ctx, resourceGroupName, name, siteConfig, options)
	if err != nil {
		return WebAppsClientUpdateConfigurationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateConfigurationResponse{}, err
	}
	resp, err := client.updateConfigurationHandleResponse(httpResp)
	return resp, err
}

// updateConfigurationCreateRequest creates the UpdateConfiguration request.
func (client *WebAppsClient) updateConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *WebAppsClientUpdateConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteConfig); err != nil {
		return nil, err
	}
	return req, nil
}

// updateConfigurationHandleResponse handles the UpdateConfiguration response.
func (client *WebAppsClient) updateConfigurationHandleResponse(resp *http.Response) (WebAppsClientUpdateConfigurationResponse, error) {
	result := WebAppsClientUpdateConfigurationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsClientUpdateConfigurationResponse{}, err
	}
	return result, nil
}

// UpdateConfigurationSlot - Description for Updates the configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
//   - siteConfig - JSON representation of a SiteConfig object. See example.
//   - options - WebAppsClientUpdateConfigurationSlotOptions contains the optional parameters for the WebAppsClient.UpdateConfigurationSlot
//     method.
func (client *WebAppsClient) UpdateConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *WebAppsClientUpdateConfigurationSlotOptions) (WebAppsClientUpdateConfigurationSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateConfigurationSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, siteConfig, options)
	if err != nil {
		return WebAppsClientUpdateConfigurationSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateConfigurationSlotResponse{}, err
	}
	resp, err := client.updateConfigurationSlotHandleResponse(httpResp)
	return resp, err
}

// updateConfigurationSlotCreateRequest creates the UpdateConfigurationSlot request.
func (client *WebAppsClient) updateConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *WebAppsClientUpdateConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteConfig); err != nil {
		return nil, err
	}
	return req, nil
}

// updateConfigurationSlotHandleResponse handles the UpdateConfigurationSlot response.
func (client *WebAppsClient) updateConfigurationSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateConfigurationSlotResponse, error) {
	result := WebAppsClientUpdateConfigurationSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsClientUpdateConfigurationSlotResponse{}, err
	}
	return result, nil
}

// UpdateConnectionStrings - Description for Replaces the connection strings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - connectionStrings - Connection strings of the app or deployment slot. See example.
//   - options - WebAppsClientUpdateConnectionStringsOptions contains the optional parameters for the WebAppsClient.UpdateConnectionStrings
//     method.
func (client *WebAppsClient) UpdateConnectionStrings(ctx context.Context, resourceGroupName string, name string, connectionStrings ConnectionStringDictionary, options *WebAppsClientUpdateConnectionStringsOptions) (WebAppsClientUpdateConnectionStringsResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateConnectionStrings"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateConnectionStringsCreateRequest(ctx, resourceGroupName, name, connectionStrings, options)
	if err != nil {
		return WebAppsClientUpdateConnectionStringsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateConnectionStringsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateConnectionStringsResponse{}, err
	}
	resp, err := client.updateConnectionStringsHandleResponse(httpResp)
	return resp, err
}

// updateConnectionStringsCreateRequest creates the UpdateConnectionStrings request.
func (client *WebAppsClient) updateConnectionStringsCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionStrings ConnectionStringDictionary, options *WebAppsClientUpdateConnectionStringsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionStrings); err != nil {
		return nil, err
	}
	return req, nil
}

// updateConnectionStringsHandleResponse handles the UpdateConnectionStrings response.
func (client *WebAppsClient) updateConnectionStringsHandleResponse(resp *http.Response) (WebAppsClientUpdateConnectionStringsResponse, error) {
	result := WebAppsClientUpdateConnectionStringsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionStringDictionary); err != nil {
		return WebAppsClientUpdateConnectionStringsResponse{}, err
	}
	return result, nil
}

// UpdateConnectionStringsSlot - Description for Replaces the connection strings of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update the connection settings for the production
//     slot.
//   - connectionStrings - Connection strings of the app or deployment slot. See example.
//   - options - WebAppsClientUpdateConnectionStringsSlotOptions contains the optional parameters for the WebAppsClient.UpdateConnectionStringsSlot
//     method.
func (client *WebAppsClient) UpdateConnectionStringsSlot(ctx context.Context, resourceGroupName string, name string, slot string, connectionStrings ConnectionStringDictionary, options *WebAppsClientUpdateConnectionStringsSlotOptions) (WebAppsClientUpdateConnectionStringsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateConnectionStringsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateConnectionStringsSlotCreateRequest(ctx, resourceGroupName, name, slot, connectionStrings, options)
	if err != nil {
		return WebAppsClientUpdateConnectionStringsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateConnectionStringsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateConnectionStringsSlotResponse{}, err
	}
	resp, err := client.updateConnectionStringsSlotHandleResponse(httpResp)
	return resp, err
}

// updateConnectionStringsSlotCreateRequest creates the UpdateConnectionStringsSlot request.
func (client *WebAppsClient) updateConnectionStringsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, connectionStrings ConnectionStringDictionary, options *WebAppsClientUpdateConnectionStringsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionStrings); err != nil {
		return nil, err
	}
	return req, nil
}

// updateConnectionStringsSlotHandleResponse handles the UpdateConnectionStringsSlot response.
func (client *WebAppsClient) updateConnectionStringsSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateConnectionStringsSlotResponse, error) {
	result := WebAppsClientUpdateConnectionStringsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionStringDictionary); err != nil {
		return WebAppsClientUpdateConnectionStringsSlotResponse{}, err
	}
	return result, nil
}

// UpdateDiagnosticLogsConfig - Description for Updates the logging configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - siteLogsConfig - A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
//   - options - WebAppsClientUpdateDiagnosticLogsConfigOptions contains the optional parameters for the WebAppsClient.UpdateDiagnosticLogsConfig
//     method.
func (client *WebAppsClient) UpdateDiagnosticLogsConfig(ctx context.Context, resourceGroupName string, name string, siteLogsConfig SiteLogsConfig, options *WebAppsClientUpdateDiagnosticLogsConfigOptions) (WebAppsClientUpdateDiagnosticLogsConfigResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateDiagnosticLogsConfig"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateDiagnosticLogsConfigCreateRequest(ctx, resourceGroupName, name, siteLogsConfig, options)
	if err != nil {
		return WebAppsClientUpdateDiagnosticLogsConfigResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateDiagnosticLogsConfigResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateDiagnosticLogsConfigResponse{}, err
	}
	resp, err := client.updateDiagnosticLogsConfigHandleResponse(httpResp)
	return resp, err
}

// updateDiagnosticLogsConfigCreateRequest creates the UpdateDiagnosticLogsConfig request.
func (client *WebAppsClient) updateDiagnosticLogsConfigCreateRequest(ctx context.Context, resourceGroupName string, name string, siteLogsConfig SiteLogsConfig, options *WebAppsClientUpdateDiagnosticLogsConfigOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteLogsConfig); err != nil {
		return nil, err
	}
	return req, nil
}

// updateDiagnosticLogsConfigHandleResponse handles the UpdateDiagnosticLogsConfig response.
func (client *WebAppsClient) updateDiagnosticLogsConfigHandleResponse(resp *http.Response) (WebAppsClientUpdateDiagnosticLogsConfigResponse, error) {
	result := WebAppsClientUpdateDiagnosticLogsConfigResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteLogsConfig); err != nil {
		return WebAppsClientUpdateDiagnosticLogsConfigResponse{}, err
	}
	return result, nil
}

// UpdateDiagnosticLogsConfigSlot - Description for Updates the logging configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update the logging configuration for the production
//     slot.
//   - siteLogsConfig - A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
//   - options - WebAppsClientUpdateDiagnosticLogsConfigSlotOptions contains the optional parameters for the WebAppsClient.UpdateDiagnosticLogsConfigSlot
//     method.
func (client *WebAppsClient) UpdateDiagnosticLogsConfigSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteLogsConfig SiteLogsConfig, options *WebAppsClientUpdateDiagnosticLogsConfigSlotOptions) (WebAppsClientUpdateDiagnosticLogsConfigSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateDiagnosticLogsConfigSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateDiagnosticLogsConfigSlotCreateRequest(ctx, resourceGroupName, name, slot, siteLogsConfig, options)
	if err != nil {
		return WebAppsClientUpdateDiagnosticLogsConfigSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateDiagnosticLogsConfigSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateDiagnosticLogsConfigSlotResponse{}, err
	}
	resp, err := client.updateDiagnosticLogsConfigSlotHandleResponse(httpResp)
	return resp, err
}

// updateDiagnosticLogsConfigSlotCreateRequest creates the UpdateDiagnosticLogsConfigSlot request.
func (client *WebAppsClient) updateDiagnosticLogsConfigSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteLogsConfig SiteLogsConfig, options *WebAppsClientUpdateDiagnosticLogsConfigSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteLogsConfig); err != nil {
		return nil, err
	}
	return req, nil
}

// updateDiagnosticLogsConfigSlotHandleResponse handles the UpdateDiagnosticLogsConfigSlot response.
func (client *WebAppsClient) updateDiagnosticLogsConfigSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateDiagnosticLogsConfigSlotResponse, error) {
	result := WebAppsClientUpdateDiagnosticLogsConfigSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteLogsConfig); err != nil {
		return WebAppsClientUpdateDiagnosticLogsConfigSlotResponse{}, err
	}
	return result, nil
}

// UpdateDomainOwnershipIdentifier - Description for Creates a domain ownership identifier for web app, or updates an existing
// ownership identifier.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - domainOwnershipIdentifierName - Name of domain ownership identifier.
//   - domainOwnershipIdentifier - A JSON representation of the domain ownership properties.
//   - options - WebAppsClientUpdateDomainOwnershipIdentifierOptions contains the optional parameters for the WebAppsClient.UpdateDomainOwnershipIdentifier
//     method.
func (client *WebAppsClient) UpdateDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *WebAppsClientUpdateDomainOwnershipIdentifierOptions) (WebAppsClientUpdateDomainOwnershipIdentifierResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateDomainOwnershipIdentifier"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options)
	if err != nil {
		return WebAppsClientUpdateDomainOwnershipIdentifierResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateDomainOwnershipIdentifierResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateDomainOwnershipIdentifierResponse{}, err
	}
	resp, err := client.updateDomainOwnershipIdentifierHandleResponse(httpResp)
	return resp, err
}

// updateDomainOwnershipIdentifierCreateRequest creates the UpdateDomainOwnershipIdentifier request.
func (client *WebAppsClient) updateDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *WebAppsClientUpdateDomainOwnershipIdentifierOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, domainOwnershipIdentifier); err != nil {
		return nil, err
	}
	return req, nil
}

// updateDomainOwnershipIdentifierHandleResponse handles the UpdateDomainOwnershipIdentifier response.
func (client *WebAppsClient) updateDomainOwnershipIdentifierHandleResponse(resp *http.Response) (WebAppsClientUpdateDomainOwnershipIdentifierResponse, error) {
	result := WebAppsClientUpdateDomainOwnershipIdentifierResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return WebAppsClientUpdateDomainOwnershipIdentifierResponse{}, err
	}
	return result, nil
}

// UpdateDomainOwnershipIdentifierSlot - Description for Creates a domain ownership identifier for web app, or updates an
// existing ownership identifier.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - domainOwnershipIdentifierName - Name of domain ownership identifier.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
//   - domainOwnershipIdentifier - A JSON representation of the domain ownership properties.
//   - options - WebAppsClientUpdateDomainOwnershipIdentifierSlotOptions contains the optional parameters for the WebAppsClient.UpdateDomainOwnershipIdentifierSlot
//     method.
func (client *WebAppsClient) UpdateDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *WebAppsClientUpdateDomainOwnershipIdentifierSlotOptions) (WebAppsClientUpdateDomainOwnershipIdentifierSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateDomainOwnershipIdentifierSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier, options)
	if err != nil {
		return WebAppsClientUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	resp, err := client.updateDomainOwnershipIdentifierSlotHandleResponse(httpResp)
	return resp, err
}

// updateDomainOwnershipIdentifierSlotCreateRequest creates the UpdateDomainOwnershipIdentifierSlot request.
func (client *WebAppsClient) updateDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *WebAppsClientUpdateDomainOwnershipIdentifierSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, domainOwnershipIdentifier); err != nil {
		return nil, err
	}
	return req, nil
}

// updateDomainOwnershipIdentifierSlotHandleResponse handles the UpdateDomainOwnershipIdentifierSlot response.
func (client *WebAppsClient) updateDomainOwnershipIdentifierSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateDomainOwnershipIdentifierSlotResponse, error) {
	result := WebAppsClientUpdateDomainOwnershipIdentifierSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return WebAppsClientUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	return result, nil
}

// UpdateFtpAllowed - Description for Updates whether FTP is allowed on the site or not.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientUpdateFtpAllowedOptions contains the optional parameters for the WebAppsClient.UpdateFtpAllowed
//     method.
func (client *WebAppsClient) UpdateFtpAllowed(ctx context.Context, resourceGroupName string, name string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsClientUpdateFtpAllowedOptions) (WebAppsClientUpdateFtpAllowedResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateFtpAllowed"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateFtpAllowedCreateRequest(ctx, resourceGroupName, name, csmPublishingAccessPoliciesEntity, options)
	if err != nil {
		return WebAppsClientUpdateFtpAllowedResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateFtpAllowedResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateFtpAllowedResponse{}, err
	}
	resp, err := client.updateFtpAllowedHandleResponse(httpResp)
	return resp, err
}

// updateFtpAllowedCreateRequest creates the UpdateFtpAllowed request.
func (client *WebAppsClient) updateFtpAllowedCreateRequest(ctx context.Context, resourceGroupName string, name string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsClientUpdateFtpAllowedOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/ftp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, csmPublishingAccessPoliciesEntity); err != nil {
		return nil, err
	}
	return req, nil
}

// updateFtpAllowedHandleResponse handles the UpdateFtpAllowed response.
func (client *WebAppsClient) updateFtpAllowedHandleResponse(resp *http.Response) (WebAppsClientUpdateFtpAllowedResponse, error) {
	result := WebAppsClientUpdateFtpAllowedResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsClientUpdateFtpAllowedResponse{}, err
	}
	return result, nil
}

// UpdateFtpAllowedSlot - Description for Updates whether FTP is allowed on the site or not.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientUpdateFtpAllowedSlotOptions contains the optional parameters for the WebAppsClient.UpdateFtpAllowedSlot
//     method.
func (client *WebAppsClient) UpdateFtpAllowedSlot(ctx context.Context, resourceGroupName string, name string, slot string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsClientUpdateFtpAllowedSlotOptions) (WebAppsClientUpdateFtpAllowedSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateFtpAllowedSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateFtpAllowedSlotCreateRequest(ctx, resourceGroupName, name, slot, csmPublishingAccessPoliciesEntity, options)
	if err != nil {
		return WebAppsClientUpdateFtpAllowedSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateFtpAllowedSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateFtpAllowedSlotResponse{}, err
	}
	resp, err := client.updateFtpAllowedSlotHandleResponse(httpResp)
	return resp, err
}

// updateFtpAllowedSlotCreateRequest creates the UpdateFtpAllowedSlot request.
func (client *WebAppsClient) updateFtpAllowedSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsClientUpdateFtpAllowedSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/ftp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, csmPublishingAccessPoliciesEntity); err != nil {
		return nil, err
	}
	return req, nil
}

// updateFtpAllowedSlotHandleResponse handles the UpdateFtpAllowedSlot response.
func (client *WebAppsClient) updateFtpAllowedSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateFtpAllowedSlotResponse, error) {
	result := WebAppsClientUpdateFtpAllowedSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsClientUpdateFtpAllowedSlotResponse{}, err
	}
	return result, nil
}

// UpdateHybridConnection - Description for Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - namespaceName - The namespace for this hybrid connection.
//   - relayName - The relay name for this hybrid connection.
//   - connectionEnvelope - The details of the hybrid connection.
//   - options - WebAppsClientUpdateHybridConnectionOptions contains the optional parameters for the WebAppsClient.UpdateHybridConnection
//     method.
func (client *WebAppsClient) UpdateHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *WebAppsClientUpdateHybridConnectionOptions) (WebAppsClientUpdateHybridConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateHybridConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientUpdateHybridConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateHybridConnectionResponse{}, err
	}
	resp, err := client.updateHybridConnectionHandleResponse(httpResp)
	return resp, err
}

// updateHybridConnectionCreateRequest creates the UpdateHybridConnection request.
func (client *WebAppsClient) updateHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *WebAppsClientUpdateHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// updateHybridConnectionHandleResponse handles the UpdateHybridConnection response.
func (client *WebAppsClient) updateHybridConnectionHandleResponse(resp *http.Response) (WebAppsClientUpdateHybridConnectionResponse, error) {
	result := WebAppsClientUpdateHybridConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsClientUpdateHybridConnectionResponse{}, err
	}
	return result, nil
}

// UpdateHybridConnectionSlot - Description for Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - The name of the web app.
//   - namespaceName - The namespace for this hybrid connection.
//   - relayName - The relay name for this hybrid connection.
//   - slot - The name of the slot for the web app.
//   - connectionEnvelope - The details of the hybrid connection.
//   - options - WebAppsClientUpdateHybridConnectionSlotOptions contains the optional parameters for the WebAppsClient.UpdateHybridConnectionSlot
//     method.
func (client *WebAppsClient) UpdateHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *WebAppsClientUpdateHybridConnectionSlotOptions) (WebAppsClientUpdateHybridConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateHybridConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientUpdateHybridConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateHybridConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateHybridConnectionSlotResponse{}, err
	}
	resp, err := client.updateHybridConnectionSlotHandleResponse(httpResp)
	return resp, err
}

// updateHybridConnectionSlotCreateRequest creates the UpdateHybridConnectionSlot request.
func (client *WebAppsClient) updateHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *WebAppsClientUpdateHybridConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// updateHybridConnectionSlotHandleResponse handles the UpdateHybridConnectionSlot response.
func (client *WebAppsClient) updateHybridConnectionSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateHybridConnectionSlotResponse, error) {
	result := WebAppsClientUpdateHybridConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsClientUpdateHybridConnectionSlotResponse{}, err
	}
	return result, nil
}

// UpdateMetadata - Description for Replaces the metadata of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - metadata - Edited metadata of the app or deployment slot. See example.
//   - options - WebAppsClientUpdateMetadataOptions contains the optional parameters for the WebAppsClient.UpdateMetadata method.
func (client *WebAppsClient) UpdateMetadata(ctx context.Context, resourceGroupName string, name string, metadata StringDictionary, options *WebAppsClientUpdateMetadataOptions) (WebAppsClientUpdateMetadataResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateMetadata"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateMetadataCreateRequest(ctx, resourceGroupName, name, metadata, options)
	if err != nil {
		return WebAppsClientUpdateMetadataResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateMetadataResponse{}, err
	}
	resp, err := client.updateMetadataHandleResponse(httpResp)
	return resp, err
}

// updateMetadataCreateRequest creates the UpdateMetadata request.
func (client *WebAppsClient) updateMetadataCreateRequest(ctx context.Context, resourceGroupName string, name string, metadata StringDictionary, options *WebAppsClientUpdateMetadataOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, metadata); err != nil {
		return nil, err
	}
	return req, nil
}

// updateMetadataHandleResponse handles the UpdateMetadata response.
func (client *WebAppsClient) updateMetadataHandleResponse(resp *http.Response) (WebAppsClientUpdateMetadataResponse, error) {
	result := WebAppsClientUpdateMetadataResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsClientUpdateMetadataResponse{}, err
	}
	return result, nil
}

// UpdateMetadataSlot - Description for Replaces the metadata of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update the metadata for the production slot.
//   - metadata - Edited metadata of the app or deployment slot. See example.
//   - options - WebAppsClientUpdateMetadataSlotOptions contains the optional parameters for the WebAppsClient.UpdateMetadataSlot
//     method.
func (client *WebAppsClient) UpdateMetadataSlot(ctx context.Context, resourceGroupName string, name string, slot string, metadata StringDictionary, options *WebAppsClientUpdateMetadataSlotOptions) (WebAppsClientUpdateMetadataSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateMetadataSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateMetadataSlotCreateRequest(ctx, resourceGroupName, name, slot, metadata, options)
	if err != nil {
		return WebAppsClientUpdateMetadataSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateMetadataSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateMetadataSlotResponse{}, err
	}
	resp, err := client.updateMetadataSlotHandleResponse(httpResp)
	return resp, err
}

// updateMetadataSlotCreateRequest creates the UpdateMetadataSlot request.
func (client *WebAppsClient) updateMetadataSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, metadata StringDictionary, options *WebAppsClientUpdateMetadataSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, metadata); err != nil {
		return nil, err
	}
	return req, nil
}

// updateMetadataSlotHandleResponse handles the UpdateMetadataSlot response.
func (client *WebAppsClient) updateMetadataSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateMetadataSlotResponse, error) {
	result := WebAppsClientUpdateMetadataSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsClientUpdateMetadataSlotResponse{}, err
	}
	return result, nil
}

// UpdatePremierAddOn - Description for Updates a named add-on of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - premierAddOnName - Add-on name.
//   - premierAddOn - A JSON representation of the edited premier add-on.
//   - options - WebAppsClientUpdatePremierAddOnOptions contains the optional parameters for the WebAppsClient.UpdatePremierAddOn
//     method.
func (client *WebAppsClient) UpdatePremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOnPatchResource, options *WebAppsClientUpdatePremierAddOnOptions) (WebAppsClientUpdatePremierAddOnResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdatePremierAddOn"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updatePremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, premierAddOn, options)
	if err != nil {
		return WebAppsClientUpdatePremierAddOnResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdatePremierAddOnResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdatePremierAddOnResponse{}, err
	}
	resp, err := client.updatePremierAddOnHandleResponse(httpResp)
	return resp, err
}

// updatePremierAddOnCreateRequest creates the UpdatePremierAddOn request.
func (client *WebAppsClient) updatePremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOnPatchResource, options *WebAppsClientUpdatePremierAddOnOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, premierAddOn); err != nil {
		return nil, err
	}
	return req, nil
}

// updatePremierAddOnHandleResponse handles the UpdatePremierAddOn response.
func (client *WebAppsClient) updatePremierAddOnHandleResponse(resp *http.Response) (WebAppsClientUpdatePremierAddOnResponse, error) {
	result := WebAppsClientUpdatePremierAddOnResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsClientUpdatePremierAddOnResponse{}, err
	}
	return result, nil
}

// UpdatePremierAddOnSlot - Description for Updates a named add-on of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - premierAddOnName - Add-on name.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update the named add-on for the production
//     slot.
//   - premierAddOn - A JSON representation of the edited premier add-on.
//   - options - WebAppsClientUpdatePremierAddOnSlotOptions contains the optional parameters for the WebAppsClient.UpdatePremierAddOnSlot
//     method.
func (client *WebAppsClient) UpdatePremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOnPatchResource, options *WebAppsClientUpdatePremierAddOnSlotOptions) (WebAppsClientUpdatePremierAddOnSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdatePremierAddOnSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updatePremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, premierAddOn, options)
	if err != nil {
		return WebAppsClientUpdatePremierAddOnSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdatePremierAddOnSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdatePremierAddOnSlotResponse{}, err
	}
	resp, err := client.updatePremierAddOnSlotHandleResponse(httpResp)
	return resp, err
}

// updatePremierAddOnSlotCreateRequest creates the UpdatePremierAddOnSlot request.
func (client *WebAppsClient) updatePremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOnPatchResource, options *WebAppsClientUpdatePremierAddOnSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, premierAddOn); err != nil {
		return nil, err
	}
	return req, nil
}

// updatePremierAddOnSlotHandleResponse handles the UpdatePremierAddOnSlot response.
func (client *WebAppsClient) updatePremierAddOnSlotHandleResponse(resp *http.Response) (WebAppsClientUpdatePremierAddOnSlotResponse, error) {
	result := WebAppsClientUpdatePremierAddOnSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsClientUpdatePremierAddOnSlotResponse{}, err
	}
	return result, nil
}

// UpdateRelayServiceConnection - Description for Creates a new hybrid connection configuration (PUT), or updates an existing
// one (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - entityName - Name of the hybrid connection configuration.
//   - connectionEnvelope - Details of the hybrid connection configuration.
//   - options - WebAppsClientUpdateRelayServiceConnectionOptions contains the optional parameters for the WebAppsClient.UpdateRelayServiceConnection
//     method.
func (client *WebAppsClient) UpdateRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsClientUpdateRelayServiceConnectionOptions) (WebAppsClientUpdateRelayServiceConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateRelayServiceConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientUpdateRelayServiceConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateRelayServiceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateRelayServiceConnectionResponse{}, err
	}
	resp, err := client.updateRelayServiceConnectionHandleResponse(httpResp)
	return resp, err
}

// updateRelayServiceConnectionCreateRequest creates the UpdateRelayServiceConnection request.
func (client *WebAppsClient) updateRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsClientUpdateRelayServiceConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// updateRelayServiceConnectionHandleResponse handles the UpdateRelayServiceConnection response.
func (client *WebAppsClient) updateRelayServiceConnectionHandleResponse(resp *http.Response) (WebAppsClientUpdateRelayServiceConnectionResponse, error) {
	result := WebAppsClientUpdateRelayServiceConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsClientUpdateRelayServiceConnectionResponse{}, err
	}
	return result, nil
}

// UpdateRelayServiceConnectionSlot - Description for Creates a new hybrid connection configuration (PUT), or updates an existing
// one (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - entityName - Name of the hybrid connection configuration.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the
//     production slot.
//   - connectionEnvelope - Details of the hybrid connection configuration.
//   - options - WebAppsClientUpdateRelayServiceConnectionSlotOptions contains the optional parameters for the WebAppsClient.UpdateRelayServiceConnectionSlot
//     method.
func (client *WebAppsClient) UpdateRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsClientUpdateRelayServiceConnectionSlotOptions) (WebAppsClientUpdateRelayServiceConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateRelayServiceConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientUpdateRelayServiceConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateRelayServiceConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateRelayServiceConnectionSlotResponse{}, err
	}
	resp, err := client.updateRelayServiceConnectionSlotHandleResponse(httpResp)
	return resp, err
}

// updateRelayServiceConnectionSlotCreateRequest creates the UpdateRelayServiceConnectionSlot request.
func (client *WebAppsClient) updateRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsClientUpdateRelayServiceConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// updateRelayServiceConnectionSlotHandleResponse handles the UpdateRelayServiceConnectionSlot response.
func (client *WebAppsClient) updateRelayServiceConnectionSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateRelayServiceConnectionSlotResponse, error) {
	result := WebAppsClientUpdateRelayServiceConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsClientUpdateRelayServiceConnectionSlotResponse{}, err
	}
	return result, nil
}

// UpdateScmAllowed - Description for Updates whether user publishing credentials are allowed on the site or not.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientUpdateScmAllowedOptions contains the optional parameters for the WebAppsClient.UpdateScmAllowed
//     method.
func (client *WebAppsClient) UpdateScmAllowed(ctx context.Context, resourceGroupName string, name string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsClientUpdateScmAllowedOptions) (WebAppsClientUpdateScmAllowedResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateScmAllowed"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateScmAllowedCreateRequest(ctx, resourceGroupName, name, csmPublishingAccessPoliciesEntity, options)
	if err != nil {
		return WebAppsClientUpdateScmAllowedResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateScmAllowedResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateScmAllowedResponse{}, err
	}
	resp, err := client.updateScmAllowedHandleResponse(httpResp)
	return resp, err
}

// updateScmAllowedCreateRequest creates the UpdateScmAllowed request.
func (client *WebAppsClient) updateScmAllowedCreateRequest(ctx context.Context, resourceGroupName string, name string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsClientUpdateScmAllowedOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/scm"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, csmPublishingAccessPoliciesEntity); err != nil {
		return nil, err
	}
	return req, nil
}

// updateScmAllowedHandleResponse handles the UpdateScmAllowed response.
func (client *WebAppsClient) updateScmAllowedHandleResponse(resp *http.Response) (WebAppsClientUpdateScmAllowedResponse, error) {
	result := WebAppsClientUpdateScmAllowedResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsClientUpdateScmAllowedResponse{}, err
	}
	return result, nil
}

// UpdateScmAllowedSlot - Description for Updates whether user publishing credentials are allowed on the site or not.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - options - WebAppsClientUpdateScmAllowedSlotOptions contains the optional parameters for the WebAppsClient.UpdateScmAllowedSlot
//     method.
func (client *WebAppsClient) UpdateScmAllowedSlot(ctx context.Context, resourceGroupName string, name string, slot string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsClientUpdateScmAllowedSlotOptions) (WebAppsClientUpdateScmAllowedSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateScmAllowedSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateScmAllowedSlotCreateRequest(ctx, resourceGroupName, name, slot, csmPublishingAccessPoliciesEntity, options)
	if err != nil {
		return WebAppsClientUpdateScmAllowedSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateScmAllowedSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateScmAllowedSlotResponse{}, err
	}
	resp, err := client.updateScmAllowedSlotHandleResponse(httpResp)
	return resp, err
}

// updateScmAllowedSlotCreateRequest creates the UpdateScmAllowedSlot request.
func (client *WebAppsClient) updateScmAllowedSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsClientUpdateScmAllowedSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/scm"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, csmPublishingAccessPoliciesEntity); err != nil {
		return nil, err
	}
	return req, nil
}

// updateScmAllowedSlotHandleResponse handles the UpdateScmAllowedSlot response.
func (client *WebAppsClient) updateScmAllowedSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateScmAllowedSlotResponse, error) {
	result := WebAppsClientUpdateScmAllowedSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsClientUpdateScmAllowedSlotResponse{}, err
	}
	return result, nil
}

// UpdateSitePushSettings - Description for Updates the Push settings associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - pushSettings - Push settings associated with web app.
//   - options - WebAppsClientUpdateSitePushSettingsOptions contains the optional parameters for the WebAppsClient.UpdateSitePushSettings
//     method.
func (client *WebAppsClient) UpdateSitePushSettings(ctx context.Context, resourceGroupName string, name string, pushSettings PushSettings, options *WebAppsClientUpdateSitePushSettingsOptions) (WebAppsClientUpdateSitePushSettingsResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateSitePushSettings"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateSitePushSettingsCreateRequest(ctx, resourceGroupName, name, pushSettings, options)
	if err != nil {
		return WebAppsClientUpdateSitePushSettingsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateSitePushSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateSitePushSettingsResponse{}, err
	}
	resp, err := client.updateSitePushSettingsHandleResponse(httpResp)
	return resp, err
}

// updateSitePushSettingsCreateRequest creates the UpdateSitePushSettings request.
func (client *WebAppsClient) updateSitePushSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, pushSettings PushSettings, options *WebAppsClientUpdateSitePushSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, pushSettings); err != nil {
		return nil, err
	}
	return req, nil
}

// updateSitePushSettingsHandleResponse handles the UpdateSitePushSettings response.
func (client *WebAppsClient) updateSitePushSettingsHandleResponse(resp *http.Response) (WebAppsClientUpdateSitePushSettingsResponse, error) {
	result := WebAppsClientUpdateSitePushSettingsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PushSettings); err != nil {
		return WebAppsClientUpdateSitePushSettingsResponse{}, err
	}
	return result, nil
}

// UpdateSitePushSettingsSlot - Description for Updates the Push settings associated with web app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of web app.
//   - slot - Name of web app slot. If not specified then will default to production slot.
//   - pushSettings - Push settings associated with web app.
//   - options - WebAppsClientUpdateSitePushSettingsSlotOptions contains the optional parameters for the WebAppsClient.UpdateSitePushSettingsSlot
//     method.
func (client *WebAppsClient) UpdateSitePushSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, pushSettings PushSettings, options *WebAppsClientUpdateSitePushSettingsSlotOptions) (WebAppsClientUpdateSitePushSettingsSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateSitePushSettingsSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateSitePushSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, pushSettings, options)
	if err != nil {
		return WebAppsClientUpdateSitePushSettingsSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateSitePushSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateSitePushSettingsSlotResponse{}, err
	}
	resp, err := client.updateSitePushSettingsSlotHandleResponse(httpResp)
	return resp, err
}

// updateSitePushSettingsSlotCreateRequest creates the UpdateSitePushSettingsSlot request.
func (client *WebAppsClient) updateSitePushSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, pushSettings PushSettings, options *WebAppsClientUpdateSitePushSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, pushSettings); err != nil {
		return nil, err
	}
	return req, nil
}

// updateSitePushSettingsSlotHandleResponse handles the UpdateSitePushSettingsSlot response.
func (client *WebAppsClient) updateSitePushSettingsSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateSitePushSettingsSlotResponse, error) {
	result := WebAppsClientUpdateSitePushSettingsSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PushSettings); err != nil {
		return WebAppsClientUpdateSitePushSettingsSlotResponse{}, err
	}
	return result, nil
}

// UpdateSlot - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing
// app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
//   - slot - Name of the deployment slot to create or update. By default, this API attempts to create or modify the production
//     slot.
//   - siteEnvelope - A JSON representation of the app properties. See example.
//   - options - WebAppsClientUpdateSlotOptions contains the optional parameters for the WebAppsClient.UpdateSlot method.
func (client *WebAppsClient) UpdateSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope SitePatchResource, options *WebAppsClientUpdateSlotOptions) (WebAppsClientUpdateSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateSlotCreateRequest(ctx, resourceGroupName, name, slot, siteEnvelope, options)
	if err != nil {
		return WebAppsClientUpdateSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateSlotResponse{}, err
	}
	resp, err := client.updateSlotHandleResponse(httpResp)
	return resp, err
}

// updateSlotCreateRequest creates the UpdateSlot request.
func (client *WebAppsClient) updateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope SitePatchResource, options *WebAppsClientUpdateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// updateSlotHandleResponse handles the UpdateSlot response.
func (client *WebAppsClient) updateSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateSlotResponse, error) {
	result := WebAppsClientUpdateSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Site); err != nil {
		return WebAppsClientUpdateSlotResponse{}, err
	}
	return result, nil
}

// UpdateSlotConfigurationNames - Description for Updates the names of application settings and connection string that remain
// with the slot during swap operation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slotConfigNames - Names of application settings and connection strings. See example.
//   - options - WebAppsClientUpdateSlotConfigurationNamesOptions contains the optional parameters for the WebAppsClient.UpdateSlotConfigurationNames
//     method.
func (client *WebAppsClient) UpdateSlotConfigurationNames(ctx context.Context, resourceGroupName string, name string, slotConfigNames SlotConfigNamesResource, options *WebAppsClientUpdateSlotConfigurationNamesOptions) (WebAppsClientUpdateSlotConfigurationNamesResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateSlotConfigurationNames"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateSlotConfigurationNamesCreateRequest(ctx, resourceGroupName, name, slotConfigNames, options)
	if err != nil {
		return WebAppsClientUpdateSlotConfigurationNamesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateSlotConfigurationNamesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateSlotConfigurationNamesResponse{}, err
	}
	resp, err := client.updateSlotConfigurationNamesHandleResponse(httpResp)
	return resp, err
}

// updateSlotConfigurationNamesCreateRequest creates the UpdateSlotConfigurationNames request.
func (client *WebAppsClient) updateSlotConfigurationNamesCreateRequest(ctx context.Context, resourceGroupName string, name string, slotConfigNames SlotConfigNamesResource, options *WebAppsClientUpdateSlotConfigurationNamesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, slotConfigNames); err != nil {
		return nil, err
	}
	return req, nil
}

// updateSlotConfigurationNamesHandleResponse handles the UpdateSlotConfigurationNames response.
func (client *WebAppsClient) updateSlotConfigurationNamesHandleResponse(resp *http.Response) (WebAppsClientUpdateSlotConfigurationNamesResponse, error) {
	result := WebAppsClientUpdateSlotConfigurationNamesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SlotConfigNamesResource); err != nil {
		return WebAppsClientUpdateSlotConfigurationNamesResponse{}, err
	}
	return result, nil
}

// UpdateSourceControl - Description for Updates the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - siteSourceControl - JSON representation of a SiteSourceControl object. See example.
//   - options - WebAppsClientUpdateSourceControlOptions contains the optional parameters for the WebAppsClient.UpdateSourceControl
//     method.
func (client *WebAppsClient) UpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsClientUpdateSourceControlOptions) (WebAppsClientUpdateSourceControlResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateSourceControl"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateSourceControlCreateRequest(ctx, resourceGroupName, name, siteSourceControl, options)
	if err != nil {
		return WebAppsClientUpdateSourceControlResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateSourceControlResponse{}, err
	}
	resp, err := client.updateSourceControlHandleResponse(httpResp)
	return resp, err
}

// updateSourceControlCreateRequest creates the UpdateSourceControl request.
func (client *WebAppsClient) updateSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsClientUpdateSourceControlOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteSourceControl); err != nil {
		return nil, err
	}
	return req, nil
}

// updateSourceControlHandleResponse handles the UpdateSourceControl response.
func (client *WebAppsClient) updateSourceControlHandleResponse(resp *http.Response) (WebAppsClientUpdateSourceControlResponse, error) {
	result := WebAppsClientUpdateSourceControlResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteSourceControl); err != nil {
		return WebAppsClientUpdateSourceControlResponse{}, err
	}
	return result, nil
}

// UpdateSourceControlSlot - Description for Updates the source control configuration of an app.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for
//     the production slot.
//   - siteSourceControl - JSON representation of a SiteSourceControl object. See example.
//   - options - WebAppsClientUpdateSourceControlSlotOptions contains the optional parameters for the WebAppsClient.UpdateSourceControlSlot
//     method.
func (client *WebAppsClient) UpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsClientUpdateSourceControlSlotOptions) (WebAppsClientUpdateSourceControlSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateSourceControlSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, siteSourceControl, options)
	if err != nil {
		return WebAppsClientUpdateSourceControlSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateSourceControlSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateSourceControlSlotResponse{}, err
	}
	resp, err := client.updateSourceControlSlotHandleResponse(httpResp)
	return resp, err
}

// updateSourceControlSlotCreateRequest creates the UpdateSourceControlSlot request.
func (client *WebAppsClient) updateSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsClientUpdateSourceControlSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, siteSourceControl); err != nil {
		return nil, err
	}
	return req, nil
}

// updateSourceControlSlotHandleResponse handles the UpdateSourceControlSlot response.
func (client *WebAppsClient) updateSourceControlSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateSourceControlSlotResponse, error) {
	result := WebAppsClientUpdateSourceControlSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteSourceControl); err != nil {
		return WebAppsClientUpdateSourceControlSlotResponse{}, err
	}
	return result, nil
}

// UpdateSwiftVirtualNetworkConnectionWithCheck - Description for Integrates this Web App with a Virtual Network. This requires
// that 1) "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - connectionEnvelope - Properties of the Virtual Network connection. See example.
//   - options - WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckOptions contains the optional parameters for the WebAppsClient.UpdateSwiftVirtualNetworkConnectionWithCheck
//     method.
func (client *WebAppsClient) UpdateSwiftVirtualNetworkConnectionWithCheck(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckOptions) (WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateSwiftVirtualNetworkConnectionWithCheck"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateSwiftVirtualNetworkConnectionWithCheckCreateRequest(ctx, resourceGroupName, name, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, err
	}
	resp, err := client.updateSwiftVirtualNetworkConnectionWithCheckHandleResponse(httpResp)
	return resp, err
}

// updateSwiftVirtualNetworkConnectionWithCheckCreateRequest creates the UpdateSwiftVirtualNetworkConnectionWithCheck request.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// updateSwiftVirtualNetworkConnectionWithCheckHandleResponse handles the UpdateSwiftVirtualNetworkConnectionWithCheck response.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckHandleResponse(resp *http.Response) (WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckResponse, error) {
	result := WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, err
	}
	return result, nil
}

// UpdateSwiftVirtualNetworkConnectionWithCheckSlot - Description for Integrates this Web App with a Virtual Network. This
// requires that 1) "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has already
// been
// delegated, and is not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production
//     slot.
//   - connectionEnvelope - Properties of the Virtual Network connection. See example.
//   - options - WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions contains the optional parameters for the
//     WebAppsClient.UpdateSwiftVirtualNetworkConnectionWithCheckSlot method.
func (client *WebAppsClient) UpdateSwiftVirtualNetworkConnectionWithCheckSlot(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions) (WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateSwiftVirtualNetworkConnectionWithCheckSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest(ctx, resourceGroupName, name, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, err
	}
	resp, err := client.updateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse(httpResp)
	return resp, err
}

// updateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest creates the UpdateSwiftVirtualNetworkConnectionWithCheckSlot request.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// updateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse handles the UpdateSwiftVirtualNetworkConnectionWithCheckSlot response.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse, error) {
	result := WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return WebAppsClientUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, err
	}
	return result, nil
}

// UpdateVnetConnection - Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection
// properties (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of an existing Virtual Network.
//   - connectionEnvelope - Properties of the Virtual Network connection. See example.
//   - options - WebAppsClientUpdateVnetConnectionOptions contains the optional parameters for the WebAppsClient.UpdateVnetConnection
//     method.
func (client *WebAppsClient) UpdateVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfoResource, options *WebAppsClientUpdateVnetConnectionOptions) (WebAppsClientUpdateVnetConnectionResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateVnetConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientUpdateVnetConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateVnetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateVnetConnectionResponse{}, err
	}
	resp, err := client.updateVnetConnectionHandleResponse(httpResp)
	return resp, err
}

// updateVnetConnectionCreateRequest creates the UpdateVnetConnection request.
func (client *WebAppsClient) updateVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfoResource, options *WebAppsClientUpdateVnetConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// updateVnetConnectionHandleResponse handles the UpdateVnetConnection response.
func (client *WebAppsClient) updateVnetConnectionHandleResponse(resp *http.Response) (WebAppsClientUpdateVnetConnectionResponse, error) {
	result := WebAppsClientUpdateVnetConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResource); err != nil {
		return WebAppsClientUpdateVnetConnectionResponse{}, err
	}
	return result, nil
}

// UpdateVnetConnectionGateway - Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of the Virtual Network.
//   - gatewayName - Name of the gateway. Currently, the only supported string is "primary".
//   - connectionEnvelope - The properties to update this gateway with.
//   - options - WebAppsClientUpdateVnetConnectionGatewayOptions contains the optional parameters for the WebAppsClient.UpdateVnetConnectionGateway
//     method.
func (client *WebAppsClient) UpdateVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *WebAppsClientUpdateVnetConnectionGatewayOptions) (WebAppsClientUpdateVnetConnectionGatewayResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateVnetConnectionGateway"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateVnetConnectionGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientUpdateVnetConnectionGatewayResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateVnetConnectionGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateVnetConnectionGatewayResponse{}, err
	}
	resp, err := client.updateVnetConnectionGatewayHandleResponse(httpResp)
	return resp, err
}

// updateVnetConnectionGatewayCreateRequest creates the UpdateVnetConnectionGateway request.
func (client *WebAppsClient) updateVnetConnectionGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *WebAppsClientUpdateVnetConnectionGatewayOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// updateVnetConnectionGatewayHandleResponse handles the UpdateVnetConnectionGateway response.
func (client *WebAppsClient) updateVnetConnectionGatewayHandleResponse(resp *http.Response) (WebAppsClientUpdateVnetConnectionGatewayResponse, error) {
	result := WebAppsClientUpdateVnetConnectionGatewayResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return WebAppsClientUpdateVnetConnectionGatewayResponse{}, err
	}
	return result, nil
}

// UpdateVnetConnectionGatewaySlot - Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of the Virtual Network.
//   - gatewayName - Name of the gateway. Currently, the only supported string is "primary".
//   - slot - Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production
//     slot's Virtual Network.
//   - connectionEnvelope - The properties to update this gateway with.
//   - options - WebAppsClientUpdateVnetConnectionGatewaySlotOptions contains the optional parameters for the WebAppsClient.UpdateVnetConnectionGatewaySlot
//     method.
func (client *WebAppsClient) UpdateVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *WebAppsClientUpdateVnetConnectionGatewaySlotOptions) (WebAppsClientUpdateVnetConnectionGatewaySlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateVnetConnectionGatewaySlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateVnetConnectionGatewaySlotCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	resp, err := client.updateVnetConnectionGatewaySlotHandleResponse(httpResp)
	return resp, err
}

// updateVnetConnectionGatewaySlotCreateRequest creates the UpdateVnetConnectionGatewaySlot request.
func (client *WebAppsClient) updateVnetConnectionGatewaySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *WebAppsClientUpdateVnetConnectionGatewaySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// updateVnetConnectionGatewaySlotHandleResponse handles the UpdateVnetConnectionGatewaySlot response.
func (client *WebAppsClient) updateVnetConnectionGatewaySlotHandleResponse(resp *http.Response) (WebAppsClientUpdateVnetConnectionGatewaySlotResponse, error) {
	result := WebAppsClientUpdateVnetConnectionGatewaySlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return WebAppsClientUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	return result, nil
}

// UpdateVnetConnectionSlot - Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection
// properties (PATCH).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-01-01
//   - resourceGroupName - Name of the resource group to which the resource belongs.
//   - name - Name of the app.
//   - vnetName - Name of an existing Virtual Network.
//   - slot - Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production
//     slot.
//   - connectionEnvelope - Properties of the Virtual Network connection. See example.
//   - options - WebAppsClientUpdateVnetConnectionSlotOptions contains the optional parameters for the WebAppsClient.UpdateVnetConnectionSlot
//     method.
func (client *WebAppsClient) UpdateVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfoResource, options *WebAppsClientUpdateVnetConnectionSlotOptions) (WebAppsClientUpdateVnetConnectionSlotResponse, error) {
	var err error
	const operationName = "WebAppsClient.UpdateVnetConnectionSlot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsClientUpdateVnetConnectionSlotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebAppsClientUpdateVnetConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebAppsClientUpdateVnetConnectionSlotResponse{}, err
	}
	resp, err := client.updateVnetConnectionSlotHandleResponse(httpResp)
	return resp, err
}

// updateVnetConnectionSlotCreateRequest creates the UpdateVnetConnectionSlot request.
func (client *WebAppsClient) updateVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfoResource, options *WebAppsClientUpdateVnetConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, connectionEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// updateVnetConnectionSlotHandleResponse handles the UpdateVnetConnectionSlot response.
func (client *WebAppsClient) updateVnetConnectionSlotHandleResponse(resp *http.Response) (WebAppsClientUpdateVnetConnectionSlotResponse, error) {
	result := WebAppsClientUpdateVnetConnectionSlotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResource); err != nil {
		return WebAppsClientUpdateVnetConnectionSlotResponse{}, err
	}
	return result, nil
}
