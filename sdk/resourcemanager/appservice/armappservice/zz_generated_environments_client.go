//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armappservice

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// EnvironmentsClient contains the methods for the AppServiceEnvironments group.
// Don't use this type directly, use NewEnvironmentsClient() instead.
type EnvironmentsClient struct {
	host           string
	subscriptionID string
	pl             runtime.Pipeline
}

// NewEnvironmentsClient creates a new instance of EnvironmentsClient with the specified values.
// subscriptionID - Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
// credential - used to authorize requests. Usually a credential from azidentity.
// options - pass nil to accept the default values.
func NewEnvironmentsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) *EnvironmentsClient {
	if options == nil {
		options = &arm.ClientOptions{}
	}
	ep := options.Endpoint
	if len(ep) == 0 {
		ep = arm.AzurePublicCloud
	}
	client := &EnvironmentsClient{
		subscriptionID: subscriptionID,
		host:           string(ep),
		pl:             armruntime.NewPipeline(moduleName, moduleVersion, credential, runtime.PipelineOptions{}, options),
	}
	return client
}

// BeginApproveOrRejectPrivateEndpointConnection - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientBeginApproveOrRejectPrivateEndpointConnectionOptions contains the optional parameters for the
// EnvironmentsClient.BeginApproveOrRejectPrivateEndpointConnection method.
func (client *EnvironmentsClient) BeginApproveOrRejectPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *EnvironmentsClientBeginApproveOrRejectPrivateEndpointConnectionOptions) (EnvironmentsClientApproveOrRejectPrivateEndpointConnectionPollerResponse, error) {
	resp, err := client.approveOrRejectPrivateEndpointConnection(ctx, resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options)
	if err != nil {
		return EnvironmentsClientApproveOrRejectPrivateEndpointConnectionPollerResponse{}, err
	}
	result := EnvironmentsClientApproveOrRejectPrivateEndpointConnectionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("EnvironmentsClient.ApproveOrRejectPrivateEndpointConnection", "", resp, client.pl)
	if err != nil {
		return EnvironmentsClientApproveOrRejectPrivateEndpointConnectionPollerResponse{}, err
	}
	result.Poller = &EnvironmentsClientApproveOrRejectPrivateEndpointConnectionPoller{
		pt: pt,
	}
	return result, nil
}

// ApproveOrRejectPrivateEndpointConnection - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
func (client *EnvironmentsClient) approveOrRejectPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *EnvironmentsClientBeginApproveOrRejectPrivateEndpointConnectionOptions) (*http.Response, error) {
	req, err := client.approveOrRejectPrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// approveOrRejectPrivateEndpointConnectionCreateRequest creates the ApproveOrRejectPrivateEndpointConnection request.
func (client *EnvironmentsClient) approveOrRejectPrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *EnvironmentsClientBeginApproveOrRejectPrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, privateEndpointWrapper)
}

// BeginChangeVnet - Description for Move an App Service Environment to a different VNET.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// vnetInfo - Details for the new virtual network.
// options - EnvironmentsClientBeginChangeVnetOptions contains the optional parameters for the EnvironmentsClient.BeginChangeVnet
// method.
func (client *EnvironmentsClient) BeginChangeVnet(ctx context.Context, resourceGroupName string, name string, vnetInfo VirtualNetworkProfile, options *EnvironmentsClientBeginChangeVnetOptions) (EnvironmentsClientChangeVnetPollerResponse, error) {
	resp, err := client.changeVnet(ctx, resourceGroupName, name, vnetInfo, options)
	if err != nil {
		return EnvironmentsClientChangeVnetPollerResponse{}, err
	}
	result := EnvironmentsClientChangeVnetPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("EnvironmentsClient.ChangeVnet", "", resp, client.pl)
	if err != nil {
		return EnvironmentsClientChangeVnetPollerResponse{}, err
	}
	result.Poller = &EnvironmentsClientChangeVnetPoller{
		pt:     pt,
		client: client,
	}
	return result, nil
}

// ChangeVnet - Description for Move an App Service Environment to a different VNET.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *EnvironmentsClient) changeVnet(ctx context.Context, resourceGroupName string, name string, vnetInfo VirtualNetworkProfile, options *EnvironmentsClientBeginChangeVnetOptions) (*http.Response, error) {
	req, err := client.changeVnetCreateRequest(ctx, resourceGroupName, name, vnetInfo, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// changeVnetCreateRequest creates the ChangeVnet request.
func (client *EnvironmentsClient) changeVnetCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetInfo VirtualNetworkProfile, options *EnvironmentsClientBeginChangeVnetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/changeVirtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, vnetInfo)
}

// changeVnetHandleResponse handles the ChangeVnet response.
func (client *EnvironmentsClient) changeVnetHandleResponse(resp *http.Response) (EnvironmentsClientChangeVnetResponse, error) {
	result := EnvironmentsClientChangeVnetResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return EnvironmentsClientChangeVnetResponse{}, err
	}
	return result, nil
}

// BeginCreateOrUpdate - Description for Create or update an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// hostingEnvironmentEnvelope - Configuration details of the App Service Environment.
// options - EnvironmentsClientBeginCreateOrUpdateOptions contains the optional parameters for the EnvironmentsClient.BeginCreateOrUpdate
// method.
func (client *EnvironmentsClient) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, name string, hostingEnvironmentEnvelope EnvironmentResource, options *EnvironmentsClientBeginCreateOrUpdateOptions) (EnvironmentsClientCreateOrUpdatePollerResponse, error) {
	resp, err := client.createOrUpdate(ctx, resourceGroupName, name, hostingEnvironmentEnvelope, options)
	if err != nil {
		return EnvironmentsClientCreateOrUpdatePollerResponse{}, err
	}
	result := EnvironmentsClientCreateOrUpdatePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("EnvironmentsClient.CreateOrUpdate", "", resp, client.pl)
	if err != nil {
		return EnvironmentsClientCreateOrUpdatePollerResponse{}, err
	}
	result.Poller = &EnvironmentsClientCreateOrUpdatePoller{
		pt: pt,
	}
	return result, nil
}

// CreateOrUpdate - Description for Create or update an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *EnvironmentsClient) createOrUpdate(ctx context.Context, resourceGroupName string, name string, hostingEnvironmentEnvelope EnvironmentResource, options *EnvironmentsClientBeginCreateOrUpdateOptions) (*http.Response, error) {
	req, err := client.createOrUpdateCreateRequest(ctx, resourceGroupName, name, hostingEnvironmentEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *EnvironmentsClient) createOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, name string, hostingEnvironmentEnvelope EnvironmentResource, options *EnvironmentsClientBeginCreateOrUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, hostingEnvironmentEnvelope)
}

// BeginCreateOrUpdateMultiRolePool - Description for Create or update a multi-role pool.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// multiRolePoolEnvelope - Properties of the multi-role pool.
// options - EnvironmentsClientBeginCreateOrUpdateMultiRolePoolOptions contains the optional parameters for the EnvironmentsClient.BeginCreateOrUpdateMultiRolePool
// method.
func (client *EnvironmentsClient) BeginCreateOrUpdateMultiRolePool(ctx context.Context, resourceGroupName string, name string, multiRolePoolEnvelope WorkerPoolResource, options *EnvironmentsClientBeginCreateOrUpdateMultiRolePoolOptions) (EnvironmentsClientCreateOrUpdateMultiRolePoolPollerResponse, error) {
	resp, err := client.createOrUpdateMultiRolePool(ctx, resourceGroupName, name, multiRolePoolEnvelope, options)
	if err != nil {
		return EnvironmentsClientCreateOrUpdateMultiRolePoolPollerResponse{}, err
	}
	result := EnvironmentsClientCreateOrUpdateMultiRolePoolPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("EnvironmentsClient.CreateOrUpdateMultiRolePool", "", resp, client.pl)
	if err != nil {
		return EnvironmentsClientCreateOrUpdateMultiRolePoolPollerResponse{}, err
	}
	result.Poller = &EnvironmentsClientCreateOrUpdateMultiRolePoolPoller{
		pt: pt,
	}
	return result, nil
}

// CreateOrUpdateMultiRolePool - Description for Create or update a multi-role pool.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *EnvironmentsClient) createOrUpdateMultiRolePool(ctx context.Context, resourceGroupName string, name string, multiRolePoolEnvelope WorkerPoolResource, options *EnvironmentsClientBeginCreateOrUpdateMultiRolePoolOptions) (*http.Response, error) {
	req, err := client.createOrUpdateMultiRolePoolCreateRequest(ctx, resourceGroupName, name, multiRolePoolEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createOrUpdateMultiRolePoolCreateRequest creates the CreateOrUpdateMultiRolePool request.
func (client *EnvironmentsClient) createOrUpdateMultiRolePoolCreateRequest(ctx context.Context, resourceGroupName string, name string, multiRolePoolEnvelope WorkerPoolResource, options *EnvironmentsClientBeginCreateOrUpdateMultiRolePoolOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, multiRolePoolEnvelope)
}

// BeginCreateOrUpdateWorkerPool - Description for Create or update a worker pool.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// workerPoolName - Name of the worker pool.
// workerPoolEnvelope - Properties of the worker pool.
// options - EnvironmentsClientBeginCreateOrUpdateWorkerPoolOptions contains the optional parameters for the EnvironmentsClient.BeginCreateOrUpdateWorkerPool
// method.
func (client *EnvironmentsClient) BeginCreateOrUpdateWorkerPool(ctx context.Context, resourceGroupName string, name string, workerPoolName string, workerPoolEnvelope WorkerPoolResource, options *EnvironmentsClientBeginCreateOrUpdateWorkerPoolOptions) (EnvironmentsClientCreateOrUpdateWorkerPoolPollerResponse, error) {
	resp, err := client.createOrUpdateWorkerPool(ctx, resourceGroupName, name, workerPoolName, workerPoolEnvelope, options)
	if err != nil {
		return EnvironmentsClientCreateOrUpdateWorkerPoolPollerResponse{}, err
	}
	result := EnvironmentsClientCreateOrUpdateWorkerPoolPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("EnvironmentsClient.CreateOrUpdateWorkerPool", "", resp, client.pl)
	if err != nil {
		return EnvironmentsClientCreateOrUpdateWorkerPoolPollerResponse{}, err
	}
	result.Poller = &EnvironmentsClientCreateOrUpdateWorkerPoolPoller{
		pt: pt,
	}
	return result, nil
}

// CreateOrUpdateWorkerPool - Description for Create or update a worker pool.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *EnvironmentsClient) createOrUpdateWorkerPool(ctx context.Context, resourceGroupName string, name string, workerPoolName string, workerPoolEnvelope WorkerPoolResource, options *EnvironmentsClientBeginCreateOrUpdateWorkerPoolOptions) (*http.Response, error) {
	req, err := client.createOrUpdateWorkerPoolCreateRequest(ctx, resourceGroupName, name, workerPoolName, workerPoolEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// createOrUpdateWorkerPoolCreateRequest creates the CreateOrUpdateWorkerPool request.
func (client *EnvironmentsClient) createOrUpdateWorkerPoolCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, workerPoolEnvelope WorkerPoolResource, options *EnvironmentsClientBeginCreateOrUpdateWorkerPoolOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workerPoolEnvelope)
}

// BeginDelete - Description for Delete an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientBeginDeleteOptions contains the optional parameters for the EnvironmentsClient.BeginDelete
// method.
func (client *EnvironmentsClient) BeginDelete(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientBeginDeleteOptions) (EnvironmentsClientDeletePollerResponse, error) {
	resp, err := client.deleteOperation(ctx, resourceGroupName, name, options)
	if err != nil {
		return EnvironmentsClientDeletePollerResponse{}, err
	}
	result := EnvironmentsClientDeletePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("EnvironmentsClient.Delete", "", resp, client.pl)
	if err != nil {
		return EnvironmentsClientDeletePollerResponse{}, err
	}
	result.Poller = &EnvironmentsClientDeletePoller{
		pt: pt,
	}
	return result, nil
}

// Delete - Description for Delete an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *EnvironmentsClient) deleteOperation(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientBeginDeleteOptions) (*http.Response, error) {
	req, err := client.deleteCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteCreateRequest creates the Delete request.
func (client *EnvironmentsClient) deleteCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientBeginDeleteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ForceDelete != nil {
		reqQP.Set("forceDelete", strconv.FormatBool(*options.ForceDelete))
	}
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginDeletePrivateEndpointConnection - Description for Deletes a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientBeginDeletePrivateEndpointConnectionOptions contains the optional parameters for the EnvironmentsClient.BeginDeletePrivateEndpointConnection
// method.
func (client *EnvironmentsClient) BeginDeletePrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *EnvironmentsClientBeginDeletePrivateEndpointConnectionOptions) (EnvironmentsClientDeletePrivateEndpointConnectionPollerResponse, error) {
	resp, err := client.deletePrivateEndpointConnection(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return EnvironmentsClientDeletePrivateEndpointConnectionPollerResponse{}, err
	}
	result := EnvironmentsClientDeletePrivateEndpointConnectionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("EnvironmentsClient.DeletePrivateEndpointConnection", "", resp, client.pl)
	if err != nil {
		return EnvironmentsClientDeletePrivateEndpointConnectionPollerResponse{}, err
	}
	result.Poller = &EnvironmentsClientDeletePrivateEndpointConnectionPoller{
		pt: pt,
	}
	return result, nil
}

// DeletePrivateEndpointConnection - Description for Deletes a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
func (client *EnvironmentsClient) deletePrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *EnvironmentsClientBeginDeletePrivateEndpointConnectionOptions) (*http.Response, error) {
	req, err := client.deletePrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deletePrivateEndpointConnectionCreateRequest creates the DeletePrivateEndpointConnection request.
func (client *EnvironmentsClient) deletePrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *EnvironmentsClientBeginDeletePrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// Get - Description for Get the properties of an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientGetOptions contains the optional parameters for the EnvironmentsClient.Get method.
func (client *EnvironmentsClient) Get(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetOptions) (EnvironmentsClientGetResponse, error) {
	req, err := client.getCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return EnvironmentsClientGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return EnvironmentsClientGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.getHandleResponse(resp)
}

// getCreateRequest creates the Get request.
func (client *EnvironmentsClient) getCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *EnvironmentsClient) getHandleResponse(resp *http.Response) (EnvironmentsClientGetResponse, error) {
	result := EnvironmentsClientGetResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.EnvironmentResource); err != nil {
		return EnvironmentsClientGetResponse{}, err
	}
	return result, nil
}

// GetAseV3NetworkingConfiguration - Description for Get networking configuration of an App Service Environment
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientGetAseV3NetworkingConfigurationOptions contains the optional parameters for the EnvironmentsClient.GetAseV3NetworkingConfiguration
// method.
func (client *EnvironmentsClient) GetAseV3NetworkingConfiguration(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetAseV3NetworkingConfigurationOptions) (EnvironmentsClientGetAseV3NetworkingConfigurationResponse, error) {
	req, err := client.getAseV3NetworkingConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return EnvironmentsClientGetAseV3NetworkingConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientGetAseV3NetworkingConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return EnvironmentsClientGetAseV3NetworkingConfigurationResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAseV3NetworkingConfigurationHandleResponse(resp)
}

// getAseV3NetworkingConfigurationCreateRequest creates the GetAseV3NetworkingConfiguration request.
func (client *EnvironmentsClient) getAseV3NetworkingConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetAseV3NetworkingConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/networking"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAseV3NetworkingConfigurationHandleResponse handles the GetAseV3NetworkingConfiguration response.
func (client *EnvironmentsClient) getAseV3NetworkingConfigurationHandleResponse(resp *http.Response) (EnvironmentsClientGetAseV3NetworkingConfigurationResponse, error) {
	result := EnvironmentsClientGetAseV3NetworkingConfigurationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AseV3NetworkingConfiguration); err != nil {
		return EnvironmentsClientGetAseV3NetworkingConfigurationResponse{}, err
	}
	return result, nil
}

// GetDiagnosticsItem - Description for Get a diagnostics item for an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// diagnosticsName - Name of the diagnostics item.
// options - EnvironmentsClientGetDiagnosticsItemOptions contains the optional parameters for the EnvironmentsClient.GetDiagnosticsItem
// method.
func (client *EnvironmentsClient) GetDiagnosticsItem(ctx context.Context, resourceGroupName string, name string, diagnosticsName string, options *EnvironmentsClientGetDiagnosticsItemOptions) (EnvironmentsClientGetDiagnosticsItemResponse, error) {
	req, err := client.getDiagnosticsItemCreateRequest(ctx, resourceGroupName, name, diagnosticsName, options)
	if err != nil {
		return EnvironmentsClientGetDiagnosticsItemResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientGetDiagnosticsItemResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return EnvironmentsClientGetDiagnosticsItemResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDiagnosticsItemHandleResponse(resp)
}

// getDiagnosticsItemCreateRequest creates the GetDiagnosticsItem request.
func (client *EnvironmentsClient) getDiagnosticsItemCreateRequest(ctx context.Context, resourceGroupName string, name string, diagnosticsName string, options *EnvironmentsClientGetDiagnosticsItemOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/diagnostics/{diagnosticsName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if diagnosticsName == "" {
		return nil, errors.New("parameter diagnosticsName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticsName}", url.PathEscape(diagnosticsName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDiagnosticsItemHandleResponse handles the GetDiagnosticsItem response.
func (client *EnvironmentsClient) getDiagnosticsItemHandleResponse(resp *http.Response) (EnvironmentsClientGetDiagnosticsItemResponse, error) {
	result := EnvironmentsClientGetDiagnosticsItemResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostingEnvironmentDiagnostics); err != nil {
		return EnvironmentsClientGetDiagnosticsItemResponse{}, err
	}
	return result, nil
}

// GetInboundNetworkDependenciesEndpoints - Description for Get the network endpoints of all inbound dependencies of an App
// Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientGetInboundNetworkDependenciesEndpointsOptions contains the optional parameters for the EnvironmentsClient.GetInboundNetworkDependenciesEndpoints
// method.
func (client *EnvironmentsClient) GetInboundNetworkDependenciesEndpoints(resourceGroupName string, name string, options *EnvironmentsClientGetInboundNetworkDependenciesEndpointsOptions) *EnvironmentsClientGetInboundNetworkDependenciesEndpointsPager {
	return &EnvironmentsClientGetInboundNetworkDependenciesEndpointsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getInboundNetworkDependenciesEndpointsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientGetInboundNetworkDependenciesEndpointsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.InboundEnvironmentEndpointCollection.NextLink)
		},
	}
}

// getInboundNetworkDependenciesEndpointsCreateRequest creates the GetInboundNetworkDependenciesEndpoints request.
func (client *EnvironmentsClient) getInboundNetworkDependenciesEndpointsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetInboundNetworkDependenciesEndpointsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/inboundNetworkDependenciesEndpoints"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInboundNetworkDependenciesEndpointsHandleResponse handles the GetInboundNetworkDependenciesEndpoints response.
func (client *EnvironmentsClient) getInboundNetworkDependenciesEndpointsHandleResponse(resp *http.Response) (EnvironmentsClientGetInboundNetworkDependenciesEndpointsResponse, error) {
	result := EnvironmentsClientGetInboundNetworkDependenciesEndpointsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.InboundEnvironmentEndpointCollection); err != nil {
		return EnvironmentsClientGetInboundNetworkDependenciesEndpointsResponse{}, err
	}
	return result, nil
}

// GetMultiRolePool - Description for Get properties of a multi-role pool.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientGetMultiRolePoolOptions contains the optional parameters for the EnvironmentsClient.GetMultiRolePool
// method.
func (client *EnvironmentsClient) GetMultiRolePool(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetMultiRolePoolOptions) (EnvironmentsClientGetMultiRolePoolResponse, error) {
	req, err := client.getMultiRolePoolCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return EnvironmentsClientGetMultiRolePoolResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientGetMultiRolePoolResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return EnvironmentsClientGetMultiRolePoolResponse{}, runtime.NewResponseError(resp)
	}
	return client.getMultiRolePoolHandleResponse(resp)
}

// getMultiRolePoolCreateRequest creates the GetMultiRolePool request.
func (client *EnvironmentsClient) getMultiRolePoolCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetMultiRolePoolOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiRolePoolHandleResponse handles the GetMultiRolePool response.
func (client *EnvironmentsClient) getMultiRolePoolHandleResponse(resp *http.Response) (EnvironmentsClientGetMultiRolePoolResponse, error) {
	result := EnvironmentsClientGetMultiRolePoolResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkerPoolResource); err != nil {
		return EnvironmentsClientGetMultiRolePoolResponse{}, err
	}
	return result, nil
}

// GetOutboundNetworkDependenciesEndpoints - Description for Get the network endpoints of all outbound dependencies of an
// App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientGetOutboundNetworkDependenciesEndpointsOptions contains the optional parameters for the EnvironmentsClient.GetOutboundNetworkDependenciesEndpoints
// method.
func (client *EnvironmentsClient) GetOutboundNetworkDependenciesEndpoints(resourceGroupName string, name string, options *EnvironmentsClientGetOutboundNetworkDependenciesEndpointsOptions) *EnvironmentsClientGetOutboundNetworkDependenciesEndpointsPager {
	return &EnvironmentsClientGetOutboundNetworkDependenciesEndpointsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getOutboundNetworkDependenciesEndpointsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientGetOutboundNetworkDependenciesEndpointsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.OutboundEnvironmentEndpointCollection.NextLink)
		},
	}
}

// getOutboundNetworkDependenciesEndpointsCreateRequest creates the GetOutboundNetworkDependenciesEndpoints request.
func (client *EnvironmentsClient) getOutboundNetworkDependenciesEndpointsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetOutboundNetworkDependenciesEndpointsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/outboundNetworkDependenciesEndpoints"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getOutboundNetworkDependenciesEndpointsHandleResponse handles the GetOutboundNetworkDependenciesEndpoints response.
func (client *EnvironmentsClient) getOutboundNetworkDependenciesEndpointsHandleResponse(resp *http.Response) (EnvironmentsClientGetOutboundNetworkDependenciesEndpointsResponse, error) {
	result := EnvironmentsClientGetOutboundNetworkDependenciesEndpointsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.OutboundEnvironmentEndpointCollection); err != nil {
		return EnvironmentsClientGetOutboundNetworkDependenciesEndpointsResponse{}, err
	}
	return result, nil
}

// GetPrivateEndpointConnection - Description for Gets a private endpoint connection
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// privateEndpointConnectionName - Name of the private endpoint connection.
// options - EnvironmentsClientGetPrivateEndpointConnectionOptions contains the optional parameters for the EnvironmentsClient.GetPrivateEndpointConnection
// method.
func (client *EnvironmentsClient) GetPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *EnvironmentsClientGetPrivateEndpointConnectionOptions) (EnvironmentsClientGetPrivateEndpointConnectionResponse, error) {
	req, err := client.getPrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return EnvironmentsClientGetPrivateEndpointConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientGetPrivateEndpointConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return EnvironmentsClientGetPrivateEndpointConnectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPrivateEndpointConnectionHandleResponse(resp)
}

// getPrivateEndpointConnectionCreateRequest creates the GetPrivateEndpointConnection request.
func (client *EnvironmentsClient) getPrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *EnvironmentsClientGetPrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionHandleResponse handles the GetPrivateEndpointConnection response.
func (client *EnvironmentsClient) getPrivateEndpointConnectionHandleResponse(resp *http.Response) (EnvironmentsClientGetPrivateEndpointConnectionResponse, error) {
	result := EnvironmentsClientGetPrivateEndpointConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemotePrivateEndpointConnectionARMResource); err != nil {
		return EnvironmentsClientGetPrivateEndpointConnectionResponse{}, err
	}
	return result, nil
}

// GetPrivateEndpointConnectionList - Description for Gets the list of private endpoints associated with a hosting environment
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientGetPrivateEndpointConnectionListOptions contains the optional parameters for the EnvironmentsClient.GetPrivateEndpointConnectionList
// method.
func (client *EnvironmentsClient) GetPrivateEndpointConnectionList(resourceGroupName string, name string, options *EnvironmentsClientGetPrivateEndpointConnectionListOptions) *EnvironmentsClientGetPrivateEndpointConnectionListPager {
	return &EnvironmentsClientGetPrivateEndpointConnectionListPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getPrivateEndpointConnectionListCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientGetPrivateEndpointConnectionListResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PrivateEndpointConnectionCollection.NextLink)
		},
	}
}

// getPrivateEndpointConnectionListCreateRequest creates the GetPrivateEndpointConnectionList request.
func (client *EnvironmentsClient) getPrivateEndpointConnectionListCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetPrivateEndpointConnectionListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionListHandleResponse handles the GetPrivateEndpointConnectionList response.
func (client *EnvironmentsClient) getPrivateEndpointConnectionListHandleResponse(resp *http.Response) (EnvironmentsClientGetPrivateEndpointConnectionListResponse, error) {
	result := EnvironmentsClientGetPrivateEndpointConnectionListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateEndpointConnectionCollection); err != nil {
		return EnvironmentsClientGetPrivateEndpointConnectionListResponse{}, err
	}
	return result, nil
}

// GetPrivateLinkResources - Description for Gets the private link resources
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientGetPrivateLinkResourcesOptions contains the optional parameters for the EnvironmentsClient.GetPrivateLinkResources
// method.
func (client *EnvironmentsClient) GetPrivateLinkResources(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetPrivateLinkResourcesOptions) (EnvironmentsClientGetPrivateLinkResourcesResponse, error) {
	req, err := client.getPrivateLinkResourcesCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return EnvironmentsClientGetPrivateLinkResourcesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientGetPrivateLinkResourcesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return EnvironmentsClientGetPrivateLinkResourcesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPrivateLinkResourcesHandleResponse(resp)
}

// getPrivateLinkResourcesCreateRequest creates the GetPrivateLinkResources request.
func (client *EnvironmentsClient) getPrivateLinkResourcesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetPrivateLinkResourcesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateLinkResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateLinkResourcesHandleResponse handles the GetPrivateLinkResources response.
func (client *EnvironmentsClient) getPrivateLinkResourcesHandleResponse(resp *http.Response) (EnvironmentsClientGetPrivateLinkResourcesResponse, error) {
	result := EnvironmentsClientGetPrivateLinkResourcesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateLinkResourcesWrapper); err != nil {
		return EnvironmentsClientGetPrivateLinkResourcesResponse{}, err
	}
	return result, nil
}

// GetVipInfo - Description for Get IP addresses assigned to an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientGetVipInfoOptions contains the optional parameters for the EnvironmentsClient.GetVipInfo method.
func (client *EnvironmentsClient) GetVipInfo(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetVipInfoOptions) (EnvironmentsClientGetVipInfoResponse, error) {
	req, err := client.getVipInfoCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return EnvironmentsClientGetVipInfoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientGetVipInfoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return EnvironmentsClientGetVipInfoResponse{}, runtime.NewResponseError(resp)
	}
	return client.getVipInfoHandleResponse(resp)
}

// getVipInfoCreateRequest creates the GetVipInfo request.
func (client *EnvironmentsClient) getVipInfoCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientGetVipInfoOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/capacities/virtualip"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getVipInfoHandleResponse handles the GetVipInfo response.
func (client *EnvironmentsClient) getVipInfoHandleResponse(resp *http.Response) (EnvironmentsClientGetVipInfoResponse, error) {
	result := EnvironmentsClientGetVipInfoResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AddressResponse); err != nil {
		return EnvironmentsClientGetVipInfoResponse{}, err
	}
	return result, nil
}

// GetWorkerPool - Description for Get properties of a worker pool.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// workerPoolName - Name of the worker pool.
// options - EnvironmentsClientGetWorkerPoolOptions contains the optional parameters for the EnvironmentsClient.GetWorkerPool
// method.
func (client *EnvironmentsClient) GetWorkerPool(ctx context.Context, resourceGroupName string, name string, workerPoolName string, options *EnvironmentsClientGetWorkerPoolOptions) (EnvironmentsClientGetWorkerPoolResponse, error) {
	req, err := client.getWorkerPoolCreateRequest(ctx, resourceGroupName, name, workerPoolName, options)
	if err != nil {
		return EnvironmentsClientGetWorkerPoolResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientGetWorkerPoolResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return EnvironmentsClientGetWorkerPoolResponse{}, runtime.NewResponseError(resp)
	}
	return client.getWorkerPoolHandleResponse(resp)
}

// getWorkerPoolCreateRequest creates the GetWorkerPool request.
func (client *EnvironmentsClient) getWorkerPoolCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, options *EnvironmentsClientGetWorkerPoolOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getWorkerPoolHandleResponse handles the GetWorkerPool response.
func (client *EnvironmentsClient) getWorkerPoolHandleResponse(resp *http.Response) (EnvironmentsClientGetWorkerPoolResponse, error) {
	result := EnvironmentsClientGetWorkerPoolResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkerPoolResource); err != nil {
		return EnvironmentsClientGetWorkerPoolResponse{}, err
	}
	return result, nil
}

// List - Description for Get all App Service Environments for a subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// options - EnvironmentsClientListOptions contains the optional parameters for the EnvironmentsClient.List method.
func (client *EnvironmentsClient) List(options *EnvironmentsClientListOptions) *EnvironmentsClientListPager {
	return &EnvironmentsClientListPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.EnvironmentCollection.NextLink)
		},
	}
}

// listCreateRequest creates the List request.
func (client *EnvironmentsClient) listCreateRequest(ctx context.Context, options *EnvironmentsClientListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/hostingEnvironments"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHandleResponse handles the List response.
func (client *EnvironmentsClient) listHandleResponse(resp *http.Response) (EnvironmentsClientListResponse, error) {
	result := EnvironmentsClientListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.EnvironmentCollection); err != nil {
		return EnvironmentsClientListResponse{}, err
	}
	return result, nil
}

// ListAppServicePlans - Description for Get all App Service plans in an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientListAppServicePlansOptions contains the optional parameters for the EnvironmentsClient.ListAppServicePlans
// method.
func (client *EnvironmentsClient) ListAppServicePlans(resourceGroupName string, name string, options *EnvironmentsClientListAppServicePlansOptions) *EnvironmentsClientListAppServicePlansPager {
	return &EnvironmentsClientListAppServicePlansPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listAppServicePlansCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListAppServicePlansResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PlanCollection.NextLink)
		},
	}
}

// listAppServicePlansCreateRequest creates the ListAppServicePlans request.
func (client *EnvironmentsClient) listAppServicePlansCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListAppServicePlansOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/serverfarms"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listAppServicePlansHandleResponse handles the ListAppServicePlans response.
func (client *EnvironmentsClient) listAppServicePlansHandleResponse(resp *http.Response) (EnvironmentsClientListAppServicePlansResponse, error) {
	result := EnvironmentsClientListAppServicePlansResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PlanCollection); err != nil {
		return EnvironmentsClientListAppServicePlansResponse{}, err
	}
	return result, nil
}

// ListByResourceGroup - Description for Get all App Service Environments in a resource group.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// options - EnvironmentsClientListByResourceGroupOptions contains the optional parameters for the EnvironmentsClient.ListByResourceGroup
// method.
func (client *EnvironmentsClient) ListByResourceGroup(resourceGroupName string, options *EnvironmentsClientListByResourceGroupOptions) *EnvironmentsClientListByResourceGroupPager {
	return &EnvironmentsClientListByResourceGroupPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listByResourceGroupCreateRequest(ctx, resourceGroupName, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListByResourceGroupResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.EnvironmentCollection.NextLink)
		},
	}
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *EnvironmentsClient) listByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *EnvironmentsClientListByResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *EnvironmentsClient) listByResourceGroupHandleResponse(resp *http.Response) (EnvironmentsClientListByResourceGroupResponse, error) {
	result := EnvironmentsClientListByResourceGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.EnvironmentCollection); err != nil {
		return EnvironmentsClientListByResourceGroupResponse{}, err
	}
	return result, nil
}

// ListCapacities - Description for Get the used, available, and total worker capacity an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientListCapacitiesOptions contains the optional parameters for the EnvironmentsClient.ListCapacities
// method.
func (client *EnvironmentsClient) ListCapacities(resourceGroupName string, name string, options *EnvironmentsClientListCapacitiesOptions) *EnvironmentsClientListCapacitiesPager {
	return &EnvironmentsClientListCapacitiesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listCapacitiesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListCapacitiesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.StampCapacityCollection.NextLink)
		},
	}
}

// listCapacitiesCreateRequest creates the ListCapacities request.
func (client *EnvironmentsClient) listCapacitiesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListCapacitiesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/capacities/compute"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listCapacitiesHandleResponse handles the ListCapacities response.
func (client *EnvironmentsClient) listCapacitiesHandleResponse(resp *http.Response) (EnvironmentsClientListCapacitiesResponse, error) {
	result := EnvironmentsClientListCapacitiesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StampCapacityCollection); err != nil {
		return EnvironmentsClientListCapacitiesResponse{}, err
	}
	return result, nil
}

// ListDiagnostics - Description for Get diagnostic information for an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientListDiagnosticsOptions contains the optional parameters for the EnvironmentsClient.ListDiagnostics
// method.
func (client *EnvironmentsClient) ListDiagnostics(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListDiagnosticsOptions) (EnvironmentsClientListDiagnosticsResponse, error) {
	req, err := client.listDiagnosticsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return EnvironmentsClientListDiagnosticsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientListDiagnosticsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return EnvironmentsClientListDiagnosticsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listDiagnosticsHandleResponse(resp)
}

// listDiagnosticsCreateRequest creates the ListDiagnostics request.
func (client *EnvironmentsClient) listDiagnosticsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListDiagnosticsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/diagnostics"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDiagnosticsHandleResponse handles the ListDiagnostics response.
func (client *EnvironmentsClient) listDiagnosticsHandleResponse(resp *http.Response) (EnvironmentsClientListDiagnosticsResponse, error) {
	result := EnvironmentsClientListDiagnosticsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostingEnvironmentDiagnosticsArray); err != nil {
		return EnvironmentsClientListDiagnosticsResponse{}, err
	}
	return result, nil
}

// ListMultiRoleMetricDefinitions - Description for Get metric definitions for a multi-role pool of an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientListMultiRoleMetricDefinitionsOptions contains the optional parameters for the EnvironmentsClient.ListMultiRoleMetricDefinitions
// method.
func (client *EnvironmentsClient) ListMultiRoleMetricDefinitions(resourceGroupName string, name string, options *EnvironmentsClientListMultiRoleMetricDefinitionsOptions) *EnvironmentsClientListMultiRoleMetricDefinitionsPager {
	return &EnvironmentsClientListMultiRoleMetricDefinitionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listMultiRoleMetricDefinitionsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListMultiRoleMetricDefinitionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ResourceMetricDefinitionCollection.NextLink)
		},
	}
}

// listMultiRoleMetricDefinitionsCreateRequest creates the ListMultiRoleMetricDefinitions request.
func (client *EnvironmentsClient) listMultiRoleMetricDefinitionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListMultiRoleMetricDefinitionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/metricdefinitions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMultiRoleMetricDefinitionsHandleResponse handles the ListMultiRoleMetricDefinitions response.
func (client *EnvironmentsClient) listMultiRoleMetricDefinitionsHandleResponse(resp *http.Response) (EnvironmentsClientListMultiRoleMetricDefinitionsResponse, error) {
	result := EnvironmentsClientListMultiRoleMetricDefinitionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricDefinitionCollection); err != nil {
		return EnvironmentsClientListMultiRoleMetricDefinitionsResponse{}, err
	}
	return result, nil
}

// ListMultiRolePoolInstanceMetricDefinitions - Description for Get metric definitions for a specific instance of a multi-role
// pool of an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// instance - Name of the instance in the multi-role pool.
// options - EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsOptions contains the optional parameters for the
// EnvironmentsClient.ListMultiRolePoolInstanceMetricDefinitions method.
func (client *EnvironmentsClient) ListMultiRolePoolInstanceMetricDefinitions(resourceGroupName string, name string, instance string, options *EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsOptions) *EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsPager {
	return &EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listMultiRolePoolInstanceMetricDefinitionsCreateRequest(ctx, resourceGroupName, name, instance, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ResourceMetricDefinitionCollection.NextLink)
		},
	}
}

// listMultiRolePoolInstanceMetricDefinitionsCreateRequest creates the ListMultiRolePoolInstanceMetricDefinitions request.
func (client *EnvironmentsClient) listMultiRolePoolInstanceMetricDefinitionsCreateRequest(ctx context.Context, resourceGroupName string, name string, instance string, options *EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/instances/{instance}/metricdefinitions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instance == "" {
		return nil, errors.New("parameter instance cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instance}", url.PathEscape(instance))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMultiRolePoolInstanceMetricDefinitionsHandleResponse handles the ListMultiRolePoolInstanceMetricDefinitions response.
func (client *EnvironmentsClient) listMultiRolePoolInstanceMetricDefinitionsHandleResponse(resp *http.Response) (EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsResponse, error) {
	result := EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricDefinitionCollection); err != nil {
		return EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsResponse{}, err
	}
	return result, nil
}

// ListMultiRolePoolSKUs - Description for Get available SKUs for scaling a multi-role pool.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientListMultiRolePoolSKUsOptions contains the optional parameters for the EnvironmentsClient.ListMultiRolePoolSKUs
// method.
func (client *EnvironmentsClient) ListMultiRolePoolSKUs(resourceGroupName string, name string, options *EnvironmentsClientListMultiRolePoolSKUsOptions) *EnvironmentsClientListMultiRolePoolSKUsPager {
	return &EnvironmentsClientListMultiRolePoolSKUsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listMultiRolePoolSKUsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListMultiRolePoolSKUsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SKUInfoCollection.NextLink)
		},
	}
}

// listMultiRolePoolSKUsCreateRequest creates the ListMultiRolePoolSKUs request.
func (client *EnvironmentsClient) listMultiRolePoolSKUsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListMultiRolePoolSKUsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/skus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMultiRolePoolSKUsHandleResponse handles the ListMultiRolePoolSKUs response.
func (client *EnvironmentsClient) listMultiRolePoolSKUsHandleResponse(resp *http.Response) (EnvironmentsClientListMultiRolePoolSKUsResponse, error) {
	result := EnvironmentsClientListMultiRolePoolSKUsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SKUInfoCollection); err != nil {
		return EnvironmentsClientListMultiRolePoolSKUsResponse{}, err
	}
	return result, nil
}

// ListMultiRolePools - Description for Get all multi-role pools.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientListMultiRolePoolsOptions contains the optional parameters for the EnvironmentsClient.ListMultiRolePools
// method.
func (client *EnvironmentsClient) ListMultiRolePools(resourceGroupName string, name string, options *EnvironmentsClientListMultiRolePoolsOptions) *EnvironmentsClientListMultiRolePoolsPager {
	return &EnvironmentsClientListMultiRolePoolsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listMultiRolePoolsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListMultiRolePoolsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkerPoolCollection.NextLink)
		},
	}
}

// listMultiRolePoolsCreateRequest creates the ListMultiRolePools request.
func (client *EnvironmentsClient) listMultiRolePoolsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListMultiRolePoolsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMultiRolePoolsHandleResponse handles the ListMultiRolePools response.
func (client *EnvironmentsClient) listMultiRolePoolsHandleResponse(resp *http.Response) (EnvironmentsClientListMultiRolePoolsResponse, error) {
	result := EnvironmentsClientListMultiRolePoolsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkerPoolCollection); err != nil {
		return EnvironmentsClientListMultiRolePoolsResponse{}, err
	}
	return result, nil
}

// ListMultiRoleUsages - Description for Get usage metrics for a multi-role pool of an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientListMultiRoleUsagesOptions contains the optional parameters for the EnvironmentsClient.ListMultiRoleUsages
// method.
func (client *EnvironmentsClient) ListMultiRoleUsages(resourceGroupName string, name string, options *EnvironmentsClientListMultiRoleUsagesOptions) *EnvironmentsClientListMultiRoleUsagesPager {
	return &EnvironmentsClientListMultiRoleUsagesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listMultiRoleUsagesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListMultiRoleUsagesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.UsageCollection.NextLink)
		},
	}
}

// listMultiRoleUsagesCreateRequest creates the ListMultiRoleUsages request.
func (client *EnvironmentsClient) listMultiRoleUsagesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListMultiRoleUsagesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMultiRoleUsagesHandleResponse handles the ListMultiRoleUsages response.
func (client *EnvironmentsClient) listMultiRoleUsagesHandleResponse(resp *http.Response) (EnvironmentsClientListMultiRoleUsagesResponse, error) {
	result := EnvironmentsClientListMultiRoleUsagesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.UsageCollection); err != nil {
		return EnvironmentsClientListMultiRoleUsagesResponse{}, err
	}
	return result, nil
}

// ListOperations - Description for List all currently running operations on the App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientListOperationsOptions contains the optional parameters for the EnvironmentsClient.ListOperations
// method.
func (client *EnvironmentsClient) ListOperations(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListOperationsOptions) (EnvironmentsClientListOperationsResponse, error) {
	req, err := client.listOperationsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return EnvironmentsClientListOperationsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientListOperationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return EnvironmentsClientListOperationsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listOperationsHandleResponse(resp)
}

// listOperationsCreateRequest creates the ListOperations request.
func (client *EnvironmentsClient) listOperationsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListOperationsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/operations"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listOperationsHandleResponse handles the ListOperations response.
func (client *EnvironmentsClient) listOperationsHandleResponse(resp *http.Response) (EnvironmentsClientListOperationsResponse, error) {
	result := EnvironmentsClientListOperationsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.OperationArray); err != nil {
		return EnvironmentsClientListOperationsResponse{}, err
	}
	return result, nil
}

// ListUsages - Description for Get global usage metrics of an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientListUsagesOptions contains the optional parameters for the EnvironmentsClient.ListUsages method.
func (client *EnvironmentsClient) ListUsages(resourceGroupName string, name string, options *EnvironmentsClientListUsagesOptions) *EnvironmentsClientListUsagesPager {
	return &EnvironmentsClientListUsagesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listUsagesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListUsagesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.CsmUsageQuotaCollection.NextLink)
		},
	}
}

// listUsagesCreateRequest creates the ListUsages request.
func (client *EnvironmentsClient) listUsagesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListUsagesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listUsagesHandleResponse handles the ListUsages response.
func (client *EnvironmentsClient) listUsagesHandleResponse(resp *http.Response) (EnvironmentsClientListUsagesResponse, error) {
	result := EnvironmentsClientListUsagesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmUsageQuotaCollection); err != nil {
		return EnvironmentsClientListUsagesResponse{}, err
	}
	return result, nil
}

// ListWebApps - Description for Get all apps in an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientListWebAppsOptions contains the optional parameters for the EnvironmentsClient.ListWebApps
// method.
func (client *EnvironmentsClient) ListWebApps(resourceGroupName string, name string, options *EnvironmentsClientListWebAppsOptions) *EnvironmentsClientListWebAppsPager {
	return &EnvironmentsClientListWebAppsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWebAppsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListWebAppsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WebAppCollection.NextLink)
		},
	}
}

// listWebAppsCreateRequest creates the ListWebApps request.
func (client *EnvironmentsClient) listWebAppsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListWebAppsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/sites"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.PropertiesToInclude != nil {
		reqQP.Set("propertiesToInclude", *options.PropertiesToInclude)
	}
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWebAppsHandleResponse handles the ListWebApps response.
func (client *EnvironmentsClient) listWebAppsHandleResponse(resp *http.Response) (EnvironmentsClientListWebAppsResponse, error) {
	result := EnvironmentsClientListWebAppsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return EnvironmentsClientListWebAppsResponse{}, err
	}
	return result, nil
}

// ListWebWorkerMetricDefinitions - Description for Get metric definitions for a worker pool of an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// workerPoolName - Name of the worker pool.
// options - EnvironmentsClientListWebWorkerMetricDefinitionsOptions contains the optional parameters for the EnvironmentsClient.ListWebWorkerMetricDefinitions
// method.
func (client *EnvironmentsClient) ListWebWorkerMetricDefinitions(resourceGroupName string, name string, workerPoolName string, options *EnvironmentsClientListWebWorkerMetricDefinitionsOptions) *EnvironmentsClientListWebWorkerMetricDefinitionsPager {
	return &EnvironmentsClientListWebWorkerMetricDefinitionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWebWorkerMetricDefinitionsCreateRequest(ctx, resourceGroupName, name, workerPoolName, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListWebWorkerMetricDefinitionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ResourceMetricDefinitionCollection.NextLink)
		},
	}
}

// listWebWorkerMetricDefinitionsCreateRequest creates the ListWebWorkerMetricDefinitions request.
func (client *EnvironmentsClient) listWebWorkerMetricDefinitionsCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, options *EnvironmentsClientListWebWorkerMetricDefinitionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/metricdefinitions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWebWorkerMetricDefinitionsHandleResponse handles the ListWebWorkerMetricDefinitions response.
func (client *EnvironmentsClient) listWebWorkerMetricDefinitionsHandleResponse(resp *http.Response) (EnvironmentsClientListWebWorkerMetricDefinitionsResponse, error) {
	result := EnvironmentsClientListWebWorkerMetricDefinitionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricDefinitionCollection); err != nil {
		return EnvironmentsClientListWebWorkerMetricDefinitionsResponse{}, err
	}
	return result, nil
}

// ListWebWorkerUsages - Description for Get usage metrics for a worker pool of an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// workerPoolName - Name of the worker pool.
// options - EnvironmentsClientListWebWorkerUsagesOptions contains the optional parameters for the EnvironmentsClient.ListWebWorkerUsages
// method.
func (client *EnvironmentsClient) ListWebWorkerUsages(resourceGroupName string, name string, workerPoolName string, options *EnvironmentsClientListWebWorkerUsagesOptions) *EnvironmentsClientListWebWorkerUsagesPager {
	return &EnvironmentsClientListWebWorkerUsagesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWebWorkerUsagesCreateRequest(ctx, resourceGroupName, name, workerPoolName, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListWebWorkerUsagesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.UsageCollection.NextLink)
		},
	}
}

// listWebWorkerUsagesCreateRequest creates the ListWebWorkerUsages request.
func (client *EnvironmentsClient) listWebWorkerUsagesCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, options *EnvironmentsClientListWebWorkerUsagesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWebWorkerUsagesHandleResponse handles the ListWebWorkerUsages response.
func (client *EnvironmentsClient) listWebWorkerUsagesHandleResponse(resp *http.Response) (EnvironmentsClientListWebWorkerUsagesResponse, error) {
	result := EnvironmentsClientListWebWorkerUsagesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.UsageCollection); err != nil {
		return EnvironmentsClientListWebWorkerUsagesResponse{}, err
	}
	return result, nil
}

// ListWorkerPoolInstanceMetricDefinitions - Description for Get metric definitions for a specific instance of a worker pool
// of an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// workerPoolName - Name of the worker pool.
// instance - Name of the instance in the worker pool.
// options - EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsOptions contains the optional parameters for the EnvironmentsClient.ListWorkerPoolInstanceMetricDefinitions
// method.
func (client *EnvironmentsClient) ListWorkerPoolInstanceMetricDefinitions(resourceGroupName string, name string, workerPoolName string, instance string, options *EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsOptions) *EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsPager {
	return &EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWorkerPoolInstanceMetricDefinitionsCreateRequest(ctx, resourceGroupName, name, workerPoolName, instance, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ResourceMetricDefinitionCollection.NextLink)
		},
	}
}

// listWorkerPoolInstanceMetricDefinitionsCreateRequest creates the ListWorkerPoolInstanceMetricDefinitions request.
func (client *EnvironmentsClient) listWorkerPoolInstanceMetricDefinitionsCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, instance string, options *EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/instances/{instance}/metricdefinitions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if instance == "" {
		return nil, errors.New("parameter instance cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instance}", url.PathEscape(instance))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWorkerPoolInstanceMetricDefinitionsHandleResponse handles the ListWorkerPoolInstanceMetricDefinitions response.
func (client *EnvironmentsClient) listWorkerPoolInstanceMetricDefinitionsHandleResponse(resp *http.Response) (EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsResponse, error) {
	result := EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricDefinitionCollection); err != nil {
		return EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsResponse{}, err
	}
	return result, nil
}

// ListWorkerPoolSKUs - Description for Get available SKUs for scaling a worker pool.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// workerPoolName - Name of the worker pool.
// options - EnvironmentsClientListWorkerPoolSKUsOptions contains the optional parameters for the EnvironmentsClient.ListWorkerPoolSKUs
// method.
func (client *EnvironmentsClient) ListWorkerPoolSKUs(resourceGroupName string, name string, workerPoolName string, options *EnvironmentsClientListWorkerPoolSKUsOptions) *EnvironmentsClientListWorkerPoolSKUsPager {
	return &EnvironmentsClientListWorkerPoolSKUsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWorkerPoolSKUsCreateRequest(ctx, resourceGroupName, name, workerPoolName, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListWorkerPoolSKUsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SKUInfoCollection.NextLink)
		},
	}
}

// listWorkerPoolSKUsCreateRequest creates the ListWorkerPoolSKUs request.
func (client *EnvironmentsClient) listWorkerPoolSKUsCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, options *EnvironmentsClientListWorkerPoolSKUsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/skus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWorkerPoolSKUsHandleResponse handles the ListWorkerPoolSKUs response.
func (client *EnvironmentsClient) listWorkerPoolSKUsHandleResponse(resp *http.Response) (EnvironmentsClientListWorkerPoolSKUsResponse, error) {
	result := EnvironmentsClientListWorkerPoolSKUsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SKUInfoCollection); err != nil {
		return EnvironmentsClientListWorkerPoolSKUsResponse{}, err
	}
	return result, nil
}

// ListWorkerPools - Description for Get all worker pools of an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientListWorkerPoolsOptions contains the optional parameters for the EnvironmentsClient.ListWorkerPools
// method.
func (client *EnvironmentsClient) ListWorkerPools(resourceGroupName string, name string, options *EnvironmentsClientListWorkerPoolsOptions) *EnvironmentsClientListWorkerPoolsPager {
	return &EnvironmentsClientListWorkerPoolsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWorkerPoolsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp EnvironmentsClientListWorkerPoolsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkerPoolCollection.NextLink)
		},
	}
}

// listWorkerPoolsCreateRequest creates the ListWorkerPools request.
func (client *EnvironmentsClient) listWorkerPoolsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientListWorkerPoolsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWorkerPoolsHandleResponse handles the ListWorkerPools response.
func (client *EnvironmentsClient) listWorkerPoolsHandleResponse(resp *http.Response) (EnvironmentsClientListWorkerPoolsResponse, error) {
	result := EnvironmentsClientListWorkerPoolsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkerPoolCollection); err != nil {
		return EnvironmentsClientListWorkerPoolsResponse{}, err
	}
	return result, nil
}

// Reboot - Description for Reboot all machines in an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientRebootOptions contains the optional parameters for the EnvironmentsClient.Reboot method.
func (client *EnvironmentsClient) Reboot(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientRebootOptions) (EnvironmentsClientRebootResponse, error) {
	req, err := client.rebootCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return EnvironmentsClientRebootResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientRebootResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return EnvironmentsClientRebootResponse{}, runtime.NewResponseError(resp)
	}
	return EnvironmentsClientRebootResponse{RawResponse: resp}, nil
}

// rebootCreateRequest creates the Reboot request.
func (client *EnvironmentsClient) rebootCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientRebootOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/reboot"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginResume - Description for Resume an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientBeginResumeOptions contains the optional parameters for the EnvironmentsClient.BeginResume
// method.
func (client *EnvironmentsClient) BeginResume(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientBeginResumeOptions) (EnvironmentsClientResumePollerResponse, error) {
	resp, err := client.resume(ctx, resourceGroupName, name, options)
	if err != nil {
		return EnvironmentsClientResumePollerResponse{}, err
	}
	result := EnvironmentsClientResumePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("EnvironmentsClient.Resume", "", resp, client.pl)
	if err != nil {
		return EnvironmentsClientResumePollerResponse{}, err
	}
	result.Poller = &EnvironmentsClientResumePoller{
		pt:     pt,
		client: client,
	}
	return result, nil
}

// Resume - Description for Resume an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *EnvironmentsClient) resume(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientBeginResumeOptions) (*http.Response, error) {
	req, err := client.resumeCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// resumeCreateRequest creates the Resume request.
func (client *EnvironmentsClient) resumeCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientBeginResumeOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/resume"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// resumeHandleResponse handles the Resume response.
func (client *EnvironmentsClient) resumeHandleResponse(resp *http.Response) (EnvironmentsClientResumeResponse, error) {
	result := EnvironmentsClientResumeResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return EnvironmentsClientResumeResponse{}, err
	}
	return result, nil
}

// BeginSuspend - Description for Suspend an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientBeginSuspendOptions contains the optional parameters for the EnvironmentsClient.BeginSuspend
// method.
func (client *EnvironmentsClient) BeginSuspend(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientBeginSuspendOptions) (EnvironmentsClientSuspendPollerResponse, error) {
	resp, err := client.suspend(ctx, resourceGroupName, name, options)
	if err != nil {
		return EnvironmentsClientSuspendPollerResponse{}, err
	}
	result := EnvironmentsClientSuspendPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("EnvironmentsClient.Suspend", "", resp, client.pl)
	if err != nil {
		return EnvironmentsClientSuspendPollerResponse{}, err
	}
	result.Poller = &EnvironmentsClientSuspendPoller{
		pt:     pt,
		client: client,
	}
	return result, nil
}

// Suspend - Description for Suspend an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *EnvironmentsClient) suspend(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientBeginSuspendOptions) (*http.Response, error) {
	req, err := client.suspendCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// suspendCreateRequest creates the Suspend request.
func (client *EnvironmentsClient) suspendCreateRequest(ctx context.Context, resourceGroupName string, name string, options *EnvironmentsClientBeginSuspendOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/suspend"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// suspendHandleResponse handles the Suspend response.
func (client *EnvironmentsClient) suspendHandleResponse(resp *http.Response) (EnvironmentsClientSuspendResponse, error) {
	result := EnvironmentsClientSuspendResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return EnvironmentsClientSuspendResponse{}, err
	}
	return result, nil
}

// Update - Description for Create or update an App Service Environment.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// hostingEnvironmentEnvelope - Configuration details of the App Service Environment.
// options - EnvironmentsClientUpdateOptions contains the optional parameters for the EnvironmentsClient.Update method.
func (client *EnvironmentsClient) Update(ctx context.Context, resourceGroupName string, name string, hostingEnvironmentEnvelope EnvironmentPatchResource, options *EnvironmentsClientUpdateOptions) (EnvironmentsClientUpdateResponse, error) {
	req, err := client.updateCreateRequest(ctx, resourceGroupName, name, hostingEnvironmentEnvelope, options)
	if err != nil {
		return EnvironmentsClientUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return EnvironmentsClientUpdateResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateHandleResponse(resp)
}

// updateCreateRequest creates the Update request.
func (client *EnvironmentsClient) updateCreateRequest(ctx context.Context, resourceGroupName string, name string, hostingEnvironmentEnvelope EnvironmentPatchResource, options *EnvironmentsClientUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, hostingEnvironmentEnvelope)
}

// updateHandleResponse handles the Update response.
func (client *EnvironmentsClient) updateHandleResponse(resp *http.Response) (EnvironmentsClientUpdateResponse, error) {
	result := EnvironmentsClientUpdateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.EnvironmentResource); err != nil {
		return EnvironmentsClientUpdateResponse{}, err
	}
	return result, nil
}

// UpdateAseNetworkingConfiguration - Description for Update networking configuration of an App Service Environment
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// options - EnvironmentsClientUpdateAseNetworkingConfigurationOptions contains the optional parameters for the EnvironmentsClient.UpdateAseNetworkingConfiguration
// method.
func (client *EnvironmentsClient) UpdateAseNetworkingConfiguration(ctx context.Context, resourceGroupName string, name string, aseNetworkingConfiguration AseV3NetworkingConfiguration, options *EnvironmentsClientUpdateAseNetworkingConfigurationOptions) (EnvironmentsClientUpdateAseNetworkingConfigurationResponse, error) {
	req, err := client.updateAseNetworkingConfigurationCreateRequest(ctx, resourceGroupName, name, aseNetworkingConfiguration, options)
	if err != nil {
		return EnvironmentsClientUpdateAseNetworkingConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientUpdateAseNetworkingConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return EnvironmentsClientUpdateAseNetworkingConfigurationResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateAseNetworkingConfigurationHandleResponse(resp)
}

// updateAseNetworkingConfigurationCreateRequest creates the UpdateAseNetworkingConfiguration request.
func (client *EnvironmentsClient) updateAseNetworkingConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, aseNetworkingConfiguration AseV3NetworkingConfiguration, options *EnvironmentsClientUpdateAseNetworkingConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/networking"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, aseNetworkingConfiguration)
}

// updateAseNetworkingConfigurationHandleResponse handles the UpdateAseNetworkingConfiguration response.
func (client *EnvironmentsClient) updateAseNetworkingConfigurationHandleResponse(resp *http.Response) (EnvironmentsClientUpdateAseNetworkingConfigurationResponse, error) {
	result := EnvironmentsClientUpdateAseNetworkingConfigurationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AseV3NetworkingConfiguration); err != nil {
		return EnvironmentsClientUpdateAseNetworkingConfigurationResponse{}, err
	}
	return result, nil
}

// UpdateMultiRolePool - Description for Create or update a multi-role pool.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// multiRolePoolEnvelope - Properties of the multi-role pool.
// options - EnvironmentsClientUpdateMultiRolePoolOptions contains the optional parameters for the EnvironmentsClient.UpdateMultiRolePool
// method.
func (client *EnvironmentsClient) UpdateMultiRolePool(ctx context.Context, resourceGroupName string, name string, multiRolePoolEnvelope WorkerPoolResource, options *EnvironmentsClientUpdateMultiRolePoolOptions) (EnvironmentsClientUpdateMultiRolePoolResponse, error) {
	req, err := client.updateMultiRolePoolCreateRequest(ctx, resourceGroupName, name, multiRolePoolEnvelope, options)
	if err != nil {
		return EnvironmentsClientUpdateMultiRolePoolResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientUpdateMultiRolePoolResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return EnvironmentsClientUpdateMultiRolePoolResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateMultiRolePoolHandleResponse(resp)
}

// updateMultiRolePoolCreateRequest creates the UpdateMultiRolePool request.
func (client *EnvironmentsClient) updateMultiRolePoolCreateRequest(ctx context.Context, resourceGroupName string, name string, multiRolePoolEnvelope WorkerPoolResource, options *EnvironmentsClientUpdateMultiRolePoolOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, multiRolePoolEnvelope)
}

// updateMultiRolePoolHandleResponse handles the UpdateMultiRolePool response.
func (client *EnvironmentsClient) updateMultiRolePoolHandleResponse(resp *http.Response) (EnvironmentsClientUpdateMultiRolePoolResponse, error) {
	result := EnvironmentsClientUpdateMultiRolePoolResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkerPoolResource); err != nil {
		return EnvironmentsClientUpdateMultiRolePoolResponse{}, err
	}
	return result, nil
}

// UpdateWorkerPool - Description for Create or update a worker pool.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Name of the resource group to which the resource belongs.
// name - Name of the App Service Environment.
// workerPoolName - Name of the worker pool.
// workerPoolEnvelope - Properties of the worker pool.
// options - EnvironmentsClientUpdateWorkerPoolOptions contains the optional parameters for the EnvironmentsClient.UpdateWorkerPool
// method.
func (client *EnvironmentsClient) UpdateWorkerPool(ctx context.Context, resourceGroupName string, name string, workerPoolName string, workerPoolEnvelope WorkerPoolResource, options *EnvironmentsClientUpdateWorkerPoolOptions) (EnvironmentsClientUpdateWorkerPoolResponse, error) {
	req, err := client.updateWorkerPoolCreateRequest(ctx, resourceGroupName, name, workerPoolName, workerPoolEnvelope, options)
	if err != nil {
		return EnvironmentsClientUpdateWorkerPoolResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientUpdateWorkerPoolResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return EnvironmentsClientUpdateWorkerPoolResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateWorkerPoolHandleResponse(resp)
}

// updateWorkerPoolCreateRequest creates the UpdateWorkerPool request.
func (client *EnvironmentsClient) updateWorkerPoolCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, workerPoolEnvelope WorkerPoolResource, options *EnvironmentsClientUpdateWorkerPoolOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workerPoolEnvelope)
}

// updateWorkerPoolHandleResponse handles the UpdateWorkerPool response.
func (client *EnvironmentsClient) updateWorkerPoolHandleResponse(resp *http.Response) (EnvironmentsClientUpdateWorkerPoolResponse, error) {
	result := EnvironmentsClientUpdateWorkerPoolResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkerPoolResource); err != nil {
		return EnvironmentsClientUpdateWorkerPoolResponse{}, err
	}
	return result, nil
}
