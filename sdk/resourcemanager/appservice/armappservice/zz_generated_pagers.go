//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armappservice

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// CertificateOrdersClientListByResourceGroupPager provides operations for iterating over paged responses.
type CertificateOrdersClientListByResourceGroupPager struct {
	client    *CertificateOrdersClient
	current   CertificateOrdersClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CertificateOrdersClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CertificateOrdersClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CertificateOrdersClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CertificateOrderCollection.NextLink == nil || len(*p.current.CertificateOrderCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CertificateOrdersClientListByResourceGroupResponse page.
func (p *CertificateOrdersClientListByResourceGroupPager) PageResponse() CertificateOrdersClientListByResourceGroupResponse {
	return p.current
}

// CertificateOrdersClientListCertificatesPager provides operations for iterating over paged responses.
type CertificateOrdersClientListCertificatesPager struct {
	client    *CertificateOrdersClient
	current   CertificateOrdersClientListCertificatesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CertificateOrdersClientListCertificatesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CertificateOrdersClientListCertificatesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CertificateOrdersClientListCertificatesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CertificateCollection.NextLink == nil || len(*p.current.CertificateCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listCertificatesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CertificateOrdersClientListCertificatesResponse page.
func (p *CertificateOrdersClientListCertificatesPager) PageResponse() CertificateOrdersClientListCertificatesResponse {
	return p.current
}

// CertificateOrdersClientListPager provides operations for iterating over paged responses.
type CertificateOrdersClientListPager struct {
	client    *CertificateOrdersClient
	current   CertificateOrdersClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CertificateOrdersClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CertificateOrdersClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CertificateOrdersClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CertificateOrderCollection.NextLink == nil || len(*p.current.CertificateOrderCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CertificateOrdersClientListResponse page.
func (p *CertificateOrdersClientListPager) PageResponse() CertificateOrdersClientListResponse {
	return p.current
}

// CertificateOrdersDiagnosticsClientListAppServiceCertificateOrderDetectorResponsePager provides operations for iterating over paged responses.
type CertificateOrdersDiagnosticsClientListAppServiceCertificateOrderDetectorResponsePager struct {
	client    *CertificateOrdersDiagnosticsClient
	current   CertificateOrdersDiagnosticsClientListAppServiceCertificateOrderDetectorResponseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CertificateOrdersDiagnosticsClientListAppServiceCertificateOrderDetectorResponseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CertificateOrdersDiagnosticsClientListAppServiceCertificateOrderDetectorResponsePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CertificateOrdersDiagnosticsClientListAppServiceCertificateOrderDetectorResponsePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DetectorResponseCollection.NextLink == nil || len(*p.current.DetectorResponseCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAppServiceCertificateOrderDetectorResponseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CertificateOrdersDiagnosticsClientListAppServiceCertificateOrderDetectorResponseResponse page.
func (p *CertificateOrdersDiagnosticsClientListAppServiceCertificateOrderDetectorResponsePager) PageResponse() CertificateOrdersDiagnosticsClientListAppServiceCertificateOrderDetectorResponseResponse {
	return p.current
}

// CertificateRegistrationProviderClientListOperationsPager provides operations for iterating over paged responses.
type CertificateRegistrationProviderClientListOperationsPager struct {
	client    *CertificateRegistrationProviderClient
	current   CertificateRegistrationProviderClientListOperationsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CertificateRegistrationProviderClientListOperationsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CertificateRegistrationProviderClientListOperationsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CertificateRegistrationProviderClientListOperationsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CsmOperationCollection.NextLink == nil || len(*p.current.CsmOperationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listOperationsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CertificateRegistrationProviderClientListOperationsResponse page.
func (p *CertificateRegistrationProviderClientListOperationsPager) PageResponse() CertificateRegistrationProviderClientListOperationsResponse {
	return p.current
}

// CertificatesClientListByResourceGroupPager provides operations for iterating over paged responses.
type CertificatesClientListByResourceGroupPager struct {
	client    *CertificatesClient
	current   CertificatesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CertificatesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CertificatesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CertificatesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AppCertificateCollection.NextLink == nil || len(*p.current.AppCertificateCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CertificatesClientListByResourceGroupResponse page.
func (p *CertificatesClientListByResourceGroupPager) PageResponse() CertificatesClientListByResourceGroupResponse {
	return p.current
}

// CertificatesClientListPager provides operations for iterating over paged responses.
type CertificatesClientListPager struct {
	client    *CertificatesClient
	current   CertificatesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CertificatesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CertificatesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CertificatesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AppCertificateCollection.NextLink == nil || len(*p.current.AppCertificateCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CertificatesClientListResponse page.
func (p *CertificatesClientListPager) PageResponse() CertificatesClientListResponse {
	return p.current
}

// ContainerAppsClientListByResourceGroupPager provides operations for iterating over paged responses.
type ContainerAppsClientListByResourceGroupPager struct {
	client    *ContainerAppsClient
	current   ContainerAppsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContainerAppsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ContainerAppsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ContainerAppsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContainerAppCollection.NextLink == nil || len(*p.current.ContainerAppCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ContainerAppsClientListByResourceGroupResponse page.
func (p *ContainerAppsClientListByResourceGroupPager) PageResponse() ContainerAppsClientListByResourceGroupResponse {
	return p.current
}

// ContainerAppsClientListBySubscriptionPager provides operations for iterating over paged responses.
type ContainerAppsClientListBySubscriptionPager struct {
	client    *ContainerAppsClient
	current   ContainerAppsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContainerAppsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ContainerAppsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ContainerAppsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContainerAppCollection.NextLink == nil || len(*p.current.ContainerAppCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ContainerAppsClientListBySubscriptionResponse page.
func (p *ContainerAppsClientListBySubscriptionPager) PageResponse() ContainerAppsClientListBySubscriptionResponse {
	return p.current
}

// ContainerAppsRevisionsClientListRevisionsPager provides operations for iterating over paged responses.
type ContainerAppsRevisionsClientListRevisionsPager struct {
	client    *ContainerAppsRevisionsClient
	current   ContainerAppsRevisionsClientListRevisionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContainerAppsRevisionsClientListRevisionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ContainerAppsRevisionsClientListRevisionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ContainerAppsRevisionsClientListRevisionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RevisionCollection.NextLink == nil || len(*p.current.RevisionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listRevisionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ContainerAppsRevisionsClientListRevisionsResponse page.
func (p *ContainerAppsRevisionsClientListRevisionsPager) PageResponse() ContainerAppsRevisionsClientListRevisionsResponse {
	return p.current
}

// DeletedWebAppsClientListByLocationPager provides operations for iterating over paged responses.
type DeletedWebAppsClientListByLocationPager struct {
	client    *DeletedWebAppsClient
	current   DeletedWebAppsClientListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeletedWebAppsClientListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DeletedWebAppsClientListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DeletedWebAppsClientListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeletedWebAppCollection.NextLink == nil || len(*p.current.DeletedWebAppCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DeletedWebAppsClientListByLocationResponse page.
func (p *DeletedWebAppsClientListByLocationPager) PageResponse() DeletedWebAppsClientListByLocationResponse {
	return p.current
}

// DeletedWebAppsClientListPager provides operations for iterating over paged responses.
type DeletedWebAppsClientListPager struct {
	client    *DeletedWebAppsClient
	current   DeletedWebAppsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeletedWebAppsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DeletedWebAppsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DeletedWebAppsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeletedWebAppCollection.NextLink == nil || len(*p.current.DeletedWebAppCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DeletedWebAppsClientListResponse page.
func (p *DeletedWebAppsClientListPager) PageResponse() DeletedWebAppsClientListResponse {
	return p.current
}

// DiagnosticsClientListHostingEnvironmentDetectorResponsesPager provides operations for iterating over paged responses.
type DiagnosticsClientListHostingEnvironmentDetectorResponsesPager struct {
	client    *DiagnosticsClient
	current   DiagnosticsClientListHostingEnvironmentDetectorResponsesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiagnosticsClientListHostingEnvironmentDetectorResponsesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiagnosticsClientListHostingEnvironmentDetectorResponsesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiagnosticsClientListHostingEnvironmentDetectorResponsesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DetectorResponseCollection.NextLink == nil || len(*p.current.DetectorResponseCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHostingEnvironmentDetectorResponsesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiagnosticsClientListHostingEnvironmentDetectorResponsesResponse page.
func (p *DiagnosticsClientListHostingEnvironmentDetectorResponsesPager) PageResponse() DiagnosticsClientListHostingEnvironmentDetectorResponsesResponse {
	return p.current
}

// DiagnosticsClientListSiteAnalysesPager provides operations for iterating over paged responses.
type DiagnosticsClientListSiteAnalysesPager struct {
	client    *DiagnosticsClient
	current   DiagnosticsClientListSiteAnalysesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiagnosticsClientListSiteAnalysesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiagnosticsClientListSiteAnalysesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiagnosticsClientListSiteAnalysesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticAnalysisCollection.NextLink == nil || len(*p.current.DiagnosticAnalysisCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteAnalysesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiagnosticsClientListSiteAnalysesResponse page.
func (p *DiagnosticsClientListSiteAnalysesPager) PageResponse() DiagnosticsClientListSiteAnalysesResponse {
	return p.current
}

// DiagnosticsClientListSiteAnalysesSlotPager provides operations for iterating over paged responses.
type DiagnosticsClientListSiteAnalysesSlotPager struct {
	client    *DiagnosticsClient
	current   DiagnosticsClientListSiteAnalysesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiagnosticsClientListSiteAnalysesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiagnosticsClientListSiteAnalysesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiagnosticsClientListSiteAnalysesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticAnalysisCollection.NextLink == nil || len(*p.current.DiagnosticAnalysisCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteAnalysesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiagnosticsClientListSiteAnalysesSlotResponse page.
func (p *DiagnosticsClientListSiteAnalysesSlotPager) PageResponse() DiagnosticsClientListSiteAnalysesSlotResponse {
	return p.current
}

// DiagnosticsClientListSiteDetectorResponsesPager provides operations for iterating over paged responses.
type DiagnosticsClientListSiteDetectorResponsesPager struct {
	client    *DiagnosticsClient
	current   DiagnosticsClientListSiteDetectorResponsesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiagnosticsClientListSiteDetectorResponsesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiagnosticsClientListSiteDetectorResponsesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiagnosticsClientListSiteDetectorResponsesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DetectorResponseCollection.NextLink == nil || len(*p.current.DetectorResponseCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteDetectorResponsesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiagnosticsClientListSiteDetectorResponsesResponse page.
func (p *DiagnosticsClientListSiteDetectorResponsesPager) PageResponse() DiagnosticsClientListSiteDetectorResponsesResponse {
	return p.current
}

// DiagnosticsClientListSiteDetectorResponsesSlotPager provides operations for iterating over paged responses.
type DiagnosticsClientListSiteDetectorResponsesSlotPager struct {
	client    *DiagnosticsClient
	current   DiagnosticsClientListSiteDetectorResponsesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiagnosticsClientListSiteDetectorResponsesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiagnosticsClientListSiteDetectorResponsesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiagnosticsClientListSiteDetectorResponsesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DetectorResponseCollection.NextLink == nil || len(*p.current.DetectorResponseCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteDetectorResponsesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiagnosticsClientListSiteDetectorResponsesSlotResponse page.
func (p *DiagnosticsClientListSiteDetectorResponsesSlotPager) PageResponse() DiagnosticsClientListSiteDetectorResponsesSlotResponse {
	return p.current
}

// DiagnosticsClientListSiteDetectorsPager provides operations for iterating over paged responses.
type DiagnosticsClientListSiteDetectorsPager struct {
	client    *DiagnosticsClient
	current   DiagnosticsClientListSiteDetectorsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiagnosticsClientListSiteDetectorsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiagnosticsClientListSiteDetectorsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiagnosticsClientListSiteDetectorsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticDetectorCollection.NextLink == nil || len(*p.current.DiagnosticDetectorCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteDetectorsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiagnosticsClientListSiteDetectorsResponse page.
func (p *DiagnosticsClientListSiteDetectorsPager) PageResponse() DiagnosticsClientListSiteDetectorsResponse {
	return p.current
}

// DiagnosticsClientListSiteDetectorsSlotPager provides operations for iterating over paged responses.
type DiagnosticsClientListSiteDetectorsSlotPager struct {
	client    *DiagnosticsClient
	current   DiagnosticsClientListSiteDetectorsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiagnosticsClientListSiteDetectorsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiagnosticsClientListSiteDetectorsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiagnosticsClientListSiteDetectorsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticDetectorCollection.NextLink == nil || len(*p.current.DiagnosticDetectorCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteDetectorsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiagnosticsClientListSiteDetectorsSlotResponse page.
func (p *DiagnosticsClientListSiteDetectorsSlotPager) PageResponse() DiagnosticsClientListSiteDetectorsSlotResponse {
	return p.current
}

// DiagnosticsClientListSiteDiagnosticCategoriesPager provides operations for iterating over paged responses.
type DiagnosticsClientListSiteDiagnosticCategoriesPager struct {
	client    *DiagnosticsClient
	current   DiagnosticsClientListSiteDiagnosticCategoriesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiagnosticsClientListSiteDiagnosticCategoriesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiagnosticsClientListSiteDiagnosticCategoriesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiagnosticsClientListSiteDiagnosticCategoriesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticCategoryCollection.NextLink == nil || len(*p.current.DiagnosticCategoryCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteDiagnosticCategoriesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiagnosticsClientListSiteDiagnosticCategoriesResponse page.
func (p *DiagnosticsClientListSiteDiagnosticCategoriesPager) PageResponse() DiagnosticsClientListSiteDiagnosticCategoriesResponse {
	return p.current
}

// DiagnosticsClientListSiteDiagnosticCategoriesSlotPager provides operations for iterating over paged responses.
type DiagnosticsClientListSiteDiagnosticCategoriesSlotPager struct {
	client    *DiagnosticsClient
	current   DiagnosticsClientListSiteDiagnosticCategoriesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiagnosticsClientListSiteDiagnosticCategoriesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiagnosticsClientListSiteDiagnosticCategoriesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiagnosticsClientListSiteDiagnosticCategoriesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticCategoryCollection.NextLink == nil || len(*p.current.DiagnosticCategoryCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteDiagnosticCategoriesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiagnosticsClientListSiteDiagnosticCategoriesSlotResponse page.
func (p *DiagnosticsClientListSiteDiagnosticCategoriesSlotPager) PageResponse() DiagnosticsClientListSiteDiagnosticCategoriesSlotResponse {
	return p.current
}

// DomainRegistrationProviderClientListOperationsPager provides operations for iterating over paged responses.
type DomainRegistrationProviderClientListOperationsPager struct {
	client    *DomainRegistrationProviderClient
	current   DomainRegistrationProviderClientListOperationsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DomainRegistrationProviderClientListOperationsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DomainRegistrationProviderClientListOperationsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DomainRegistrationProviderClientListOperationsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CsmOperationCollection.NextLink == nil || len(*p.current.CsmOperationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listOperationsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DomainRegistrationProviderClientListOperationsResponse page.
func (p *DomainRegistrationProviderClientListOperationsPager) PageResponse() DomainRegistrationProviderClientListOperationsResponse {
	return p.current
}

// DomainsClientListByResourceGroupPager provides operations for iterating over paged responses.
type DomainsClientListByResourceGroupPager struct {
	client    *DomainsClient
	current   DomainsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DomainsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DomainsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DomainsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DomainCollection.NextLink == nil || len(*p.current.DomainCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DomainsClientListByResourceGroupResponse page.
func (p *DomainsClientListByResourceGroupPager) PageResponse() DomainsClientListByResourceGroupResponse {
	return p.current
}

// DomainsClientListOwnershipIdentifiersPager provides operations for iterating over paged responses.
type DomainsClientListOwnershipIdentifiersPager struct {
	client    *DomainsClient
	current   DomainsClientListOwnershipIdentifiersResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DomainsClientListOwnershipIdentifiersResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DomainsClientListOwnershipIdentifiersPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DomainsClientListOwnershipIdentifiersPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DomainOwnershipIdentifierCollection.NextLink == nil || len(*p.current.DomainOwnershipIdentifierCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listOwnershipIdentifiersHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DomainsClientListOwnershipIdentifiersResponse page.
func (p *DomainsClientListOwnershipIdentifiersPager) PageResponse() DomainsClientListOwnershipIdentifiersResponse {
	return p.current
}

// DomainsClientListPager provides operations for iterating over paged responses.
type DomainsClientListPager struct {
	client    *DomainsClient
	current   DomainsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DomainsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DomainsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DomainsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DomainCollection.NextLink == nil || len(*p.current.DomainCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DomainsClientListResponse page.
func (p *DomainsClientListPager) PageResponse() DomainsClientListResponse {
	return p.current
}

// DomainsClientListRecommendationsPager provides operations for iterating over paged responses.
type DomainsClientListRecommendationsPager struct {
	client    *DomainsClient
	current   DomainsClientListRecommendationsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DomainsClientListRecommendationsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DomainsClientListRecommendationsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DomainsClientListRecommendationsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NameIdentifierCollection.NextLink == nil || len(*p.current.NameIdentifierCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listRecommendationsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DomainsClientListRecommendationsResponse page.
func (p *DomainsClientListRecommendationsPager) PageResponse() DomainsClientListRecommendationsResponse {
	return p.current
}

// EnvironmentsClientChangeVnetPager provides operations for iterating over paged responses.
type EnvironmentsClientChangeVnetPager struct {
	client  *EnvironmentsClient
	current EnvironmentsClientChangeVnetResponse
	err     error
	second  bool
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientChangeVnetPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientChangeVnetPager) NextPage(ctx context.Context) bool {
	if !p.second {
		p.second = true
		return true
	} else if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppCollection.NextLink == nil || len(*p.current.WebAppCollection.NextLink) == 0 {
			return false
		}
	}
	req, err := runtime.NewRequest(ctx, http.MethodGet, *p.current.WebAppCollection.NextLink)
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.changeVnetHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientChangeVnetResponse page.
func (p *EnvironmentsClientChangeVnetPager) PageResponse() EnvironmentsClientChangeVnetResponse {
	return p.current
}

// EnvironmentsClientGetInboundNetworkDependenciesEndpointsPager provides operations for iterating over paged responses.
type EnvironmentsClientGetInboundNetworkDependenciesEndpointsPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientGetInboundNetworkDependenciesEndpointsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientGetInboundNetworkDependenciesEndpointsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientGetInboundNetworkDependenciesEndpointsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientGetInboundNetworkDependenciesEndpointsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InboundEnvironmentEndpointCollection.NextLink == nil || len(*p.current.InboundEnvironmentEndpointCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getInboundNetworkDependenciesEndpointsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientGetInboundNetworkDependenciesEndpointsResponse page.
func (p *EnvironmentsClientGetInboundNetworkDependenciesEndpointsPager) PageResponse() EnvironmentsClientGetInboundNetworkDependenciesEndpointsResponse {
	return p.current
}

// EnvironmentsClientGetOutboundNetworkDependenciesEndpointsPager provides operations for iterating over paged responses.
type EnvironmentsClientGetOutboundNetworkDependenciesEndpointsPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientGetOutboundNetworkDependenciesEndpointsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientGetOutboundNetworkDependenciesEndpointsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientGetOutboundNetworkDependenciesEndpointsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientGetOutboundNetworkDependenciesEndpointsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OutboundEnvironmentEndpointCollection.NextLink == nil || len(*p.current.OutboundEnvironmentEndpointCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getOutboundNetworkDependenciesEndpointsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientGetOutboundNetworkDependenciesEndpointsResponse page.
func (p *EnvironmentsClientGetOutboundNetworkDependenciesEndpointsPager) PageResponse() EnvironmentsClientGetOutboundNetworkDependenciesEndpointsResponse {
	return p.current
}

// EnvironmentsClientGetPrivateEndpointConnectionListPager provides operations for iterating over paged responses.
type EnvironmentsClientGetPrivateEndpointConnectionListPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientGetPrivateEndpointConnectionListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientGetPrivateEndpointConnectionListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientGetPrivateEndpointConnectionListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientGetPrivateEndpointConnectionListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionCollection.NextLink == nil || len(*p.current.PrivateEndpointConnectionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getPrivateEndpointConnectionListHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientGetPrivateEndpointConnectionListResponse page.
func (p *EnvironmentsClientGetPrivateEndpointConnectionListPager) PageResponse() EnvironmentsClientGetPrivateEndpointConnectionListResponse {
	return p.current
}

// EnvironmentsClientListAppServicePlansPager provides operations for iterating over paged responses.
type EnvironmentsClientListAppServicePlansPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListAppServicePlansResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListAppServicePlansResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListAppServicePlansPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListAppServicePlansPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PlanCollection.NextLink == nil || len(*p.current.PlanCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAppServicePlansHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListAppServicePlansResponse page.
func (p *EnvironmentsClientListAppServicePlansPager) PageResponse() EnvironmentsClientListAppServicePlansResponse {
	return p.current
}

// EnvironmentsClientListByResourceGroupPager provides operations for iterating over paged responses.
type EnvironmentsClientListByResourceGroupPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EnvironmentCollection.NextLink == nil || len(*p.current.EnvironmentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListByResourceGroupResponse page.
func (p *EnvironmentsClientListByResourceGroupPager) PageResponse() EnvironmentsClientListByResourceGroupResponse {
	return p.current
}

// EnvironmentsClientListCapacitiesPager provides operations for iterating over paged responses.
type EnvironmentsClientListCapacitiesPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListCapacitiesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListCapacitiesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListCapacitiesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListCapacitiesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StampCapacityCollection.NextLink == nil || len(*p.current.StampCapacityCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listCapacitiesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListCapacitiesResponse page.
func (p *EnvironmentsClientListCapacitiesPager) PageResponse() EnvironmentsClientListCapacitiesResponse {
	return p.current
}

// EnvironmentsClientListMultiRoleMetricDefinitionsPager provides operations for iterating over paged responses.
type EnvironmentsClientListMultiRoleMetricDefinitionsPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListMultiRoleMetricDefinitionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListMultiRoleMetricDefinitionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListMultiRoleMetricDefinitionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListMultiRoleMetricDefinitionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceMetricDefinitionCollection.NextLink == nil || len(*p.current.ResourceMetricDefinitionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listMultiRoleMetricDefinitionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListMultiRoleMetricDefinitionsResponse page.
func (p *EnvironmentsClientListMultiRoleMetricDefinitionsPager) PageResponse() EnvironmentsClientListMultiRoleMetricDefinitionsResponse {
	return p.current
}

// EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsPager provides operations for iterating over paged responses.
type EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceMetricDefinitionCollection.NextLink == nil || len(*p.current.ResourceMetricDefinitionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listMultiRolePoolInstanceMetricDefinitionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsResponse page.
func (p *EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsPager) PageResponse() EnvironmentsClientListMultiRolePoolInstanceMetricDefinitionsResponse {
	return p.current
}

// EnvironmentsClientListMultiRolePoolSKUsPager provides operations for iterating over paged responses.
type EnvironmentsClientListMultiRolePoolSKUsPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListMultiRolePoolSKUsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListMultiRolePoolSKUsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListMultiRolePoolSKUsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListMultiRolePoolSKUsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SKUInfoCollection.NextLink == nil || len(*p.current.SKUInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listMultiRolePoolSKUsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListMultiRolePoolSKUsResponse page.
func (p *EnvironmentsClientListMultiRolePoolSKUsPager) PageResponse() EnvironmentsClientListMultiRolePoolSKUsResponse {
	return p.current
}

// EnvironmentsClientListMultiRolePoolsPager provides operations for iterating over paged responses.
type EnvironmentsClientListMultiRolePoolsPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListMultiRolePoolsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListMultiRolePoolsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListMultiRolePoolsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListMultiRolePoolsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkerPoolCollection.NextLink == nil || len(*p.current.WorkerPoolCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listMultiRolePoolsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListMultiRolePoolsResponse page.
func (p *EnvironmentsClientListMultiRolePoolsPager) PageResponse() EnvironmentsClientListMultiRolePoolsResponse {
	return p.current
}

// EnvironmentsClientListMultiRoleUsagesPager provides operations for iterating over paged responses.
type EnvironmentsClientListMultiRoleUsagesPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListMultiRoleUsagesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListMultiRoleUsagesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListMultiRoleUsagesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListMultiRoleUsagesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsageCollection.NextLink == nil || len(*p.current.UsageCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listMultiRoleUsagesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListMultiRoleUsagesResponse page.
func (p *EnvironmentsClientListMultiRoleUsagesPager) PageResponse() EnvironmentsClientListMultiRoleUsagesResponse {
	return p.current
}

// EnvironmentsClientListPager provides operations for iterating over paged responses.
type EnvironmentsClientListPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EnvironmentCollection.NextLink == nil || len(*p.current.EnvironmentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListResponse page.
func (p *EnvironmentsClientListPager) PageResponse() EnvironmentsClientListResponse {
	return p.current
}

// EnvironmentsClientListUsagesPager provides operations for iterating over paged responses.
type EnvironmentsClientListUsagesPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListUsagesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListUsagesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListUsagesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListUsagesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CsmUsageQuotaCollection.NextLink == nil || len(*p.current.CsmUsageQuotaCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listUsagesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListUsagesResponse page.
func (p *EnvironmentsClientListUsagesPager) PageResponse() EnvironmentsClientListUsagesResponse {
	return p.current
}

// EnvironmentsClientListWebAppsPager provides operations for iterating over paged responses.
type EnvironmentsClientListWebAppsPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListWebAppsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListWebAppsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListWebAppsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListWebAppsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppCollection.NextLink == nil || len(*p.current.WebAppCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listWebAppsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListWebAppsResponse page.
func (p *EnvironmentsClientListWebAppsPager) PageResponse() EnvironmentsClientListWebAppsResponse {
	return p.current
}

// EnvironmentsClientListWebWorkerMetricDefinitionsPager provides operations for iterating over paged responses.
type EnvironmentsClientListWebWorkerMetricDefinitionsPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListWebWorkerMetricDefinitionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListWebWorkerMetricDefinitionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListWebWorkerMetricDefinitionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListWebWorkerMetricDefinitionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceMetricDefinitionCollection.NextLink == nil || len(*p.current.ResourceMetricDefinitionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listWebWorkerMetricDefinitionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListWebWorkerMetricDefinitionsResponse page.
func (p *EnvironmentsClientListWebWorkerMetricDefinitionsPager) PageResponse() EnvironmentsClientListWebWorkerMetricDefinitionsResponse {
	return p.current
}

// EnvironmentsClientListWebWorkerUsagesPager provides operations for iterating over paged responses.
type EnvironmentsClientListWebWorkerUsagesPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListWebWorkerUsagesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListWebWorkerUsagesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListWebWorkerUsagesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListWebWorkerUsagesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsageCollection.NextLink == nil || len(*p.current.UsageCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listWebWorkerUsagesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListWebWorkerUsagesResponse page.
func (p *EnvironmentsClientListWebWorkerUsagesPager) PageResponse() EnvironmentsClientListWebWorkerUsagesResponse {
	return p.current
}

// EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsPager provides operations for iterating over paged responses.
type EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceMetricDefinitionCollection.NextLink == nil || len(*p.current.ResourceMetricDefinitionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listWorkerPoolInstanceMetricDefinitionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsResponse page.
func (p *EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsPager) PageResponse() EnvironmentsClientListWorkerPoolInstanceMetricDefinitionsResponse {
	return p.current
}

// EnvironmentsClientListWorkerPoolSKUsPager provides operations for iterating over paged responses.
type EnvironmentsClientListWorkerPoolSKUsPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListWorkerPoolSKUsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListWorkerPoolSKUsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListWorkerPoolSKUsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListWorkerPoolSKUsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SKUInfoCollection.NextLink == nil || len(*p.current.SKUInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listWorkerPoolSKUsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListWorkerPoolSKUsResponse page.
func (p *EnvironmentsClientListWorkerPoolSKUsPager) PageResponse() EnvironmentsClientListWorkerPoolSKUsResponse {
	return p.current
}

// EnvironmentsClientListWorkerPoolsPager provides operations for iterating over paged responses.
type EnvironmentsClientListWorkerPoolsPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListWorkerPoolsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListWorkerPoolsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientListWorkerPoolsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientListWorkerPoolsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkerPoolCollection.NextLink == nil || len(*p.current.WorkerPoolCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listWorkerPoolsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientListWorkerPoolsResponse page.
func (p *EnvironmentsClientListWorkerPoolsPager) PageResponse() EnvironmentsClientListWorkerPoolsResponse {
	return p.current
}

// EnvironmentsClientResumePager provides operations for iterating over paged responses.
type EnvironmentsClientResumePager struct {
	client  *EnvironmentsClient
	current EnvironmentsClientResumeResponse
	err     error
	second  bool
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientResumePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientResumePager) NextPage(ctx context.Context) bool {
	if !p.second {
		p.second = true
		return true
	} else if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppCollection.NextLink == nil || len(*p.current.WebAppCollection.NextLink) == 0 {
			return false
		}
	}
	req, err := runtime.NewRequest(ctx, http.MethodGet, *p.current.WebAppCollection.NextLink)
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.resumeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientResumeResponse page.
func (p *EnvironmentsClientResumePager) PageResponse() EnvironmentsClientResumeResponse {
	return p.current
}

// EnvironmentsClientSuspendPager provides operations for iterating over paged responses.
type EnvironmentsClientSuspendPager struct {
	client  *EnvironmentsClient
	current EnvironmentsClientSuspendResponse
	err     error
	second  bool
}

// Err returns the last error encountered while paging.
func (p *EnvironmentsClientSuspendPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnvironmentsClientSuspendPager) NextPage(ctx context.Context) bool {
	if !p.second {
		p.second = true
		return true
	} else if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppCollection.NextLink == nil || len(*p.current.WebAppCollection.NextLink) == 0 {
			return false
		}
	}
	req, err := runtime.NewRequest(ctx, http.MethodGet, *p.current.WebAppCollection.NextLink)
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.suspendHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnvironmentsClientSuspendResponse page.
func (p *EnvironmentsClientSuspendPager) PageResponse() EnvironmentsClientSuspendResponse {
	return p.current
}

// KubeEnvironmentsClientListByResourceGroupPager provides operations for iterating over paged responses.
type KubeEnvironmentsClientListByResourceGroupPager struct {
	client    *KubeEnvironmentsClient
	current   KubeEnvironmentsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, KubeEnvironmentsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *KubeEnvironmentsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *KubeEnvironmentsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.KubeEnvironmentCollection.NextLink == nil || len(*p.current.KubeEnvironmentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current KubeEnvironmentsClientListByResourceGroupResponse page.
func (p *KubeEnvironmentsClientListByResourceGroupPager) PageResponse() KubeEnvironmentsClientListByResourceGroupResponse {
	return p.current
}

// KubeEnvironmentsClientListBySubscriptionPager provides operations for iterating over paged responses.
type KubeEnvironmentsClientListBySubscriptionPager struct {
	client    *KubeEnvironmentsClient
	current   KubeEnvironmentsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, KubeEnvironmentsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *KubeEnvironmentsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *KubeEnvironmentsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.KubeEnvironmentCollection.NextLink == nil || len(*p.current.KubeEnvironmentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current KubeEnvironmentsClientListBySubscriptionResponse page.
func (p *KubeEnvironmentsClientListBySubscriptionPager) PageResponse() KubeEnvironmentsClientListBySubscriptionResponse {
	return p.current
}

// PlansClientListByResourceGroupPager provides operations for iterating over paged responses.
type PlansClientListByResourceGroupPager struct {
	client    *PlansClient
	current   PlansClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PlansClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PlansClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PlansClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PlanCollection.NextLink == nil || len(*p.current.PlanCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PlansClientListByResourceGroupResponse page.
func (p *PlansClientListByResourceGroupPager) PageResponse() PlansClientListByResourceGroupResponse {
	return p.current
}

// PlansClientListHybridConnectionsPager provides operations for iterating over paged responses.
type PlansClientListHybridConnectionsPager struct {
	client    *PlansClient
	current   PlansClientListHybridConnectionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PlansClientListHybridConnectionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PlansClientListHybridConnectionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PlansClientListHybridConnectionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.HybridConnectionCollection.NextLink == nil || len(*p.current.HybridConnectionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHybridConnectionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PlansClientListHybridConnectionsResponse page.
func (p *PlansClientListHybridConnectionsPager) PageResponse() PlansClientListHybridConnectionsResponse {
	return p.current
}

// PlansClientListPager provides operations for iterating over paged responses.
type PlansClientListPager struct {
	client    *PlansClient
	current   PlansClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PlansClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PlansClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PlansClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PlanCollection.NextLink == nil || len(*p.current.PlanCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PlansClientListResponse page.
func (p *PlansClientListPager) PageResponse() PlansClientListResponse {
	return p.current
}

// PlansClientListUsagesPager provides operations for iterating over paged responses.
type PlansClientListUsagesPager struct {
	client    *PlansClient
	current   PlansClientListUsagesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PlansClientListUsagesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PlansClientListUsagesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PlansClientListUsagesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CsmUsageQuotaCollection.NextLink == nil || len(*p.current.CsmUsageQuotaCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listUsagesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PlansClientListUsagesResponse page.
func (p *PlansClientListUsagesPager) PageResponse() PlansClientListUsagesResponse {
	return p.current
}

// PlansClientListWebAppsByHybridConnectionPager provides operations for iterating over paged responses.
type PlansClientListWebAppsByHybridConnectionPager struct {
	client    *PlansClient
	current   PlansClientListWebAppsByHybridConnectionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PlansClientListWebAppsByHybridConnectionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PlansClientListWebAppsByHybridConnectionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PlansClientListWebAppsByHybridConnectionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceCollection.NextLink == nil || len(*p.current.ResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listWebAppsByHybridConnectionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PlansClientListWebAppsByHybridConnectionResponse page.
func (p *PlansClientListWebAppsByHybridConnectionPager) PageResponse() PlansClientListWebAppsByHybridConnectionResponse {
	return p.current
}

// PlansClientListWebAppsPager provides operations for iterating over paged responses.
type PlansClientListWebAppsPager struct {
	client    *PlansClient
	current   PlansClientListWebAppsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PlansClientListWebAppsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PlansClientListWebAppsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PlansClientListWebAppsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppCollection.NextLink == nil || len(*p.current.WebAppCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listWebAppsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PlansClientListWebAppsResponse page.
func (p *PlansClientListWebAppsPager) PageResponse() PlansClientListWebAppsResponse {
	return p.current
}

// ProviderClientGetAvailableStacksOnPremPager provides operations for iterating over paged responses.
type ProviderClientGetAvailableStacksOnPremPager struct {
	client    *ProviderClient
	current   ProviderClientGetAvailableStacksOnPremResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProviderClientGetAvailableStacksOnPremResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProviderClientGetAvailableStacksOnPremPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProviderClientGetAvailableStacksOnPremPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationStackCollection.NextLink == nil || len(*p.current.ApplicationStackCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getAvailableStacksOnPremHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProviderClientGetAvailableStacksOnPremResponse page.
func (p *ProviderClientGetAvailableStacksOnPremPager) PageResponse() ProviderClientGetAvailableStacksOnPremResponse {
	return p.current
}

// ProviderClientGetAvailableStacksPager provides operations for iterating over paged responses.
type ProviderClientGetAvailableStacksPager struct {
	client    *ProviderClient
	current   ProviderClientGetAvailableStacksResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProviderClientGetAvailableStacksResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProviderClientGetAvailableStacksPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProviderClientGetAvailableStacksPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationStackCollection.NextLink == nil || len(*p.current.ApplicationStackCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getAvailableStacksHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProviderClientGetAvailableStacksResponse page.
func (p *ProviderClientGetAvailableStacksPager) PageResponse() ProviderClientGetAvailableStacksResponse {
	return p.current
}

// ProviderClientGetFunctionAppStacksForLocationPager provides operations for iterating over paged responses.
type ProviderClientGetFunctionAppStacksForLocationPager struct {
	client    *ProviderClient
	current   ProviderClientGetFunctionAppStacksForLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProviderClientGetFunctionAppStacksForLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProviderClientGetFunctionAppStacksForLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProviderClientGetFunctionAppStacksForLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FunctionAppStackCollection.NextLink == nil || len(*p.current.FunctionAppStackCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getFunctionAppStacksForLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProviderClientGetFunctionAppStacksForLocationResponse page.
func (p *ProviderClientGetFunctionAppStacksForLocationPager) PageResponse() ProviderClientGetFunctionAppStacksForLocationResponse {
	return p.current
}

// ProviderClientGetFunctionAppStacksPager provides operations for iterating over paged responses.
type ProviderClientGetFunctionAppStacksPager struct {
	client    *ProviderClient
	current   ProviderClientGetFunctionAppStacksResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProviderClientGetFunctionAppStacksResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProviderClientGetFunctionAppStacksPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProviderClientGetFunctionAppStacksPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FunctionAppStackCollection.NextLink == nil || len(*p.current.FunctionAppStackCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getFunctionAppStacksHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProviderClientGetFunctionAppStacksResponse page.
func (p *ProviderClientGetFunctionAppStacksPager) PageResponse() ProviderClientGetFunctionAppStacksResponse {
	return p.current
}

// ProviderClientGetWebAppStacksForLocationPager provides operations for iterating over paged responses.
type ProviderClientGetWebAppStacksForLocationPager struct {
	client    *ProviderClient
	current   ProviderClientGetWebAppStacksForLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProviderClientGetWebAppStacksForLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProviderClientGetWebAppStacksForLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProviderClientGetWebAppStacksForLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppStackCollection.NextLink == nil || len(*p.current.WebAppStackCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getWebAppStacksForLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProviderClientGetWebAppStacksForLocationResponse page.
func (p *ProviderClientGetWebAppStacksForLocationPager) PageResponse() ProviderClientGetWebAppStacksForLocationResponse {
	return p.current
}

// ProviderClientGetWebAppStacksPager provides operations for iterating over paged responses.
type ProviderClientGetWebAppStacksPager struct {
	client    *ProviderClient
	current   ProviderClientGetWebAppStacksResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProviderClientGetWebAppStacksResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProviderClientGetWebAppStacksPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProviderClientGetWebAppStacksPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppStackCollection.NextLink == nil || len(*p.current.WebAppStackCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getWebAppStacksHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProviderClientGetWebAppStacksResponse page.
func (p *ProviderClientGetWebAppStacksPager) PageResponse() ProviderClientGetWebAppStacksResponse {
	return p.current
}

// ProviderClientListOperationsPager provides operations for iterating over paged responses.
type ProviderClientListOperationsPager struct {
	client    *ProviderClient
	current   ProviderClientListOperationsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProviderClientListOperationsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProviderClientListOperationsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProviderClientListOperationsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CsmOperationCollection.NextLink == nil || len(*p.current.CsmOperationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listOperationsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProviderClientListOperationsResponse page.
func (p *ProviderClientListOperationsPager) PageResponse() ProviderClientListOperationsResponse {
	return p.current
}

// RecommendationsClientListHistoryForHostingEnvironmentPager provides operations for iterating over paged responses.
type RecommendationsClientListHistoryForHostingEnvironmentPager struct {
	client    *RecommendationsClient
	current   RecommendationsClientListHistoryForHostingEnvironmentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RecommendationsClientListHistoryForHostingEnvironmentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RecommendationsClientListHistoryForHostingEnvironmentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RecommendationsClientListHistoryForHostingEnvironmentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RecommendationCollection.NextLink == nil || len(*p.current.RecommendationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHistoryForHostingEnvironmentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RecommendationsClientListHistoryForHostingEnvironmentResponse page.
func (p *RecommendationsClientListHistoryForHostingEnvironmentPager) PageResponse() RecommendationsClientListHistoryForHostingEnvironmentResponse {
	return p.current
}

// RecommendationsClientListHistoryForWebAppPager provides operations for iterating over paged responses.
type RecommendationsClientListHistoryForWebAppPager struct {
	client    *RecommendationsClient
	current   RecommendationsClientListHistoryForWebAppResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RecommendationsClientListHistoryForWebAppResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RecommendationsClientListHistoryForWebAppPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RecommendationsClientListHistoryForWebAppPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RecommendationCollection.NextLink == nil || len(*p.current.RecommendationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHistoryForWebAppHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RecommendationsClientListHistoryForWebAppResponse page.
func (p *RecommendationsClientListHistoryForWebAppPager) PageResponse() RecommendationsClientListHistoryForWebAppResponse {
	return p.current
}

// RecommendationsClientListPager provides operations for iterating over paged responses.
type RecommendationsClientListPager struct {
	client    *RecommendationsClient
	current   RecommendationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RecommendationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RecommendationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RecommendationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RecommendationCollection.NextLink == nil || len(*p.current.RecommendationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RecommendationsClientListResponse page.
func (p *RecommendationsClientListPager) PageResponse() RecommendationsClientListResponse {
	return p.current
}

// RecommendationsClientListRecommendedRulesForHostingEnvironmentPager provides operations for iterating over paged responses.
type RecommendationsClientListRecommendedRulesForHostingEnvironmentPager struct {
	client    *RecommendationsClient
	current   RecommendationsClientListRecommendedRulesForHostingEnvironmentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RecommendationsClientListRecommendedRulesForHostingEnvironmentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RecommendationsClientListRecommendedRulesForHostingEnvironmentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RecommendationsClientListRecommendedRulesForHostingEnvironmentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RecommendationCollection.NextLink == nil || len(*p.current.RecommendationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listRecommendedRulesForHostingEnvironmentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RecommendationsClientListRecommendedRulesForHostingEnvironmentResponse page.
func (p *RecommendationsClientListRecommendedRulesForHostingEnvironmentPager) PageResponse() RecommendationsClientListRecommendedRulesForHostingEnvironmentResponse {
	return p.current
}

// RecommendationsClientListRecommendedRulesForWebAppPager provides operations for iterating over paged responses.
type RecommendationsClientListRecommendedRulesForWebAppPager struct {
	client    *RecommendationsClient
	current   RecommendationsClientListRecommendedRulesForWebAppResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RecommendationsClientListRecommendedRulesForWebAppResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RecommendationsClientListRecommendedRulesForWebAppPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RecommendationsClientListRecommendedRulesForWebAppPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RecommendationCollection.NextLink == nil || len(*p.current.RecommendationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listRecommendedRulesForWebAppHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RecommendationsClientListRecommendedRulesForWebAppResponse page.
func (p *RecommendationsClientListRecommendedRulesForWebAppPager) PageResponse() RecommendationsClientListRecommendedRulesForWebAppResponse {
	return p.current
}

// ResourceHealthMetadataClientListByResourceGroupPager provides operations for iterating over paged responses.
type ResourceHealthMetadataClientListByResourceGroupPager struct {
	client    *ResourceHealthMetadataClient
	current   ResourceHealthMetadataClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ResourceHealthMetadataClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ResourceHealthMetadataClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ResourceHealthMetadataClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceHealthMetadataCollection.NextLink == nil || len(*p.current.ResourceHealthMetadataCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ResourceHealthMetadataClientListByResourceGroupResponse page.
func (p *ResourceHealthMetadataClientListByResourceGroupPager) PageResponse() ResourceHealthMetadataClientListByResourceGroupResponse {
	return p.current
}

// ResourceHealthMetadataClientListBySitePager provides operations for iterating over paged responses.
type ResourceHealthMetadataClientListBySitePager struct {
	client    *ResourceHealthMetadataClient
	current   ResourceHealthMetadataClientListBySiteResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ResourceHealthMetadataClientListBySiteResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ResourceHealthMetadataClientListBySitePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ResourceHealthMetadataClientListBySitePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceHealthMetadataCollection.NextLink == nil || len(*p.current.ResourceHealthMetadataCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySiteHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ResourceHealthMetadataClientListBySiteResponse page.
func (p *ResourceHealthMetadataClientListBySitePager) PageResponse() ResourceHealthMetadataClientListBySiteResponse {
	return p.current
}

// ResourceHealthMetadataClientListBySiteSlotPager provides operations for iterating over paged responses.
type ResourceHealthMetadataClientListBySiteSlotPager struct {
	client    *ResourceHealthMetadataClient
	current   ResourceHealthMetadataClientListBySiteSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ResourceHealthMetadataClientListBySiteSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ResourceHealthMetadataClientListBySiteSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ResourceHealthMetadataClientListBySiteSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceHealthMetadataCollection.NextLink == nil || len(*p.current.ResourceHealthMetadataCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySiteSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ResourceHealthMetadataClientListBySiteSlotResponse page.
func (p *ResourceHealthMetadataClientListBySiteSlotPager) PageResponse() ResourceHealthMetadataClientListBySiteSlotResponse {
	return p.current
}

// ResourceHealthMetadataClientListPager provides operations for iterating over paged responses.
type ResourceHealthMetadataClientListPager struct {
	client    *ResourceHealthMetadataClient
	current   ResourceHealthMetadataClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ResourceHealthMetadataClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ResourceHealthMetadataClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ResourceHealthMetadataClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceHealthMetadataCollection.NextLink == nil || len(*p.current.ResourceHealthMetadataCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ResourceHealthMetadataClientListResponse page.
func (p *ResourceHealthMetadataClientListPager) PageResponse() ResourceHealthMetadataClientListResponse {
	return p.current
}

// StaticSitesClientGetPrivateEndpointConnectionListPager provides operations for iterating over paged responses.
type StaticSitesClientGetPrivateEndpointConnectionListPager struct {
	client    *StaticSitesClient
	current   StaticSitesClientGetPrivateEndpointConnectionListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StaticSitesClientGetPrivateEndpointConnectionListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StaticSitesClientGetPrivateEndpointConnectionListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StaticSitesClientGetPrivateEndpointConnectionListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionCollection.NextLink == nil || len(*p.current.PrivateEndpointConnectionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getPrivateEndpointConnectionListHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StaticSitesClientGetPrivateEndpointConnectionListResponse page.
func (p *StaticSitesClientGetPrivateEndpointConnectionListPager) PageResponse() StaticSitesClientGetPrivateEndpointConnectionListResponse {
	return p.current
}

// StaticSitesClientGetStaticSiteBuildsPager provides operations for iterating over paged responses.
type StaticSitesClientGetStaticSiteBuildsPager struct {
	client    *StaticSitesClient
	current   StaticSitesClientGetStaticSiteBuildsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StaticSitesClientGetStaticSiteBuildsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StaticSitesClientGetStaticSiteBuildsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StaticSitesClientGetStaticSiteBuildsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteBuildCollection.NextLink == nil || len(*p.current.StaticSiteBuildCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getStaticSiteBuildsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StaticSitesClientGetStaticSiteBuildsResponse page.
func (p *StaticSitesClientGetStaticSiteBuildsPager) PageResponse() StaticSitesClientGetStaticSiteBuildsResponse {
	return p.current
}

// StaticSitesClientGetStaticSitesByResourceGroupPager provides operations for iterating over paged responses.
type StaticSitesClientGetStaticSitesByResourceGroupPager struct {
	client    *StaticSitesClient
	current   StaticSitesClientGetStaticSitesByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StaticSitesClientGetStaticSitesByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StaticSitesClientGetStaticSitesByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StaticSitesClientGetStaticSitesByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteCollection.NextLink == nil || len(*p.current.StaticSiteCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getStaticSitesByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StaticSitesClientGetStaticSitesByResourceGroupResponse page.
func (p *StaticSitesClientGetStaticSitesByResourceGroupPager) PageResponse() StaticSitesClientGetStaticSitesByResourceGroupResponse {
	return p.current
}

// StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteBuildPager provides operations for iterating over paged responses.
type StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteBuildPager struct {
	client    *StaticSitesClient
	current   StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteBuildResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteBuildResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteBuildPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteBuildPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteUserProvidedFunctionAppsCollection.NextLink == nil || len(*p.current.StaticSiteUserProvidedFunctionAppsCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getUserProvidedFunctionAppsForStaticSiteBuildHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteBuildResponse page.
func (p *StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteBuildPager) PageResponse() StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteBuildResponse {
	return p.current
}

// StaticSitesClientGetUserProvidedFunctionAppsForStaticSitePager provides operations for iterating over paged responses.
type StaticSitesClientGetUserProvidedFunctionAppsForStaticSitePager struct {
	client    *StaticSitesClient
	current   StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StaticSitesClientGetUserProvidedFunctionAppsForStaticSitePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StaticSitesClientGetUserProvidedFunctionAppsForStaticSitePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteUserProvidedFunctionAppsCollection.NextLink == nil || len(*p.current.StaticSiteUserProvidedFunctionAppsCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getUserProvidedFunctionAppsForStaticSiteHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteResponse page.
func (p *StaticSitesClientGetUserProvidedFunctionAppsForStaticSitePager) PageResponse() StaticSitesClientGetUserProvidedFunctionAppsForStaticSiteResponse {
	return p.current
}

// StaticSitesClientListPager provides operations for iterating over paged responses.
type StaticSitesClientListPager struct {
	client    *StaticSitesClient
	current   StaticSitesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StaticSitesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StaticSitesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StaticSitesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteCollection.NextLink == nil || len(*p.current.StaticSiteCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StaticSitesClientListResponse page.
func (p *StaticSitesClientListPager) PageResponse() StaticSitesClientListResponse {
	return p.current
}

// StaticSitesClientListStaticSiteBuildFunctionsPager provides operations for iterating over paged responses.
type StaticSitesClientListStaticSiteBuildFunctionsPager struct {
	client    *StaticSitesClient
	current   StaticSitesClientListStaticSiteBuildFunctionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StaticSitesClientListStaticSiteBuildFunctionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StaticSitesClientListStaticSiteBuildFunctionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StaticSitesClientListStaticSiteBuildFunctionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteFunctionOverviewCollection.NextLink == nil || len(*p.current.StaticSiteFunctionOverviewCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listStaticSiteBuildFunctionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StaticSitesClientListStaticSiteBuildFunctionsResponse page.
func (p *StaticSitesClientListStaticSiteBuildFunctionsPager) PageResponse() StaticSitesClientListStaticSiteBuildFunctionsResponse {
	return p.current
}

// StaticSitesClientListStaticSiteCustomDomainsPager provides operations for iterating over paged responses.
type StaticSitesClientListStaticSiteCustomDomainsPager struct {
	client    *StaticSitesClient
	current   StaticSitesClientListStaticSiteCustomDomainsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StaticSitesClientListStaticSiteCustomDomainsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StaticSitesClientListStaticSiteCustomDomainsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StaticSitesClientListStaticSiteCustomDomainsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteCustomDomainOverviewCollection.NextLink == nil || len(*p.current.StaticSiteCustomDomainOverviewCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listStaticSiteCustomDomainsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StaticSitesClientListStaticSiteCustomDomainsResponse page.
func (p *StaticSitesClientListStaticSiteCustomDomainsPager) PageResponse() StaticSitesClientListStaticSiteCustomDomainsResponse {
	return p.current
}

// StaticSitesClientListStaticSiteFunctionsPager provides operations for iterating over paged responses.
type StaticSitesClientListStaticSiteFunctionsPager struct {
	client    *StaticSitesClient
	current   StaticSitesClientListStaticSiteFunctionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StaticSitesClientListStaticSiteFunctionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StaticSitesClientListStaticSiteFunctionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StaticSitesClientListStaticSiteFunctionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteFunctionOverviewCollection.NextLink == nil || len(*p.current.StaticSiteFunctionOverviewCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listStaticSiteFunctionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StaticSitesClientListStaticSiteFunctionsResponse page.
func (p *StaticSitesClientListStaticSiteFunctionsPager) PageResponse() StaticSitesClientListStaticSiteFunctionsResponse {
	return p.current
}

// StaticSitesClientListStaticSiteUsersPager provides operations for iterating over paged responses.
type StaticSitesClientListStaticSiteUsersPager struct {
	client    *StaticSitesClient
	current   StaticSitesClientListStaticSiteUsersResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StaticSitesClientListStaticSiteUsersResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StaticSitesClientListStaticSiteUsersPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StaticSitesClientListStaticSiteUsersPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteUserCollection.NextLink == nil || len(*p.current.StaticSiteUserCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listStaticSiteUsersHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StaticSitesClientListStaticSiteUsersResponse page.
func (p *StaticSitesClientListStaticSiteUsersPager) PageResponse() StaticSitesClientListStaticSiteUsersResponse {
	return p.current
}

// TopLevelDomainsClientListAgreementsPager provides operations for iterating over paged responses.
type TopLevelDomainsClientListAgreementsPager struct {
	client    *TopLevelDomainsClient
	current   TopLevelDomainsClientListAgreementsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TopLevelDomainsClientListAgreementsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TopLevelDomainsClientListAgreementsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TopLevelDomainsClientListAgreementsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TldLegalAgreementCollection.NextLink == nil || len(*p.current.TldLegalAgreementCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAgreementsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TopLevelDomainsClientListAgreementsResponse page.
func (p *TopLevelDomainsClientListAgreementsPager) PageResponse() TopLevelDomainsClientListAgreementsResponse {
	return p.current
}

// TopLevelDomainsClientListPager provides operations for iterating over paged responses.
type TopLevelDomainsClientListPager struct {
	client    *TopLevelDomainsClient
	current   TopLevelDomainsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TopLevelDomainsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TopLevelDomainsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TopLevelDomainsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TopLevelDomainCollection.NextLink == nil || len(*p.current.TopLevelDomainCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TopLevelDomainsClientListResponse page.
func (p *TopLevelDomainsClientListPager) PageResponse() TopLevelDomainsClientListResponse {
	return p.current
}

// WebAppsClientGetAppSettingsKeyVaultReferencesPager provides operations for iterating over paged responses.
type WebAppsClientGetAppSettingsKeyVaultReferencesPager struct {
	client    *WebAppsClient
	current   WebAppsClientGetAppSettingsKeyVaultReferencesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientGetAppSettingsKeyVaultReferencesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientGetAppSettingsKeyVaultReferencesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientGetAppSettingsKeyVaultReferencesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIKVReferenceCollection.NextLink == nil || len(*p.current.APIKVReferenceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getAppSettingsKeyVaultReferencesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientGetAppSettingsKeyVaultReferencesResponse page.
func (p *WebAppsClientGetAppSettingsKeyVaultReferencesPager) PageResponse() WebAppsClientGetAppSettingsKeyVaultReferencesResponse {
	return p.current
}

// WebAppsClientGetAppSettingsKeyVaultReferencesSlotPager provides operations for iterating over paged responses.
type WebAppsClientGetAppSettingsKeyVaultReferencesSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientGetAppSettingsKeyVaultReferencesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientGetAppSettingsKeyVaultReferencesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIKVReferenceCollection.NextLink == nil || len(*p.current.APIKVReferenceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getAppSettingsKeyVaultReferencesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse page.
func (p *WebAppsClientGetAppSettingsKeyVaultReferencesSlotPager) PageResponse() WebAppsClientGetAppSettingsKeyVaultReferencesSlotResponse {
	return p.current
}

// WebAppsClientGetPrivateEndpointConnectionListPager provides operations for iterating over paged responses.
type WebAppsClientGetPrivateEndpointConnectionListPager struct {
	client    *WebAppsClient
	current   WebAppsClientGetPrivateEndpointConnectionListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientGetPrivateEndpointConnectionListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientGetPrivateEndpointConnectionListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientGetPrivateEndpointConnectionListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionCollection.NextLink == nil || len(*p.current.PrivateEndpointConnectionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getPrivateEndpointConnectionListHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientGetPrivateEndpointConnectionListResponse page.
func (p *WebAppsClientGetPrivateEndpointConnectionListPager) PageResponse() WebAppsClientGetPrivateEndpointConnectionListResponse {
	return p.current
}

// WebAppsClientGetPrivateEndpointConnectionListSlotPager provides operations for iterating over paged responses.
type WebAppsClientGetPrivateEndpointConnectionListSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientGetPrivateEndpointConnectionListSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientGetPrivateEndpointConnectionListSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientGetPrivateEndpointConnectionListSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientGetPrivateEndpointConnectionListSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionCollection.NextLink == nil || len(*p.current.PrivateEndpointConnectionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getPrivateEndpointConnectionListSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientGetPrivateEndpointConnectionListSlotResponse page.
func (p *WebAppsClientGetPrivateEndpointConnectionListSlotPager) PageResponse() WebAppsClientGetPrivateEndpointConnectionListSlotResponse {
	return p.current
}

// WebAppsClientGetSiteConnectionStringKeyVaultReferencesPager provides operations for iterating over paged responses.
type WebAppsClientGetSiteConnectionStringKeyVaultReferencesPager struct {
	client    *WebAppsClient
	current   WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientGetSiteConnectionStringKeyVaultReferencesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientGetSiteConnectionStringKeyVaultReferencesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIKVReferenceCollection.NextLink == nil || len(*p.current.APIKVReferenceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getSiteConnectionStringKeyVaultReferencesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse page.
func (p *WebAppsClientGetSiteConnectionStringKeyVaultReferencesPager) PageResponse() WebAppsClientGetSiteConnectionStringKeyVaultReferencesResponse {
	return p.current
}

// WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotPager provides operations for iterating over paged responses.
type WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIKVReferenceCollection.NextLink == nil || len(*p.current.APIKVReferenceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getSiteConnectionStringKeyVaultReferencesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse page.
func (p *WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotPager) PageResponse() WebAppsClientGetSiteConnectionStringKeyVaultReferencesSlotResponse {
	return p.current
}

// WebAppsClientListBackupsPager provides operations for iterating over paged responses.
type WebAppsClientListBackupsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListBackupsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListBackupsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListBackupsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListBackupsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackupItemCollection.NextLink == nil || len(*p.current.BackupItemCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBackupsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListBackupsResponse page.
func (p *WebAppsClientListBackupsPager) PageResponse() WebAppsClientListBackupsResponse {
	return p.current
}

// WebAppsClientListBackupsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListBackupsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListBackupsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListBackupsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListBackupsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListBackupsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackupItemCollection.NextLink == nil || len(*p.current.BackupItemCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBackupsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListBackupsSlotResponse page.
func (p *WebAppsClientListBackupsSlotPager) PageResponse() WebAppsClientListBackupsSlotResponse {
	return p.current
}

// WebAppsClientListBasicPublishingCredentialsPoliciesPager provides operations for iterating over paged responses.
type WebAppsClientListBasicPublishingCredentialsPoliciesPager struct {
	client    *WebAppsClient
	current   WebAppsClientListBasicPublishingCredentialsPoliciesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListBasicPublishingCredentialsPoliciesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListBasicPublishingCredentialsPoliciesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListBasicPublishingCredentialsPoliciesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublishingCredentialsPoliciesCollection.NextLink == nil || len(*p.current.PublishingCredentialsPoliciesCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBasicPublishingCredentialsPoliciesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListBasicPublishingCredentialsPoliciesResponse page.
func (p *WebAppsClientListBasicPublishingCredentialsPoliciesPager) PageResponse() WebAppsClientListBasicPublishingCredentialsPoliciesResponse {
	return p.current
}

// WebAppsClientListBasicPublishingCredentialsPoliciesSlotPager provides operations for iterating over paged responses.
type WebAppsClientListBasicPublishingCredentialsPoliciesSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListBasicPublishingCredentialsPoliciesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListBasicPublishingCredentialsPoliciesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublishingCredentialsPoliciesCollection.NextLink == nil || len(*p.current.PublishingCredentialsPoliciesCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBasicPublishingCredentialsPoliciesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse page.
func (p *WebAppsClientListBasicPublishingCredentialsPoliciesSlotPager) PageResponse() WebAppsClientListBasicPublishingCredentialsPoliciesSlotResponse {
	return p.current
}

// WebAppsClientListByResourceGroupPager provides operations for iterating over paged responses.
type WebAppsClientListByResourceGroupPager struct {
	client    *WebAppsClient
	current   WebAppsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppCollection.NextLink == nil || len(*p.current.WebAppCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListByResourceGroupResponse page.
func (p *WebAppsClientListByResourceGroupPager) PageResponse() WebAppsClientListByResourceGroupResponse {
	return p.current
}

// WebAppsClientListConfigurationSnapshotInfoPager provides operations for iterating over paged responses.
type WebAppsClientListConfigurationSnapshotInfoPager struct {
	client    *WebAppsClient
	current   WebAppsClientListConfigurationSnapshotInfoResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListConfigurationSnapshotInfoResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListConfigurationSnapshotInfoPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListConfigurationSnapshotInfoPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SiteConfigurationSnapshotInfoCollection.NextLink == nil || len(*p.current.SiteConfigurationSnapshotInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listConfigurationSnapshotInfoHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListConfigurationSnapshotInfoResponse page.
func (p *WebAppsClientListConfigurationSnapshotInfoPager) PageResponse() WebAppsClientListConfigurationSnapshotInfoResponse {
	return p.current
}

// WebAppsClientListConfigurationSnapshotInfoSlotPager provides operations for iterating over paged responses.
type WebAppsClientListConfigurationSnapshotInfoSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListConfigurationSnapshotInfoSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListConfigurationSnapshotInfoSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListConfigurationSnapshotInfoSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListConfigurationSnapshotInfoSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SiteConfigurationSnapshotInfoCollection.NextLink == nil || len(*p.current.SiteConfigurationSnapshotInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listConfigurationSnapshotInfoSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListConfigurationSnapshotInfoSlotResponse page.
func (p *WebAppsClientListConfigurationSnapshotInfoSlotPager) PageResponse() WebAppsClientListConfigurationSnapshotInfoSlotResponse {
	return p.current
}

// WebAppsClientListConfigurationsPager provides operations for iterating over paged responses.
type WebAppsClientListConfigurationsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListConfigurationsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListConfigurationsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListConfigurationsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListConfigurationsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SiteConfigResourceCollection.NextLink == nil || len(*p.current.SiteConfigResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listConfigurationsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListConfigurationsResponse page.
func (p *WebAppsClientListConfigurationsPager) PageResponse() WebAppsClientListConfigurationsResponse {
	return p.current
}

// WebAppsClientListConfigurationsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListConfigurationsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListConfigurationsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListConfigurationsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListConfigurationsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListConfigurationsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SiteConfigResourceCollection.NextLink == nil || len(*p.current.SiteConfigResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listConfigurationsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListConfigurationsSlotResponse page.
func (p *WebAppsClientListConfigurationsSlotPager) PageResponse() WebAppsClientListConfigurationsSlotResponse {
	return p.current
}

// WebAppsClientListContinuousWebJobsPager provides operations for iterating over paged responses.
type WebAppsClientListContinuousWebJobsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListContinuousWebJobsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListContinuousWebJobsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListContinuousWebJobsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListContinuousWebJobsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContinuousWebJobCollection.NextLink == nil || len(*p.current.ContinuousWebJobCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listContinuousWebJobsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListContinuousWebJobsResponse page.
func (p *WebAppsClientListContinuousWebJobsPager) PageResponse() WebAppsClientListContinuousWebJobsResponse {
	return p.current
}

// WebAppsClientListContinuousWebJobsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListContinuousWebJobsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListContinuousWebJobsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListContinuousWebJobsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListContinuousWebJobsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListContinuousWebJobsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContinuousWebJobCollection.NextLink == nil || len(*p.current.ContinuousWebJobCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listContinuousWebJobsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListContinuousWebJobsSlotResponse page.
func (p *WebAppsClientListContinuousWebJobsSlotPager) PageResponse() WebAppsClientListContinuousWebJobsSlotResponse {
	return p.current
}

// WebAppsClientListDeploymentsPager provides operations for iterating over paged responses.
type WebAppsClientListDeploymentsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListDeploymentsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListDeploymentsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListDeploymentsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListDeploymentsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentCollection.NextLink == nil || len(*p.current.DeploymentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listDeploymentsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListDeploymentsResponse page.
func (p *WebAppsClientListDeploymentsPager) PageResponse() WebAppsClientListDeploymentsResponse {
	return p.current
}

// WebAppsClientListDeploymentsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListDeploymentsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListDeploymentsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListDeploymentsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListDeploymentsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListDeploymentsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentCollection.NextLink == nil || len(*p.current.DeploymentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listDeploymentsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListDeploymentsSlotResponse page.
func (p *WebAppsClientListDeploymentsSlotPager) PageResponse() WebAppsClientListDeploymentsSlotResponse {
	return p.current
}

// WebAppsClientListDomainOwnershipIdentifiersPager provides operations for iterating over paged responses.
type WebAppsClientListDomainOwnershipIdentifiersPager struct {
	client    *WebAppsClient
	current   WebAppsClientListDomainOwnershipIdentifiersResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListDomainOwnershipIdentifiersResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListDomainOwnershipIdentifiersPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListDomainOwnershipIdentifiersPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IdentifierCollection.NextLink == nil || len(*p.current.IdentifierCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listDomainOwnershipIdentifiersHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListDomainOwnershipIdentifiersResponse page.
func (p *WebAppsClientListDomainOwnershipIdentifiersPager) PageResponse() WebAppsClientListDomainOwnershipIdentifiersResponse {
	return p.current
}

// WebAppsClientListDomainOwnershipIdentifiersSlotPager provides operations for iterating over paged responses.
type WebAppsClientListDomainOwnershipIdentifiersSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListDomainOwnershipIdentifiersSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListDomainOwnershipIdentifiersSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListDomainOwnershipIdentifiersSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListDomainOwnershipIdentifiersSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IdentifierCollection.NextLink == nil || len(*p.current.IdentifierCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listDomainOwnershipIdentifiersSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListDomainOwnershipIdentifiersSlotResponse page.
func (p *WebAppsClientListDomainOwnershipIdentifiersSlotPager) PageResponse() WebAppsClientListDomainOwnershipIdentifiersSlotResponse {
	return p.current
}

// WebAppsClientListFunctionsPager provides operations for iterating over paged responses.
type WebAppsClientListFunctionsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListFunctionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListFunctionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListFunctionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListFunctionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FunctionEnvelopeCollection.NextLink == nil || len(*p.current.FunctionEnvelopeCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listFunctionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListFunctionsResponse page.
func (p *WebAppsClientListFunctionsPager) PageResponse() WebAppsClientListFunctionsResponse {
	return p.current
}

// WebAppsClientListHostNameBindingsPager provides operations for iterating over paged responses.
type WebAppsClientListHostNameBindingsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListHostNameBindingsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListHostNameBindingsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListHostNameBindingsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListHostNameBindingsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.HostNameBindingCollection.NextLink == nil || len(*p.current.HostNameBindingCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHostNameBindingsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListHostNameBindingsResponse page.
func (p *WebAppsClientListHostNameBindingsPager) PageResponse() WebAppsClientListHostNameBindingsResponse {
	return p.current
}

// WebAppsClientListHostNameBindingsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListHostNameBindingsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListHostNameBindingsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListHostNameBindingsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListHostNameBindingsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListHostNameBindingsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.HostNameBindingCollection.NextLink == nil || len(*p.current.HostNameBindingCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHostNameBindingsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListHostNameBindingsSlotResponse page.
func (p *WebAppsClientListHostNameBindingsSlotPager) PageResponse() WebAppsClientListHostNameBindingsSlotResponse {
	return p.current
}

// WebAppsClientListInstanceFunctionsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListInstanceFunctionsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListInstanceFunctionsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListInstanceFunctionsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListInstanceFunctionsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListInstanceFunctionsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FunctionEnvelopeCollection.NextLink == nil || len(*p.current.FunctionEnvelopeCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInstanceFunctionsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListInstanceFunctionsSlotResponse page.
func (p *WebAppsClientListInstanceFunctionsSlotPager) PageResponse() WebAppsClientListInstanceFunctionsSlotResponse {
	return p.current
}

// WebAppsClientListInstanceIdentifiersPager provides operations for iterating over paged responses.
type WebAppsClientListInstanceIdentifiersPager struct {
	client    *WebAppsClient
	current   WebAppsClientListInstanceIdentifiersResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListInstanceIdentifiersResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListInstanceIdentifiersPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListInstanceIdentifiersPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppInstanceStatusCollection.NextLink == nil || len(*p.current.WebAppInstanceStatusCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInstanceIdentifiersHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListInstanceIdentifiersResponse page.
func (p *WebAppsClientListInstanceIdentifiersPager) PageResponse() WebAppsClientListInstanceIdentifiersResponse {
	return p.current
}

// WebAppsClientListInstanceIdentifiersSlotPager provides operations for iterating over paged responses.
type WebAppsClientListInstanceIdentifiersSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListInstanceIdentifiersSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListInstanceIdentifiersSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListInstanceIdentifiersSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListInstanceIdentifiersSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppInstanceStatusCollection.NextLink == nil || len(*p.current.WebAppInstanceStatusCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInstanceIdentifiersSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListInstanceIdentifiersSlotResponse page.
func (p *WebAppsClientListInstanceIdentifiersSlotPager) PageResponse() WebAppsClientListInstanceIdentifiersSlotResponse {
	return p.current
}

// WebAppsClientListInstanceProcessModulesPager provides operations for iterating over paged responses.
type WebAppsClientListInstanceProcessModulesPager struct {
	client    *WebAppsClient
	current   WebAppsClientListInstanceProcessModulesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListInstanceProcessModulesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListInstanceProcessModulesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListInstanceProcessModulesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessModuleInfoCollection.NextLink == nil || len(*p.current.ProcessModuleInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInstanceProcessModulesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListInstanceProcessModulesResponse page.
func (p *WebAppsClientListInstanceProcessModulesPager) PageResponse() WebAppsClientListInstanceProcessModulesResponse {
	return p.current
}

// WebAppsClientListInstanceProcessModulesSlotPager provides operations for iterating over paged responses.
type WebAppsClientListInstanceProcessModulesSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListInstanceProcessModulesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListInstanceProcessModulesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListInstanceProcessModulesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListInstanceProcessModulesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessModuleInfoCollection.NextLink == nil || len(*p.current.ProcessModuleInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInstanceProcessModulesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListInstanceProcessModulesSlotResponse page.
func (p *WebAppsClientListInstanceProcessModulesSlotPager) PageResponse() WebAppsClientListInstanceProcessModulesSlotResponse {
	return p.current
}

// WebAppsClientListInstanceProcessThreadsPager provides operations for iterating over paged responses.
type WebAppsClientListInstanceProcessThreadsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListInstanceProcessThreadsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListInstanceProcessThreadsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListInstanceProcessThreadsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListInstanceProcessThreadsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessThreadInfoCollection.NextLink == nil || len(*p.current.ProcessThreadInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInstanceProcessThreadsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListInstanceProcessThreadsResponse page.
func (p *WebAppsClientListInstanceProcessThreadsPager) PageResponse() WebAppsClientListInstanceProcessThreadsResponse {
	return p.current
}

// WebAppsClientListInstanceProcessThreadsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListInstanceProcessThreadsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListInstanceProcessThreadsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListInstanceProcessThreadsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListInstanceProcessThreadsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListInstanceProcessThreadsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessThreadInfoCollection.NextLink == nil || len(*p.current.ProcessThreadInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInstanceProcessThreadsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListInstanceProcessThreadsSlotResponse page.
func (p *WebAppsClientListInstanceProcessThreadsSlotPager) PageResponse() WebAppsClientListInstanceProcessThreadsSlotResponse {
	return p.current
}

// WebAppsClientListInstanceProcessesPager provides operations for iterating over paged responses.
type WebAppsClientListInstanceProcessesPager struct {
	client    *WebAppsClient
	current   WebAppsClientListInstanceProcessesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListInstanceProcessesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListInstanceProcessesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListInstanceProcessesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessInfoCollection.NextLink == nil || len(*p.current.ProcessInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInstanceProcessesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListInstanceProcessesResponse page.
func (p *WebAppsClientListInstanceProcessesPager) PageResponse() WebAppsClientListInstanceProcessesResponse {
	return p.current
}

// WebAppsClientListInstanceProcessesSlotPager provides operations for iterating over paged responses.
type WebAppsClientListInstanceProcessesSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListInstanceProcessesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListInstanceProcessesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListInstanceProcessesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListInstanceProcessesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessInfoCollection.NextLink == nil || len(*p.current.ProcessInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInstanceProcessesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListInstanceProcessesSlotResponse page.
func (p *WebAppsClientListInstanceProcessesSlotPager) PageResponse() WebAppsClientListInstanceProcessesSlotResponse {
	return p.current
}

// WebAppsClientListPager provides operations for iterating over paged responses.
type WebAppsClientListPager struct {
	client    *WebAppsClient
	current   WebAppsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppCollection.NextLink == nil || len(*p.current.WebAppCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListResponse page.
func (p *WebAppsClientListPager) PageResponse() WebAppsClientListResponse {
	return p.current
}

// WebAppsClientListPerfMonCountersPager provides operations for iterating over paged responses.
type WebAppsClientListPerfMonCountersPager struct {
	client    *WebAppsClient
	current   WebAppsClientListPerfMonCountersResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListPerfMonCountersResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListPerfMonCountersPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListPerfMonCountersPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PerfMonCounterCollection.NextLink == nil || len(*p.current.PerfMonCounterCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listPerfMonCountersHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListPerfMonCountersResponse page.
func (p *WebAppsClientListPerfMonCountersPager) PageResponse() WebAppsClientListPerfMonCountersResponse {
	return p.current
}

// WebAppsClientListPerfMonCountersSlotPager provides operations for iterating over paged responses.
type WebAppsClientListPerfMonCountersSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListPerfMonCountersSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListPerfMonCountersSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListPerfMonCountersSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListPerfMonCountersSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PerfMonCounterCollection.NextLink == nil || len(*p.current.PerfMonCounterCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listPerfMonCountersSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListPerfMonCountersSlotResponse page.
func (p *WebAppsClientListPerfMonCountersSlotPager) PageResponse() WebAppsClientListPerfMonCountersSlotResponse {
	return p.current
}

// WebAppsClientListProcessModulesPager provides operations for iterating over paged responses.
type WebAppsClientListProcessModulesPager struct {
	client    *WebAppsClient
	current   WebAppsClientListProcessModulesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListProcessModulesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListProcessModulesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListProcessModulesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessModuleInfoCollection.NextLink == nil || len(*p.current.ProcessModuleInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listProcessModulesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListProcessModulesResponse page.
func (p *WebAppsClientListProcessModulesPager) PageResponse() WebAppsClientListProcessModulesResponse {
	return p.current
}

// WebAppsClientListProcessModulesSlotPager provides operations for iterating over paged responses.
type WebAppsClientListProcessModulesSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListProcessModulesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListProcessModulesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListProcessModulesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListProcessModulesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessModuleInfoCollection.NextLink == nil || len(*p.current.ProcessModuleInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listProcessModulesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListProcessModulesSlotResponse page.
func (p *WebAppsClientListProcessModulesSlotPager) PageResponse() WebAppsClientListProcessModulesSlotResponse {
	return p.current
}

// WebAppsClientListProcessThreadsPager provides operations for iterating over paged responses.
type WebAppsClientListProcessThreadsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListProcessThreadsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListProcessThreadsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListProcessThreadsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListProcessThreadsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessThreadInfoCollection.NextLink == nil || len(*p.current.ProcessThreadInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listProcessThreadsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListProcessThreadsResponse page.
func (p *WebAppsClientListProcessThreadsPager) PageResponse() WebAppsClientListProcessThreadsResponse {
	return p.current
}

// WebAppsClientListProcessThreadsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListProcessThreadsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListProcessThreadsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListProcessThreadsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListProcessThreadsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListProcessThreadsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessThreadInfoCollection.NextLink == nil || len(*p.current.ProcessThreadInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listProcessThreadsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListProcessThreadsSlotResponse page.
func (p *WebAppsClientListProcessThreadsSlotPager) PageResponse() WebAppsClientListProcessThreadsSlotResponse {
	return p.current
}

// WebAppsClientListProcessesPager provides operations for iterating over paged responses.
type WebAppsClientListProcessesPager struct {
	client    *WebAppsClient
	current   WebAppsClientListProcessesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListProcessesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListProcessesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListProcessesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessInfoCollection.NextLink == nil || len(*p.current.ProcessInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listProcessesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListProcessesResponse page.
func (p *WebAppsClientListProcessesPager) PageResponse() WebAppsClientListProcessesResponse {
	return p.current
}

// WebAppsClientListProcessesSlotPager provides operations for iterating over paged responses.
type WebAppsClientListProcessesSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListProcessesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListProcessesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListProcessesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListProcessesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessInfoCollection.NextLink == nil || len(*p.current.ProcessInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listProcessesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListProcessesSlotResponse page.
func (p *WebAppsClientListProcessesSlotPager) PageResponse() WebAppsClientListProcessesSlotResponse {
	return p.current
}

// WebAppsClientListPublicCertificatesPager provides operations for iterating over paged responses.
type WebAppsClientListPublicCertificatesPager struct {
	client    *WebAppsClient
	current   WebAppsClientListPublicCertificatesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListPublicCertificatesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListPublicCertificatesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListPublicCertificatesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicCertificateCollection.NextLink == nil || len(*p.current.PublicCertificateCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listPublicCertificatesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListPublicCertificatesResponse page.
func (p *WebAppsClientListPublicCertificatesPager) PageResponse() WebAppsClientListPublicCertificatesResponse {
	return p.current
}

// WebAppsClientListPublicCertificatesSlotPager provides operations for iterating over paged responses.
type WebAppsClientListPublicCertificatesSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListPublicCertificatesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListPublicCertificatesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListPublicCertificatesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListPublicCertificatesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicCertificateCollection.NextLink == nil || len(*p.current.PublicCertificateCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listPublicCertificatesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListPublicCertificatesSlotResponse page.
func (p *WebAppsClientListPublicCertificatesSlotPager) PageResponse() WebAppsClientListPublicCertificatesSlotResponse {
	return p.current
}

// WebAppsClientListSiteBackupsPager provides operations for iterating over paged responses.
type WebAppsClientListSiteBackupsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListSiteBackupsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListSiteBackupsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListSiteBackupsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListSiteBackupsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackupItemCollection.NextLink == nil || len(*p.current.BackupItemCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteBackupsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListSiteBackupsResponse page.
func (p *WebAppsClientListSiteBackupsPager) PageResponse() WebAppsClientListSiteBackupsResponse {
	return p.current
}

// WebAppsClientListSiteBackupsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListSiteBackupsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListSiteBackupsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListSiteBackupsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListSiteBackupsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListSiteBackupsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackupItemCollection.NextLink == nil || len(*p.current.BackupItemCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteBackupsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListSiteBackupsSlotResponse page.
func (p *WebAppsClientListSiteBackupsSlotPager) PageResponse() WebAppsClientListSiteBackupsSlotResponse {
	return p.current
}

// WebAppsClientListSiteExtensionsPager provides operations for iterating over paged responses.
type WebAppsClientListSiteExtensionsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListSiteExtensionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListSiteExtensionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListSiteExtensionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListSiteExtensionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SiteExtensionInfoCollection.NextLink == nil || len(*p.current.SiteExtensionInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteExtensionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListSiteExtensionsResponse page.
func (p *WebAppsClientListSiteExtensionsPager) PageResponse() WebAppsClientListSiteExtensionsResponse {
	return p.current
}

// WebAppsClientListSiteExtensionsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListSiteExtensionsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListSiteExtensionsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListSiteExtensionsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListSiteExtensionsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListSiteExtensionsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SiteExtensionInfoCollection.NextLink == nil || len(*p.current.SiteExtensionInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteExtensionsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListSiteExtensionsSlotResponse page.
func (p *WebAppsClientListSiteExtensionsSlotPager) PageResponse() WebAppsClientListSiteExtensionsSlotResponse {
	return p.current
}

// WebAppsClientListSlotDifferencesFromProductionPager provides operations for iterating over paged responses.
type WebAppsClientListSlotDifferencesFromProductionPager struct {
	client    *WebAppsClient
	current   WebAppsClientListSlotDifferencesFromProductionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListSlotDifferencesFromProductionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListSlotDifferencesFromProductionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListSlotDifferencesFromProductionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SlotDifferenceCollection.NextLink == nil || len(*p.current.SlotDifferenceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSlotDifferencesFromProductionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListSlotDifferencesFromProductionResponse page.
func (p *WebAppsClientListSlotDifferencesFromProductionPager) PageResponse() WebAppsClientListSlotDifferencesFromProductionResponse {
	return p.current
}

// WebAppsClientListSlotDifferencesSlotPager provides operations for iterating over paged responses.
type WebAppsClientListSlotDifferencesSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListSlotDifferencesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListSlotDifferencesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListSlotDifferencesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListSlotDifferencesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SlotDifferenceCollection.NextLink == nil || len(*p.current.SlotDifferenceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSlotDifferencesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListSlotDifferencesSlotResponse page.
func (p *WebAppsClientListSlotDifferencesSlotPager) PageResponse() WebAppsClientListSlotDifferencesSlotResponse {
	return p.current
}

// WebAppsClientListSlotsPager provides operations for iterating over paged responses.
type WebAppsClientListSlotsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListSlotsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListSlotsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListSlotsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListSlotsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppCollection.NextLink == nil || len(*p.current.WebAppCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSlotsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListSlotsResponse page.
func (p *WebAppsClientListSlotsPager) PageResponse() WebAppsClientListSlotsResponse {
	return p.current
}

// WebAppsClientListSnapshotsFromDRSecondaryPager provides operations for iterating over paged responses.
type WebAppsClientListSnapshotsFromDRSecondaryPager struct {
	client    *WebAppsClient
	current   WebAppsClientListSnapshotsFromDRSecondaryResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListSnapshotsFromDRSecondaryResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListSnapshotsFromDRSecondaryPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListSnapshotsFromDRSecondaryPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotCollection.NextLink == nil || len(*p.current.SnapshotCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSnapshotsFromDRSecondaryHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListSnapshotsFromDRSecondaryResponse page.
func (p *WebAppsClientListSnapshotsFromDRSecondaryPager) PageResponse() WebAppsClientListSnapshotsFromDRSecondaryResponse {
	return p.current
}

// WebAppsClientListSnapshotsFromDRSecondarySlotPager provides operations for iterating over paged responses.
type WebAppsClientListSnapshotsFromDRSecondarySlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListSnapshotsFromDRSecondarySlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListSnapshotsFromDRSecondarySlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListSnapshotsFromDRSecondarySlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListSnapshotsFromDRSecondarySlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotCollection.NextLink == nil || len(*p.current.SnapshotCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSnapshotsFromDRSecondarySlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListSnapshotsFromDRSecondarySlotResponse page.
func (p *WebAppsClientListSnapshotsFromDRSecondarySlotPager) PageResponse() WebAppsClientListSnapshotsFromDRSecondarySlotResponse {
	return p.current
}

// WebAppsClientListSnapshotsPager provides operations for iterating over paged responses.
type WebAppsClientListSnapshotsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListSnapshotsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListSnapshotsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListSnapshotsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListSnapshotsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotCollection.NextLink == nil || len(*p.current.SnapshotCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSnapshotsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListSnapshotsResponse page.
func (p *WebAppsClientListSnapshotsPager) PageResponse() WebAppsClientListSnapshotsResponse {
	return p.current
}

// WebAppsClientListSnapshotsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListSnapshotsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListSnapshotsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListSnapshotsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListSnapshotsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListSnapshotsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotCollection.NextLink == nil || len(*p.current.SnapshotCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSnapshotsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListSnapshotsSlotResponse page.
func (p *WebAppsClientListSnapshotsSlotPager) PageResponse() WebAppsClientListSnapshotsSlotResponse {
	return p.current
}

// WebAppsClientListTriggeredWebJobHistoryPager provides operations for iterating over paged responses.
type WebAppsClientListTriggeredWebJobHistoryPager struct {
	client    *WebAppsClient
	current   WebAppsClientListTriggeredWebJobHistoryResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListTriggeredWebJobHistoryResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListTriggeredWebJobHistoryPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListTriggeredWebJobHistoryPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TriggeredJobHistoryCollection.NextLink == nil || len(*p.current.TriggeredJobHistoryCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listTriggeredWebJobHistoryHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListTriggeredWebJobHistoryResponse page.
func (p *WebAppsClientListTriggeredWebJobHistoryPager) PageResponse() WebAppsClientListTriggeredWebJobHistoryResponse {
	return p.current
}

// WebAppsClientListTriggeredWebJobHistorySlotPager provides operations for iterating over paged responses.
type WebAppsClientListTriggeredWebJobHistorySlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListTriggeredWebJobHistorySlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListTriggeredWebJobHistorySlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListTriggeredWebJobHistorySlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListTriggeredWebJobHistorySlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TriggeredJobHistoryCollection.NextLink == nil || len(*p.current.TriggeredJobHistoryCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listTriggeredWebJobHistorySlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListTriggeredWebJobHistorySlotResponse page.
func (p *WebAppsClientListTriggeredWebJobHistorySlotPager) PageResponse() WebAppsClientListTriggeredWebJobHistorySlotResponse {
	return p.current
}

// WebAppsClientListTriggeredWebJobsPager provides operations for iterating over paged responses.
type WebAppsClientListTriggeredWebJobsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListTriggeredWebJobsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListTriggeredWebJobsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListTriggeredWebJobsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListTriggeredWebJobsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TriggeredWebJobCollection.NextLink == nil || len(*p.current.TriggeredWebJobCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listTriggeredWebJobsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListTriggeredWebJobsResponse page.
func (p *WebAppsClientListTriggeredWebJobsPager) PageResponse() WebAppsClientListTriggeredWebJobsResponse {
	return p.current
}

// WebAppsClientListTriggeredWebJobsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListTriggeredWebJobsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListTriggeredWebJobsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListTriggeredWebJobsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListTriggeredWebJobsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListTriggeredWebJobsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TriggeredWebJobCollection.NextLink == nil || len(*p.current.TriggeredWebJobCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listTriggeredWebJobsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListTriggeredWebJobsSlotResponse page.
func (p *WebAppsClientListTriggeredWebJobsSlotPager) PageResponse() WebAppsClientListTriggeredWebJobsSlotResponse {
	return p.current
}

// WebAppsClientListUsagesPager provides operations for iterating over paged responses.
type WebAppsClientListUsagesPager struct {
	client    *WebAppsClient
	current   WebAppsClientListUsagesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListUsagesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListUsagesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListUsagesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CsmUsageQuotaCollection.NextLink == nil || len(*p.current.CsmUsageQuotaCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listUsagesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListUsagesResponse page.
func (p *WebAppsClientListUsagesPager) PageResponse() WebAppsClientListUsagesResponse {
	return p.current
}

// WebAppsClientListUsagesSlotPager provides operations for iterating over paged responses.
type WebAppsClientListUsagesSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListUsagesSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListUsagesSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListUsagesSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListUsagesSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CsmUsageQuotaCollection.NextLink == nil || len(*p.current.CsmUsageQuotaCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listUsagesSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListUsagesSlotResponse page.
func (p *WebAppsClientListUsagesSlotPager) PageResponse() WebAppsClientListUsagesSlotResponse {
	return p.current
}

// WebAppsClientListWebJobsPager provides operations for iterating over paged responses.
type WebAppsClientListWebJobsPager struct {
	client    *WebAppsClient
	current   WebAppsClientListWebJobsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListWebJobsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListWebJobsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListWebJobsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebJobCollection.NextLink == nil || len(*p.current.WebJobCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listWebJobsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListWebJobsResponse page.
func (p *WebAppsClientListWebJobsPager) PageResponse() WebAppsClientListWebJobsResponse {
	return p.current
}

// WebAppsClientListWebJobsSlotPager provides operations for iterating over paged responses.
type WebAppsClientListWebJobsSlotPager struct {
	client    *WebAppsClient
	current   WebAppsClientListWebJobsSlotResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebAppsClientListWebJobsSlotResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebAppsClientListWebJobsSlotPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebAppsClientListWebJobsSlotPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebJobCollection.NextLink == nil || len(*p.current.WebJobCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listWebJobsSlotHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebAppsClientListWebJobsSlotResponse page.
func (p *WebAppsClientListWebJobsSlotPager) PageResponse() WebAppsClientListWebJobsSlotResponse {
	return p.current
}

// WebSiteManagementClientListBillingMetersPager provides operations for iterating over paged responses.
type WebSiteManagementClientListBillingMetersPager struct {
	client    *WebSiteManagementClient
	current   WebSiteManagementClientListBillingMetersResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebSiteManagementClientListBillingMetersResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebSiteManagementClientListBillingMetersPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebSiteManagementClientListBillingMetersPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BillingMeterCollection.NextLink == nil || len(*p.current.BillingMeterCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBillingMetersHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebSiteManagementClientListBillingMetersResponse page.
func (p *WebSiteManagementClientListBillingMetersPager) PageResponse() WebSiteManagementClientListBillingMetersResponse {
	return p.current
}

// WebSiteManagementClientListCustomHostNameSitesPager provides operations for iterating over paged responses.
type WebSiteManagementClientListCustomHostNameSitesPager struct {
	client    *WebSiteManagementClient
	current   WebSiteManagementClientListCustomHostNameSitesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebSiteManagementClientListCustomHostNameSitesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebSiteManagementClientListCustomHostNameSitesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebSiteManagementClientListCustomHostNameSitesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomHostnameSitesCollection.NextLink == nil || len(*p.current.CustomHostnameSitesCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listCustomHostNameSitesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebSiteManagementClientListCustomHostNameSitesResponse page.
func (p *WebSiteManagementClientListCustomHostNameSitesPager) PageResponse() WebSiteManagementClientListCustomHostNameSitesResponse {
	return p.current
}

// WebSiteManagementClientListGeoRegionsPager provides operations for iterating over paged responses.
type WebSiteManagementClientListGeoRegionsPager struct {
	client    *WebSiteManagementClient
	current   WebSiteManagementClientListGeoRegionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebSiteManagementClientListGeoRegionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebSiteManagementClientListGeoRegionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebSiteManagementClientListGeoRegionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GeoRegionCollection.NextLink == nil || len(*p.current.GeoRegionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listGeoRegionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebSiteManagementClientListGeoRegionsResponse page.
func (p *WebSiteManagementClientListGeoRegionsPager) PageResponse() WebSiteManagementClientListGeoRegionsResponse {
	return p.current
}

// WebSiteManagementClientListPremierAddOnOffersPager provides operations for iterating over paged responses.
type WebSiteManagementClientListPremierAddOnOffersPager struct {
	client    *WebSiteManagementClient
	current   WebSiteManagementClientListPremierAddOnOffersResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebSiteManagementClientListPremierAddOnOffersResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebSiteManagementClientListPremierAddOnOffersPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebSiteManagementClientListPremierAddOnOffersPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PremierAddOnOfferCollection.NextLink == nil || len(*p.current.PremierAddOnOfferCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listPremierAddOnOffersHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebSiteManagementClientListPremierAddOnOffersResponse page.
func (p *WebSiteManagementClientListPremierAddOnOffersPager) PageResponse() WebSiteManagementClientListPremierAddOnOffersResponse {
	return p.current
}

// WebSiteManagementClientListSiteIdentifiersAssignedToHostNamePager provides operations for iterating over paged responses.
type WebSiteManagementClientListSiteIdentifiersAssignedToHostNamePager struct {
	client    *WebSiteManagementClient
	current   WebSiteManagementClientListSiteIdentifiersAssignedToHostNameResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebSiteManagementClientListSiteIdentifiersAssignedToHostNameResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebSiteManagementClientListSiteIdentifiersAssignedToHostNamePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebSiteManagementClientListSiteIdentifiersAssignedToHostNamePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IdentifierCollection.NextLink == nil || len(*p.current.IdentifierCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSiteIdentifiersAssignedToHostNameHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebSiteManagementClientListSiteIdentifiersAssignedToHostNameResponse page.
func (p *WebSiteManagementClientListSiteIdentifiersAssignedToHostNamePager) PageResponse() WebSiteManagementClientListSiteIdentifiersAssignedToHostNameResponse {
	return p.current
}

// WebSiteManagementClientListSourceControlsPager provides operations for iterating over paged responses.
type WebSiteManagementClientListSourceControlsPager struct {
	client    *WebSiteManagementClient
	current   WebSiteManagementClientListSourceControlsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebSiteManagementClientListSourceControlsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebSiteManagementClientListSourceControlsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebSiteManagementClientListSourceControlsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SourceControlCollection.NextLink == nil || len(*p.current.SourceControlCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSourceControlsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebSiteManagementClientListSourceControlsResponse page.
func (p *WebSiteManagementClientListSourceControlsPager) PageResponse() WebSiteManagementClientListSourceControlsResponse {
	return p.current
}
