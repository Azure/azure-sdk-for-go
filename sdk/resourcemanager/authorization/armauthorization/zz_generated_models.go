//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armauthorization

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AccessReviewActorIdentity - Details of the actor identity
type AccessReviewActorIdentity struct {
	// READ-ONLY; The identity id
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The identity display name
	PrincipalName *string `json:"principalName,omitempty" azure:"ro"`

	// READ-ONLY; The identity type : user/servicePrincipal
	PrincipalType *AccessReviewActorIdentityType `json:"principalType,omitempty" azure:"ro"`

	// READ-ONLY; The user principal name(if valid)
	UserPrincipalName *string `json:"userPrincipalName,omitempty" azure:"ro"`
}

// AccessReviewDecision - Access Review.
type AccessReviewDecision struct {
	// Access Review Decision properties.
	Properties *AccessReviewDecisionProperties `json:"properties,omitempty"`

	// READ-ONLY; The access review decision id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The access review decision name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// AccessReviewDecisionListResult - List of access review decisions.
type AccessReviewDecisionListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Access Review Decision list.
	Value []*AccessReviewDecision `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccessReviewDecisionListResult.
func (a AccessReviewDecisionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AccessReviewDecisionProperties - Approval Step.
type AccessReviewDecisionProperties struct {
	// The decision on the approval step. This value is initially set to NotReviewed. Approvers can take action of Approve/Deny
	Decision *AccessReviewResult `json:"decision,omitempty"`

	// Justification provided by approvers for their action
	Justification *string `json:"justification,omitempty"`

	// READ-ONLY; Details of the applier.
	AppliedBy *AccessReviewActorIdentity `json:"appliedBy,omitempty" azure:"ro"`

	// READ-ONLY; The date and time when the review decision was applied.
	AppliedDateTime *time.Time `json:"appliedDateTime,omitempty" azure:"ro"`

	// READ-ONLY; The outcome of applying the decision.
	ApplyResult *AccessReviewApplyResult `json:"applyResult,omitempty" azure:"ro"`

	// READ-ONLY; The feature- generated recommendation shown to the reviewer.
	Recommendation *AccessRecommendationType `json:"recommendation,omitempty" azure:"ro"`

	// READ-ONLY; Details of the approver.
	ReviewedBy *AccessReviewActorIdentity `json:"reviewedBy,omitempty" azure:"ro"`

	// READ-ONLY; Date Time when a decision was taken.
	ReviewedDateTime *time.Time `json:"reviewedDateTime,omitempty" azure:"ro"`

	// READ-ONLY; Target of this decision record. Can be UserDecisionTarget or ServicePrincipalDecisionTarget
	Target AccessReviewDecisionTargetClassification `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccessReviewDecisionProperties.
func (a AccessReviewDecisionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appliedBy", a.AppliedBy)
	populateTimeRFC3339(objectMap, "appliedDateTime", a.AppliedDateTime)
	populate(objectMap, "applyResult", a.ApplyResult)
	populate(objectMap, "decision", a.Decision)
	populate(objectMap, "justification", a.Justification)
	populate(objectMap, "recommendation", a.Recommendation)
	populate(objectMap, "reviewedBy", a.ReviewedBy)
	populateTimeRFC3339(objectMap, "reviewedDateTime", a.ReviewedDateTime)
	populate(objectMap, "target", a.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessReviewDecisionProperties.
func (a *AccessReviewDecisionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appliedBy":
			err = unpopulate(val, &a.AppliedBy)
			delete(rawMsg, key)
		case "appliedDateTime":
			err = unpopulateTimeRFC3339(val, &a.AppliedDateTime)
			delete(rawMsg, key)
		case "applyResult":
			err = unpopulate(val, &a.ApplyResult)
			delete(rawMsg, key)
		case "decision":
			err = unpopulate(val, &a.Decision)
			delete(rawMsg, key)
		case "justification":
			err = unpopulate(val, &a.Justification)
			delete(rawMsg, key)
		case "recommendation":
			err = unpopulate(val, &a.Recommendation)
			delete(rawMsg, key)
		case "reviewedBy":
			err = unpopulate(val, &a.ReviewedBy)
			delete(rawMsg, key)
		case "reviewedDateTime":
			err = unpopulateTimeRFC3339(val, &a.ReviewedDateTime)
			delete(rawMsg, key)
		case "target":
			a.Target, err = unmarshalAccessReviewDecisionTargetClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AccessReviewDecisionTargetClassification provides polymorphic access to related types.
// Call the interface's GetAccessReviewDecisionTarget() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AccessReviewDecisionTarget, *ServicePrincipalDecisionTarget, *UserDecisionTarget
type AccessReviewDecisionTargetClassification interface {
	// GetAccessReviewDecisionTarget returns the AccessReviewDecisionTarget content of the underlying type.
	GetAccessReviewDecisionTarget() *AccessReviewDecisionTarget
}

// AccessReviewDecisionTarget - Target of the decision.
type AccessReviewDecisionTarget struct {
	// REQUIRED; The type of decision target : User/ServicePrincipal
	Type *DecisionTargetType `json:"type,omitempty"`
}

// GetAccessReviewDecisionTarget implements the AccessReviewDecisionTargetClassification interface for type AccessReviewDecisionTarget.
func (a *AccessReviewDecisionTarget) GetAccessReviewDecisionTarget() *AccessReviewDecisionTarget {
	return a
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessReviewDecisionTarget.
func (a *AccessReviewDecisionTarget) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AccessReviewDecisionTarget) marshalInternal(objectMap map[string]interface{}, discValue DecisionTargetType) {
	a.Type = &discValue
	objectMap["type"] = a.Type
}

func (a *AccessReviewDecisionTarget) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AccessReviewDefaultSettings - Access Review Default Settings.
type AccessReviewDefaultSettings struct {
	// Access Review properties.
	Properties *AccessReviewScheduleSettings `json:"properties,omitempty"`

	// READ-ONLY; The access review default settings id. This is only going to be default
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The access review default settings name. This is always going to be Access Review Default Settings
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// AccessReviewDefaultSettingsGetOptions contains the optional parameters for the AccessReviewDefaultSettings.Get method.
type AccessReviewDefaultSettingsGetOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewDefaultSettingsPutOptions contains the optional parameters for the AccessReviewDefaultSettings.Put method.
type AccessReviewDefaultSettingsPutOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstance - Access Review Instance.
type AccessReviewInstance struct {
	// Access Review properties.
	Properties *AccessReviewInstanceProperties `json:"properties,omitempty"`

	// READ-ONLY; The access review instance id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The access review instance name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// AccessReviewInstanceAcceptRecommendationsOptions contains the optional parameters for the AccessReviewInstance.AcceptRecommendations method.
type AccessReviewInstanceAcceptRecommendationsOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstanceApplyDecisionsOptions contains the optional parameters for the AccessReviewInstance.ApplyDecisions method.
type AccessReviewInstanceApplyDecisionsOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstanceDecisionsListOptions contains the optional parameters for the AccessReviewInstanceDecisions.List method.
type AccessReviewInstanceDecisionsListOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstanceListResult - List of Access Review Instances.
type AccessReviewInstanceListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Access Review Instance list.
	Value []*AccessReviewInstance `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccessReviewInstanceListResult.
func (a AccessReviewInstanceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AccessReviewInstanceMyDecisionsGetByIDOptions contains the optional parameters for the AccessReviewInstanceMyDecisions.GetByID method.
type AccessReviewInstanceMyDecisionsGetByIDOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstanceMyDecisionsListOptions contains the optional parameters for the AccessReviewInstanceMyDecisions.List method.
type AccessReviewInstanceMyDecisionsListOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstanceMyDecisionsPatchOptions contains the optional parameters for the AccessReviewInstanceMyDecisions.Patch method.
type AccessReviewInstanceMyDecisionsPatchOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstanceProperties - Access Review Instance properties.
type AccessReviewInstanceProperties struct {
	// The DateTime when the review instance is scheduled to end.
	EndDateTime *time.Time `json:"endDateTime,omitempty"`

	// The DateTime when the review instance is scheduled to be start.
	StartDateTime *time.Time `json:"startDateTime,omitempty"`

	// READ-ONLY; This read-only field specifies the status of an access review instance.
	Status *AccessReviewInstanceStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccessReviewInstanceProperties.
func (a AccessReviewInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endDateTime", a.EndDateTime)
	populateTimeRFC3339(objectMap, "startDateTime", a.StartDateTime)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessReviewInstanceProperties.
func (a *AccessReviewInstanceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endDateTime":
			err = unpopulateTimeRFC3339(val, &a.EndDateTime)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateTimeRFC3339(val, &a.StartDateTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &a.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AccessReviewInstanceResetDecisionsOptions contains the optional parameters for the AccessReviewInstance.ResetDecisions method.
type AccessReviewInstanceResetDecisionsOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstanceSendRemindersOptions contains the optional parameters for the AccessReviewInstance.SendReminders method.
type AccessReviewInstanceSendRemindersOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstanceStopOptions contains the optional parameters for the AccessReviewInstance.Stop method.
type AccessReviewInstanceStopOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstancesAssignedForMyApprovalGetByIDOptions contains the optional parameters for the AccessReviewInstancesAssignedForMyApproval.GetByID
// method.
type AccessReviewInstancesAssignedForMyApprovalGetByIDOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstancesAssignedForMyApprovalListOptions contains the optional parameters for the AccessReviewInstancesAssignedForMyApproval.List method.
type AccessReviewInstancesAssignedForMyApprovalListOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstancesGetByIDOptions contains the optional parameters for the AccessReviewInstances.GetByID method.
type AccessReviewInstancesGetByIDOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewInstancesListOptions contains the optional parameters for the AccessReviewInstances.List method.
type AccessReviewInstancesListOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewRecurrencePattern - Recurrence Pattern of an Access Review Schedule Definition.
type AccessReviewRecurrencePattern struct {
	// The interval for recurrence. For a quarterly review, the interval is 3 for type : absoluteMonthly.
	Interval *int32 `json:"interval,omitempty"`

	// The recurrence type : weekly, monthly, etc.
	Type *AccessReviewRecurrencePatternType `json:"type,omitempty"`
}

// AccessReviewRecurrenceRange - Recurrence Range of an Access Review Schedule Definition.
type AccessReviewRecurrenceRange struct {
	// The DateTime when the review is scheduled to end. Required if type is endDate
	EndDate *time.Time `json:"endDate,omitempty"`

	// The number of times to repeat the access review. Required and must be positive if type is numbered.
	NumberOfOccurrences *int32 `json:"numberOfOccurrences,omitempty"`

	// The DateTime when the review is scheduled to be start. This could be a date in the future. Required on create.
	StartDate *time.Time `json:"startDate,omitempty"`

	// The recurrence range type. The possible values are: endDate, noEnd, numbered.
	Type *AccessReviewRecurrenceRangeType `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccessReviewRecurrenceRange.
func (a AccessReviewRecurrenceRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endDate", a.EndDate)
	populate(objectMap, "numberOfOccurrences", a.NumberOfOccurrences)
	populateTimeRFC3339(objectMap, "startDate", a.StartDate)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessReviewRecurrenceRange.
func (a *AccessReviewRecurrenceRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endDate":
			err = unpopulateTimeRFC3339(val, &a.EndDate)
			delete(rawMsg, key)
		case "numberOfOccurrences":
			err = unpopulate(val, &a.NumberOfOccurrences)
			delete(rawMsg, key)
		case "startDate":
			err = unpopulateTimeRFC3339(val, &a.StartDate)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AccessReviewRecurrenceSettings - Recurrence Settings of an Access Review Schedule Definition.
type AccessReviewRecurrenceSettings struct {
	// Access Review schedule definition recurrence pattern.
	Pattern *AccessReviewRecurrencePattern `json:"pattern,omitempty"`

	// Access Review schedule definition recurrence range.
	Range *AccessReviewRecurrenceRange `json:"range,omitempty"`
}

// AccessReviewReviewer - Descriptor for what needs to be reviewed
type AccessReviewReviewer struct {
	// The id of the reviewer(user/servicePrincipal)
	PrincipalID *string `json:"principalId,omitempty"`

	// READ-ONLY; The identity type : user/servicePrincipal
	PrincipalType *AccessReviewReviewerType `json:"principalType,omitempty" azure:"ro"`
}

// AccessReviewScheduleDefinition - Access Review Schedule Definition.
type AccessReviewScheduleDefinition struct {
	// Access Review properties.
	Properties *AccessReviewScheduleDefinitionProperties `json:"properties,omitempty"`

	// READ-ONLY; The access review schedule definition id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The access review schedule definition unique id.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// AccessReviewScheduleDefinitionListResult - List of Access Review Schedule Definitions.
type AccessReviewScheduleDefinitionListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Access Review Schedule Definition list.
	Value []*AccessReviewScheduleDefinition `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccessReviewScheduleDefinitionListResult.
func (a AccessReviewScheduleDefinitionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AccessReviewScheduleDefinitionProperties - Access Review.
type AccessReviewScheduleDefinitionProperties struct {
	// The description provided by the access review creator and visible to admins.
	DescriptionForAdmins *string `json:"descriptionForAdmins,omitempty"`

	// The description provided by the access review creator to be shown to reviewers.
	DescriptionForReviewers *string `json:"descriptionForReviewers,omitempty"`

	// The display name for the schedule definition.
	DisplayName *string `json:"displayName,omitempty"`

	// This is the collection of instances returned when one does an expand on it.
	Instances []*AccessReviewInstance `json:"instances,omitempty"`

	// This is the collection of reviewers.
	Reviewers []*AccessReviewReviewer `json:"reviewers,omitempty"`

	// Access Review Settings.
	Settings *AccessReviewScheduleSettings `json:"settings,omitempty"`

	// READ-ONLY; The user or other identity who created this review.
	CreatedBy *AccessReviewActorIdentity `json:"createdBy,omitempty" azure:"ro"`

	// READ-ONLY; This field specifies the type of reviewers for a review. Usually for a review, reviewers are explicitly assigned. However, in some cases,
	// the reviewers may not be assigned and instead be chosen
	// dynamically. For example managers review or self review.
	ReviewersType *AccessReviewScheduleDefinitionReviewersType `json:"reviewersType,omitempty" azure:"ro"`

	// READ-ONLY; This is used to define what to include in scope of the review. The scope definition includes the resourceId and roleDefinitionId.
	Scope *AccessReviewScope `json:"scope,omitempty" azure:"ro"`

	// READ-ONLY; This read-only field specifies the status of an accessReview.
	Status *AccessReviewScheduleDefinitionStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccessReviewScheduleDefinitionProperties.
func (a AccessReviewScheduleDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "createdBy", a.CreatedBy)
	populate(objectMap, "descriptionForAdmins", a.DescriptionForAdmins)
	populate(objectMap, "descriptionForReviewers", a.DescriptionForReviewers)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "instances", a.Instances)
	populate(objectMap, "reviewers", a.Reviewers)
	populate(objectMap, "reviewersType", a.ReviewersType)
	populate(objectMap, "scope", a.Scope)
	populate(objectMap, "settings", a.Settings)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// AccessReviewScheduleDefinitionsAssignedForMyApprovalListOptions contains the optional parameters for the AccessReviewScheduleDefinitionsAssignedForMyApproval.List
// method.
type AccessReviewScheduleDefinitionsAssignedForMyApprovalListOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewScheduleDefinitionsCreateOrUpdateByIDOptions contains the optional parameters for the AccessReviewScheduleDefinitions.CreateOrUpdateByID
// method.
type AccessReviewScheduleDefinitionsCreateOrUpdateByIDOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewScheduleDefinitionsDeleteByIDOptions contains the optional parameters for the AccessReviewScheduleDefinitions.DeleteByID method.
type AccessReviewScheduleDefinitionsDeleteByIDOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewScheduleDefinitionsGetByIDOptions contains the optional parameters for the AccessReviewScheduleDefinitions.GetByID method.
type AccessReviewScheduleDefinitionsGetByIDOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewScheduleDefinitionsListOptions contains the optional parameters for the AccessReviewScheduleDefinitions.List method.
type AccessReviewScheduleDefinitionsListOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewScheduleDefinitionsStopOptions contains the optional parameters for the AccessReviewScheduleDefinitions.Stop method.
type AccessReviewScheduleDefinitionsStopOptions struct {
	// placeholder for future optional parameters
}

// AccessReviewScheduleSettings - Settings of an Access Review.
type AccessReviewScheduleSettings struct {
	// Flag to indicate whether auto-apply capability, to automatically change the target object access resource, is enabled. If not enabled, a user must, after
	// the review completes, apply the access review.
	AutoApplyDecisionsEnabled *bool `json:"autoApplyDecisionsEnabled,omitempty"`

	// This specifies the behavior for the autoReview feature when an access review completes.
	DefaultDecision *DefaultDecisionType `json:"defaultDecision,omitempty"`

	// Flag to indicate whether reviewers are required to provide a justification when reviewing access.
	DefaultDecisionEnabled *bool `json:"defaultDecisionEnabled,omitempty"`

	// The duration in days for an instance.
	InstanceDurationInDays *int32 `json:"instanceDurationInDays,omitempty"`

	// Flag to indicate whether the reviewer is required to pass justification when recording a decision.
	JustificationRequiredOnApproval *bool `json:"justificationRequiredOnApproval,omitempty"`

	// Flag to indicate whether sending mails to reviewers and the review creator is enabled.
	MailNotificationsEnabled *bool `json:"mailNotificationsEnabled,omitempty"`

	// Flag to indicate whether showing recommendations to reviewers is enabled.
	RecommendationsEnabled *bool `json:"recommendationsEnabled,omitempty"`

	// Access Review Settings.
	Recurrence *AccessReviewRecurrenceSettings `json:"recurrence,omitempty"`

	// Flag to indicate whether sending reminder emails to reviewers are enabled.
	ReminderNotificationsEnabled *bool `json:"reminderNotificationsEnabled,omitempty"`
}

// AccessReviewScope - Descriptor for what needs to be reviewed
type AccessReviewScope struct {
	// READ-ONLY; The identity type user/servicePrincipal to review
	PrincipalType *AccessReviewScopePrincipalType `json:"principalType,omitempty" azure:"ro"`

	// READ-ONLY; ResourceId in which this review is getting created
	ResourceID *string `json:"resourceId,omitempty" azure:"ro"`

	// READ-ONLY; This is used to indicate the role being reviewed
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty" azure:"ro"`
}

// ApprovalSettings - The approval settings.
type ApprovalSettings struct {
	// The type of rule
	ApprovalMode *ApprovalMode `json:"approvalMode,omitempty"`

	// The approval stages of the request.
	ApprovalStages []*ApprovalStage `json:"approvalStages,omitempty"`

	// Determine whether approval is required or not.
	IsApprovalRequired *bool `json:"isApprovalRequired,omitempty"`

	// Determine whether approval is required for assignment extension.
	IsApprovalRequiredForExtension *bool `json:"isApprovalRequiredForExtension,omitempty"`

	// Determine whether requestor justification required.
	IsRequestorJustificationRequired *bool `json:"isRequestorJustificationRequired,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApprovalSettings.
func (a ApprovalSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "approvalMode", a.ApprovalMode)
	populate(objectMap, "approvalStages", a.ApprovalStages)
	populate(objectMap, "isApprovalRequired", a.IsApprovalRequired)
	populate(objectMap, "isApprovalRequiredForExtension", a.IsApprovalRequiredForExtension)
	populate(objectMap, "isRequestorJustificationRequired", a.IsRequestorJustificationRequired)
	return json.Marshal(objectMap)
}

// ApprovalStage - The approval stage.
type ApprovalStage struct {
	// The time in days when approval request would be timed out.
	ApprovalStageTimeOutInDays *int32 `json:"approvalStageTimeOutInDays,omitempty"`

	// The escalation approver of the request.
	EscalationApprovers []*UserSet `json:"escalationApprovers,omitempty"`

	// The time in minutes when the approval request would be escalated if the primary approver does not approves.
	EscalationTimeInMinutes *int32 `json:"escalationTimeInMinutes,omitempty"`

	// Determine whether approver need to provide justification for his decision.
	IsApproverJustificationRequired *bool `json:"isApproverJustificationRequired,omitempty"`

	// The value determine whether escalation feature is enabled.
	IsEscalationEnabled *bool `json:"isEscalationEnabled,omitempty"`

	// The primary approver of the request.
	PrimaryApprovers []*UserSet `json:"primaryApprovers,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApprovalStage.
func (a ApprovalStage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "approvalStageTimeOutInDays", a.ApprovalStageTimeOutInDays)
	populate(objectMap, "escalationApprovers", a.EscalationApprovers)
	populate(objectMap, "escalationTimeInMinutes", a.EscalationTimeInMinutes)
	populate(objectMap, "isApproverJustificationRequired", a.IsApproverJustificationRequired)
	populate(objectMap, "isEscalationEnabled", a.IsEscalationEnabled)
	populate(objectMap, "primaryApprovers", a.PrimaryApprovers)
	return json.Marshal(objectMap)
}

// CloudError - An error response from the service.
// Implements the error and azcore.HTTPResponse interfaces.
type CloudError struct {
	raw string
	// An error response from the service.
	InnerError *CloudErrorBody `json:"error,omitempty"`
}

// Error implements the error interface for type CloudError.
// The contents of the error text are not contractual and subject to change.
func (e CloudError) Error() string {
	return e.raw
}

// CloudErrorBody - An error response from the service.
type CloudErrorBody struct {
	// An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`
}

// DenyAssignment - Deny Assignment
type DenyAssignment struct {
	// Deny assignment properties.
	Properties *DenyAssignmentProperties `json:"properties,omitempty"`

	// READ-ONLY; The deny assignment ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The deny assignment name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The deny assignment type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// DenyAssignmentFilter - Deny Assignments filter
type DenyAssignmentFilter struct {
	// Return deny assignment with specified name.
	DenyAssignmentName *string `json:"denyAssignmentName,omitempty"`

	// Return all deny assignments where the specified principal is listed either in the principals list or exclude principals list of deny assignments.
	GdprExportPrincipalID *string `json:"gdprExportPrincipalId,omitempty"`

	// Return all deny assignments where the specified principal is listed in the principals list of deny assignments.
	PrincipalID *string `json:"principalId,omitempty"`
}

// DenyAssignmentListResult - Deny assignment list operation result.
type DenyAssignmentListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Deny assignment list.
	Value []*DenyAssignment `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DenyAssignmentListResult.
func (d DenyAssignmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DenyAssignmentPermission - Deny assignment permissions.
type DenyAssignmentPermission struct {
	// Actions to which the deny assignment does not grant access.
	Actions []*string `json:"actions,omitempty"`

	// Data actions to which the deny assignment does not grant access.
	DataActions []*string `json:"dataActions,omitempty"`

	// Actions to exclude from that the deny assignment does not grant access.
	NotActions []*string `json:"notActions,omitempty"`

	// Data actions to exclude from that the deny assignment does not grant access.
	NotDataActions []*string `json:"notDataActions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DenyAssignmentPermission.
func (d DenyAssignmentPermission) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", d.Actions)
	populate(objectMap, "dataActions", d.DataActions)
	populate(objectMap, "notActions", d.NotActions)
	populate(objectMap, "notDataActions", d.NotDataActions)
	return json.Marshal(objectMap)
}

// DenyAssignmentProperties - Deny assignment properties.
type DenyAssignmentProperties struct {
	// The display name of the deny assignment.
	DenyAssignmentName *string `json:"denyAssignmentName,omitempty"`

	// The description of the deny assignment.
	Description *string `json:"description,omitempty"`

	// Determines if the deny assignment applies to child scopes. Default value is false.
	DoNotApplyToChildScopes *bool `json:"doNotApplyToChildScopes,omitempty"`

	// Array of principals to which the deny assignment does not apply.
	ExcludePrincipals []*Principal `json:"excludePrincipals,omitempty"`

	// Specifies whether this deny assignment was created by Azure and cannot be edited or deleted.
	IsSystemProtected *bool `json:"isSystemProtected,omitempty"`

	// An array of permissions that are denied by the deny assignment.
	Permissions []*DenyAssignmentPermission `json:"permissions,omitempty"`

	// Array of principals to which the deny assignment applies.
	Principals []*Principal `json:"principals,omitempty"`

	// The deny assignment scope.
	Scope *string `json:"scope,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DenyAssignmentProperties.
func (d DenyAssignmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "denyAssignmentName", d.DenyAssignmentName)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "doNotApplyToChildScopes", d.DoNotApplyToChildScopes)
	populate(objectMap, "excludePrincipals", d.ExcludePrincipals)
	populate(objectMap, "isSystemProtected", d.IsSystemProtected)
	populate(objectMap, "permissions", d.Permissions)
	populate(objectMap, "principals", d.Principals)
	populate(objectMap, "scope", d.Scope)
	return json.Marshal(objectMap)
}

// DenyAssignmentsGetByIDOptions contains the optional parameters for the DenyAssignments.GetByID method.
type DenyAssignmentsGetByIDOptions struct {
	// placeholder for future optional parameters
}

// DenyAssignmentsGetOptions contains the optional parameters for the DenyAssignments.Get method.
type DenyAssignmentsGetOptions struct {
	// placeholder for future optional parameters
}

// DenyAssignmentsListForResourceGroupOptions contains the optional parameters for the DenyAssignments.ListForResourceGroup method.
type DenyAssignmentsListForResourceGroupOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all deny assignments at or above the scope. Use $filter=denyAssignmentName eq '{name}'
	// to search deny assignments by name at specified scope. Use $filter=principalId eq '{id}' to return all deny assignments at, above and below the scope
	// for the specified principal. Use $filter=gdprExportPrincipalId eq '{id}' to return all deny assignments at, above and below the scope for the specified
	// principal. This filter is different from the principalId filter as it returns not only those deny assignments that contain the specified principal is
	// the Principals list but also those deny assignments that contain the specified principal is the ExcludePrincipals list. Additionally, when gdprExportPrincipalId
	// filter is used, only the deny assignment name and description properties are returned.
	Filter *string
}

// DenyAssignmentsListForResourceOptions contains the optional parameters for the DenyAssignments.ListForResource method.
type DenyAssignmentsListForResourceOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all deny assignments at or above the scope. Use $filter=denyAssignmentName eq '{name}'
	// to search deny assignments by name at specified scope. Use $filter=principalId eq '{id}' to return all deny assignments at, above and below the scope
	// for the specified principal. Use $filter=gdprExportPrincipalId eq '{id}' to return all deny assignments at, above and below the scope for the specified
	// principal. This filter is different from the principalId filter as it returns not only those deny assignments that contain the specified principal is
	// the Principals list but also those deny assignments that contain the specified principal is the ExcludePrincipals list. Additionally, when gdprExportPrincipalId
	// filter is used, only the deny assignment name and description properties are returned.
	Filter *string
}

// DenyAssignmentsListForScopeOptions contains the optional parameters for the DenyAssignments.ListForScope method.
type DenyAssignmentsListForScopeOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all deny assignments at or above the scope. Use $filter=denyAssignmentName eq '{name}'
	// to search deny assignments by name at specified scope. Use $filter=principalId eq '{id}' to return all deny assignments at, above and below the scope
	// for the specified principal. Use $filter=gdprExportPrincipalId eq '{id}' to return all deny assignments at, above and below the scope for the specified
	// principal. This filter is different from the principalId filter as it returns not only those deny assignments that contain the specified principal is
	// the Principals list but also those deny assignments that contain the specified principal is the ExcludePrincipals list. Additionally, when gdprExportPrincipalId
	// filter is used, only the deny assignment name and description properties are returned.
	Filter *string
}

// DenyAssignmentsListOptions contains the optional parameters for the DenyAssignments.List method.
type DenyAssignmentsListOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all deny assignments at or above the scope. Use $filter=denyAssignmentName eq '{name}'
	// to search deny assignments by name at specified scope. Use $filter=principalId eq '{id}' to return all deny assignments at, above and below the scope
	// for the specified principal. Use $filter=gdprExportPrincipalId eq '{id}' to return all deny assignments at, above and below the scope for the specified
	// principal. This filter is different from the principalId filter as it returns not only those deny assignments that contain the specified principal is
	// the Principals list but also those deny assignments that contain the specified principal is the ExcludePrincipals list. Additionally, when gdprExportPrincipalId
	// filter is used, only the deny assignment name and description properties are returned.
	Filter *string
}

// EligibleChildResource - Eligible child resource
type EligibleChildResource struct {
	// READ-ONLY; The resource scope Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// EligibleChildResourcesGetOptions contains the optional parameters for the EligibleChildResources.Get method.
type EligibleChildResourcesGetOptions struct {
	// The filter to apply on the operation. Use $filter=resourceType+eq+'Subscription' to filter on only resource of type = 'Subscription'. Use $filter=resourceType+eq+'subscription'+or+resourceType+eq+'resourcegroup'
	// to filter on resource of type = 'Subscription' or 'ResourceGroup'
	Filter *string
}

// EligibleChildResourcesListResult - Eligible child resources list operation result.
type EligibleChildResourcesListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Eligible child resource list.
	Value []*EligibleChildResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EligibleChildResourcesListResult.
func (e EligibleChildResourcesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorDefinition - Error description and code explaining why an operation failed.
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorDefinition struct {
	raw string
	// Error of the list gateway status.
	InnerError *ErrorDefinitionProperties `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorDefinition.
// The contents of the error text are not contractual and subject to change.
func (e ErrorDefinition) Error() string {
	return e.raw
}

// ErrorDefinitionProperties - Error description and code explaining why an operation failed.
type ErrorDefinitionProperties struct {
	// Error code of list gateway.
	Code *string `json:"code,omitempty"`

	// READ-ONLY; Description of the error.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// ErrorDetail - The error detail.
type ErrorDetail struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorDetail `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ErrorResponse - Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData
// error response format.).
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// The error object.
	InnerError *ErrorDetail `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

type ExpandedProperties struct {
	// Details of the principal
	Principal *ExpandedPropertiesPrincipal `json:"principal,omitempty"`

	// Details of role definition
	RoleDefinition *ExpandedPropertiesRoleDefinition `json:"roleDefinition,omitempty"`

	// Details of the resource scope
	Scope *ExpandedPropertiesScope `json:"scope,omitempty"`
}

// ExpandedPropertiesPrincipal - Details of the principal
type ExpandedPropertiesPrincipal struct {
	// Display name of the principal
	DisplayName *string `json:"displayName,omitempty"`

	// Email id of the principal
	Email *string `json:"email,omitempty"`

	// Id of the principal
	ID *string `json:"id,omitempty"`

	// Type of the principal
	Type *string `json:"type,omitempty"`
}

// ExpandedPropertiesRoleDefinition - Details of role definition
type ExpandedPropertiesRoleDefinition struct {
	// Display name of the role definition
	DisplayName *string `json:"displayName,omitempty"`

	// Id of the role definition
	ID *string `json:"id,omitempty"`

	// Type of the role definition
	Type *string `json:"type,omitempty"`
}

// ExpandedPropertiesScope - Details of the resource scope
type ExpandedPropertiesScope struct {
	// Display name of the resource
	DisplayName *string `json:"displayName,omitempty"`

	// Scope id of the resource
	ID *string `json:"id,omitempty"`

	// Type of the resource
	Type *string `json:"type,omitempty"`
}

// Operation - The definition of a Microsoft.Authorization operation.
type Operation struct {
	// Display of the operation
	Display *OperationDisplay `json:"display,omitempty"`

	// Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty"`

	// Name of the operation
	Name *string `json:"name,omitempty"`

	// Origin of the operation
	Origin *string `json:"origin,omitempty"`
}

// OperationDisplay - The display information for a Microsoft.Authorization operation.
type OperationDisplay struct {
	// READ-ONLY; The description for the operation.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The operation that users can perform.
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY; The resource provider name: Microsoft.Authorization.
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY; The resource on which the operation is performed.
	Resource *string `json:"resource,omitempty" azure:"ro"`
}

// OperationListResult - The result of a request to list Microsoft.Authorization operations.
type OperationListResult struct {
	// The URI that can be used to request the next set of paged results.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection value.
	Value []*Operation `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// Permission - Role definition permissions.
type Permission struct {
	// Allowed actions.
	Actions []*string `json:"actions,omitempty"`

	// Allowed Data actions.
	DataActions []*string `json:"dataActions,omitempty"`

	// Denied actions.
	NotActions []*string `json:"notActions,omitempty"`

	// Denied Data actions.
	NotDataActions []*string `json:"notDataActions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Permission.
func (p Permission) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", p.Actions)
	populate(objectMap, "dataActions", p.DataActions)
	populate(objectMap, "notActions", p.NotActions)
	populate(objectMap, "notDataActions", p.NotDataActions)
	return json.Marshal(objectMap)
}

// PermissionGetResult - Permissions information.
type PermissionGetResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// An array of permissions.
	Value []*Permission `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PermissionGetResult.
func (p PermissionGetResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PermissionsListForResourceGroupOptions contains the optional parameters for the Permissions.ListForResourceGroup method.
type PermissionsListForResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// PermissionsListForResourceOptions contains the optional parameters for the Permissions.ListForResource method.
type PermissionsListForResourceOptions struct {
	// placeholder for future optional parameters
}

type PolicyAssignmentProperties struct {
	// Details of the policy
	Policy *PolicyAssignmentPropertiesPolicy `json:"policy,omitempty"`

	// Details of role definition
	RoleDefinition *PolicyAssignmentPropertiesRoleDefinition `json:"roleDefinition,omitempty"`

	// Details of the resource scope
	Scope *PolicyAssignmentPropertiesScope `json:"scope,omitempty"`
}

// PolicyAssignmentPropertiesPolicy - Details of the policy
type PolicyAssignmentPropertiesPolicy struct {
	// Id of the policy
	ID *string `json:"id,omitempty"`

	// The last modified date time.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`

	// READ-ONLY; The name of the entity last modified it
	LastModifiedBy *Principal `json:"lastModifiedBy,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicyAssignmentPropertiesPolicy.
func (p PolicyAssignmentPropertiesPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", p.ID)
	populate(objectMap, "lastModifiedBy", p.LastModifiedBy)
	populateTimeRFC3339(objectMap, "lastModifiedDateTime", p.LastModifiedDateTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolicyAssignmentPropertiesPolicy.
func (p *PolicyAssignmentPropertiesPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &p.ID)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &p.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedDateTime":
			err = unpopulateTimeRFC3339(val, &p.LastModifiedDateTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PolicyAssignmentPropertiesRoleDefinition - Details of role definition
type PolicyAssignmentPropertiesRoleDefinition struct {
	// Display name of the role definition
	DisplayName *string `json:"displayName,omitempty"`

	// Id of the role definition
	ID *string `json:"id,omitempty"`

	// Type of the role definition
	Type *string `json:"type,omitempty"`
}

// PolicyAssignmentPropertiesScope - Details of the resource scope
type PolicyAssignmentPropertiesScope struct {
	// Display name of the resource
	DisplayName *string `json:"displayName,omitempty"`

	// Scope id of the resource
	ID *string `json:"id,omitempty"`

	// Type of the resource
	Type *string `json:"type,omitempty"`
}

type PolicyProperties struct {
	// READ-ONLY; Details of the resource scope
	Scope *PolicyPropertiesScope `json:"scope,omitempty" azure:"ro"`
}

// PolicyPropertiesScope - Details of the resource scope
type PolicyPropertiesScope struct {
	// Display name of the resource
	DisplayName *string `json:"displayName,omitempty"`

	// Scope id of the resource
	ID *string `json:"id,omitempty"`

	// Type of the resource
	Type *string `json:"type,omitempty"`
}

// Principal - The name of the entity last modified it
type Principal struct {
	// The name of the principal made changes
	DisplayName *string `json:"displayName,omitempty"`

	// Email of principal
	Email *string `json:"email,omitempty"`

	// The id of the principal made changes
	ID *string `json:"id,omitempty"`

	// Type of principal such as user , group etc
	Type *string `json:"type,omitempty"`
}

// ProviderOperation - Operation
type ProviderOperation struct {
	// The operation description.
	Description *string `json:"description,omitempty"`

	// The operation display name.
	DisplayName *string `json:"displayName,omitempty"`

	// The dataAction flag to specify the operation type.
	IsDataAction *bool `json:"isDataAction,omitempty"`

	// The operation name.
	Name *string `json:"name,omitempty"`

	// The operation origin.
	Origin *string `json:"origin,omitempty"`

	// The operation properties.
	Properties map[string]interface{} `json:"properties,omitempty"`
}

// ProviderOperationsMetadata - Provider Operations metadata
type ProviderOperationsMetadata struct {
	// The provider display name.
	DisplayName *string `json:"displayName,omitempty"`

	// The provider id.
	ID *string `json:"id,omitempty"`

	// The provider name.
	Name *string `json:"name,omitempty"`

	// The provider operations.
	Operations []*ProviderOperation `json:"operations,omitempty"`

	// The provider resource types
	ResourceTypes []*ResourceType `json:"resourceTypes,omitempty"`

	// The provider type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ProviderOperationsMetadata.
func (p ProviderOperationsMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "operations", p.Operations)
	populate(objectMap, "resourceTypes", p.ResourceTypes)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// ProviderOperationsMetadataGetOptions contains the optional parameters for the ProviderOperationsMetadata.Get method.
type ProviderOperationsMetadataGetOptions struct {
	// Specifies whether to expand the values.
	Expand *string
}

// ProviderOperationsMetadataListOptions contains the optional parameters for the ProviderOperationsMetadata.List method.
type ProviderOperationsMetadataListOptions struct {
	// Specifies whether to expand the values.
	Expand *string
}

// ProviderOperationsMetadataListResult - Provider operations metadata list
type ProviderOperationsMetadataListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of providers.
	Value []*ProviderOperationsMetadata `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ProviderOperationsMetadataListResult.
func (p ProviderOperationsMetadataListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// ResourceType - Resource Type
type ResourceType struct {
	// The resource type display name.
	DisplayName *string `json:"displayName,omitempty"`

	// The resource type name.
	Name *string `json:"name,omitempty"`

	// The resource type operations.
	Operations []*ProviderOperation `json:"operations,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceType.
func (r ResourceType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayName", r.DisplayName)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "operations", r.Operations)
	return json.Marshal(objectMap)
}

// RoleAssignment - Role Assignments
type RoleAssignment struct {
	// Role assignment properties.
	Properties *RoleAssignmentProperties `json:"properties,omitempty"`

	// READ-ONLY; The role assignment ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RoleAssignmentCreateParameters - Role assignment create parameters.
type RoleAssignmentCreateParameters struct {
	// REQUIRED; Role assignment properties.
	Properties *RoleAssignmentProperties `json:"properties,omitempty"`
}

// RoleAssignmentFilter - Role Assignments filter
type RoleAssignmentFilter struct {
	// Returns role assignment of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`
}

// RoleAssignmentListResult - Role assignment list operation result.
type RoleAssignmentListResult struct {
	// Role assignment list.
	Value []*RoleAssignment `json:"value,omitempty"`

	// READ-ONLY; The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleAssignmentListResult.
func (r RoleAssignmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoleAssignmentMetricsGetMetricsForSubscriptionOptions contains the optional parameters for the RoleAssignmentMetrics.GetMetricsForSubscription method.
type RoleAssignmentMetricsGetMetricsForSubscriptionOptions struct {
	// placeholder for future optional parameters
}

// RoleAssignmentMetricsResult - Role Assignment Metrics
type RoleAssignmentMetricsResult struct {
	// READ-ONLY; The number of current role assignments.
	RoleAssignmentsCurrentCount *int64 `json:"roleAssignmentsCurrentCount,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment limit.
	RoleAssignmentsLimit *int64 `json:"roleAssignmentsLimit,omitempty" azure:"ro"`

	// READ-ONLY; The number of remaining role assignments available.
	RoleAssignmentsRemainingCount *int64 `json:"roleAssignmentsRemainingCount,omitempty" azure:"ro"`

	// READ-ONLY; The subscription ID.
	SubscriptionID *string `json:"subscriptionId,omitempty" azure:"ro"`
}

// RoleAssignmentProperties - Role assignment properties.
type RoleAssignmentProperties struct {
	// REQUIRED; The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`

	// REQUIRED; The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
	// StringEqualsIgnoreCase
	// 'foostoragecontainer'
	Condition *string `json:"condition,omitempty"`

	// Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`

	// Id of the delegated managed identity resource
	DelegatedManagedIdentityResourceID *string `json:"delegatedManagedIdentityResourceId,omitempty"`

	// Description of role assignment
	Description *string `json:"description,omitempty"`

	// The principal type of the assigned principal ID.
	PrincipalType *PrincipalType `json:"principalType,omitempty"`

	// READ-ONLY; Id of the user who created the assignment
	CreatedBy *string `json:"createdBy,omitempty" azure:"ro"`

	// READ-ONLY; Time it was created
	CreatedOn *time.Time `json:"createdOn,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment scope.
	Scope *string `json:"scope,omitempty" azure:"ro"`

	// READ-ONLY; Id of the user who updated the assignment
	UpdatedBy *string `json:"updatedBy,omitempty" azure:"ro"`

	// READ-ONLY; Time it was updated
	UpdatedOn *time.Time `json:"updatedOn,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleAssignmentProperties.
func (r RoleAssignmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "condition", r.Condition)
	populate(objectMap, "conditionVersion", r.ConditionVersion)
	populate(objectMap, "createdBy", r.CreatedBy)
	populateTimeRFC3339(objectMap, "createdOn", r.CreatedOn)
	populate(objectMap, "delegatedManagedIdentityResourceId", r.DelegatedManagedIdentityResourceID)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "principalId", r.PrincipalID)
	populate(objectMap, "principalType", r.PrincipalType)
	populate(objectMap, "roleDefinitionId", r.RoleDefinitionID)
	populate(objectMap, "scope", r.Scope)
	populate(objectMap, "updatedBy", r.UpdatedBy)
	populateTimeRFC3339(objectMap, "updatedOn", r.UpdatedOn)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleAssignmentProperties.
func (r *RoleAssignmentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "condition":
			err = unpopulate(val, &r.Condition)
			delete(rawMsg, key)
		case "conditionVersion":
			err = unpopulate(val, &r.ConditionVersion)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &r.CreatedBy)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, &r.CreatedOn)
			delete(rawMsg, key)
		case "delegatedManagedIdentityResourceId":
			err = unpopulate(val, &r.DelegatedManagedIdentityResourceID)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &r.Description)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, &r.PrincipalID)
			delete(rawMsg, key)
		case "principalType":
			err = unpopulate(val, &r.PrincipalType)
			delete(rawMsg, key)
		case "roleDefinitionId":
			err = unpopulate(val, &r.RoleDefinitionID)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &r.Scope)
			delete(rawMsg, key)
		case "updatedBy":
			err = unpopulate(val, &r.UpdatedBy)
			delete(rawMsg, key)
		case "updatedOn":
			err = unpopulateTimeRFC3339(val, &r.UpdatedOn)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleAssignmentSchedule - Role Assignment schedule
type RoleAssignmentSchedule struct {
	// Role assignment schedule properties.
	Properties *RoleAssignmentScheduleProperties `json:"properties,omitempty"`

	// READ-ONLY; The role assignment schedule Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment schedule name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment schedule type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RoleAssignmentScheduleFilter - Role assignment schedule filter
type RoleAssignmentScheduleFilter struct {
	// Returns role assignment schedule of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`

	// Returns role assignment schedule of the specific role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// Returns role assignment schedule instances of the specific status.
	Status *string `json:"status,omitempty"`
}

// RoleAssignmentScheduleInstance - Information about current or upcoming role assignment schedule instance
type RoleAssignmentScheduleInstance struct {
	// Role assignment schedule instance properties.
	Properties *RoleAssignmentScheduleInstanceProperties `json:"properties,omitempty"`

	// READ-ONLY; The role assignment schedule instance ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment schedule instance name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment schedule instance type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RoleAssignmentScheduleInstanceFilter - Role assignment schedule instance filter
type RoleAssignmentScheduleInstanceFilter struct {
	// Returns role assignment schedule instances of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`

	// Returns role assignment schedule instances belonging to a specific role assignment schedule.
	RoleAssignmentScheduleID *string `json:"roleAssignmentScheduleId,omitempty"`

	// Returns role assignment schedule instances of the specific role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// Returns role assignment schedule instances of the specific status.
	Status *string `json:"status,omitempty"`
}

// RoleAssignmentScheduleInstanceListResult - Role assignment schedule instance list operation result.
type RoleAssignmentScheduleInstanceListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Role assignment schedule instance list.
	Value []*RoleAssignmentScheduleInstance `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleAssignmentScheduleInstanceListResult.
func (r RoleAssignmentScheduleInstanceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoleAssignmentScheduleInstanceProperties - Role assignment schedule properties with scope.
type RoleAssignmentScheduleInstanceProperties struct {
	// Assignment type of the role assignment schedule
	AssignmentType *AssignmentType `json:"assignmentType,omitempty"`

	// The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
	// StringEqualsIgnoreCase
	// 'foostoragecontainer'
	Condition *string `json:"condition,omitempty"`

	// Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`

	// DateTime when role assignment schedule was created
	CreatedOn *time.Time `json:"createdOn,omitempty"`

	// The endDateTime of the role assignment schedule instance
	EndDateTime *time.Time `json:"endDateTime,omitempty"`

	// Additional properties of principal, scope and role definition
	ExpandedProperties *ExpandedProperties `json:"expandedProperties,omitempty"`

	// roleEligibilityScheduleId used to activate
	LinkedRoleEligibilityScheduleID *string `json:"linkedRoleEligibilityScheduleId,omitempty"`

	// roleEligibilityScheduleInstanceId linked to this roleAssignmentScheduleInstance
	LinkedRoleEligibilityScheduleInstanceID *string `json:"linkedRoleEligibilityScheduleInstanceId,omitempty"`

	// Membership type of the role assignment schedule
	MemberType *MemberType `json:"memberType,omitempty"`

	// Role Assignment Id in external system
	OriginRoleAssignmentID *string `json:"originRoleAssignmentId,omitempty"`

	// The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`

	// The principal type of the assigned principal ID.
	PrincipalType *PrincipalType `json:"principalType,omitempty"`

	// Id of the master role assignment schedule
	RoleAssignmentScheduleID *string `json:"roleAssignmentScheduleId,omitempty"`

	// The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// The role assignment schedule scope.
	Scope *string `json:"scope,omitempty"`

	// The startDateTime of the role assignment schedule instance
	StartDateTime *time.Time `json:"startDateTime,omitempty"`

	// The status of the role assignment schedule instance.
	Status *Status `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleAssignmentScheduleInstanceProperties.
func (r RoleAssignmentScheduleInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assignmentType", r.AssignmentType)
	populate(objectMap, "condition", r.Condition)
	populate(objectMap, "conditionVersion", r.ConditionVersion)
	populateTimeRFC3339(objectMap, "createdOn", r.CreatedOn)
	populateTimeRFC3339(objectMap, "endDateTime", r.EndDateTime)
	populate(objectMap, "expandedProperties", r.ExpandedProperties)
	populate(objectMap, "linkedRoleEligibilityScheduleId", r.LinkedRoleEligibilityScheduleID)
	populate(objectMap, "linkedRoleEligibilityScheduleInstanceId", r.LinkedRoleEligibilityScheduleInstanceID)
	populate(objectMap, "memberType", r.MemberType)
	populate(objectMap, "originRoleAssignmentId", r.OriginRoleAssignmentID)
	populate(objectMap, "principalId", r.PrincipalID)
	populate(objectMap, "principalType", r.PrincipalType)
	populate(objectMap, "roleAssignmentScheduleId", r.RoleAssignmentScheduleID)
	populate(objectMap, "roleDefinitionId", r.RoleDefinitionID)
	populate(objectMap, "scope", r.Scope)
	populateTimeRFC3339(objectMap, "startDateTime", r.StartDateTime)
	populate(objectMap, "status", r.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleAssignmentScheduleInstanceProperties.
func (r *RoleAssignmentScheduleInstanceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assignmentType":
			err = unpopulate(val, &r.AssignmentType)
			delete(rawMsg, key)
		case "condition":
			err = unpopulate(val, &r.Condition)
			delete(rawMsg, key)
		case "conditionVersion":
			err = unpopulate(val, &r.ConditionVersion)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, &r.CreatedOn)
			delete(rawMsg, key)
		case "endDateTime":
			err = unpopulateTimeRFC3339(val, &r.EndDateTime)
			delete(rawMsg, key)
		case "expandedProperties":
			err = unpopulate(val, &r.ExpandedProperties)
			delete(rawMsg, key)
		case "linkedRoleEligibilityScheduleId":
			err = unpopulate(val, &r.LinkedRoleEligibilityScheduleID)
			delete(rawMsg, key)
		case "linkedRoleEligibilityScheduleInstanceId":
			err = unpopulate(val, &r.LinkedRoleEligibilityScheduleInstanceID)
			delete(rawMsg, key)
		case "memberType":
			err = unpopulate(val, &r.MemberType)
			delete(rawMsg, key)
		case "originRoleAssignmentId":
			err = unpopulate(val, &r.OriginRoleAssignmentID)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, &r.PrincipalID)
			delete(rawMsg, key)
		case "principalType":
			err = unpopulate(val, &r.PrincipalType)
			delete(rawMsg, key)
		case "roleAssignmentScheduleId":
			err = unpopulate(val, &r.RoleAssignmentScheduleID)
			delete(rawMsg, key)
		case "roleDefinitionId":
			err = unpopulate(val, &r.RoleDefinitionID)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &r.Scope)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateTimeRFC3339(val, &r.StartDateTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleAssignmentScheduleInstancesGetOptions contains the optional parameters for the RoleAssignmentScheduleInstances.Get method.
type RoleAssignmentScheduleInstancesGetOptions struct {
	// placeholder for future optional parameters
}

// RoleAssignmentScheduleInstancesListForScopeOptions contains the optional parameters for the RoleAssignmentScheduleInstances.ListForScope method.
type RoleAssignmentScheduleInstancesListForScopeOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all role assignment schedules at or above the scope. Use $filter=principalId eq
	// {id} to return all role assignment schedules at, above or below the scope for the specified principal. Use $filter=assignedTo('{userId}') to return all
	// role assignment schedule instances for the user. Use $filter=asTarget() to return all role assignment schedule instances created for the current user.
	Filter *string
}

// RoleAssignmentScheduleListResult - Role assignment schedule list operation result.
type RoleAssignmentScheduleListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Role assignment schedule list.
	Value []*RoleAssignmentSchedule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleAssignmentScheduleListResult.
func (r RoleAssignmentScheduleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoleAssignmentScheduleProperties - Role assignment schedule properties with scope.
type RoleAssignmentScheduleProperties struct {
	// Assignment type of the role assignment schedule
	AssignmentType *AssignmentType `json:"assignmentType,omitempty"`

	// The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
	// StringEqualsIgnoreCase
	// 'foostoragecontainer'
	Condition *string `json:"condition,omitempty"`

	// Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`

	// DateTime when role assignment schedule was created
	CreatedOn *time.Time `json:"createdOn,omitempty"`

	// End DateTime when role assignment schedule
	EndDateTime *time.Time `json:"endDateTime,omitempty"`

	// Additional properties of principal, scope and role definition
	ExpandedProperties *ExpandedProperties `json:"expandedProperties,omitempty"`

	// The id of roleEligibilitySchedule used to activated this roleAssignmentSchedule
	LinkedRoleEligibilityScheduleID *string `json:"linkedRoleEligibilityScheduleId,omitempty"`

	// Membership type of the role assignment schedule
	MemberType *MemberType `json:"memberType,omitempty"`

	// The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`

	// The principal type of the assigned principal ID.
	PrincipalType *PrincipalType `json:"principalType,omitempty"`

	// The id of roleAssignmentScheduleRequest used to create this roleAssignmentSchedule
	RoleAssignmentScheduleRequestID *string `json:"roleAssignmentScheduleRequestId,omitempty"`

	// The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// The role assignment schedule scope.
	Scope *string `json:"scope,omitempty"`

	// Start DateTime when role assignment schedule
	StartDateTime *time.Time `json:"startDateTime,omitempty"`

	// The status of the role assignment schedule.
	Status *Status `json:"status,omitempty"`

	// DateTime when role assignment schedule was modified
	UpdatedOn *time.Time `json:"updatedOn,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleAssignmentScheduleProperties.
func (r RoleAssignmentScheduleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assignmentType", r.AssignmentType)
	populate(objectMap, "condition", r.Condition)
	populate(objectMap, "conditionVersion", r.ConditionVersion)
	populateTimeRFC3339(objectMap, "createdOn", r.CreatedOn)
	populateTimeRFC3339(objectMap, "endDateTime", r.EndDateTime)
	populate(objectMap, "expandedProperties", r.ExpandedProperties)
	populate(objectMap, "linkedRoleEligibilityScheduleId", r.LinkedRoleEligibilityScheduleID)
	populate(objectMap, "memberType", r.MemberType)
	populate(objectMap, "principalId", r.PrincipalID)
	populate(objectMap, "principalType", r.PrincipalType)
	populate(objectMap, "roleAssignmentScheduleRequestId", r.RoleAssignmentScheduleRequestID)
	populate(objectMap, "roleDefinitionId", r.RoleDefinitionID)
	populate(objectMap, "scope", r.Scope)
	populateTimeRFC3339(objectMap, "startDateTime", r.StartDateTime)
	populate(objectMap, "status", r.Status)
	populateTimeRFC3339(objectMap, "updatedOn", r.UpdatedOn)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleAssignmentScheduleProperties.
func (r *RoleAssignmentScheduleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assignmentType":
			err = unpopulate(val, &r.AssignmentType)
			delete(rawMsg, key)
		case "condition":
			err = unpopulate(val, &r.Condition)
			delete(rawMsg, key)
		case "conditionVersion":
			err = unpopulate(val, &r.ConditionVersion)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, &r.CreatedOn)
			delete(rawMsg, key)
		case "endDateTime":
			err = unpopulateTimeRFC3339(val, &r.EndDateTime)
			delete(rawMsg, key)
		case "expandedProperties":
			err = unpopulate(val, &r.ExpandedProperties)
			delete(rawMsg, key)
		case "linkedRoleEligibilityScheduleId":
			err = unpopulate(val, &r.LinkedRoleEligibilityScheduleID)
			delete(rawMsg, key)
		case "memberType":
			err = unpopulate(val, &r.MemberType)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, &r.PrincipalID)
			delete(rawMsg, key)
		case "principalType":
			err = unpopulate(val, &r.PrincipalType)
			delete(rawMsg, key)
		case "roleAssignmentScheduleRequestId":
			err = unpopulate(val, &r.RoleAssignmentScheduleRequestID)
			delete(rawMsg, key)
		case "roleDefinitionId":
			err = unpopulate(val, &r.RoleDefinitionID)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &r.Scope)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateTimeRFC3339(val, &r.StartDateTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "updatedOn":
			err = unpopulateTimeRFC3339(val, &r.UpdatedOn)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleAssignmentScheduleRequest - Role Assignment schedule request
type RoleAssignmentScheduleRequest struct {
	// Role assignment schedule request properties.
	Properties *RoleAssignmentScheduleRequestProperties `json:"properties,omitempty"`

	// READ-ONLY; The role assignment schedule request ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment schedule request name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment schedule request type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RoleAssignmentScheduleRequestFilter - Role assignment schedule request filter
type RoleAssignmentScheduleRequestFilter struct {
	// Returns role assignment requests of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`

	// Returns role assignment requests created by specific principal.
	RequestorID *string `json:"requestorId,omitempty"`

	// Returns role assignment requests of the specific role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// Returns role assignment requests of specific status.
	Status *string `json:"status,omitempty"`
}

// RoleAssignmentScheduleRequestListResult - Role assignment schedule request list operation result.
type RoleAssignmentScheduleRequestListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Role assignment schedule request list.
	Value []*RoleAssignmentScheduleRequest `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleAssignmentScheduleRequestListResult.
func (r RoleAssignmentScheduleRequestListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoleAssignmentScheduleRequestProperties - Role assignment schedule request properties with scope.
type RoleAssignmentScheduleRequestProperties struct {
	// REQUIRED; The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`

	// REQUIRED; The type of the role assignment schedule request. Eg: SelfActivate, AdminAssign etc
	RequestType *RequestType `json:"requestType,omitempty"`

	// REQUIRED; The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
	// StringEqualsIgnoreCase
	// 'foostoragecontainer'
	Condition *string `json:"condition,omitempty"`

	// Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`

	// Justification for the role assignment
	Justification *string `json:"justification,omitempty"`

	// The linked role eligibility schedule id - to activate an eligibility.
	LinkedRoleEligibilityScheduleID *string `json:"linkedRoleEligibilityScheduleId,omitempty"`

	// Schedule info of the role assignment schedule
	ScheduleInfo *RoleAssignmentScheduleRequestPropertiesScheduleInfo `json:"scheduleInfo,omitempty"`

	// The resultant role assignment schedule id or the role assignment schedule id being updated
	TargetRoleAssignmentScheduleID *string `json:"targetRoleAssignmentScheduleId,omitempty"`

	// The role assignment schedule instance id being updated
	TargetRoleAssignmentScheduleInstanceID *string `json:"targetRoleAssignmentScheduleInstanceId,omitempty"`

	// Ticket Info of the role assignment
	TicketInfo *RoleAssignmentScheduleRequestPropertiesTicketInfo `json:"ticketInfo,omitempty"`

	// READ-ONLY; The approvalId of the role assignment schedule request.
	ApprovalID *string `json:"approvalId,omitempty" azure:"ro"`

	// READ-ONLY; DateTime when role assignment schedule request was created
	CreatedOn *time.Time `json:"createdOn,omitempty" azure:"ro"`

	// READ-ONLY; Additional properties of principal, scope and role definition
	ExpandedProperties *ExpandedProperties `json:"expandedProperties,omitempty" azure:"ro"`

	// READ-ONLY; The principal type of the assigned principal ID.
	PrincipalType *PrincipalType `json:"principalType,omitempty" azure:"ro"`

	// READ-ONLY; Id of the user who created this request
	RequestorID *string `json:"requestorId,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment schedule request scope.
	Scope *string `json:"scope,omitempty" azure:"ro"`

	// READ-ONLY; The status of the role assignment schedule request.
	Status *Status `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleAssignmentScheduleRequestProperties.
func (r RoleAssignmentScheduleRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "approvalId", r.ApprovalID)
	populate(objectMap, "condition", r.Condition)
	populate(objectMap, "conditionVersion", r.ConditionVersion)
	populateTimeRFC3339(objectMap, "createdOn", r.CreatedOn)
	populate(objectMap, "expandedProperties", r.ExpandedProperties)
	populate(objectMap, "justification", r.Justification)
	populate(objectMap, "linkedRoleEligibilityScheduleId", r.LinkedRoleEligibilityScheduleID)
	populate(objectMap, "principalId", r.PrincipalID)
	populate(objectMap, "principalType", r.PrincipalType)
	populate(objectMap, "requestType", r.RequestType)
	populate(objectMap, "requestorId", r.RequestorID)
	populate(objectMap, "roleDefinitionId", r.RoleDefinitionID)
	populate(objectMap, "scheduleInfo", r.ScheduleInfo)
	populate(objectMap, "scope", r.Scope)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "targetRoleAssignmentScheduleId", r.TargetRoleAssignmentScheduleID)
	populate(objectMap, "targetRoleAssignmentScheduleInstanceId", r.TargetRoleAssignmentScheduleInstanceID)
	populate(objectMap, "ticketInfo", r.TicketInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleAssignmentScheduleRequestProperties.
func (r *RoleAssignmentScheduleRequestProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "approvalId":
			err = unpopulate(val, &r.ApprovalID)
			delete(rawMsg, key)
		case "condition":
			err = unpopulate(val, &r.Condition)
			delete(rawMsg, key)
		case "conditionVersion":
			err = unpopulate(val, &r.ConditionVersion)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, &r.CreatedOn)
			delete(rawMsg, key)
		case "expandedProperties":
			err = unpopulate(val, &r.ExpandedProperties)
			delete(rawMsg, key)
		case "justification":
			err = unpopulate(val, &r.Justification)
			delete(rawMsg, key)
		case "linkedRoleEligibilityScheduleId":
			err = unpopulate(val, &r.LinkedRoleEligibilityScheduleID)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, &r.PrincipalID)
			delete(rawMsg, key)
		case "principalType":
			err = unpopulate(val, &r.PrincipalType)
			delete(rawMsg, key)
		case "requestType":
			err = unpopulate(val, &r.RequestType)
			delete(rawMsg, key)
		case "requestorId":
			err = unpopulate(val, &r.RequestorID)
			delete(rawMsg, key)
		case "roleDefinitionId":
			err = unpopulate(val, &r.RoleDefinitionID)
			delete(rawMsg, key)
		case "scheduleInfo":
			err = unpopulate(val, &r.ScheduleInfo)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &r.Scope)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "targetRoleAssignmentScheduleId":
			err = unpopulate(val, &r.TargetRoleAssignmentScheduleID)
			delete(rawMsg, key)
		case "targetRoleAssignmentScheduleInstanceId":
			err = unpopulate(val, &r.TargetRoleAssignmentScheduleInstanceID)
			delete(rawMsg, key)
		case "ticketInfo":
			err = unpopulate(val, &r.TicketInfo)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleAssignmentScheduleRequestPropertiesScheduleInfo - Schedule info of the role assignment schedule
type RoleAssignmentScheduleRequestPropertiesScheduleInfo struct {
	// Expiration of the role assignment schedule
	Expiration *RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration `json:"expiration,omitempty"`

	// Start DateTime of the role assignment schedule.
	StartDateTime *time.Time `json:"startDateTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleAssignmentScheduleRequestPropertiesScheduleInfo.
func (r RoleAssignmentScheduleRequestPropertiesScheduleInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "expiration", r.Expiration)
	populateTimeRFC3339(objectMap, "startDateTime", r.StartDateTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleAssignmentScheduleRequestPropertiesScheduleInfo.
func (r *RoleAssignmentScheduleRequestPropertiesScheduleInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiration":
			err = unpopulate(val, &r.Expiration)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateTimeRFC3339(val, &r.StartDateTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration - Expiration of the role assignment schedule
type RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration struct {
	// Duration of the role assignment schedule in TimeSpan.
	Duration *string `json:"duration,omitempty"`

	// End DateTime of the role assignment schedule.
	EndDateTime *time.Time `json:"endDateTime,omitempty"`

	// Type of the role assignment schedule expiration
	Type *Type `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration.
func (r RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "duration", r.Duration)
	populateTimeRFC3339(objectMap, "endDateTime", r.EndDateTime)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration.
func (r *RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
			err = unpopulate(val, &r.Duration)
			delete(rawMsg, key)
		case "endDateTime":
			err = unpopulateTimeRFC3339(val, &r.EndDateTime)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleAssignmentScheduleRequestPropertiesTicketInfo - Ticket Info of the role assignment
type RoleAssignmentScheduleRequestPropertiesTicketInfo struct {
	// Ticket number for the role assignment
	TicketNumber *string `json:"ticketNumber,omitempty"`

	// Ticket system name for the role assignment
	TicketSystem *string `json:"ticketSystem,omitempty"`
}

// RoleAssignmentScheduleRequestsCancelOptions contains the optional parameters for the RoleAssignmentScheduleRequests.Cancel method.
type RoleAssignmentScheduleRequestsCancelOptions struct {
	// placeholder for future optional parameters
}

// RoleAssignmentScheduleRequestsCreateOptions contains the optional parameters for the RoleAssignmentScheduleRequests.Create method.
type RoleAssignmentScheduleRequestsCreateOptions struct {
	// placeholder for future optional parameters
}

// RoleAssignmentScheduleRequestsGetOptions contains the optional parameters for the RoleAssignmentScheduleRequests.Get method.
type RoleAssignmentScheduleRequestsGetOptions struct {
	// placeholder for future optional parameters
}

// RoleAssignmentScheduleRequestsListForScopeOptions contains the optional parameters for the RoleAssignmentScheduleRequests.ListForScope method.
type RoleAssignmentScheduleRequestsListForScopeOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all role assignment schedule requests at or above the scope. Use $filter=principalId
	// eq {id} to return all role assignment schedule requests at, above or below the scope for the specified principal. Use $filter=asRequestor() to return
	// all role assignment schedule requests requested by the current user. Use $filter=asTarget() to return all role assignment schedule requests created for
	// the current user. Use $filter=asApprover() to return all role assignment schedule requests where the current user is an approver.
	Filter *string
}

// RoleAssignmentSchedulesGetOptions contains the optional parameters for the RoleAssignmentSchedules.Get method.
type RoleAssignmentSchedulesGetOptions struct {
	// placeholder for future optional parameters
}

// RoleAssignmentSchedulesListForScopeOptions contains the optional parameters for the RoleAssignmentSchedules.ListForScope method.
type RoleAssignmentSchedulesListForScopeOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all role assignment schedules at or above the scope. Use $filter=principalId eq
	// {id} to return all role assignment schedules at, above or below the scope for the specified principal. Use $filter=assignedTo('{userId}') to return all
	// role assignment schedules for the current user. Use $filter=asTarget() to return all role assignment schedules created for the current user.
	Filter *string
}

// RoleAssignmentsCreateByIDOptions contains the optional parameters for the RoleAssignments.CreateByID method.
type RoleAssignmentsCreateByIDOptions struct {
	// placeholder for future optional parameters
}

// RoleAssignmentsCreateOptions contains the optional parameters for the RoleAssignments.Create method.
type RoleAssignmentsCreateOptions struct {
	// placeholder for future optional parameters
}

// RoleAssignmentsDeleteByIDOptions contains the optional parameters for the RoleAssignments.DeleteByID method.
type RoleAssignmentsDeleteByIDOptions struct {
	// Tenant ID for cross-tenant request
	TenantID *string
}

// RoleAssignmentsDeleteOptions contains the optional parameters for the RoleAssignments.Delete method.
type RoleAssignmentsDeleteOptions struct {
	// Tenant ID for cross-tenant request
	TenantID *string
}

// RoleAssignmentsGetByIDOptions contains the optional parameters for the RoleAssignments.GetByID method.
type RoleAssignmentsGetByIDOptions struct {
	// Tenant ID for cross-tenant request
	TenantID *string
}

// RoleAssignmentsGetOptions contains the optional parameters for the RoleAssignments.Get method.
type RoleAssignmentsGetOptions struct {
	// Tenant ID for cross-tenant request
	TenantID *string
}

// RoleAssignmentsListForResourceGroupOptions contains the optional parameters for the RoleAssignments.ListForResourceGroup method.
type RoleAssignmentsListForResourceGroupOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all role assignments at or above the scope. Use $filter=principalId eq {id} to
	// return all role assignments at, above or below the scope for the specified principal.
	Filter *string
	// Tenant ID for cross-tenant request
	TenantID *string
}

// RoleAssignmentsListForResourceOptions contains the optional parameters for the RoleAssignments.ListForResource method.
type RoleAssignmentsListForResourceOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all role assignments at or above the scope. Use $filter=principalId eq {id} to
	// return all role assignments at, above or below the scope for the specified principal.
	Filter *string
	// Tenant ID for cross-tenant request
	TenantID *string
}

// RoleAssignmentsListForScopeOptions contains the optional parameters for the RoleAssignments.ListForScope method.
type RoleAssignmentsListForScopeOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all role assignments at or above the scope. Use $filter=principalId eq {id} to
	// return all role assignments at, above or below the scope for the specified principal.
	Filter *string
	// Tenant ID for cross-tenant request
	TenantID *string
}

// RoleAssignmentsListForSubscriptionOptions contains the optional parameters for the RoleAssignments.ListForSubscription method.
type RoleAssignmentsListForSubscriptionOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all role assignments at or above the scope. Use $filter=principalId eq {id} to
	// return all role assignments at, above or below the scope for the specified principal.
	Filter *string
	// Tenant ID for cross-tenant request
	TenantID *string
}

// RoleAssignmentsValidateByIDOptions contains the optional parameters for the RoleAssignments.ValidateByID method.
type RoleAssignmentsValidateByIDOptions struct {
	// placeholder for future optional parameters
}

// RoleAssignmentsValidateOptions contains the optional parameters for the RoleAssignments.Validate method.
type RoleAssignmentsValidateOptions struct {
	// placeholder for future optional parameters
}

// RoleDefinition - Role definition.
type RoleDefinition struct {
	// Role definition properties.
	Properties *RoleDefinitionProperties `json:"properties,omitempty"`

	// READ-ONLY; The role definition ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The role definition name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The role definition type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RoleDefinitionFilter - Role Definitions filter
type RoleDefinitionFilter struct {
	// Returns role definition with the specific name.
	RoleName *string `json:"roleName,omitempty"`

	// Returns role definition with the specific type.
	Type *string `json:"type,omitempty"`
}

// RoleDefinitionListResult - Role definition list operation result.
type RoleDefinitionListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Role definition list.
	Value []*RoleDefinition `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleDefinitionListResult.
func (r RoleDefinitionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoleDefinitionProperties - Role definition properties.
type RoleDefinitionProperties struct {
	// Role definition assignable scopes.
	AssignableScopes []*string `json:"assignableScopes,omitempty"`

	// The role definition description.
	Description *string `json:"description,omitempty"`

	// Role definition permissions.
	Permissions []*Permission `json:"permissions,omitempty"`

	// The role name.
	RoleName *string `json:"roleName,omitempty"`

	// The role type.
	RoleType *string `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleDefinitionProperties.
func (r RoleDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assignableScopes", r.AssignableScopes)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "permissions", r.Permissions)
	populate(objectMap, "roleName", r.RoleName)
	populate(objectMap, "type", r.RoleType)
	return json.Marshal(objectMap)
}

// RoleDefinitionsCreateOrUpdateOptions contains the optional parameters for the RoleDefinitions.CreateOrUpdate method.
type RoleDefinitionsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// RoleDefinitionsDeleteOptions contains the optional parameters for the RoleDefinitions.Delete method.
type RoleDefinitionsDeleteOptions struct {
	// placeholder for future optional parameters
}

// RoleDefinitionsGetByIDOptions contains the optional parameters for the RoleDefinitions.GetByID method.
type RoleDefinitionsGetByIDOptions struct {
	// placeholder for future optional parameters
}

// RoleDefinitionsGetOptions contains the optional parameters for the RoleDefinitions.Get method.
type RoleDefinitionsGetOptions struct {
	// placeholder for future optional parameters
}

// RoleDefinitionsListOptions contains the optional parameters for the RoleDefinitions.List method.
type RoleDefinitionsListOptions struct {
	// The filter to apply on the operation. Use atScopeAndBelow filter to search below the given scope as well.
	Filter *string
}

// RoleEligibilitySchedule - Role eligibility schedule
type RoleEligibilitySchedule struct {
	// role eligibility schedule properties.
	Properties *RoleEligibilityScheduleProperties `json:"properties,omitempty"`

	// READ-ONLY; The role eligibility schedule Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The role eligibility schedule name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The role eligibility schedule type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RoleEligibilityScheduleFilter - Role eligibility schedule filter
type RoleEligibilityScheduleFilter struct {
	// Returns role eligibility schedule of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`

	// Returns role eligibility schedule of the specific role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// Returns role eligibility schedule of the specific status.
	Status *string `json:"status,omitempty"`
}

// RoleEligibilityScheduleInstance - Information about current or upcoming role eligibility schedule instance
type RoleEligibilityScheduleInstance struct {
	// Role eligibility schedule instance properties.
	Properties *RoleEligibilityScheduleInstanceProperties `json:"properties,omitempty"`

	// READ-ONLY; The role eligibility schedule instance ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The role eligibility schedule instance name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The role eligibility schedule instance type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RoleEligibilityScheduleInstanceFilter - Role eligibility schedule instance filter
type RoleEligibilityScheduleInstanceFilter struct {
	// Returns role eligibility schedule instances of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`

	// Returns role eligibility schedule instances of the specific role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// Returns role eligibility schedule instances belonging to a specific role eligibility schedule.
	RoleEligibilityScheduleID *string `json:"roleEligibilityScheduleId,omitempty"`

	// Returns role eligibility schedule instances of the specific status.
	Status *string `json:"status,omitempty"`
}

// RoleEligibilityScheduleInstanceListResult - Role eligibility schedule instance list operation result.
type RoleEligibilityScheduleInstanceListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Role eligibility schedule instance list.
	Value []*RoleEligibilityScheduleInstance `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleEligibilityScheduleInstanceListResult.
func (r RoleEligibilityScheduleInstanceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoleEligibilityScheduleInstanceProperties - Role eligibility schedule properties with scope.
type RoleEligibilityScheduleInstanceProperties struct {
	// The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
	// StringEqualsIgnoreCase
	// 'foostoragecontainer'
	Condition *string `json:"condition,omitempty"`

	// Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`

	// DateTime when role eligibility schedule was created
	CreatedOn *time.Time `json:"createdOn,omitempty"`

	// The endDateTime of the role eligibility schedule instance
	EndDateTime *time.Time `json:"endDateTime,omitempty"`

	// Additional properties of principal, scope and role definition
	ExpandedProperties *ExpandedProperties `json:"expandedProperties,omitempty"`

	// Membership type of the role eligibility schedule
	MemberType *MemberType `json:"memberType,omitempty"`

	// The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`

	// The principal type of the assigned principal ID.
	PrincipalType *PrincipalType `json:"principalType,omitempty"`

	// The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// Id of the master role eligibility schedule
	RoleEligibilityScheduleID *string `json:"roleEligibilityScheduleId,omitempty"`

	// The role eligibility schedule scope.
	Scope *string `json:"scope,omitempty"`

	// The startDateTime of the role eligibility schedule instance
	StartDateTime *time.Time `json:"startDateTime,omitempty"`

	// The status of the role eligibility schedule instance
	Status *Status `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleEligibilityScheduleInstanceProperties.
func (r RoleEligibilityScheduleInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "condition", r.Condition)
	populate(objectMap, "conditionVersion", r.ConditionVersion)
	populateTimeRFC3339(objectMap, "createdOn", r.CreatedOn)
	populateTimeRFC3339(objectMap, "endDateTime", r.EndDateTime)
	populate(objectMap, "expandedProperties", r.ExpandedProperties)
	populate(objectMap, "memberType", r.MemberType)
	populate(objectMap, "principalId", r.PrincipalID)
	populate(objectMap, "principalType", r.PrincipalType)
	populate(objectMap, "roleDefinitionId", r.RoleDefinitionID)
	populate(objectMap, "roleEligibilityScheduleId", r.RoleEligibilityScheduleID)
	populate(objectMap, "scope", r.Scope)
	populateTimeRFC3339(objectMap, "startDateTime", r.StartDateTime)
	populate(objectMap, "status", r.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleEligibilityScheduleInstanceProperties.
func (r *RoleEligibilityScheduleInstanceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "condition":
			err = unpopulate(val, &r.Condition)
			delete(rawMsg, key)
		case "conditionVersion":
			err = unpopulate(val, &r.ConditionVersion)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, &r.CreatedOn)
			delete(rawMsg, key)
		case "endDateTime":
			err = unpopulateTimeRFC3339(val, &r.EndDateTime)
			delete(rawMsg, key)
		case "expandedProperties":
			err = unpopulate(val, &r.ExpandedProperties)
			delete(rawMsg, key)
		case "memberType":
			err = unpopulate(val, &r.MemberType)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, &r.PrincipalID)
			delete(rawMsg, key)
		case "principalType":
			err = unpopulate(val, &r.PrincipalType)
			delete(rawMsg, key)
		case "roleDefinitionId":
			err = unpopulate(val, &r.RoleDefinitionID)
			delete(rawMsg, key)
		case "roleEligibilityScheduleId":
			err = unpopulate(val, &r.RoleEligibilityScheduleID)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &r.Scope)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateTimeRFC3339(val, &r.StartDateTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleEligibilityScheduleInstancesGetOptions contains the optional parameters for the RoleEligibilityScheduleInstances.Get method.
type RoleEligibilityScheduleInstancesGetOptions struct {
	// placeholder for future optional parameters
}

// RoleEligibilityScheduleInstancesListForScopeOptions contains the optional parameters for the RoleEligibilityScheduleInstances.ListForScope method.
type RoleEligibilityScheduleInstancesListForScopeOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all role assignment schedules at or above the scope. Use $filter=principalId eq
	// {id} to return all role assignment schedules at, above or below the scope for the specified principal. Use $filter=assignedTo('{userId}') to return all
	// role eligibility schedules for the user. Use $filter=asTarget() to return all role eligibility schedules created for the current user.
	Filter *string
}

// RoleEligibilityScheduleListResult - role eligibility schedule list operation result.
type RoleEligibilityScheduleListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// role eligibility schedule list.
	Value []*RoleEligibilitySchedule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleEligibilityScheduleListResult.
func (r RoleEligibilityScheduleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoleEligibilityScheduleProperties - Role eligibility schedule properties with scope.
type RoleEligibilityScheduleProperties struct {
	// The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
	// StringEqualsIgnoreCase
	// 'foostoragecontainer'
	Condition *string `json:"condition,omitempty"`

	// Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`

	// DateTime when role eligibility schedule was created
	CreatedOn *time.Time `json:"createdOn,omitempty"`

	// End DateTime when role eligibility schedule
	EndDateTime *time.Time `json:"endDateTime,omitempty"`

	// Additional properties of principal, scope and role definition
	ExpandedProperties *ExpandedProperties `json:"expandedProperties,omitempty"`

	// Membership type of the role eligibility schedule
	MemberType *MemberType `json:"memberType,omitempty"`

	// The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`

	// The principal type of the assigned principal ID.
	PrincipalType *PrincipalType `json:"principalType,omitempty"`

	// The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// The id of roleEligibilityScheduleRequest used to create this roleAssignmentSchedule
	RoleEligibilityScheduleRequestID *string `json:"roleEligibilityScheduleRequestId,omitempty"`

	// The role eligibility schedule scope.
	Scope *string `json:"scope,omitempty"`

	// Start DateTime when role eligibility schedule
	StartDateTime *time.Time `json:"startDateTime,omitempty"`

	// The status of the role eligibility schedule.
	Status *Status `json:"status,omitempty"`

	// DateTime when role eligibility schedule was modified
	UpdatedOn *time.Time `json:"updatedOn,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleEligibilityScheduleProperties.
func (r RoleEligibilityScheduleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "condition", r.Condition)
	populate(objectMap, "conditionVersion", r.ConditionVersion)
	populateTimeRFC3339(objectMap, "createdOn", r.CreatedOn)
	populateTimeRFC3339(objectMap, "endDateTime", r.EndDateTime)
	populate(objectMap, "expandedProperties", r.ExpandedProperties)
	populate(objectMap, "memberType", r.MemberType)
	populate(objectMap, "principalId", r.PrincipalID)
	populate(objectMap, "principalType", r.PrincipalType)
	populate(objectMap, "roleDefinitionId", r.RoleDefinitionID)
	populate(objectMap, "roleEligibilityScheduleRequestId", r.RoleEligibilityScheduleRequestID)
	populate(objectMap, "scope", r.Scope)
	populateTimeRFC3339(objectMap, "startDateTime", r.StartDateTime)
	populate(objectMap, "status", r.Status)
	populateTimeRFC3339(objectMap, "updatedOn", r.UpdatedOn)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleEligibilityScheduleProperties.
func (r *RoleEligibilityScheduleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "condition":
			err = unpopulate(val, &r.Condition)
			delete(rawMsg, key)
		case "conditionVersion":
			err = unpopulate(val, &r.ConditionVersion)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, &r.CreatedOn)
			delete(rawMsg, key)
		case "endDateTime":
			err = unpopulateTimeRFC3339(val, &r.EndDateTime)
			delete(rawMsg, key)
		case "expandedProperties":
			err = unpopulate(val, &r.ExpandedProperties)
			delete(rawMsg, key)
		case "memberType":
			err = unpopulate(val, &r.MemberType)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, &r.PrincipalID)
			delete(rawMsg, key)
		case "principalType":
			err = unpopulate(val, &r.PrincipalType)
			delete(rawMsg, key)
		case "roleDefinitionId":
			err = unpopulate(val, &r.RoleDefinitionID)
			delete(rawMsg, key)
		case "roleEligibilityScheduleRequestId":
			err = unpopulate(val, &r.RoleEligibilityScheduleRequestID)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &r.Scope)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateTimeRFC3339(val, &r.StartDateTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "updatedOn":
			err = unpopulateTimeRFC3339(val, &r.UpdatedOn)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleEligibilityScheduleRequest - Role Eligibility schedule request
type RoleEligibilityScheduleRequest struct {
	// Role eligibility schedule request properties.
	Properties *RoleEligibilityScheduleRequestProperties `json:"properties,omitempty"`

	// READ-ONLY; The role eligibility schedule request ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The role eligibility schedule request name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The role eligibility schedule request type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RoleEligibilityScheduleRequestFilter - Role eligibility schedule request filter
type RoleEligibilityScheduleRequestFilter struct {
	// Returns role eligibility requests of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`

	// Returns role eligibility requests created by specific principal.
	RequestorID *string `json:"requestorId,omitempty"`

	// Returns role eligibility requests of the specific role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// Returns role eligibility requests of specific status.
	Status *string `json:"status,omitempty"`
}

// RoleEligibilityScheduleRequestListResult - Role eligibility schedule request list operation result.
type RoleEligibilityScheduleRequestListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Role eligibility schedule request list.
	Value []*RoleEligibilityScheduleRequest `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleEligibilityScheduleRequestListResult.
func (r RoleEligibilityScheduleRequestListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoleEligibilityScheduleRequestProperties - Role eligibility schedule request properties with scope.
type RoleEligibilityScheduleRequestProperties struct {
	// REQUIRED; The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`

	// REQUIRED; The type of the role assignment schedule request. Eg: SelfActivate, AdminAssign etc
	RequestType *RequestType `json:"requestType,omitempty"`

	// REQUIRED; The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
	// StringEqualsIgnoreCase
	// 'foostoragecontainer'
	Condition *string `json:"condition,omitempty"`

	// Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`

	// Justification for the role eligibility
	Justification *string `json:"justification,omitempty"`

	// Schedule info of the role eligibility schedule
	ScheduleInfo *RoleEligibilityScheduleRequestPropertiesScheduleInfo `json:"scheduleInfo,omitempty"`

	// The resultant role eligibility schedule id or the role eligibility schedule id being updated
	TargetRoleEligibilityScheduleID *string `json:"targetRoleEligibilityScheduleId,omitempty"`

	// The role eligibility schedule instance id being updated
	TargetRoleEligibilityScheduleInstanceID *string `json:"targetRoleEligibilityScheduleInstanceId,omitempty"`

	// Ticket Info of the role eligibility
	TicketInfo *RoleEligibilityScheduleRequestPropertiesTicketInfo `json:"ticketInfo,omitempty"`

	// READ-ONLY; The approvalId of the role eligibility schedule request.
	ApprovalID *string `json:"approvalId,omitempty" azure:"ro"`

	// READ-ONLY; DateTime when role eligibility schedule request was created
	CreatedOn *time.Time `json:"createdOn,omitempty" azure:"ro"`

	// READ-ONLY; Additional properties of principal, scope and role definition
	ExpandedProperties *ExpandedProperties `json:"expandedProperties,omitempty" azure:"ro"`

	// READ-ONLY; The principal type of the assigned principal ID.
	PrincipalType *PrincipalType `json:"principalType,omitempty" azure:"ro"`

	// READ-ONLY; Id of the user who created this request
	RequestorID *string `json:"requestorId,omitempty" azure:"ro"`

	// READ-ONLY; The role eligibility schedule request scope.
	Scope *string `json:"scope,omitempty" azure:"ro"`

	// READ-ONLY; The status of the role eligibility schedule request.
	Status *Status `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleEligibilityScheduleRequestProperties.
func (r RoleEligibilityScheduleRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "approvalId", r.ApprovalID)
	populate(objectMap, "condition", r.Condition)
	populate(objectMap, "conditionVersion", r.ConditionVersion)
	populateTimeRFC3339(objectMap, "createdOn", r.CreatedOn)
	populate(objectMap, "expandedProperties", r.ExpandedProperties)
	populate(objectMap, "justification", r.Justification)
	populate(objectMap, "principalId", r.PrincipalID)
	populate(objectMap, "principalType", r.PrincipalType)
	populate(objectMap, "requestType", r.RequestType)
	populate(objectMap, "requestorId", r.RequestorID)
	populate(objectMap, "roleDefinitionId", r.RoleDefinitionID)
	populate(objectMap, "scheduleInfo", r.ScheduleInfo)
	populate(objectMap, "scope", r.Scope)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "targetRoleEligibilityScheduleId", r.TargetRoleEligibilityScheduleID)
	populate(objectMap, "targetRoleEligibilityScheduleInstanceId", r.TargetRoleEligibilityScheduleInstanceID)
	populate(objectMap, "ticketInfo", r.TicketInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleEligibilityScheduleRequestProperties.
func (r *RoleEligibilityScheduleRequestProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "approvalId":
			err = unpopulate(val, &r.ApprovalID)
			delete(rawMsg, key)
		case "condition":
			err = unpopulate(val, &r.Condition)
			delete(rawMsg, key)
		case "conditionVersion":
			err = unpopulate(val, &r.ConditionVersion)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulateTimeRFC3339(val, &r.CreatedOn)
			delete(rawMsg, key)
		case "expandedProperties":
			err = unpopulate(val, &r.ExpandedProperties)
			delete(rawMsg, key)
		case "justification":
			err = unpopulate(val, &r.Justification)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, &r.PrincipalID)
			delete(rawMsg, key)
		case "principalType":
			err = unpopulate(val, &r.PrincipalType)
			delete(rawMsg, key)
		case "requestType":
			err = unpopulate(val, &r.RequestType)
			delete(rawMsg, key)
		case "requestorId":
			err = unpopulate(val, &r.RequestorID)
			delete(rawMsg, key)
		case "roleDefinitionId":
			err = unpopulate(val, &r.RoleDefinitionID)
			delete(rawMsg, key)
		case "scheduleInfo":
			err = unpopulate(val, &r.ScheduleInfo)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &r.Scope)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "targetRoleEligibilityScheduleId":
			err = unpopulate(val, &r.TargetRoleEligibilityScheduleID)
			delete(rawMsg, key)
		case "targetRoleEligibilityScheduleInstanceId":
			err = unpopulate(val, &r.TargetRoleEligibilityScheduleInstanceID)
			delete(rawMsg, key)
		case "ticketInfo":
			err = unpopulate(val, &r.TicketInfo)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleEligibilityScheduleRequestPropertiesScheduleInfo - Schedule info of the role eligibility schedule
type RoleEligibilityScheduleRequestPropertiesScheduleInfo struct {
	// Expiration of the role eligibility schedule
	Expiration *RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration `json:"expiration,omitempty"`

	// Start DateTime of the role eligibility schedule.
	StartDateTime *time.Time `json:"startDateTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleEligibilityScheduleRequestPropertiesScheduleInfo.
func (r RoleEligibilityScheduleRequestPropertiesScheduleInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "expiration", r.Expiration)
	populateTimeRFC3339(objectMap, "startDateTime", r.StartDateTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleEligibilityScheduleRequestPropertiesScheduleInfo.
func (r *RoleEligibilityScheduleRequestPropertiesScheduleInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiration":
			err = unpopulate(val, &r.Expiration)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateTimeRFC3339(val, &r.StartDateTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration - Expiration of the role eligibility schedule
type RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration struct {
	// Duration of the role eligibility schedule in TimeSpan.
	Duration *string `json:"duration,omitempty"`

	// End DateTime of the role eligibility schedule.
	EndDateTime *time.Time `json:"endDateTime,omitempty"`

	// Type of the role eligibility schedule expiration
	Type *Type `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration.
func (r RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "duration", r.Duration)
	populateTimeRFC3339(objectMap, "endDateTime", r.EndDateTime)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration.
func (r *RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
			err = unpopulate(val, &r.Duration)
			delete(rawMsg, key)
		case "endDateTime":
			err = unpopulateTimeRFC3339(val, &r.EndDateTime)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleEligibilityScheduleRequestPropertiesTicketInfo - Ticket Info of the role eligibility
type RoleEligibilityScheduleRequestPropertiesTicketInfo struct {
	// Ticket number for the role eligibility
	TicketNumber *string `json:"ticketNumber,omitempty"`

	// Ticket system name for the role eligibility
	TicketSystem *string `json:"ticketSystem,omitempty"`
}

// RoleEligibilityScheduleRequestsCancelOptions contains the optional parameters for the RoleEligibilityScheduleRequests.Cancel method.
type RoleEligibilityScheduleRequestsCancelOptions struct {
	// placeholder for future optional parameters
}

// RoleEligibilityScheduleRequestsCreateOptions contains the optional parameters for the RoleEligibilityScheduleRequests.Create method.
type RoleEligibilityScheduleRequestsCreateOptions struct {
	// placeholder for future optional parameters
}

// RoleEligibilityScheduleRequestsGetOptions contains the optional parameters for the RoleEligibilityScheduleRequests.Get method.
type RoleEligibilityScheduleRequestsGetOptions struct {
	// placeholder for future optional parameters
}

// RoleEligibilityScheduleRequestsListForScopeOptions contains the optional parameters for the RoleEligibilityScheduleRequests.ListForScope method.
type RoleEligibilityScheduleRequestsListForScopeOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all role eligibility schedule requests at or above the scope. Use $filter=principalId
	// eq {id} to return all role eligibility schedule requests at, above or below the scope for the specified principal. Use $filter=asRequestor() to return
	// all role eligibility schedule requests requested by the current user. Use $filter=asTarget() to return all role eligibility schedule requests created
	// for the current user. Use $filter=asApprover() to return all role eligibility schedule requests where the current user is an approver.
	Filter *string
}

// RoleEligibilitySchedulesGetOptions contains the optional parameters for the RoleEligibilitySchedules.Get method.
type RoleEligibilitySchedulesGetOptions struct {
	// placeholder for future optional parameters
}

// RoleEligibilitySchedulesListForScopeOptions contains the optional parameters for the RoleEligibilitySchedules.ListForScope method.
type RoleEligibilitySchedulesListForScopeOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all role eligibility schedules at or above the scope. Use $filter=principalId eq
	// {id} to return all role eligibility schedules at, above or below the scope for the specified principal. Use $filter=assignedTo('{userId}') to return
	// all role eligibility schedules for the user. Use $filter=asTarget() to return all role eligibility schedules created for the current user.
	Filter *string
}

// RoleManagementPoliciesDeleteOptions contains the optional parameters for the RoleManagementPolicies.Delete method.
type RoleManagementPoliciesDeleteOptions struct {
	// placeholder for future optional parameters
}

// RoleManagementPoliciesGetOptions contains the optional parameters for the RoleManagementPolicies.Get method.
type RoleManagementPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// RoleManagementPoliciesListForScopeOptions contains the optional parameters for the RoleManagementPolicies.ListForScope method.
type RoleManagementPoliciesListForScopeOptions struct {
	// placeholder for future optional parameters
}

// RoleManagementPoliciesUpdateOptions contains the optional parameters for the RoleManagementPolicies.Update method.
type RoleManagementPoliciesUpdateOptions struct {
	// placeholder for future optional parameters
}

// RoleManagementPolicy - Role management policy
type RoleManagementPolicy struct {
	// Role management policy properties.
	Properties *RoleManagementPolicyProperties `json:"properties,omitempty"`

	// READ-ONLY; The role management policy Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The role management policy name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The role management policy type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleManagementPolicy.
func (r RoleManagementPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// RoleManagementPolicyApprovalRule - The role management policy rule.
type RoleManagementPolicyApprovalRule struct {
	RoleManagementPolicyRule
	// The approval setting
	Setting *ApprovalSettings `json:"setting,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleManagementPolicyApprovalRule.
func (r RoleManagementPolicyApprovalRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.RoleManagementPolicyRule.marshalInternal(objectMap, RoleManagementPolicyRuleTypeRoleManagementPolicyApprovalRule)
	populate(objectMap, "setting", r.Setting)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleManagementPolicyApprovalRule.
func (r *RoleManagementPolicyApprovalRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "setting":
			err = unpopulate(val, &r.Setting)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.RoleManagementPolicyRule.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RoleManagementPolicyAssignment - Role management policy
type RoleManagementPolicyAssignment struct {
	// Role management policy properties.
	Properties *RoleManagementPolicyAssignmentProperties `json:"properties,omitempty"`

	// READ-ONLY; The role management policy Id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The role management policy name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The role management policy type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RoleManagementPolicyAssignmentListResult - Role management policy assignment list operation result.
type RoleManagementPolicyAssignmentListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Role management policy assignment list.
	Value []*RoleManagementPolicyAssignment `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleManagementPolicyAssignmentListResult.
func (r RoleManagementPolicyAssignmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoleManagementPolicyAssignmentProperties - Role management policy assignment properties with scope.
type RoleManagementPolicyAssignmentProperties struct {
	// The policy id role management policy assignment.
	PolicyID *string `json:"policyId,omitempty"`

	// The role definition of management policy assignment.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// The role management policy scope.
	Scope *string `json:"scope,omitempty"`

	// READ-ONLY; Additional properties of scope, role definition and policy
	PolicyAssignmentProperties *PolicyAssignmentProperties `json:"policyAssignmentProperties,omitempty" azure:"ro"`
}

// RoleManagementPolicyAssignmentsCreateOptions contains the optional parameters for the RoleManagementPolicyAssignments.Create method.
type RoleManagementPolicyAssignmentsCreateOptions struct {
	// placeholder for future optional parameters
}

// RoleManagementPolicyAssignmentsDeleteOptions contains the optional parameters for the RoleManagementPolicyAssignments.Delete method.
type RoleManagementPolicyAssignmentsDeleteOptions struct {
	// placeholder for future optional parameters
}

// RoleManagementPolicyAssignmentsGetOptions contains the optional parameters for the RoleManagementPolicyAssignments.Get method.
type RoleManagementPolicyAssignmentsGetOptions struct {
	// placeholder for future optional parameters
}

// RoleManagementPolicyAssignmentsListForScopeOptions contains the optional parameters for the RoleManagementPolicyAssignments.ListForScope method.
type RoleManagementPolicyAssignmentsListForScopeOptions struct {
	// placeholder for future optional parameters
}

// RoleManagementPolicyAuthenticationContextRule - The role management policy rule.
type RoleManagementPolicyAuthenticationContextRule struct {
	RoleManagementPolicyRule
	// The claim value.
	ClaimValue *string `json:"claimValue,omitempty"`

	// The value indicating if rule is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleManagementPolicyAuthenticationContextRule.
func (r RoleManagementPolicyAuthenticationContextRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.RoleManagementPolicyRule.marshalInternal(objectMap, RoleManagementPolicyRuleTypeRoleManagementPolicyAuthenticationContextRule)
	populate(objectMap, "claimValue", r.ClaimValue)
	populate(objectMap, "isEnabled", r.IsEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleManagementPolicyAuthenticationContextRule.
func (r *RoleManagementPolicyAuthenticationContextRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "claimValue":
			err = unpopulate(val, &r.ClaimValue)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, &r.IsEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.RoleManagementPolicyRule.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RoleManagementPolicyEnablementRule - The role management policy rule.
type RoleManagementPolicyEnablementRule struct {
	RoleManagementPolicyRule
	// The list of enabled rules.
	EnabledRules []*EnablementRules `json:"enabledRules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleManagementPolicyEnablementRule.
func (r RoleManagementPolicyEnablementRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.RoleManagementPolicyRule.marshalInternal(objectMap, RoleManagementPolicyRuleTypeRoleManagementPolicyEnablementRule)
	populate(objectMap, "enabledRules", r.EnabledRules)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleManagementPolicyEnablementRule.
func (r *RoleManagementPolicyEnablementRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enabledRules":
			err = unpopulate(val, &r.EnabledRules)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.RoleManagementPolicyRule.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RoleManagementPolicyExpirationRule - The role management policy rule.
type RoleManagementPolicyExpirationRule struct {
	RoleManagementPolicyRule
	// The value indicating whether expiration is required.
	IsExpirationRequired *bool `json:"isExpirationRequired,omitempty"`

	// The maximum duration of expiration in timespan.
	MaximumDuration *string `json:"maximumDuration,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleManagementPolicyExpirationRule.
func (r RoleManagementPolicyExpirationRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.RoleManagementPolicyRule.marshalInternal(objectMap, RoleManagementPolicyRuleTypeRoleManagementPolicyExpirationRule)
	populate(objectMap, "isExpirationRequired", r.IsExpirationRequired)
	populate(objectMap, "maximumDuration", r.MaximumDuration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleManagementPolicyExpirationRule.
func (r *RoleManagementPolicyExpirationRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isExpirationRequired":
			err = unpopulate(val, &r.IsExpirationRequired)
			delete(rawMsg, key)
		case "maximumDuration":
			err = unpopulate(val, &r.MaximumDuration)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.RoleManagementPolicyRule.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RoleManagementPolicyListResult - Role management policy list operation result.
type RoleManagementPolicyListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Role management policy list.
	Value []*RoleManagementPolicy `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleManagementPolicyListResult.
func (r RoleManagementPolicyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoleManagementPolicyNotificationRule - The role management policy rule.
type RoleManagementPolicyNotificationRule struct {
	RoleManagementPolicyRule
	// Its value determine if the notification need to be sent to the recipient type specified in policy rule.
	IsDefaultRecipientsEnabled *bool `json:"isDefaultRecipientsEnabled,omitempty"`

	// The notification level.
	NotificationLevel *NotificationLevel `json:"notificationLevel,omitempty"`

	// The list notification recipients.
	NotificationRecipients []*string `json:"notificationRecipients,omitempty"`

	// The type of notification.
	NotificationType *NotificationDeliveryMechanism `json:"notificationType,omitempty"`

	// The recipient type.
	RecipientType *RecipientType `json:"recipientType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleManagementPolicyNotificationRule.
func (r RoleManagementPolicyNotificationRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.RoleManagementPolicyRule.marshalInternal(objectMap, RoleManagementPolicyRuleTypeRoleManagementPolicyNotificationRule)
	populate(objectMap, "isDefaultRecipientsEnabled", r.IsDefaultRecipientsEnabled)
	populate(objectMap, "notificationLevel", r.NotificationLevel)
	populate(objectMap, "notificationRecipients", r.NotificationRecipients)
	populate(objectMap, "notificationType", r.NotificationType)
	populate(objectMap, "recipientType", r.RecipientType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleManagementPolicyNotificationRule.
func (r *RoleManagementPolicyNotificationRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isDefaultRecipientsEnabled":
			err = unpopulate(val, &r.IsDefaultRecipientsEnabled)
			delete(rawMsg, key)
		case "notificationLevel":
			err = unpopulate(val, &r.NotificationLevel)
			delete(rawMsg, key)
		case "notificationRecipients":
			err = unpopulate(val, &r.NotificationRecipients)
			delete(rawMsg, key)
		case "notificationType":
			err = unpopulate(val, &r.NotificationType)
			delete(rawMsg, key)
		case "recipientType":
			err = unpopulate(val, &r.RecipientType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.RoleManagementPolicyRule.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RoleManagementPolicyProperties - Role management policy properties with scope.
type RoleManagementPolicyProperties struct {
	// The role management policy description.
	Description *string `json:"description,omitempty"`

	// The role management policy display name.
	DisplayName *string `json:"displayName,omitempty"`

	// The role management policy is default policy.
	IsOrganizationDefault *bool `json:"isOrganizationDefault,omitempty"`

	// The rule applied to the policy.
	Rules []RoleManagementPolicyRuleClassification `json:"rules,omitempty"`

	// The role management policy scope.
	Scope *string `json:"scope,omitempty"`

	// READ-ONLY; The readonly computed rule applied to the policy.
	EffectiveRules []RoleManagementPolicyRuleClassification `json:"effectiveRules,omitempty" azure:"ro"`

	// READ-ONLY; The name of the entity last modified it
	LastModifiedBy *Principal `json:"lastModifiedBy,omitempty" azure:"ro"`

	// READ-ONLY; The last modified date time.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty" azure:"ro"`

	// READ-ONLY; Additional properties of scope
	PolicyProperties *PolicyProperties `json:"policyProperties,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleManagementPolicyProperties.
func (r RoleManagementPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", r.Description)
	populate(objectMap, "displayName", r.DisplayName)
	populate(objectMap, "effectiveRules", r.EffectiveRules)
	populate(objectMap, "isOrganizationDefault", r.IsOrganizationDefault)
	populate(objectMap, "lastModifiedBy", r.LastModifiedBy)
	populateTimeRFC3339(objectMap, "lastModifiedDateTime", r.LastModifiedDateTime)
	populate(objectMap, "policyProperties", r.PolicyProperties)
	populate(objectMap, "rules", r.Rules)
	populate(objectMap, "scope", r.Scope)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleManagementPolicyProperties.
func (r *RoleManagementPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &r.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &r.DisplayName)
			delete(rawMsg, key)
		case "effectiveRules":
			r.EffectiveRules, err = unmarshalRoleManagementPolicyRuleClassificationArray(val)
			delete(rawMsg, key)
		case "isOrganizationDefault":
			err = unpopulate(val, &r.IsOrganizationDefault)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &r.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedDateTime":
			err = unpopulateTimeRFC3339(val, &r.LastModifiedDateTime)
			delete(rawMsg, key)
		case "policyProperties":
			err = unpopulate(val, &r.PolicyProperties)
			delete(rawMsg, key)
		case "rules":
			r.Rules, err = unmarshalRoleManagementPolicyRuleClassificationArray(val)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &r.Scope)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleManagementPolicyRuleClassification provides polymorphic access to related types.
// Call the interface's GetRoleManagementPolicyRule() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *RoleManagementPolicyApprovalRule, *RoleManagementPolicyAuthenticationContextRule, *RoleManagementPolicyEnablementRule,
// - *RoleManagementPolicyExpirationRule, *RoleManagementPolicyNotificationRule, *RoleManagementPolicyRule
type RoleManagementPolicyRuleClassification interface {
	// GetRoleManagementPolicyRule returns the RoleManagementPolicyRule content of the underlying type.
	GetRoleManagementPolicyRule() *RoleManagementPolicyRule
}

// RoleManagementPolicyRule - The role management policy rule.
type RoleManagementPolicyRule struct {
	// REQUIRED; The type of rule
	RuleType *RoleManagementPolicyRuleType `json:"ruleType,omitempty"`

	// The id of the rule.
	ID *string `json:"id,omitempty"`

	// The target of the current rule.
	Target *RoleManagementPolicyRuleTarget `json:"target,omitempty"`
}

// GetRoleManagementPolicyRule implements the RoleManagementPolicyRuleClassification interface for type RoleManagementPolicyRule.
func (r *RoleManagementPolicyRule) GetRoleManagementPolicyRule() *RoleManagementPolicyRule { return r }

// UnmarshalJSON implements the json.Unmarshaller interface for type RoleManagementPolicyRule.
func (r *RoleManagementPolicyRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r RoleManagementPolicyRule) marshalInternal(objectMap map[string]interface{}, discValue RoleManagementPolicyRuleType) {
	populate(objectMap, "id", r.ID)
	r.RuleType = &discValue
	objectMap["ruleType"] = r.RuleType
	populate(objectMap, "target", r.Target)
}

func (r *RoleManagementPolicyRule) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &r.ID)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, &r.RuleType)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &r.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RoleManagementPolicyRuleTarget - The role management policy rule target.
type RoleManagementPolicyRuleTarget struct {
	// The caller of the setting.
	Caller *string `json:"caller,omitempty"`

	// The list of enforced settings.
	EnforcedSettings []*string `json:"enforcedSettings,omitempty"`

	// The list of inheritable settings.
	InheritableSettings []*string `json:"inheritableSettings,omitempty"`

	// The assignment level to which it is applied.
	Level *string `json:"level,omitempty"`

	// The type of operation.
	Operations []*string `json:"operations,omitempty"`

	// The list of target objects.
	TargetObjects []*string `json:"targetObjects,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleManagementPolicyRuleTarget.
func (r RoleManagementPolicyRuleTarget) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "caller", r.Caller)
	populate(objectMap, "enforcedSettings", r.EnforcedSettings)
	populate(objectMap, "inheritableSettings", r.InheritableSettings)
	populate(objectMap, "level", r.Level)
	populate(objectMap, "operations", r.Operations)
	populate(objectMap, "targetObjects", r.TargetObjects)
	return json.Marshal(objectMap)
}

// ServicePrincipalDecisionTarget - Service Principal Decision Target
type ServicePrincipalDecisionTarget struct {
	AccessReviewDecisionTarget
	// READ-ONLY; The appId for the service principal entity being reviewed
	AppID *string `json:"appId,omitempty" azure:"ro"`

	// READ-ONLY; The id of service principal whose access is reviewed.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The display name of the service principal whose access was reviewed.
	PrincipalName *string `json:"principalName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ServicePrincipalDecisionTarget.
func (s ServicePrincipalDecisionTarget) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.AccessReviewDecisionTarget.marshalInternal(objectMap, DecisionTargetTypeServicePrincipal)
	populate(objectMap, "appId", s.AppID)
	populate(objectMap, "principalId", s.PrincipalID)
	populate(objectMap, "principalName", s.PrincipalName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePrincipalDecisionTarget.
func (s *ServicePrincipalDecisionTarget) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appId":
			err = unpopulate(val, &s.AppID)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, &s.PrincipalID)
			delete(rawMsg, key)
		case "principalName":
			err = unpopulate(val, &s.PrincipalName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.AccessReviewDecisionTarget.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// UserDecisionTarget - User Decision Target
type UserDecisionTarget struct {
	AccessReviewDecisionTarget
	// READ-ONLY; The id of user whose access was reviewed.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The display name of the user whose access was reviewed.
	PrincipalName *string `json:"principalName,omitempty" azure:"ro"`

	// READ-ONLY; The user principal name of the user whose access was reviewed.
	UserPrincipalName *string `json:"userPrincipalName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UserDecisionTarget.
func (u UserDecisionTarget) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.AccessReviewDecisionTarget.marshalInternal(objectMap, DecisionTargetTypeUser)
	populate(objectMap, "principalId", u.PrincipalID)
	populate(objectMap, "principalName", u.PrincipalName)
	populate(objectMap, "userPrincipalName", u.UserPrincipalName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserDecisionTarget.
func (u *UserDecisionTarget) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principalId":
			err = unpopulate(val, &u.PrincipalID)
			delete(rawMsg, key)
		case "principalName":
			err = unpopulate(val, &u.PrincipalName)
			delete(rawMsg, key)
		case "userPrincipalName":
			err = unpopulate(val, &u.UserPrincipalName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.AccessReviewDecisionTarget.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// UserSet - The detail of a user.
type UserSet struct {
	// The description of the user.
	Description *string `json:"description,omitempty"`

	// The object id of the user.
	ID *string `json:"id,omitempty"`

	// The value indicating whether the user is a backup fallback approver
	IsBackup *bool `json:"isBackup,omitempty"`

	// The type of user.
	UserType *UserType `json:"userType,omitempty"`
}

// ValidationResponse - Validation response
type ValidationResponse struct {
	// Failed validation result details
	ErrorInfo *ValidationResponseErrorInfo `json:"errorInfo,omitempty"`

	// READ-ONLY; Whether or not validation succeeded
	IsValid *bool `json:"isValid,omitempty" azure:"ro"`
}

// ValidationResponseErrorInfo - Failed validation result details
type ValidationResponseErrorInfo struct {
	// READ-ONLY; Error code indicating why validation failed
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; Message indicating why validation failed
	Message *string `json:"message,omitempty" azure:"ro"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
