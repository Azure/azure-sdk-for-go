//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armauthorization

import (
	"context"
	"net/http"
	"reflect"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// AccessReviewInstanceDecisionsListPager provides operations for iterating over paged responses.
type AccessReviewInstanceDecisionsListPager struct {
	client    *AccessReviewInstanceDecisionsClient
	current   AccessReviewInstanceDecisionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccessReviewInstanceDecisionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccessReviewInstanceDecisionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccessReviewInstanceDecisionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccessReviewDecisionListResult.NextLink == nil || len(*p.current.AccessReviewDecisionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccessReviewInstanceDecisionsListResponse page.
func (p *AccessReviewInstanceDecisionsListPager) PageResponse() AccessReviewInstanceDecisionsListResponse {
	return p.current
}

// AccessReviewInstanceMyDecisionsListPager provides operations for iterating over paged responses.
type AccessReviewInstanceMyDecisionsListPager struct {
	client    *AccessReviewInstanceMyDecisionsClient
	current   AccessReviewInstanceMyDecisionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccessReviewInstanceMyDecisionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccessReviewInstanceMyDecisionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccessReviewInstanceMyDecisionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccessReviewDecisionListResult.NextLink == nil || len(*p.current.AccessReviewDecisionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccessReviewInstanceMyDecisionsListResponse page.
func (p *AccessReviewInstanceMyDecisionsListPager) PageResponse() AccessReviewInstanceMyDecisionsListResponse {
	return p.current
}

// AccessReviewInstancesAssignedForMyApprovalListPager provides operations for iterating over paged responses.
type AccessReviewInstancesAssignedForMyApprovalListPager struct {
	client    *AccessReviewInstancesAssignedForMyApprovalClient
	current   AccessReviewInstancesAssignedForMyApprovalListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccessReviewInstancesAssignedForMyApprovalListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccessReviewInstancesAssignedForMyApprovalListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccessReviewInstancesAssignedForMyApprovalListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccessReviewInstanceListResult.NextLink == nil || len(*p.current.AccessReviewInstanceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccessReviewInstancesAssignedForMyApprovalListResponse page.
func (p *AccessReviewInstancesAssignedForMyApprovalListPager) PageResponse() AccessReviewInstancesAssignedForMyApprovalListResponse {
	return p.current
}

// AccessReviewInstancesListPager provides operations for iterating over paged responses.
type AccessReviewInstancesListPager struct {
	client    *AccessReviewInstancesClient
	current   AccessReviewInstancesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccessReviewInstancesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccessReviewInstancesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccessReviewInstancesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccessReviewInstanceListResult.NextLink == nil || len(*p.current.AccessReviewInstanceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccessReviewInstancesListResponse page.
func (p *AccessReviewInstancesListPager) PageResponse() AccessReviewInstancesListResponse {
	return p.current
}

// AccessReviewScheduleDefinitionsAssignedForMyApprovalListPager provides operations for iterating over paged responses.
type AccessReviewScheduleDefinitionsAssignedForMyApprovalListPager struct {
	client    *AccessReviewScheduleDefinitionsAssignedForMyApprovalClient
	current   AccessReviewScheduleDefinitionsAssignedForMyApprovalListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccessReviewScheduleDefinitionsAssignedForMyApprovalListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccessReviewScheduleDefinitionsAssignedForMyApprovalListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccessReviewScheduleDefinitionsAssignedForMyApprovalListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccessReviewScheduleDefinitionListResult.NextLink == nil || len(*p.current.AccessReviewScheduleDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccessReviewScheduleDefinitionsAssignedForMyApprovalListResponse page.
func (p *AccessReviewScheduleDefinitionsAssignedForMyApprovalListPager) PageResponse() AccessReviewScheduleDefinitionsAssignedForMyApprovalListResponse {
	return p.current
}

// AccessReviewScheduleDefinitionsListPager provides operations for iterating over paged responses.
type AccessReviewScheduleDefinitionsListPager struct {
	client    *AccessReviewScheduleDefinitionsClient
	current   AccessReviewScheduleDefinitionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccessReviewScheduleDefinitionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccessReviewScheduleDefinitionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccessReviewScheduleDefinitionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccessReviewScheduleDefinitionListResult.NextLink == nil || len(*p.current.AccessReviewScheduleDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccessReviewScheduleDefinitionsListResponse page.
func (p *AccessReviewScheduleDefinitionsListPager) PageResponse() AccessReviewScheduleDefinitionsListResponse {
	return p.current
}

// DenyAssignmentsListForResourceGroupPager provides operations for iterating over paged responses.
type DenyAssignmentsListForResourceGroupPager struct {
	client    *DenyAssignmentsClient
	current   DenyAssignmentsListForResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DenyAssignmentsListForResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DenyAssignmentsListForResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DenyAssignmentsListForResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DenyAssignmentListResult.NextLink == nil || len(*p.current.DenyAssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listForResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DenyAssignmentsListForResourceGroupResponse page.
func (p *DenyAssignmentsListForResourceGroupPager) PageResponse() DenyAssignmentsListForResourceGroupResponse {
	return p.current
}

// DenyAssignmentsListForResourcePager provides operations for iterating over paged responses.
type DenyAssignmentsListForResourcePager struct {
	client    *DenyAssignmentsClient
	current   DenyAssignmentsListForResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DenyAssignmentsListForResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DenyAssignmentsListForResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DenyAssignmentsListForResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DenyAssignmentListResult.NextLink == nil || len(*p.current.DenyAssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForResourceHandleError(resp)
		return false
	}
	result, err := p.client.listForResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DenyAssignmentsListForResourceResponse page.
func (p *DenyAssignmentsListForResourcePager) PageResponse() DenyAssignmentsListForResourceResponse {
	return p.current
}

// DenyAssignmentsListForScopePager provides operations for iterating over paged responses.
type DenyAssignmentsListForScopePager struct {
	client    *DenyAssignmentsClient
	current   DenyAssignmentsListForScopeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DenyAssignmentsListForScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DenyAssignmentsListForScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DenyAssignmentsListForScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DenyAssignmentListResult.NextLink == nil || len(*p.current.DenyAssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForScopeHandleError(resp)
		return false
	}
	result, err := p.client.listForScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DenyAssignmentsListForScopeResponse page.
func (p *DenyAssignmentsListForScopePager) PageResponse() DenyAssignmentsListForScopeResponse {
	return p.current
}

// DenyAssignmentsListPager provides operations for iterating over paged responses.
type DenyAssignmentsListPager struct {
	client    *DenyAssignmentsClient
	current   DenyAssignmentsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DenyAssignmentsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DenyAssignmentsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DenyAssignmentsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DenyAssignmentListResult.NextLink == nil || len(*p.current.DenyAssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DenyAssignmentsListResponse page.
func (p *DenyAssignmentsListPager) PageResponse() DenyAssignmentsListResponse {
	return p.current
}

// EligibleChildResourcesGetPager provides operations for iterating over paged responses.
type EligibleChildResourcesGetPager struct {
	client    *EligibleChildResourcesClient
	current   EligibleChildResourcesGetResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EligibleChildResourcesGetResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EligibleChildResourcesGetPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EligibleChildResourcesGetPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EligibleChildResourcesListResult.NextLink == nil || len(*p.current.EligibleChildResourcesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.getHandleError(resp)
		return false
	}
	result, err := p.client.getHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EligibleChildResourcesGetResponse page.
func (p *EligibleChildResourcesGetPager) PageResponse() EligibleChildResourcesGetResponse {
	return p.current
}

// OperationsListPager provides operations for iterating over paged responses.
type OperationsListPager struct {
	client    *OperationsClient
	current   OperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsListResponse page.
func (p *OperationsListPager) PageResponse() OperationsListResponse {
	return p.current
}

// PermissionsListForResourceGroupPager provides operations for iterating over paged responses.
type PermissionsListForResourceGroupPager struct {
	client    *PermissionsClient
	current   PermissionsListForResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PermissionsListForResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PermissionsListForResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PermissionsListForResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PermissionGetResult.NextLink == nil || len(*p.current.PermissionGetResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listForResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PermissionsListForResourceGroupResponse page.
func (p *PermissionsListForResourceGroupPager) PageResponse() PermissionsListForResourceGroupResponse {
	return p.current
}

// PermissionsListForResourcePager provides operations for iterating over paged responses.
type PermissionsListForResourcePager struct {
	client    *PermissionsClient
	current   PermissionsListForResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PermissionsListForResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PermissionsListForResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PermissionsListForResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PermissionGetResult.NextLink == nil || len(*p.current.PermissionGetResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForResourceHandleError(resp)
		return false
	}
	result, err := p.client.listForResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PermissionsListForResourceResponse page.
func (p *PermissionsListForResourcePager) PageResponse() PermissionsListForResourceResponse {
	return p.current
}

// ProviderOperationsMetadataListPager provides operations for iterating over paged responses.
type ProviderOperationsMetadataListPager struct {
	client    *ProviderOperationsMetadataClient
	current   ProviderOperationsMetadataListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProviderOperationsMetadataListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProviderOperationsMetadataListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProviderOperationsMetadataListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProviderOperationsMetadataListResult.NextLink == nil || len(*p.current.ProviderOperationsMetadataListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProviderOperationsMetadataListResponse page.
func (p *ProviderOperationsMetadataListPager) PageResponse() ProviderOperationsMetadataListResponse {
	return p.current
}

// RoleAssignmentScheduleInstancesListForScopePager provides operations for iterating over paged responses.
type RoleAssignmentScheduleInstancesListForScopePager struct {
	client    *RoleAssignmentScheduleInstancesClient
	current   RoleAssignmentScheduleInstancesListForScopeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentScheduleInstancesListForScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleAssignmentScheduleInstancesListForScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleAssignmentScheduleInstancesListForScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentScheduleInstanceListResult.NextLink == nil || len(*p.current.RoleAssignmentScheduleInstanceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForScopeHandleError(resp)
		return false
	}
	result, err := p.client.listForScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleAssignmentScheduleInstancesListForScopeResponse page.
func (p *RoleAssignmentScheduleInstancesListForScopePager) PageResponse() RoleAssignmentScheduleInstancesListForScopeResponse {
	return p.current
}

// RoleAssignmentScheduleRequestsListForScopePager provides operations for iterating over paged responses.
type RoleAssignmentScheduleRequestsListForScopePager struct {
	client    *RoleAssignmentScheduleRequestsClient
	current   RoleAssignmentScheduleRequestsListForScopeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentScheduleRequestsListForScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleAssignmentScheduleRequestsListForScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleAssignmentScheduleRequestsListForScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentScheduleRequestListResult.NextLink == nil || len(*p.current.RoleAssignmentScheduleRequestListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForScopeHandleError(resp)
		return false
	}
	result, err := p.client.listForScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleAssignmentScheduleRequestsListForScopeResponse page.
func (p *RoleAssignmentScheduleRequestsListForScopePager) PageResponse() RoleAssignmentScheduleRequestsListForScopeResponse {
	return p.current
}

// RoleAssignmentSchedulesListForScopePager provides operations for iterating over paged responses.
type RoleAssignmentSchedulesListForScopePager struct {
	client    *RoleAssignmentSchedulesClient
	current   RoleAssignmentSchedulesListForScopeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentSchedulesListForScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleAssignmentSchedulesListForScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleAssignmentSchedulesListForScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentScheduleListResult.NextLink == nil || len(*p.current.RoleAssignmentScheduleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForScopeHandleError(resp)
		return false
	}
	result, err := p.client.listForScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleAssignmentSchedulesListForScopeResponse page.
func (p *RoleAssignmentSchedulesListForScopePager) PageResponse() RoleAssignmentSchedulesListForScopeResponse {
	return p.current
}

// RoleAssignmentsListForResourceGroupPager provides operations for iterating over paged responses.
type RoleAssignmentsListForResourceGroupPager struct {
	client    *RoleAssignmentsClient
	current   RoleAssignmentsListForResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentsListForResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleAssignmentsListForResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleAssignmentsListForResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentListResult.NextLink == nil || len(*p.current.RoleAssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listForResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleAssignmentsListForResourceGroupResponse page.
func (p *RoleAssignmentsListForResourceGroupPager) PageResponse() RoleAssignmentsListForResourceGroupResponse {
	return p.current
}

// RoleAssignmentsListForResourcePager provides operations for iterating over paged responses.
type RoleAssignmentsListForResourcePager struct {
	client    *RoleAssignmentsClient
	current   RoleAssignmentsListForResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentsListForResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleAssignmentsListForResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleAssignmentsListForResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentListResult.NextLink == nil || len(*p.current.RoleAssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForResourceHandleError(resp)
		return false
	}
	result, err := p.client.listForResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleAssignmentsListForResourceResponse page.
func (p *RoleAssignmentsListForResourcePager) PageResponse() RoleAssignmentsListForResourceResponse {
	return p.current
}

// RoleAssignmentsListForScopePager provides operations for iterating over paged responses.
type RoleAssignmentsListForScopePager struct {
	client    *RoleAssignmentsClient
	current   RoleAssignmentsListForScopeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentsListForScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleAssignmentsListForScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleAssignmentsListForScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentListResult.NextLink == nil || len(*p.current.RoleAssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForScopeHandleError(resp)
		return false
	}
	result, err := p.client.listForScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleAssignmentsListForScopeResponse page.
func (p *RoleAssignmentsListForScopePager) PageResponse() RoleAssignmentsListForScopeResponse {
	return p.current
}

// RoleAssignmentsListForSubscriptionPager provides operations for iterating over paged responses.
type RoleAssignmentsListForSubscriptionPager struct {
	client    *RoleAssignmentsClient
	current   RoleAssignmentsListForSubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentsListForSubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleAssignmentsListForSubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleAssignmentsListForSubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentListResult.NextLink == nil || len(*p.current.RoleAssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForSubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listForSubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleAssignmentsListForSubscriptionResponse page.
func (p *RoleAssignmentsListForSubscriptionPager) PageResponse() RoleAssignmentsListForSubscriptionResponse {
	return p.current
}

// RoleDefinitionsListPager provides operations for iterating over paged responses.
type RoleDefinitionsListPager struct {
	client    *RoleDefinitionsClient
	current   RoleDefinitionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleDefinitionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleDefinitionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleDefinitionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleDefinitionListResult.NextLink == nil || len(*p.current.RoleDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleDefinitionsListResponse page.
func (p *RoleDefinitionsListPager) PageResponse() RoleDefinitionsListResponse {
	return p.current
}

// RoleEligibilityScheduleInstancesListForScopePager provides operations for iterating over paged responses.
type RoleEligibilityScheduleInstancesListForScopePager struct {
	client    *RoleEligibilityScheduleInstancesClient
	current   RoleEligibilityScheduleInstancesListForScopeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleEligibilityScheduleInstancesListForScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleEligibilityScheduleInstancesListForScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleEligibilityScheduleInstancesListForScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleEligibilityScheduleInstanceListResult.NextLink == nil || len(*p.current.RoleEligibilityScheduleInstanceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForScopeHandleError(resp)
		return false
	}
	result, err := p.client.listForScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleEligibilityScheduleInstancesListForScopeResponse page.
func (p *RoleEligibilityScheduleInstancesListForScopePager) PageResponse() RoleEligibilityScheduleInstancesListForScopeResponse {
	return p.current
}

// RoleEligibilityScheduleRequestsListForScopePager provides operations for iterating over paged responses.
type RoleEligibilityScheduleRequestsListForScopePager struct {
	client    *RoleEligibilityScheduleRequestsClient
	current   RoleEligibilityScheduleRequestsListForScopeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleEligibilityScheduleRequestsListForScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleEligibilityScheduleRequestsListForScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleEligibilityScheduleRequestsListForScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleEligibilityScheduleRequestListResult.NextLink == nil || len(*p.current.RoleEligibilityScheduleRequestListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForScopeHandleError(resp)
		return false
	}
	result, err := p.client.listForScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleEligibilityScheduleRequestsListForScopeResponse page.
func (p *RoleEligibilityScheduleRequestsListForScopePager) PageResponse() RoleEligibilityScheduleRequestsListForScopeResponse {
	return p.current
}

// RoleEligibilitySchedulesListForScopePager provides operations for iterating over paged responses.
type RoleEligibilitySchedulesListForScopePager struct {
	client    *RoleEligibilitySchedulesClient
	current   RoleEligibilitySchedulesListForScopeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleEligibilitySchedulesListForScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleEligibilitySchedulesListForScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleEligibilitySchedulesListForScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleEligibilityScheduleListResult.NextLink == nil || len(*p.current.RoleEligibilityScheduleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForScopeHandleError(resp)
		return false
	}
	result, err := p.client.listForScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleEligibilitySchedulesListForScopeResponse page.
func (p *RoleEligibilitySchedulesListForScopePager) PageResponse() RoleEligibilitySchedulesListForScopeResponse {
	return p.current
}

// RoleManagementPoliciesListForScopePager provides operations for iterating over paged responses.
type RoleManagementPoliciesListForScopePager struct {
	client    *RoleManagementPoliciesClient
	current   RoleManagementPoliciesListForScopeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleManagementPoliciesListForScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleManagementPoliciesListForScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleManagementPoliciesListForScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleManagementPolicyListResult.NextLink == nil || len(*p.current.RoleManagementPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForScopeHandleError(resp)
		return false
	}
	result, err := p.client.listForScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleManagementPoliciesListForScopeResponse page.
func (p *RoleManagementPoliciesListForScopePager) PageResponse() RoleManagementPoliciesListForScopeResponse {
	return p.current
}

// RoleManagementPolicyAssignmentsListForScopePager provides operations for iterating over paged responses.
type RoleManagementPolicyAssignmentsListForScopePager struct {
	client    *RoleManagementPolicyAssignmentsClient
	current   RoleManagementPolicyAssignmentsListForScopeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleManagementPolicyAssignmentsListForScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleManagementPolicyAssignmentsListForScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleManagementPolicyAssignmentsListForScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleManagementPolicyAssignmentListResult.NextLink == nil || len(*p.current.RoleManagementPolicyAssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listForScopeHandleError(resp)
		return false
	}
	result, err := p.client.listForScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleManagementPolicyAssignmentsListForScopeResponse page.
func (p *RoleManagementPolicyAssignmentsListForScopePager) PageResponse() RoleManagementPolicyAssignmentsListForScopeResponse {
	return p.current
}
