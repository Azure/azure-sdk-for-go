//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armautomation

import (
	"context"
	"net/http"
	"reflect"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// ActivityListByModulePager provides operations for iterating over paged responses.
type ActivityListByModulePager struct {
	client    *ActivityClient
	current   ActivityListByModuleResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ActivityListByModuleResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ActivityListByModulePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ActivityListByModulePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ActivityListResult.NextLink == nil || len(*p.current.ActivityListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByModuleHandleError(resp)
		return false
	}
	result, err := p.client.listByModuleHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ActivityListByModuleResponse page.
func (p *ActivityListByModulePager) PageResponse() ActivityListByModuleResponse {
	return p.current
}

// AutomationAccountListByResourceGroupPager provides operations for iterating over paged responses.
type AutomationAccountListByResourceGroupPager struct {
	client    *AutomationAccountClient
	current   AutomationAccountListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AutomationAccountListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AutomationAccountListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AutomationAccountListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutomationAccountListResult.NextLink == nil || len(*p.current.AutomationAccountListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AutomationAccountListByResourceGroupResponse page.
func (p *AutomationAccountListByResourceGroupPager) PageResponse() AutomationAccountListByResourceGroupResponse {
	return p.current
}

// AutomationAccountListPager provides operations for iterating over paged responses.
type AutomationAccountListPager struct {
	client    *AutomationAccountClient
	current   AutomationAccountListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AutomationAccountListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AutomationAccountListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AutomationAccountListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutomationAccountListResult.NextLink == nil || len(*p.current.AutomationAccountListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AutomationAccountListResponse page.
func (p *AutomationAccountListPager) PageResponse() AutomationAccountListResponse {
	return p.current
}

// CertificateListByAutomationAccountPager provides operations for iterating over paged responses.
type CertificateListByAutomationAccountPager struct {
	client    *CertificateClient
	current   CertificateListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CertificateListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CertificateListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CertificateListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CertificateListResult.NextLink == nil || len(*p.current.CertificateListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CertificateListByAutomationAccountResponse page.
func (p *CertificateListByAutomationAccountPager) PageResponse() CertificateListByAutomationAccountResponse {
	return p.current
}

// ConnectionListByAutomationAccountPager provides operations for iterating over paged responses.
type ConnectionListByAutomationAccountPager struct {
	client    *ConnectionClient
	current   ConnectionListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConnectionListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ConnectionListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ConnectionListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectionListResult.NextLink == nil || len(*p.current.ConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ConnectionListByAutomationAccountResponse page.
func (p *ConnectionListByAutomationAccountPager) PageResponse() ConnectionListByAutomationAccountResponse {
	return p.current
}

// ConnectionTypeListByAutomationAccountPager provides operations for iterating over paged responses.
type ConnectionTypeListByAutomationAccountPager struct {
	client    *ConnectionTypeClient
	current   ConnectionTypeListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConnectionTypeListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ConnectionTypeListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ConnectionTypeListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectionTypeListResult.NextLink == nil || len(*p.current.ConnectionTypeListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ConnectionTypeListByAutomationAccountResponse page.
func (p *ConnectionTypeListByAutomationAccountPager) PageResponse() ConnectionTypeListByAutomationAccountResponse {
	return p.current
}

// CredentialListByAutomationAccountPager provides operations for iterating over paged responses.
type CredentialListByAutomationAccountPager struct {
	client    *CredentialClient
	current   CredentialListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CredentialListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CredentialListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CredentialListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CredentialListResult.NextLink == nil || len(*p.current.CredentialListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CredentialListByAutomationAccountResponse page.
func (p *CredentialListByAutomationAccountPager) PageResponse() CredentialListByAutomationAccountResponse {
	return p.current
}

// DscCompilationJobListByAutomationAccountPager provides operations for iterating over paged responses.
type DscCompilationJobListByAutomationAccountPager struct {
	client    *DscCompilationJobClient
	current   DscCompilationJobListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DscCompilationJobListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DscCompilationJobListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DscCompilationJobListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscCompilationJobListResult.NextLink == nil || len(*p.current.DscCompilationJobListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DscCompilationJobListByAutomationAccountResponse page.
func (p *DscCompilationJobListByAutomationAccountPager) PageResponse() DscCompilationJobListByAutomationAccountResponse {
	return p.current
}

// DscConfigurationListByAutomationAccountPager provides operations for iterating over paged responses.
type DscConfigurationListByAutomationAccountPager struct {
	client    *DscConfigurationClient
	current   DscConfigurationListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DscConfigurationListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DscConfigurationListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DscConfigurationListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscConfigurationListResult.NextLink == nil || len(*p.current.DscConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DscConfigurationListByAutomationAccountResponse page.
func (p *DscConfigurationListByAutomationAccountPager) PageResponse() DscConfigurationListByAutomationAccountResponse {
	return p.current
}

// DscNodeConfigurationListByAutomationAccountPager provides operations for iterating over paged responses.
type DscNodeConfigurationListByAutomationAccountPager struct {
	client    *DscNodeConfigurationClient
	current   DscNodeConfigurationListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DscNodeConfigurationListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DscNodeConfigurationListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DscNodeConfigurationListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscNodeConfigurationListResult.NextLink == nil || len(*p.current.DscNodeConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DscNodeConfigurationListByAutomationAccountResponse page.
func (p *DscNodeConfigurationListByAutomationAccountPager) PageResponse() DscNodeConfigurationListByAutomationAccountResponse {
	return p.current
}

// DscNodeListByAutomationAccountPager provides operations for iterating over paged responses.
type DscNodeListByAutomationAccountPager struct {
	client    *DscNodeClient
	current   DscNodeListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DscNodeListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DscNodeListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DscNodeListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscNodeListResult.NextLink == nil || len(*p.current.DscNodeListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DscNodeListByAutomationAccountResponse page.
func (p *DscNodeListByAutomationAccountPager) PageResponse() DscNodeListByAutomationAccountResponse {
	return p.current
}

// HybridRunbookWorkerGroupListByAutomationAccountPager provides operations for iterating over paged responses.
type HybridRunbookWorkerGroupListByAutomationAccountPager struct {
	client    *HybridRunbookWorkerGroupClient
	current   HybridRunbookWorkerGroupListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, HybridRunbookWorkerGroupListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *HybridRunbookWorkerGroupListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *HybridRunbookWorkerGroupListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.HybridRunbookWorkerGroupsListResult.NextLink == nil || len(*p.current.HybridRunbookWorkerGroupsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current HybridRunbookWorkerGroupListByAutomationAccountResponse page.
func (p *HybridRunbookWorkerGroupListByAutomationAccountPager) PageResponse() HybridRunbookWorkerGroupListByAutomationAccountResponse {
	return p.current
}

// HybridRunbookWorkersListByHybridRunbookWorkerGroupPager provides operations for iterating over paged responses.
type HybridRunbookWorkersListByHybridRunbookWorkerGroupPager struct {
	client    *HybridRunbookWorkersClient
	current   HybridRunbookWorkersListByHybridRunbookWorkerGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, HybridRunbookWorkersListByHybridRunbookWorkerGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *HybridRunbookWorkersListByHybridRunbookWorkerGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *HybridRunbookWorkersListByHybridRunbookWorkerGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.HybridRunbookWorkersListResult.NextLink == nil || len(*p.current.HybridRunbookWorkersListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByHybridRunbookWorkerGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByHybridRunbookWorkerGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current HybridRunbookWorkersListByHybridRunbookWorkerGroupResponse page.
func (p *HybridRunbookWorkersListByHybridRunbookWorkerGroupPager) PageResponse() HybridRunbookWorkersListByHybridRunbookWorkerGroupResponse {
	return p.current
}

// JobListByAutomationAccountPager provides operations for iterating over paged responses.
type JobListByAutomationAccountPager struct {
	client    *JobClient
	current   JobListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobListResultV2.NextLink == nil || len(*p.current.JobListResultV2.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobListByAutomationAccountResponse page.
func (p *JobListByAutomationAccountPager) PageResponse() JobListByAutomationAccountResponse {
	return p.current
}

// JobScheduleListByAutomationAccountPager provides operations for iterating over paged responses.
type JobScheduleListByAutomationAccountPager struct {
	client    *JobScheduleClient
	current   JobScheduleListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobScheduleListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobScheduleListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobScheduleListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobScheduleListResult.NextLink == nil || len(*p.current.JobScheduleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobScheduleListByAutomationAccountResponse page.
func (p *JobScheduleListByAutomationAccountPager) PageResponse() JobScheduleListByAutomationAccountResponse {
	return p.current
}

// JobStreamListByJobPager provides operations for iterating over paged responses.
type JobStreamListByJobPager struct {
	client    *JobStreamClient
	current   JobStreamListByJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobStreamListByJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobStreamListByJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobStreamListByJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobStreamListResult.NextLink == nil || len(*p.current.JobStreamListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByJobHandleError(resp)
		return false
	}
	result, err := p.client.listByJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobStreamListByJobResponse page.
func (p *JobStreamListByJobPager) PageResponse() JobStreamListByJobResponse {
	return p.current
}

// ModuleListByAutomationAccountPager provides operations for iterating over paged responses.
type ModuleListByAutomationAccountPager struct {
	client    *ModuleClient
	current   ModuleListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ModuleListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ModuleListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ModuleListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ModuleListResult.NextLink == nil || len(*p.current.ModuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ModuleListByAutomationAccountResponse page.
func (p *ModuleListByAutomationAccountPager) PageResponse() ModuleListByAutomationAccountResponse {
	return p.current
}

// NodeReportsListByNodePager provides operations for iterating over paged responses.
type NodeReportsListByNodePager struct {
	client    *NodeReportsClient
	current   NodeReportsListByNodeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NodeReportsListByNodeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NodeReportsListByNodePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NodeReportsListByNodePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscNodeReportListResult.NextLink == nil || len(*p.current.DscNodeReportListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByNodeHandleError(resp)
		return false
	}
	result, err := p.client.listByNodeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NodeReportsListByNodeResponse page.
func (p *NodeReportsListByNodePager) PageResponse() NodeReportsListByNodeResponse {
	return p.current
}

// Python2PackageListByAutomationAccountPager provides operations for iterating over paged responses.
type Python2PackageListByAutomationAccountPager struct {
	client    *Python2PackageClient
	current   Python2PackageListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, Python2PackageListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *Python2PackageListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *Python2PackageListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ModuleListResult.NextLink == nil || len(*p.current.ModuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current Python2PackageListByAutomationAccountResponse page.
func (p *Python2PackageListByAutomationAccountPager) PageResponse() Python2PackageListByAutomationAccountResponse {
	return p.current
}

// RunbookListByAutomationAccountPager provides operations for iterating over paged responses.
type RunbookListByAutomationAccountPager struct {
	client    *RunbookClient
	current   RunbookListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RunbookListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RunbookListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RunbookListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RunbookListResult.NextLink == nil || len(*p.current.RunbookListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RunbookListByAutomationAccountResponse page.
func (p *RunbookListByAutomationAccountPager) PageResponse() RunbookListByAutomationAccountResponse {
	return p.current
}

// ScheduleListByAutomationAccountPager provides operations for iterating over paged responses.
type ScheduleListByAutomationAccountPager struct {
	client    *ScheduleClient
	current   ScheduleListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ScheduleListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ScheduleListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ScheduleListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleListResult.NextLink == nil || len(*p.current.ScheduleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ScheduleListByAutomationAccountResponse page.
func (p *ScheduleListByAutomationAccountPager) PageResponse() ScheduleListByAutomationAccountResponse {
	return p.current
}

// SourceControlListByAutomationAccountPager provides operations for iterating over paged responses.
type SourceControlListByAutomationAccountPager struct {
	client    *SourceControlClient
	current   SourceControlListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SourceControlListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SourceControlListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SourceControlListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SourceControlListResult.NextLink == nil || len(*p.current.SourceControlListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SourceControlListByAutomationAccountResponse page.
func (p *SourceControlListByAutomationAccountPager) PageResponse() SourceControlListByAutomationAccountResponse {
	return p.current
}

// SourceControlSyncJobListByAutomationAccountPager provides operations for iterating over paged responses.
type SourceControlSyncJobListByAutomationAccountPager struct {
	client    *SourceControlSyncJobClient
	current   SourceControlSyncJobListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SourceControlSyncJobListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SourceControlSyncJobListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SourceControlSyncJobListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SourceControlSyncJobListResult.NextLink == nil || len(*p.current.SourceControlSyncJobListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SourceControlSyncJobListByAutomationAccountResponse page.
func (p *SourceControlSyncJobListByAutomationAccountPager) PageResponse() SourceControlSyncJobListByAutomationAccountResponse {
	return p.current
}

// SourceControlSyncJobStreamsListBySyncJobPager provides operations for iterating over paged responses.
type SourceControlSyncJobStreamsListBySyncJobPager struct {
	client    *SourceControlSyncJobStreamsClient
	current   SourceControlSyncJobStreamsListBySyncJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SourceControlSyncJobStreamsListBySyncJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SourceControlSyncJobStreamsListBySyncJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SourceControlSyncJobStreamsListBySyncJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SourceControlSyncJobStreamsListBySyncJob.NextLink == nil || len(*p.current.SourceControlSyncJobStreamsListBySyncJob.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySyncJobHandleError(resp)
		return false
	}
	result, err := p.client.listBySyncJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SourceControlSyncJobStreamsListBySyncJobResponse page.
func (p *SourceControlSyncJobStreamsListBySyncJobPager) PageResponse() SourceControlSyncJobStreamsListBySyncJobResponse {
	return p.current
}

// TestJobStreamsListByTestJobPager provides operations for iterating over paged responses.
type TestJobStreamsListByTestJobPager struct {
	client    *TestJobStreamsClient
	current   TestJobStreamsListByTestJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TestJobStreamsListByTestJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TestJobStreamsListByTestJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TestJobStreamsListByTestJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobStreamListResult.NextLink == nil || len(*p.current.JobStreamListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByTestJobHandleError(resp)
		return false
	}
	result, err := p.client.listByTestJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TestJobStreamsListByTestJobResponse page.
func (p *TestJobStreamsListByTestJobPager) PageResponse() TestJobStreamsListByTestJobResponse {
	return p.current
}

// VariableListByAutomationAccountPager provides operations for iterating over paged responses.
type VariableListByAutomationAccountPager struct {
	client    *VariableClient
	current   VariableListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VariableListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VariableListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VariableListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VariableListResult.NextLink == nil || len(*p.current.VariableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VariableListByAutomationAccountResponse page.
func (p *VariableListByAutomationAccountPager) PageResponse() VariableListByAutomationAccountResponse {
	return p.current
}

// WatcherListByAutomationAccountPager provides operations for iterating over paged responses.
type WatcherListByAutomationAccountPager struct {
	client    *WatcherClient
	current   WatcherListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WatcherListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WatcherListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WatcherListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WatcherListResult.NextLink == nil || len(*p.current.WatcherListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WatcherListByAutomationAccountResponse page.
func (p *WatcherListByAutomationAccountPager) PageResponse() WatcherListByAutomationAccountResponse {
	return p.current
}

// WebhookListByAutomationAccountPager provides operations for iterating over paged responses.
type WebhookListByAutomationAccountPager struct {
	client    *WebhookClient
	current   WebhookListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebhookListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebhookListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebhookListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebhookListResult.NextLink == nil || len(*p.current.WebhookListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAutomationAccountHandleError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebhookListByAutomationAccountResponse page.
func (p *WebhookListByAutomationAccountPager) PageResponse() WebhookListByAutomationAccountResponse {
	return p.current
}
