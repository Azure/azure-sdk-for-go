//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armautomation

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AccountClientListByResourceGroupPager provides operations for iterating over paged responses.
type AccountClientListByResourceGroupPager struct {
	client    *AccountClient
	current   AccountClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccountClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccountClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccountListResult.NextLink == nil || len(*p.current.AccountListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccountClientListByResourceGroupResponse page.
func (p *AccountClientListByResourceGroupPager) PageResponse() AccountClientListByResourceGroupResponse {
	return p.current
}

// AccountClientListPager provides operations for iterating over paged responses.
type AccountClientListPager struct {
	client    *AccountClient
	current   AccountClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccountClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccountClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccountListResult.NextLink == nil || len(*p.current.AccountListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccountClientListResponse page.
func (p *AccountClientListPager) PageResponse() AccountClientListResponse {
	return p.current
}

// ActivityClientListByModulePager provides operations for iterating over paged responses.
type ActivityClientListByModulePager struct {
	client    *ActivityClient
	current   ActivityClientListByModuleResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ActivityClientListByModuleResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ActivityClientListByModulePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ActivityClientListByModulePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ActivityListResult.NextLink == nil || len(*p.current.ActivityListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByModuleHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ActivityClientListByModuleResponse page.
func (p *ActivityClientListByModulePager) PageResponse() ActivityClientListByModuleResponse {
	return p.current
}

// CertificateClientListByAutomationAccountPager provides operations for iterating over paged responses.
type CertificateClientListByAutomationAccountPager struct {
	client    *CertificateClient
	current   CertificateClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CertificateClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CertificateClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CertificateClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CertificateListResult.NextLink == nil || len(*p.current.CertificateListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CertificateClientListByAutomationAccountResponse page.
func (p *CertificateClientListByAutomationAccountPager) PageResponse() CertificateClientListByAutomationAccountResponse {
	return p.current
}

// ConnectionClientListByAutomationAccountPager provides operations for iterating over paged responses.
type ConnectionClientListByAutomationAccountPager struct {
	client    *ConnectionClient
	current   ConnectionClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConnectionClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ConnectionClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ConnectionClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectionListResult.NextLink == nil || len(*p.current.ConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ConnectionClientListByAutomationAccountResponse page.
func (p *ConnectionClientListByAutomationAccountPager) PageResponse() ConnectionClientListByAutomationAccountResponse {
	return p.current
}

// ConnectionTypeClientListByAutomationAccountPager provides operations for iterating over paged responses.
type ConnectionTypeClientListByAutomationAccountPager struct {
	client    *ConnectionTypeClient
	current   ConnectionTypeClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConnectionTypeClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ConnectionTypeClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ConnectionTypeClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectionTypeListResult.NextLink == nil || len(*p.current.ConnectionTypeListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ConnectionTypeClientListByAutomationAccountResponse page.
func (p *ConnectionTypeClientListByAutomationAccountPager) PageResponse() ConnectionTypeClientListByAutomationAccountResponse {
	return p.current
}

// CredentialClientListByAutomationAccountPager provides operations for iterating over paged responses.
type CredentialClientListByAutomationAccountPager struct {
	client    *CredentialClient
	current   CredentialClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CredentialClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CredentialClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CredentialClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CredentialListResult.NextLink == nil || len(*p.current.CredentialListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CredentialClientListByAutomationAccountResponse page.
func (p *CredentialClientListByAutomationAccountPager) PageResponse() CredentialClientListByAutomationAccountResponse {
	return p.current
}

// DscCompilationJobClientListByAutomationAccountPager provides operations for iterating over paged responses.
type DscCompilationJobClientListByAutomationAccountPager struct {
	client    *DscCompilationJobClient
	current   DscCompilationJobClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DscCompilationJobClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DscCompilationJobClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DscCompilationJobClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscCompilationJobListResult.NextLink == nil || len(*p.current.DscCompilationJobListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DscCompilationJobClientListByAutomationAccountResponse page.
func (p *DscCompilationJobClientListByAutomationAccountPager) PageResponse() DscCompilationJobClientListByAutomationAccountResponse {
	return p.current
}

// DscConfigurationClientListByAutomationAccountPager provides operations for iterating over paged responses.
type DscConfigurationClientListByAutomationAccountPager struct {
	client    *DscConfigurationClient
	current   DscConfigurationClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DscConfigurationClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DscConfigurationClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DscConfigurationClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscConfigurationListResult.NextLink == nil || len(*p.current.DscConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DscConfigurationClientListByAutomationAccountResponse page.
func (p *DscConfigurationClientListByAutomationAccountPager) PageResponse() DscConfigurationClientListByAutomationAccountResponse {
	return p.current
}

// DscNodeClientListByAutomationAccountPager provides operations for iterating over paged responses.
type DscNodeClientListByAutomationAccountPager struct {
	client    *DscNodeClient
	current   DscNodeClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DscNodeClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DscNodeClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DscNodeClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscNodeListResult.NextLink == nil || len(*p.current.DscNodeListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DscNodeClientListByAutomationAccountResponse page.
func (p *DscNodeClientListByAutomationAccountPager) PageResponse() DscNodeClientListByAutomationAccountResponse {
	return p.current
}

// DscNodeConfigurationClientListByAutomationAccountPager provides operations for iterating over paged responses.
type DscNodeConfigurationClientListByAutomationAccountPager struct {
	client    *DscNodeConfigurationClient
	current   DscNodeConfigurationClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DscNodeConfigurationClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DscNodeConfigurationClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DscNodeConfigurationClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscNodeConfigurationListResult.NextLink == nil || len(*p.current.DscNodeConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DscNodeConfigurationClientListByAutomationAccountResponse page.
func (p *DscNodeConfigurationClientListByAutomationAccountPager) PageResponse() DscNodeConfigurationClientListByAutomationAccountResponse {
	return p.current
}

// HybridRunbookWorkerGroupClientListByAutomationAccountPager provides operations for iterating over paged responses.
type HybridRunbookWorkerGroupClientListByAutomationAccountPager struct {
	client    *HybridRunbookWorkerGroupClient
	current   HybridRunbookWorkerGroupClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, HybridRunbookWorkerGroupClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *HybridRunbookWorkerGroupClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *HybridRunbookWorkerGroupClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.HybridRunbookWorkerGroupsListResult.NextLink == nil || len(*p.current.HybridRunbookWorkerGroupsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current HybridRunbookWorkerGroupClientListByAutomationAccountResponse page.
func (p *HybridRunbookWorkerGroupClientListByAutomationAccountPager) PageResponse() HybridRunbookWorkerGroupClientListByAutomationAccountResponse {
	return p.current
}

// HybridRunbookWorkersClientListByHybridRunbookWorkerGroupPager provides operations for iterating over paged responses.
type HybridRunbookWorkersClientListByHybridRunbookWorkerGroupPager struct {
	client    *HybridRunbookWorkersClient
	current   HybridRunbookWorkersClientListByHybridRunbookWorkerGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, HybridRunbookWorkersClientListByHybridRunbookWorkerGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *HybridRunbookWorkersClientListByHybridRunbookWorkerGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *HybridRunbookWorkersClientListByHybridRunbookWorkerGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.HybridRunbookWorkersListResult.NextLink == nil || len(*p.current.HybridRunbookWorkersListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByHybridRunbookWorkerGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current HybridRunbookWorkersClientListByHybridRunbookWorkerGroupResponse page.
func (p *HybridRunbookWorkersClientListByHybridRunbookWorkerGroupPager) PageResponse() HybridRunbookWorkersClientListByHybridRunbookWorkerGroupResponse {
	return p.current
}

// JobClientListByAutomationAccountPager provides operations for iterating over paged responses.
type JobClientListByAutomationAccountPager struct {
	client    *JobClient
	current   JobClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobListResultV2.NextLink == nil || len(*p.current.JobListResultV2.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobClientListByAutomationAccountResponse page.
func (p *JobClientListByAutomationAccountPager) PageResponse() JobClientListByAutomationAccountResponse {
	return p.current
}

// JobScheduleClientListByAutomationAccountPager provides operations for iterating over paged responses.
type JobScheduleClientListByAutomationAccountPager struct {
	client    *JobScheduleClient
	current   JobScheduleClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobScheduleClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobScheduleClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobScheduleClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobScheduleListResult.NextLink == nil || len(*p.current.JobScheduleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobScheduleClientListByAutomationAccountResponse page.
func (p *JobScheduleClientListByAutomationAccountPager) PageResponse() JobScheduleClientListByAutomationAccountResponse {
	return p.current
}

// JobStreamClientListByJobPager provides operations for iterating over paged responses.
type JobStreamClientListByJobPager struct {
	client    *JobStreamClient
	current   JobStreamClientListByJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobStreamClientListByJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobStreamClientListByJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobStreamClientListByJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobStreamListResult.NextLink == nil || len(*p.current.JobStreamListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobStreamClientListByJobResponse page.
func (p *JobStreamClientListByJobPager) PageResponse() JobStreamClientListByJobResponse {
	return p.current
}

// ModuleClientListByAutomationAccountPager provides operations for iterating over paged responses.
type ModuleClientListByAutomationAccountPager struct {
	client    *ModuleClient
	current   ModuleClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ModuleClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ModuleClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ModuleClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ModuleListResult.NextLink == nil || len(*p.current.ModuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ModuleClientListByAutomationAccountResponse page.
func (p *ModuleClientListByAutomationAccountPager) PageResponse() ModuleClientListByAutomationAccountResponse {
	return p.current
}

// NodeReportsClientListByNodePager provides operations for iterating over paged responses.
type NodeReportsClientListByNodePager struct {
	client    *NodeReportsClient
	current   NodeReportsClientListByNodeResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NodeReportsClientListByNodeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NodeReportsClientListByNodePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NodeReportsClientListByNodePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscNodeReportListResult.NextLink == nil || len(*p.current.DscNodeReportListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByNodeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NodeReportsClientListByNodeResponse page.
func (p *NodeReportsClientListByNodePager) PageResponse() NodeReportsClientListByNodeResponse {
	return p.current
}

// Python2PackageClientListByAutomationAccountPager provides operations for iterating over paged responses.
type Python2PackageClientListByAutomationAccountPager struct {
	client    *Python2PackageClient
	current   Python2PackageClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, Python2PackageClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *Python2PackageClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *Python2PackageClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ModuleListResult.NextLink == nil || len(*p.current.ModuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current Python2PackageClientListByAutomationAccountResponse page.
func (p *Python2PackageClientListByAutomationAccountPager) PageResponse() Python2PackageClientListByAutomationAccountResponse {
	return p.current
}

// RunbookClientListByAutomationAccountPager provides operations for iterating over paged responses.
type RunbookClientListByAutomationAccountPager struct {
	client    *RunbookClient
	current   RunbookClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RunbookClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RunbookClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RunbookClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RunbookListResult.NextLink == nil || len(*p.current.RunbookListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RunbookClientListByAutomationAccountResponse page.
func (p *RunbookClientListByAutomationAccountPager) PageResponse() RunbookClientListByAutomationAccountResponse {
	return p.current
}

// ScheduleClientListByAutomationAccountPager provides operations for iterating over paged responses.
type ScheduleClientListByAutomationAccountPager struct {
	client    *ScheduleClient
	current   ScheduleClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ScheduleClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ScheduleClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ScheduleClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleListResult.NextLink == nil || len(*p.current.ScheduleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ScheduleClientListByAutomationAccountResponse page.
func (p *ScheduleClientListByAutomationAccountPager) PageResponse() ScheduleClientListByAutomationAccountResponse {
	return p.current
}

// SourceControlClientListByAutomationAccountPager provides operations for iterating over paged responses.
type SourceControlClientListByAutomationAccountPager struct {
	client    *SourceControlClient
	current   SourceControlClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SourceControlClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SourceControlClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SourceControlClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SourceControlListResult.NextLink == nil || len(*p.current.SourceControlListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SourceControlClientListByAutomationAccountResponse page.
func (p *SourceControlClientListByAutomationAccountPager) PageResponse() SourceControlClientListByAutomationAccountResponse {
	return p.current
}

// SourceControlSyncJobClientListByAutomationAccountPager provides operations for iterating over paged responses.
type SourceControlSyncJobClientListByAutomationAccountPager struct {
	client    *SourceControlSyncJobClient
	current   SourceControlSyncJobClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SourceControlSyncJobClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SourceControlSyncJobClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SourceControlSyncJobClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SourceControlSyncJobListResult.NextLink == nil || len(*p.current.SourceControlSyncJobListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SourceControlSyncJobClientListByAutomationAccountResponse page.
func (p *SourceControlSyncJobClientListByAutomationAccountPager) PageResponse() SourceControlSyncJobClientListByAutomationAccountResponse {
	return p.current
}

// SourceControlSyncJobStreamsClientListBySyncJobPager provides operations for iterating over paged responses.
type SourceControlSyncJobStreamsClientListBySyncJobPager struct {
	client    *SourceControlSyncJobStreamsClient
	current   SourceControlSyncJobStreamsClientListBySyncJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SourceControlSyncJobStreamsClientListBySyncJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SourceControlSyncJobStreamsClientListBySyncJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SourceControlSyncJobStreamsClientListBySyncJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SourceControlSyncJobStreamsListBySyncJob.NextLink == nil || len(*p.current.SourceControlSyncJobStreamsListBySyncJob.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySyncJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SourceControlSyncJobStreamsClientListBySyncJobResponse page.
func (p *SourceControlSyncJobStreamsClientListBySyncJobPager) PageResponse() SourceControlSyncJobStreamsClientListBySyncJobResponse {
	return p.current
}

// TestJobStreamsClientListByTestJobPager provides operations for iterating over paged responses.
type TestJobStreamsClientListByTestJobPager struct {
	client    *TestJobStreamsClient
	current   TestJobStreamsClientListByTestJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TestJobStreamsClientListByTestJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TestJobStreamsClientListByTestJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TestJobStreamsClientListByTestJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobStreamListResult.NextLink == nil || len(*p.current.JobStreamListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByTestJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TestJobStreamsClientListByTestJobResponse page.
func (p *TestJobStreamsClientListByTestJobPager) PageResponse() TestJobStreamsClientListByTestJobResponse {
	return p.current
}

// VariableClientListByAutomationAccountPager provides operations for iterating over paged responses.
type VariableClientListByAutomationAccountPager struct {
	client    *VariableClient
	current   VariableClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VariableClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VariableClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VariableClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VariableListResult.NextLink == nil || len(*p.current.VariableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VariableClientListByAutomationAccountResponse page.
func (p *VariableClientListByAutomationAccountPager) PageResponse() VariableClientListByAutomationAccountResponse {
	return p.current
}

// WatcherClientListByAutomationAccountPager provides operations for iterating over paged responses.
type WatcherClientListByAutomationAccountPager struct {
	client    *WatcherClient
	current   WatcherClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WatcherClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WatcherClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WatcherClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WatcherListResult.NextLink == nil || len(*p.current.WatcherListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WatcherClientListByAutomationAccountResponse page.
func (p *WatcherClientListByAutomationAccountPager) PageResponse() WatcherClientListByAutomationAccountResponse {
	return p.current
}

// WebhookClientListByAutomationAccountPager provides operations for iterating over paged responses.
type WebhookClientListByAutomationAccountPager struct {
	client    *WebhookClient
	current   WebhookClientListByAutomationAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebhookClientListByAutomationAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebhookClientListByAutomationAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebhookClientListByAutomationAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebhookListResult.NextLink == nil || len(*p.current.WebhookListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAutomationAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebhookClientListByAutomationAccountResponse page.
func (p *WebhookClientListByAutomationAccountPager) PageResponse() WebhookClientListByAutomationAccountResponse {
	return p.current
}
