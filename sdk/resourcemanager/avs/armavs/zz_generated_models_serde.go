//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armavs

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type Addon.
func (a Addon) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Addon.
func (a *Addon) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			a.Properties, err = unmarshalAddonPropertiesClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAddonProperties implements the AddonPropertiesClassification interface for type AddonHcxProperties.
func (a *AddonHcxProperties) GetAddonProperties() *AddonProperties {
	return &AddonProperties{
		AddonType:         a.AddonType,
		ProvisioningState: a.ProvisioningState,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AddonHcxProperties.
func (a AddonHcxProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["addonType"] = AddonTypeHCX
	populate(objectMap, "offer", a.Offer)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonHcxProperties.
func (a *AddonHcxProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addonType":
			err = unpopulate(val, &a.AddonType)
			delete(rawMsg, key)
		case "offer":
			err = unpopulate(val, &a.Offer)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddonList.
func (a AddonList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// GetAddonProperties implements the AddonPropertiesClassification interface for type AddonProperties.
func (a *AddonProperties) GetAddonProperties() *AddonProperties { return a }

// GetAddonProperties implements the AddonPropertiesClassification interface for type AddonSrmProperties.
func (a *AddonSrmProperties) GetAddonProperties() *AddonProperties {
	return &AddonProperties{
		AddonType:         a.AddonType,
		ProvisioningState: a.ProvisioningState,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AddonSrmProperties.
func (a AddonSrmProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["addonType"] = AddonTypeSRM
	populate(objectMap, "licenseKey", a.LicenseKey)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonSrmProperties.
func (a *AddonSrmProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addonType":
			err = unpopulate(val, &a.AddonType)
			delete(rawMsg, key)
		case "licenseKey":
			err = unpopulate(val, &a.LicenseKey)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAddonProperties implements the AddonPropertiesClassification interface for type AddonVrProperties.
func (a *AddonVrProperties) GetAddonProperties() *AddonProperties {
	return &AddonProperties{
		AddonType:         a.AddonType,
		ProvisioningState: a.ProvisioningState,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AddonVrProperties.
func (a AddonVrProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["addonType"] = AddonTypeVR
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "vrsCount", a.VrsCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonVrProperties.
func (a *AddonVrProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addonType":
			err = unpopulate(val, &a.AddonType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &a.ProvisioningState)
			delete(rawMsg, key)
		case "vrsCount":
			err = unpopulate(val, &a.VrsCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudLinkList.
func (c CloudLinkList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ClusterList.
func (c ClusterList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ClusterProperties.
func (c ClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clusterId", c.ClusterID)
	populate(objectMap, "clusterSize", c.ClusterSize)
	populate(objectMap, "hosts", c.Hosts)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ClusterUpdate.
func (c ClusterUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ClusterUpdateProperties.
func (c ClusterUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clusterSize", c.ClusterSize)
	populate(objectMap, "hosts", c.Hosts)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CommonClusterProperties.
func (c CommonClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clusterId", c.ClusterID)
	populate(objectMap, "clusterSize", c.ClusterSize)
	populate(objectMap, "hosts", c.Hosts)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DatastoreList.
func (d DatastoreList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponse.
func (e ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ExpressRouteAuthorizationList.
func (e ExpressRouteAuthorizationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type GlobalReachConnectionList.
func (g GlobalReachConnectionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type HcxEnterpriseSiteList.
func (h HcxEnterpriseSiteList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ManagementCluster.
func (m ManagementCluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clusterId", m.ClusterID)
	populate(objectMap, "clusterSize", m.ClusterSize)
	populate(objectMap, "hosts", m.Hosts)
	populate(objectMap, "provisioningState", m.ProvisioningState)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetricSpecification.
func (m MetricSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregationType", m.AggregationType)
	populate(objectMap, "category", m.Category)
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "displayDescription", m.DisplayDescription)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "enableRegionalMdmAccount", m.EnableRegionalMdmAccount)
	populate(objectMap, "fillGapWithZero", m.FillGapWithZero)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "sourceMdmAccount", m.SourceMdmAccount)
	populate(objectMap, "sourceMdmNamespace", m.SourceMdmNamespace)
	populate(objectMap, "supportedAggregationTypes", m.SupportedAggregationTypes)
	populate(objectMap, "supportedTimeGrainTypes", m.SupportedTimeGrainTypes)
	populate(objectMap, "unit", m.Unit)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OperationList.
func (o OperationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// GetScriptExecutionParameter implements the ScriptExecutionParameterClassification interface for type PSCredentialExecutionParameter.
func (p *PSCredentialExecutionParameter) GetScriptExecutionParameter() *ScriptExecutionParameter {
	return &ScriptExecutionParameter{
		Name: p.Name,
		Type: p.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PSCredentialExecutionParameter.
func (p PSCredentialExecutionParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", p.Name)
	populate(objectMap, "password", p.Password)
	objectMap["type"] = ScriptExecutionParameterTypeCredential
	populate(objectMap, "username", p.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PSCredentialExecutionParameter.
func (p *PSCredentialExecutionParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &p.Name)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &p.Password)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &p.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPoliciesList.
func (p PlacementPoliciesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPolicy.
func (p PlacementPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlacementPolicy.
func (p *PlacementPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &p.Name)
			delete(rawMsg, key)
		case "properties":
			p.Properties, err = unmarshalPlacementPolicyPropertiesClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetPlacementPolicyProperties implements the PlacementPolicyPropertiesClassification interface for type PlacementPolicyProperties.
func (p *PlacementPolicyProperties) GetPlacementPolicyProperties() *PlacementPolicyProperties {
	return p
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPolicyUpdate.
func (p PlacementPolicyUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPolicyUpdateProperties.
func (p PlacementPolicyUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "hostMembers", p.HostMembers)
	populate(objectMap, "state", p.State)
	populate(objectMap, "vmMembers", p.VMMembers)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloud.
func (p PrivateCloud) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", p.ID)
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "sku", p.SKU)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloudList.
func (p PrivateCloudList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloudProperties.
func (p PrivateCloudProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "availability", p.Availability)
	populate(objectMap, "circuit", p.Circuit)
	populate(objectMap, "encryption", p.Encryption)
	populate(objectMap, "endpoints", p.Endpoints)
	populate(objectMap, "externalCloudLinks", p.ExternalCloudLinks)
	populate(objectMap, "identitySources", p.IdentitySources)
	populate(objectMap, "internet", p.Internet)
	populate(objectMap, "managementCluster", p.ManagementCluster)
	populate(objectMap, "managementNetwork", p.ManagementNetwork)
	populate(objectMap, "networkBlock", p.NetworkBlock)
	populate(objectMap, "nsxtCertificateThumbprint", p.NsxtCertificateThumbprint)
	populate(objectMap, "nsxtPassword", p.NsxtPassword)
	populate(objectMap, "provisioningNetwork", p.ProvisioningNetwork)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "secondaryCircuit", p.SecondaryCircuit)
	populate(objectMap, "vcenterCertificateThumbprint", p.VcenterCertificateThumbprint)
	populate(objectMap, "vcenterPassword", p.VcenterPassword)
	populate(objectMap, "vmotionNetwork", p.VmotionNetwork)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloudUpdate.
func (p PrivateCloudUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloudUpdateProperties.
func (p PrivateCloudUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "availability", p.Availability)
	populate(objectMap, "encryption", p.Encryption)
	populate(objectMap, "identitySources", p.IdentitySources)
	populate(objectMap, "internet", p.Internet)
	populate(objectMap, "managementCluster", p.ManagementCluster)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Quota.
func (q Quota) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "hostsRemaining", q.HostsRemaining)
	populate(objectMap, "quotaEnabled", q.QuotaEnabled)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ScriptCmdletProperties.
func (s ScriptCmdletProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "timeout", s.Timeout)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ScriptCmdletsList.
func (s ScriptCmdletsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// GetScriptExecutionParameter implements the ScriptExecutionParameterClassification interface for type ScriptExecutionParameter.
func (s *ScriptExecutionParameter) GetScriptExecutionParameter() *ScriptExecutionParameter { return s }

// MarshalJSON implements the json.Marshaller interface for type ScriptExecutionProperties.
func (s ScriptExecutionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errors", s.Errors)
	populate(objectMap, "failureReason", s.FailureReason)
	populateTimeRFC3339(objectMap, "finishedAt", s.FinishedAt)
	populate(objectMap, "hiddenParameters", s.HiddenParameters)
	populate(objectMap, "information", s.Information)
	populate(objectMap, "namedOutputs", s.NamedOutputs)
	populate(objectMap, "output", s.Output)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "retention", s.Retention)
	populate(objectMap, "scriptCmdletId", s.ScriptCmdletID)
	populateTimeRFC3339(objectMap, "startedAt", s.StartedAt)
	populateTimeRFC3339(objectMap, "submittedAt", s.SubmittedAt)
	populate(objectMap, "timeout", s.Timeout)
	populate(objectMap, "warnings", s.Warnings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptExecutionProperties.
func (s *ScriptExecutionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
			err = unpopulate(val, &s.Errors)
			delete(rawMsg, key)
		case "failureReason":
			err = unpopulate(val, &s.FailureReason)
			delete(rawMsg, key)
		case "finishedAt":
			err = unpopulateTimeRFC3339(val, &s.FinishedAt)
			delete(rawMsg, key)
		case "hiddenParameters":
			s.HiddenParameters, err = unmarshalScriptExecutionParameterClassificationArray(val)
			delete(rawMsg, key)
		case "information":
			err = unpopulate(val, &s.Information)
			delete(rawMsg, key)
		case "namedOutputs":
			err = unpopulate(val, &s.NamedOutputs)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &s.Output)
			delete(rawMsg, key)
		case "parameters":
			s.Parameters, err = unmarshalScriptExecutionParameterClassificationArray(val)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "retention":
			err = unpopulate(val, &s.Retention)
			delete(rawMsg, key)
		case "scriptCmdletId":
			err = unpopulate(val, &s.ScriptCmdletID)
			delete(rawMsg, key)
		case "startedAt":
			err = unpopulateTimeRFC3339(val, &s.StartedAt)
			delete(rawMsg, key)
		case "submittedAt":
			err = unpopulateTimeRFC3339(val, &s.SubmittedAt)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, &s.Timeout)
			delete(rawMsg, key)
		case "warnings":
			err = unpopulate(val, &s.Warnings)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptExecutionsList.
func (s ScriptExecutionsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ScriptPackagesList.
func (s ScriptPackagesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// GetScriptExecutionParameter implements the ScriptExecutionParameterClassification interface for type ScriptSecureStringExecutionParameter.
func (s *ScriptSecureStringExecutionParameter) GetScriptExecutionParameter() *ScriptExecutionParameter {
	return &ScriptExecutionParameter{
		Name: s.Name,
		Type: s.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ScriptSecureStringExecutionParameter.
func (s ScriptSecureStringExecutionParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", s.Name)
	populate(objectMap, "secureValue", s.SecureValue)
	objectMap["type"] = ScriptExecutionParameterTypeSecureValue
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptSecureStringExecutionParameter.
func (s *ScriptSecureStringExecutionParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "secureValue":
			err = unpopulate(val, &s.SecureValue)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetScriptExecutionParameter implements the ScriptExecutionParameterClassification interface for type ScriptStringExecutionParameter.
func (s *ScriptStringExecutionParameter) GetScriptExecutionParameter() *ScriptExecutionParameter {
	return &ScriptExecutionParameter{
		Name: s.Name,
		Type: s.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ScriptStringExecutionParameter.
func (s ScriptStringExecutionParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", s.Name)
	objectMap["type"] = ScriptExecutionParameterTypeValue
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptStringExecutionParameter.
func (s *ScriptStringExecutionParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceSpecification.
func (s ServiceSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "logSpecifications", s.LogSpecifications)
	populate(objectMap, "metricSpecifications", s.MetricSpecifications)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// GetPlacementPolicyProperties implements the PlacementPolicyPropertiesClassification interface for type VMHostPlacementPolicyProperties.
func (v *VMHostPlacementPolicyProperties) GetPlacementPolicyProperties() *PlacementPolicyProperties {
	return &PlacementPolicyProperties{
		Type:              v.Type,
		State:             v.State,
		DisplayName:       v.DisplayName,
		ProvisioningState: v.ProvisioningState,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VMHostPlacementPolicyProperties.
func (v VMHostPlacementPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "affinityType", v.AffinityType)
	populate(objectMap, "displayName", v.DisplayName)
	populate(objectMap, "hostMembers", v.HostMembers)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "state", v.State)
	objectMap["type"] = PlacementPolicyTypeVMHost
	populate(objectMap, "vmMembers", v.VMMembers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMHostPlacementPolicyProperties.
func (v *VMHostPlacementPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityType":
			err = unpopulate(val, &v.AffinityType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &v.DisplayName)
			delete(rawMsg, key)
		case "hostMembers":
			err = unpopulate(val, &v.HostMembers)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &v.ProvisioningState)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &v.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &v.Type)
			delete(rawMsg, key)
		case "vmMembers":
			err = unpopulate(val, &v.VMMembers)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetPlacementPolicyProperties implements the PlacementPolicyPropertiesClassification interface for type VMPlacementPolicyProperties.
func (v *VMPlacementPolicyProperties) GetPlacementPolicyProperties() *PlacementPolicyProperties {
	return &PlacementPolicyProperties{
		Type:              v.Type,
		State:             v.State,
		DisplayName:       v.DisplayName,
		ProvisioningState: v.ProvisioningState,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VMPlacementPolicyProperties.
func (v VMPlacementPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "affinityType", v.AffinityType)
	populate(objectMap, "displayName", v.DisplayName)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "state", v.State)
	objectMap["type"] = PlacementPolicyTypeVMVM
	populate(objectMap, "vmMembers", v.VMMembers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMPlacementPolicyProperties.
func (v *VMPlacementPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityType":
			err = unpopulate(val, &v.AffinityType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &v.DisplayName)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &v.ProvisioningState)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &v.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &v.Type)
			delete(rawMsg, key)
		case "vmMembers":
			err = unpopulate(val, &v.VMMembers)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachinesList.
func (v VirtualMachinesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSService.
func (w WorkloadNetworkDNSService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSServiceProperties.
func (w WorkloadNetworkDNSServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dnsServiceIp", w.DNSServiceIP)
	populate(objectMap, "defaultDnsZone", w.DefaultDNSZone)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "fqdnZones", w.FqdnZones)
	populate(objectMap, "logLevel", w.LogLevel)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSServicesList.
func (w WorkloadNetworkDNSServicesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSZone.
func (w WorkloadNetworkDNSZone) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSZoneProperties.
func (w WorkloadNetworkDNSZoneProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dnsServerIps", w.DNSServerIPs)
	populate(objectMap, "dnsServices", w.DNSServices)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "domain", w.Domain)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "sourceIp", w.SourceIP)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSZonesList.
func (w WorkloadNetworkDNSZonesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcp.
func (w WorkloadNetworkDhcp) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDhcp.
func (w *WorkloadNetworkDhcp) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &w.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &w.Name)
			delete(rawMsg, key)
		case "properties":
			w.Properties, err = unmarshalWorkloadNetworkDhcpEntityClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetWorkloadNetworkDhcpEntity implements the WorkloadNetworkDhcpEntityClassification interface for type WorkloadNetworkDhcpEntity.
func (w *WorkloadNetworkDhcpEntity) GetWorkloadNetworkDhcpEntity() *WorkloadNetworkDhcpEntity {
	return w
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcpEntity.
func (w WorkloadNetworkDhcpEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["dhcpType"] = w.DhcpType
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "segments", w.Segments)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcpList.
func (w WorkloadNetworkDhcpList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// GetWorkloadNetworkDhcpEntity implements the WorkloadNetworkDhcpEntityClassification interface for type WorkloadNetworkDhcpRelay.
func (w *WorkloadNetworkDhcpRelay) GetWorkloadNetworkDhcpEntity() *WorkloadNetworkDhcpEntity {
	return &WorkloadNetworkDhcpEntity{
		DhcpType:          w.DhcpType,
		DisplayName:       w.DisplayName,
		Segments:          w.Segments,
		ProvisioningState: w.ProvisioningState,
		Revision:          w.Revision,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcpRelay.
func (w WorkloadNetworkDhcpRelay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["dhcpType"] = DhcpTypeEnumRELAY
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "segments", w.Segments)
	populate(objectMap, "serverAddresses", w.ServerAddresses)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDhcpRelay.
func (w *WorkloadNetworkDhcpRelay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dhcpType":
			err = unpopulate(val, &w.DhcpType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &w.DisplayName)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &w.ProvisioningState)
			delete(rawMsg, key)
		case "revision":
			err = unpopulate(val, &w.Revision)
			delete(rawMsg, key)
		case "segments":
			err = unpopulate(val, &w.Segments)
			delete(rawMsg, key)
		case "serverAddresses":
			err = unpopulate(val, &w.ServerAddresses)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetWorkloadNetworkDhcpEntity implements the WorkloadNetworkDhcpEntityClassification interface for type WorkloadNetworkDhcpServer.
func (w *WorkloadNetworkDhcpServer) GetWorkloadNetworkDhcpEntity() *WorkloadNetworkDhcpEntity {
	return &WorkloadNetworkDhcpEntity{
		DhcpType:          w.DhcpType,
		DisplayName:       w.DisplayName,
		Segments:          w.Segments,
		ProvisioningState: w.ProvisioningState,
		Revision:          w.Revision,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcpServer.
func (w WorkloadNetworkDhcpServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["dhcpType"] = DhcpTypeEnumSERVER
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "leaseTime", w.LeaseTime)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "segments", w.Segments)
	populate(objectMap, "serverAddress", w.ServerAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDhcpServer.
func (w *WorkloadNetworkDhcpServer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dhcpType":
			err = unpopulate(val, &w.DhcpType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &w.DisplayName)
			delete(rawMsg, key)
		case "leaseTime":
			err = unpopulate(val, &w.LeaseTime)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &w.ProvisioningState)
			delete(rawMsg, key)
		case "revision":
			err = unpopulate(val, &w.Revision)
			delete(rawMsg, key)
		case "segments":
			err = unpopulate(val, &w.Segments)
			delete(rawMsg, key)
		case "serverAddress":
			err = unpopulate(val, &w.ServerAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkGatewayList.
func (w WorkloadNetworkGatewayList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkPortMirroring.
func (w WorkloadNetworkPortMirroring) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkPortMirroringList.
func (w WorkloadNetworkPortMirroringList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkPublicIPsList.
func (w WorkloadNetworkPublicIPsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegment.
func (w WorkloadNetworkSegment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegmentProperties.
func (w WorkloadNetworkSegmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectedGateway", w.ConnectedGateway)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "portVif", w.PortVif)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "status", w.Status)
	populate(objectMap, "subnet", w.Subnet)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegmentSubnet.
func (w WorkloadNetworkSegmentSubnet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dhcpRanges", w.DhcpRanges)
	populate(objectMap, "gatewayAddress", w.GatewayAddress)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegmentsList.
func (w WorkloadNetworkSegmentsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVMGroup.
func (w WorkloadNetworkVMGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVMGroupProperties.
func (w WorkloadNetworkVMGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "members", w.Members)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVMGroupsList.
func (w WorkloadNetworkVMGroupsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVirtualMachinesList.
func (w WorkloadNetworkVirtualMachinesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
