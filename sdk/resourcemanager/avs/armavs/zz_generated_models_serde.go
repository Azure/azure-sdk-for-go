//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armavs

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type Addon.
func (a Addon) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Addon.
func (a *Addon) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			a.Properties, err = unmarshalAddonPropertiesClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddonHcxProperties.
func (a AddonHcxProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["addonType"] = AddonTypeHCX
	populate(objectMap, "offer", a.Offer)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonHcxProperties.
func (a *AddonHcxProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addonType":
			err = unpopulate(val, "AddonType", &a.AddonType)
			delete(rawMsg, key)
		case "offer":
			err = unpopulate(val, "Offer", &a.Offer)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddonSrmProperties.
func (a AddonSrmProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["addonType"] = AddonTypeSRM
	populate(objectMap, "licenseKey", a.LicenseKey)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonSrmProperties.
func (a *AddonSrmProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addonType":
			err = unpopulate(val, "AddonType", &a.AddonType)
			delete(rawMsg, key)
		case "licenseKey":
			err = unpopulate(val, "LicenseKey", &a.LicenseKey)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddonVrProperties.
func (a AddonVrProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["addonType"] = AddonTypeVR
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "vrsCount", a.VrsCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonVrProperties.
func (a *AddonVrProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addonType":
			err = unpopulate(val, "AddonType", &a.AddonType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "vrsCount":
			err = unpopulate(val, "VrsCount", &a.VrsCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterProperties.
func (c ClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clusterId", c.ClusterID)
	populate(objectMap, "clusterSize", c.ClusterSize)
	populate(objectMap, "hosts", c.Hosts)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ClusterUpdate.
func (c ClusterUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ClusterUpdateProperties.
func (c ClusterUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clusterSize", c.ClusterSize)
	populate(objectMap, "hosts", c.Hosts)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CommonClusterProperties.
func (c CommonClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clusterId", c.ClusterID)
	populate(objectMap, "clusterSize", c.ClusterSize)
	populate(objectMap, "hosts", c.Hosts)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ManagementCluster.
func (m ManagementCluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clusterId", m.ClusterID)
	populate(objectMap, "clusterSize", m.ClusterSize)
	populate(objectMap, "hosts", m.Hosts)
	populate(objectMap, "provisioningState", m.ProvisioningState)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PSCredentialExecutionParameter.
func (p PSCredentialExecutionParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", p.Name)
	populate(objectMap, "password", p.Password)
	objectMap["type"] = ScriptExecutionParameterTypeCredential
	populate(objectMap, "username", p.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PSCredentialExecutionParameter.
func (p *PSCredentialExecutionParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &p.Password)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &p.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPolicy.
func (p PlacementPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlacementPolicy.
func (p *PlacementPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			p.Properties, err = unmarshalPlacementPolicyPropertiesClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPolicyUpdate.
func (p PlacementPolicyUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPolicyUpdateProperties.
func (p PlacementPolicyUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "hostMembers", p.HostMembers)
	populate(objectMap, "state", p.State)
	populate(objectMap, "vmMembers", p.VMMembers)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloud.
func (p PrivateCloud) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", p.ID)
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "sku", p.SKU)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloudProperties.
func (p PrivateCloudProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "availability", p.Availability)
	populate(objectMap, "circuit", p.Circuit)
	populate(objectMap, "encryption", p.Encryption)
	populate(objectMap, "endpoints", p.Endpoints)
	populate(objectMap, "externalCloudLinks", p.ExternalCloudLinks)
	populate(objectMap, "identitySources", p.IdentitySources)
	populate(objectMap, "internet", p.Internet)
	populate(objectMap, "managementCluster", p.ManagementCluster)
	populate(objectMap, "managementNetwork", p.ManagementNetwork)
	populate(objectMap, "networkBlock", p.NetworkBlock)
	populate(objectMap, "nsxtCertificateThumbprint", p.NsxtCertificateThumbprint)
	populate(objectMap, "nsxtPassword", p.NsxtPassword)
	populate(objectMap, "provisioningNetwork", p.ProvisioningNetwork)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "secondaryCircuit", p.SecondaryCircuit)
	populate(objectMap, "vcenterCertificateThumbprint", p.VcenterCertificateThumbprint)
	populate(objectMap, "vcenterPassword", p.VcenterPassword)
	populate(objectMap, "vmotionNetwork", p.VmotionNetwork)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloudUpdate.
func (p PrivateCloudUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloudUpdateProperties.
func (p PrivateCloudUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "availability", p.Availability)
	populate(objectMap, "encryption", p.Encryption)
	populate(objectMap, "identitySources", p.IdentitySources)
	populate(objectMap, "internet", p.Internet)
	populate(objectMap, "managementCluster", p.ManagementCluster)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ScriptCmdletProperties.
func (s ScriptCmdletProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "timeout", s.Timeout)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ScriptExecutionProperties.
func (s ScriptExecutionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errors", s.Errors)
	populate(objectMap, "failureReason", s.FailureReason)
	populateTimeRFC3339(objectMap, "finishedAt", s.FinishedAt)
	populate(objectMap, "hiddenParameters", s.HiddenParameters)
	populate(objectMap, "information", s.Information)
	populate(objectMap, "namedOutputs", s.NamedOutputs)
	populate(objectMap, "output", s.Output)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "retention", s.Retention)
	populate(objectMap, "scriptCmdletId", s.ScriptCmdletID)
	populateTimeRFC3339(objectMap, "startedAt", s.StartedAt)
	populateTimeRFC3339(objectMap, "submittedAt", s.SubmittedAt)
	populate(objectMap, "timeout", s.Timeout)
	populate(objectMap, "warnings", s.Warnings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptExecutionProperties.
func (s *ScriptExecutionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
			err = unpopulate(val, "Errors", &s.Errors)
			delete(rawMsg, key)
		case "failureReason":
			err = unpopulate(val, "FailureReason", &s.FailureReason)
			delete(rawMsg, key)
		case "finishedAt":
			err = unpopulateTimeRFC3339(val, "FinishedAt", &s.FinishedAt)
			delete(rawMsg, key)
		case "hiddenParameters":
			s.HiddenParameters, err = unmarshalScriptExecutionParameterClassificationArray(val)
			delete(rawMsg, key)
		case "information":
			err = unpopulate(val, "Information", &s.Information)
			delete(rawMsg, key)
		case "namedOutputs":
			err = unpopulate(val, "NamedOutputs", &s.NamedOutputs)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, "Output", &s.Output)
			delete(rawMsg, key)
		case "parameters":
			s.Parameters, err = unmarshalScriptExecutionParameterClassificationArray(val)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "retention":
			err = unpopulate(val, "Retention", &s.Retention)
			delete(rawMsg, key)
		case "scriptCmdletId":
			err = unpopulate(val, "ScriptCmdletID", &s.ScriptCmdletID)
			delete(rawMsg, key)
		case "startedAt":
			err = unpopulateTimeRFC3339(val, "StartedAt", &s.StartedAt)
			delete(rawMsg, key)
		case "submittedAt":
			err = unpopulateTimeRFC3339(val, "SubmittedAt", &s.SubmittedAt)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &s.Timeout)
			delete(rawMsg, key)
		case "warnings":
			err = unpopulate(val, "Warnings", &s.Warnings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptSecureStringExecutionParameter.
func (s ScriptSecureStringExecutionParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", s.Name)
	populate(objectMap, "secureValue", s.SecureValue)
	objectMap["type"] = ScriptExecutionParameterTypeSecureValue
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptSecureStringExecutionParameter.
func (s *ScriptSecureStringExecutionParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "secureValue":
			err = unpopulate(val, "SecureValue", &s.SecureValue)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptStringExecutionParameter.
func (s ScriptStringExecutionParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", s.Name)
	objectMap["type"] = ScriptExecutionParameterTypeValue
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptStringExecutionParameter.
func (s *ScriptStringExecutionParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type VMHostPlacementPolicyProperties.
func (v VMHostPlacementPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "affinityType", v.AffinityType)
	populate(objectMap, "displayName", v.DisplayName)
	populate(objectMap, "hostMembers", v.HostMembers)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "state", v.State)
	objectMap["type"] = PlacementPolicyTypeVMHost
	populate(objectMap, "vmMembers", v.VMMembers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMHostPlacementPolicyProperties.
func (v *VMHostPlacementPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityType":
			err = unpopulate(val, "AffinityType", &v.AffinityType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &v.DisplayName)
			delete(rawMsg, key)
		case "hostMembers":
			err = unpopulate(val, "HostMembers", &v.HostMembers)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &v.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		case "vmMembers":
			err = unpopulate(val, "VMMembers", &v.VMMembers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMPlacementPolicyProperties.
func (v VMPlacementPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "affinityType", v.AffinityType)
	populate(objectMap, "displayName", v.DisplayName)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "state", v.State)
	objectMap["type"] = PlacementPolicyTypeVMVM
	populate(objectMap, "vmMembers", v.VMMembers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMPlacementPolicyProperties.
func (v *VMPlacementPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityType":
			err = unpopulate(val, "AffinityType", &v.AffinityType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &v.DisplayName)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &v.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		case "vmMembers":
			err = unpopulate(val, "VMMembers", &v.VMMembers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSService.
func (w WorkloadNetworkDNSService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSServiceProperties.
func (w WorkloadNetworkDNSServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dnsServiceIp", w.DNSServiceIP)
	populate(objectMap, "defaultDnsZone", w.DefaultDNSZone)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "fqdnZones", w.FqdnZones)
	populate(objectMap, "logLevel", w.LogLevel)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSZone.
func (w WorkloadNetworkDNSZone) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSZoneProperties.
func (w WorkloadNetworkDNSZoneProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dnsServerIps", w.DNSServerIPs)
	populate(objectMap, "dnsServices", w.DNSServices)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "domain", w.Domain)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "sourceIp", w.SourceIP)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcp.
func (w WorkloadNetworkDhcp) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDhcp.
func (w *WorkloadNetworkDhcp) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
			w.Properties, err = unmarshalWorkloadNetworkDhcpEntityClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcpEntity.
func (w WorkloadNetworkDhcpEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["dhcpType"] = w.DhcpType
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "segments", w.Segments)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcpRelay.
func (w WorkloadNetworkDhcpRelay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["dhcpType"] = DhcpTypeEnumRELAY
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "segments", w.Segments)
	populate(objectMap, "serverAddresses", w.ServerAddresses)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDhcpRelay.
func (w *WorkloadNetworkDhcpRelay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dhcpType":
			err = unpopulate(val, "DhcpType", &w.DhcpType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "revision":
			err = unpopulate(val, "Revision", &w.Revision)
			delete(rawMsg, key)
		case "segments":
			err = unpopulate(val, "Segments", &w.Segments)
			delete(rawMsg, key)
		case "serverAddresses":
			err = unpopulate(val, "ServerAddresses", &w.ServerAddresses)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcpServer.
func (w WorkloadNetworkDhcpServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["dhcpType"] = DhcpTypeEnumSERVER
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "leaseTime", w.LeaseTime)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "segments", w.Segments)
	populate(objectMap, "serverAddress", w.ServerAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDhcpServer.
func (w *WorkloadNetworkDhcpServer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dhcpType":
			err = unpopulate(val, "DhcpType", &w.DhcpType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "leaseTime":
			err = unpopulate(val, "LeaseTime", &w.LeaseTime)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "revision":
			err = unpopulate(val, "Revision", &w.Revision)
			delete(rawMsg, key)
		case "segments":
			err = unpopulate(val, "Segments", &w.Segments)
			delete(rawMsg, key)
		case "serverAddress":
			err = unpopulate(val, "ServerAddress", &w.ServerAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkPortMirroring.
func (w WorkloadNetworkPortMirroring) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegment.
func (w WorkloadNetworkSegment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegmentProperties.
func (w WorkloadNetworkSegmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectedGateway", w.ConnectedGateway)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "portVif", w.PortVif)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "status", w.Status)
	populate(objectMap, "subnet", w.Subnet)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegmentSubnet.
func (w WorkloadNetworkSegmentSubnet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dhcpRanges", w.DhcpRanges)
	populate(objectMap, "gatewayAddress", w.GatewayAddress)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVMGroup.
func (w WorkloadNetworkVMGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVMGroupProperties.
func (w WorkloadNetworkVMGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "members", w.Members)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v interface{}) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
