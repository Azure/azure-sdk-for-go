//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armavs

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// AddonsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AddonsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AddonsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AddonsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AddonsCreateOrUpdateResponse will be returned.
func (p *AddonsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (AddonsCreateOrUpdateResponse, error) {
	respType := AddonsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Addon)
	if err != nil {
		return AddonsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AddonsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AddonsDeletePoller provides polling facilities until the operation reaches a terminal state.
type AddonsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AddonsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AddonsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AddonsDeleteResponse will be returned.
func (p *AddonsDeletePoller) FinalResponse(ctx context.Context) (AddonsDeleteResponse, error) {
	respType := AddonsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AddonsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AddonsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AuthorizationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AuthorizationsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AuthorizationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AuthorizationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AuthorizationsCreateOrUpdateResponse will be returned.
func (p *AuthorizationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (AuthorizationsCreateOrUpdateResponse, error) {
	respType := AuthorizationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteAuthorization)
	if err != nil {
		return AuthorizationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AuthorizationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AuthorizationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type AuthorizationsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AuthorizationsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AuthorizationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AuthorizationsDeleteResponse will be returned.
func (p *AuthorizationsDeletePoller) FinalResponse(ctx context.Context) (AuthorizationsDeleteResponse, error) {
	respType := AuthorizationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AuthorizationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AuthorizationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CloudLinksCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CloudLinksCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CloudLinksCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CloudLinksCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CloudLinksCreateOrUpdateResponse will be returned.
func (p *CloudLinksCreateOrUpdatePoller) FinalResponse(ctx context.Context) (CloudLinksCreateOrUpdateResponse, error) {
	respType := CloudLinksCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CloudLink)
	if err != nil {
		return CloudLinksCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CloudLinksCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CloudLinksDeletePoller provides polling facilities until the operation reaches a terminal state.
type CloudLinksDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CloudLinksDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CloudLinksDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CloudLinksDeleteResponse will be returned.
func (p *CloudLinksDeletePoller) FinalResponse(ctx context.Context) (CloudLinksDeleteResponse, error) {
	respType := CloudLinksDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CloudLinksDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CloudLinksDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ClustersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ClustersCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ClustersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ClustersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ClustersCreateOrUpdateResponse will be returned.
func (p *ClustersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ClustersCreateOrUpdateResponse, error) {
	respType := ClustersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Cluster)
	if err != nil {
		return ClustersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ClustersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ClustersDeletePoller provides polling facilities until the operation reaches a terminal state.
type ClustersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ClustersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ClustersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ClustersDeleteResponse will be returned.
func (p *ClustersDeletePoller) FinalResponse(ctx context.Context) (ClustersDeleteResponse, error) {
	respType := ClustersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ClustersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ClustersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ClustersUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ClustersUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ClustersUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ClustersUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ClustersUpdateResponse will be returned.
func (p *ClustersUpdatePoller) FinalResponse(ctx context.Context) (ClustersUpdateResponse, error) {
	respType := ClustersUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Cluster)
	if err != nil {
		return ClustersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ClustersUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatastoresCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatastoresCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatastoresCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatastoresCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatastoresCreateOrUpdateResponse will be returned.
func (p *DatastoresCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DatastoresCreateOrUpdateResponse, error) {
	respType := DatastoresCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Datastore)
	if err != nil {
		return DatastoresCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatastoresCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatastoresDeletePoller provides polling facilities until the operation reaches a terminal state.
type DatastoresDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatastoresDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatastoresDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatastoresDeleteResponse will be returned.
func (p *DatastoresDeletePoller) FinalResponse(ctx context.Context) (DatastoresDeleteResponse, error) {
	respType := DatastoresDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatastoresDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatastoresDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GlobalReachConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type GlobalReachConnectionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GlobalReachConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GlobalReachConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GlobalReachConnectionsCreateOrUpdateResponse will be returned.
func (p *GlobalReachConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (GlobalReachConnectionsCreateOrUpdateResponse, error) {
	respType := GlobalReachConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GlobalReachConnection)
	if err != nil {
		return GlobalReachConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GlobalReachConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// GlobalReachConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type GlobalReachConnectionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GlobalReachConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *GlobalReachConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final GlobalReachConnectionsDeleteResponse will be returned.
func (p *GlobalReachConnectionsDeletePoller) FinalResponse(ctx context.Context) (GlobalReachConnectionsDeleteResponse, error) {
	respType := GlobalReachConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return GlobalReachConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *GlobalReachConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PlacementPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PlacementPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PlacementPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PlacementPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PlacementPoliciesCreateOrUpdateResponse will be returned.
func (p *PlacementPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PlacementPoliciesCreateOrUpdateResponse, error) {
	respType := PlacementPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PlacementPolicy)
	if err != nil {
		return PlacementPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PlacementPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PlacementPoliciesDeletePoller provides polling facilities until the operation reaches a terminal state.
type PlacementPoliciesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PlacementPoliciesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PlacementPoliciesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PlacementPoliciesDeleteResponse will be returned.
func (p *PlacementPoliciesDeletePoller) FinalResponse(ctx context.Context) (PlacementPoliciesDeleteResponse, error) {
	respType := PlacementPoliciesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PlacementPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PlacementPoliciesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PlacementPoliciesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PlacementPoliciesUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PlacementPoliciesUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PlacementPoliciesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PlacementPoliciesUpdateResponse will be returned.
func (p *PlacementPoliciesUpdatePoller) FinalResponse(ctx context.Context) (PlacementPoliciesUpdateResponse, error) {
	respType := PlacementPoliciesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PlacementPolicy)
	if err != nil {
		return PlacementPoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PlacementPoliciesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateCloudsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateCloudsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateCloudsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateCloudsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateCloudsCreateOrUpdateResponse will be returned.
func (p *PrivateCloudsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateCloudsCreateOrUpdateResponse, error) {
	respType := PrivateCloudsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateCloud)
	if err != nil {
		return PrivateCloudsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateCloudsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateCloudsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateCloudsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateCloudsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateCloudsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateCloudsDeleteResponse will be returned.
func (p *PrivateCloudsDeletePoller) FinalResponse(ctx context.Context) (PrivateCloudsDeleteResponse, error) {
	respType := PrivateCloudsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateCloudsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateCloudsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateCloudsRotateNsxtPasswordPoller provides polling facilities until the operation reaches a terminal state.
type PrivateCloudsRotateNsxtPasswordPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateCloudsRotateNsxtPasswordPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateCloudsRotateNsxtPasswordPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateCloudsRotateNsxtPasswordResponse will be returned.
func (p *PrivateCloudsRotateNsxtPasswordPoller) FinalResponse(ctx context.Context) (PrivateCloudsRotateNsxtPasswordResponse, error) {
	respType := PrivateCloudsRotateNsxtPasswordResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateCloudsRotateNsxtPasswordResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateCloudsRotateNsxtPasswordPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateCloudsRotateVcenterPasswordPoller provides polling facilities until the operation reaches a terminal state.
type PrivateCloudsRotateVcenterPasswordPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateCloudsRotateVcenterPasswordPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateCloudsRotateVcenterPasswordPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateCloudsRotateVcenterPasswordResponse will be returned.
func (p *PrivateCloudsRotateVcenterPasswordPoller) FinalResponse(ctx context.Context) (PrivateCloudsRotateVcenterPasswordResponse, error) {
	respType := PrivateCloudsRotateVcenterPasswordResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateCloudsRotateVcenterPasswordResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateCloudsRotateVcenterPasswordPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateCloudsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateCloudsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateCloudsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateCloudsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateCloudsUpdateResponse will be returned.
func (p *PrivateCloudsUpdatePoller) FinalResponse(ctx context.Context) (PrivateCloudsUpdateResponse, error) {
	respType := PrivateCloudsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateCloud)
	if err != nil {
		return PrivateCloudsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateCloudsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ScriptExecutionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ScriptExecutionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ScriptExecutionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ScriptExecutionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ScriptExecutionsCreateOrUpdateResponse will be returned.
func (p *ScriptExecutionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ScriptExecutionsCreateOrUpdateResponse, error) {
	respType := ScriptExecutionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ScriptExecution)
	if err != nil {
		return ScriptExecutionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ScriptExecutionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ScriptExecutionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ScriptExecutionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ScriptExecutionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ScriptExecutionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ScriptExecutionsDeleteResponse will be returned.
func (p *ScriptExecutionsDeletePoller) FinalResponse(ctx context.Context) (ScriptExecutionsDeleteResponse, error) {
	respType := ScriptExecutionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ScriptExecutionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ScriptExecutionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualMachinesRestrictMovementPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesRestrictMovementPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesRestrictMovementPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualMachinesRestrictMovementPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualMachinesRestrictMovementResponse will be returned.
func (p *VirtualMachinesRestrictMovementPoller) FinalResponse(ctx context.Context) (VirtualMachinesRestrictMovementResponse, error) {
	respType := VirtualMachinesRestrictMovementResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualMachinesRestrictMovementResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualMachinesRestrictMovementPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksCreateDNSServicePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksCreateDNSServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksCreateDNSServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksCreateDNSServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksCreateDNSServiceResponse will be returned.
func (p *WorkloadNetworksCreateDNSServicePoller) FinalResponse(ctx context.Context) (WorkloadNetworksCreateDNSServiceResponse, error) {
	respType := WorkloadNetworksCreateDNSServiceResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkDNSService)
	if err != nil {
		return WorkloadNetworksCreateDNSServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksCreateDNSServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksCreateDNSZonePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksCreateDNSZonePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksCreateDNSZonePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksCreateDNSZonePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksCreateDNSZoneResponse will be returned.
func (p *WorkloadNetworksCreateDNSZonePoller) FinalResponse(ctx context.Context) (WorkloadNetworksCreateDNSZoneResponse, error) {
	respType := WorkloadNetworksCreateDNSZoneResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkDNSZone)
	if err != nil {
		return WorkloadNetworksCreateDNSZoneResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksCreateDNSZonePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksCreateDhcpPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksCreateDhcpPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksCreateDhcpPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksCreateDhcpPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksCreateDhcpResponse will be returned.
func (p *WorkloadNetworksCreateDhcpPoller) FinalResponse(ctx context.Context) (WorkloadNetworksCreateDhcpResponse, error) {
	respType := WorkloadNetworksCreateDhcpResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkDhcp)
	if err != nil {
		return WorkloadNetworksCreateDhcpResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksCreateDhcpPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksCreatePortMirroringPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksCreatePortMirroringPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksCreatePortMirroringPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksCreatePortMirroringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksCreatePortMirroringResponse will be returned.
func (p *WorkloadNetworksCreatePortMirroringPoller) FinalResponse(ctx context.Context) (WorkloadNetworksCreatePortMirroringResponse, error) {
	respType := WorkloadNetworksCreatePortMirroringResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkPortMirroring)
	if err != nil {
		return WorkloadNetworksCreatePortMirroringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksCreatePortMirroringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksCreatePublicIPPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksCreatePublicIPPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksCreatePublicIPPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksCreatePublicIPPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksCreatePublicIPResponse will be returned.
func (p *WorkloadNetworksCreatePublicIPPoller) FinalResponse(ctx context.Context) (WorkloadNetworksCreatePublicIPResponse, error) {
	respType := WorkloadNetworksCreatePublicIPResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkPublicIP)
	if err != nil {
		return WorkloadNetworksCreatePublicIPResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksCreatePublicIPPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksCreateSegmentsPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksCreateSegmentsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksCreateSegmentsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksCreateSegmentsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksCreateSegmentsResponse will be returned.
func (p *WorkloadNetworksCreateSegmentsPoller) FinalResponse(ctx context.Context) (WorkloadNetworksCreateSegmentsResponse, error) {
	respType := WorkloadNetworksCreateSegmentsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkSegment)
	if err != nil {
		return WorkloadNetworksCreateSegmentsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksCreateSegmentsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksCreateVMGroupPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksCreateVMGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksCreateVMGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksCreateVMGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksCreateVMGroupResponse will be returned.
func (p *WorkloadNetworksCreateVMGroupPoller) FinalResponse(ctx context.Context) (WorkloadNetworksCreateVMGroupResponse, error) {
	respType := WorkloadNetworksCreateVMGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkVMGroup)
	if err != nil {
		return WorkloadNetworksCreateVMGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksCreateVMGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksDeleteDNSServicePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksDeleteDNSServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksDeleteDNSServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksDeleteDNSServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksDeleteDNSServiceResponse will be returned.
func (p *WorkloadNetworksDeleteDNSServicePoller) FinalResponse(ctx context.Context) (WorkloadNetworksDeleteDNSServiceResponse, error) {
	respType := WorkloadNetworksDeleteDNSServiceResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadNetworksDeleteDNSServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksDeleteDNSServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksDeleteDNSZonePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksDeleteDNSZonePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksDeleteDNSZonePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksDeleteDNSZonePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksDeleteDNSZoneResponse will be returned.
func (p *WorkloadNetworksDeleteDNSZonePoller) FinalResponse(ctx context.Context) (WorkloadNetworksDeleteDNSZoneResponse, error) {
	respType := WorkloadNetworksDeleteDNSZoneResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadNetworksDeleteDNSZoneResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksDeleteDNSZonePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksDeleteDhcpPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksDeleteDhcpPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksDeleteDhcpPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksDeleteDhcpPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksDeleteDhcpResponse will be returned.
func (p *WorkloadNetworksDeleteDhcpPoller) FinalResponse(ctx context.Context) (WorkloadNetworksDeleteDhcpResponse, error) {
	respType := WorkloadNetworksDeleteDhcpResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadNetworksDeleteDhcpResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksDeleteDhcpPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksDeletePortMirroringPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksDeletePortMirroringPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksDeletePortMirroringPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksDeletePortMirroringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksDeletePortMirroringResponse will be returned.
func (p *WorkloadNetworksDeletePortMirroringPoller) FinalResponse(ctx context.Context) (WorkloadNetworksDeletePortMirroringResponse, error) {
	respType := WorkloadNetworksDeletePortMirroringResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadNetworksDeletePortMirroringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksDeletePortMirroringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksDeletePublicIPPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksDeletePublicIPPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksDeletePublicIPPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksDeletePublicIPPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksDeletePublicIPResponse will be returned.
func (p *WorkloadNetworksDeletePublicIPPoller) FinalResponse(ctx context.Context) (WorkloadNetworksDeletePublicIPResponse, error) {
	respType := WorkloadNetworksDeletePublicIPResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadNetworksDeletePublicIPResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksDeletePublicIPPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksDeleteSegmentPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksDeleteSegmentPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksDeleteSegmentPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksDeleteSegmentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksDeleteSegmentResponse will be returned.
func (p *WorkloadNetworksDeleteSegmentPoller) FinalResponse(ctx context.Context) (WorkloadNetworksDeleteSegmentResponse, error) {
	respType := WorkloadNetworksDeleteSegmentResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadNetworksDeleteSegmentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksDeleteSegmentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksDeleteVMGroupPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksDeleteVMGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksDeleteVMGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksDeleteVMGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksDeleteVMGroupResponse will be returned.
func (p *WorkloadNetworksDeleteVMGroupPoller) FinalResponse(ctx context.Context) (WorkloadNetworksDeleteVMGroupResponse, error) {
	respType := WorkloadNetworksDeleteVMGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadNetworksDeleteVMGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksDeleteVMGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksUpdateDNSServicePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksUpdateDNSServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksUpdateDNSServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksUpdateDNSServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksUpdateDNSServiceResponse will be returned.
func (p *WorkloadNetworksUpdateDNSServicePoller) FinalResponse(ctx context.Context) (WorkloadNetworksUpdateDNSServiceResponse, error) {
	respType := WorkloadNetworksUpdateDNSServiceResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkDNSService)
	if err != nil {
		return WorkloadNetworksUpdateDNSServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksUpdateDNSServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksUpdateDNSZonePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksUpdateDNSZonePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksUpdateDNSZonePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksUpdateDNSZonePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksUpdateDNSZoneResponse will be returned.
func (p *WorkloadNetworksUpdateDNSZonePoller) FinalResponse(ctx context.Context) (WorkloadNetworksUpdateDNSZoneResponse, error) {
	respType := WorkloadNetworksUpdateDNSZoneResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkDNSZone)
	if err != nil {
		return WorkloadNetworksUpdateDNSZoneResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksUpdateDNSZonePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksUpdateDhcpPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksUpdateDhcpPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksUpdateDhcpPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksUpdateDhcpPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksUpdateDhcpResponse will be returned.
func (p *WorkloadNetworksUpdateDhcpPoller) FinalResponse(ctx context.Context) (WorkloadNetworksUpdateDhcpResponse, error) {
	respType := WorkloadNetworksUpdateDhcpResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkDhcp)
	if err != nil {
		return WorkloadNetworksUpdateDhcpResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksUpdateDhcpPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksUpdatePortMirroringPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksUpdatePortMirroringPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksUpdatePortMirroringPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksUpdatePortMirroringPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksUpdatePortMirroringResponse will be returned.
func (p *WorkloadNetworksUpdatePortMirroringPoller) FinalResponse(ctx context.Context) (WorkloadNetworksUpdatePortMirroringResponse, error) {
	respType := WorkloadNetworksUpdatePortMirroringResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkPortMirroring)
	if err != nil {
		return WorkloadNetworksUpdatePortMirroringResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksUpdatePortMirroringPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksUpdateSegmentsPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksUpdateSegmentsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksUpdateSegmentsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksUpdateSegmentsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksUpdateSegmentsResponse will be returned.
func (p *WorkloadNetworksUpdateSegmentsPoller) FinalResponse(ctx context.Context) (WorkloadNetworksUpdateSegmentsResponse, error) {
	respType := WorkloadNetworksUpdateSegmentsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkSegment)
	if err != nil {
		return WorkloadNetworksUpdateSegmentsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksUpdateSegmentsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadNetworksUpdateVMGroupPoller provides polling facilities until the operation reaches a terminal state.
type WorkloadNetworksUpdateVMGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadNetworksUpdateVMGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadNetworksUpdateVMGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadNetworksUpdateVMGroupResponse will be returned.
func (p *WorkloadNetworksUpdateVMGroupPoller) FinalResponse(ctx context.Context) (WorkloadNetworksUpdateVMGroupResponse, error) {
	respType := WorkloadNetworksUpdateVMGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadNetworkVMGroup)
	if err != nil {
		return WorkloadNetworksUpdateVMGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadNetworksUpdateVMGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
