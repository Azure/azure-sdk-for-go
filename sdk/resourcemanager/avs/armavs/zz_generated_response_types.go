//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armavs

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// AddonsCreateOrUpdatePollerResponse contains the response from method Addons.CreateOrUpdate.
type AddonsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AddonsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AddonsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AddonsCreateOrUpdateResponse, error) {
	respType := AddonsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Addon)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AddonsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AddonsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AddonsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AddonsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &AddonsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AddonsCreateOrUpdateResponse contains the response from method Addons.CreateOrUpdate.
type AddonsCreateOrUpdateResponse struct {
	AddonsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AddonsCreateOrUpdateResult contains the result from method Addons.CreateOrUpdate.
type AddonsCreateOrUpdateResult struct {
	Addon
}

// AddonsDeletePollerResponse contains the response from method Addons.Delete.
type AddonsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AddonsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AddonsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AddonsDeleteResponse, error) {
	respType := AddonsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AddonsDeletePollerResponse from the provided client and resume token.
func (l *AddonsDeletePollerResponse) Resume(ctx context.Context, client *AddonsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AddonsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AddonsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AddonsDeleteResponse contains the response from method Addons.Delete.
type AddonsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AddonsGetResponse contains the response from method Addons.Get.
type AddonsGetResponse struct {
	AddonsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AddonsGetResult contains the result from method Addons.Get.
type AddonsGetResult struct {
	Addon
}

// AddonsListResponse contains the response from method Addons.List.
type AddonsListResponse struct {
	AddonsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AddonsListResult contains the result from method Addons.List.
type AddonsListResult struct {
	AddonList
}

// AuthorizationsCreateOrUpdatePollerResponse contains the response from method Authorizations.CreateOrUpdate.
type AuthorizationsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AuthorizationsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AuthorizationsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AuthorizationsCreateOrUpdateResponse, error) {
	respType := AuthorizationsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteAuthorization)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AuthorizationsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AuthorizationsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AuthorizationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AuthorizationsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &AuthorizationsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AuthorizationsCreateOrUpdateResponse contains the response from method Authorizations.CreateOrUpdate.
type AuthorizationsCreateOrUpdateResponse struct {
	AuthorizationsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AuthorizationsCreateOrUpdateResult contains the result from method Authorizations.CreateOrUpdate.
type AuthorizationsCreateOrUpdateResult struct {
	ExpressRouteAuthorization
}

// AuthorizationsDeletePollerResponse contains the response from method Authorizations.Delete.
type AuthorizationsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AuthorizationsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AuthorizationsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AuthorizationsDeleteResponse, error) {
	respType := AuthorizationsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AuthorizationsDeletePollerResponse from the provided client and resume token.
func (l *AuthorizationsDeletePollerResponse) Resume(ctx context.Context, client *AuthorizationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AuthorizationsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AuthorizationsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AuthorizationsDeleteResponse contains the response from method Authorizations.Delete.
type AuthorizationsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AuthorizationsGetResponse contains the response from method Authorizations.Get.
type AuthorizationsGetResponse struct {
	AuthorizationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AuthorizationsGetResult contains the result from method Authorizations.Get.
type AuthorizationsGetResult struct {
	ExpressRouteAuthorization
}

// AuthorizationsListResponse contains the response from method Authorizations.List.
type AuthorizationsListResponse struct {
	AuthorizationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AuthorizationsListResult contains the result from method Authorizations.List.
type AuthorizationsListResult struct {
	ExpressRouteAuthorizationList
}

// CloudLinksCreateOrUpdatePollerResponse contains the response from method CloudLinks.CreateOrUpdate.
type CloudLinksCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CloudLinksCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CloudLinksCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CloudLinksCreateOrUpdateResponse, error) {
	respType := CloudLinksCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CloudLink)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CloudLinksCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *CloudLinksCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *CloudLinksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CloudLinksClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &CloudLinksCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CloudLinksCreateOrUpdateResponse contains the response from method CloudLinks.CreateOrUpdate.
type CloudLinksCreateOrUpdateResponse struct {
	CloudLinksCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CloudLinksCreateOrUpdateResult contains the result from method CloudLinks.CreateOrUpdate.
type CloudLinksCreateOrUpdateResult struct {
	CloudLink
}

// CloudLinksDeletePollerResponse contains the response from method CloudLinks.Delete.
type CloudLinksDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CloudLinksDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CloudLinksDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CloudLinksDeleteResponse, error) {
	respType := CloudLinksDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CloudLinksDeletePollerResponse from the provided client and resume token.
func (l *CloudLinksDeletePollerResponse) Resume(ctx context.Context, client *CloudLinksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CloudLinksClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &CloudLinksDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CloudLinksDeleteResponse contains the response from method CloudLinks.Delete.
type CloudLinksDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CloudLinksGetResponse contains the response from method CloudLinks.Get.
type CloudLinksGetResponse struct {
	CloudLinksGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CloudLinksGetResult contains the result from method CloudLinks.Get.
type CloudLinksGetResult struct {
	CloudLink
}

// CloudLinksListResponse contains the response from method CloudLinks.List.
type CloudLinksListResponse struct {
	CloudLinksListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CloudLinksListResult contains the result from method CloudLinks.List.
type CloudLinksListResult struct {
	CloudLinkList
}

// ClustersCreateOrUpdatePollerResponse contains the response from method Clusters.CreateOrUpdate.
type ClustersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersCreateOrUpdateResponse, error) {
	respType := ClustersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Cluster)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ClustersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ClustersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersCreateOrUpdateResponse contains the response from method Clusters.CreateOrUpdate.
type ClustersCreateOrUpdateResponse struct {
	ClustersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersCreateOrUpdateResult contains the result from method Clusters.CreateOrUpdate.
type ClustersCreateOrUpdateResult struct {
	Cluster
}

// ClustersDeletePollerResponse contains the response from method Clusters.Delete.
type ClustersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersDeleteResponse, error) {
	respType := ClustersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersDeletePollerResponse from the provided client and resume token.
func (l *ClustersDeletePollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ClustersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersDeleteResponse contains the response from method Clusters.Delete.
type ClustersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersGetResponse contains the response from method Clusters.Get.
type ClustersGetResponse struct {
	ClustersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersGetResult contains the result from method Clusters.Get.
type ClustersGetResult struct {
	Cluster
}

// ClustersListResponse contains the response from method Clusters.List.
type ClustersListResponse struct {
	ClustersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersListResult contains the result from method Clusters.List.
type ClustersListResult struct {
	ClusterList
}

// ClustersUpdatePollerResponse contains the response from method Clusters.Update.
type ClustersUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ClustersUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ClustersUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ClustersUpdateResponse, error) {
	respType := ClustersUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Cluster)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ClustersUpdatePollerResponse from the provided client and resume token.
func (l *ClustersUpdatePollerResponse) Resume(ctx context.Context, client *ClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ClustersClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ClustersUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ClustersUpdateResponse contains the response from method Clusters.Update.
type ClustersUpdateResponse struct {
	ClustersUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ClustersUpdateResult contains the result from method Clusters.Update.
type ClustersUpdateResult struct {
	Cluster
}

// DatastoresCreateOrUpdatePollerResponse contains the response from method Datastores.CreateOrUpdate.
type DatastoresCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatastoresCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatastoresCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatastoresCreateOrUpdateResponse, error) {
	respType := DatastoresCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Datastore)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatastoresCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DatastoresCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DatastoresClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatastoresClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DatastoresCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatastoresCreateOrUpdateResponse contains the response from method Datastores.CreateOrUpdate.
type DatastoresCreateOrUpdateResponse struct {
	DatastoresCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatastoresCreateOrUpdateResult contains the result from method Datastores.CreateOrUpdate.
type DatastoresCreateOrUpdateResult struct {
	Datastore
}

// DatastoresDeletePollerResponse contains the response from method Datastores.Delete.
type DatastoresDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatastoresDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatastoresDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatastoresDeleteResponse, error) {
	respType := DatastoresDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatastoresDeletePollerResponse from the provided client and resume token.
func (l *DatastoresDeletePollerResponse) Resume(ctx context.Context, client *DatastoresClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatastoresClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DatastoresDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatastoresDeleteResponse contains the response from method Datastores.Delete.
type DatastoresDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatastoresGetResponse contains the response from method Datastores.Get.
type DatastoresGetResponse struct {
	DatastoresGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatastoresGetResult contains the result from method Datastores.Get.
type DatastoresGetResult struct {
	Datastore
}

// DatastoresListResponse contains the response from method Datastores.List.
type DatastoresListResponse struct {
	DatastoresListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatastoresListResult contains the result from method Datastores.List.
type DatastoresListResult struct {
	DatastoreList
}

// GlobalReachConnectionsCreateOrUpdatePollerResponse contains the response from method GlobalReachConnections.CreateOrUpdate.
type GlobalReachConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GlobalReachConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GlobalReachConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GlobalReachConnectionsCreateOrUpdateResponse, error) {
	respType := GlobalReachConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GlobalReachConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GlobalReachConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *GlobalReachConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *GlobalReachConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GlobalReachConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &GlobalReachConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GlobalReachConnectionsCreateOrUpdateResponse contains the response from method GlobalReachConnections.CreateOrUpdate.
type GlobalReachConnectionsCreateOrUpdateResponse struct {
	GlobalReachConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GlobalReachConnectionsCreateOrUpdateResult contains the result from method GlobalReachConnections.CreateOrUpdate.
type GlobalReachConnectionsCreateOrUpdateResult struct {
	GlobalReachConnection
}

// GlobalReachConnectionsDeletePollerResponse contains the response from method GlobalReachConnections.Delete.
type GlobalReachConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GlobalReachConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GlobalReachConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GlobalReachConnectionsDeleteResponse, error) {
	respType := GlobalReachConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GlobalReachConnectionsDeletePollerResponse from the provided client and resume token.
func (l *GlobalReachConnectionsDeletePollerResponse) Resume(ctx context.Context, client *GlobalReachConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GlobalReachConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &GlobalReachConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GlobalReachConnectionsDeleteResponse contains the response from method GlobalReachConnections.Delete.
type GlobalReachConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GlobalReachConnectionsGetResponse contains the response from method GlobalReachConnections.Get.
type GlobalReachConnectionsGetResponse struct {
	GlobalReachConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GlobalReachConnectionsGetResult contains the result from method GlobalReachConnections.Get.
type GlobalReachConnectionsGetResult struct {
	GlobalReachConnection
}

// GlobalReachConnectionsListResponse contains the response from method GlobalReachConnections.List.
type GlobalReachConnectionsListResponse struct {
	GlobalReachConnectionsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GlobalReachConnectionsListResult contains the result from method GlobalReachConnections.List.
type GlobalReachConnectionsListResult struct {
	GlobalReachConnectionList
}

// HcxEnterpriseSitesCreateOrUpdateResponse contains the response from method HcxEnterpriseSites.CreateOrUpdate.
type HcxEnterpriseSitesCreateOrUpdateResponse struct {
	HcxEnterpriseSitesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HcxEnterpriseSitesCreateOrUpdateResult contains the result from method HcxEnterpriseSites.CreateOrUpdate.
type HcxEnterpriseSitesCreateOrUpdateResult struct {
	HcxEnterpriseSite
}

// HcxEnterpriseSitesDeleteResponse contains the response from method HcxEnterpriseSites.Delete.
type HcxEnterpriseSitesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HcxEnterpriseSitesGetResponse contains the response from method HcxEnterpriseSites.Get.
type HcxEnterpriseSitesGetResponse struct {
	HcxEnterpriseSitesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HcxEnterpriseSitesGetResult contains the result from method HcxEnterpriseSites.Get.
type HcxEnterpriseSitesGetResult struct {
	HcxEnterpriseSite
}

// HcxEnterpriseSitesListResponse contains the response from method HcxEnterpriseSites.List.
type HcxEnterpriseSitesListResponse struct {
	HcxEnterpriseSitesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HcxEnterpriseSitesListResult contains the result from method HcxEnterpriseSites.List.
type HcxEnterpriseSitesListResult struct {
	HcxEnterpriseSiteList
}

// LocationsCheckQuotaAvailabilityResponse contains the response from method Locations.CheckQuotaAvailability.
type LocationsCheckQuotaAvailabilityResponse struct {
	LocationsCheckQuotaAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocationsCheckQuotaAvailabilityResult contains the result from method Locations.CheckQuotaAvailability.
type LocationsCheckQuotaAvailabilityResult struct {
	Quota
}

// LocationsCheckTrialAvailabilityResponse contains the response from method Locations.CheckTrialAvailability.
type LocationsCheckTrialAvailabilityResponse struct {
	LocationsCheckTrialAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocationsCheckTrialAvailabilityResult contains the result from method Locations.CheckTrialAvailability.
type LocationsCheckTrialAvailabilityResult struct {
	Trial
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationList
}

// PlacementPoliciesCreateOrUpdatePollerResponse contains the response from method PlacementPolicies.CreateOrUpdate.
type PlacementPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PlacementPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PlacementPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PlacementPoliciesCreateOrUpdateResponse, error) {
	respType := PlacementPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PlacementPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PlacementPoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PlacementPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PlacementPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PlacementPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PlacementPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PlacementPoliciesCreateOrUpdateResponse contains the response from method PlacementPolicies.CreateOrUpdate.
type PlacementPoliciesCreateOrUpdateResponse struct {
	PlacementPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PlacementPoliciesCreateOrUpdateResult contains the result from method PlacementPolicies.CreateOrUpdate.
type PlacementPoliciesCreateOrUpdateResult struct {
	PlacementPolicy
}

// PlacementPoliciesDeletePollerResponse contains the response from method PlacementPolicies.Delete.
type PlacementPoliciesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PlacementPoliciesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PlacementPoliciesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PlacementPoliciesDeleteResponse, error) {
	respType := PlacementPoliciesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PlacementPoliciesDeletePollerResponse from the provided client and resume token.
func (l *PlacementPoliciesDeletePollerResponse) Resume(ctx context.Context, client *PlacementPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PlacementPoliciesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PlacementPoliciesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PlacementPoliciesDeleteResponse contains the response from method PlacementPolicies.Delete.
type PlacementPoliciesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PlacementPoliciesGetResponse contains the response from method PlacementPolicies.Get.
type PlacementPoliciesGetResponse struct {
	PlacementPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PlacementPoliciesGetResult contains the result from method PlacementPolicies.Get.
type PlacementPoliciesGetResult struct {
	PlacementPolicy
}

// PlacementPoliciesListResponse contains the response from method PlacementPolicies.List.
type PlacementPoliciesListResponse struct {
	PlacementPoliciesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PlacementPoliciesListResult contains the result from method PlacementPolicies.List.
type PlacementPoliciesListResult struct {
	PlacementPoliciesList
}

// PlacementPoliciesUpdatePollerResponse contains the response from method PlacementPolicies.Update.
type PlacementPoliciesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PlacementPoliciesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PlacementPoliciesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PlacementPoliciesUpdateResponse, error) {
	respType := PlacementPoliciesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PlacementPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PlacementPoliciesUpdatePollerResponse from the provided client and resume token.
func (l *PlacementPoliciesUpdatePollerResponse) Resume(ctx context.Context, client *PlacementPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PlacementPoliciesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &PlacementPoliciesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PlacementPoliciesUpdateResponse contains the response from method PlacementPolicies.Update.
type PlacementPoliciesUpdateResponse struct {
	PlacementPoliciesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PlacementPoliciesUpdateResult contains the result from method PlacementPolicies.Update.
type PlacementPoliciesUpdateResult struct {
	PlacementPolicy
}

// PrivateCloudsCreateOrUpdatePollerResponse contains the response from method PrivateClouds.CreateOrUpdate.
type PrivateCloudsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateCloudsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateCloudsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateCloudsCreateOrUpdateResponse, error) {
	respType := PrivateCloudsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateCloud)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateCloudsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateCloudsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateCloudsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateCloudsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateCloudsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateCloudsCreateOrUpdateResponse contains the response from method PrivateClouds.CreateOrUpdate.
type PrivateCloudsCreateOrUpdateResponse struct {
	PrivateCloudsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateCloudsCreateOrUpdateResult contains the result from method PrivateClouds.CreateOrUpdate.
type PrivateCloudsCreateOrUpdateResult struct {
	PrivateCloud
}

// PrivateCloudsDeletePollerResponse contains the response from method PrivateClouds.Delete.
type PrivateCloudsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateCloudsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateCloudsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateCloudsDeleteResponse, error) {
	respType := PrivateCloudsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateCloudsDeletePollerResponse from the provided client and resume token.
func (l *PrivateCloudsDeletePollerResponse) Resume(ctx context.Context, client *PrivateCloudsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateCloudsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateCloudsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateCloudsDeleteResponse contains the response from method PrivateClouds.Delete.
type PrivateCloudsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateCloudsGetResponse contains the response from method PrivateClouds.Get.
type PrivateCloudsGetResponse struct {
	PrivateCloudsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateCloudsGetResult contains the result from method PrivateClouds.Get.
type PrivateCloudsGetResult struct {
	PrivateCloud
}

// PrivateCloudsListAdminCredentialsResponse contains the response from method PrivateClouds.ListAdminCredentials.
type PrivateCloudsListAdminCredentialsResponse struct {
	PrivateCloudsListAdminCredentialsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateCloudsListAdminCredentialsResult contains the result from method PrivateClouds.ListAdminCredentials.
type PrivateCloudsListAdminCredentialsResult struct {
	AdminCredentials
}

// PrivateCloudsListInSubscriptionResponse contains the response from method PrivateClouds.ListInSubscription.
type PrivateCloudsListInSubscriptionResponse struct {
	PrivateCloudsListInSubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateCloudsListInSubscriptionResult contains the result from method PrivateClouds.ListInSubscription.
type PrivateCloudsListInSubscriptionResult struct {
	PrivateCloudList
}

// PrivateCloudsListResponse contains the response from method PrivateClouds.List.
type PrivateCloudsListResponse struct {
	PrivateCloudsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateCloudsListResult contains the result from method PrivateClouds.List.
type PrivateCloudsListResult struct {
	PrivateCloudList
}

// PrivateCloudsRotateNsxtPasswordPollerResponse contains the response from method PrivateClouds.RotateNsxtPassword.
type PrivateCloudsRotateNsxtPasswordPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateCloudsRotateNsxtPasswordPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateCloudsRotateNsxtPasswordPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateCloudsRotateNsxtPasswordResponse, error) {
	respType := PrivateCloudsRotateNsxtPasswordResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateCloudsRotateNsxtPasswordPollerResponse from the provided client and resume token.
func (l *PrivateCloudsRotateNsxtPasswordPollerResponse) Resume(ctx context.Context, client *PrivateCloudsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateCloudsClient.RotateNsxtPassword", token, client.pl, client.rotateNsxtPasswordHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateCloudsRotateNsxtPasswordPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateCloudsRotateNsxtPasswordResponse contains the response from method PrivateClouds.RotateNsxtPassword.
type PrivateCloudsRotateNsxtPasswordResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateCloudsRotateVcenterPasswordPollerResponse contains the response from method PrivateClouds.RotateVcenterPassword.
type PrivateCloudsRotateVcenterPasswordPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateCloudsRotateVcenterPasswordPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateCloudsRotateVcenterPasswordPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateCloudsRotateVcenterPasswordResponse, error) {
	respType := PrivateCloudsRotateVcenterPasswordResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateCloudsRotateVcenterPasswordPollerResponse from the provided client and resume token.
func (l *PrivateCloudsRotateVcenterPasswordPollerResponse) Resume(ctx context.Context, client *PrivateCloudsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateCloudsClient.RotateVcenterPassword", token, client.pl, client.rotateVcenterPasswordHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateCloudsRotateVcenterPasswordPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateCloudsRotateVcenterPasswordResponse contains the response from method PrivateClouds.RotateVcenterPassword.
type PrivateCloudsRotateVcenterPasswordResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateCloudsUpdatePollerResponse contains the response from method PrivateClouds.Update.
type PrivateCloudsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateCloudsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateCloudsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateCloudsUpdateResponse, error) {
	respType := PrivateCloudsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateCloud)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateCloudsUpdatePollerResponse from the provided client and resume token.
func (l *PrivateCloudsUpdatePollerResponse) Resume(ctx context.Context, client *PrivateCloudsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateCloudsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateCloudsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateCloudsUpdateResponse contains the response from method PrivateClouds.Update.
type PrivateCloudsUpdateResponse struct {
	PrivateCloudsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateCloudsUpdateResult contains the result from method PrivateClouds.Update.
type PrivateCloudsUpdateResult struct {
	PrivateCloud
}

// ScriptCmdletsGetResponse contains the response from method ScriptCmdlets.Get.
type ScriptCmdletsGetResponse struct {
	ScriptCmdletsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptCmdletsGetResult contains the result from method ScriptCmdlets.Get.
type ScriptCmdletsGetResult struct {
	ScriptCmdlet
}

// ScriptCmdletsListResponse contains the response from method ScriptCmdlets.List.
type ScriptCmdletsListResponse struct {
	ScriptCmdletsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptCmdletsListResult contains the result from method ScriptCmdlets.List.
type ScriptCmdletsListResult struct {
	ScriptCmdletsList
}

// ScriptExecutionsCreateOrUpdatePollerResponse contains the response from method ScriptExecutions.CreateOrUpdate.
type ScriptExecutionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ScriptExecutionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ScriptExecutionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ScriptExecutionsCreateOrUpdateResponse, error) {
	respType := ScriptExecutionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ScriptExecution)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ScriptExecutionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ScriptExecutionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ScriptExecutionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ScriptExecutionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ScriptExecutionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ScriptExecutionsCreateOrUpdateResponse contains the response from method ScriptExecutions.CreateOrUpdate.
type ScriptExecutionsCreateOrUpdateResponse struct {
	ScriptExecutionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptExecutionsCreateOrUpdateResult contains the result from method ScriptExecutions.CreateOrUpdate.
type ScriptExecutionsCreateOrUpdateResult struct {
	ScriptExecution
}

// ScriptExecutionsDeletePollerResponse contains the response from method ScriptExecutions.Delete.
type ScriptExecutionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ScriptExecutionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ScriptExecutionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ScriptExecutionsDeleteResponse, error) {
	respType := ScriptExecutionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ScriptExecutionsDeletePollerResponse from the provided client and resume token.
func (l *ScriptExecutionsDeletePollerResponse) Resume(ctx context.Context, client *ScriptExecutionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ScriptExecutionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ScriptExecutionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ScriptExecutionsDeleteResponse contains the response from method ScriptExecutions.Delete.
type ScriptExecutionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptExecutionsGetExecutionLogsResponse contains the response from method ScriptExecutions.GetExecutionLogs.
type ScriptExecutionsGetExecutionLogsResponse struct {
	ScriptExecutionsGetExecutionLogsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptExecutionsGetExecutionLogsResult contains the result from method ScriptExecutions.GetExecutionLogs.
type ScriptExecutionsGetExecutionLogsResult struct {
	ScriptExecution
}

// ScriptExecutionsGetResponse contains the response from method ScriptExecutions.Get.
type ScriptExecutionsGetResponse struct {
	ScriptExecutionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptExecutionsGetResult contains the result from method ScriptExecutions.Get.
type ScriptExecutionsGetResult struct {
	ScriptExecution
}

// ScriptExecutionsListResponse contains the response from method ScriptExecutions.List.
type ScriptExecutionsListResponse struct {
	ScriptExecutionsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptExecutionsListResult contains the result from method ScriptExecutions.List.
type ScriptExecutionsListResult struct {
	ScriptExecutionsList
}

// ScriptPackagesGetResponse contains the response from method ScriptPackages.Get.
type ScriptPackagesGetResponse struct {
	ScriptPackagesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptPackagesGetResult contains the result from method ScriptPackages.Get.
type ScriptPackagesGetResult struct {
	ScriptPackage
}

// ScriptPackagesListResponse contains the response from method ScriptPackages.List.
type ScriptPackagesListResponse struct {
	ScriptPackagesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ScriptPackagesListResult contains the result from method ScriptPackages.List.
type ScriptPackagesListResult struct {
	ScriptPackagesList
}

// VirtualMachinesGetResponse contains the response from method VirtualMachines.Get.
type VirtualMachinesGetResponse struct {
	VirtualMachinesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesGetResult contains the result from method VirtualMachines.Get.
type VirtualMachinesGetResult struct {
	VirtualMachine
}

// VirtualMachinesListResponse contains the response from method VirtualMachines.List.
type VirtualMachinesListResponse struct {
	VirtualMachinesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesListResult contains the result from method VirtualMachines.List.
type VirtualMachinesListResult struct {
	VirtualMachinesList
}

// VirtualMachinesRestrictMovementPollerResponse contains the response from method VirtualMachines.RestrictMovement.
type VirtualMachinesRestrictMovementPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesRestrictMovementPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesRestrictMovementPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesRestrictMovementResponse, error) {
	respType := VirtualMachinesRestrictMovementResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesRestrictMovementPollerResponse from the provided client and resume token.
func (l *VirtualMachinesRestrictMovementPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.RestrictMovement", token, client.pl, client.restrictMovementHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesRestrictMovementPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesRestrictMovementResponse contains the response from method VirtualMachines.RestrictMovement.
type VirtualMachinesRestrictMovementResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksCreateDNSServicePollerResponse contains the response from method WorkloadNetworks.CreateDNSService.
type WorkloadNetworksCreateDNSServicePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksCreateDNSServicePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksCreateDNSServicePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksCreateDNSServiceResponse, error) {
	respType := WorkloadNetworksCreateDNSServiceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkDNSService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksCreateDNSServicePollerResponse from the provided client and resume token.
func (l *WorkloadNetworksCreateDNSServicePollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.CreateDNSService", token, client.pl, client.createDNSServiceHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksCreateDNSServicePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksCreateDNSServiceResponse contains the response from method WorkloadNetworks.CreateDNSService.
type WorkloadNetworksCreateDNSServiceResponse struct {
	WorkloadNetworksCreateDNSServiceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksCreateDNSServiceResult contains the result from method WorkloadNetworks.CreateDNSService.
type WorkloadNetworksCreateDNSServiceResult struct {
	WorkloadNetworkDNSService
}

// WorkloadNetworksCreateDNSZonePollerResponse contains the response from method WorkloadNetworks.CreateDNSZone.
type WorkloadNetworksCreateDNSZonePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksCreateDNSZonePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksCreateDNSZonePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksCreateDNSZoneResponse, error) {
	respType := WorkloadNetworksCreateDNSZoneResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkDNSZone)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksCreateDNSZonePollerResponse from the provided client and resume token.
func (l *WorkloadNetworksCreateDNSZonePollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.CreateDNSZone", token, client.pl, client.createDNSZoneHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksCreateDNSZonePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksCreateDNSZoneResponse contains the response from method WorkloadNetworks.CreateDNSZone.
type WorkloadNetworksCreateDNSZoneResponse struct {
	WorkloadNetworksCreateDNSZoneResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksCreateDNSZoneResult contains the result from method WorkloadNetworks.CreateDNSZone.
type WorkloadNetworksCreateDNSZoneResult struct {
	WorkloadNetworkDNSZone
}

// WorkloadNetworksCreateDhcpPollerResponse contains the response from method WorkloadNetworks.CreateDhcp.
type WorkloadNetworksCreateDhcpPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksCreateDhcpPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksCreateDhcpPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksCreateDhcpResponse, error) {
	respType := WorkloadNetworksCreateDhcpResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkDhcp)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksCreateDhcpPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksCreateDhcpPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.CreateDhcp", token, client.pl, client.createDhcpHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksCreateDhcpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksCreateDhcpResponse contains the response from method WorkloadNetworks.CreateDhcp.
type WorkloadNetworksCreateDhcpResponse struct {
	WorkloadNetworksCreateDhcpResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksCreateDhcpResult contains the result from method WorkloadNetworks.CreateDhcp.
type WorkloadNetworksCreateDhcpResult struct {
	WorkloadNetworkDhcp
}

// WorkloadNetworksCreatePortMirroringPollerResponse contains the response from method WorkloadNetworks.CreatePortMirroring.
type WorkloadNetworksCreatePortMirroringPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksCreatePortMirroringPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksCreatePortMirroringPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksCreatePortMirroringResponse, error) {
	respType := WorkloadNetworksCreatePortMirroringResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkPortMirroring)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksCreatePortMirroringPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksCreatePortMirroringPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.CreatePortMirroring", token, client.pl, client.createPortMirroringHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksCreatePortMirroringPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksCreatePortMirroringResponse contains the response from method WorkloadNetworks.CreatePortMirroring.
type WorkloadNetworksCreatePortMirroringResponse struct {
	WorkloadNetworksCreatePortMirroringResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksCreatePortMirroringResult contains the result from method WorkloadNetworks.CreatePortMirroring.
type WorkloadNetworksCreatePortMirroringResult struct {
	WorkloadNetworkPortMirroring
}

// WorkloadNetworksCreatePublicIPPollerResponse contains the response from method WorkloadNetworks.CreatePublicIP.
type WorkloadNetworksCreatePublicIPPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksCreatePublicIPPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksCreatePublicIPPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksCreatePublicIPResponse, error) {
	respType := WorkloadNetworksCreatePublicIPResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkPublicIP)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksCreatePublicIPPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksCreatePublicIPPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.CreatePublicIP", token, client.pl, client.createPublicIPHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksCreatePublicIPPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksCreatePublicIPResponse contains the response from method WorkloadNetworks.CreatePublicIP.
type WorkloadNetworksCreatePublicIPResponse struct {
	WorkloadNetworksCreatePublicIPResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksCreatePublicIPResult contains the result from method WorkloadNetworks.CreatePublicIP.
type WorkloadNetworksCreatePublicIPResult struct {
	WorkloadNetworkPublicIP
}

// WorkloadNetworksCreateSegmentsPollerResponse contains the response from method WorkloadNetworks.CreateSegments.
type WorkloadNetworksCreateSegmentsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksCreateSegmentsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksCreateSegmentsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksCreateSegmentsResponse, error) {
	respType := WorkloadNetworksCreateSegmentsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkSegment)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksCreateSegmentsPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksCreateSegmentsPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.CreateSegments", token, client.pl, client.createSegmentsHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksCreateSegmentsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksCreateSegmentsResponse contains the response from method WorkloadNetworks.CreateSegments.
type WorkloadNetworksCreateSegmentsResponse struct {
	WorkloadNetworksCreateSegmentsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksCreateSegmentsResult contains the result from method WorkloadNetworks.CreateSegments.
type WorkloadNetworksCreateSegmentsResult struct {
	WorkloadNetworkSegment
}

// WorkloadNetworksCreateVMGroupPollerResponse contains the response from method WorkloadNetworks.CreateVMGroup.
type WorkloadNetworksCreateVMGroupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksCreateVMGroupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksCreateVMGroupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksCreateVMGroupResponse, error) {
	respType := WorkloadNetworksCreateVMGroupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkVMGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksCreateVMGroupPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksCreateVMGroupPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.CreateVMGroup", token, client.pl, client.createVMGroupHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksCreateVMGroupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksCreateVMGroupResponse contains the response from method WorkloadNetworks.CreateVMGroup.
type WorkloadNetworksCreateVMGroupResponse struct {
	WorkloadNetworksCreateVMGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksCreateVMGroupResult contains the result from method WorkloadNetworks.CreateVMGroup.
type WorkloadNetworksCreateVMGroupResult struct {
	WorkloadNetworkVMGroup
}

// WorkloadNetworksDeleteDNSServicePollerResponse contains the response from method WorkloadNetworks.DeleteDNSService.
type WorkloadNetworksDeleteDNSServicePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksDeleteDNSServicePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksDeleteDNSServicePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksDeleteDNSServiceResponse, error) {
	respType := WorkloadNetworksDeleteDNSServiceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksDeleteDNSServicePollerResponse from the provided client and resume token.
func (l *WorkloadNetworksDeleteDNSServicePollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.DeleteDNSService", token, client.pl, client.deleteDNSServiceHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksDeleteDNSServicePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksDeleteDNSServiceResponse contains the response from method WorkloadNetworks.DeleteDNSService.
type WorkloadNetworksDeleteDNSServiceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksDeleteDNSZonePollerResponse contains the response from method WorkloadNetworks.DeleteDNSZone.
type WorkloadNetworksDeleteDNSZonePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksDeleteDNSZonePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksDeleteDNSZonePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksDeleteDNSZoneResponse, error) {
	respType := WorkloadNetworksDeleteDNSZoneResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksDeleteDNSZonePollerResponse from the provided client and resume token.
func (l *WorkloadNetworksDeleteDNSZonePollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.DeleteDNSZone", token, client.pl, client.deleteDNSZoneHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksDeleteDNSZonePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksDeleteDNSZoneResponse contains the response from method WorkloadNetworks.DeleteDNSZone.
type WorkloadNetworksDeleteDNSZoneResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksDeleteDhcpPollerResponse contains the response from method WorkloadNetworks.DeleteDhcp.
type WorkloadNetworksDeleteDhcpPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksDeleteDhcpPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksDeleteDhcpPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksDeleteDhcpResponse, error) {
	respType := WorkloadNetworksDeleteDhcpResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksDeleteDhcpPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksDeleteDhcpPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.DeleteDhcp", token, client.pl, client.deleteDhcpHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksDeleteDhcpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksDeleteDhcpResponse contains the response from method WorkloadNetworks.DeleteDhcp.
type WorkloadNetworksDeleteDhcpResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksDeletePortMirroringPollerResponse contains the response from method WorkloadNetworks.DeletePortMirroring.
type WorkloadNetworksDeletePortMirroringPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksDeletePortMirroringPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksDeletePortMirroringPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksDeletePortMirroringResponse, error) {
	respType := WorkloadNetworksDeletePortMirroringResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksDeletePortMirroringPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksDeletePortMirroringPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.DeletePortMirroring", token, client.pl, client.deletePortMirroringHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksDeletePortMirroringPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksDeletePortMirroringResponse contains the response from method WorkloadNetworks.DeletePortMirroring.
type WorkloadNetworksDeletePortMirroringResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksDeletePublicIPPollerResponse contains the response from method WorkloadNetworks.DeletePublicIP.
type WorkloadNetworksDeletePublicIPPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksDeletePublicIPPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksDeletePublicIPPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksDeletePublicIPResponse, error) {
	respType := WorkloadNetworksDeletePublicIPResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksDeletePublicIPPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksDeletePublicIPPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.DeletePublicIP", token, client.pl, client.deletePublicIPHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksDeletePublicIPPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksDeletePublicIPResponse contains the response from method WorkloadNetworks.DeletePublicIP.
type WorkloadNetworksDeletePublicIPResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksDeleteSegmentPollerResponse contains the response from method WorkloadNetworks.DeleteSegment.
type WorkloadNetworksDeleteSegmentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksDeleteSegmentPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksDeleteSegmentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksDeleteSegmentResponse, error) {
	respType := WorkloadNetworksDeleteSegmentResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksDeleteSegmentPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksDeleteSegmentPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.DeleteSegment", token, client.pl, client.deleteSegmentHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksDeleteSegmentPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksDeleteSegmentResponse contains the response from method WorkloadNetworks.DeleteSegment.
type WorkloadNetworksDeleteSegmentResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksDeleteVMGroupPollerResponse contains the response from method WorkloadNetworks.DeleteVMGroup.
type WorkloadNetworksDeleteVMGroupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksDeleteVMGroupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksDeleteVMGroupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksDeleteVMGroupResponse, error) {
	respType := WorkloadNetworksDeleteVMGroupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksDeleteVMGroupPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksDeleteVMGroupPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.DeleteVMGroup", token, client.pl, client.deleteVMGroupHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksDeleteVMGroupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksDeleteVMGroupResponse contains the response from method WorkloadNetworks.DeleteVMGroup.
type WorkloadNetworksDeleteVMGroupResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksGetDNSServiceResponse contains the response from method WorkloadNetworks.GetDNSService.
type WorkloadNetworksGetDNSServiceResponse struct {
	WorkloadNetworksGetDNSServiceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksGetDNSServiceResult contains the result from method WorkloadNetworks.GetDNSService.
type WorkloadNetworksGetDNSServiceResult struct {
	WorkloadNetworkDNSService
}

// WorkloadNetworksGetDNSZoneResponse contains the response from method WorkloadNetworks.GetDNSZone.
type WorkloadNetworksGetDNSZoneResponse struct {
	WorkloadNetworksGetDNSZoneResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksGetDNSZoneResult contains the result from method WorkloadNetworks.GetDNSZone.
type WorkloadNetworksGetDNSZoneResult struct {
	WorkloadNetworkDNSZone
}

// WorkloadNetworksGetDhcpResponse contains the response from method WorkloadNetworks.GetDhcp.
type WorkloadNetworksGetDhcpResponse struct {
	WorkloadNetworksGetDhcpResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksGetDhcpResult contains the result from method WorkloadNetworks.GetDhcp.
type WorkloadNetworksGetDhcpResult struct {
	WorkloadNetworkDhcp
}

// WorkloadNetworksGetGatewayResponse contains the response from method WorkloadNetworks.GetGateway.
type WorkloadNetworksGetGatewayResponse struct {
	WorkloadNetworksGetGatewayResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksGetGatewayResult contains the result from method WorkloadNetworks.GetGateway.
type WorkloadNetworksGetGatewayResult struct {
	WorkloadNetworkGateway
}

// WorkloadNetworksGetPortMirroringResponse contains the response from method WorkloadNetworks.GetPortMirroring.
type WorkloadNetworksGetPortMirroringResponse struct {
	WorkloadNetworksGetPortMirroringResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksGetPortMirroringResult contains the result from method WorkloadNetworks.GetPortMirroring.
type WorkloadNetworksGetPortMirroringResult struct {
	WorkloadNetworkPortMirroring
}

// WorkloadNetworksGetPublicIPResponse contains the response from method WorkloadNetworks.GetPublicIP.
type WorkloadNetworksGetPublicIPResponse struct {
	WorkloadNetworksGetPublicIPResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksGetPublicIPResult contains the result from method WorkloadNetworks.GetPublicIP.
type WorkloadNetworksGetPublicIPResult struct {
	WorkloadNetworkPublicIP
}

// WorkloadNetworksGetSegmentResponse contains the response from method WorkloadNetworks.GetSegment.
type WorkloadNetworksGetSegmentResponse struct {
	WorkloadNetworksGetSegmentResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksGetSegmentResult contains the result from method WorkloadNetworks.GetSegment.
type WorkloadNetworksGetSegmentResult struct {
	WorkloadNetworkSegment
}

// WorkloadNetworksGetVMGroupResponse contains the response from method WorkloadNetworks.GetVMGroup.
type WorkloadNetworksGetVMGroupResponse struct {
	WorkloadNetworksGetVMGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksGetVMGroupResult contains the result from method WorkloadNetworks.GetVMGroup.
type WorkloadNetworksGetVMGroupResult struct {
	WorkloadNetworkVMGroup
}

// WorkloadNetworksGetVirtualMachineResponse contains the response from method WorkloadNetworks.GetVirtualMachine.
type WorkloadNetworksGetVirtualMachineResponse struct {
	WorkloadNetworksGetVirtualMachineResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksGetVirtualMachineResult contains the result from method WorkloadNetworks.GetVirtualMachine.
type WorkloadNetworksGetVirtualMachineResult struct {
	WorkloadNetworkVirtualMachine
}

// WorkloadNetworksListDNSServicesResponse contains the response from method WorkloadNetworks.ListDNSServices.
type WorkloadNetworksListDNSServicesResponse struct {
	WorkloadNetworksListDNSServicesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksListDNSServicesResult contains the result from method WorkloadNetworks.ListDNSServices.
type WorkloadNetworksListDNSServicesResult struct {
	WorkloadNetworkDNSServicesList
}

// WorkloadNetworksListDNSZonesResponse contains the response from method WorkloadNetworks.ListDNSZones.
type WorkloadNetworksListDNSZonesResponse struct {
	WorkloadNetworksListDNSZonesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksListDNSZonesResult contains the result from method WorkloadNetworks.ListDNSZones.
type WorkloadNetworksListDNSZonesResult struct {
	WorkloadNetworkDNSZonesList
}

// WorkloadNetworksListDhcpResponse contains the response from method WorkloadNetworks.ListDhcp.
type WorkloadNetworksListDhcpResponse struct {
	WorkloadNetworksListDhcpResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksListDhcpResult contains the result from method WorkloadNetworks.ListDhcp.
type WorkloadNetworksListDhcpResult struct {
	WorkloadNetworkDhcpList
}

// WorkloadNetworksListGatewaysResponse contains the response from method WorkloadNetworks.ListGateways.
type WorkloadNetworksListGatewaysResponse struct {
	WorkloadNetworksListGatewaysResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksListGatewaysResult contains the result from method WorkloadNetworks.ListGateways.
type WorkloadNetworksListGatewaysResult struct {
	WorkloadNetworkGatewayList
}

// WorkloadNetworksListPortMirroringResponse contains the response from method WorkloadNetworks.ListPortMirroring.
type WorkloadNetworksListPortMirroringResponse struct {
	WorkloadNetworksListPortMirroringResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksListPortMirroringResult contains the result from method WorkloadNetworks.ListPortMirroring.
type WorkloadNetworksListPortMirroringResult struct {
	WorkloadNetworkPortMirroringList
}

// WorkloadNetworksListPublicIPsResponse contains the response from method WorkloadNetworks.ListPublicIPs.
type WorkloadNetworksListPublicIPsResponse struct {
	WorkloadNetworksListPublicIPsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksListPublicIPsResult contains the result from method WorkloadNetworks.ListPublicIPs.
type WorkloadNetworksListPublicIPsResult struct {
	WorkloadNetworkPublicIPsList
}

// WorkloadNetworksListSegmentsResponse contains the response from method WorkloadNetworks.ListSegments.
type WorkloadNetworksListSegmentsResponse struct {
	WorkloadNetworksListSegmentsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksListSegmentsResult contains the result from method WorkloadNetworks.ListSegments.
type WorkloadNetworksListSegmentsResult struct {
	WorkloadNetworkSegmentsList
}

// WorkloadNetworksListVMGroupsResponse contains the response from method WorkloadNetworks.ListVMGroups.
type WorkloadNetworksListVMGroupsResponse struct {
	WorkloadNetworksListVMGroupsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksListVMGroupsResult contains the result from method WorkloadNetworks.ListVMGroups.
type WorkloadNetworksListVMGroupsResult struct {
	WorkloadNetworkVMGroupsList
}

// WorkloadNetworksListVirtualMachinesResponse contains the response from method WorkloadNetworks.ListVirtualMachines.
type WorkloadNetworksListVirtualMachinesResponse struct {
	WorkloadNetworksListVirtualMachinesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksListVirtualMachinesResult contains the result from method WorkloadNetworks.ListVirtualMachines.
type WorkloadNetworksListVirtualMachinesResult struct {
	WorkloadNetworkVirtualMachinesList
}

// WorkloadNetworksUpdateDNSServicePollerResponse contains the response from method WorkloadNetworks.UpdateDNSService.
type WorkloadNetworksUpdateDNSServicePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksUpdateDNSServicePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksUpdateDNSServicePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksUpdateDNSServiceResponse, error) {
	respType := WorkloadNetworksUpdateDNSServiceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkDNSService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksUpdateDNSServicePollerResponse from the provided client and resume token.
func (l *WorkloadNetworksUpdateDNSServicePollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.UpdateDNSService", token, client.pl, client.updateDNSServiceHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksUpdateDNSServicePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksUpdateDNSServiceResponse contains the response from method WorkloadNetworks.UpdateDNSService.
type WorkloadNetworksUpdateDNSServiceResponse struct {
	WorkloadNetworksUpdateDNSServiceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksUpdateDNSServiceResult contains the result from method WorkloadNetworks.UpdateDNSService.
type WorkloadNetworksUpdateDNSServiceResult struct {
	WorkloadNetworkDNSService
}

// WorkloadNetworksUpdateDNSZonePollerResponse contains the response from method WorkloadNetworks.UpdateDNSZone.
type WorkloadNetworksUpdateDNSZonePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksUpdateDNSZonePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksUpdateDNSZonePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksUpdateDNSZoneResponse, error) {
	respType := WorkloadNetworksUpdateDNSZoneResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkDNSZone)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksUpdateDNSZonePollerResponse from the provided client and resume token.
func (l *WorkloadNetworksUpdateDNSZonePollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.UpdateDNSZone", token, client.pl, client.updateDNSZoneHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksUpdateDNSZonePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksUpdateDNSZoneResponse contains the response from method WorkloadNetworks.UpdateDNSZone.
type WorkloadNetworksUpdateDNSZoneResponse struct {
	WorkloadNetworksUpdateDNSZoneResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksUpdateDNSZoneResult contains the result from method WorkloadNetworks.UpdateDNSZone.
type WorkloadNetworksUpdateDNSZoneResult struct {
	WorkloadNetworkDNSZone
}

// WorkloadNetworksUpdateDhcpPollerResponse contains the response from method WorkloadNetworks.UpdateDhcp.
type WorkloadNetworksUpdateDhcpPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksUpdateDhcpPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksUpdateDhcpPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksUpdateDhcpResponse, error) {
	respType := WorkloadNetworksUpdateDhcpResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkDhcp)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksUpdateDhcpPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksUpdateDhcpPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.UpdateDhcp", token, client.pl, client.updateDhcpHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksUpdateDhcpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksUpdateDhcpResponse contains the response from method WorkloadNetworks.UpdateDhcp.
type WorkloadNetworksUpdateDhcpResponse struct {
	WorkloadNetworksUpdateDhcpResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksUpdateDhcpResult contains the result from method WorkloadNetworks.UpdateDhcp.
type WorkloadNetworksUpdateDhcpResult struct {
	WorkloadNetworkDhcp
}

// WorkloadNetworksUpdatePortMirroringPollerResponse contains the response from method WorkloadNetworks.UpdatePortMirroring.
type WorkloadNetworksUpdatePortMirroringPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksUpdatePortMirroringPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksUpdatePortMirroringPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksUpdatePortMirroringResponse, error) {
	respType := WorkloadNetworksUpdatePortMirroringResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkPortMirroring)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksUpdatePortMirroringPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksUpdatePortMirroringPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.UpdatePortMirroring", token, client.pl, client.updatePortMirroringHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksUpdatePortMirroringPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksUpdatePortMirroringResponse contains the response from method WorkloadNetworks.UpdatePortMirroring.
type WorkloadNetworksUpdatePortMirroringResponse struct {
	WorkloadNetworksUpdatePortMirroringResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksUpdatePortMirroringResult contains the result from method WorkloadNetworks.UpdatePortMirroring.
type WorkloadNetworksUpdatePortMirroringResult struct {
	WorkloadNetworkPortMirroring
}

// WorkloadNetworksUpdateSegmentsPollerResponse contains the response from method WorkloadNetworks.UpdateSegments.
type WorkloadNetworksUpdateSegmentsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksUpdateSegmentsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksUpdateSegmentsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksUpdateSegmentsResponse, error) {
	respType := WorkloadNetworksUpdateSegmentsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkSegment)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksUpdateSegmentsPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksUpdateSegmentsPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.UpdateSegments", token, client.pl, client.updateSegmentsHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksUpdateSegmentsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksUpdateSegmentsResponse contains the response from method WorkloadNetworks.UpdateSegments.
type WorkloadNetworksUpdateSegmentsResponse struct {
	WorkloadNetworksUpdateSegmentsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksUpdateSegmentsResult contains the result from method WorkloadNetworks.UpdateSegments.
type WorkloadNetworksUpdateSegmentsResult struct {
	WorkloadNetworkSegment
}

// WorkloadNetworksUpdateVMGroupPollerResponse contains the response from method WorkloadNetworks.UpdateVMGroup.
type WorkloadNetworksUpdateVMGroupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadNetworksUpdateVMGroupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadNetworksUpdateVMGroupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadNetworksUpdateVMGroupResponse, error) {
	respType := WorkloadNetworksUpdateVMGroupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadNetworkVMGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadNetworksUpdateVMGroupPollerResponse from the provided client and resume token.
func (l *WorkloadNetworksUpdateVMGroupPollerResponse) Resume(ctx context.Context, client *WorkloadNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadNetworksClient.UpdateVMGroup", token, client.pl, client.updateVMGroupHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadNetworksUpdateVMGroupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadNetworksUpdateVMGroupResponse contains the response from method WorkloadNetworks.UpdateVMGroup.
type WorkloadNetworksUpdateVMGroupResponse struct {
	WorkloadNetworksUpdateVMGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadNetworksUpdateVMGroupResult contains the result from method WorkloadNetworks.UpdateVMGroup.
type WorkloadNetworksUpdateVMGroupResult struct {
	WorkloadNetworkVMGroup
}
