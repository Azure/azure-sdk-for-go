//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armavs

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strings"
)

// WorkloadNetworksClient contains the methods for the WorkloadNetworks group.
// Don't use this type directly, use NewWorkloadNetworksClient() instead.
type WorkloadNetworksClient struct {
	ep             string
	pl             runtime.Pipeline
	subscriptionID string
}

// NewWorkloadNetworksClient creates a new instance of WorkloadNetworksClient with the specified values.
func NewWorkloadNetworksClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) *WorkloadNetworksClient {
	cp := arm.ClientOptions{}
	if options != nil {
		cp = *options
	}
	if len(cp.Host) == 0 {
		cp.Host = arm.AzurePublicCloud
	}
	return &WorkloadNetworksClient{subscriptionID: subscriptionID, ep: string(cp.Host), pl: armruntime.NewPipeline(module, version, credential, &cp)}
}

// BeginCreateDNSService - Create a DNS service by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginCreateDNSService(ctx context.Context, resourceGroupName string, privateCloudName string, dnsServiceID string, workloadNetworkDNSService WorkloadNetworkDNSService, options *WorkloadNetworksBeginCreateDNSServiceOptions) (WorkloadNetworksCreateDNSServicePollerResponse, error) {
	resp, err := client.createDNSService(ctx, resourceGroupName, privateCloudName, dnsServiceID, workloadNetworkDNSService, options)
	if err != nil {
		return WorkloadNetworksCreateDNSServicePollerResponse{}, err
	}
	result := WorkloadNetworksCreateDNSServicePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.CreateDNSService", "", resp, client.pl, client.createDNSServiceHandleError)
	if err != nil {
		return WorkloadNetworksCreateDNSServicePollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksCreateDNSServicePoller{
		pt: pt,
	}
	return result, nil
}

// CreateDNSService - Create a DNS service by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) createDNSService(ctx context.Context, resourceGroupName string, privateCloudName string, dnsServiceID string, workloadNetworkDNSService WorkloadNetworkDNSService, options *WorkloadNetworksBeginCreateDNSServiceOptions) (*http.Response, error) {
	req, err := client.createDNSServiceCreateRequest(ctx, resourceGroupName, privateCloudName, dnsServiceID, workloadNetworkDNSService, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, client.createDNSServiceHandleError(resp)
	}
	return resp, nil
}

// createDNSServiceCreateRequest creates the CreateDNSService request.
func (client *WorkloadNetworksClient) createDNSServiceCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, dnsServiceID string, workloadNetworkDNSService WorkloadNetworkDNSService, options *WorkloadNetworksBeginCreateDNSServiceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if dnsServiceID == "" {
		return nil, errors.New("parameter dnsServiceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dnsServiceId}", url.PathEscape(dnsServiceID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkDNSService)
}

// createDNSServiceHandleError handles the CreateDNSService error response.
func (client *WorkloadNetworksClient) createDNSServiceHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateDNSZone - Create a DNS zone by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginCreateDNSZone(ctx context.Context, resourceGroupName string, privateCloudName string, dnsZoneID string, workloadNetworkDNSZone WorkloadNetworkDNSZone, options *WorkloadNetworksBeginCreateDNSZoneOptions) (WorkloadNetworksCreateDNSZonePollerResponse, error) {
	resp, err := client.createDNSZone(ctx, resourceGroupName, privateCloudName, dnsZoneID, workloadNetworkDNSZone, options)
	if err != nil {
		return WorkloadNetworksCreateDNSZonePollerResponse{}, err
	}
	result := WorkloadNetworksCreateDNSZonePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.CreateDNSZone", "", resp, client.pl, client.createDNSZoneHandleError)
	if err != nil {
		return WorkloadNetworksCreateDNSZonePollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksCreateDNSZonePoller{
		pt: pt,
	}
	return result, nil
}

// CreateDNSZone - Create a DNS zone by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) createDNSZone(ctx context.Context, resourceGroupName string, privateCloudName string, dnsZoneID string, workloadNetworkDNSZone WorkloadNetworkDNSZone, options *WorkloadNetworksBeginCreateDNSZoneOptions) (*http.Response, error) {
	req, err := client.createDNSZoneCreateRequest(ctx, resourceGroupName, privateCloudName, dnsZoneID, workloadNetworkDNSZone, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, client.createDNSZoneHandleError(resp)
	}
	return resp, nil
}

// createDNSZoneCreateRequest creates the CreateDNSZone request.
func (client *WorkloadNetworksClient) createDNSZoneCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, dnsZoneID string, workloadNetworkDNSZone WorkloadNetworkDNSZone, options *WorkloadNetworksBeginCreateDNSZoneOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if dnsZoneID == "" {
		return nil, errors.New("parameter dnsZoneID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dnsZoneId}", url.PathEscape(dnsZoneID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkDNSZone)
}

// createDNSZoneHandleError handles the CreateDNSZone error response.
func (client *WorkloadNetworksClient) createDNSZoneHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateDhcp - Create dhcp by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginCreateDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp, options *WorkloadNetworksBeginCreateDhcpOptions) (WorkloadNetworksCreateDhcpPollerResponse, error) {
	resp, err := client.createDhcp(ctx, resourceGroupName, privateCloudName, dhcpID, workloadNetworkDhcp, options)
	if err != nil {
		return WorkloadNetworksCreateDhcpPollerResponse{}, err
	}
	result := WorkloadNetworksCreateDhcpPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.CreateDhcp", "", resp, client.pl, client.createDhcpHandleError)
	if err != nil {
		return WorkloadNetworksCreateDhcpPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksCreateDhcpPoller{
		pt: pt,
	}
	return result, nil
}

// CreateDhcp - Create dhcp by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) createDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp, options *WorkloadNetworksBeginCreateDhcpOptions) (*http.Response, error) {
	req, err := client.createDhcpCreateRequest(ctx, resourceGroupName, privateCloudName, dhcpID, workloadNetworkDhcp, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, client.createDhcpHandleError(resp)
	}
	return resp, nil
}

// createDhcpCreateRequest creates the CreateDhcp request.
func (client *WorkloadNetworksClient) createDhcpCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp, options *WorkloadNetworksBeginCreateDhcpOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if dhcpID == "" {
		return nil, errors.New("parameter dhcpID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dhcpId}", url.PathEscape(dhcpID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkDhcp)
}

// createDhcpHandleError handles the CreateDhcp error response.
func (client *WorkloadNetworksClient) createDhcpHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreatePortMirroring - Create a port mirroring profile by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginCreatePortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring, options *WorkloadNetworksBeginCreatePortMirroringOptions) (WorkloadNetworksCreatePortMirroringPollerResponse, error) {
	resp, err := client.createPortMirroring(ctx, resourceGroupName, privateCloudName, portMirroringID, workloadNetworkPortMirroring, options)
	if err != nil {
		return WorkloadNetworksCreatePortMirroringPollerResponse{}, err
	}
	result := WorkloadNetworksCreatePortMirroringPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.CreatePortMirroring", "", resp, client.pl, client.createPortMirroringHandleError)
	if err != nil {
		return WorkloadNetworksCreatePortMirroringPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksCreatePortMirroringPoller{
		pt: pt,
	}
	return result, nil
}

// CreatePortMirroring - Create a port mirroring profile by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) createPortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring, options *WorkloadNetworksBeginCreatePortMirroringOptions) (*http.Response, error) {
	req, err := client.createPortMirroringCreateRequest(ctx, resourceGroupName, privateCloudName, portMirroringID, workloadNetworkPortMirroring, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, client.createPortMirroringHandleError(resp)
	}
	return resp, nil
}

// createPortMirroringCreateRequest creates the CreatePortMirroring request.
func (client *WorkloadNetworksClient) createPortMirroringCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring, options *WorkloadNetworksBeginCreatePortMirroringOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if portMirroringID == "" {
		return nil, errors.New("parameter portMirroringID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{portMirroringId}", url.PathEscape(portMirroringID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkPortMirroring)
}

// createPortMirroringHandleError handles the CreatePortMirroring error response.
func (client *WorkloadNetworksClient) createPortMirroringHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreatePublicIP - Create a Public IP Block by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginCreatePublicIP(ctx context.Context, resourceGroupName string, privateCloudName string, publicIPID string, workloadNetworkPublicIP WorkloadNetworkPublicIP, options *WorkloadNetworksBeginCreatePublicIPOptions) (WorkloadNetworksCreatePublicIPPollerResponse, error) {
	resp, err := client.createPublicIP(ctx, resourceGroupName, privateCloudName, publicIPID, workloadNetworkPublicIP, options)
	if err != nil {
		return WorkloadNetworksCreatePublicIPPollerResponse{}, err
	}
	result := WorkloadNetworksCreatePublicIPPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.CreatePublicIP", "", resp, client.pl, client.createPublicIPHandleError)
	if err != nil {
		return WorkloadNetworksCreatePublicIPPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksCreatePublicIPPoller{
		pt: pt,
	}
	return result, nil
}

// CreatePublicIP - Create a Public IP Block by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) createPublicIP(ctx context.Context, resourceGroupName string, privateCloudName string, publicIPID string, workloadNetworkPublicIP WorkloadNetworkPublicIP, options *WorkloadNetworksBeginCreatePublicIPOptions) (*http.Response, error) {
	req, err := client.createPublicIPCreateRequest(ctx, resourceGroupName, privateCloudName, publicIPID, workloadNetworkPublicIP, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, client.createPublicIPHandleError(resp)
	}
	return resp, nil
}

// createPublicIPCreateRequest creates the CreatePublicIP request.
func (client *WorkloadNetworksClient) createPublicIPCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, publicIPID string, workloadNetworkPublicIP WorkloadNetworkPublicIP, options *WorkloadNetworksBeginCreatePublicIPOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if publicIPID == "" {
		return nil, errors.New("parameter publicIPID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicIPId}", url.PathEscape(publicIPID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkPublicIP)
}

// createPublicIPHandleError handles the CreatePublicIP error response.
func (client *WorkloadNetworksClient) createPublicIPHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateSegments - Create a segment by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginCreateSegments(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment, options *WorkloadNetworksBeginCreateSegmentsOptions) (WorkloadNetworksCreateSegmentsPollerResponse, error) {
	resp, err := client.createSegments(ctx, resourceGroupName, privateCloudName, segmentID, workloadNetworkSegment, options)
	if err != nil {
		return WorkloadNetworksCreateSegmentsPollerResponse{}, err
	}
	result := WorkloadNetworksCreateSegmentsPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.CreateSegments", "", resp, client.pl, client.createSegmentsHandleError)
	if err != nil {
		return WorkloadNetworksCreateSegmentsPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksCreateSegmentsPoller{
		pt: pt,
	}
	return result, nil
}

// CreateSegments - Create a segment by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) createSegments(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment, options *WorkloadNetworksBeginCreateSegmentsOptions) (*http.Response, error) {
	req, err := client.createSegmentsCreateRequest(ctx, resourceGroupName, privateCloudName, segmentID, workloadNetworkSegment, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, client.createSegmentsHandleError(resp)
	}
	return resp, nil
}

// createSegmentsCreateRequest creates the CreateSegments request.
func (client *WorkloadNetworksClient) createSegmentsCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment, options *WorkloadNetworksBeginCreateSegmentsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if segmentID == "" {
		return nil, errors.New("parameter segmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{segmentId}", url.PathEscape(segmentID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkSegment)
}

// createSegmentsHandleError handles the CreateSegments error response.
func (client *WorkloadNetworksClient) createSegmentsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateVMGroup - Create a vm group by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginCreateVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup, options *WorkloadNetworksBeginCreateVMGroupOptions) (WorkloadNetworksCreateVMGroupPollerResponse, error) {
	resp, err := client.createVMGroup(ctx, resourceGroupName, privateCloudName, vmGroupID, workloadNetworkVMGroup, options)
	if err != nil {
		return WorkloadNetworksCreateVMGroupPollerResponse{}, err
	}
	result := WorkloadNetworksCreateVMGroupPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.CreateVMGroup", "", resp, client.pl, client.createVMGroupHandleError)
	if err != nil {
		return WorkloadNetworksCreateVMGroupPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksCreateVMGroupPoller{
		pt: pt,
	}
	return result, nil
}

// CreateVMGroup - Create a vm group by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) createVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup, options *WorkloadNetworksBeginCreateVMGroupOptions) (*http.Response, error) {
	req, err := client.createVMGroupCreateRequest(ctx, resourceGroupName, privateCloudName, vmGroupID, workloadNetworkVMGroup, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, client.createVMGroupHandleError(resp)
	}
	return resp, nil
}

// createVMGroupCreateRequest creates the CreateVMGroup request.
func (client *WorkloadNetworksClient) createVMGroupCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup, options *WorkloadNetworksBeginCreateVMGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if vmGroupID == "" {
		return nil, errors.New("parameter vmGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vmGroupId}", url.PathEscape(vmGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkVMGroup)
}

// createVMGroupHandleError handles the CreateVMGroup error response.
func (client *WorkloadNetworksClient) createVMGroupHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeleteDNSService - Delete a DNS service by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginDeleteDNSService(ctx context.Context, resourceGroupName string, dnsServiceID string, privateCloudName string, options *WorkloadNetworksBeginDeleteDNSServiceOptions) (WorkloadNetworksDeleteDNSServicePollerResponse, error) {
	resp, err := client.deleteDNSService(ctx, resourceGroupName, dnsServiceID, privateCloudName, options)
	if err != nil {
		return WorkloadNetworksDeleteDNSServicePollerResponse{}, err
	}
	result := WorkloadNetworksDeleteDNSServicePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.DeleteDNSService", "", resp, client.pl, client.deleteDNSServiceHandleError)
	if err != nil {
		return WorkloadNetworksDeleteDNSServicePollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksDeleteDNSServicePoller{
		pt: pt,
	}
	return result, nil
}

// DeleteDNSService - Delete a DNS service by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) deleteDNSService(ctx context.Context, resourceGroupName string, dnsServiceID string, privateCloudName string, options *WorkloadNetworksBeginDeleteDNSServiceOptions) (*http.Response, error) {
	req, err := client.deleteDNSServiceCreateRequest(ctx, resourceGroupName, dnsServiceID, privateCloudName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteDNSServiceHandleError(resp)
	}
	return resp, nil
}

// deleteDNSServiceCreateRequest creates the DeleteDNSService request.
func (client *WorkloadNetworksClient) deleteDNSServiceCreateRequest(ctx context.Context, resourceGroupName string, dnsServiceID string, privateCloudName string, options *WorkloadNetworksBeginDeleteDNSServiceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if dnsServiceID == "" {
		return nil, errors.New("parameter dnsServiceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dnsServiceId}", url.PathEscape(dnsServiceID))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDNSServiceHandleError handles the DeleteDNSService error response.
func (client *WorkloadNetworksClient) deleteDNSServiceHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeleteDNSZone - Delete a DNS zone by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginDeleteDNSZone(ctx context.Context, resourceGroupName string, dnsZoneID string, privateCloudName string, options *WorkloadNetworksBeginDeleteDNSZoneOptions) (WorkloadNetworksDeleteDNSZonePollerResponse, error) {
	resp, err := client.deleteDNSZone(ctx, resourceGroupName, dnsZoneID, privateCloudName, options)
	if err != nil {
		return WorkloadNetworksDeleteDNSZonePollerResponse{}, err
	}
	result := WorkloadNetworksDeleteDNSZonePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.DeleteDNSZone", "", resp, client.pl, client.deleteDNSZoneHandleError)
	if err != nil {
		return WorkloadNetworksDeleteDNSZonePollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksDeleteDNSZonePoller{
		pt: pt,
	}
	return result, nil
}

// DeleteDNSZone - Delete a DNS zone by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) deleteDNSZone(ctx context.Context, resourceGroupName string, dnsZoneID string, privateCloudName string, options *WorkloadNetworksBeginDeleteDNSZoneOptions) (*http.Response, error) {
	req, err := client.deleteDNSZoneCreateRequest(ctx, resourceGroupName, dnsZoneID, privateCloudName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteDNSZoneHandleError(resp)
	}
	return resp, nil
}

// deleteDNSZoneCreateRequest creates the DeleteDNSZone request.
func (client *WorkloadNetworksClient) deleteDNSZoneCreateRequest(ctx context.Context, resourceGroupName string, dnsZoneID string, privateCloudName string, options *WorkloadNetworksBeginDeleteDNSZoneOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if dnsZoneID == "" {
		return nil, errors.New("parameter dnsZoneID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dnsZoneId}", url.PathEscape(dnsZoneID))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDNSZoneHandleError handles the DeleteDNSZone error response.
func (client *WorkloadNetworksClient) deleteDNSZoneHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeleteDhcp - Delete dhcp by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginDeleteDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, options *WorkloadNetworksBeginDeleteDhcpOptions) (WorkloadNetworksDeleteDhcpPollerResponse, error) {
	resp, err := client.deleteDhcp(ctx, resourceGroupName, privateCloudName, dhcpID, options)
	if err != nil {
		return WorkloadNetworksDeleteDhcpPollerResponse{}, err
	}
	result := WorkloadNetworksDeleteDhcpPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.DeleteDhcp", "", resp, client.pl, client.deleteDhcpHandleError)
	if err != nil {
		return WorkloadNetworksDeleteDhcpPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksDeleteDhcpPoller{
		pt: pt,
	}
	return result, nil
}

// DeleteDhcp - Delete dhcp by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) deleteDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, options *WorkloadNetworksBeginDeleteDhcpOptions) (*http.Response, error) {
	req, err := client.deleteDhcpCreateRequest(ctx, resourceGroupName, privateCloudName, dhcpID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteDhcpHandleError(resp)
	}
	return resp, nil
}

// deleteDhcpCreateRequest creates the DeleteDhcp request.
func (client *WorkloadNetworksClient) deleteDhcpCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, options *WorkloadNetworksBeginDeleteDhcpOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if dhcpID == "" {
		return nil, errors.New("parameter dhcpID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dhcpId}", url.PathEscape(dhcpID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDhcpHandleError handles the DeleteDhcp error response.
func (client *WorkloadNetworksClient) deleteDhcpHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeletePortMirroring - Delete a port mirroring profile by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginDeletePortMirroring(ctx context.Context, resourceGroupName string, portMirroringID string, privateCloudName string, options *WorkloadNetworksBeginDeletePortMirroringOptions) (WorkloadNetworksDeletePortMirroringPollerResponse, error) {
	resp, err := client.deletePortMirroring(ctx, resourceGroupName, portMirroringID, privateCloudName, options)
	if err != nil {
		return WorkloadNetworksDeletePortMirroringPollerResponse{}, err
	}
	result := WorkloadNetworksDeletePortMirroringPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.DeletePortMirroring", "", resp, client.pl, client.deletePortMirroringHandleError)
	if err != nil {
		return WorkloadNetworksDeletePortMirroringPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksDeletePortMirroringPoller{
		pt: pt,
	}
	return result, nil
}

// DeletePortMirroring - Delete a port mirroring profile by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) deletePortMirroring(ctx context.Context, resourceGroupName string, portMirroringID string, privateCloudName string, options *WorkloadNetworksBeginDeletePortMirroringOptions) (*http.Response, error) {
	req, err := client.deletePortMirroringCreateRequest(ctx, resourceGroupName, portMirroringID, privateCloudName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deletePortMirroringHandleError(resp)
	}
	return resp, nil
}

// deletePortMirroringCreateRequest creates the DeletePortMirroring request.
func (client *WorkloadNetworksClient) deletePortMirroringCreateRequest(ctx context.Context, resourceGroupName string, portMirroringID string, privateCloudName string, options *WorkloadNetworksBeginDeletePortMirroringOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if portMirroringID == "" {
		return nil, errors.New("parameter portMirroringID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{portMirroringId}", url.PathEscape(portMirroringID))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deletePortMirroringHandleError handles the DeletePortMirroring error response.
func (client *WorkloadNetworksClient) deletePortMirroringHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeletePublicIP - Delete a Public IP Block by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginDeletePublicIP(ctx context.Context, resourceGroupName string, publicIPID string, privateCloudName string, options *WorkloadNetworksBeginDeletePublicIPOptions) (WorkloadNetworksDeletePublicIPPollerResponse, error) {
	resp, err := client.deletePublicIP(ctx, resourceGroupName, publicIPID, privateCloudName, options)
	if err != nil {
		return WorkloadNetworksDeletePublicIPPollerResponse{}, err
	}
	result := WorkloadNetworksDeletePublicIPPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.DeletePublicIP", "", resp, client.pl, client.deletePublicIPHandleError)
	if err != nil {
		return WorkloadNetworksDeletePublicIPPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksDeletePublicIPPoller{
		pt: pt,
	}
	return result, nil
}

// DeletePublicIP - Delete a Public IP Block by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) deletePublicIP(ctx context.Context, resourceGroupName string, publicIPID string, privateCloudName string, options *WorkloadNetworksBeginDeletePublicIPOptions) (*http.Response, error) {
	req, err := client.deletePublicIPCreateRequest(ctx, resourceGroupName, publicIPID, privateCloudName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deletePublicIPHandleError(resp)
	}
	return resp, nil
}

// deletePublicIPCreateRequest creates the DeletePublicIP request.
func (client *WorkloadNetworksClient) deletePublicIPCreateRequest(ctx context.Context, resourceGroupName string, publicIPID string, privateCloudName string, options *WorkloadNetworksBeginDeletePublicIPOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if publicIPID == "" {
		return nil, errors.New("parameter publicIPID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicIPId}", url.PathEscape(publicIPID))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deletePublicIPHandleError handles the DeletePublicIP error response.
func (client *WorkloadNetworksClient) deletePublicIPHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeleteSegment - Delete a segment by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginDeleteSegment(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, options *WorkloadNetworksBeginDeleteSegmentOptions) (WorkloadNetworksDeleteSegmentPollerResponse, error) {
	resp, err := client.deleteSegment(ctx, resourceGroupName, privateCloudName, segmentID, options)
	if err != nil {
		return WorkloadNetworksDeleteSegmentPollerResponse{}, err
	}
	result := WorkloadNetworksDeleteSegmentPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.DeleteSegment", "", resp, client.pl, client.deleteSegmentHandleError)
	if err != nil {
		return WorkloadNetworksDeleteSegmentPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksDeleteSegmentPoller{
		pt: pt,
	}
	return result, nil
}

// DeleteSegment - Delete a segment by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) deleteSegment(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, options *WorkloadNetworksBeginDeleteSegmentOptions) (*http.Response, error) {
	req, err := client.deleteSegmentCreateRequest(ctx, resourceGroupName, privateCloudName, segmentID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteSegmentHandleError(resp)
	}
	return resp, nil
}

// deleteSegmentCreateRequest creates the DeleteSegment request.
func (client *WorkloadNetworksClient) deleteSegmentCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, options *WorkloadNetworksBeginDeleteSegmentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if segmentID == "" {
		return nil, errors.New("parameter segmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{segmentId}", url.PathEscape(segmentID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSegmentHandleError handles the DeleteSegment error response.
func (client *WorkloadNetworksClient) deleteSegmentHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeleteVMGroup - Delete a vm group by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginDeleteVMGroup(ctx context.Context, resourceGroupName string, vmGroupID string, privateCloudName string, options *WorkloadNetworksBeginDeleteVMGroupOptions) (WorkloadNetworksDeleteVMGroupPollerResponse, error) {
	resp, err := client.deleteVMGroup(ctx, resourceGroupName, vmGroupID, privateCloudName, options)
	if err != nil {
		return WorkloadNetworksDeleteVMGroupPollerResponse{}, err
	}
	result := WorkloadNetworksDeleteVMGroupPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.DeleteVMGroup", "", resp, client.pl, client.deleteVMGroupHandleError)
	if err != nil {
		return WorkloadNetworksDeleteVMGroupPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksDeleteVMGroupPoller{
		pt: pt,
	}
	return result, nil
}

// DeleteVMGroup - Delete a vm group by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) deleteVMGroup(ctx context.Context, resourceGroupName string, vmGroupID string, privateCloudName string, options *WorkloadNetworksBeginDeleteVMGroupOptions) (*http.Response, error) {
	req, err := client.deleteVMGroupCreateRequest(ctx, resourceGroupName, vmGroupID, privateCloudName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteVMGroupHandleError(resp)
	}
	return resp, nil
}

// deleteVMGroupCreateRequest creates the DeleteVMGroup request.
func (client *WorkloadNetworksClient) deleteVMGroupCreateRequest(ctx context.Context, resourceGroupName string, vmGroupID string, privateCloudName string, options *WorkloadNetworksBeginDeleteVMGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if vmGroupID == "" {
		return nil, errors.New("parameter vmGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vmGroupId}", url.PathEscape(vmGroupID))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteVMGroupHandleError handles the DeleteVMGroup error response.
func (client *WorkloadNetworksClient) deleteVMGroupHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDNSService - Get a DNS service by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) GetDNSService(ctx context.Context, resourceGroupName string, privateCloudName string, dnsServiceID string, options *WorkloadNetworksGetDNSServiceOptions) (WorkloadNetworksGetDNSServiceResponse, error) {
	req, err := client.getDNSServiceCreateRequest(ctx, resourceGroupName, privateCloudName, dnsServiceID, options)
	if err != nil {
		return WorkloadNetworksGetDNSServiceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksGetDNSServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WorkloadNetworksGetDNSServiceResponse{}, client.getDNSServiceHandleError(resp)
	}
	return client.getDNSServiceHandleResponse(resp)
}

// getDNSServiceCreateRequest creates the GetDNSService request.
func (client *WorkloadNetworksClient) getDNSServiceCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, dnsServiceID string, options *WorkloadNetworksGetDNSServiceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if dnsServiceID == "" {
		return nil, errors.New("parameter dnsServiceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dnsServiceId}", url.PathEscape(dnsServiceID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDNSServiceHandleResponse handles the GetDNSService response.
func (client *WorkloadNetworksClient) getDNSServiceHandleResponse(resp *http.Response) (WorkloadNetworksGetDNSServiceResponse, error) {
	result := WorkloadNetworksGetDNSServiceResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkDNSService); err != nil {
		return WorkloadNetworksGetDNSServiceResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDNSServiceHandleError handles the GetDNSService error response.
func (client *WorkloadNetworksClient) getDNSServiceHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDNSZone - Get a DNS zone by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) GetDNSZone(ctx context.Context, resourceGroupName string, privateCloudName string, dnsZoneID string, options *WorkloadNetworksGetDNSZoneOptions) (WorkloadNetworksGetDNSZoneResponse, error) {
	req, err := client.getDNSZoneCreateRequest(ctx, resourceGroupName, privateCloudName, dnsZoneID, options)
	if err != nil {
		return WorkloadNetworksGetDNSZoneResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksGetDNSZoneResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WorkloadNetworksGetDNSZoneResponse{}, client.getDNSZoneHandleError(resp)
	}
	return client.getDNSZoneHandleResponse(resp)
}

// getDNSZoneCreateRequest creates the GetDNSZone request.
func (client *WorkloadNetworksClient) getDNSZoneCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, dnsZoneID string, options *WorkloadNetworksGetDNSZoneOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if dnsZoneID == "" {
		return nil, errors.New("parameter dnsZoneID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dnsZoneId}", url.PathEscape(dnsZoneID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDNSZoneHandleResponse handles the GetDNSZone response.
func (client *WorkloadNetworksClient) getDNSZoneHandleResponse(resp *http.Response) (WorkloadNetworksGetDNSZoneResponse, error) {
	result := WorkloadNetworksGetDNSZoneResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkDNSZone); err != nil {
		return WorkloadNetworksGetDNSZoneResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDNSZoneHandleError handles the GetDNSZone error response.
func (client *WorkloadNetworksClient) getDNSZoneHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDhcp - Get dhcp by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) GetDhcp(ctx context.Context, resourceGroupName string, dhcpID string, privateCloudName string, options *WorkloadNetworksGetDhcpOptions) (WorkloadNetworksGetDhcpResponse, error) {
	req, err := client.getDhcpCreateRequest(ctx, resourceGroupName, dhcpID, privateCloudName, options)
	if err != nil {
		return WorkloadNetworksGetDhcpResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksGetDhcpResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WorkloadNetworksGetDhcpResponse{}, client.getDhcpHandleError(resp)
	}
	return client.getDhcpHandleResponse(resp)
}

// getDhcpCreateRequest creates the GetDhcp request.
func (client *WorkloadNetworksClient) getDhcpCreateRequest(ctx context.Context, resourceGroupName string, dhcpID string, privateCloudName string, options *WorkloadNetworksGetDhcpOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if dhcpID == "" {
		return nil, errors.New("parameter dhcpID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dhcpId}", url.PathEscape(dhcpID))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDhcpHandleResponse handles the GetDhcp response.
func (client *WorkloadNetworksClient) getDhcpHandleResponse(resp *http.Response) (WorkloadNetworksGetDhcpResponse, error) {
	result := WorkloadNetworksGetDhcpResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkDhcp); err != nil {
		return WorkloadNetworksGetDhcpResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDhcpHandleError handles the GetDhcp error response.
func (client *WorkloadNetworksClient) getDhcpHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetGateway - Get a gateway by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) GetGateway(ctx context.Context, resourceGroupName string, privateCloudName string, gatewayID string, options *WorkloadNetworksGetGatewayOptions) (WorkloadNetworksGetGatewayResponse, error) {
	req, err := client.getGatewayCreateRequest(ctx, resourceGroupName, privateCloudName, gatewayID, options)
	if err != nil {
		return WorkloadNetworksGetGatewayResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksGetGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WorkloadNetworksGetGatewayResponse{}, client.getGatewayHandleError(resp)
	}
	return client.getGatewayHandleResponse(resp)
}

// getGatewayCreateRequest creates the GetGateway request.
func (client *WorkloadNetworksClient) getGatewayCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, gatewayID string, options *WorkloadNetworksGetGatewayOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways/{gatewayId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if gatewayID == "" {
		return nil, errors.New("parameter gatewayID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayId}", url.PathEscape(gatewayID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getGatewayHandleResponse handles the GetGateway response.
func (client *WorkloadNetworksClient) getGatewayHandleResponse(resp *http.Response) (WorkloadNetworksGetGatewayResponse, error) {
	result := WorkloadNetworksGetGatewayResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkGateway); err != nil {
		return WorkloadNetworksGetGatewayResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getGatewayHandleError handles the GetGateway error response.
func (client *WorkloadNetworksClient) getGatewayHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPortMirroring - Get a port mirroring profile by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) GetPortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, options *WorkloadNetworksGetPortMirroringOptions) (WorkloadNetworksGetPortMirroringResponse, error) {
	req, err := client.getPortMirroringCreateRequest(ctx, resourceGroupName, privateCloudName, portMirroringID, options)
	if err != nil {
		return WorkloadNetworksGetPortMirroringResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksGetPortMirroringResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WorkloadNetworksGetPortMirroringResponse{}, client.getPortMirroringHandleError(resp)
	}
	return client.getPortMirroringHandleResponse(resp)
}

// getPortMirroringCreateRequest creates the GetPortMirroring request.
func (client *WorkloadNetworksClient) getPortMirroringCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, options *WorkloadNetworksGetPortMirroringOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if portMirroringID == "" {
		return nil, errors.New("parameter portMirroringID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{portMirroringId}", url.PathEscape(portMirroringID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPortMirroringHandleResponse handles the GetPortMirroring response.
func (client *WorkloadNetworksClient) getPortMirroringHandleResponse(resp *http.Response) (WorkloadNetworksGetPortMirroringResponse, error) {
	result := WorkloadNetworksGetPortMirroringResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkPortMirroring); err != nil {
		return WorkloadNetworksGetPortMirroringResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPortMirroringHandleError handles the GetPortMirroring error response.
func (client *WorkloadNetworksClient) getPortMirroringHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPublicIP - Get a Public IP Block by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) GetPublicIP(ctx context.Context, resourceGroupName string, privateCloudName string, publicIPID string, options *WorkloadNetworksGetPublicIPOptions) (WorkloadNetworksGetPublicIPResponse, error) {
	req, err := client.getPublicIPCreateRequest(ctx, resourceGroupName, privateCloudName, publicIPID, options)
	if err != nil {
		return WorkloadNetworksGetPublicIPResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksGetPublicIPResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WorkloadNetworksGetPublicIPResponse{}, client.getPublicIPHandleError(resp)
	}
	return client.getPublicIPHandleResponse(resp)
}

// getPublicIPCreateRequest creates the GetPublicIP request.
func (client *WorkloadNetworksClient) getPublicIPCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, publicIPID string, options *WorkloadNetworksGetPublicIPOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if publicIPID == "" {
		return nil, errors.New("parameter publicIPID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicIPId}", url.PathEscape(publicIPID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPublicIPHandleResponse handles the GetPublicIP response.
func (client *WorkloadNetworksClient) getPublicIPHandleResponse(resp *http.Response) (WorkloadNetworksGetPublicIPResponse, error) {
	result := WorkloadNetworksGetPublicIPResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkPublicIP); err != nil {
		return WorkloadNetworksGetPublicIPResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPublicIPHandleError handles the GetPublicIP error response.
func (client *WorkloadNetworksClient) getPublicIPHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSegment - Get a segment by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) GetSegment(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, options *WorkloadNetworksGetSegmentOptions) (WorkloadNetworksGetSegmentResponse, error) {
	req, err := client.getSegmentCreateRequest(ctx, resourceGroupName, privateCloudName, segmentID, options)
	if err != nil {
		return WorkloadNetworksGetSegmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksGetSegmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WorkloadNetworksGetSegmentResponse{}, client.getSegmentHandleError(resp)
	}
	return client.getSegmentHandleResponse(resp)
}

// getSegmentCreateRequest creates the GetSegment request.
func (client *WorkloadNetworksClient) getSegmentCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, options *WorkloadNetworksGetSegmentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if segmentID == "" {
		return nil, errors.New("parameter segmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{segmentId}", url.PathEscape(segmentID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSegmentHandleResponse handles the GetSegment response.
func (client *WorkloadNetworksClient) getSegmentHandleResponse(resp *http.Response) (WorkloadNetworksGetSegmentResponse, error) {
	result := WorkloadNetworksGetSegmentResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkSegment); err != nil {
		return WorkloadNetworksGetSegmentResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSegmentHandleError handles the GetSegment error response.
func (client *WorkloadNetworksClient) getSegmentHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetVMGroup - Get a vm group by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) GetVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, options *WorkloadNetworksGetVMGroupOptions) (WorkloadNetworksGetVMGroupResponse, error) {
	req, err := client.getVMGroupCreateRequest(ctx, resourceGroupName, privateCloudName, vmGroupID, options)
	if err != nil {
		return WorkloadNetworksGetVMGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksGetVMGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WorkloadNetworksGetVMGroupResponse{}, client.getVMGroupHandleError(resp)
	}
	return client.getVMGroupHandleResponse(resp)
}

// getVMGroupCreateRequest creates the GetVMGroup request.
func (client *WorkloadNetworksClient) getVMGroupCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, options *WorkloadNetworksGetVMGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if vmGroupID == "" {
		return nil, errors.New("parameter vmGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vmGroupId}", url.PathEscape(vmGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getVMGroupHandleResponse handles the GetVMGroup response.
func (client *WorkloadNetworksClient) getVMGroupHandleResponse(resp *http.Response) (WorkloadNetworksGetVMGroupResponse, error) {
	result := WorkloadNetworksGetVMGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkVMGroup); err != nil {
		return WorkloadNetworksGetVMGroupResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getVMGroupHandleError handles the GetVMGroup error response.
func (client *WorkloadNetworksClient) getVMGroupHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetVirtualMachine - Get a virtual machine by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) GetVirtualMachine(ctx context.Context, resourceGroupName string, privateCloudName string, virtualMachineID string, options *WorkloadNetworksGetVirtualMachineOptions) (WorkloadNetworksGetVirtualMachineResponse, error) {
	req, err := client.getVirtualMachineCreateRequest(ctx, resourceGroupName, privateCloudName, virtualMachineID, options)
	if err != nil {
		return WorkloadNetworksGetVirtualMachineResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksGetVirtualMachineResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WorkloadNetworksGetVirtualMachineResponse{}, client.getVirtualMachineHandleError(resp)
	}
	return client.getVirtualMachineHandleResponse(resp)
}

// getVirtualMachineCreateRequest creates the GetVirtualMachine request.
func (client *WorkloadNetworksClient) getVirtualMachineCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, virtualMachineID string, options *WorkloadNetworksGetVirtualMachineOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines/{virtualMachineId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if virtualMachineID == "" {
		return nil, errors.New("parameter virtualMachineID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{virtualMachineId}", url.PathEscape(virtualMachineID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getVirtualMachineHandleResponse handles the GetVirtualMachine response.
func (client *WorkloadNetworksClient) getVirtualMachineHandleResponse(resp *http.Response) (WorkloadNetworksGetVirtualMachineResponse, error) {
	result := WorkloadNetworksGetVirtualMachineResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkVirtualMachine); err != nil {
		return WorkloadNetworksGetVirtualMachineResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getVirtualMachineHandleError handles the GetVirtualMachine error response.
func (client *WorkloadNetworksClient) getVirtualMachineHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListDNSServices - List of DNS services in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) ListDNSServices(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListDNSServicesOptions) *WorkloadNetworksListDNSServicesPager {
	return &WorkloadNetworksListDNSServicesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listDNSServicesCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		advancer: func(ctx context.Context, resp WorkloadNetworksListDNSServicesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkDNSServicesList.NextLink)
		},
	}
}

// listDNSServicesCreateRequest creates the ListDNSServices request.
func (client *WorkloadNetworksClient) listDNSServicesCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListDNSServicesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDNSServicesHandleResponse handles the ListDNSServices response.
func (client *WorkloadNetworksClient) listDNSServicesHandleResponse(resp *http.Response) (WorkloadNetworksListDNSServicesResponse, error) {
	result := WorkloadNetworksListDNSServicesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkDNSServicesList); err != nil {
		return WorkloadNetworksListDNSServicesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listDNSServicesHandleError handles the ListDNSServices error response.
func (client *WorkloadNetworksClient) listDNSServicesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListDNSZones - List of DNS zones in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) ListDNSZones(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListDNSZonesOptions) *WorkloadNetworksListDNSZonesPager {
	return &WorkloadNetworksListDNSZonesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listDNSZonesCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		advancer: func(ctx context.Context, resp WorkloadNetworksListDNSZonesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkDNSZonesList.NextLink)
		},
	}
}

// listDNSZonesCreateRequest creates the ListDNSZones request.
func (client *WorkloadNetworksClient) listDNSZonesCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListDNSZonesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDNSZonesHandleResponse handles the ListDNSZones response.
func (client *WorkloadNetworksClient) listDNSZonesHandleResponse(resp *http.Response) (WorkloadNetworksListDNSZonesResponse, error) {
	result := WorkloadNetworksListDNSZonesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkDNSZonesList); err != nil {
		return WorkloadNetworksListDNSZonesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listDNSZonesHandleError handles the ListDNSZones error response.
func (client *WorkloadNetworksClient) listDNSZonesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListDhcp - List dhcp in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) ListDhcp(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListDhcpOptions) *WorkloadNetworksListDhcpPager {
	return &WorkloadNetworksListDhcpPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listDhcpCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		advancer: func(ctx context.Context, resp WorkloadNetworksListDhcpResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkDhcpList.NextLink)
		},
	}
}

// listDhcpCreateRequest creates the ListDhcp request.
func (client *WorkloadNetworksClient) listDhcpCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListDhcpOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDhcpHandleResponse handles the ListDhcp response.
func (client *WorkloadNetworksClient) listDhcpHandleResponse(resp *http.Response) (WorkloadNetworksListDhcpResponse, error) {
	result := WorkloadNetworksListDhcpResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkDhcpList); err != nil {
		return WorkloadNetworksListDhcpResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listDhcpHandleError handles the ListDhcp error response.
func (client *WorkloadNetworksClient) listDhcpHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListGateways - List of gateways in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) ListGateways(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListGatewaysOptions) *WorkloadNetworksListGatewaysPager {
	return &WorkloadNetworksListGatewaysPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listGatewaysCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		advancer: func(ctx context.Context, resp WorkloadNetworksListGatewaysResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkGatewayList.NextLink)
		},
	}
}

// listGatewaysCreateRequest creates the ListGateways request.
func (client *WorkloadNetworksClient) listGatewaysCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListGatewaysOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listGatewaysHandleResponse handles the ListGateways response.
func (client *WorkloadNetworksClient) listGatewaysHandleResponse(resp *http.Response) (WorkloadNetworksListGatewaysResponse, error) {
	result := WorkloadNetworksListGatewaysResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkGatewayList); err != nil {
		return WorkloadNetworksListGatewaysResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listGatewaysHandleError handles the ListGateways error response.
func (client *WorkloadNetworksClient) listGatewaysHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListPortMirroring - List of port mirroring profiles in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) ListPortMirroring(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListPortMirroringOptions) *WorkloadNetworksListPortMirroringPager {
	return &WorkloadNetworksListPortMirroringPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listPortMirroringCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		advancer: func(ctx context.Context, resp WorkloadNetworksListPortMirroringResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkPortMirroringList.NextLink)
		},
	}
}

// listPortMirroringCreateRequest creates the ListPortMirroring request.
func (client *WorkloadNetworksClient) listPortMirroringCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListPortMirroringOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listPortMirroringHandleResponse handles the ListPortMirroring response.
func (client *WorkloadNetworksClient) listPortMirroringHandleResponse(resp *http.Response) (WorkloadNetworksListPortMirroringResponse, error) {
	result := WorkloadNetworksListPortMirroringResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkPortMirroringList); err != nil {
		return WorkloadNetworksListPortMirroringResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listPortMirroringHandleError handles the ListPortMirroring error response.
func (client *WorkloadNetworksClient) listPortMirroringHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListPublicIPs - List of Public IP Blocks in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) ListPublicIPs(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListPublicIPsOptions) *WorkloadNetworksListPublicIPsPager {
	return &WorkloadNetworksListPublicIPsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listPublicIPsCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		advancer: func(ctx context.Context, resp WorkloadNetworksListPublicIPsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkPublicIPsList.NextLink)
		},
	}
}

// listPublicIPsCreateRequest creates the ListPublicIPs request.
func (client *WorkloadNetworksClient) listPublicIPsCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListPublicIPsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listPublicIPsHandleResponse handles the ListPublicIPs response.
func (client *WorkloadNetworksClient) listPublicIPsHandleResponse(resp *http.Response) (WorkloadNetworksListPublicIPsResponse, error) {
	result := WorkloadNetworksListPublicIPsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkPublicIPsList); err != nil {
		return WorkloadNetworksListPublicIPsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listPublicIPsHandleError handles the ListPublicIPs error response.
func (client *WorkloadNetworksClient) listPublicIPsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSegments - List of segments in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) ListSegments(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListSegmentsOptions) *WorkloadNetworksListSegmentsPager {
	return &WorkloadNetworksListSegmentsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSegmentsCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		advancer: func(ctx context.Context, resp WorkloadNetworksListSegmentsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkSegmentsList.NextLink)
		},
	}
}

// listSegmentsCreateRequest creates the ListSegments request.
func (client *WorkloadNetworksClient) listSegmentsCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListSegmentsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSegmentsHandleResponse handles the ListSegments response.
func (client *WorkloadNetworksClient) listSegmentsHandleResponse(resp *http.Response) (WorkloadNetworksListSegmentsResponse, error) {
	result := WorkloadNetworksListSegmentsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkSegmentsList); err != nil {
		return WorkloadNetworksListSegmentsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSegmentsHandleError handles the ListSegments error response.
func (client *WorkloadNetworksClient) listSegmentsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListVMGroups - List of vm groups in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) ListVMGroups(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListVMGroupsOptions) *WorkloadNetworksListVMGroupsPager {
	return &WorkloadNetworksListVMGroupsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listVMGroupsCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		advancer: func(ctx context.Context, resp WorkloadNetworksListVMGroupsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkVMGroupsList.NextLink)
		},
	}
}

// listVMGroupsCreateRequest creates the ListVMGroups request.
func (client *WorkloadNetworksClient) listVMGroupsCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListVMGroupsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listVMGroupsHandleResponse handles the ListVMGroups response.
func (client *WorkloadNetworksClient) listVMGroupsHandleResponse(resp *http.Response) (WorkloadNetworksListVMGroupsResponse, error) {
	result := WorkloadNetworksListVMGroupsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkVMGroupsList); err != nil {
		return WorkloadNetworksListVMGroupsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listVMGroupsHandleError handles the ListVMGroups error response.
func (client *WorkloadNetworksClient) listVMGroupsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListVirtualMachines - List of virtual machines in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) ListVirtualMachines(resourceGroupName string, privateCloudName string, options *WorkloadNetworksListVirtualMachinesOptions) *WorkloadNetworksListVirtualMachinesPager {
	return &WorkloadNetworksListVirtualMachinesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listVirtualMachinesCreateRequest(ctx, resourceGroupName, privateCloudName, options)
		},
		advancer: func(ctx context.Context, resp WorkloadNetworksListVirtualMachinesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkloadNetworkVirtualMachinesList.NextLink)
		},
	}
}

// listVirtualMachinesCreateRequest creates the ListVirtualMachines request.
func (client *WorkloadNetworksClient) listVirtualMachinesCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, options *WorkloadNetworksListVirtualMachinesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listVirtualMachinesHandleResponse handles the ListVirtualMachines response.
func (client *WorkloadNetworksClient) listVirtualMachinesHandleResponse(resp *http.Response) (WorkloadNetworksListVirtualMachinesResponse, error) {
	result := WorkloadNetworksListVirtualMachinesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkloadNetworkVirtualMachinesList); err != nil {
		return WorkloadNetworksListVirtualMachinesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listVirtualMachinesHandleError handles the ListVirtualMachines error response.
func (client *WorkloadNetworksClient) listVirtualMachinesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginUpdateDNSService - Create or update a DNS service by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginUpdateDNSService(ctx context.Context, resourceGroupName string, privateCloudName string, dnsServiceID string, workloadNetworkDNSService WorkloadNetworkDNSService, options *WorkloadNetworksBeginUpdateDNSServiceOptions) (WorkloadNetworksUpdateDNSServicePollerResponse, error) {
	resp, err := client.updateDNSService(ctx, resourceGroupName, privateCloudName, dnsServiceID, workloadNetworkDNSService, options)
	if err != nil {
		return WorkloadNetworksUpdateDNSServicePollerResponse{}, err
	}
	result := WorkloadNetworksUpdateDNSServicePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.UpdateDNSService", "", resp, client.pl, client.updateDNSServiceHandleError)
	if err != nil {
		return WorkloadNetworksUpdateDNSServicePollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksUpdateDNSServicePoller{
		pt: pt,
	}
	return result, nil
}

// UpdateDNSService - Create or update a DNS service by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) updateDNSService(ctx context.Context, resourceGroupName string, privateCloudName string, dnsServiceID string, workloadNetworkDNSService WorkloadNetworkDNSService, options *WorkloadNetworksBeginUpdateDNSServiceOptions) (*http.Response, error) {
	req, err := client.updateDNSServiceCreateRequest(ctx, resourceGroupName, privateCloudName, dnsServiceID, workloadNetworkDNSService, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.updateDNSServiceHandleError(resp)
	}
	return resp, nil
}

// updateDNSServiceCreateRequest creates the UpdateDNSService request.
func (client *WorkloadNetworksClient) updateDNSServiceCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, dnsServiceID string, workloadNetworkDNSService WorkloadNetworkDNSService, options *WorkloadNetworksBeginUpdateDNSServiceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if dnsServiceID == "" {
		return nil, errors.New("parameter dnsServiceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dnsServiceId}", url.PathEscape(dnsServiceID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkDNSService)
}

// updateDNSServiceHandleError handles the UpdateDNSService error response.
func (client *WorkloadNetworksClient) updateDNSServiceHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginUpdateDNSZone - Create or update a DNS zone by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginUpdateDNSZone(ctx context.Context, resourceGroupName string, privateCloudName string, dnsZoneID string, workloadNetworkDNSZone WorkloadNetworkDNSZone, options *WorkloadNetworksBeginUpdateDNSZoneOptions) (WorkloadNetworksUpdateDNSZonePollerResponse, error) {
	resp, err := client.updateDNSZone(ctx, resourceGroupName, privateCloudName, dnsZoneID, workloadNetworkDNSZone, options)
	if err != nil {
		return WorkloadNetworksUpdateDNSZonePollerResponse{}, err
	}
	result := WorkloadNetworksUpdateDNSZonePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.UpdateDNSZone", "", resp, client.pl, client.updateDNSZoneHandleError)
	if err != nil {
		return WorkloadNetworksUpdateDNSZonePollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksUpdateDNSZonePoller{
		pt: pt,
	}
	return result, nil
}

// UpdateDNSZone - Create or update a DNS zone by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) updateDNSZone(ctx context.Context, resourceGroupName string, privateCloudName string, dnsZoneID string, workloadNetworkDNSZone WorkloadNetworkDNSZone, options *WorkloadNetworksBeginUpdateDNSZoneOptions) (*http.Response, error) {
	req, err := client.updateDNSZoneCreateRequest(ctx, resourceGroupName, privateCloudName, dnsZoneID, workloadNetworkDNSZone, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.updateDNSZoneHandleError(resp)
	}
	return resp, nil
}

// updateDNSZoneCreateRequest creates the UpdateDNSZone request.
func (client *WorkloadNetworksClient) updateDNSZoneCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, dnsZoneID string, workloadNetworkDNSZone WorkloadNetworkDNSZone, options *WorkloadNetworksBeginUpdateDNSZoneOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if dnsZoneID == "" {
		return nil, errors.New("parameter dnsZoneID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dnsZoneId}", url.PathEscape(dnsZoneID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkDNSZone)
}

// updateDNSZoneHandleError handles the UpdateDNSZone error response.
func (client *WorkloadNetworksClient) updateDNSZoneHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginUpdateDhcp - Create or update dhcp by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginUpdateDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp, options *WorkloadNetworksBeginUpdateDhcpOptions) (WorkloadNetworksUpdateDhcpPollerResponse, error) {
	resp, err := client.updateDhcp(ctx, resourceGroupName, privateCloudName, dhcpID, workloadNetworkDhcp, options)
	if err != nil {
		return WorkloadNetworksUpdateDhcpPollerResponse{}, err
	}
	result := WorkloadNetworksUpdateDhcpPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.UpdateDhcp", "", resp, client.pl, client.updateDhcpHandleError)
	if err != nil {
		return WorkloadNetworksUpdateDhcpPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksUpdateDhcpPoller{
		pt: pt,
	}
	return result, nil
}

// UpdateDhcp - Create or update dhcp by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) updateDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp, options *WorkloadNetworksBeginUpdateDhcpOptions) (*http.Response, error) {
	req, err := client.updateDhcpCreateRequest(ctx, resourceGroupName, privateCloudName, dhcpID, workloadNetworkDhcp, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.updateDhcpHandleError(resp)
	}
	return resp, nil
}

// updateDhcpCreateRequest creates the UpdateDhcp request.
func (client *WorkloadNetworksClient) updateDhcpCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp, options *WorkloadNetworksBeginUpdateDhcpOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if dhcpID == "" {
		return nil, errors.New("parameter dhcpID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dhcpId}", url.PathEscape(dhcpID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkDhcp)
}

// updateDhcpHandleError handles the UpdateDhcp error response.
func (client *WorkloadNetworksClient) updateDhcpHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginUpdatePortMirroring - Create or update a port mirroring profile by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginUpdatePortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring, options *WorkloadNetworksBeginUpdatePortMirroringOptions) (WorkloadNetworksUpdatePortMirroringPollerResponse, error) {
	resp, err := client.updatePortMirroring(ctx, resourceGroupName, privateCloudName, portMirroringID, workloadNetworkPortMirroring, options)
	if err != nil {
		return WorkloadNetworksUpdatePortMirroringPollerResponse{}, err
	}
	result := WorkloadNetworksUpdatePortMirroringPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.UpdatePortMirroring", "", resp, client.pl, client.updatePortMirroringHandleError)
	if err != nil {
		return WorkloadNetworksUpdatePortMirroringPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksUpdatePortMirroringPoller{
		pt: pt,
	}
	return result, nil
}

// UpdatePortMirroring - Create or update a port mirroring profile by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) updatePortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring, options *WorkloadNetworksBeginUpdatePortMirroringOptions) (*http.Response, error) {
	req, err := client.updatePortMirroringCreateRequest(ctx, resourceGroupName, privateCloudName, portMirroringID, workloadNetworkPortMirroring, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.updatePortMirroringHandleError(resp)
	}
	return resp, nil
}

// updatePortMirroringCreateRequest creates the UpdatePortMirroring request.
func (client *WorkloadNetworksClient) updatePortMirroringCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring, options *WorkloadNetworksBeginUpdatePortMirroringOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if portMirroringID == "" {
		return nil, errors.New("parameter portMirroringID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{portMirroringId}", url.PathEscape(portMirroringID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkPortMirroring)
}

// updatePortMirroringHandleError handles the UpdatePortMirroring error response.
func (client *WorkloadNetworksClient) updatePortMirroringHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginUpdateSegments - Create or update a segment by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginUpdateSegments(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment, options *WorkloadNetworksBeginUpdateSegmentsOptions) (WorkloadNetworksUpdateSegmentsPollerResponse, error) {
	resp, err := client.updateSegments(ctx, resourceGroupName, privateCloudName, segmentID, workloadNetworkSegment, options)
	if err != nil {
		return WorkloadNetworksUpdateSegmentsPollerResponse{}, err
	}
	result := WorkloadNetworksUpdateSegmentsPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.UpdateSegments", "", resp, client.pl, client.updateSegmentsHandleError)
	if err != nil {
		return WorkloadNetworksUpdateSegmentsPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksUpdateSegmentsPoller{
		pt: pt,
	}
	return result, nil
}

// UpdateSegments - Create or update a segment by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) updateSegments(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment, options *WorkloadNetworksBeginUpdateSegmentsOptions) (*http.Response, error) {
	req, err := client.updateSegmentsCreateRequest(ctx, resourceGroupName, privateCloudName, segmentID, workloadNetworkSegment, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.updateSegmentsHandleError(resp)
	}
	return resp, nil
}

// updateSegmentsCreateRequest creates the UpdateSegments request.
func (client *WorkloadNetworksClient) updateSegmentsCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment, options *WorkloadNetworksBeginUpdateSegmentsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if segmentID == "" {
		return nil, errors.New("parameter segmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{segmentId}", url.PathEscape(segmentID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkSegment)
}

// updateSegmentsHandleError handles the UpdateSegments error response.
func (client *WorkloadNetworksClient) updateSegmentsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginUpdateVMGroup - Create or update a vm group by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) BeginUpdateVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup, options *WorkloadNetworksBeginUpdateVMGroupOptions) (WorkloadNetworksUpdateVMGroupPollerResponse, error) {
	resp, err := client.updateVMGroup(ctx, resourceGroupName, privateCloudName, vmGroupID, workloadNetworkVMGroup, options)
	if err != nil {
		return WorkloadNetworksUpdateVMGroupPollerResponse{}, err
	}
	result := WorkloadNetworksUpdateVMGroupPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WorkloadNetworksClient.UpdateVMGroup", "", resp, client.pl, client.updateVMGroupHandleError)
	if err != nil {
		return WorkloadNetworksUpdateVMGroupPollerResponse{}, err
	}
	result.Poller = &WorkloadNetworksUpdateVMGroupPoller{
		pt: pt,
	}
	return result, nil
}

// UpdateVMGroup - Create or update a vm group by id in a private cloud workload network.
// If the operation fails it returns the *CloudError error type.
func (client *WorkloadNetworksClient) updateVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup, options *WorkloadNetworksBeginUpdateVMGroupOptions) (*http.Response, error) {
	req, err := client.updateVMGroupCreateRequest(ctx, resourceGroupName, privateCloudName, vmGroupID, workloadNetworkVMGroup, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.updateVMGroupHandleError(resp)
	}
	return resp, nil
}

// updateVMGroupCreateRequest creates the UpdateVMGroup request.
func (client *WorkloadNetworksClient) updateVMGroupCreateRequest(ctx context.Context, resourceGroupName string, privateCloudName string, vmGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup, options *WorkloadNetworksBeginUpdateVMGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if privateCloudName == "" {
		return nil, errors.New("parameter privateCloudName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateCloudName}", url.PathEscape(privateCloudName))
	if vmGroupID == "" {
		return nil, errors.New("parameter vmGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vmGroupId}", url.PathEscape(vmGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-12-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workloadNetworkVMGroup)
}

// updateVMGroupHandleError handles the UpdateVMGroup error response.
func (client *WorkloadNetworksClient) updateVMGroupHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := CloudError{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
