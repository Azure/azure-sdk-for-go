// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armazurestackhci

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type ArcConnectivityProperties.
func (a ArcConnectivityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enabled", a.Enabled)
	populate(objectMap, "serviceConfigurations", a.ServiceConfigurations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArcConnectivityProperties.
func (a *ArcConnectivityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enabled":
			err = unpopulate(val, "Enabled", &a.Enabled)
			delete(rawMsg, key)
		case "serviceConfigurations":
			err = unpopulate(val, "ServiceConfigurations", &a.ServiceConfigurations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArcIdentityResponse.
func (a ArcIdentityResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArcIdentityResponse.
func (a *ArcIdentityResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArcIdentityResponseProperties.
func (a ArcIdentityResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arcApplicationClientId", a.ArcApplicationClientID)
	populate(objectMap, "arcApplicationObjectId", a.ArcApplicationObjectID)
	populate(objectMap, "arcApplicationTenantId", a.ArcApplicationTenantID)
	populate(objectMap, "arcServicePrincipalObjectId", a.ArcServicePrincipalObjectID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArcIdentityResponseProperties.
func (a *ArcIdentityResponseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arcApplicationClientId":
			err = unpopulate(val, "ArcApplicationClientID", &a.ArcApplicationClientID)
			delete(rawMsg, key)
		case "arcApplicationObjectId":
			err = unpopulate(val, "ArcApplicationObjectID", &a.ArcApplicationObjectID)
			delete(rawMsg, key)
		case "arcApplicationTenantId":
			err = unpopulate(val, "ArcApplicationTenantID", &a.ArcApplicationTenantID)
			delete(rawMsg, key)
		case "arcServicePrincipalObjectId":
			err = unpopulate(val, "ArcServicePrincipalObjectID", &a.ArcServicePrincipalObjectID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArcSetting.
func (a ArcSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArcSetting.
func (a *ArcSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArcSettingList.
func (a ArcSettingList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArcSettingList.
func (a *ArcSettingList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArcSettingProperties.
func (a ArcSettingProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aggregateState", a.AggregateState)
	populate(objectMap, "arcApplicationClientId", a.ArcApplicationClientID)
	populate(objectMap, "arcApplicationObjectId", a.ArcApplicationObjectID)
	populate(objectMap, "arcApplicationTenantId", a.ArcApplicationTenantID)
	populate(objectMap, "arcInstanceResourceGroup", a.ArcInstanceResourceGroup)
	populate(objectMap, "arcServicePrincipalObjectId", a.ArcServicePrincipalObjectID)
	populate(objectMap, "connectivityProperties", a.ConnectivityProperties)
	populate(objectMap, "defaultExtensions", a.DefaultExtensions)
	populate(objectMap, "perNodeDetails", a.PerNodeDetails)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArcSettingProperties.
func (a *ArcSettingProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aggregateState":
			err = unpopulate(val, "AggregateState", &a.AggregateState)
			delete(rawMsg, key)
		case "arcApplicationClientId":
			err = unpopulate(val, "ArcApplicationClientID", &a.ArcApplicationClientID)
			delete(rawMsg, key)
		case "arcApplicationObjectId":
			err = unpopulate(val, "ArcApplicationObjectID", &a.ArcApplicationObjectID)
			delete(rawMsg, key)
		case "arcApplicationTenantId":
			err = unpopulate(val, "ArcApplicationTenantID", &a.ArcApplicationTenantID)
			delete(rawMsg, key)
		case "arcInstanceResourceGroup":
			err = unpopulate(val, "ArcInstanceResourceGroup", &a.ArcInstanceResourceGroup)
			delete(rawMsg, key)
		case "arcServicePrincipalObjectId":
			err = unpopulate(val, "ArcServicePrincipalObjectID", &a.ArcServicePrincipalObjectID)
			delete(rawMsg, key)
		case "connectivityProperties":
			err = unpopulate(val, "ConnectivityProperties", &a.ConnectivityProperties)
			delete(rawMsg, key)
		case "defaultExtensions":
			err = unpopulate(val, "DefaultExtensions", &a.DefaultExtensions)
			delete(rawMsg, key)
		case "perNodeDetails":
			err = unpopulate(val, "PerNodeDetails", &a.PerNodeDetails)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArcSettingsPatch.
func (a ArcSettingsPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArcSettingsPatch.
func (a *ArcSettingsPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArcSettingsPatchProperties.
func (a ArcSettingsPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectivityProperties", a.ConnectivityProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArcSettingsPatchProperties.
func (a *ArcSettingsPatchProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectivityProperties":
			err = unpopulate(val, "ConnectivityProperties", &a.ConnectivityProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssemblyInfo.
func (a AssemblyInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "packageVersion", a.PackageVersion)
	populate(objectMap, "payload", a.Payload)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssemblyInfo.
func (a *AssemblyInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "packageVersion":
			err = unpopulate(val, "PackageVersion", &a.PackageVersion)
			delete(rawMsg, key)
		case "payload":
			err = unpopulate(val, "Payload", &a.Payload)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssemblyInfoPayload.
func (a AssemblyInfoPayload) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fileName", a.FileName)
	populate(objectMap, "hash", a.Hash)
	populate(objectMap, "identifier", a.Identifier)
	populate(objectMap, "url", a.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssemblyInfoPayload.
func (a *AssemblyInfoPayload) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &a.FileName)
			delete(rawMsg, key)
		case "hash":
			err = unpopulate(val, "Hash", &a.Hash)
			delete(rawMsg, key)
		case "identifier":
			err = unpopulate(val, "Identifier", &a.Identifier)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &a.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChangeRingRequest.
func (c ChangeRingRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChangeRingRequest.
func (c *ChangeRingRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChangeRingRequestProperties.
func (c ChangeRingRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "targetRing", c.TargetRing)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChangeRingRequestProperties.
func (c *ChangeRingRequestProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "targetRing":
			err = unpopulate(val, "TargetRing", &c.TargetRing)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Cluster.
func (c Cluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "identity", c.Identity)
	populate(objectMap, "kind", c.Kind)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Cluster.
func (c *Cluster) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &c.Identity)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &c.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterDesiredProperties.
func (c ClusterDesiredProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diagnosticLevel", c.DiagnosticLevel)
	populate(objectMap, "windowsServerSubscription", c.WindowsServerSubscription)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterDesiredProperties.
func (c *ClusterDesiredProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diagnosticLevel":
			err = unpopulate(val, "DiagnosticLevel", &c.DiagnosticLevel)
			delete(rawMsg, key)
		case "windowsServerSubscription":
			err = unpopulate(val, "WindowsServerSubscription", &c.WindowsServerSubscription)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterIdentityResponse.
func (c ClusterIdentityResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterIdentityResponse.
func (c *ClusterIdentityResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterIdentityResponseProperties.
func (c ClusterIdentityResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aadApplicationObjectId", c.AADApplicationObjectID)
	populate(objectMap, "aadClientId", c.AADClientID)
	populate(objectMap, "aadServicePrincipalObjectId", c.AADServicePrincipalObjectID)
	populate(objectMap, "aadTenantId", c.AADTenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterIdentityResponseProperties.
func (c *ClusterIdentityResponseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadApplicationObjectId":
			err = unpopulate(val, "AADApplicationObjectID", &c.AADApplicationObjectID)
			delete(rawMsg, key)
		case "aadClientId":
			err = unpopulate(val, "AADClientID", &c.AADClientID)
			delete(rawMsg, key)
		case "aadServicePrincipalObjectId":
			err = unpopulate(val, "AADServicePrincipalObjectID", &c.AADServicePrincipalObjectID)
			delete(rawMsg, key)
		case "aadTenantId":
			err = unpopulate(val, "AADTenantID", &c.AADTenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterList.
func (c ClusterList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterList.
func (c *ClusterList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterNode.
func (c ClusterNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "coreCount", c.CoreCount)
	populate(objectMap, "ehcResourceId", c.EhcResourceID)
	populate(objectMap, "id", c.ID)
	populateDateTimeRFC3339(objectMap, "lastLicensingTimestamp", c.LastLicensingTimestamp)
	populate(objectMap, "manufacturer", c.Manufacturer)
	populate(objectMap, "memoryInGiB", c.MemoryInGiB)
	populate(objectMap, "model", c.Model)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "nodeType", c.NodeType)
	populate(objectMap, "osDisplayVersion", c.OSDisplayVersion)
	populate(objectMap, "osName", c.OSName)
	populate(objectMap, "osVersion", c.OSVersion)
	populate(objectMap, "oemActivation", c.OemActivation)
	populate(objectMap, "serialNumber", c.SerialNumber)
	populate(objectMap, "windowsServerSubscription", c.WindowsServerSubscription)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterNode.
func (c *ClusterNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coreCount":
			err = unpopulate(val, "CoreCount", &c.CoreCount)
			delete(rawMsg, key)
		case "ehcResourceId":
			err = unpopulate(val, "EhcResourceID", &c.EhcResourceID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "lastLicensingTimestamp":
			err = unpopulateDateTimeRFC3339(val, "LastLicensingTimestamp", &c.LastLicensingTimestamp)
			delete(rawMsg, key)
		case "manufacturer":
			err = unpopulate(val, "Manufacturer", &c.Manufacturer)
			delete(rawMsg, key)
		case "memoryInGiB":
			err = unpopulate(val, "MemoryInGiB", &c.MemoryInGiB)
			delete(rawMsg, key)
		case "model":
			err = unpopulate(val, "Model", &c.Model)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "nodeType":
			err = unpopulate(val, "NodeType", &c.NodeType)
			delete(rawMsg, key)
		case "osDisplayVersion":
			err = unpopulate(val, "OSDisplayVersion", &c.OSDisplayVersion)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &c.OSName)
			delete(rawMsg, key)
		case "osVersion":
			err = unpopulate(val, "OSVersion", &c.OSVersion)
			delete(rawMsg, key)
		case "oemActivation":
			err = unpopulate(val, "OemActivation", &c.OemActivation)
			delete(rawMsg, key)
		case "serialNumber":
			err = unpopulate(val, "SerialNumber", &c.SerialNumber)
			delete(rawMsg, key)
		case "windowsServerSubscription":
			err = unpopulate(val, "WindowsServerSubscription", &c.WindowsServerSubscription)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterPatch.
func (c ClusterPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", c.Identity)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterPatch.
func (c *ClusterPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, "Identity", &c.Identity)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterPatchProperties.
func (c ClusterPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aadClientId", c.AADClientID)
	populate(objectMap, "aadTenantId", c.AADTenantID)
	populate(objectMap, "cloudManagementEndpoint", c.CloudManagementEndpoint)
	populate(objectMap, "desiredProperties", c.DesiredProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterPatchProperties.
func (c *ClusterPatchProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadClientId":
			err = unpopulate(val, "AADClientID", &c.AADClientID)
			delete(rawMsg, key)
		case "aadTenantId":
			err = unpopulate(val, "AADTenantID", &c.AADTenantID)
			delete(rawMsg, key)
		case "cloudManagementEndpoint":
			err = unpopulate(val, "CloudManagementEndpoint", &c.CloudManagementEndpoint)
			delete(rawMsg, key)
		case "desiredProperties":
			err = unpopulate(val, "DesiredProperties", &c.DesiredProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterProperties.
func (c ClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aadApplicationObjectId", c.AADApplicationObjectID)
	populate(objectMap, "aadClientId", c.AADClientID)
	populate(objectMap, "aadServicePrincipalObjectId", c.AADServicePrincipalObjectID)
	populate(objectMap, "aadTenantId", c.AADTenantID)
	populate(objectMap, "billingModel", c.BillingModel)
	populate(objectMap, "cloudId", c.CloudID)
	populate(objectMap, "cloudManagementEndpoint", c.CloudManagementEndpoint)
	populate(objectMap, "clusterPattern", c.ClusterPattern)
	populate(objectMap, "confidentialVmProperties", c.ConfidentialVMProperties)
	populate(objectMap, "connectivityStatus", c.ConnectivityStatus)
	populate(objectMap, "desiredProperties", c.DesiredProperties)
	populate(objectMap, "identityProvider", c.IdentityProvider)
	populate(objectMap, "isManagementCluster", c.IsManagementCluster)
	populate(objectMap, "isolatedVmAttestationConfiguration", c.IsolatedVMAttestationConfiguration)
	populateDateTimeRFC3339(objectMap, "lastBillingTimestamp", c.LastBillingTimestamp)
	populateDateTimeRFC3339(objectMap, "lastSyncTimestamp", c.LastSyncTimestamp)
	populate(objectMap, "localAvailabilityZones", c.LocalAvailabilityZones)
	populate(objectMap, "logCollectionProperties", c.LogCollectionProperties)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populateDateTimeRFC3339(objectMap, "registrationTimestamp", c.RegistrationTimestamp)
	populate(objectMap, "remoteSupportProperties", c.RemoteSupportProperties)
	populate(objectMap, "reportedProperties", c.ReportedProperties)
	populate(objectMap, "resourceProviderObjectId", c.ResourceProviderObjectID)
	populate(objectMap, "ring", c.Ring)
	populate(objectMap, "sdnProperties", c.SdnProperties)
	populate(objectMap, "secretsLocations", c.SecretsLocations)
	populate(objectMap, "serviceEndpoint", c.ServiceEndpoint)
	populate(objectMap, "softwareAssuranceProperties", c.SoftwareAssuranceProperties)
	populate(objectMap, "status", c.Status)
	populate(objectMap, "supportStatus", c.SupportStatus)
	populate(objectMap, "trialDaysRemaining", c.TrialDaysRemaining)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterProperties.
func (c *ClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadApplicationObjectId":
			err = unpopulate(val, "AADApplicationObjectID", &c.AADApplicationObjectID)
			delete(rawMsg, key)
		case "aadClientId":
			err = unpopulate(val, "AADClientID", &c.AADClientID)
			delete(rawMsg, key)
		case "aadServicePrincipalObjectId":
			err = unpopulate(val, "AADServicePrincipalObjectID", &c.AADServicePrincipalObjectID)
			delete(rawMsg, key)
		case "aadTenantId":
			err = unpopulate(val, "AADTenantID", &c.AADTenantID)
			delete(rawMsg, key)
		case "billingModel":
			err = unpopulate(val, "BillingModel", &c.BillingModel)
			delete(rawMsg, key)
		case "cloudId":
			err = unpopulate(val, "CloudID", &c.CloudID)
			delete(rawMsg, key)
		case "cloudManagementEndpoint":
			err = unpopulate(val, "CloudManagementEndpoint", &c.CloudManagementEndpoint)
			delete(rawMsg, key)
		case "clusterPattern":
			err = unpopulate(val, "ClusterPattern", &c.ClusterPattern)
			delete(rawMsg, key)
		case "confidentialVmProperties":
			err = unpopulate(val, "ConfidentialVMProperties", &c.ConfidentialVMProperties)
			delete(rawMsg, key)
		case "connectivityStatus":
			err = unpopulate(val, "ConnectivityStatus", &c.ConnectivityStatus)
			delete(rawMsg, key)
		case "desiredProperties":
			err = unpopulate(val, "DesiredProperties", &c.DesiredProperties)
			delete(rawMsg, key)
		case "identityProvider":
			err = unpopulate(val, "IdentityProvider", &c.IdentityProvider)
			delete(rawMsg, key)
		case "isManagementCluster":
			err = unpopulate(val, "IsManagementCluster", &c.IsManagementCluster)
			delete(rawMsg, key)
		case "isolatedVmAttestationConfiguration":
			err = unpopulate(val, "IsolatedVMAttestationConfiguration", &c.IsolatedVMAttestationConfiguration)
			delete(rawMsg, key)
		case "lastBillingTimestamp":
			err = unpopulateDateTimeRFC3339(val, "LastBillingTimestamp", &c.LastBillingTimestamp)
			delete(rawMsg, key)
		case "lastSyncTimestamp":
			err = unpopulateDateTimeRFC3339(val, "LastSyncTimestamp", &c.LastSyncTimestamp)
			delete(rawMsg, key)
		case "localAvailabilityZones":
			err = unpopulate(val, "LocalAvailabilityZones", &c.LocalAvailabilityZones)
			delete(rawMsg, key)
		case "logCollectionProperties":
			err = unpopulate(val, "LogCollectionProperties", &c.LogCollectionProperties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "registrationTimestamp":
			err = unpopulateDateTimeRFC3339(val, "RegistrationTimestamp", &c.RegistrationTimestamp)
			delete(rawMsg, key)
		case "remoteSupportProperties":
			err = unpopulate(val, "RemoteSupportProperties", &c.RemoteSupportProperties)
			delete(rawMsg, key)
		case "reportedProperties":
			err = unpopulate(val, "ReportedProperties", &c.ReportedProperties)
			delete(rawMsg, key)
		case "resourceProviderObjectId":
			err = unpopulate(val, "ResourceProviderObjectID", &c.ResourceProviderObjectID)
			delete(rawMsg, key)
		case "ring":
			err = unpopulate(val, "Ring", &c.Ring)
			delete(rawMsg, key)
		case "sdnProperties":
			err = unpopulate(val, "SdnProperties", &c.SdnProperties)
			delete(rawMsg, key)
		case "secretsLocations":
			err = unpopulate(val, "SecretsLocations", &c.SecretsLocations)
			delete(rawMsg, key)
		case "serviceEndpoint":
			err = unpopulate(val, "ServiceEndpoint", &c.ServiceEndpoint)
			delete(rawMsg, key)
		case "softwareAssuranceProperties":
			err = unpopulate(val, "SoftwareAssuranceProperties", &c.SoftwareAssuranceProperties)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &c.Status)
			delete(rawMsg, key)
		case "supportStatus":
			err = unpopulate(val, "SupportStatus", &c.SupportStatus)
			delete(rawMsg, key)
		case "trialDaysRemaining":
			err = unpopulate(val, "TrialDaysRemaining", &c.TrialDaysRemaining)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterReportedProperties.
func (c ClusterReportedProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterId", c.ClusterID)
	populate(objectMap, "clusterName", c.ClusterName)
	populate(objectMap, "clusterType", c.ClusterType)
	populate(objectMap, "clusterVersion", c.ClusterVersion)
	populate(objectMap, "diagnosticLevel", c.DiagnosticLevel)
	populate(objectMap, "hardwareClass", c.HardwareClass)
	populate(objectMap, "imdsAttestation", c.ImdsAttestation)
	populateDateTimeRFC3339(objectMap, "lastUpdated", c.LastUpdated)
	populate(objectMap, "manufacturer", c.Manufacturer)
	populateDateTimeRFC3339(objectMap, "msiExpirationTimeStamp", c.MsiExpirationTimeStamp)
	populate(objectMap, "nodes", c.Nodes)
	populate(objectMap, "oemActivation", c.OemActivation)
	populate(objectMap, "supportedCapabilities", c.SupportedCapabilities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterReportedProperties.
func (c *ClusterReportedProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterId":
			err = unpopulate(val, "ClusterID", &c.ClusterID)
			delete(rawMsg, key)
		case "clusterName":
			err = unpopulate(val, "ClusterName", &c.ClusterName)
			delete(rawMsg, key)
		case "clusterType":
			err = unpopulate(val, "ClusterType", &c.ClusterType)
			delete(rawMsg, key)
		case "clusterVersion":
			err = unpopulate(val, "ClusterVersion", &c.ClusterVersion)
			delete(rawMsg, key)
		case "diagnosticLevel":
			err = unpopulate(val, "DiagnosticLevel", &c.DiagnosticLevel)
			delete(rawMsg, key)
		case "hardwareClass":
			err = unpopulate(val, "HardwareClass", &c.HardwareClass)
			delete(rawMsg, key)
		case "imdsAttestation":
			err = unpopulate(val, "ImdsAttestation", &c.ImdsAttestation)
			delete(rawMsg, key)
		case "lastUpdated":
			err = unpopulateDateTimeRFC3339(val, "LastUpdated", &c.LastUpdated)
			delete(rawMsg, key)
		case "manufacturer":
			err = unpopulate(val, "Manufacturer", &c.Manufacturer)
			delete(rawMsg, key)
		case "msiExpirationTimeStamp":
			err = unpopulateDateTimeRFC3339(val, "MsiExpirationTimeStamp", &c.MsiExpirationTimeStamp)
			delete(rawMsg, key)
		case "nodes":
			err = unpopulate(val, "Nodes", &c.Nodes)
			delete(rawMsg, key)
		case "oemActivation":
			err = unpopulate(val, "OemActivation", &c.OemActivation)
			delete(rawMsg, key)
		case "supportedCapabilities":
			err = unpopulate(val, "SupportedCapabilities", &c.SupportedCapabilities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterSdnProperties.
func (c ClusterSdnProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sdnApiAddress", c.SdnAPIAddress)
	populate(objectMap, "sdnDomainName", c.SdnDomainName)
	populate(objectMap, "sdnIntegrationIntent", c.SdnIntegrationIntent)
	populate(objectMap, "sdnStatus", c.SdnStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterSdnProperties.
func (c *ClusterSdnProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sdnApiAddress":
			err = unpopulate(val, "SdnAPIAddress", &c.SdnAPIAddress)
			delete(rawMsg, key)
		case "sdnDomainName":
			err = unpopulate(val, "SdnDomainName", &c.SdnDomainName)
			delete(rawMsg, key)
		case "sdnIntegrationIntent":
			err = unpopulate(val, "SdnIntegrationIntent", &c.SdnIntegrationIntent)
			delete(rawMsg, key)
		case "sdnStatus":
			err = unpopulate(val, "SdnStatus", &c.SdnStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConfidentialVMProfile.
func (c ConfidentialVMProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "igvmStatus", c.IgvmStatus)
	populate(objectMap, "statusDetails", c.StatusDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConfidentialVMProfile.
func (c *ConfidentialVMProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "igvmStatus":
			err = unpopulate(val, "IgvmStatus", &c.IgvmStatus)
			delete(rawMsg, key)
		case "statusDetails":
			err = unpopulate(val, "StatusDetails", &c.StatusDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConfidentialVMProperties.
func (c ConfidentialVMProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "confidentialVmIntent", c.ConfidentialVMIntent)
	populate(objectMap, "confidentialVmStatus", c.ConfidentialVMStatus)
	populate(objectMap, "confidentialVmStatusSummary", c.ConfidentialVMStatusSummary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConfidentialVMProperties.
func (c *ConfidentialVMProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "confidentialVmIntent":
			err = unpopulate(val, "ConfidentialVMIntent", &c.ConfidentialVMIntent)
			delete(rawMsg, key)
		case "confidentialVmStatus":
			err = unpopulate(val, "ConfidentialVMStatus", &c.ConfidentialVMStatus)
			delete(rawMsg, key)
		case "confidentialVmStatusSummary":
			err = unpopulate(val, "ConfidentialVMStatusSummary", &c.ConfidentialVMStatusSummary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentPayload.
func (c ContentPayload) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fileName", c.FileName)
	populate(objectMap, "group", c.Group)
	populate(objectMap, "hash", c.Hash)
	populate(objectMap, "hashAlgorithm", c.HashAlgorithm)
	populate(objectMap, "identifier", c.Identifier)
	populate(objectMap, "packageSizeInBytes", c.PackageSizeInBytes)
	populate(objectMap, "url", c.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentPayload.
func (c *ContentPayload) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &c.FileName)
			delete(rawMsg, key)
		case "group":
			err = unpopulate(val, "Group", &c.Group)
			delete(rawMsg, key)
		case "hash":
			err = unpopulate(val, "Hash", &c.Hash)
			delete(rawMsg, key)
		case "hashAlgorithm":
			err = unpopulate(val, "HashAlgorithm", &c.HashAlgorithm)
			delete(rawMsg, key)
		case "identifier":
			err = unpopulate(val, "Identifier", &c.Identifier)
			delete(rawMsg, key)
		case "packageSizeInBytes":
			err = unpopulate(val, "PackageSizeInBytes", &c.PackageSizeInBytes)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &c.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSZones.
func (d DNSZones) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dnsForwarder", d.DNSForwarder)
	populate(objectMap, "dnsZoneName", d.DNSZoneName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSZones.
func (d *DNSZones) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dnsForwarder":
			err = unpopulate(val, "DNSForwarder", &d.DNSForwarder)
			delete(rawMsg, key)
		case "dnsZoneName":
			err = unpopulate(val, "DNSZoneName", &d.DNSZoneName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DefaultExtensionDetails.
func (d DefaultExtensionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "category", d.Category)
	populateDateTimeRFC3339(objectMap, "consentTime", d.ConsentTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DefaultExtensionDetails.
func (d *DefaultExtensionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
			err = unpopulate(val, "Category", &d.Category)
			delete(rawMsg, key)
		case "consentTime":
			err = unpopulateDateTimeRFC3339(val, "ConsentTime", &d.ConsentTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentCluster.
func (d DeploymentCluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureServiceEndpoint", d.AzureServiceEndpoint)
	populate(objectMap, "cloudAccountName", d.CloudAccountName)
	populate(objectMap, "clusterPattern", d.ClusterPattern)
	populate(objectMap, "hardwareClass", d.HardwareClass)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "witnessPath", d.WitnessPath)
	populate(objectMap, "witnessType", d.WitnessType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentCluster.
func (d *DeploymentCluster) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureServiceEndpoint":
			err = unpopulate(val, "AzureServiceEndpoint", &d.AzureServiceEndpoint)
			delete(rawMsg, key)
		case "cloudAccountName":
			err = unpopulate(val, "CloudAccountName", &d.CloudAccountName)
			delete(rawMsg, key)
		case "clusterPattern":
			err = unpopulate(val, "ClusterPattern", &d.ClusterPattern)
			delete(rawMsg, key)
		case "hardwareClass":
			err = unpopulate(val, "HardwareClass", &d.HardwareClass)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "witnessPath":
			err = unpopulate(val, "WitnessPath", &d.WitnessPath)
			delete(rawMsg, key)
		case "witnessType":
			err = unpopulate(val, "WitnessType", &d.WitnessType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentConfiguration.
func (d DeploymentConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "scaleUnits", d.ScaleUnits)
	populate(objectMap, "version", d.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentConfiguration.
func (d *DeploymentConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scaleUnits":
			err = unpopulate(val, "ScaleUnits", &d.ScaleUnits)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &d.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentData.
func (d DeploymentData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adouPath", d.AdouPath)
	populate(objectMap, "assemblyInfo", d.AssemblyInfo)
	populate(objectMap, "cluster", d.Cluster)
	populate(objectMap, "domainFqdn", d.DomainFqdn)
	populate(objectMap, "hostNetwork", d.HostNetwork)
	populate(objectMap, "identityProvider", d.IdentityProvider)
	populate(objectMap, "infrastructureNetwork", d.InfrastructureNetwork)
	populate(objectMap, "isManagementCluster", d.IsManagementCluster)
	populate(objectMap, "localAvailabilityZones", d.LocalAvailabilityZones)
	populate(objectMap, "namingPrefix", d.NamingPrefix)
	populate(objectMap, "observability", d.Observability)
	populate(objectMap, "optionalServices", d.OptionalServices)
	populate(objectMap, "physicalNodes", d.PhysicalNodes)
	populate(objectMap, "sdnIntegration", d.SdnIntegration)
	populate(objectMap, "secrets", d.Secrets)
	populate(objectMap, "secretsLocation", d.SecretsLocation)
	populate(objectMap, "securitySettings", d.SecuritySettings)
	populate(objectMap, "storage", d.Storage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentData.
func (d *DeploymentData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adouPath":
			err = unpopulate(val, "AdouPath", &d.AdouPath)
			delete(rawMsg, key)
		case "assemblyInfo":
			err = unpopulate(val, "AssemblyInfo", &d.AssemblyInfo)
			delete(rawMsg, key)
		case "cluster":
			err = unpopulate(val, "Cluster", &d.Cluster)
			delete(rawMsg, key)
		case "domainFqdn":
			err = unpopulate(val, "DomainFqdn", &d.DomainFqdn)
			delete(rawMsg, key)
		case "hostNetwork":
			err = unpopulate(val, "HostNetwork", &d.HostNetwork)
			delete(rawMsg, key)
		case "identityProvider":
			err = unpopulate(val, "IdentityProvider", &d.IdentityProvider)
			delete(rawMsg, key)
		case "infrastructureNetwork":
			err = unpopulate(val, "InfrastructureNetwork", &d.InfrastructureNetwork)
			delete(rawMsg, key)
		case "isManagementCluster":
			err = unpopulate(val, "IsManagementCluster", &d.IsManagementCluster)
			delete(rawMsg, key)
		case "localAvailabilityZones":
			err = unpopulate(val, "LocalAvailabilityZones", &d.LocalAvailabilityZones)
			delete(rawMsg, key)
		case "namingPrefix":
			err = unpopulate(val, "NamingPrefix", &d.NamingPrefix)
			delete(rawMsg, key)
		case "observability":
			err = unpopulate(val, "Observability", &d.Observability)
			delete(rawMsg, key)
		case "optionalServices":
			err = unpopulate(val, "OptionalServices", &d.OptionalServices)
			delete(rawMsg, key)
		case "physicalNodes":
			err = unpopulate(val, "PhysicalNodes", &d.PhysicalNodes)
			delete(rawMsg, key)
		case "sdnIntegration":
			err = unpopulate(val, "SdnIntegration", &d.SdnIntegration)
			delete(rawMsg, key)
		case "secrets":
			err = unpopulate(val, "Secrets", &d.Secrets)
			delete(rawMsg, key)
		case "secretsLocation":
			err = unpopulate(val, "SecretsLocation", &d.SecretsLocation)
			delete(rawMsg, key)
		case "securitySettings":
			err = unpopulate(val, "SecuritySettings", &d.SecuritySettings)
			delete(rawMsg, key)
		case "storage":
			err = unpopulate(val, "Storage", &d.Storage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentSecuritySettings.
func (d DeploymentSecuritySettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bitlockerBootVolume", d.BitlockerBootVolume)
	populate(objectMap, "bitlockerDataVolumes", d.BitlockerDataVolumes)
	populate(objectMap, "credentialGuardEnforced", d.CredentialGuardEnforced)
	populate(objectMap, "driftControlEnforced", d.DriftControlEnforced)
	populate(objectMap, "drtmProtection", d.DrtmProtection)
	populate(objectMap, "hvciProtection", d.HvciProtection)
	populate(objectMap, "sideChannelMitigationEnforced", d.SideChannelMitigationEnforced)
	populate(objectMap, "smbClusterEncryption", d.SmbClusterEncryption)
	populate(objectMap, "smbSigningEnforced", d.SmbSigningEnforced)
	populate(objectMap, "wdacEnforced", d.WdacEnforced)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentSecuritySettings.
func (d *DeploymentSecuritySettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bitlockerBootVolume":
			err = unpopulate(val, "BitlockerBootVolume", &d.BitlockerBootVolume)
			delete(rawMsg, key)
		case "bitlockerDataVolumes":
			err = unpopulate(val, "BitlockerDataVolumes", &d.BitlockerDataVolumes)
			delete(rawMsg, key)
		case "credentialGuardEnforced":
			err = unpopulate(val, "CredentialGuardEnforced", &d.CredentialGuardEnforced)
			delete(rawMsg, key)
		case "driftControlEnforced":
			err = unpopulate(val, "DriftControlEnforced", &d.DriftControlEnforced)
			delete(rawMsg, key)
		case "drtmProtection":
			err = unpopulate(val, "DrtmProtection", &d.DrtmProtection)
			delete(rawMsg, key)
		case "hvciProtection":
			err = unpopulate(val, "HvciProtection", &d.HvciProtection)
			delete(rawMsg, key)
		case "sideChannelMitigationEnforced":
			err = unpopulate(val, "SideChannelMitigationEnforced", &d.SideChannelMitigationEnforced)
			delete(rawMsg, key)
		case "smbClusterEncryption":
			err = unpopulate(val, "SmbClusterEncryption", &d.SmbClusterEncryption)
			delete(rawMsg, key)
		case "smbSigningEnforced":
			err = unpopulate(val, "SmbSigningEnforced", &d.SmbSigningEnforced)
			delete(rawMsg, key)
		case "wdacEnforced":
			err = unpopulate(val, "WdacEnforced", &d.WdacEnforced)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentSetting.
func (d DeploymentSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentSetting.
func (d *DeploymentSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentSettingAdapterPropertyOverrides.
func (d DeploymentSettingAdapterPropertyOverrides) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "jumboPacket", d.JumboPacket)
	populate(objectMap, "networkDirect", d.NetworkDirect)
	populate(objectMap, "networkDirectTechnology", d.NetworkDirectTechnology)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentSettingAdapterPropertyOverrides.
func (d *DeploymentSettingAdapterPropertyOverrides) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jumboPacket":
			err = unpopulate(val, "JumboPacket", &d.JumboPacket)
			delete(rawMsg, key)
		case "networkDirect":
			err = unpopulate(val, "NetworkDirect", &d.NetworkDirect)
			delete(rawMsg, key)
		case "networkDirectTechnology":
			err = unpopulate(val, "NetworkDirectTechnology", &d.NetworkDirectTechnology)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentSettingHostNetwork.
func (d DeploymentSettingHostNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enableStorageAutoIp", d.EnableStorageAutoIP)
	populate(objectMap, "intents", d.Intents)
	populate(objectMap, "storageConnectivitySwitchless", d.StorageConnectivitySwitchless)
	populate(objectMap, "storageNetworks", d.StorageNetworks)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentSettingHostNetwork.
func (d *DeploymentSettingHostNetwork) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableStorageAutoIp":
			err = unpopulate(val, "EnableStorageAutoIP", &d.EnableStorageAutoIP)
			delete(rawMsg, key)
		case "intents":
			err = unpopulate(val, "Intents", &d.Intents)
			delete(rawMsg, key)
		case "storageConnectivitySwitchless":
			err = unpopulate(val, "StorageConnectivitySwitchless", &d.StorageConnectivitySwitchless)
			delete(rawMsg, key)
		case "storageNetworks":
			err = unpopulate(val, "StorageNetworks", &d.StorageNetworks)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentSettingIntents.
func (d DeploymentSettingIntents) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adapter", d.Adapter)
	populate(objectMap, "adapterPropertyOverrides", d.AdapterPropertyOverrides)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "overrideAdapterProperty", d.OverrideAdapterProperty)
	populate(objectMap, "overrideQosPolicy", d.OverrideQosPolicy)
	populate(objectMap, "overrideVirtualSwitchConfiguration", d.OverrideVirtualSwitchConfiguration)
	populate(objectMap, "qosPolicyOverrides", d.QosPolicyOverrides)
	populate(objectMap, "trafficType", d.TrafficType)
	populate(objectMap, "virtualSwitchConfigurationOverrides", d.VirtualSwitchConfigurationOverrides)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentSettingIntents.
func (d *DeploymentSettingIntents) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adapter":
			err = unpopulate(val, "Adapter", &d.Adapter)
			delete(rawMsg, key)
		case "adapterPropertyOverrides":
			err = unpopulate(val, "AdapterPropertyOverrides", &d.AdapterPropertyOverrides)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "overrideAdapterProperty":
			err = unpopulate(val, "OverrideAdapterProperty", &d.OverrideAdapterProperty)
			delete(rawMsg, key)
		case "overrideQosPolicy":
			err = unpopulate(val, "OverrideQosPolicy", &d.OverrideQosPolicy)
			delete(rawMsg, key)
		case "overrideVirtualSwitchConfiguration":
			err = unpopulate(val, "OverrideVirtualSwitchConfiguration", &d.OverrideVirtualSwitchConfiguration)
			delete(rawMsg, key)
		case "qosPolicyOverrides":
			err = unpopulate(val, "QosPolicyOverrides", &d.QosPolicyOverrides)
			delete(rawMsg, key)
		case "trafficType":
			err = unpopulate(val, "TrafficType", &d.TrafficType)
			delete(rawMsg, key)
		case "virtualSwitchConfigurationOverrides":
			err = unpopulate(val, "VirtualSwitchConfigurationOverrides", &d.VirtualSwitchConfigurationOverrides)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentSettingListResult.
func (d DeploymentSettingListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentSettingListResult.
func (d *DeploymentSettingListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentSettingStorageAdapterIPInfo.
func (d DeploymentSettingStorageAdapterIPInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipv4Address", d.IPv4Address)
	populate(objectMap, "physicalNode", d.PhysicalNode)
	populate(objectMap, "subnetMask", d.SubnetMask)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentSettingStorageAdapterIPInfo.
func (d *DeploymentSettingStorageAdapterIPInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipv4Address":
			err = unpopulate(val, "IPv4Address", &d.IPv4Address)
			delete(rawMsg, key)
		case "physicalNode":
			err = unpopulate(val, "PhysicalNode", &d.PhysicalNode)
			delete(rawMsg, key)
		case "subnetMask":
			err = unpopulate(val, "SubnetMask", &d.SubnetMask)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentSettingStorageNetworks.
func (d DeploymentSettingStorageNetworks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "networkAdapterName", d.NetworkAdapterName)
	populate(objectMap, "storageAdapterIPInfo", d.StorageAdapterIPInfo)
	populate(objectMap, "vlanId", d.VlanID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentSettingStorageNetworks.
func (d *DeploymentSettingStorageNetworks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "networkAdapterName":
			err = unpopulate(val, "NetworkAdapterName", &d.NetworkAdapterName)
			delete(rawMsg, key)
		case "storageAdapterIPInfo":
			err = unpopulate(val, "StorageAdapterIPInfo", &d.StorageAdapterIPInfo)
			delete(rawMsg, key)
		case "vlanId":
			err = unpopulate(val, "VlanID", &d.VlanID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentSettingVirtualSwitchConfigurationOverrides.
func (d DeploymentSettingVirtualSwitchConfigurationOverrides) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enableIov", d.EnableIov)
	populate(objectMap, "loadBalancingAlgorithm", d.LoadBalancingAlgorithm)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentSettingVirtualSwitchConfigurationOverrides.
func (d *DeploymentSettingVirtualSwitchConfigurationOverrides) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableIov":
			err = unpopulate(val, "EnableIov", &d.EnableIov)
			delete(rawMsg, key)
		case "loadBalancingAlgorithm":
			err = unpopulate(val, "LoadBalancingAlgorithm", &d.LoadBalancingAlgorithm)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentSettingsProperties.
func (d DeploymentSettingsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arcNodeResourceIds", d.ArcNodeResourceIDs)
	populate(objectMap, "deploymentConfiguration", d.DeploymentConfiguration)
	populate(objectMap, "deploymentMode", d.DeploymentMode)
	populate(objectMap, "operationType", d.OperationType)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "reportedProperties", d.ReportedProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentSettingsProperties.
func (d *DeploymentSettingsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arcNodeResourceIds":
			err = unpopulate(val, "ArcNodeResourceIDs", &d.ArcNodeResourceIDs)
			delete(rawMsg, key)
		case "deploymentConfiguration":
			err = unpopulate(val, "DeploymentConfiguration", &d.DeploymentConfiguration)
			delete(rawMsg, key)
		case "deploymentMode":
			err = unpopulate(val, "DeploymentMode", &d.DeploymentMode)
			delete(rawMsg, key)
		case "operationType":
			err = unpopulate(val, "OperationType", &d.OperationType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "reportedProperties":
			err = unpopulate(val, "ReportedProperties", &d.ReportedProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentStep.
func (d DeploymentStep) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "endTimeUtc", d.EndTimeUTC)
	populate(objectMap, "exception", d.Exception)
	populate(objectMap, "fullStepIndex", d.FullStepIndex)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "startTimeUtc", d.StartTimeUTC)
	populate(objectMap, "status", d.Status)
	populate(objectMap, "steps", d.Steps)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentStep.
func (d *DeploymentStep) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulate(val, "EndTimeUTC", &d.EndTimeUTC)
			delete(rawMsg, key)
		case "exception":
			err = unpopulate(val, "Exception", &d.Exception)
			delete(rawMsg, key)
		case "fullStepIndex":
			err = unpopulate(val, "FullStepIndex", &d.FullStepIndex)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulate(val, "StartTimeUTC", &d.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &d.Status)
			delete(rawMsg, key)
		case "steps":
			err = unpopulate(val, "Steps", &d.Steps)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeviceConfiguration.
func (d DeviceConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deviceMetadata", d.DeviceMetadata)
	populate(objectMap, "nicDetails", d.NicDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeviceConfiguration.
func (d *DeviceConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deviceMetadata":
			err = unpopulate(val, "DeviceMetadata", &d.DeviceMetadata)
			delete(rawMsg, key)
		case "nicDetails":
			err = unpopulate(val, "NicDetails", &d.NicDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DownloadOsJobProperties.
func (d DownloadOsJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentMode", d.DeploymentMode)
	populate(objectMap, "downloadRequest", d.DownloadRequest)
	populateDateTimeRFC3339(objectMap, "endTimeUtc", d.EndTimeUTC)
	populate(objectMap, "error", d.Error)
	populate(objectMap, "jobId", d.JobID)
	objectMap["jobType"] = EdgeMachineJobTypeDownloadOs
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "reportedProperties", d.ReportedProperties)
	populateDateTimeRFC3339(objectMap, "startTimeUtc", d.StartTimeUTC)
	populate(objectMap, "status", d.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DownloadOsJobProperties.
func (d *DownloadOsJobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentMode":
			err = unpopulate(val, "DeploymentMode", &d.DeploymentMode)
			delete(rawMsg, key)
		case "downloadRequest":
			err = unpopulate(val, "DownloadRequest", &d.DownloadRequest)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "EndTimeUTC", &d.EndTimeUTC)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &d.Error)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, "JobID", &d.JobID)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &d.JobType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "reportedProperties":
			err = unpopulate(val, "ReportedProperties", &d.ReportedProperties)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "StartTimeUTC", &d.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &d.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DownloadOsProfile.
func (d DownloadOsProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "gpgPubKey", d.GpgPubKey)
	populate(objectMap, "imageHash", d.ImageHash)
	populate(objectMap, "osImageLocation", d.OSImageLocation)
	populate(objectMap, "osName", d.OSName)
	populate(objectMap, "osType", d.OSType)
	populate(objectMap, "osVersion", d.OSVersion)
	populate(objectMap, "vsrVersion", d.VsrVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DownloadOsProfile.
func (d *DownloadOsProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "gpgPubKey":
			err = unpopulate(val, "GpgPubKey", &d.GpgPubKey)
			delete(rawMsg, key)
		case "imageHash":
			err = unpopulate(val, "ImageHash", &d.ImageHash)
			delete(rawMsg, key)
		case "osImageLocation":
			err = unpopulate(val, "OSImageLocation", &d.OSImageLocation)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &d.OSName)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &d.OSType)
			delete(rawMsg, key)
		case "osVersion":
			err = unpopulate(val, "OSVersion", &d.OSVersion)
			delete(rawMsg, key)
		case "vsrVersion":
			err = unpopulate(val, "VsrVersion", &d.VsrVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DownloadRequest.
func (d DownloadRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "osProfile", d.OSProfile)
	populate(objectMap, "target", d.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DownloadRequest.
func (d *DownloadRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "osProfile":
			err = unpopulate(val, "OSProfile", &d.OSProfile)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &d.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EceActionStatus.
func (e EceActionStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "status", e.Status)
	populate(objectMap, "steps", e.Steps)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EceActionStatus.
func (e *EceActionStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "status":
			err = unpopulate(val, "Status", &e.Status)
			delete(rawMsg, key)
		case "steps":
			err = unpopulate(val, "Steps", &e.Steps)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EceDeploymentSecrets.
func (e EceDeploymentSecrets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eceSecretName", e.EceSecretName)
	populate(objectMap, "secretLocation", e.SecretLocation)
	populate(objectMap, "secretName", e.SecretName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EceDeploymentSecrets.
func (e *EceDeploymentSecrets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eceSecretName":
			err = unpopulate(val, "EceSecretName", &e.EceSecretName)
			delete(rawMsg, key)
		case "secretLocation":
			err = unpopulate(val, "SecretLocation", &e.SecretLocation)
			delete(rawMsg, key)
		case "secretName":
			err = unpopulate(val, "SecretName", &e.SecretName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EceReportedProperties.
func (e EceReportedProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentStatus", e.DeploymentStatus)
	populate(objectMap, "validationStatus", e.ValidationStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EceReportedProperties.
func (e *EceReportedProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentStatus":
			err = unpopulate(val, "DeploymentStatus", &e.DeploymentStatus)
			delete(rawMsg, key)
		case "validationStatus":
			err = unpopulate(val, "ValidationStatus", &e.ValidationStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeDevice.
func (e EdgeDevice) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "kind", e.Kind)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeDevice.
func (e *EdgeDevice) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &e.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeDeviceJob.
func (e EdgeDeviceJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "kind", e.Kind)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeDeviceJob.
func (e *EdgeDeviceJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &e.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeDeviceJobListResult.
func (e EdgeDeviceJobListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeDeviceJobListResult.
func (e *EdgeDeviceJobListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			e.Value, err = unmarshalEdgeDeviceJobClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeDeviceListResult.
func (e EdgeDeviceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeDeviceListResult.
func (e *EdgeDeviceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			e.Value, err = unmarshalEdgeDeviceClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachine.
func (e EdgeMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "identity", e.Identity)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "tags", e.Tags)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachine.
func (e *EdgeMachine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &e.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &e.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &e.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineCollectLogJobProperties.
func (e EdgeMachineCollectLogJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentMode", e.DeploymentMode)
	populateDateTimeRFC3339(objectMap, "endTimeUtc", e.EndTimeUTC)
	populate(objectMap, "error", e.Error)
	populateDateTimeRFC3339(objectMap, "fromDate", e.FromDate)
	populate(objectMap, "jobId", e.JobID)
	objectMap["jobType"] = EdgeMachineJobTypeCollectLog
	populateDateTimeRFC3339(objectMap, "lastLogGenerated", e.LastLogGenerated)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "reportedProperties", e.ReportedProperties)
	populateDateTimeRFC3339(objectMap, "startTimeUtc", e.StartTimeUTC)
	populate(objectMap, "status", e.Status)
	populateDateTimeRFC3339(objectMap, "toDate", e.ToDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineCollectLogJobProperties.
func (e *EdgeMachineCollectLogJobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentMode":
			err = unpopulate(val, "DeploymentMode", &e.DeploymentMode)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "EndTimeUTC", &e.EndTimeUTC)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		case "fromDate":
			err = unpopulateDateTimeRFC3339(val, "FromDate", &e.FromDate)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, "JobID", &e.JobID)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &e.JobType)
			delete(rawMsg, key)
		case "lastLogGenerated":
			err = unpopulateDateTimeRFC3339(val, "LastLogGenerated", &e.LastLogGenerated)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		case "reportedProperties":
			err = unpopulate(val, "ReportedProperties", &e.ReportedProperties)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "StartTimeUTC", &e.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &e.Status)
			delete(rawMsg, key)
		case "toDate":
			err = unpopulateDateTimeRFC3339(val, "ToDate", &e.ToDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineCollectLogJobReportedProperties.
func (e EdgeMachineCollectLogJobReportedProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentStatus", e.DeploymentStatus)
	populate(objectMap, "logCollectionSessionDetails", e.LogCollectionSessionDetails)
	populate(objectMap, "percentComplete", e.PercentComplete)
	populate(objectMap, "validationStatus", e.ValidationStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineCollectLogJobReportedProperties.
func (e *EdgeMachineCollectLogJobReportedProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentStatus":
			err = unpopulate(val, "DeploymentStatus", &e.DeploymentStatus)
			delete(rawMsg, key)
		case "logCollectionSessionDetails":
			err = unpopulate(val, "LogCollectionSessionDetails", &e.LogCollectionSessionDetails)
			delete(rawMsg, key)
		case "percentComplete":
			err = unpopulate(val, "PercentComplete", &e.PercentComplete)
			delete(rawMsg, key)
		case "validationStatus":
			err = unpopulate(val, "ValidationStatus", &e.ValidationStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineJob.
func (e EdgeMachineJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineJob.
func (e *EdgeMachineJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			e.Properties, err = unmarshalEdgeMachineJobPropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineJobListResult.
func (e EdgeMachineJobListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineJobListResult.
func (e *EdgeMachineJobListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineJobProperties.
func (e EdgeMachineJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentMode", e.DeploymentMode)
	populateDateTimeRFC3339(objectMap, "endTimeUtc", e.EndTimeUTC)
	populate(objectMap, "error", e.Error)
	populate(objectMap, "jobId", e.JobID)
	populate(objectMap, "jobType", e.JobType)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populateDateTimeRFC3339(objectMap, "startTimeUtc", e.StartTimeUTC)
	populate(objectMap, "status", e.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineJobProperties.
func (e *EdgeMachineJobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentMode":
			err = unpopulate(val, "DeploymentMode", &e.DeploymentMode)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "EndTimeUTC", &e.EndTimeUTC)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, "JobID", &e.JobID)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &e.JobType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "StartTimeUTC", &e.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &e.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineListResult.
func (e EdgeMachineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineListResult.
func (e *EdgeMachineListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineNetworkProfile.
func (e EdgeMachineNetworkProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nicDetails", e.NicDetails)
	populate(objectMap, "switchDetails", e.SwitchDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineNetworkProfile.
func (e *EdgeMachineNetworkProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nicDetails":
			err = unpopulate(val, "NicDetails", &e.NicDetails)
			delete(rawMsg, key)
		case "switchDetails":
			err = unpopulate(val, "SwitchDetails", &e.SwitchDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineNicDetail.
func (e EdgeMachineNicDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adapterName", e.AdapterName)
	populate(objectMap, "componentId", e.ComponentID)
	populate(objectMap, "dnsServers", e.DNSServers)
	populate(objectMap, "defaultGateway", e.DefaultGateway)
	populate(objectMap, "defaultIsolationId", e.DefaultIsolationID)
	populate(objectMap, "driverVersion", e.DriverVersion)
	populate(objectMap, "interfaceDescription", e.InterfaceDescription)
	populate(objectMap, "ip4Address", e.Ip4Address)
	populate(objectMap, "macAddress", e.MacAddress)
	populate(objectMap, "nicStatus", e.NicStatus)
	populate(objectMap, "nicType", e.NicType)
	populate(objectMap, "rdmaCapability", e.RdmaCapability)
	populate(objectMap, "slot", e.Slot)
	populate(objectMap, "subnetMask", e.SubnetMask)
	populate(objectMap, "switchName", e.SwitchName)
	populate(objectMap, "vlanId", e.VlanID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineNicDetail.
func (e *EdgeMachineNicDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adapterName":
			err = unpopulate(val, "AdapterName", &e.AdapterName)
			delete(rawMsg, key)
		case "componentId":
			err = unpopulate(val, "ComponentID", &e.ComponentID)
			delete(rawMsg, key)
		case "dnsServers":
			err = unpopulate(val, "DNSServers", &e.DNSServers)
			delete(rawMsg, key)
		case "defaultGateway":
			err = unpopulate(val, "DefaultGateway", &e.DefaultGateway)
			delete(rawMsg, key)
		case "defaultIsolationId":
			err = unpopulate(val, "DefaultIsolationID", &e.DefaultIsolationID)
			delete(rawMsg, key)
		case "driverVersion":
			err = unpopulate(val, "DriverVersion", &e.DriverVersion)
			delete(rawMsg, key)
		case "interfaceDescription":
			err = unpopulate(val, "InterfaceDescription", &e.InterfaceDescription)
			delete(rawMsg, key)
		case "ip4Address":
			err = unpopulate(val, "Ip4Address", &e.Ip4Address)
			delete(rawMsg, key)
		case "macAddress":
			err = unpopulate(val, "MacAddress", &e.MacAddress)
			delete(rawMsg, key)
		case "nicStatus":
			err = unpopulate(val, "NicStatus", &e.NicStatus)
			delete(rawMsg, key)
		case "nicType":
			err = unpopulate(val, "NicType", &e.NicType)
			delete(rawMsg, key)
		case "rdmaCapability":
			err = unpopulate(val, "RdmaCapability", &e.RdmaCapability)
			delete(rawMsg, key)
		case "slot":
			err = unpopulate(val, "Slot", &e.Slot)
			delete(rawMsg, key)
		case "subnetMask":
			err = unpopulate(val, "SubnetMask", &e.SubnetMask)
			delete(rawMsg, key)
		case "switchName":
			err = unpopulate(val, "SwitchName", &e.SwitchName)
			delete(rawMsg, key)
		case "vlanId":
			err = unpopulate(val, "VlanID", &e.VlanID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachinePatch.
func (e EdgeMachinePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", e.Identity)
	populate(objectMap, "tags", e.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachinePatch.
func (e *EdgeMachinePatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, "Identity", &e.Identity)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &e.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineProperties.
func (e EdgeMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arcGatewayResourceId", e.ArcGatewayResourceID)
	populate(objectMap, "arcMachineResourceGroupId", e.ArcMachineResourceGroupID)
	populate(objectMap, "arcMachineResourceId", e.ArcMachineResourceID)
	populate(objectMap, "claimedBy", e.ClaimedBy)
	populate(objectMap, "cloudId", e.CloudID)
	populate(objectMap, "connectivityStatus", e.ConnectivityStatus)
	populate(objectMap, "devicePoolResourceId", e.DevicePoolResourceID)
	populate(objectMap, "edgeMachineKind", e.EdgeMachineKind)
	populateDateTimeRFC3339(objectMap, "lastSyncTimestamp", e.LastSyncTimestamp)
	populate(objectMap, "machineState", e.MachineState)
	populate(objectMap, "operationDetails", e.OperationDetails)
	populate(objectMap, "ownershipVoucherDetails", e.OwnershipVoucherDetails)
	populate(objectMap, "provisioningDetails", e.ProvisioningDetails)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "reportedProperties", e.ReportedProperties)
	populate(objectMap, "siteDetails", e.SiteDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineProperties.
func (e *EdgeMachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arcGatewayResourceId":
			err = unpopulate(val, "ArcGatewayResourceID", &e.ArcGatewayResourceID)
			delete(rawMsg, key)
		case "arcMachineResourceGroupId":
			err = unpopulate(val, "ArcMachineResourceGroupID", &e.ArcMachineResourceGroupID)
			delete(rawMsg, key)
		case "arcMachineResourceId":
			err = unpopulate(val, "ArcMachineResourceID", &e.ArcMachineResourceID)
			delete(rawMsg, key)
		case "claimedBy":
			err = unpopulate(val, "ClaimedBy", &e.ClaimedBy)
			delete(rawMsg, key)
		case "cloudId":
			err = unpopulate(val, "CloudID", &e.CloudID)
			delete(rawMsg, key)
		case "connectivityStatus":
			err = unpopulate(val, "ConnectivityStatus", &e.ConnectivityStatus)
			delete(rawMsg, key)
		case "devicePoolResourceId":
			err = unpopulate(val, "DevicePoolResourceID", &e.DevicePoolResourceID)
			delete(rawMsg, key)
		case "edgeMachineKind":
			err = unpopulate(val, "EdgeMachineKind", &e.EdgeMachineKind)
			delete(rawMsg, key)
		case "lastSyncTimestamp":
			err = unpopulateDateTimeRFC3339(val, "LastSyncTimestamp", &e.LastSyncTimestamp)
			delete(rawMsg, key)
		case "machineState":
			err = unpopulate(val, "MachineState", &e.MachineState)
			delete(rawMsg, key)
		case "operationDetails":
			err = unpopulate(val, "OperationDetails", &e.OperationDetails)
			delete(rawMsg, key)
		case "ownershipVoucherDetails":
			err = unpopulate(val, "OwnershipVoucherDetails", &e.OwnershipVoucherDetails)
			delete(rawMsg, key)
		case "provisioningDetails":
			err = unpopulate(val, "ProvisioningDetails", &e.ProvisioningDetails)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		case "reportedProperties":
			err = unpopulate(val, "ReportedProperties", &e.ReportedProperties)
			delete(rawMsg, key)
		case "siteDetails":
			err = unpopulate(val, "SiteDetails", &e.SiteDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineRemoteSupportJobProperties.
func (e EdgeMachineRemoteSupportJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessLevel", e.AccessLevel)
	populate(objectMap, "deploymentMode", e.DeploymentMode)
	populateDateTimeRFC3339(objectMap, "endTimeUtc", e.EndTimeUTC)
	populate(objectMap, "error", e.Error)
	populateDateTimeRFC3339(objectMap, "expirationTimestamp", e.ExpirationTimestamp)
	populate(objectMap, "jobId", e.JobID)
	objectMap["jobType"] = EdgeMachineJobTypeRemoteSupport
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "reportedProperties", e.ReportedProperties)
	populateDateTimeRFC3339(objectMap, "startTimeUtc", e.StartTimeUTC)
	populate(objectMap, "status", e.Status)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineRemoteSupportJobProperties.
func (e *EdgeMachineRemoteSupportJobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessLevel":
			err = unpopulate(val, "AccessLevel", &e.AccessLevel)
			delete(rawMsg, key)
		case "deploymentMode":
			err = unpopulate(val, "DeploymentMode", &e.DeploymentMode)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "EndTimeUTC", &e.EndTimeUTC)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		case "expirationTimestamp":
			err = unpopulateDateTimeRFC3339(val, "ExpirationTimestamp", &e.ExpirationTimestamp)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, "JobID", &e.JobID)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &e.JobType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		case "reportedProperties":
			err = unpopulate(val, "ReportedProperties", &e.ReportedProperties)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "StartTimeUTC", &e.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &e.Status)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineRemoteSupportJobReportedProperties.
func (e EdgeMachineRemoteSupportJobReportedProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentStatus", e.DeploymentStatus)
	populate(objectMap, "nodeSettings", e.NodeSettings)
	populate(objectMap, "percentComplete", e.PercentComplete)
	populate(objectMap, "sessionDetails", e.SessionDetails)
	populate(objectMap, "validationStatus", e.ValidationStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineRemoteSupportJobReportedProperties.
func (e *EdgeMachineRemoteSupportJobReportedProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentStatus":
			err = unpopulate(val, "DeploymentStatus", &e.DeploymentStatus)
			delete(rawMsg, key)
		case "nodeSettings":
			err = unpopulate(val, "NodeSettings", &e.NodeSettings)
			delete(rawMsg, key)
		case "percentComplete":
			err = unpopulate(val, "PercentComplete", &e.PercentComplete)
			delete(rawMsg, key)
		case "sessionDetails":
			err = unpopulate(val, "SessionDetails", &e.SessionDetails)
			delete(rawMsg, key)
		case "validationStatus":
			err = unpopulate(val, "ValidationStatus", &e.ValidationStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineRemoteSupportNodeSettings.
func (e EdgeMachineRemoteSupportNodeSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionErrorMessage", e.ConnectionErrorMessage)
	populate(objectMap, "connectionStatus", e.ConnectionStatus)
	populateDateTimeRFC3339(objectMap, "createdAt", e.CreatedAt)
	populate(objectMap, "state", e.State)
	populateDateTimeRFC3339(objectMap, "updatedAt", e.UpdatedAt)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineRemoteSupportNodeSettings.
func (e *EdgeMachineRemoteSupportNodeSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionErrorMessage":
			err = unpopulate(val, "ConnectionErrorMessage", &e.ConnectionErrorMessage)
			delete(rawMsg, key)
		case "connectionStatus":
			err = unpopulate(val, "ConnectionStatus", &e.ConnectionStatus)
			delete(rawMsg, key)
		case "createdAt":
			err = unpopulateDateTimeRFC3339(val, "CreatedAt", &e.CreatedAt)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &e.State)
			delete(rawMsg, key)
		case "updatedAt":
			err = unpopulateDateTimeRFC3339(val, "UpdatedAt", &e.UpdatedAt)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeMachineReportedProperties.
func (e EdgeMachineReportedProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extensionProfile", e.ExtensionProfile)
	populate(objectMap, "hardwareProfile", e.HardwareProfile)
	populateDateTimeRFC3339(objectMap, "lastUpdated", e.LastUpdated)
	populate(objectMap, "networkProfile", e.NetworkProfile)
	populate(objectMap, "osProfile", e.OSProfile)
	populate(objectMap, "sbeDeploymentPackageInfo", e.SbeDeploymentPackageInfo)
	populate(objectMap, "storageProfile", e.StorageProfile)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeMachineReportedProperties.
func (e *EdgeMachineReportedProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extensionProfile":
			err = unpopulate(val, "ExtensionProfile", &e.ExtensionProfile)
			delete(rawMsg, key)
		case "hardwareProfile":
			err = unpopulate(val, "HardwareProfile", &e.HardwareProfile)
			delete(rawMsg, key)
		case "lastUpdated":
			err = unpopulateDateTimeRFC3339(val, "LastUpdated", &e.LastUpdated)
			delete(rawMsg, key)
		case "networkProfile":
			err = unpopulate(val, "NetworkProfile", &e.NetworkProfile)
			delete(rawMsg, key)
		case "osProfile":
			err = unpopulate(val, "OSProfile", &e.OSProfile)
			delete(rawMsg, key)
		case "sbeDeploymentPackageInfo":
			err = unpopulate(val, "SbeDeploymentPackageInfo", &e.SbeDeploymentPackageInfo)
			delete(rawMsg, key)
		case "storageProfile":
			err = unpopulate(val, "StorageProfile", &e.StorageProfile)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorAdditionalInfo.
func (e ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "info", e.Info)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorAdditionalInfo.
func (e *ErrorAdditionalInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "info":
			err = unpopulate(val, "Info", &e.Info)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetail.
func (e *ErrorDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
			err = unpopulate(val, "AdditionalInfo", &e.AdditionalInfo)
			delete(rawMsg, key)
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "details":
			err = unpopulate(val, "Details", &e.Details)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &e.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Extension.
func (e Extension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Extension.
func (e *Extension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtensionInstanceView.
func (e ExtensionInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "status", e.Status)
	populate(objectMap, "type", e.Type)
	populate(objectMap, "typeHandlerVersion", e.TypeHandlerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtensionInstanceView.
func (e *ExtensionInstanceView) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &e.Status)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "typeHandlerVersion":
			err = unpopulate(val, "TypeHandlerVersion", &e.TypeHandlerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtensionInstanceViewStatus.
func (e ExtensionInstanceViewStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "displayStatus", e.DisplayStatus)
	populate(objectMap, "level", e.Level)
	populate(objectMap, "message", e.Message)
	populateDateTimeRFC3339(objectMap, "time", e.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtensionInstanceViewStatus.
func (e *ExtensionInstanceViewStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "displayStatus":
			err = unpopulate(val, "DisplayStatus", &e.DisplayStatus)
			delete(rawMsg, key)
		case "level":
			err = unpopulate(val, "Level", &e.Level)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "time":
			err = unpopulateDateTimeRFC3339(val, "Time", &e.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtensionList.
func (e ExtensionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtensionList.
func (e *ExtensionList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtensionParameters.
func (e ExtensionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoUpgradeMinorVersion", e.AutoUpgradeMinorVersion)
	populate(objectMap, "enableAutomaticUpgrade", e.EnableAutomaticUpgrade)
	populate(objectMap, "forceUpdateTag", e.ForceUpdateTag)
	populateAny(objectMap, "protectedSettings", e.ProtectedSettings)
	populate(objectMap, "publisher", e.Publisher)
	populateAny(objectMap, "settings", e.Settings)
	populate(objectMap, "type", e.Type)
	populate(objectMap, "typeHandlerVersion", e.TypeHandlerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtensionParameters.
func (e *ExtensionParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUpgradeMinorVersion":
			err = unpopulate(val, "AutoUpgradeMinorVersion", &e.AutoUpgradeMinorVersion)
			delete(rawMsg, key)
		case "enableAutomaticUpgrade":
			err = unpopulate(val, "EnableAutomaticUpgrade", &e.EnableAutomaticUpgrade)
			delete(rawMsg, key)
		case "forceUpdateTag":
			err = unpopulate(val, "ForceUpdateTag", &e.ForceUpdateTag)
			delete(rawMsg, key)
		case "protectedSettings":
			err = unpopulate(val, "ProtectedSettings", &e.ProtectedSettings)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &e.Publisher)
			delete(rawMsg, key)
		case "settings":
			err = unpopulate(val, "Settings", &e.Settings)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "typeHandlerVersion":
			err = unpopulate(val, "TypeHandlerVersion", &e.TypeHandlerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtensionPatch.
func (e ExtensionPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtensionPatch.
func (e *ExtensionPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtensionPatchParameters.
func (e ExtensionPatchParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enableAutomaticUpgrade", e.EnableAutomaticUpgrade)
	populateAny(objectMap, "protectedSettings", e.ProtectedSettings)
	populateAny(objectMap, "settings", e.Settings)
	populate(objectMap, "typeHandlerVersion", e.TypeHandlerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtensionPatchParameters.
func (e *ExtensionPatchParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableAutomaticUpgrade":
			err = unpopulate(val, "EnableAutomaticUpgrade", &e.EnableAutomaticUpgrade)
			delete(rawMsg, key)
		case "protectedSettings":
			err = unpopulate(val, "ProtectedSettings", &e.ProtectedSettings)
			delete(rawMsg, key)
		case "settings":
			err = unpopulate(val, "Settings", &e.Settings)
			delete(rawMsg, key)
		case "typeHandlerVersion":
			err = unpopulate(val, "TypeHandlerVersion", &e.TypeHandlerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtensionPatchProperties.
func (e ExtensionPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extensionParameters", e.ExtensionParameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtensionPatchProperties.
func (e *ExtensionPatchProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extensionParameters":
			err = unpopulate(val, "ExtensionParameters", &e.ExtensionParameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtensionProfile.
func (e ExtensionProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extensions", e.Extensions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtensionProfile.
func (e *ExtensionProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extensions":
			err = unpopulate(val, "Extensions", &e.Extensions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtensionProperties.
func (e ExtensionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aggregateState", e.AggregateState)
	populate(objectMap, "extensionParameters", e.ExtensionParameters)
	populate(objectMap, "managedBy", e.ManagedBy)
	populate(objectMap, "perNodeExtensionDetails", e.PerNodeExtensionDetails)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtensionProperties.
func (e *ExtensionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aggregateState":
			err = unpopulate(val, "AggregateState", &e.AggregateState)
			delete(rawMsg, key)
		case "extensionParameters":
			err = unpopulate(val, "ExtensionParameters", &e.ExtensionParameters)
			delete(rawMsg, key)
		case "managedBy":
			err = unpopulate(val, "ManagedBy", &e.ManagedBy)
			delete(rawMsg, key)
		case "perNodeExtensionDetails":
			err = unpopulate(val, "PerNodeExtensionDetails", &e.PerNodeExtensionDetails)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtensionUpgradeParameters.
func (e ExtensionUpgradeParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "targetVersion", e.TargetVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtensionUpgradeParameters.
func (e *ExtensionUpgradeParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "targetVersion":
			err = unpopulate(val, "TargetVersion", &e.TargetVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HardwareProfile.
func (h HardwareProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cpuCores", h.CPUCores)
	populate(objectMap, "cpuSockets", h.CPUSockets)
	populate(objectMap, "manufacturer", h.Manufacturer)
	populate(objectMap, "memoryCapacityInGb", h.MemoryCapacityInGb)
	populate(objectMap, "model", h.Model)
	populate(objectMap, "processorType", h.ProcessorType)
	populate(objectMap, "serialNumber", h.SerialNumber)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HardwareProfile.
func (h *HardwareProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cpuCores":
			err = unpopulate(val, "CPUCores", &h.CPUCores)
			delete(rawMsg, key)
		case "cpuSockets":
			err = unpopulate(val, "CPUSockets", &h.CPUSockets)
			delete(rawMsg, key)
		case "manufacturer":
			err = unpopulate(val, "Manufacturer", &h.Manufacturer)
			delete(rawMsg, key)
		case "memoryCapacityInGb":
			err = unpopulate(val, "MemoryCapacityInGb", &h.MemoryCapacityInGb)
			delete(rawMsg, key)
		case "model":
			err = unpopulate(val, "Model", &h.Model)
			delete(rawMsg, key)
		case "processorType":
			err = unpopulate(val, "ProcessorType", &h.ProcessorType)
			delete(rawMsg, key)
		case "serialNumber":
			err = unpopulate(val, "SerialNumber", &h.SerialNumber)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciCollectLogJobProperties.
func (h HciCollectLogJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentMode", h.DeploymentMode)
	populateDateTimeRFC3339(objectMap, "endTimeUtc", h.EndTimeUTC)
	populateDateTimeRFC3339(objectMap, "fromDate", h.FromDate)
	populate(objectMap, "jobId", h.JobID)
	objectMap["jobType"] = HciEdgeDeviceJobTypeCollectLog
	populateDateTimeRFC3339(objectMap, "lastLogGenerated", h.LastLogGenerated)
	populate(objectMap, "provisioningState", h.ProvisioningState)
	populate(objectMap, "reportedProperties", h.ReportedProperties)
	populateDateTimeRFC3339(objectMap, "startTimeUtc", h.StartTimeUTC)
	populate(objectMap, "status", h.Status)
	populateDateTimeRFC3339(objectMap, "toDate", h.ToDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciCollectLogJobProperties.
func (h *HciCollectLogJobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentMode":
			err = unpopulate(val, "DeploymentMode", &h.DeploymentMode)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "EndTimeUTC", &h.EndTimeUTC)
			delete(rawMsg, key)
		case "fromDate":
			err = unpopulateDateTimeRFC3339(val, "FromDate", &h.FromDate)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, "JobID", &h.JobID)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &h.JobType)
			delete(rawMsg, key)
		case "lastLogGenerated":
			err = unpopulateDateTimeRFC3339(val, "LastLogGenerated", &h.LastLogGenerated)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &h.ProvisioningState)
			delete(rawMsg, key)
		case "reportedProperties":
			err = unpopulate(val, "ReportedProperties", &h.ReportedProperties)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "StartTimeUTC", &h.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &h.Status)
			delete(rawMsg, key)
		case "toDate":
			err = unpopulateDateTimeRFC3339(val, "ToDate", &h.ToDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciEdgeDevice.
func (h HciEdgeDevice) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	objectMap["kind"] = DeviceKindHCI
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciEdgeDevice.
func (h *HciEdgeDevice) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &h.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &h.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciEdgeDeviceAdapterPropertyOverrides.
func (h HciEdgeDeviceAdapterPropertyOverrides) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "jumboPacket", h.JumboPacket)
	populate(objectMap, "networkDirect", h.NetworkDirect)
	populate(objectMap, "networkDirectTechnology", h.NetworkDirectTechnology)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciEdgeDeviceAdapterPropertyOverrides.
func (h *HciEdgeDeviceAdapterPropertyOverrides) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jumboPacket":
			err = unpopulate(val, "JumboPacket", &h.JumboPacket)
			delete(rawMsg, key)
		case "networkDirect":
			err = unpopulate(val, "NetworkDirect", &h.NetworkDirect)
			delete(rawMsg, key)
		case "networkDirectTechnology":
			err = unpopulate(val, "NetworkDirectTechnology", &h.NetworkDirectTechnology)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciEdgeDeviceArcExtension.
func (h HciEdgeDeviceArcExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errorDetails", h.ErrorDetails)
	populate(objectMap, "extensionName", h.ExtensionName)
	populate(objectMap, "extensionResourceId", h.ExtensionResourceID)
	populate(objectMap, "managedBy", h.ManagedBy)
	populate(objectMap, "state", h.State)
	populate(objectMap, "typeHandlerVersion", h.TypeHandlerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciEdgeDeviceArcExtension.
func (h *HciEdgeDeviceArcExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorDetails":
			err = unpopulate(val, "ErrorDetails", &h.ErrorDetails)
			delete(rawMsg, key)
		case "extensionName":
			err = unpopulate(val, "ExtensionName", &h.ExtensionName)
			delete(rawMsg, key)
		case "extensionResourceId":
			err = unpopulate(val, "ExtensionResourceID", &h.ExtensionResourceID)
			delete(rawMsg, key)
		case "managedBy":
			err = unpopulate(val, "ManagedBy", &h.ManagedBy)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &h.State)
			delete(rawMsg, key)
		case "typeHandlerVersion":
			err = unpopulate(val, "TypeHandlerVersion", &h.TypeHandlerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciEdgeDeviceHostNetwork.
func (h HciEdgeDeviceHostNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enableStorageAutoIp", h.EnableStorageAutoIP)
	populate(objectMap, "intents", h.Intents)
	populate(objectMap, "storageConnectivitySwitchless", h.StorageConnectivitySwitchless)
	populate(objectMap, "storageNetworks", h.StorageNetworks)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciEdgeDeviceHostNetwork.
func (h *HciEdgeDeviceHostNetwork) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableStorageAutoIp":
			err = unpopulate(val, "EnableStorageAutoIP", &h.EnableStorageAutoIP)
			delete(rawMsg, key)
		case "intents":
			err = unpopulate(val, "Intents", &h.Intents)
			delete(rawMsg, key)
		case "storageConnectivitySwitchless":
			err = unpopulate(val, "StorageConnectivitySwitchless", &h.StorageConnectivitySwitchless)
			delete(rawMsg, key)
		case "storageNetworks":
			err = unpopulate(val, "StorageNetworks", &h.StorageNetworks)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciEdgeDeviceIntents.
func (h HciEdgeDeviceIntents) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adapterPropertyOverrides", h.AdapterPropertyOverrides)
	populate(objectMap, "intentAdapters", h.IntentAdapters)
	populate(objectMap, "intentName", h.IntentName)
	populate(objectMap, "intentType", h.IntentType)
	populate(objectMap, "isComputeIntentSet", h.IsComputeIntentSet)
	populate(objectMap, "isManagementIntentSet", h.IsManagementIntentSet)
	populate(objectMap, "isNetworkIntentType", h.IsNetworkIntentType)
	populate(objectMap, "isOnlyStorage", h.IsOnlyStorage)
	populate(objectMap, "isOnlyStretch", h.IsOnlyStretch)
	populate(objectMap, "isStorageIntentSet", h.IsStorageIntentSet)
	populate(objectMap, "isStretchIntentSet", h.IsStretchIntentSet)
	populate(objectMap, "overrideAdapterProperty", h.OverrideAdapterProperty)
	populate(objectMap, "overrideQosPolicy", h.OverrideQosPolicy)
	populate(objectMap, "overrideVirtualSwitchConfiguration", h.OverrideVirtualSwitchConfiguration)
	populate(objectMap, "qosPolicyOverrides", h.QosPolicyOverrides)
	populate(objectMap, "scope", h.Scope)
	populate(objectMap, "virtualSwitchConfigurationOverrides", h.VirtualSwitchConfigurationOverrides)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciEdgeDeviceIntents.
func (h *HciEdgeDeviceIntents) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adapterPropertyOverrides":
			err = unpopulate(val, "AdapterPropertyOverrides", &h.AdapterPropertyOverrides)
			delete(rawMsg, key)
		case "intentAdapters":
			err = unpopulate(val, "IntentAdapters", &h.IntentAdapters)
			delete(rawMsg, key)
		case "intentName":
			err = unpopulate(val, "IntentName", &h.IntentName)
			delete(rawMsg, key)
		case "intentType":
			err = unpopulate(val, "IntentType", &h.IntentType)
			delete(rawMsg, key)
		case "isComputeIntentSet":
			err = unpopulate(val, "IsComputeIntentSet", &h.IsComputeIntentSet)
			delete(rawMsg, key)
		case "isManagementIntentSet":
			err = unpopulate(val, "IsManagementIntentSet", &h.IsManagementIntentSet)
			delete(rawMsg, key)
		case "isNetworkIntentType":
			err = unpopulate(val, "IsNetworkIntentType", &h.IsNetworkIntentType)
			delete(rawMsg, key)
		case "isOnlyStorage":
			err = unpopulate(val, "IsOnlyStorage", &h.IsOnlyStorage)
			delete(rawMsg, key)
		case "isOnlyStretch":
			err = unpopulate(val, "IsOnlyStretch", &h.IsOnlyStretch)
			delete(rawMsg, key)
		case "isStorageIntentSet":
			err = unpopulate(val, "IsStorageIntentSet", &h.IsStorageIntentSet)
			delete(rawMsg, key)
		case "isStretchIntentSet":
			err = unpopulate(val, "IsStretchIntentSet", &h.IsStretchIntentSet)
			delete(rawMsg, key)
		case "overrideAdapterProperty":
			err = unpopulate(val, "OverrideAdapterProperty", &h.OverrideAdapterProperty)
			delete(rawMsg, key)
		case "overrideQosPolicy":
			err = unpopulate(val, "OverrideQosPolicy", &h.OverrideQosPolicy)
			delete(rawMsg, key)
		case "overrideVirtualSwitchConfiguration":
			err = unpopulate(val, "OverrideVirtualSwitchConfiguration", &h.OverrideVirtualSwitchConfiguration)
			delete(rawMsg, key)
		case "qosPolicyOverrides":
			err = unpopulate(val, "QosPolicyOverrides", &h.QosPolicyOverrides)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, "Scope", &h.Scope)
			delete(rawMsg, key)
		case "virtualSwitchConfigurationOverrides":
			err = unpopulate(val, "VirtualSwitchConfigurationOverrides", &h.VirtualSwitchConfigurationOverrides)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciEdgeDeviceJob.
func (h HciEdgeDeviceJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	objectMap["kind"] = EdgeDeviceKindHCI
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciEdgeDeviceJob.
func (h *HciEdgeDeviceJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &h.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
			h.Properties, err = unmarshalHciEdgeDeviceJobPropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &h.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciEdgeDeviceJobProperties.
func (h HciEdgeDeviceJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentMode", h.DeploymentMode)
	populateDateTimeRFC3339(objectMap, "endTimeUtc", h.EndTimeUTC)
	populate(objectMap, "jobId", h.JobID)
	populate(objectMap, "jobType", h.JobType)
	populate(objectMap, "provisioningState", h.ProvisioningState)
	populateDateTimeRFC3339(objectMap, "startTimeUtc", h.StartTimeUTC)
	populate(objectMap, "status", h.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciEdgeDeviceJobProperties.
func (h *HciEdgeDeviceJobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentMode":
			err = unpopulate(val, "DeploymentMode", &h.DeploymentMode)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "EndTimeUTC", &h.EndTimeUTC)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, "JobID", &h.JobID)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &h.JobType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &h.ProvisioningState)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "StartTimeUTC", &h.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &h.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciEdgeDeviceProperties.
func (h HciEdgeDeviceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deviceConfiguration", h.DeviceConfiguration)
	populate(objectMap, "provisioningState", h.ProvisioningState)
	populate(objectMap, "reportedProperties", h.ReportedProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciEdgeDeviceProperties.
func (h *HciEdgeDeviceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deviceConfiguration":
			err = unpopulate(val, "DeviceConfiguration", &h.DeviceConfiguration)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &h.ProvisioningState)
			delete(rawMsg, key)
		case "reportedProperties":
			err = unpopulate(val, "ReportedProperties", &h.ReportedProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciEdgeDeviceStorageAdapterIPInfo.
func (h HciEdgeDeviceStorageAdapterIPInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipv4Address", h.IPv4Address)
	populate(objectMap, "physicalNode", h.PhysicalNode)
	populate(objectMap, "subnetMask", h.SubnetMask)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciEdgeDeviceStorageAdapterIPInfo.
func (h *HciEdgeDeviceStorageAdapterIPInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipv4Address":
			err = unpopulate(val, "IPv4Address", &h.IPv4Address)
			delete(rawMsg, key)
		case "physicalNode":
			err = unpopulate(val, "PhysicalNode", &h.PhysicalNode)
			delete(rawMsg, key)
		case "subnetMask":
			err = unpopulate(val, "SubnetMask", &h.SubnetMask)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciEdgeDeviceStorageNetworks.
func (h HciEdgeDeviceStorageNetworks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "networkAdapterName", h.NetworkAdapterName)
	populate(objectMap, "storageAdapterIPInfo", h.StorageAdapterIPInfo)
	populate(objectMap, "storageVlanId", h.StorageVlanID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciEdgeDeviceStorageNetworks.
func (h *HciEdgeDeviceStorageNetworks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "networkAdapterName":
			err = unpopulate(val, "NetworkAdapterName", &h.NetworkAdapterName)
			delete(rawMsg, key)
		case "storageAdapterIPInfo":
			err = unpopulate(val, "StorageAdapterIPInfo", &h.StorageAdapterIPInfo)
			delete(rawMsg, key)
		case "storageVlanId":
			err = unpopulate(val, "StorageVlanID", &h.StorageVlanID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciEdgeDeviceVirtualSwitchConfigurationOverrides.
func (h HciEdgeDeviceVirtualSwitchConfigurationOverrides) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enableIov", h.EnableIov)
	populate(objectMap, "loadBalancingAlgorithm", h.LoadBalancingAlgorithm)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciEdgeDeviceVirtualSwitchConfigurationOverrides.
func (h *HciEdgeDeviceVirtualSwitchConfigurationOverrides) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableIov":
			err = unpopulate(val, "EnableIov", &h.EnableIov)
			delete(rawMsg, key)
		case "loadBalancingAlgorithm":
			err = unpopulate(val, "LoadBalancingAlgorithm", &h.LoadBalancingAlgorithm)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciHardwareProfile.
func (h HciHardwareProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "processorType", h.ProcessorType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciHardwareProfile.
func (h *HciHardwareProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "processorType":
			err = unpopulate(val, "ProcessorType", &h.ProcessorType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciNetworkProfile.
func (h HciNetworkProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hostNetwork", h.HostNetwork)
	populate(objectMap, "nicDetails", h.NicDetails)
	populate(objectMap, "sdnProperties", h.SdnProperties)
	populate(objectMap, "switchDetails", h.SwitchDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciNetworkProfile.
func (h *HciNetworkProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hostNetwork":
			err = unpopulate(val, "HostNetwork", &h.HostNetwork)
			delete(rawMsg, key)
		case "nicDetails":
			err = unpopulate(val, "NicDetails", &h.NicDetails)
			delete(rawMsg, key)
		case "sdnProperties":
			err = unpopulate(val, "SdnProperties", &h.SdnProperties)
			delete(rawMsg, key)
		case "switchDetails":
			err = unpopulate(val, "SwitchDetails", &h.SwitchDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciNicDetail.
func (h HciNicDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adapterName", h.AdapterName)
	populate(objectMap, "componentId", h.ComponentID)
	populate(objectMap, "dnsServers", h.DNSServers)
	populate(objectMap, "defaultGateway", h.DefaultGateway)
	populate(objectMap, "defaultIsolationId", h.DefaultIsolationID)
	populate(objectMap, "driverVersion", h.DriverVersion)
	populate(objectMap, "interfaceDescription", h.InterfaceDescription)
	populate(objectMap, "ip4Address", h.Ip4Address)
	populate(objectMap, "macAddress", h.MacAddress)
	populate(objectMap, "nicStatus", h.NicStatus)
	populate(objectMap, "nicType", h.NicType)
	populate(objectMap, "rdmaCapability", h.RdmaCapability)
	populate(objectMap, "slot", h.Slot)
	populate(objectMap, "subnetMask", h.SubnetMask)
	populate(objectMap, "switchName", h.SwitchName)
	populate(objectMap, "vlanId", h.VlanID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciNicDetail.
func (h *HciNicDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adapterName":
			err = unpopulate(val, "AdapterName", &h.AdapterName)
			delete(rawMsg, key)
		case "componentId":
			err = unpopulate(val, "ComponentID", &h.ComponentID)
			delete(rawMsg, key)
		case "dnsServers":
			err = unpopulate(val, "DNSServers", &h.DNSServers)
			delete(rawMsg, key)
		case "defaultGateway":
			err = unpopulate(val, "DefaultGateway", &h.DefaultGateway)
			delete(rawMsg, key)
		case "defaultIsolationId":
			err = unpopulate(val, "DefaultIsolationID", &h.DefaultIsolationID)
			delete(rawMsg, key)
		case "driverVersion":
			err = unpopulate(val, "DriverVersion", &h.DriverVersion)
			delete(rawMsg, key)
		case "interfaceDescription":
			err = unpopulate(val, "InterfaceDescription", &h.InterfaceDescription)
			delete(rawMsg, key)
		case "ip4Address":
			err = unpopulate(val, "Ip4Address", &h.Ip4Address)
			delete(rawMsg, key)
		case "macAddress":
			err = unpopulate(val, "MacAddress", &h.MacAddress)
			delete(rawMsg, key)
		case "nicStatus":
			err = unpopulate(val, "NicStatus", &h.NicStatus)
			delete(rawMsg, key)
		case "nicType":
			err = unpopulate(val, "NicType", &h.NicType)
			delete(rawMsg, key)
		case "rdmaCapability":
			err = unpopulate(val, "RdmaCapability", &h.RdmaCapability)
			delete(rawMsg, key)
		case "slot":
			err = unpopulate(val, "Slot", &h.Slot)
			delete(rawMsg, key)
		case "subnetMask":
			err = unpopulate(val, "SubnetMask", &h.SubnetMask)
			delete(rawMsg, key)
		case "switchName":
			err = unpopulate(val, "SwitchName", &h.SwitchName)
			delete(rawMsg, key)
		case "vlanId":
			err = unpopulate(val, "VlanID", &h.VlanID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciOsProfile.
func (h HciOsProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assemblyVersion", h.AssemblyVersion)
	populate(objectMap, "bootType", h.BootType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciOsProfile.
func (h *HciOsProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assemblyVersion":
			err = unpopulate(val, "AssemblyVersion", &h.AssemblyVersion)
			delete(rawMsg, key)
		case "bootType":
			err = unpopulate(val, "BootType", &h.BootType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciRemoteSupportJobProperties.
func (h HciRemoteSupportJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessLevel", h.AccessLevel)
	populate(objectMap, "deploymentMode", h.DeploymentMode)
	populateDateTimeRFC3339(objectMap, "endTimeUtc", h.EndTimeUTC)
	populateDateTimeRFC3339(objectMap, "expirationTimestamp", h.ExpirationTimestamp)
	populate(objectMap, "jobId", h.JobID)
	objectMap["jobType"] = HciEdgeDeviceJobTypeRemoteSupport
	populate(objectMap, "provisioningState", h.ProvisioningState)
	populate(objectMap, "reportedProperties", h.ReportedProperties)
	populateDateTimeRFC3339(objectMap, "startTimeUtc", h.StartTimeUTC)
	populate(objectMap, "status", h.Status)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciRemoteSupportJobProperties.
func (h *HciRemoteSupportJobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessLevel":
			err = unpopulate(val, "AccessLevel", &h.AccessLevel)
			delete(rawMsg, key)
		case "deploymentMode":
			err = unpopulate(val, "DeploymentMode", &h.DeploymentMode)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "EndTimeUTC", &h.EndTimeUTC)
			delete(rawMsg, key)
		case "expirationTimestamp":
			err = unpopulateDateTimeRFC3339(val, "ExpirationTimestamp", &h.ExpirationTimestamp)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, "JobID", &h.JobID)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &h.JobType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &h.ProvisioningState)
			delete(rawMsg, key)
		case "reportedProperties":
			err = unpopulate(val, "ReportedProperties", &h.ReportedProperties)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "StartTimeUTC", &h.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &h.Status)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciReportedProperties.
func (h HciReportedProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "confidentialVmProfile", h.ConfidentialVMProfile)
	populate(objectMap, "deviceState", h.DeviceState)
	populate(objectMap, "extensionProfile", h.ExtensionProfile)
	populate(objectMap, "hardwareProfile", h.HardwareProfile)
	populateDateTimeRFC3339(objectMap, "lastSyncTimestamp", h.LastSyncTimestamp)
	populate(objectMap, "networkProfile", h.NetworkProfile)
	populate(objectMap, "osProfile", h.OSProfile)
	populate(objectMap, "sbeDeploymentPackageInfo", h.SbeDeploymentPackageInfo)
	populate(objectMap, "storageProfile", h.StorageProfile)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciReportedProperties.
func (h *HciReportedProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "confidentialVmProfile":
			err = unpopulate(val, "ConfidentialVMProfile", &h.ConfidentialVMProfile)
			delete(rawMsg, key)
		case "deviceState":
			err = unpopulate(val, "DeviceState", &h.DeviceState)
			delete(rawMsg, key)
		case "extensionProfile":
			err = unpopulate(val, "ExtensionProfile", &h.ExtensionProfile)
			delete(rawMsg, key)
		case "hardwareProfile":
			err = unpopulate(val, "HardwareProfile", &h.HardwareProfile)
			delete(rawMsg, key)
		case "lastSyncTimestamp":
			err = unpopulateDateTimeRFC3339(val, "LastSyncTimestamp", &h.LastSyncTimestamp)
			delete(rawMsg, key)
		case "networkProfile":
			err = unpopulate(val, "NetworkProfile", &h.NetworkProfile)
			delete(rawMsg, key)
		case "osProfile":
			err = unpopulate(val, "OSProfile", &h.OSProfile)
			delete(rawMsg, key)
		case "sbeDeploymentPackageInfo":
			err = unpopulate(val, "SbeDeploymentPackageInfo", &h.SbeDeploymentPackageInfo)
			delete(rawMsg, key)
		case "storageProfile":
			err = unpopulate(val, "StorageProfile", &h.StorageProfile)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciStorageProfile.
func (h HciStorageProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "poolableDisksCount", h.PoolableDisksCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciStorageProfile.
func (h *HciStorageProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "poolableDisksCount":
			err = unpopulate(val, "PoolableDisksCount", &h.PoolableDisksCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HciValidationFailureDetail.
func (h HciValidationFailureDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "exception", h.Exception)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HciValidationFailureDetail.
func (h *HciValidationFailureDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exception":
			err = unpopulate(val, "Exception", &h.Exception)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPAddressRange.
func (i IPAddressRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "endIp", i.EndIP)
	populate(objectMap, "startIp", i.StartIP)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPAddressRange.
func (i *IPAddressRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endIp":
			err = unpopulate(val, "EndIP", &i.EndIP)
			delete(rawMsg, key)
		case "startIp":
			err = unpopulate(val, "StartIP", &i.StartIP)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPPools.
func (i IPPools) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "endingAddress", i.EndingAddress)
	populate(objectMap, "startingAddress", i.StartingAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPPools.
func (i *IPPools) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endingAddress":
			err = unpopulate(val, "EndingAddress", &i.EndingAddress)
			delete(rawMsg, key)
		case "startingAddress":
			err = unpopulate(val, "StartingAddress", &i.StartingAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IgvmStatusDetail.
func (i IgvmStatusDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", i.Code)
	populate(objectMap, "message", i.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IgvmStatusDetail.
func (i *IgvmStatusDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &i.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &i.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InfrastructureNetwork.
func (i InfrastructureNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dnsServerConfig", i.DNSServerConfig)
	populate(objectMap, "dnsServers", i.DNSServers)
	populate(objectMap, "dnsZones", i.DNSZones)
	populate(objectMap, "gateway", i.Gateway)
	populate(objectMap, "ipPools", i.IPPools)
	populate(objectMap, "subnetMask", i.SubnetMask)
	populate(objectMap, "useDhcp", i.UseDhcp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InfrastructureNetwork.
func (i *InfrastructureNetwork) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dnsServerConfig":
			err = unpopulate(val, "DNSServerConfig", &i.DNSServerConfig)
			delete(rawMsg, key)
		case "dnsServers":
			err = unpopulate(val, "DNSServers", &i.DNSServers)
			delete(rawMsg, key)
		case "dnsZones":
			err = unpopulate(val, "DNSZones", &i.DNSZones)
			delete(rawMsg, key)
		case "gateway":
			err = unpopulate(val, "Gateway", &i.Gateway)
			delete(rawMsg, key)
		case "ipPools":
			err = unpopulate(val, "IPPools", &i.IPPools)
			delete(rawMsg, key)
		case "subnetMask":
			err = unpopulate(val, "SubnetMask", &i.SubnetMask)
			delete(rawMsg, key)
		case "useDhcp":
			err = unpopulate(val, "UseDhcp", &i.UseDhcp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IsolatedVMAttestationConfiguration.
func (i IsolatedVMAttestationConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "attestationResourceId", i.AttestationResourceID)
	populate(objectMap, "attestationServiceEndpoint", i.AttestationServiceEndpoint)
	populate(objectMap, "relyingPartyServiceEndpoint", i.RelyingPartyServiceEndpoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IsolatedVMAttestationConfiguration.
func (i *IsolatedVMAttestationConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attestationResourceId":
			err = unpopulate(val, "AttestationResourceID", &i.AttestationResourceID)
			delete(rawMsg, key)
		case "attestationServiceEndpoint":
			err = unpopulate(val, "AttestationServiceEndpoint", &i.AttestationServiceEndpoint)
			delete(rawMsg, key)
		case "relyingPartyServiceEndpoint":
			err = unpopulate(val, "RelyingPartyServiceEndpoint", &i.RelyingPartyServiceEndpoint)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesVersion.
func (k KubernetesVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", k.ID)
	populate(objectMap, "name", k.Name)
	populate(objectMap, "properties", k.Properties)
	populate(objectMap, "systemData", k.SystemData)
	populate(objectMap, "type", k.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesVersion.
func (k *KubernetesVersion) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &k.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &k.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &k.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &k.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &k.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesVersionListResult.
func (k KubernetesVersionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", k.NextLink)
	populate(objectMap, "value", k.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesVersionListResult.
func (k *KubernetesVersionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &k.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &k.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesVersionProperties.
func (k KubernetesVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "version", k.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesVersionProperties.
func (k *KubernetesVersionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "version":
			err = unpopulate(val, "Version", &k.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LocalAvailabilityZones.
func (l LocalAvailabilityZones) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "localAvailabilityZoneName", l.LocalAvailabilityZoneName)
	populate(objectMap, "nodes", l.Nodes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LocalAvailabilityZones.
func (l *LocalAvailabilityZones) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "localAvailabilityZoneName":
			err = unpopulate(val, "LocalAvailabilityZoneName", &l.LocalAvailabilityZoneName)
			delete(rawMsg, key)
		case "nodes":
			err = unpopulate(val, "Nodes", &l.Nodes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogCollectionError.
func (l LogCollectionError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errorCode", l.ErrorCode)
	populate(objectMap, "errorMessage", l.ErrorMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogCollectionError.
func (l *LogCollectionError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorCode":
			err = unpopulate(val, "ErrorCode", &l.ErrorCode)
			delete(rawMsg, key)
		case "errorMessage":
			err = unpopulate(val, "ErrorMessage", &l.ErrorMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogCollectionJobSession.
func (l LogCollectionJobSession) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "correlationId", l.CorrelationID)
	populate(objectMap, "endTime", l.EndTime)
	populate(objectMap, "logSize", l.LogSize)
	populate(objectMap, "startTime", l.StartTime)
	populate(objectMap, "status", l.Status)
	populate(objectMap, "timeCollected", l.TimeCollected)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogCollectionJobSession.
func (l *LogCollectionJobSession) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "correlationId":
			err = unpopulate(val, "CorrelationID", &l.CorrelationID)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulate(val, "EndTime", &l.EndTime)
			delete(rawMsg, key)
		case "logSize":
			err = unpopulate(val, "LogSize", &l.LogSize)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulate(val, "StartTime", &l.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &l.Status)
			delete(rawMsg, key)
		case "timeCollected":
			err = unpopulate(val, "TimeCollected", &l.TimeCollected)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogCollectionProperties.
func (l LogCollectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "fromDate", l.FromDate)
	populateDateTimeRFC3339(objectMap, "lastLogGenerated", l.LastLogGenerated)
	populate(objectMap, "logCollectionSessionDetails", l.LogCollectionSessionDetails)
	populateDateTimeRFC3339(objectMap, "toDate", l.ToDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogCollectionProperties.
func (l *LogCollectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fromDate":
			err = unpopulateDateTimeRFC3339(val, "FromDate", &l.FromDate)
			delete(rawMsg, key)
		case "lastLogGenerated":
			err = unpopulateDateTimeRFC3339(val, "LastLogGenerated", &l.LastLogGenerated)
			delete(rawMsg, key)
		case "logCollectionSessionDetails":
			err = unpopulate(val, "LogCollectionSessionDetails", &l.LogCollectionSessionDetails)
			delete(rawMsg, key)
		case "toDate":
			err = unpopulateDateTimeRFC3339(val, "ToDate", &l.ToDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogCollectionReportedProperties.
func (l LogCollectionReportedProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentStatus", l.DeploymentStatus)
	populate(objectMap, "logCollectionSessionDetails", l.LogCollectionSessionDetails)
	populate(objectMap, "percentComplete", l.PercentComplete)
	populate(objectMap, "validationStatus", l.ValidationStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogCollectionReportedProperties.
func (l *LogCollectionReportedProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentStatus":
			err = unpopulate(val, "DeploymentStatus", &l.DeploymentStatus)
			delete(rawMsg, key)
		case "logCollectionSessionDetails":
			err = unpopulate(val, "LogCollectionSessionDetails", &l.LogCollectionSessionDetails)
			delete(rawMsg, key)
		case "percentComplete":
			err = unpopulate(val, "PercentComplete", &l.PercentComplete)
			delete(rawMsg, key)
		case "validationStatus":
			err = unpopulate(val, "ValidationStatus", &l.ValidationStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogCollectionRequest.
func (l LogCollectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", l.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogCollectionRequest.
func (l *LogCollectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &l.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogCollectionRequestProperties.
func (l LogCollectionRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "fromDate", l.FromDate)
	populateDateTimeRFC3339(objectMap, "toDate", l.ToDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogCollectionRequestProperties.
func (l *LogCollectionRequestProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fromDate":
			err = unpopulateDateTimeRFC3339(val, "FromDate", &l.FromDate)
			delete(rawMsg, key)
		case "toDate":
			err = unpopulateDateTimeRFC3339(val, "ToDate", &l.ToDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogCollectionSession.
func (l LogCollectionSession) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "correlationId", l.CorrelationID)
	populateDateTimeRFC3339(objectMap, "endTimeCollected", l.EndTimeCollected)
	populate(objectMap, "logCollectionError", l.LogCollectionError)
	populate(objectMap, "logCollectionJobType", l.LogCollectionJobType)
	populate(objectMap, "logCollectionStatus", l.LogCollectionStatus)
	populateDateTimeRFC3339(objectMap, "logEndTime", l.LogEndTime)
	populate(objectMap, "logSize", l.LogSize)
	populateDateTimeRFC3339(objectMap, "logStartTime", l.LogStartTime)
	populateDateTimeRFC3339(objectMap, "timeCollected", l.TimeCollected)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogCollectionSession.
func (l *LogCollectionSession) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "correlationId":
			err = unpopulate(val, "CorrelationID", &l.CorrelationID)
			delete(rawMsg, key)
		case "endTimeCollected":
			err = unpopulateDateTimeRFC3339(val, "EndTimeCollected", &l.EndTimeCollected)
			delete(rawMsg, key)
		case "logCollectionError":
			err = unpopulate(val, "LogCollectionError", &l.LogCollectionError)
			delete(rawMsg, key)
		case "logCollectionJobType":
			err = unpopulate(val, "LogCollectionJobType", &l.LogCollectionJobType)
			delete(rawMsg, key)
		case "logCollectionStatus":
			err = unpopulate(val, "LogCollectionStatus", &l.LogCollectionStatus)
			delete(rawMsg, key)
		case "logEndTime":
			err = unpopulateDateTimeRFC3339(val, "LogEndTime", &l.LogEndTime)
			delete(rawMsg, key)
		case "logSize":
			err = unpopulate(val, "LogSize", &l.LogSize)
			delete(rawMsg, key)
		case "logStartTime":
			err = unpopulateDateTimeRFC3339(val, "LogStartTime", &l.LogStartTime)
			delete(rawMsg, key)
		case "timeCollected":
			err = unpopulateDateTimeRFC3339(val, "TimeCollected", &l.TimeCollected)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedServiceIdentity.
func (m ManagedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedServiceIdentity.
func (m *ManagedServiceIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principalId":
			err = unpopulate(val, "PrincipalID", &m.PrincipalID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &m.TenantID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "userAssignedIdentities":
			err = unpopulate(val, "UserAssignedIdentities", &m.UserAssignedIdentities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkAdapter.
func (n NetworkAdapter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adapterName", n.AdapterName)
	populate(objectMap, "dnsAddressArray", n.DNSAddressArray)
	populate(objectMap, "gateway", n.Gateway)
	populate(objectMap, "ipAddress", n.IPAddress)
	populate(objectMap, "ipAddressRange", n.IPAddressRange)
	populate(objectMap, "ipAssignmentType", n.IPAssignmentType)
	populate(objectMap, "macAddress", n.MacAddress)
	populate(objectMap, "subnetMask", n.SubnetMask)
	populate(objectMap, "vlanId", n.VlanID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkAdapter.
func (n *NetworkAdapter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adapterName":
			err = unpopulate(val, "AdapterName", &n.AdapterName)
			delete(rawMsg, key)
		case "dnsAddressArray":
			err = unpopulate(val, "DNSAddressArray", &n.DNSAddressArray)
			delete(rawMsg, key)
		case "gateway":
			err = unpopulate(val, "Gateway", &n.Gateway)
			delete(rawMsg, key)
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &n.IPAddress)
			delete(rawMsg, key)
		case "ipAddressRange":
			err = unpopulate(val, "IPAddressRange", &n.IPAddressRange)
			delete(rawMsg, key)
		case "ipAssignmentType":
			err = unpopulate(val, "IPAssignmentType", &n.IPAssignmentType)
			delete(rawMsg, key)
		case "macAddress":
			err = unpopulate(val, "MacAddress", &n.MacAddress)
			delete(rawMsg, key)
		case "subnetMask":
			err = unpopulate(val, "SubnetMask", &n.SubnetMask)
			delete(rawMsg, key)
		case "vlanId":
			err = unpopulate(val, "VlanID", &n.VlanID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkConfiguration.
func (n NetworkConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "networkAdapters", n.NetworkAdapters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkConfiguration.
func (n *NetworkConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "networkAdapters":
			err = unpopulate(val, "NetworkAdapters", &n.NetworkAdapters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkController.
func (n NetworkController) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "macAddressPoolStart", n.MacAddressPoolStart)
	populate(objectMap, "macAddressPoolStop", n.MacAddressPoolStop)
	populate(objectMap, "networkVirtualizationEnabled", n.NetworkVirtualizationEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkController.
func (n *NetworkController) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "macAddressPoolStart":
			err = unpopulate(val, "MacAddressPoolStart", &n.MacAddressPoolStart)
			delete(rawMsg, key)
		case "macAddressPoolStop":
			err = unpopulate(val, "MacAddressPoolStop", &n.MacAddressPoolStop)
			delete(rawMsg, key)
		case "networkVirtualizationEnabled":
			err = unpopulate(val, "NetworkVirtualizationEnabled", &n.NetworkVirtualizationEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NicDetail.
func (n NicDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adapterName", n.AdapterName)
	populate(objectMap, "componentId", n.ComponentID)
	populate(objectMap, "dnsServers", n.DNSServers)
	populate(objectMap, "defaultGateway", n.DefaultGateway)
	populate(objectMap, "defaultIsolationId", n.DefaultIsolationID)
	populate(objectMap, "driverVersion", n.DriverVersion)
	populate(objectMap, "interfaceDescription", n.InterfaceDescription)
	populate(objectMap, "ip4Address", n.Ip4Address)
	populate(objectMap, "subnetMask", n.SubnetMask)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NicDetail.
func (n *NicDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adapterName":
			err = unpopulate(val, "AdapterName", &n.AdapterName)
			delete(rawMsg, key)
		case "componentId":
			err = unpopulate(val, "ComponentID", &n.ComponentID)
			delete(rawMsg, key)
		case "dnsServers":
			err = unpopulate(val, "DNSServers", &n.DNSServers)
			delete(rawMsg, key)
		case "defaultGateway":
			err = unpopulate(val, "DefaultGateway", &n.DefaultGateway)
			delete(rawMsg, key)
		case "defaultIsolationId":
			err = unpopulate(val, "DefaultIsolationID", &n.DefaultIsolationID)
			delete(rawMsg, key)
		case "driverVersion":
			err = unpopulate(val, "DriverVersion", &n.DriverVersion)
			delete(rawMsg, key)
		case "interfaceDescription":
			err = unpopulate(val, "InterfaceDescription", &n.InterfaceDescription)
			delete(rawMsg, key)
		case "ip4Address":
			err = unpopulate(val, "Ip4Address", &n.Ip4Address)
			delete(rawMsg, key)
		case "subnetMask":
			err = unpopulate(val, "SubnetMask", &n.SubnetMask)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Observability.
func (o Observability) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "episodicDataUpload", o.EpisodicDataUpload)
	populate(objectMap, "euLocation", o.EuLocation)
	populate(objectMap, "streamingDataClient", o.StreamingDataClient)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Observability.
func (o *Observability) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "episodicDataUpload":
			err = unpopulate(val, "EpisodicDataUpload", &o.EpisodicDataUpload)
			delete(rawMsg, key)
		case "euLocation":
			err = unpopulate(val, "EuLocation", &o.EuLocation)
			delete(rawMsg, key)
		case "streamingDataClient":
			err = unpopulate(val, "StreamingDataClient", &o.StreamingDataClient)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Offer.
func (o Offer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Offer.
func (o *Offer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &o.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OfferList.
func (o OfferList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OfferList.
func (o *OfferList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OfferProperties.
func (o OfferProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content", o.Content)
	populate(objectMap, "contentVersion", o.ContentVersion)
	populate(objectMap, "provisioningState", o.ProvisioningState)
	populate(objectMap, "publisherId", o.PublisherID)
	populate(objectMap, "skuMappings", o.SKUMappings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OfferProperties.
func (o *OfferProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
			err = unpopulate(val, "Content", &o.Content)
			delete(rawMsg, key)
		case "contentVersion":
			err = unpopulate(val, "ContentVersion", &o.ContentVersion)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &o.ProvisioningState)
			delete(rawMsg, key)
		case "publisherId":
			err = unpopulate(val, "PublisherID", &o.PublisherID)
			delete(rawMsg, key)
		case "skuMappings":
			err = unpopulate(val, "SKUMappings", &o.SKUMappings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnboardingConfiguration.
func (o OnboardingConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arcVirtualMachineId", o.ArcVirtualMachineID)
	populate(objectMap, "location", o.Location)
	populate(objectMap, "resourceId", o.ResourceID)
	populate(objectMap, "tenantId", o.TenantID)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnboardingConfiguration.
func (o *OnboardingConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arcVirtualMachineId":
			err = unpopulate(val, "ArcVirtualMachineID", &o.ArcVirtualMachineID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &o.Location)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &o.ResourceID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &o.TenantID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDetail.
func (o OperationDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "error", o.Error)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "resourceId", o.ResourceID)
	populate(objectMap, "status", o.Status)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDetail.
func (o *OperationDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &o.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &o.ResourceID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &o.Status)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OptionalServices.
func (o OptionalServices) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customLocation", o.CustomLocation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OptionalServices.
func (o *OptionalServices) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customLocation":
			err = unpopulate(val, "CustomLocation", &o.CustomLocation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OsImage.
func (o OsImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OsImage.
func (o *OsImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &o.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OsImageListResult.
func (o OsImageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OsImageListResult.
func (o *OsImageListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OsImageProperties.
func (o OsImageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "composedImageIsoHash", o.ComposedImageIsoHash)
	populate(objectMap, "composedImageIsoUrl", o.ComposedImageIsoURL)
	populate(objectMap, "composedImageVersion", o.ComposedImageVersion)
	populate(objectMap, "validatedSolutionRecipeVersion", o.ValidatedSolutionRecipeVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OsImageProperties.
func (o *OsImageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "composedImageIsoHash":
			err = unpopulate(val, "ComposedImageIsoHash", &o.ComposedImageIsoHash)
			delete(rawMsg, key)
		case "composedImageIsoUrl":
			err = unpopulate(val, "ComposedImageIsoURL", &o.ComposedImageIsoURL)
			delete(rawMsg, key)
		case "composedImageVersion":
			err = unpopulate(val, "ComposedImageVersion", &o.ComposedImageVersion)
			delete(rawMsg, key)
		case "validatedSolutionRecipeVersion":
			err = unpopulate(val, "ValidatedSolutionRecipeVersion", &o.ValidatedSolutionRecipeVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OsProfile.
func (o OsProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assemblyVersion", o.AssemblyVersion)
	populate(objectMap, "baseImageVersion", o.BaseImageVersion)
	populate(objectMap, "bootType", o.BootType)
	populate(objectMap, "buildNumber", o.BuildNumber)
	populate(objectMap, "imageVersion", o.ImageVersion)
	populate(objectMap, "osSku", o.OSSKU)
	populate(objectMap, "osType", o.OSType)
	populate(objectMap, "osVersion", o.OSVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OsProfile.
func (o *OsProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assemblyVersion":
			err = unpopulate(val, "AssemblyVersion", &o.AssemblyVersion)
			delete(rawMsg, key)
		case "baseImageVersion":
			err = unpopulate(val, "BaseImageVersion", &o.BaseImageVersion)
			delete(rawMsg, key)
		case "bootType":
			err = unpopulate(val, "BootType", &o.BootType)
			delete(rawMsg, key)
		case "buildNumber":
			err = unpopulate(val, "BuildNumber", &o.BuildNumber)
			delete(rawMsg, key)
		case "imageVersion":
			err = unpopulate(val, "ImageVersion", &o.ImageVersion)
			delete(rawMsg, key)
		case "osSku":
			err = unpopulate(val, "OSSKU", &o.OSSKU)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &o.OSType)
			delete(rawMsg, key)
		case "osVersion":
			err = unpopulate(val, "OSVersion", &o.OSVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OsProvisionProfile.
func (o OsProvisionProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "gpgPubKey", o.GpgPubKey)
	populate(objectMap, "imageHash", o.ImageHash)
	populate(objectMap, "osImageLocation", o.OSImageLocation)
	populate(objectMap, "osName", o.OSName)
	populate(objectMap, "osType", o.OSType)
	populate(objectMap, "osVersion", o.OSVersion)
	populate(objectMap, "operationType", o.OperationType)
	populate(objectMap, "vsrVersion", o.VsrVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OsProvisionProfile.
func (o *OsProvisionProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "gpgPubKey":
			err = unpopulate(val, "GpgPubKey", &o.GpgPubKey)
			delete(rawMsg, key)
		case "imageHash":
			err = unpopulate(val, "ImageHash", &o.ImageHash)
			delete(rawMsg, key)
		case "osImageLocation":
			err = unpopulate(val, "OSImageLocation", &o.OSImageLocation)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &o.OSName)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &o.OSType)
			delete(rawMsg, key)
		case "osVersion":
			err = unpopulate(val, "OSVersion", &o.OSVersion)
			delete(rawMsg, key)
		case "operationType":
			err = unpopulate(val, "OperationType", &o.OperationType)
			delete(rawMsg, key)
		case "vsrVersion":
			err = unpopulate(val, "VsrVersion", &o.VsrVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OwnershipVoucherDetails.
func (o OwnershipVoucherDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ownerKeyType", o.OwnerKeyType)
	populate(objectMap, "ownershipVoucher", o.OwnershipVoucher)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OwnershipVoucherDetails.
func (o *OwnershipVoucherDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ownerKeyType":
			err = unpopulate(val, "OwnerKeyType", &o.OwnerKeyType)
			delete(rawMsg, key)
		case "ownershipVoucher":
			err = unpopulate(val, "OwnershipVoucher", &o.OwnershipVoucher)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OwnershipVoucherValidationDetails.
func (o OwnershipVoucherValidationDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureMachineId", o.AzureMachineID)
	populate(objectMap, "error", o.Error)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "manufacturer", o.Manufacturer)
	populate(objectMap, "modelName", o.ModelName)
	populate(objectMap, "serialNumber", o.SerialNumber)
	populate(objectMap, "validationStatus", o.ValidationStatus)
	populate(objectMap, "version", o.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OwnershipVoucherValidationDetails.
func (o *OwnershipVoucherValidationDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureMachineId":
			err = unpopulate(val, "AzureMachineID", &o.AzureMachineID)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &o.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "manufacturer":
			err = unpopulate(val, "Manufacturer", &o.Manufacturer)
			delete(rawMsg, key)
		case "modelName":
			err = unpopulate(val, "ModelName", &o.ModelName)
			delete(rawMsg, key)
		case "serialNumber":
			err = unpopulate(val, "SerialNumber", &o.SerialNumber)
			delete(rawMsg, key)
		case "validationStatus":
			err = unpopulate(val, "ValidationStatus", &o.ValidationStatus)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &o.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PackageVersionInfo.
func (p PackageVersionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "lastUpdated", p.LastUpdated)
	populate(objectMap, "packageType", p.PackageType)
	populate(objectMap, "version", p.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PackageVersionInfo.
func (p *PackageVersionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastUpdated":
			err = unpopulateDateTimeRFC3339(val, "LastUpdated", &p.LastUpdated)
			delete(rawMsg, key)
		case "packageType":
			err = unpopulate(val, "PackageType", &p.PackageType)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &p.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PasswordCredential.
func (p PasswordCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endDateTime", p.EndDateTime)
	populate(objectMap, "keyId", p.KeyID)
	populate(objectMap, "secretText", p.SecretText)
	populateDateTimeRFC3339(objectMap, "startDateTime", p.StartDateTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PasswordCredential.
func (p *PasswordCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endDateTime":
			err = unpopulateDateTimeRFC3339(val, "EndDateTime", &p.EndDateTime)
			delete(rawMsg, key)
		case "keyId":
			err = unpopulate(val, "KeyID", &p.KeyID)
			delete(rawMsg, key)
		case "secretText":
			err = unpopulate(val, "SecretText", &p.SecretText)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateDateTimeRFC3339(val, "StartDateTime", &p.StartDateTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PerNodeExtensionState.
func (p PerNodeExtensionState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extension", p.Extension)
	populate(objectMap, "instanceView", p.InstanceView)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "state", p.State)
	populate(objectMap, "typeHandlerVersion", p.TypeHandlerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PerNodeExtensionState.
func (p *PerNodeExtensionState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extension":
			err = unpopulate(val, "Extension", &p.Extension)
			delete(rawMsg, key)
		case "instanceView":
			err = unpopulate(val, "InstanceView", &p.InstanceView)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &p.State)
			delete(rawMsg, key)
		case "typeHandlerVersion":
			err = unpopulate(val, "TypeHandlerVersion", &p.TypeHandlerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PerNodeRemoteSupportSession.
func (p PerNodeRemoteSupportSession) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessLevel", p.AccessLevel)
	populate(objectMap, "duration", p.Duration)
	populate(objectMap, "nodeName", p.NodeName)
	populateDateTimeRFC3339(objectMap, "sessionEndTime", p.SessionEndTime)
	populateDateTimeRFC3339(objectMap, "sessionStartTime", p.SessionStartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PerNodeRemoteSupportSession.
func (p *PerNodeRemoteSupportSession) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessLevel":
			err = unpopulate(val, "AccessLevel", &p.AccessLevel)
			delete(rawMsg, key)
		case "duration":
			err = unpopulate(val, "Duration", &p.Duration)
			delete(rawMsg, key)
		case "nodeName":
			err = unpopulate(val, "NodeName", &p.NodeName)
			delete(rawMsg, key)
		case "sessionEndTime":
			err = unpopulateDateTimeRFC3339(val, "SessionEndTime", &p.SessionEndTime)
			delete(rawMsg, key)
		case "sessionStartTime":
			err = unpopulateDateTimeRFC3339(val, "SessionStartTime", &p.SessionStartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PerNodeState.
func (p PerNodeState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arcInstance", p.ArcInstance)
	populate(objectMap, "arcNodeServicePrincipalObjectId", p.ArcNodeServicePrincipalObjectID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "state", p.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PerNodeState.
func (p *PerNodeState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arcInstance":
			err = unpopulate(val, "ArcInstance", &p.ArcInstance)
			delete(rawMsg, key)
		case "arcNodeServicePrincipalObjectId":
			err = unpopulate(val, "ArcNodeServicePrincipalObjectID", &p.ArcNodeServicePrincipalObjectID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &p.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PhysicalNodes.
func (p PhysicalNodes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipv4Address", p.IPv4Address)
	populate(objectMap, "name", p.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhysicalNodes.
func (p *PhysicalNodes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipv4Address":
			err = unpopulate(val, "IPv4Address", &p.IPv4Address)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlatformPayload.
func (p PlatformPayload) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "payloadHash", p.PayloadHash)
	populate(objectMap, "payloadIdentifier", p.PayloadIdentifier)
	populate(objectMap, "payloadPackageSizeInBytes", p.PayloadPackageSizeInBytes)
	populate(objectMap, "payloadUrl", p.PayloadURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlatformPayload.
func (p *PlatformPayload) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "payloadHash":
			err = unpopulate(val, "PayloadHash", &p.PayloadHash)
			delete(rawMsg, key)
		case "payloadIdentifier":
			err = unpopulate(val, "PayloadIdentifier", &p.PayloadIdentifier)
			delete(rawMsg, key)
		case "payloadPackageSizeInBytes":
			err = unpopulate(val, "PayloadPackageSizeInBytes", &p.PayloadPackageSizeInBytes)
			delete(rawMsg, key)
		case "payloadUrl":
			err = unpopulate(val, "PayloadURL", &p.PayloadURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlatformUpdate.
func (p PlatformUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlatformUpdate.
func (p *PlatformUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlatformUpdateDetails.
func (p PlatformUpdateDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "platformPayloads", p.PlatformPayloads)
	populate(objectMap, "platformVersion", p.PlatformVersion)
	populate(objectMap, "validatedSolutionRecipeVersion", p.ValidatedSolutionRecipeVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlatformUpdateDetails.
func (p *PlatformUpdateDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "platformPayloads":
			err = unpopulate(val, "PlatformPayloads", &p.PlatformPayloads)
			delete(rawMsg, key)
		case "platformVersion":
			err = unpopulate(val, "PlatformVersion", &p.PlatformVersion)
			delete(rawMsg, key)
		case "validatedSolutionRecipeVersion":
			err = unpopulate(val, "ValidatedSolutionRecipeVersion", &p.ValidatedSolutionRecipeVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlatformUpdateListResult.
func (p PlatformUpdateListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlatformUpdateListResult.
func (p *PlatformUpdateListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlatformUpdateProperties.
func (p PlatformUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "platformUpdateDetails", p.PlatformUpdateDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlatformUpdateProperties.
func (p *PlatformUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "platformUpdateDetails":
			err = unpopulate(val, "PlatformUpdateDetails", &p.PlatformUpdateDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrecheckResult.
func (p PrecheckResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalData", p.AdditionalData)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "healthCheckSource", p.HealthCheckSource)
	populateAny(objectMap, "healthCheckTags", p.HealthCheckTags)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "remediation", p.Remediation)
	populate(objectMap, "severity", p.Severity)
	populate(objectMap, "status", p.Status)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "targetResourceID", p.TargetResourceID)
	populate(objectMap, "targetResourceName", p.TargetResourceName)
	populate(objectMap, "targetResourceType", p.TargetResourceType)
	populateDateTimeRFC3339(objectMap, "timestamp", p.Timestamp)
	populate(objectMap, "title", p.Title)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrecheckResult.
func (p *PrecheckResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalData":
			err = unpopulate(val, "AdditionalData", &p.AdditionalData)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "healthCheckSource":
			err = unpopulate(val, "HealthCheckSource", &p.HealthCheckSource)
			delete(rawMsg, key)
		case "healthCheckTags":
			err = unpopulate(val, "HealthCheckTags", &p.HealthCheckTags)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "remediation":
			err = unpopulate(val, "Remediation", &p.Remediation)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &p.Severity)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &p.Status)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &p.Tags)
			delete(rawMsg, key)
		case "targetResourceID":
			err = unpopulate(val, "TargetResourceID", &p.TargetResourceID)
			delete(rawMsg, key)
		case "targetResourceName":
			err = unpopulate(val, "TargetResourceName", &p.TargetResourceName)
			delete(rawMsg, key)
		case "targetResourceType":
			err = unpopulate(val, "TargetResourceType", &p.TargetResourceType)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateDateTimeRFC3339(val, "Timestamp", &p.Timestamp)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, "Title", &p.Title)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrecheckResultTags.
func (p PrecheckResultTags) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", p.Key)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrecheckResultTags.
func (p *PrecheckResultTags) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, "Key", &p.Key)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProvisionOsJobProperties.
func (p ProvisionOsJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentMode", p.DeploymentMode)
	populateDateTimeRFC3339(objectMap, "endTimeUtc", p.EndTimeUTC)
	populate(objectMap, "error", p.Error)
	populate(objectMap, "jobId", p.JobID)
	objectMap["jobType"] = EdgeMachineJobTypeProvisionOs
	populate(objectMap, "provisioningRequest", p.ProvisioningRequest)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "reportedProperties", p.ReportedProperties)
	populateDateTimeRFC3339(objectMap, "startTimeUtc", p.StartTimeUTC)
	populate(objectMap, "status", p.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProvisionOsJobProperties.
func (p *ProvisionOsJobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentMode":
			err = unpopulate(val, "DeploymentMode", &p.DeploymentMode)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "EndTimeUTC", &p.EndTimeUTC)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &p.Error)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, "JobID", &p.JobID)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &p.JobType)
			delete(rawMsg, key)
		case "provisioningRequest":
			err = unpopulate(val, "ProvisioningRequest", &p.ProvisioningRequest)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		case "reportedProperties":
			err = unpopulate(val, "ReportedProperties", &p.ReportedProperties)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "StartTimeUTC", &p.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &p.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProvisionOsReportedProperties.
func (p ProvisionOsReportedProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentStatus", p.DeploymentStatus)
	populate(objectMap, "percentComplete", p.PercentComplete)
	populate(objectMap, "validationStatus", p.ValidationStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProvisionOsReportedProperties.
func (p *ProvisionOsReportedProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentStatus":
			err = unpopulate(val, "DeploymentStatus", &p.DeploymentStatus)
			delete(rawMsg, key)
		case "percentComplete":
			err = unpopulate(val, "PercentComplete", &p.PercentComplete)
			delete(rawMsg, key)
		case "validationStatus":
			err = unpopulate(val, "ValidationStatus", &p.ValidationStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProvisioningDetails.
func (p ProvisioningDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "osProfile", p.OSProfile)
	populate(objectMap, "userDetails", p.UserDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProvisioningDetails.
func (p *ProvisioningDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "osProfile":
			err = unpopulate(val, "OSProfile", &p.OSProfile)
			delete(rawMsg, key)
		case "userDetails":
			err = unpopulate(val, "UserDetails", &p.UserDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProvisioningRequest.
func (p ProvisioningRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customConfiguration", p.CustomConfiguration)
	populate(objectMap, "deviceConfiguration", p.DeviceConfiguration)
	populate(objectMap, "osProfile", p.OSProfile)
	populate(objectMap, "onboardingConfiguration", p.OnboardingConfiguration)
	populate(objectMap, "target", p.Target)
	populate(objectMap, "userDetails", p.UserDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProvisioningRequest.
func (p *ProvisioningRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customConfiguration":
			err = unpopulate(val, "CustomConfiguration", &p.CustomConfiguration)
			delete(rawMsg, key)
		case "deviceConfiguration":
			err = unpopulate(val, "DeviceConfiguration", &p.DeviceConfiguration)
			delete(rawMsg, key)
		case "osProfile":
			err = unpopulate(val, "OSProfile", &p.OSProfile)
			delete(rawMsg, key)
		case "onboardingConfiguration":
			err = unpopulate(val, "OnboardingConfiguration", &p.OnboardingConfiguration)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &p.Target)
			delete(rawMsg, key)
		case "userDetails":
			err = unpopulate(val, "UserDetails", &p.UserDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Publisher.
func (p Publisher) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Publisher.
func (p *Publisher) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PublisherList.
func (p PublisherList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PublisherList.
func (p *PublisherList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PublisherProperties.
func (p PublisherProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PublisherProperties.
func (p *PublisherProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QosPolicyOverrides.
func (q QosPolicyOverrides) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bandwidthPercentage_SMB", q.BandwidthPercentageSMB)
	populate(objectMap, "priorityValue8021Action_Cluster", q.PriorityValue8021ActionCluster)
	populate(objectMap, "priorityValue8021Action_SMB", q.PriorityValue8021ActionSMB)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QosPolicyOverrides.
func (q *QosPolicyOverrides) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bandwidthPercentage_SMB":
			err = unpopulate(val, "BandwidthPercentageSMB", &q.BandwidthPercentageSMB)
			delete(rawMsg, key)
		case "priorityValue8021Action_Cluster":
			err = unpopulate(val, "PriorityValue8021ActionCluster", &q.PriorityValue8021ActionCluster)
			delete(rawMsg, key)
		case "priorityValue8021Action_SMB":
			err = unpopulate(val, "PriorityValue8021ActionSMB", &q.PriorityValue8021ActionSMB)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RawCertificateData.
func (r RawCertificateData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "certificates", r.Certificates)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RawCertificateData.
func (r *RawCertificateData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificates":
			err = unpopulate(val, "Certificates", &r.Certificates)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReconcileArcSettingsRequest.
func (r ReconcileArcSettingsRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReconcileArcSettingsRequest.
func (r *ReconcileArcSettingsRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &r.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReconcileArcSettingsRequestProperties.
func (r ReconcileArcSettingsRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterNodes", r.ClusterNodes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReconcileArcSettingsRequestProperties.
func (r *ReconcileArcSettingsRequestProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterNodes":
			err = unpopulate(val, "ClusterNodes", &r.ClusterNodes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemoteSupportJobNodeSettings.
func (r RemoteSupportJobNodeSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionErrorMessage", r.ConnectionErrorMessage)
	populate(objectMap, "connectionStatus", r.ConnectionStatus)
	populateDateTimeRFC3339(objectMap, "createdAt", r.CreatedAt)
	populate(objectMap, "state", r.State)
	populateDateTimeRFC3339(objectMap, "updatedAt", r.UpdatedAt)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemoteSupportJobNodeSettings.
func (r *RemoteSupportJobNodeSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionErrorMessage":
			err = unpopulate(val, "ConnectionErrorMessage", &r.ConnectionErrorMessage)
			delete(rawMsg, key)
		case "connectionStatus":
			err = unpopulate(val, "ConnectionStatus", &r.ConnectionStatus)
			delete(rawMsg, key)
		case "createdAt":
			err = unpopulateDateTimeRFC3339(val, "CreatedAt", &r.CreatedAt)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &r.State)
			delete(rawMsg, key)
		case "updatedAt":
			err = unpopulateDateTimeRFC3339(val, "UpdatedAt", &r.UpdatedAt)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemoteSupportJobReportedProperties.
func (r RemoteSupportJobReportedProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentStatus", r.DeploymentStatus)
	populate(objectMap, "nodeSettings", r.NodeSettings)
	populate(objectMap, "percentComplete", r.PercentComplete)
	populate(objectMap, "sessionDetails", r.SessionDetails)
	populate(objectMap, "validationStatus", r.ValidationStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemoteSupportJobReportedProperties.
func (r *RemoteSupportJobReportedProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentStatus":
			err = unpopulate(val, "DeploymentStatus", &r.DeploymentStatus)
			delete(rawMsg, key)
		case "nodeSettings":
			err = unpopulate(val, "NodeSettings", &r.NodeSettings)
			delete(rawMsg, key)
		case "percentComplete":
			err = unpopulate(val, "PercentComplete", &r.PercentComplete)
			delete(rawMsg, key)
		case "sessionDetails":
			err = unpopulate(val, "SessionDetails", &r.SessionDetails)
			delete(rawMsg, key)
		case "validationStatus":
			err = unpopulate(val, "ValidationStatus", &r.ValidationStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemoteSupportNodeSettings.
func (r RemoteSupportNodeSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "arcResourceId", r.ArcResourceID)
	populate(objectMap, "connectionErrorMessage", r.ConnectionErrorMessage)
	populate(objectMap, "connectionStatus", r.ConnectionStatus)
	populateDateTimeRFC3339(objectMap, "createdAt", r.CreatedAt)
	populate(objectMap, "state", r.State)
	populate(objectMap, "transcriptLocation", r.TranscriptLocation)
	populateDateTimeRFC3339(objectMap, "updatedAt", r.UpdatedAt)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemoteSupportNodeSettings.
func (r *RemoteSupportNodeSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arcResourceId":
			err = unpopulate(val, "ArcResourceID", &r.ArcResourceID)
			delete(rawMsg, key)
		case "connectionErrorMessage":
			err = unpopulate(val, "ConnectionErrorMessage", &r.ConnectionErrorMessage)
			delete(rawMsg, key)
		case "connectionStatus":
			err = unpopulate(val, "ConnectionStatus", &r.ConnectionStatus)
			delete(rawMsg, key)
		case "createdAt":
			err = unpopulateDateTimeRFC3339(val, "CreatedAt", &r.CreatedAt)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &r.State)
			delete(rawMsg, key)
		case "transcriptLocation":
			err = unpopulate(val, "TranscriptLocation", &r.TranscriptLocation)
			delete(rawMsg, key)
		case "updatedAt":
			err = unpopulateDateTimeRFC3339(val, "UpdatedAt", &r.UpdatedAt)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemoteSupportProperties.
func (r RemoteSupportProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessLevel", r.AccessLevel)
	populateDateTimeRFC3339(objectMap, "expirationTimeStamp", r.ExpirationTimeStamp)
	populate(objectMap, "remoteSupportNodeSettings", r.RemoteSupportNodeSettings)
	populate(objectMap, "remoteSupportSessionDetails", r.RemoteSupportSessionDetails)
	populate(objectMap, "remoteSupportType", r.RemoteSupportType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemoteSupportProperties.
func (r *RemoteSupportProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessLevel":
			err = unpopulate(val, "AccessLevel", &r.AccessLevel)
			delete(rawMsg, key)
		case "expirationTimeStamp":
			err = unpopulateDateTimeRFC3339(val, "ExpirationTimeStamp", &r.ExpirationTimeStamp)
			delete(rawMsg, key)
		case "remoteSupportNodeSettings":
			err = unpopulate(val, "RemoteSupportNodeSettings", &r.RemoteSupportNodeSettings)
			delete(rawMsg, key)
		case "remoteSupportSessionDetails":
			err = unpopulate(val, "RemoteSupportSessionDetails", &r.RemoteSupportSessionDetails)
			delete(rawMsg, key)
		case "remoteSupportType":
			err = unpopulate(val, "RemoteSupportType", &r.RemoteSupportType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemoteSupportRequest.
func (r RemoteSupportRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemoteSupportRequest.
func (r *RemoteSupportRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &r.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemoteSupportRequestProperties.
func (r RemoteSupportRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessLevel", r.AccessLevel)
	populateDateTimeRFC3339(objectMap, "expirationTimeStamp", r.ExpirationTimeStamp)
	populate(objectMap, "remoteSupportType", r.RemoteSupportType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemoteSupportRequestProperties.
func (r *RemoteSupportRequestProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessLevel":
			err = unpopulate(val, "AccessLevel", &r.AccessLevel)
			delete(rawMsg, key)
		case "expirationTimeStamp":
			err = unpopulateDateTimeRFC3339(val, "ExpirationTimeStamp", &r.ExpirationTimeStamp)
			delete(rawMsg, key)
		case "remoteSupportType":
			err = unpopulate(val, "RemoteSupportType", &r.RemoteSupportType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemoteSupportSession.
func (r RemoteSupportSession) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessLevel", r.AccessLevel)
	populateDateTimeRFC3339(objectMap, "sessionEndTime", r.SessionEndTime)
	populate(objectMap, "sessionId", r.SessionID)
	populateDateTimeRFC3339(objectMap, "sessionStartTime", r.SessionStartTime)
	populate(objectMap, "transcriptLocation", r.TranscriptLocation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemoteSupportSession.
func (r *RemoteSupportSession) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessLevel":
			err = unpopulate(val, "AccessLevel", &r.AccessLevel)
			delete(rawMsg, key)
		case "sessionEndTime":
			err = unpopulateDateTimeRFC3339(val, "SessionEndTime", &r.SessionEndTime)
			delete(rawMsg, key)
		case "sessionId":
			err = unpopulate(val, "SessionID", &r.SessionID)
			delete(rawMsg, key)
		case "sessionStartTime":
			err = unpopulateDateTimeRFC3339(val, "SessionStartTime", &r.SessionStartTime)
			delete(rawMsg, key)
		case "transcriptLocation":
			err = unpopulate(val, "TranscriptLocation", &r.TranscriptLocation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SKU.
func (s SKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SKU.
func (s *SKU) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SKUList.
func (s SKUList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SKUList.
func (s *SKUList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SKUMappings.
func (s SKUMappings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "catalogPlanId", s.CatalogPlanID)
	populate(objectMap, "marketplaceSkuId", s.MarketplaceSKUID)
	populate(objectMap, "marketplaceSkuVersions", s.MarketplaceSKUVersions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SKUMappings.
func (s *SKUMappings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catalogPlanId":
			err = unpopulate(val, "CatalogPlanID", &s.CatalogPlanID)
			delete(rawMsg, key)
		case "marketplaceSkuId":
			err = unpopulate(val, "MarketplaceSKUID", &s.MarketplaceSKUID)
			delete(rawMsg, key)
		case "marketplaceSkuVersions":
			err = unpopulate(val, "MarketplaceSKUVersions", &s.MarketplaceSKUVersions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SKUProperties.
func (s SKUProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content", s.Content)
	populate(objectMap, "contentVersion", s.ContentVersion)
	populate(objectMap, "offerId", s.OfferID)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "publisherId", s.PublisherID)
	populate(objectMap, "skuMappings", s.SKUMappings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SKUProperties.
func (s *SKUProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
			err = unpopulate(val, "Content", &s.Content)
			delete(rawMsg, key)
		case "contentVersion":
			err = unpopulate(val, "ContentVersion", &s.ContentVersion)
			delete(rawMsg, key)
		case "offerId":
			err = unpopulate(val, "OfferID", &s.OfferID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "publisherId":
			err = unpopulate(val, "PublisherID", &s.PublisherID)
			delete(rawMsg, key)
		case "skuMappings":
			err = unpopulate(val, "SKUMappings", &s.SKUMappings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SbeCredentials.
func (s SbeCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eceSecretName", s.EceSecretName)
	populate(objectMap, "secretLocation", s.SecretLocation)
	populate(objectMap, "secretName", s.SecretName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SbeCredentials.
func (s *SbeCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eceSecretName":
			err = unpopulate(val, "EceSecretName", &s.EceSecretName)
			delete(rawMsg, key)
		case "secretLocation":
			err = unpopulate(val, "SecretLocation", &s.SecretLocation)
			delete(rawMsg, key)
		case "secretName":
			err = unpopulate(val, "SecretName", &s.SecretName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SbeDeploymentInfo.
func (s SbeDeploymentInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "family", s.Family)
	populate(objectMap, "publisher", s.Publisher)
	populateDateTimeRFC3339(objectMap, "sbeManifestCreationDate", s.SbeManifestCreationDate)
	populate(objectMap, "sbeManifestSource", s.SbeManifestSource)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SbeDeploymentInfo.
func (s *SbeDeploymentInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "family":
			err = unpopulate(val, "Family", &s.Family)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &s.Publisher)
			delete(rawMsg, key)
		case "sbeManifestCreationDate":
			err = unpopulateDateTimeRFC3339(val, "SbeManifestCreationDate", &s.SbeManifestCreationDate)
			delete(rawMsg, key)
		case "sbeManifestSource":
			err = unpopulate(val, "SbeManifestSource", &s.SbeManifestSource)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SbeDeploymentPackageInfo.
func (s SbeDeploymentPackageInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", s.Code)
	populate(objectMap, "message", s.Message)
	populate(objectMap, "sbeManifest", s.SbeManifest)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SbeDeploymentPackageInfo.
func (s *SbeDeploymentPackageInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &s.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &s.Message)
			delete(rawMsg, key)
		case "sbeManifest":
			err = unpopulate(val, "SbeManifest", &s.SbeManifest)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SbePartnerInfo.
func (s SbePartnerInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "credentialList", s.CredentialList)
	populate(objectMap, "partnerProperties", s.PartnerProperties)
	populate(objectMap, "sbeDeploymentInfo", s.SbeDeploymentInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SbePartnerInfo.
func (s *SbePartnerInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialList":
			err = unpopulate(val, "CredentialList", &s.CredentialList)
			delete(rawMsg, key)
		case "partnerProperties":
			err = unpopulate(val, "PartnerProperties", &s.PartnerProperties)
			delete(rawMsg, key)
		case "sbeDeploymentInfo":
			err = unpopulate(val, "SbeDeploymentInfo", &s.SbeDeploymentInfo)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SbePartnerProperties.
func (s SbePartnerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SbePartnerProperties.
func (s *SbePartnerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScaleUnits.
func (s ScaleUnits) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deploymentData", s.DeploymentData)
	populate(objectMap, "sbePartnerInfo", s.SbePartnerInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScaleUnits.
func (s *ScaleUnits) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentData":
			err = unpopulate(val, "DeploymentData", &s.DeploymentData)
			delete(rawMsg, key)
		case "sbePartnerInfo":
			err = unpopulate(val, "SbePartnerInfo", &s.SbePartnerInfo)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SdnIntegration.
func (s SdnIntegration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "networkController", s.NetworkController)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SdnIntegration.
func (s *SdnIntegration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "networkController":
			err = unpopulate(val, "NetworkController", &s.NetworkController)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SdnProperties.
func (s SdnProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sdnApiAddress", s.SdnAPIAddress)
	populate(objectMap, "sdnDomainName", s.SdnDomainName)
	populate(objectMap, "sdnStatus", s.SdnStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SdnProperties.
func (s *SdnProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sdnApiAddress":
			err = unpopulate(val, "SdnAPIAddress", &s.SdnAPIAddress)
			delete(rawMsg, key)
		case "sdnDomainName":
			err = unpopulate(val, "SdnDomainName", &s.SdnDomainName)
			delete(rawMsg, key)
		case "sdnStatus":
			err = unpopulate(val, "SdnStatus", &s.SdnStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretsLocationDetails.
func (s SecretsLocationDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secretsLocation", s.SecretsLocation)
	populate(objectMap, "secretsType", s.SecretsType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretsLocationDetails.
func (s *SecretsLocationDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secretsLocation":
			err = unpopulate(val, "SecretsLocation", &s.SecretsLocation)
			delete(rawMsg, key)
		case "secretsType":
			err = unpopulate(val, "SecretsType", &s.SecretsType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretsLocationsChangeRequest.
func (s SecretsLocationsChangeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretsLocationsChangeRequest.
func (s *SecretsLocationsChangeRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecurityComplianceStatus.
func (s SecurityComplianceStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataAtRestEncrypted", s.DataAtRestEncrypted)
	populate(objectMap, "dataInTransitProtected", s.DataInTransitProtected)
	populateDateTimeRFC3339(objectMap, "lastUpdated", s.LastUpdated)
	populate(objectMap, "securedCoreCompliance", s.SecuredCoreCompliance)
	populate(objectMap, "wdacCompliance", s.WdacCompliance)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityComplianceStatus.
func (s *SecurityComplianceStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataAtRestEncrypted":
			err = unpopulate(val, "DataAtRestEncrypted", &s.DataAtRestEncrypted)
			delete(rawMsg, key)
		case "dataInTransitProtected":
			err = unpopulate(val, "DataInTransitProtected", &s.DataInTransitProtected)
			delete(rawMsg, key)
		case "lastUpdated":
			err = unpopulateDateTimeRFC3339(val, "LastUpdated", &s.LastUpdated)
			delete(rawMsg, key)
		case "securedCoreCompliance":
			err = unpopulate(val, "SecuredCoreCompliance", &s.SecuredCoreCompliance)
			delete(rawMsg, key)
		case "wdacCompliance":
			err = unpopulate(val, "WdacCompliance", &s.WdacCompliance)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecurityProperties.
func (s SecurityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "securedCoreComplianceAssignment", s.SecuredCoreComplianceAssignment)
	populate(objectMap, "securityComplianceStatus", s.SecurityComplianceStatus)
	populate(objectMap, "smbEncryptionForIntraClusterTrafficComplianceAssignment", s.SmbEncryptionForIntraClusterTrafficComplianceAssignment)
	populate(objectMap, "wdacComplianceAssignment", s.WdacComplianceAssignment)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityProperties.
func (s *SecurityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "securedCoreComplianceAssignment":
			err = unpopulate(val, "SecuredCoreComplianceAssignment", &s.SecuredCoreComplianceAssignment)
			delete(rawMsg, key)
		case "securityComplianceStatus":
			err = unpopulate(val, "SecurityComplianceStatus", &s.SecurityComplianceStatus)
			delete(rawMsg, key)
		case "smbEncryptionForIntraClusterTrafficComplianceAssignment":
			err = unpopulate(val, "SmbEncryptionForIntraClusterTrafficComplianceAssignment", &s.SmbEncryptionForIntraClusterTrafficComplianceAssignment)
			delete(rawMsg, key)
		case "wdacComplianceAssignment":
			err = unpopulate(val, "WdacComplianceAssignment", &s.WdacComplianceAssignment)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecuritySetting.
func (s SecuritySetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecuritySetting.
func (s *SecuritySetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecuritySettingListResult.
func (s SecuritySettingListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecuritySettingListResult.
func (s *SecuritySettingListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceConfiguration.
func (s ServiceConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "port", s.Port)
	populate(objectMap, "serviceName", s.ServiceName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceConfiguration.
func (s *ServiceConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "port":
			err = unpopulate(val, "Port", &s.Port)
			delete(rawMsg, key)
		case "serviceName":
			err = unpopulate(val, "ServiceName", &s.ServiceName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SiteDetails.
func (s SiteDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deviceConfiguration", s.DeviceConfiguration)
	populate(objectMap, "siteResourceId", s.SiteResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SiteDetails.
func (s *SiteDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deviceConfiguration":
			err = unpopulate(val, "DeviceConfiguration", &s.DeviceConfiguration)
			delete(rawMsg, key)
		case "siteResourceId":
			err = unpopulate(val, "SiteResourceID", &s.SiteResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SoftwareAssuranceChangeRequest.
func (s SoftwareAssuranceChangeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SoftwareAssuranceChangeRequest.
func (s *SoftwareAssuranceChangeRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SoftwareAssuranceChangeRequestProperties.
func (s SoftwareAssuranceChangeRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "softwareAssuranceIntent", s.SoftwareAssuranceIntent)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SoftwareAssuranceChangeRequestProperties.
func (s *SoftwareAssuranceChangeRequestProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "softwareAssuranceIntent":
			err = unpopulate(val, "SoftwareAssuranceIntent", &s.SoftwareAssuranceIntent)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SoftwareAssuranceProperties.
func (s SoftwareAssuranceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "lastUpdated", s.LastUpdated)
	populate(objectMap, "softwareAssuranceIntent", s.SoftwareAssuranceIntent)
	populate(objectMap, "softwareAssuranceStatus", s.SoftwareAssuranceStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SoftwareAssuranceProperties.
func (s *SoftwareAssuranceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastUpdated":
			err = unpopulateDateTimeRFC3339(val, "LastUpdated", &s.LastUpdated)
			delete(rawMsg, key)
		case "softwareAssuranceIntent":
			err = unpopulate(val, "SoftwareAssuranceIntent", &s.SoftwareAssuranceIntent)
			delete(rawMsg, key)
		case "softwareAssuranceStatus":
			err = unpopulate(val, "SoftwareAssuranceStatus", &s.SoftwareAssuranceStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Step.
func (s Step) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", s.Description)
	populateDateTimeRFC3339(objectMap, "endTimeUtc", s.EndTimeUTC)
	populate(objectMap, "errorMessage", s.ErrorMessage)
	populate(objectMap, "expectedExecutionTime", s.ExpectedExecutionTime)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTimeUtc", s.LastUpdatedTimeUTC)
	populate(objectMap, "name", s.Name)
	populateDateTimeRFC3339(objectMap, "startTimeUtc", s.StartTimeUTC)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "steps", s.Steps)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Step.
func (s *Step) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "EndTimeUTC", &s.EndTimeUTC)
			delete(rawMsg, key)
		case "errorMessage":
			err = unpopulate(val, "ErrorMessage", &s.ErrorMessage)
			delete(rawMsg, key)
		case "expectedExecutionTime":
			err = unpopulate(val, "ExpectedExecutionTime", &s.ExpectedExecutionTime)
			delete(rawMsg, key)
		case "lastUpdatedTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTimeUTC", &s.LastUpdatedTimeUTC)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "StartTimeUTC", &s.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		case "steps":
			err = unpopulate(val, "Steps", &s.Steps)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Storage.
func (s Storage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "configurationMode", s.ConfigurationMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Storage.
func (s *Storage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configurationMode":
			err = unpopulate(val, "ConfigurationMode", &s.ConfigurationMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StorageConfiguration.
func (s StorageConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "partitionSize", s.PartitionSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageConfiguration.
func (s *StorageConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionSize":
			err = unpopulate(val, "PartitionSize", &s.PartitionSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StorageProfile.
func (s StorageProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "poolableDisksCount", s.PoolableDisksCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageProfile.
func (s *StorageProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "poolableDisksCount":
			err = unpopulate(val, "PoolableDisksCount", &s.PoolableDisksCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SwitchDetail.
func (s SwitchDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extensions", s.Extensions)
	populate(objectMap, "switchName", s.SwitchName)
	populate(objectMap, "switchType", s.SwitchType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchDetail.
func (s *SwitchDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extensions":
			err = unpopulate(val, "Extensions", &s.Extensions)
			delete(rawMsg, key)
		case "switchName":
			err = unpopulate(val, "SwitchName", &s.SwitchName)
			delete(rawMsg, key)
		case "switchType":
			err = unpopulate(val, "SwitchType", &s.SwitchType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SwitchExtension.
func (s SwitchExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extensionEnabled", s.ExtensionEnabled)
	populate(objectMap, "extensionName", s.ExtensionName)
	populate(objectMap, "switchId", s.SwitchID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchExtension.
func (s *SwitchExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extensionEnabled":
			err = unpopulate(val, "ExtensionEnabled", &s.ExtensionEnabled)
			delete(rawMsg, key)
		case "extensionName":
			err = unpopulate(val, "ExtensionName", &s.ExtensionName)
			delete(rawMsg, key)
		case "switchId":
			err = unpopulate(val, "SwitchID", &s.SwitchID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateDateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateDateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateDateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TargetDeviceConfiguration.
func (t TargetDeviceConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hostName", t.HostName)
	populate(objectMap, "network", t.Network)
	populate(objectMap, "storage", t.Storage)
	populate(objectMap, "time", t.Time)
	populate(objectMap, "webProxy", t.WebProxy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TargetDeviceConfiguration.
func (t *TargetDeviceConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hostName":
			err = unpopulate(val, "HostName", &t.HostName)
			delete(rawMsg, key)
		case "network":
			err = unpopulate(val, "Network", &t.Network)
			delete(rawMsg, key)
		case "storage":
			err = unpopulate(val, "Storage", &t.Storage)
			delete(rawMsg, key)
		case "time":
			err = unpopulate(val, "Time", &t.Time)
			delete(rawMsg, key)
		case "webProxy":
			err = unpopulate(val, "WebProxy", &t.WebProxy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TimeConfiguration.
func (t TimeConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "primaryTimeServer", t.PrimaryTimeServer)
	populate(objectMap, "secondaryTimeServer", t.SecondaryTimeServer)
	populate(objectMap, "timeZone", t.TimeZone)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TimeConfiguration.
func (t *TimeConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "primaryTimeServer":
			err = unpopulate(val, "PrimaryTimeServer", &t.PrimaryTimeServer)
			delete(rawMsg, key)
		case "secondaryTimeServer":
			err = unpopulate(val, "SecondaryTimeServer", &t.SecondaryTimeServer)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, "TimeZone", &t.TimeZone)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Update.
func (u Update) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", u.ID)
	populate(objectMap, "location", u.Location)
	populate(objectMap, "name", u.Name)
	populate(objectMap, "properties", u.Properties)
	populate(objectMap, "systemData", u.SystemData)
	populate(objectMap, "type", u.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Update.
func (u *Update) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &u.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &u.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &u.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &u.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &u.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &u.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateContent.
func (u UpdateContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", u.ID)
	populate(objectMap, "name", u.Name)
	populate(objectMap, "properties", u.Properties)
	populate(objectMap, "systemData", u.SystemData)
	populate(objectMap, "type", u.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateContent.
func (u *UpdateContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &u.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &u.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &u.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &u.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &u.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateContentListResult.
func (u UpdateContentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", u.NextLink)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateContentListResult.
func (u *UpdateContentListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &u.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &u.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateContentProperties.
func (u UpdateContentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "updatePayloads", u.UpdatePayloads)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateContentProperties.
func (u *UpdateContentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "updatePayloads":
			err = unpopulate(val, "UpdatePayloads", &u.UpdatePayloads)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateList.
func (u UpdateList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", u.NextLink)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateList.
func (u *UpdateList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &u.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &u.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdatePrerequisite.
func (u UpdatePrerequisite) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "packageName", u.PackageName)
	populate(objectMap, "updateType", u.UpdateType)
	populate(objectMap, "version", u.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdatePrerequisite.
func (u *UpdatePrerequisite) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "packageName":
			err = unpopulate(val, "PackageName", &u.PackageName)
			delete(rawMsg, key)
		case "updateType":
			err = unpopulate(val, "UpdateType", &u.UpdateType)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &u.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateProperties.
func (u UpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalProperties", u.AdditionalProperties)
	populate(objectMap, "availabilityType", u.AvailabilityType)
	populate(objectMap, "componentVersions", u.ComponentVersions)
	populate(objectMap, "description", u.Description)
	populate(objectMap, "displayName", u.DisplayName)
	populateDateTimeRFC3339(objectMap, "healthCheckDate", u.HealthCheckDate)
	populate(objectMap, "healthCheckResult", u.HealthCheckResult)
	populate(objectMap, "healthState", u.HealthState)
	populateDateTimeRFC3339(objectMap, "installedDate", u.InstalledDate)
	populate(objectMap, "minSbeVersionRequired", u.MinSbeVersionRequired)
	populate(objectMap, "packagePath", u.PackagePath)
	populate(objectMap, "packageSizeInMb", u.PackageSizeInMb)
	populate(objectMap, "packageType", u.PackageType)
	populate(objectMap, "prerequisites", u.Prerequisites)
	populate(objectMap, "provisioningState", u.ProvisioningState)
	populate(objectMap, "publisher", u.Publisher)
	populate(objectMap, "rebootRequired", u.RebootRequired)
	populate(objectMap, "releaseLink", u.ReleaseLink)
	populate(objectMap, "state", u.State)
	populate(objectMap, "updateStateProperties", u.UpdateStateProperties)
	populate(objectMap, "version", u.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateProperties.
func (u *UpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
			err = unpopulate(val, "AdditionalProperties", &u.AdditionalProperties)
			delete(rawMsg, key)
		case "availabilityType":
			err = unpopulate(val, "AvailabilityType", &u.AvailabilityType)
			delete(rawMsg, key)
		case "componentVersions":
			err = unpopulate(val, "ComponentVersions", &u.ComponentVersions)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &u.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		case "healthCheckDate":
			err = unpopulateDateTimeRFC3339(val, "HealthCheckDate", &u.HealthCheckDate)
			delete(rawMsg, key)
		case "healthCheckResult":
			err = unpopulate(val, "HealthCheckResult", &u.HealthCheckResult)
			delete(rawMsg, key)
		case "healthState":
			err = unpopulate(val, "HealthState", &u.HealthState)
			delete(rawMsg, key)
		case "installedDate":
			err = unpopulateDateTimeRFC3339(val, "InstalledDate", &u.InstalledDate)
			delete(rawMsg, key)
		case "minSbeVersionRequired":
			err = unpopulate(val, "MinSbeVersionRequired", &u.MinSbeVersionRequired)
			delete(rawMsg, key)
		case "packagePath":
			err = unpopulate(val, "PackagePath", &u.PackagePath)
			delete(rawMsg, key)
		case "packageSizeInMb":
			err = unpopulate(val, "PackageSizeInMb", &u.PackageSizeInMb)
			delete(rawMsg, key)
		case "packageType":
			err = unpopulate(val, "PackageType", &u.PackageType)
			delete(rawMsg, key)
		case "prerequisites":
			err = unpopulate(val, "Prerequisites", &u.Prerequisites)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &u.ProvisioningState)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &u.Publisher)
			delete(rawMsg, key)
		case "rebootRequired":
			err = unpopulate(val, "RebootRequired", &u.RebootRequired)
			delete(rawMsg, key)
		case "releaseLink":
			err = unpopulate(val, "ReleaseLink", &u.ReleaseLink)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &u.State)
			delete(rawMsg, key)
		case "updateStateProperties":
			err = unpopulate(val, "UpdateStateProperties", &u.UpdateStateProperties)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &u.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateRun.
func (u UpdateRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", u.ID)
	populate(objectMap, "location", u.Location)
	populate(objectMap, "name", u.Name)
	populate(objectMap, "properties", u.Properties)
	populate(objectMap, "systemData", u.SystemData)
	populate(objectMap, "type", u.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateRun.
func (u *UpdateRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &u.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &u.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &u.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &u.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &u.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &u.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateRunList.
func (u UpdateRunList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", u.NextLink)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateRunList.
func (u *UpdateRunList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &u.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &u.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateRunProperties.
func (u UpdateRunProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "duration", u.Duration)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", u.LastUpdatedTime)
	populate(objectMap, "progress", u.Progress)
	populate(objectMap, "provisioningState", u.ProvisioningState)
	populate(objectMap, "state", u.State)
	populateDateTimeRFC3339(objectMap, "timeStarted", u.TimeStarted)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateRunProperties.
func (u *UpdateRunProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
			err = unpopulate(val, "Duration", &u.Duration)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &u.LastUpdatedTime)
			delete(rawMsg, key)
		case "progress":
			err = unpopulate(val, "Progress", &u.Progress)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &u.ProvisioningState)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &u.State)
			delete(rawMsg, key)
		case "timeStarted":
			err = unpopulateDateTimeRFC3339(val, "TimeStarted", &u.TimeStarted)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateStateProperties.
func (u UpdateStateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "notifyMessage", u.NotifyMessage)
	populate(objectMap, "progressPercentage", u.ProgressPercentage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateStateProperties.
func (u *UpdateStateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "notifyMessage":
			err = unpopulate(val, "NotifyMessage", &u.NotifyMessage)
			delete(rawMsg, key)
		case "progressPercentage":
			err = unpopulate(val, "ProgressPercentage", &u.ProgressPercentage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateSummaries.
func (u UpdateSummaries) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", u.ID)
	populate(objectMap, "location", u.Location)
	populate(objectMap, "name", u.Name)
	populate(objectMap, "properties", u.Properties)
	populate(objectMap, "systemData", u.SystemData)
	populate(objectMap, "type", u.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateSummaries.
func (u *UpdateSummaries) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &u.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &u.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &u.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &u.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &u.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &u.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateSummariesList.
func (u UpdateSummariesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", u.NextLink)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateSummariesList.
func (u *UpdateSummariesList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &u.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &u.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateSummariesProperties.
func (u UpdateSummariesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "currentOemVersion", u.CurrentOemVersion)
	populate(objectMap, "currentSbeVersion", u.CurrentSbeVersion)
	populate(objectMap, "currentVersion", u.CurrentVersion)
	populate(objectMap, "hardwareModel", u.HardwareModel)
	populateDateTimeRFC3339(objectMap, "healthCheckDate", u.HealthCheckDate)
	populate(objectMap, "healthCheckResult", u.HealthCheckResult)
	populate(objectMap, "healthState", u.HealthState)
	populateDateTimeRFC3339(objectMap, "lastChecked", u.LastChecked)
	populateDateTimeRFC3339(objectMap, "lastUpdated", u.LastUpdated)
	populate(objectMap, "oemFamily", u.OemFamily)
	populate(objectMap, "packageVersions", u.PackageVersions)
	populate(objectMap, "provisioningState", u.ProvisioningState)
	populate(objectMap, "state", u.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateSummariesProperties.
func (u *UpdateSummariesProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentOemVersion":
			err = unpopulate(val, "CurrentOemVersion", &u.CurrentOemVersion)
			delete(rawMsg, key)
		case "currentSbeVersion":
			err = unpopulate(val, "CurrentSbeVersion", &u.CurrentSbeVersion)
			delete(rawMsg, key)
		case "currentVersion":
			err = unpopulate(val, "CurrentVersion", &u.CurrentVersion)
			delete(rawMsg, key)
		case "hardwareModel":
			err = unpopulate(val, "HardwareModel", &u.HardwareModel)
			delete(rawMsg, key)
		case "healthCheckDate":
			err = unpopulateDateTimeRFC3339(val, "HealthCheckDate", &u.HealthCheckDate)
			delete(rawMsg, key)
		case "healthCheckResult":
			err = unpopulate(val, "HealthCheckResult", &u.HealthCheckResult)
			delete(rawMsg, key)
		case "healthState":
			err = unpopulate(val, "HealthState", &u.HealthState)
			delete(rawMsg, key)
		case "lastChecked":
			err = unpopulateDateTimeRFC3339(val, "LastChecked", &u.LastChecked)
			delete(rawMsg, key)
		case "lastUpdated":
			err = unpopulateDateTimeRFC3339(val, "LastUpdated", &u.LastUpdated)
			delete(rawMsg, key)
		case "oemFamily":
			err = unpopulate(val, "OemFamily", &u.OemFamily)
			delete(rawMsg, key)
		case "packageVersions":
			err = unpopulate(val, "PackageVersions", &u.PackageVersions)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &u.ProvisioningState)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &u.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UploadCertificateRequest.
func (u UploadCertificateRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", u.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UploadCertificateRequest.
func (u *UploadCertificateRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &u.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAssignedIdentity.
func (u UserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", u.ClientID)
	populate(objectMap, "principalId", u.PrincipalID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAssignedIdentity.
func (u *UserAssignedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &u.ClientID)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, "PrincipalID", &u.PrincipalID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserDetails.
func (u UserDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sshPubKey", u.SSHPubKey)
	populate(objectMap, "secretLocation", u.SecretLocation)
	populate(objectMap, "secretType", u.SecretType)
	populate(objectMap, "userName", u.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserDetails.
func (u *UserDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sshPubKey":
			err = unpopulate(val, "SSHPubKey", &u.SSHPubKey)
			delete(rawMsg, key)
		case "secretLocation":
			err = unpopulate(val, "SecretLocation", &u.SecretLocation)
			delete(rawMsg, key)
		case "secretType":
			err = unpopulate(val, "SecretType", &u.SecretType)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &u.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateOwnershipVouchersRequest.
func (v ValidateOwnershipVouchersRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ownershipVoucherDetails", v.OwnershipVoucherDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateOwnershipVouchersRequest.
func (v *ValidateOwnershipVouchersRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ownershipVoucherDetails":
			err = unpopulate(val, "OwnershipVoucherDetails", &v.OwnershipVoucherDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateOwnershipVouchersResponse.
func (v ValidateOwnershipVouchersResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ownershipVoucherValidationDetails", v.OwnershipVoucherValidationDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateOwnershipVouchersResponse.
func (v *ValidateOwnershipVouchersResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ownershipVoucherValidationDetails":
			err = unpopulate(val, "OwnershipVoucherValidationDetails", &v.OwnershipVoucherValidationDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateRequest.
func (v ValidateRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalInfo", v.AdditionalInfo)
	populate(objectMap, "edgeDeviceIds", v.EdgeDeviceIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateRequest.
func (v *ValidateRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
			err = unpopulate(val, "AdditionalInfo", &v.AdditionalInfo)
			delete(rawMsg, key)
		case "edgeDeviceIds":
			err = unpopulate(val, "EdgeDeviceIDs", &v.EdgeDeviceIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateResponse.
func (v ValidateResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "status", v.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateResponse.
func (v *ValidateResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "status":
			err = unpopulate(val, "Status", &v.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidatedSolutionRecipe.
func (v ValidatedSolutionRecipe) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidatedSolutionRecipe.
func (v *ValidatedSolutionRecipe) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &v.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidatedSolutionRecipeCapabilities.
func (v ValidatedSolutionRecipeCapabilities) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterCapabilities", v.ClusterCapabilities)
	populate(objectMap, "nodeCapabilities", v.NodeCapabilities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidatedSolutionRecipeCapabilities.
func (v *ValidatedSolutionRecipeCapabilities) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterCapabilities":
			err = unpopulate(val, "ClusterCapabilities", &v.ClusterCapabilities)
			delete(rawMsg, key)
		case "nodeCapabilities":
			err = unpopulate(val, "NodeCapabilities", &v.NodeCapabilities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidatedSolutionRecipeCapability.
func (v ValidatedSolutionRecipeCapability) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capabilityName", v.CapabilityName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidatedSolutionRecipeCapability.
func (v *ValidatedSolutionRecipeCapability) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capabilityName":
			err = unpopulate(val, "CapabilityName", &v.CapabilityName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidatedSolutionRecipeComponent.
func (v ValidatedSolutionRecipeComponent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "installOrder", v.InstallOrder)
	populate(objectMap, "metadata", v.Metadata)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "payloads", v.Payloads)
	populate(objectMap, "requiredVersion", v.RequiredVersion)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidatedSolutionRecipeComponent.
func (v *ValidatedSolutionRecipeComponent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "installOrder":
			err = unpopulate(val, "InstallOrder", &v.InstallOrder)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &v.Metadata)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "payloads":
			err = unpopulate(val, "Payloads", &v.Payloads)
			delete(rawMsg, key)
		case "requiredVersion":
			err = unpopulate(val, "RequiredVersion", &v.RequiredVersion)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &v.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidatedSolutionRecipeComponentMetadata.
func (v ValidatedSolutionRecipeComponentMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "catalog", v.Catalog)
	populate(objectMap, "enableAutomaticUpgrade", v.EnableAutomaticUpgrade)
	populate(objectMap, "expectedHash", v.ExpectedHash)
	populate(objectMap, "extensionType", v.ExtensionType)
	populate(objectMap, "lcmUpdate", v.LcmUpdate)
	populate(objectMap, "link", v.Link)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "previewSource", v.PreviewSource)
	populate(objectMap, "publisher", v.Publisher)
	populate(objectMap, "releaseTrain", v.ReleaseTrain)
	populate(objectMap, "ring", v.Ring)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidatedSolutionRecipeComponentMetadata.
func (v *ValidatedSolutionRecipeComponentMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catalog":
			err = unpopulate(val, "Catalog", &v.Catalog)
			delete(rawMsg, key)
		case "enableAutomaticUpgrade":
			err = unpopulate(val, "EnableAutomaticUpgrade", &v.EnableAutomaticUpgrade)
			delete(rawMsg, key)
		case "expectedHash":
			err = unpopulate(val, "ExpectedHash", &v.ExpectedHash)
			delete(rawMsg, key)
		case "extensionType":
			err = unpopulate(val, "ExtensionType", &v.ExtensionType)
			delete(rawMsg, key)
		case "lcmUpdate":
			err = unpopulate(val, "LcmUpdate", &v.LcmUpdate)
			delete(rawMsg, key)
		case "link":
			err = unpopulate(val, "Link", &v.Link)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "previewSource":
			err = unpopulate(val, "PreviewSource", &v.PreviewSource)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &v.Publisher)
			delete(rawMsg, key)
		case "releaseTrain":
			err = unpopulate(val, "ReleaseTrain", &v.ReleaseTrain)
			delete(rawMsg, key)
		case "ring":
			err = unpopulate(val, "Ring", &v.Ring)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidatedSolutionRecipeComponentPayload.
func (v ValidatedSolutionRecipeComponentPayload) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fileName", v.FileName)
	populate(objectMap, "hash", v.Hash)
	populate(objectMap, "identifier", v.Identifier)
	populate(objectMap, "url", v.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidatedSolutionRecipeComponentPayload.
func (v *ValidatedSolutionRecipeComponentPayload) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			err = unpopulate(val, "FileName", &v.FileName)
			delete(rawMsg, key)
		case "hash":
			err = unpopulate(val, "Hash", &v.Hash)
			delete(rawMsg, key)
		case "identifier":
			err = unpopulate(val, "Identifier", &v.Identifier)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &v.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidatedSolutionRecipeContent.
func (v ValidatedSolutionRecipeContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capabilities", v.Capabilities)
	populate(objectMap, "components", v.Components)
	populate(objectMap, "info", v.Info)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidatedSolutionRecipeContent.
func (v *ValidatedSolutionRecipeContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capabilities":
			err = unpopulate(val, "Capabilities", &v.Capabilities)
			delete(rawMsg, key)
		case "components":
			err = unpopulate(val, "Components", &v.Components)
			delete(rawMsg, key)
		case "info":
			err = unpopulate(val, "Info", &v.Info)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidatedSolutionRecipeInfo.
func (v ValidatedSolutionRecipeInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "solutionType", v.SolutionType)
	populate(objectMap, "version", v.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidatedSolutionRecipeInfo.
func (v *ValidatedSolutionRecipeInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "solutionType":
			err = unpopulate(val, "SolutionType", &v.SolutionType)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &v.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidatedSolutionRecipeListResult.
func (v ValidatedSolutionRecipeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidatedSolutionRecipeListResult.
func (v *ValidatedSolutionRecipeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidatedSolutionRecipeProperties.
func (v ValidatedSolutionRecipeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "recipeContent", v.RecipeContent)
	populate(objectMap, "signature", v.Signature)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidatedSolutionRecipeProperties.
func (v *ValidatedSolutionRecipeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "recipeContent":
			err = unpopulate(val, "RecipeContent", &v.RecipeContent)
			delete(rawMsg, key)
		case "signature":
			err = unpopulate(val, "Signature", &v.Signature)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebProxyConfiguration.
func (w WebProxyConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bypassList", w.BypassList)
	populate(objectMap, "connectionUri", w.ConnectionURI)
	populate(objectMap, "port", w.Port)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebProxyConfiguration.
func (w *WebProxyConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bypassList":
			err = unpopulate(val, "BypassList", &w.BypassList)
			delete(rawMsg, key)
		case "connectionUri":
			err = unpopulate(val, "ConnectionURI", &w.ConnectionURI)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &w.Port)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
