//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armbatch

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// ActivateApplicationPackageParameters - Parameters for an activating an application package.
type ActivateApplicationPackageParameters struct {
	// REQUIRED; The format of the application package binary file.
	Format *string `json:"format,omitempty"`
}

// Application - Contains information about an application in a Batch account.
type Application struct {
	ProxyResource
	// The properties associated with the Application.
	Properties *ApplicationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Application.
func (a Application) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// ApplicationCreateOptions contains the optional parameters for the Application.Create method.
type ApplicationCreateOptions struct {
	// The parameters for the request.
	Parameters *Application
}

// ApplicationDeleteOptions contains the optional parameters for the Application.Delete method.
type ApplicationDeleteOptions struct {
	// placeholder for future optional parameters
}

// ApplicationGetOptions contains the optional parameters for the Application.Get method.
type ApplicationGetOptions struct {
	// placeholder for future optional parameters
}

// ApplicationListOptions contains the optional parameters for the Application.List method.
type ApplicationListOptions struct {
	// The maximum number of items to return in the response.
	Maxresults *int32
}

// ApplicationPackage - An application package which represents a particular version of an application.
type ApplicationPackage struct {
	ProxyResource
	// The properties associated with the Application Package.
	Properties *ApplicationPackageProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationPackage.
func (a ApplicationPackage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// ApplicationPackageActivateOptions contains the optional parameters for the ApplicationPackage.Activate method.
type ApplicationPackageActivateOptions struct {
	// placeholder for future optional parameters
}

// ApplicationPackageCreateOptions contains the optional parameters for the ApplicationPackage.Create method.
type ApplicationPackageCreateOptions struct {
	// The parameters for the request.
	Parameters *ApplicationPackage
}

// ApplicationPackageDeleteOptions contains the optional parameters for the ApplicationPackage.Delete method.
type ApplicationPackageDeleteOptions struct {
	// placeholder for future optional parameters
}

// ApplicationPackageGetOptions contains the optional parameters for the ApplicationPackage.Get method.
type ApplicationPackageGetOptions struct {
	// placeholder for future optional parameters
}

// ApplicationPackageListOptions contains the optional parameters for the ApplicationPackage.List method.
type ApplicationPackageListOptions struct {
	// The maximum number of items to return in the response.
	Maxresults *int32
}

// ApplicationPackageProperties - Properties of an application package
type ApplicationPackageProperties struct {
	// READ-ONLY; The format of the application package, if the package is active.
	Format *string `json:"format,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the package was last activated, if the package is active.
	LastActivationTime *time.Time `json:"lastActivationTime,omitempty" azure:"ro"`

	// READ-ONLY; The current state of the application package.
	State *PackageState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; The URL for the application package in Azure Storage.
	StorageURL *string `json:"storageUrl,omitempty" azure:"ro"`

	// READ-ONLY; The UTC time at which the Azure Storage URL will expire.
	StorageURLExpiry *time.Time `json:"storageUrlExpiry,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationPackageProperties.
func (a ApplicationPackageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "format", a.Format)
	populateTimeRFC3339(objectMap, "lastActivationTime", a.LastActivationTime)
	populate(objectMap, "state", a.State)
	populate(objectMap, "storageUrl", a.StorageURL)
	populateTimeRFC3339(objectMap, "storageUrlExpiry", a.StorageURLExpiry)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationPackageProperties.
func (a *ApplicationPackageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "format":
			err = unpopulate(val, &a.Format)
			delete(rawMsg, key)
		case "lastActivationTime":
			err = unpopulateTimeRFC3339(val, &a.LastActivationTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &a.State)
			delete(rawMsg, key)
		case "storageUrl":
			err = unpopulate(val, &a.StorageURL)
			delete(rawMsg, key)
		case "storageUrlExpiry":
			err = unpopulateTimeRFC3339(val, &a.StorageURLExpiry)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ApplicationPackageReference - Link to an application package inside the batch account
type ApplicationPackageReference struct {
	// REQUIRED; The ID of the application package to install. This must be inside the same batch account as the pool. This can either be a reference to a specific
	// version or the default version if one exists.
	ID *string `json:"id,omitempty"`

	// If this is omitted, and no default version is specified for this application, the request fails with the error code InvalidApplicationPackageReferences.
	// If you are calling the REST API directly, the
	// HTTP status code is 409.
	Version *string `json:"version,omitempty"`
}

// ApplicationProperties - The properties associated with the Application.
type ApplicationProperties struct {
	// A value indicating whether packages within the application may be overwritten using the same version string.
	AllowUpdates *bool `json:"allowUpdates,omitempty"`

	// The package to use if a client requests the application but does not specify a version. This property can only be set to the name of an existing package.
	DefaultVersion *string `json:"defaultVersion,omitempty"`

	// The display name for the application.
	DisplayName *string `json:"displayName,omitempty"`
}

// ApplicationUpdateOptions contains the optional parameters for the Application.Update method.
type ApplicationUpdateOptions struct {
	// placeholder for future optional parameters
}

// AutoScaleRun - The results and errors from an execution of a pool autoscale formula.
type AutoScaleRun struct {
	// REQUIRED; The time at which the autoscale formula was last evaluated.
	EvaluationTime *time.Time `json:"evaluationTime,omitempty"`

	// An error that occurred when autoscaling a pool.
	Error *AutoScaleRunError `json:"error,omitempty"`

	// Each variable value is returned in the form $variable=value, and variables are separated by semicolons.
	Results *string `json:"results,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AutoScaleRun.
func (a AutoScaleRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", a.Error)
	populateTimeRFC3339(objectMap, "evaluationTime", a.EvaluationTime)
	populate(objectMap, "results", a.Results)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutoScaleRun.
func (a *AutoScaleRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &a.Error)
			delete(rawMsg, key)
		case "evaluationTime":
			err = unpopulateTimeRFC3339(val, &a.EvaluationTime)
			delete(rawMsg, key)
		case "results":
			err = unpopulate(val, &a.Results)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AutoScaleRunError - An error that occurred when autoscaling a pool.
type AutoScaleRunError struct {
	// REQUIRED; An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// REQUIRED; A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`

	// Additional details about the error.
	Details []*AutoScaleRunError `json:"details,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AutoScaleRunError.
func (a AutoScaleRunError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", a.Code)
	populate(objectMap, "details", a.Details)
	populate(objectMap, "message", a.Message)
	return json.Marshal(objectMap)
}

// AutoScaleSettings - AutoScale settings for the pool.
type AutoScaleSettings struct {
	// REQUIRED; A formula for the desired number of compute nodes in the pool.
	Formula *string `json:"formula,omitempty"`

	// If omitted, the default value is 15 minutes (PT15M).
	EvaluationInterval *string `json:"evaluationInterval,omitempty"`
}

// AutoStorageBaseProperties - The properties related to the auto-storage account.
type AutoStorageBaseProperties struct {
	// REQUIRED; The resource ID of the storage account to be used for auto-storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`

	// The authentication mode which the Batch service will use to manage the auto-storage account.
	AuthenticationMode *AutoStorageAuthenticationMode `json:"authenticationMode,omitempty"`

	// The identity referenced here must be assigned to pools which have compute nodes that need access to auto-storage.
	NodeIdentityReference *ComputeNodeIdentityReference `json:"nodeIdentityReference,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AutoStorageBaseProperties.
func (a AutoStorageBaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutoStorageBaseProperties.
func (a *AutoStorageBaseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AutoStorageBaseProperties) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "authenticationMode", a.AuthenticationMode)
	populate(objectMap, "nodeIdentityReference", a.NodeIdentityReference)
	populate(objectMap, "storageAccountId", a.StorageAccountID)
}

func (a *AutoStorageBaseProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationMode":
			err = unpopulate(val, &a.AuthenticationMode)
			delete(rawMsg, key)
		case "nodeIdentityReference":
			err = unpopulate(val, &a.NodeIdentityReference)
			delete(rawMsg, key)
		case "storageAccountId":
			err = unpopulate(val, &a.StorageAccountID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AutoStorageProperties - Contains information about the auto-storage account associated with a Batch account.
type AutoStorageProperties struct {
	AutoStorageBaseProperties
	// REQUIRED; The UTC time at which storage keys were last synchronized with the Batch account.
	LastKeySync *time.Time `json:"lastKeySync,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AutoStorageProperties.
func (a AutoStorageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.AutoStorageBaseProperties.marshalInternal(objectMap)
	populateTimeRFC3339(objectMap, "lastKeySync", a.LastKeySync)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutoStorageProperties.
func (a *AutoStorageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastKeySync":
			err = unpopulateTimeRFC3339(val, &a.LastKeySync)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.AutoStorageBaseProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AutoUserSpecification - Specifies the parameters for the auto user that runs a task on the Batch service.
type AutoUserSpecification struct {
	// The default value is nonAdmin.
	ElevationLevel *ElevationLevel `json:"elevationLevel,omitempty"`

	// The default value is Pool. If the pool is running Windows a value of Task should be specified if stricter isolation between tasks is required. For example,
	// if the task mutates the registry in a way
	// which could impact other tasks, or if certificates have been specified on the pool which should not be accessible by normal tasks but should be accessible
	// by start tasks.
	Scope *AutoUserScope `json:"scope,omitempty"`
}

// AzureBlobFileSystemConfiguration - Information used to connect to an Azure Storage Container using Blobfuse.
type AzureBlobFileSystemConfiguration struct {
	// REQUIRED; The Azure Storage Account name.
	AccountName *string `json:"accountName,omitempty"`

	// REQUIRED; The Azure Blob Storage Container name.
	ContainerName *string `json:"containerName,omitempty"`

	// REQUIRED; All file systems are mounted relative to the Batch mounts directory, accessible via the AZBATCHNODEMOUNTSDIR environment variable.
	RelativeMountPath *string `json:"relativeMountPath,omitempty"`

	// This property is mutually exclusive with both sasKey and identity; exactly one must be specified.
	AccountKey *string `json:"accountKey,omitempty"`

	// These are 'net use' options in Windows and 'mount' options in Linux.
	BlobfuseOptions *string `json:"blobfuseOptions,omitempty"`

	// This property is mutually exclusive with both accountKey and sasKey; exactly one must be specified.
	IdentityReference *ComputeNodeIdentityReference `json:"identityReference,omitempty"`

	// This property is mutually exclusive with both accountKey and identity; exactly one must be specified.
	SasKey *string `json:"sasKey,omitempty"`
}

// AzureFileShareConfiguration - Information used to connect to an Azure Fileshare.
type AzureFileShareConfiguration struct {
	// REQUIRED; The Azure Storage account key.
	AccountKey *string `json:"accountKey,omitempty"`

	// REQUIRED; The Azure Storage account name.
	AccountName *string `json:"accountName,omitempty"`

	// REQUIRED; This is of the form 'https://{account}.file.core.windows.net/'.
	AzureFileURL *string `json:"azureFileUrl,omitempty"`

	// REQUIRED; All file systems are mounted relative to the Batch mounts directory, accessible via the AZBATCHNODEMOUNTSDIR environment variable.
	RelativeMountPath *string `json:"relativeMountPath,omitempty"`

	// These are 'net use' options in Windows and 'mount' options in Linux.
	MountOptions *string `json:"mountOptions,omitempty"`
}

// BatchAccount - Contains information about an Azure Batch account.
type BatchAccount struct {
	Resource
	// The identity of the Batch account.
	Identity *BatchAccountIdentity `json:"identity,omitempty"`

	// The properties associated with the account.
	Properties *BatchAccountProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchAccount.
func (b BatchAccount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.Resource.marshalInternal(objectMap)
	populate(objectMap, "identity", b.Identity)
	populate(objectMap, "properties", b.Properties)
	return json.Marshal(objectMap)
}

// BatchAccountBeginCreateOptions contains the optional parameters for the BatchAccount.BeginCreate method.
type BatchAccountBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// BatchAccountBeginDeleteOptions contains the optional parameters for the BatchAccount.BeginDelete method.
type BatchAccountBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// BatchAccountCreateParameters - Parameters supplied to the Create operation.
type BatchAccountCreateParameters struct {
	// REQUIRED; The region in which to create the account.
	Location *string `json:"location,omitempty"`

	// The identity of the Batch account.
	Identity *BatchAccountIdentity `json:"identity,omitempty"`

	// The properties of the Batch account.
	Properties *BatchAccountCreateProperties `json:"properties,omitempty"`

	// The user-specified tags associated with the account.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchAccountCreateParameters.
func (b BatchAccountCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", b.Identity)
	populate(objectMap, "location", b.Location)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "tags", b.Tags)
	return json.Marshal(objectMap)
}

// BatchAccountCreateProperties - The properties of a Batch account.
type BatchAccountCreateProperties struct {
	// List of allowed authentication modes for the Batch account that can be used to authenticate with the data plane. This does not affect authentication
	// with the control plane.
	AllowedAuthenticationModes []*AuthenticationMode `json:"allowedAuthenticationModes,omitempty"`

	// The properties related to the auto-storage account.
	AutoStorage *AutoStorageBaseProperties `json:"autoStorage,omitempty"`

	// Configures how customer data is encrypted inside the Batch account. By default, accounts are encrypted using a Microsoft managed key. For additional
	// control, a customer-managed key can be used
	// instead.
	Encryption *EncryptionProperties `json:"encryption,omitempty"`

	// A reference to the Azure key vault associated with the Batch account.
	KeyVaultReference *KeyVaultReference `json:"keyVaultReference,omitempty"`

	// The pool allocation mode also affects how clients may authenticate to the Batch Service API. If the mode is BatchService, clients may authenticate using
	// access keys or Azure Active Directory. If the
	// mode is UserSubscription, clients must use Azure Active Directory. The default is BatchService.
	PoolAllocationMode *PoolAllocationMode `json:"poolAllocationMode,omitempty"`

	// If not specified, the default value is 'enabled'.
	PublicNetworkAccess *PublicNetworkAccessType `json:"publicNetworkAccess,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchAccountCreateProperties.
func (b BatchAccountCreateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowedAuthenticationModes", b.AllowedAuthenticationModes)
	populate(objectMap, "autoStorage", b.AutoStorage)
	populate(objectMap, "encryption", b.Encryption)
	populate(objectMap, "keyVaultReference", b.KeyVaultReference)
	populate(objectMap, "poolAllocationMode", b.PoolAllocationMode)
	populate(objectMap, "publicNetworkAccess", b.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// BatchAccountGetKeysOptions contains the optional parameters for the BatchAccount.GetKeys method.
type BatchAccountGetKeysOptions struct {
	// placeholder for future optional parameters
}

// BatchAccountGetOptions contains the optional parameters for the BatchAccount.Get method.
type BatchAccountGetOptions struct {
	// placeholder for future optional parameters
}

// BatchAccountIdentity - The identity of the Batch account, if configured. This is used when the user specifies 'Microsoft.KeyVault' as their Batch account
// encryption configuration or when ManagedIdentity is selected as the
// auto-storage authentication mode.
type BatchAccountIdentity struct {
	// REQUIRED; The type of identity used for the Batch account.
	Type *ResourceIdentityType `json:"type,omitempty"`

	// The list of user identities associated with the Batch account.
	UserAssignedIdentities map[string]*UserAssignedIdentities `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; The principal id of the Batch account. This property will only be provided for a system assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant id associated with the Batch account. This property will only be provided for a system assigned identity.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchAccountIdentity.
func (b BatchAccountIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", b.PrincipalID)
	populate(objectMap, "tenantId", b.TenantID)
	populate(objectMap, "type", b.Type)
	populate(objectMap, "userAssignedIdentities", b.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// BatchAccountKeys - A set of Azure Batch account keys.
type BatchAccountKeys struct {
	// READ-ONLY; The Batch account name.
	AccountName *string `json:"accountName,omitempty" azure:"ro"`

	// READ-ONLY; The primary key associated with the account.
	Primary *string `json:"primary,omitempty" azure:"ro"`

	// READ-ONLY; The secondary key associated with the account.
	Secondary *string `json:"secondary,omitempty" azure:"ro"`
}

// BatchAccountListByResourceGroupOptions contains the optional parameters for the BatchAccount.ListByResourceGroup method.
type BatchAccountListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// BatchAccountListOptions contains the optional parameters for the BatchAccount.List method.
type BatchAccountListOptions struct {
	// placeholder for future optional parameters
}

// BatchAccountListOutboundNetworkDependenciesEndpointsOptions contains the optional parameters for the BatchAccount.ListOutboundNetworkDependenciesEndpoints
// method.
type BatchAccountListOutboundNetworkDependenciesEndpointsOptions struct {
	// placeholder for future optional parameters
}

// BatchAccountListResult - Values returned by the List operation.
type BatchAccountListResult struct {
	// The continuation token.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection of Batch accounts returned by the listing operation.
	Value []*BatchAccount `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchAccountListResult.
func (b BatchAccountListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// BatchAccountProperties - Account specific properties.
type BatchAccountProperties struct {
	// READ-ONLY; The account endpoint used to interact with the Batch service.
	AccountEndpoint *string `json:"accountEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; The active job and job schedule quota for the Batch account.
	ActiveJobAndJobScheduleQuota *int32 `json:"activeJobAndJobScheduleQuota,omitempty" azure:"ro"`

	// READ-ONLY; List of allowed authentication modes for the Batch account that can be used to authenticate with the data plane. This does not affect authentication
	// with the control plane.
	AllowedAuthenticationModes []*AuthenticationMode `json:"allowedAuthenticationModes,omitempty" azure:"ro"`

	// READ-ONLY; Contains information about the auto-storage account associated with a Batch account.
	AutoStorage *AutoStorageProperties `json:"autoStorage,omitempty" azure:"ro"`

	// READ-ONLY; For accounts with PoolAllocationMode set to UserSubscription, quota is managed on the subscription so this value is not returned.
	DedicatedCoreQuota *int32 `json:"dedicatedCoreQuota,omitempty" azure:"ro"`

	// READ-ONLY; A list of the dedicated core quota per Virtual Machine family for the Batch account. For accounts with PoolAllocationMode set to UserSubscription,
	// quota is managed on the subscription so this value is
	// not returned.
	DedicatedCoreQuotaPerVMFamily []*VirtualMachineFamilyCoreQuota `json:"dedicatedCoreQuotaPerVMFamily,omitempty" azure:"ro"`

	// READ-ONLY; Batch is transitioning its core quota system for dedicated cores to be enforced per Virtual Machine family. During this transitional phase,
	// the dedicated core quota per Virtual Machine family may not
	// yet be enforced. If this flag is false, dedicated core quota is enforced via the old dedicatedCoreQuota property on the account and does not consider
	// Virtual Machine family. If this flag is true,
	// dedicated core quota is enforced via the dedicatedCoreQuotaPerVMFamily property on the account, and the old dedicatedCoreQuota does not apply.
	DedicatedCoreQuotaPerVMFamilyEnforced *bool `json:"dedicatedCoreQuotaPerVMFamilyEnforced,omitempty" azure:"ro"`

	// READ-ONLY; Configures how customer data is encrypted inside the Batch account. By default, accounts are encrypted using a Microsoft managed key. For
	// additional control, a customer-managed key can be used
	// instead.
	Encryption *EncryptionProperties `json:"encryption,omitempty" azure:"ro"`

	// READ-ONLY; Identifies the Azure key vault associated with a Batch account.
	KeyVaultReference *KeyVaultReference `json:"keyVaultReference,omitempty" azure:"ro"`

	// READ-ONLY; For accounts with PoolAllocationMode set to UserSubscription, quota is managed on the subscription so this value is not returned.
	LowPriorityCoreQuota *int32 `json:"lowPriorityCoreQuota,omitempty" azure:"ro"`

	// READ-ONLY; The allocation mode for creating pools in the Batch account.
	PoolAllocationMode *PoolAllocationMode `json:"poolAllocationMode,omitempty" azure:"ro"`

	// READ-ONLY; The pool quota for the Batch account.
	PoolQuota *int32 `json:"poolQuota,omitempty" azure:"ro"`

	// READ-ONLY; List of private endpoint connections associated with the Batch account
	PrivateEndpointConnections []*PrivateEndpointConnection `json:"privateEndpointConnections,omitempty" azure:"ro"`

	// READ-ONLY; The provisioned state of the resource
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; If not specified, the default value is 'enabled'.
	PublicNetworkAccess *PublicNetworkAccessType `json:"publicNetworkAccess,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchAccountProperties.
func (b BatchAccountProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountEndpoint", b.AccountEndpoint)
	populate(objectMap, "activeJobAndJobScheduleQuota", b.ActiveJobAndJobScheduleQuota)
	populate(objectMap, "allowedAuthenticationModes", b.AllowedAuthenticationModes)
	populate(objectMap, "autoStorage", b.AutoStorage)
	populate(objectMap, "dedicatedCoreQuota", b.DedicatedCoreQuota)
	populate(objectMap, "dedicatedCoreQuotaPerVMFamily", b.DedicatedCoreQuotaPerVMFamily)
	populate(objectMap, "dedicatedCoreQuotaPerVMFamilyEnforced", b.DedicatedCoreQuotaPerVMFamilyEnforced)
	populate(objectMap, "encryption", b.Encryption)
	populate(objectMap, "keyVaultReference", b.KeyVaultReference)
	populate(objectMap, "lowPriorityCoreQuota", b.LowPriorityCoreQuota)
	populate(objectMap, "poolAllocationMode", b.PoolAllocationMode)
	populate(objectMap, "poolQuota", b.PoolQuota)
	populate(objectMap, "privateEndpointConnections", b.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", b.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// BatchAccountRegenerateKeyOptions contains the optional parameters for the BatchAccount.RegenerateKey method.
type BatchAccountRegenerateKeyOptions struct {
	// placeholder for future optional parameters
}

// BatchAccountRegenerateKeyParameters - Parameters supplied to the RegenerateKey operation.
type BatchAccountRegenerateKeyParameters struct {
	// REQUIRED; The type of account key to regenerate.
	KeyName *AccountKeyType `json:"keyName,omitempty"`
}

// BatchAccountSynchronizeAutoStorageKeysOptions contains the optional parameters for the BatchAccount.SynchronizeAutoStorageKeys method.
type BatchAccountSynchronizeAutoStorageKeysOptions struct {
	// placeholder for future optional parameters
}

// BatchAccountUpdateOptions contains the optional parameters for the BatchAccount.Update method.
type BatchAccountUpdateOptions struct {
	// placeholder for future optional parameters
}

// BatchAccountUpdateParameters - Parameters for updating an Azure Batch account.
type BatchAccountUpdateParameters struct {
	// The identity of the Batch account.
	Identity *BatchAccountIdentity `json:"identity,omitempty"`

	// The properties of the account.
	Properties *BatchAccountUpdateProperties `json:"properties,omitempty"`

	// The user-specified tags associated with the account.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchAccountUpdateParameters.
func (b BatchAccountUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", b.Identity)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "tags", b.Tags)
	return json.Marshal(objectMap)
}

// BatchAccountUpdateProperties - The properties of a Batch account.
type BatchAccountUpdateProperties struct {
	// List of allowed authentication modes for the Batch account that can be used to authenticate with the data plane. This does not affect authentication
	// with the control plane.
	AllowedAuthenticationModes []*AuthenticationMode `json:"allowedAuthenticationModes,omitempty"`

	// The properties related to the auto-storage account.
	AutoStorage *AutoStorageBaseProperties `json:"autoStorage,omitempty"`

	// Configures how customer data is encrypted inside the Batch account. By default, accounts are encrypted using a Microsoft managed key. For additional
	// control, a customer-managed key can be used
	// instead.
	Encryption *EncryptionProperties `json:"encryption,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchAccountUpdateProperties.
func (b BatchAccountUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowedAuthenticationModes", b.AllowedAuthenticationModes)
	populate(objectMap, "autoStorage", b.AutoStorage)
	populate(objectMap, "encryption", b.Encryption)
	return json.Marshal(objectMap)
}

// BatchLocationQuota - Quotas associated with a Batch region for a particular subscription.
type BatchLocationQuota struct {
	// READ-ONLY; The number of Batch accounts that may be created under the subscription in the specified region.
	AccountQuota *int32 `json:"accountQuota,omitempty" azure:"ro"`
}

// BatchPoolIdentity - The identity of the Batch pool, if configured. If the pool identity is updated during update an existing pool, only the new vms which
// are created after the pool shrinks to 0 will have the updated
// identities
type BatchPoolIdentity struct {
	// REQUIRED; The type of identity used for the Batch Pool.
	Type *PoolIdentityType `json:"type,omitempty"`

	// The list of user identities associated with the Batch pool.
	UserAssignedIdentities map[string]*UserAssignedIdentities `json:"userAssignedIdentities,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolIdentity.
func (b BatchPoolIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "type", b.Type)
	populate(objectMap, "userAssignedIdentities", b.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// CIFSMountConfiguration - Information used to connect to a CIFS file system.
type CIFSMountConfiguration struct {
	// REQUIRED; The password to use for authentication against the CIFS file system.
	Password *string `json:"password,omitempty"`

	// REQUIRED; All file systems are mounted relative to the Batch mounts directory, accessible via the AZBATCHNODEMOUNTSDIR environment variable.
	RelativeMountPath *string `json:"relativeMountPath,omitempty"`

	// REQUIRED; The URI of the file system to mount.
	Source *string `json:"source,omitempty"`

	// REQUIRED; The user to use for authentication against the CIFS file system.
	Username *string `json:"username,omitempty"`

	// These are 'net use' options in Windows and 'mount' options in Linux.
	MountOptions *string `json:"mountOptions,omitempty"`
}

// Certificate - Contains information about a certificate.
type Certificate struct {
	ProxyResource
	// The properties associated with the certificate.
	Properties *CertificateProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Certificate.
func (c Certificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// CertificateBaseProperties - Base certificate properties.
type CertificateBaseProperties struct {
	// The format of the certificate - either Pfx or Cer. If omitted, the default is Pfx.
	Format *CertificateFormat `json:"format,omitempty"`

	// This must match the thumbprint from the name.
	Thumbprint *string `json:"thumbprint,omitempty"`

	// This must match the first portion of the certificate name. Currently required to be 'SHA1'.
	ThumbprintAlgorithm *string `json:"thumbprintAlgorithm,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateBaseProperties.
func (c CertificateBaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateBaseProperties.
func (c *CertificateBaseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c CertificateBaseProperties) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "format", c.Format)
	populate(objectMap, "thumbprint", c.Thumbprint)
	populate(objectMap, "thumbprintAlgorithm", c.ThumbprintAlgorithm)
}

func (c *CertificateBaseProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "format":
			err = unpopulate(val, &c.Format)
			delete(rawMsg, key)
		case "thumbprint":
			err = unpopulate(val, &c.Thumbprint)
			delete(rawMsg, key)
		case "thumbprintAlgorithm":
			err = unpopulate(val, &c.ThumbprintAlgorithm)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CertificateBeginDeleteOptions contains the optional parameters for the Certificate.BeginDelete method.
type CertificateBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// CertificateCancelDeletionOptions contains the optional parameters for the Certificate.CancelDeletion method.
type CertificateCancelDeletionOptions struct {
	// placeholder for future optional parameters
}

// CertificateCreateOptions contains the optional parameters for the Certificate.Create method.
type CertificateCreateOptions struct {
	// The entity state (ETag) version of the certificate to update. A value of "*" can be used to apply the operation only if the certificate already exists.
	// If omitted, this operation will always be applied.
	IfMatch *string
	// Set to '*' to allow a new certificate to be created, but to prevent updating an existing certificate. Other values will be ignored.
	IfNoneMatch *string
}

// CertificateCreateOrUpdateParameters - Contains information about a certificate.
type CertificateCreateOrUpdateParameters struct {
	ProxyResource
	// The properties associated with the certificate.
	Properties *CertificateCreateOrUpdateProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateCreateOrUpdateParameters.
func (c CertificateCreateOrUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// CertificateCreateOrUpdateProperties - Certificate properties for create operations
type CertificateCreateOrUpdateProperties struct {
	CertificateBaseProperties
	// REQUIRED; The maximum size is 10KB.
	Data *string `json:"data,omitempty"`

	// This must not be specified if the certificate format is Cer.
	Password *string `json:"password,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateCreateOrUpdateProperties.
func (c CertificateCreateOrUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.CertificateBaseProperties.marshalInternal(objectMap)
	populate(objectMap, "data", c.Data)
	populate(objectMap, "password", c.Password)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateCreateOrUpdateProperties.
func (c *CertificateCreateOrUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "data":
			err = unpopulate(val, &c.Data)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &c.Password)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.CertificateBaseProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CertificateGetOptions contains the optional parameters for the Certificate.Get method.
type CertificateGetOptions struct {
	// placeholder for future optional parameters
}

// CertificateListByBatchAccountOptions contains the optional parameters for the Certificate.ListByBatchAccount method.
type CertificateListByBatchAccountOptions struct {
	// OData filter expression. Valid properties for filtering are "properties/provisioningState", "properties/provisioningStateTransitionTime", "name".
	Filter *string
	// The maximum number of items to return in the response.
	Maxresults *int32
	// Comma separated list of properties that should be returned. e.g. "properties/provisioningState". Only top level properties under properties/ are valid
	// for selection.
	Select *string
}

// CertificateProperties - Certificate properties.
type CertificateProperties struct {
	CertificateBaseProperties
	// READ-ONLY; This is only returned when the certificate provisioningState is 'Failed'.
	DeleteCertificateError *DeleteCertificateError `json:"deleteCertificateError,omitempty" azure:"ro"`

	// READ-ONLY; The previous provisioned state of the resource
	PreviousProvisioningState *CertificateProvisioningState `json:"previousProvisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the certificate entered its previous state.
	PreviousProvisioningStateTransitionTime *time.Time `json:"previousProvisioningStateTransitionTime,omitempty" azure:"ro"`

	// READ-ONLY
	ProvisioningState *CertificateProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the certificate entered its current state.
	ProvisioningStateTransitionTime *time.Time `json:"provisioningStateTransitionTime,omitempty" azure:"ro"`

	// READ-ONLY; The public key of the certificate.
	PublicData *string `json:"publicData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateProperties.
func (c CertificateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.CertificateBaseProperties.marshalInternal(objectMap)
	populate(objectMap, "deleteCertificateError", c.DeleteCertificateError)
	populate(objectMap, "previousProvisioningState", c.PreviousProvisioningState)
	populateTimeRFC3339(objectMap, "previousProvisioningStateTransitionTime", c.PreviousProvisioningStateTransitionTime)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populateTimeRFC3339(objectMap, "provisioningStateTransitionTime", c.ProvisioningStateTransitionTime)
	populate(objectMap, "publicData", c.PublicData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateProperties.
func (c *CertificateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deleteCertificateError":
			err = unpopulate(val, &c.DeleteCertificateError)
			delete(rawMsg, key)
		case "previousProvisioningState":
			err = unpopulate(val, &c.PreviousProvisioningState)
			delete(rawMsg, key)
		case "previousProvisioningStateTransitionTime":
			err = unpopulateTimeRFC3339(val, &c.PreviousProvisioningStateTransitionTime)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &c.ProvisioningState)
			delete(rawMsg, key)
		case "provisioningStateTransitionTime":
			err = unpopulateTimeRFC3339(val, &c.ProvisioningStateTransitionTime)
			delete(rawMsg, key)
		case "publicData":
			err = unpopulate(val, &c.PublicData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.CertificateBaseProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CertificateReference - A reference to a certificate to be installed on compute nodes in a pool. This must exist inside the same account as the pool.
type CertificateReference struct {
	// REQUIRED; The fully qualified ID of the certificate to install on the pool. This must be inside the same batch account as the pool.
	ID *string `json:"id,omitempty"`

	// The default value is currentUser. This property is applicable only for pools configured with Windows nodes (that is, created with cloudServiceConfiguration,
	// or with virtualMachineConfiguration using a
	// Windows image reference). For Linux compute nodes, the certificates are stored in a directory inside the task working directory and an environment variable
	// AZBATCHCERTIFICATES_DIR is supplied to the
	// task to query for this location. For certificates with visibility of 'remoteUser', a 'certs' directory is created in the user's home directory (e.g.,
	// /home/{user-name}/certs) and certificates are
	// placed in that directory.
	StoreLocation *CertificateStoreLocation `json:"storeLocation,omitempty"`

	// This property is applicable only for pools configured with Windows nodes (that is, created with cloudServiceConfiguration, or with virtualMachineConfiguration
	// using a Windows image reference). Common
	// store names include: My, Root, CA, Trust, Disallowed, TrustedPeople, TrustedPublisher, AuthRoot, AddressBook, but any custom store name can also be used.
	// The default value is My.
	StoreName *string `json:"storeName,omitempty"`

	// Which user accounts on the compute node should have access to the private data of the certificate.
	Visibility []*CertificateVisibility `json:"visibility,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateReference.
func (c CertificateReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	populate(objectMap, "storeLocation", c.StoreLocation)
	populate(objectMap, "storeName", c.StoreName)
	populate(objectMap, "visibility", c.Visibility)
	return json.Marshal(objectMap)
}

// CertificateUpdateOptions contains the optional parameters for the Certificate.Update method.
type CertificateUpdateOptions struct {
	// The entity state (ETag) version of the certificate to update. This value can be omitted or set to "*" to apply the operation unconditionally.
	IfMatch *string
}

// CheckNameAvailabilityParameters - Parameters for a check name availability request.
type CheckNameAvailabilityParameters struct {
	// REQUIRED; The name to check for availability
	Name *string `json:"name,omitempty"`

	// REQUIRED; The resource type.
	Type *string `json:"type,omitempty"`
}

// CheckNameAvailabilityResult - The CheckNameAvailability operation response.
type CheckNameAvailabilityResult struct {
	// READ-ONLY; Gets an error message explaining the Reason value in more detail.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Gets a boolean value that indicates whether the name is available for you to use. If true, the name is available. If false, the name has already
	// been taken or invalid and cannot be used.
	NameAvailable *bool `json:"nameAvailable,omitempty" azure:"ro"`

	// READ-ONLY; Gets the reason that a Batch account name could not be used. The Reason element is only returned if NameAvailable is false.
	Reason *NameAvailabilityReason `json:"reason,omitempty" azure:"ro"`
}

// CloudError - An error response from the Batch service.
// Implements the error and azcore.HTTPResponse interfaces.
type CloudError struct {
	raw string
	// The body of the error response.
	InnerError *CloudErrorBody `json:"error,omitempty"`
}

// Error implements the error interface for type CloudError.
// The contents of the error text are not contractual and subject to change.
func (e CloudError) Error() string {
	return e.raw
}

// CloudErrorBody - An error response from the Batch service.
type CloudErrorBody struct {
	// An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// A list of additional details about the error.
	Details []*CloudErrorBody `json:"details,omitempty"`

	// A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`

	// The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CloudErrorBody.
func (c CloudErrorBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", c.Code)
	populate(objectMap, "details", c.Details)
	populate(objectMap, "message", c.Message)
	populate(objectMap, "target", c.Target)
	return json.Marshal(objectMap)
}

// CloudServiceConfiguration - The configuration for nodes in a pool based on the Azure Cloud Services platform.
type CloudServiceConfiguration struct {
	// REQUIRED; Possible values are: 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1. 3 - OS Family 3, equivalent to Windows Server 2012. 4 - OS
	// Family 4, equivalent to Windows Server 2012 R2. 5 - OS Family
	// 5, equivalent to Windows Server 2016. 6 - OS Family 6, equivalent to Windows Server 2019. For more information, see Azure Guest OS Releases
	// (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
	OSFamily *string `json:"osFamily,omitempty"`

	// The default value is * which specifies the latest operating system version for the specified OS family.
	OSVersion *string `json:"osVersion,omitempty"`
}

// ComputeNodeIdentityReference - The reference to a user assigned identity associated with the Batch pool which a compute node will use.
type ComputeNodeIdentityReference struct {
	// The ARM resource id of the user assigned identity.
	ResourceID *string `json:"resourceId,omitempty"`
}

// ContainerConfiguration - The configuration for container-enabled pools.
type ContainerConfiguration struct {
	// REQUIRED; The container technology to be used.
	Type *string `json:"type,omitempty"`

	// This is the full image reference, as would be specified to "docker pull". An image will be sourced from the default Docker registry unless the image
	// is fully qualified with an alternative registry.
	ContainerImageNames []*string `json:"containerImageNames,omitempty"`

	// If any images must be downloaded from a private registry which requires credentials, then those credentials must be provided here.
	ContainerRegistries []*ContainerRegistry `json:"containerRegistries,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContainerConfiguration.
func (c ContainerConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containerImageNames", c.ContainerImageNames)
	populate(objectMap, "containerRegistries", c.ContainerRegistries)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// ContainerRegistry - A private container registry.
type ContainerRegistry struct {
	// The reference to a user assigned identity associated with the Batch pool which a compute node will use.
	IdentityReference *ComputeNodeIdentityReference `json:"identityReference,omitempty"`

	// The password to log into the registry server.
	Password *string `json:"password,omitempty"`

	// If omitted, the default is "docker.io".
	RegistryServer *string `json:"registryServer,omitempty"`

	// The user name to log into the registry server.
	UserName *string `json:"username,omitempty"`
}

// DataDisk - Settings which will be used by the data disks associated to Compute Nodes in the Pool. When using attached data disks, you need to mount and
// format the disks from within a VM to use them.
type DataDisk struct {
	// REQUIRED; The initial disk size in GB when creating new data disk.
	DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`

	// REQUIRED; The lun is used to uniquely identify each data disk. If attaching multiple disks, each should have a distinct lun. The value must be between
	// 0 and 63, inclusive.
	Lun *int32 `json:"lun,omitempty"`

	// Values are:
	// none - The caching mode for the disk is not enabled. readOnly - The caching mode for the disk is read only. readWrite - The caching mode for the disk
	// is read and write.
	// The default value for caching is none. For information about the caching options see: https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
	Caching *CachingType `json:"caching,omitempty"`

	// If omitted, the default is "Standard_LRS". Values are:
	// StandardLRS - The data disk should use standard locally redundant storage. PremiumLRS - The data disk should use premium locally redundant storage.
	StorageAccountType *StorageAccountType `json:"storageAccountType,omitempty"`
}

// DeleteCertificateError - An error response from the Batch service.
type DeleteCertificateError struct {
	// REQUIRED; An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// REQUIRED; A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`

	// A list of additional details about the error.
	Details []*DeleteCertificateError `json:"details,omitempty"`

	// The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeleteCertificateError.
func (d DeleteCertificateError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", d.Code)
	populate(objectMap, "details", d.Details)
	populate(objectMap, "message", d.Message)
	populate(objectMap, "target", d.Target)
	return json.Marshal(objectMap)
}

// DeploymentConfiguration - Deployment configuration properties.
type DeploymentConfiguration struct {
	// This property and virtualMachineConfiguration are mutually exclusive and one of the properties must be specified. This property cannot be specified if
	// the Batch account was created with its
	// poolAllocationMode property set to 'UserSubscription'.
	CloudServiceConfiguration *CloudServiceConfiguration `json:"cloudServiceConfiguration,omitempty"`

	// This property and cloudServiceConfiguration are mutually exclusive and one of the properties must be specified.
	VirtualMachineConfiguration *VirtualMachineConfiguration `json:"virtualMachineConfiguration,omitempty"`
}

// DiffDiskSettings - Specifies the ephemeral Disk Settings for the operating system disk used by the virtual machine.
type DiffDiskSettings struct {
	// This property can be used by user in the request to choose which location the operating system should be in. e.g., cache disk space for Ephemeral OS
	// disk provisioning. For more information on
	// Ephemeral OS disk size requirements, please refer to Ephemeral OS disk size requirements for Windows VMs at
	// https://docs.microsoft.com/en-us/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements and Linux VMs at
	// https://docs.microsoft.com/en-us/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements.
	Placement *string `json:"placement,omitempty"`
}

// DiskEncryptionConfiguration - The disk encryption configuration applied on compute nodes in the pool. Disk encryption configuration is not supported
// on Linux pool created with Virtual Machine Image or Shared Image Gallery Image.
type DiskEncryptionConfiguration struct {
	// On Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and "TemporaryDisk" must be specified.
	Targets []*DiskEncryptionTarget `json:"targets,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskEncryptionConfiguration.
func (d DiskEncryptionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "targets", d.Targets)
	return json.Marshal(objectMap)
}

// EncryptionProperties - Configures how customer data is encrypted inside the Batch account. By default, accounts are encrypted using a Microsoft managed
// key. For additional control, a customer-managed key can be used
// instead.
type EncryptionProperties struct {
	// Type of the key source.
	KeySource *KeySource `json:"keySource,omitempty"`

	// Additional details when using Microsoft.KeyVault
	KeyVaultProperties *KeyVaultProperties `json:"keyVaultProperties,omitempty"`
}

// EndpointDependency - A domain name and connection details used to access a dependency.
type EndpointDependency struct {
	// READ-ONLY; Human-readable supplemental information about the dependency and when it is applicable.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The domain name of the dependency. Domain names may be fully qualified or may contain a * wildcard.
	DomainName *string `json:"domainName,omitempty" azure:"ro"`

	// READ-ONLY; The list of connection details for this endpoint.
	EndpointDetails []*EndpointDetail `json:"endpointDetails,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EndpointDependency.
func (e EndpointDependency) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", e.Description)
	populate(objectMap, "domainName", e.DomainName)
	populate(objectMap, "endpointDetails", e.EndpointDetails)
	return json.Marshal(objectMap)
}

// EndpointDetail - Details about the connection between the Batch service and the endpoint.
type EndpointDetail struct {
	// READ-ONLY; The port an endpoint is connected to.
	Port *int32 `json:"port,omitempty" azure:"ro"`
}

// EnvironmentSetting - An environment variable to be set on a task process.
type EnvironmentSetting struct {
	// REQUIRED; The name of the environment variable.
	Name *string `json:"name,omitempty"`

	// The value of the environment variable.
	Value *string `json:"value,omitempty"`
}

// FixedScaleSettings - Fixed scale settings for the pool.
type FixedScaleSettings struct {
	// If omitted, the default value is Requeue.
	NodeDeallocationOption *ComputeNodeDeallocationOption `json:"nodeDeallocationOption,omitempty"`

	// The default value is 15 minutes. Timeout values use ISO 8601 format. For example, use PT10M for 10 minutes. The minimum value is 5 minutes. If you specify
	// a value less than 5 minutes, the Batch
	// service rejects the request with an error; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).
	ResizeTimeout *string `json:"resizeTimeout,omitempty"`

	// At least one of targetDedicatedNodes, targetLowPriorityNodes must be set.
	TargetDedicatedNodes *int32 `json:"targetDedicatedNodes,omitempty"`

	// At least one of targetDedicatedNodes, targetLowPriorityNodes must be set.
	TargetLowPriorityNodes *int32 `json:"targetLowPriorityNodes,omitempty"`
}

// ImageReference - A reference to an Azure Virtual Machines Marketplace image or the Azure Image resource of a custom Virtual Machine. To get the list
// of all imageReferences verified by Azure Batch, see the 'List
// supported node agent SKUs' operation.
type ImageReference struct {
	// This property is mutually exclusive with other properties. The Shared Image Gallery image must have replicas in the same region as the Azure Batch account.
	// For information about the firewall settings
	// for the Batch node agent to communicate with the Batch service see https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
	ID *string `json:"id,omitempty"`

	// For example, UbuntuServer or WindowsServer.
	Offer *string `json:"offer,omitempty"`

	// For example, Canonical or MicrosoftWindowsServer.
	Publisher *string `json:"publisher,omitempty"`

	// For example, 18.04-LTS or 2019-Datacenter.
	SKU *string `json:"sku,omitempty"`

	// A value of 'latest' can be specified to select the latest version of an image. If omitted, the default is 'latest'.
	Version *string `json:"version,omitempty"`
}

// InboundNatPool - A inbound NAT pool that can be used to address specific ports on compute nodes in a Batch pool externally.
type InboundNatPool struct {
	// REQUIRED; This must be unique within a Batch pool. Acceptable values are between 1 and 65535 except for 22, 3389, 29876 and 29877 as these are reserved.
	// If any reserved values are provided the request fails
	// with HTTP status code 400.
	BackendPort *int32 `json:"backendPort,omitempty"`

	// REQUIRED; Acceptable values range between 1 and 65534 except ports from 50000 to 55000 which are reserved by the Batch service. All ranges within a pool
	// must be distinct and cannot overlap. If any reserved or
	// overlapping values are provided the request fails with HTTP status code 400.
	FrontendPortRangeEnd *int32 `json:"frontendPortRangeEnd,omitempty"`

	// REQUIRED; Acceptable values range between 1 and 65534 except ports from 50000 to 55000 which are reserved. All ranges within a pool must be distinct
	// and cannot overlap. If any reserved or overlapping values are
	// provided the request fails with HTTP status code 400.
	FrontendPortRangeStart *int32 `json:"frontendPortRangeStart,omitempty"`

	// REQUIRED; The name must be unique within a Batch pool, can contain letters, numbers, underscores, periods, and hyphens. Names must start with a letter
	// or number, must end with a letter, number, or underscore,
	// and cannot exceed 77 characters. If any invalid values are provided the request fails with HTTP status code 400.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The protocol of the endpoint.
	Protocol *InboundEndpointProtocol `json:"protocol,omitempty"`

	// The maximum number of rules that can be specified across all the endpoints on a Batch pool is 25. If no network security group rules are specified, a
	// default rule will be created to allow inbound
	// access to the specified backendPort. If the maximum number of network security group rules is exceeded the request fails with HTTP status code 400.
	NetworkSecurityGroupRules []*NetworkSecurityGroupRule `json:"networkSecurityGroupRules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type InboundNatPool.
func (i InboundNatPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backendPort", i.BackendPort)
	populate(objectMap, "frontendPortRangeEnd", i.FrontendPortRangeEnd)
	populate(objectMap, "frontendPortRangeStart", i.FrontendPortRangeStart)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "networkSecurityGroupRules", i.NetworkSecurityGroupRules)
	populate(objectMap, "protocol", i.Protocol)
	return json.Marshal(objectMap)
}

// KeyVaultProperties - KeyVault configuration when using an encryption KeySource of Microsoft.KeyVault.
type KeyVaultProperties struct {
	// Full path to the versioned secret. Example https://mykeyvault.vault.azure.net/keys/testkey/6e34a81fef704045975661e297a4c053. To be usable the following
	// prerequisites must be met:
	// The Batch Account has a System Assigned identity The account identity has been granted Key/Get, Key/Unwrap and Key/Wrap permissions The KeyVault has
	// soft-delete and purge protection enabled
	KeyIdentifier *string `json:"keyIdentifier,omitempty"`
}

// KeyVaultReference - Identifies the Azure key vault associated with a Batch account.
type KeyVaultReference struct {
	// REQUIRED; The resource ID of the Azure key vault associated with the Batch account.
	ID *string `json:"id,omitempty"`

	// REQUIRED; The URL of the Azure key vault associated with the Batch account.
	URL *string `json:"url,omitempty"`
}

// LinuxUserConfiguration - Properties used to create a user account on a Linux node.
type LinuxUserConfiguration struct {
	// The uid and gid properties must be specified together or not at all. If not specified the underlying operating system picks the gid.
	Gid *int32 `json:"gid,omitempty"`

	// The private key must not be password protected. The private key is used to automatically configure asymmetric-key based authentication for SSH between
	// nodes in a Linux pool when the pool's
	// enableInterNodeCommunication property is true (it is ignored if enableInterNodeCommunication is false). It does this by placing the key pair into the
	// user's .ssh directory. If not specified,
	// password-less SSH is not configured between nodes (no modification of the user's .ssh directory is done).
	SSHPrivateKey *string `json:"sshPrivateKey,omitempty"`

	// The uid and gid properties must be specified together or not at all. If not specified the underlying operating system picks the uid.
	UID *int32 `json:"uid,omitempty"`
}

// ListApplicationPackagesResult - The result of performing list application packages.
type ListApplicationPackagesResult struct {
	// The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of application packages.
	Value []*ApplicationPackage `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListApplicationPackagesResult.
func (l ListApplicationPackagesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// ListApplicationsResult - The result of performing list applications.
type ListApplicationsResult struct {
	// The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of applications.
	Value []*Application `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListApplicationsResult.
func (l ListApplicationsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// ListCertificatesResult - Values returned by the List operation.
type ListCertificatesResult struct {
	// The continuation token.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection of returned certificates.
	Value []*Certificate `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListCertificatesResult.
func (l ListCertificatesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// ListPoolsResult - Values returned by the List operation.
type ListPoolsResult struct {
	// The continuation token.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection of returned pools.
	Value []*Pool `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListPoolsResult.
func (l ListPoolsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// ListPrivateEndpointConnectionsResult - Values returned by the List operation.
type ListPrivateEndpointConnectionsResult struct {
	// The continuation token.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection of returned private endpoint connection.
	Value []*PrivateEndpointConnection `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListPrivateEndpointConnectionsResult.
func (l ListPrivateEndpointConnectionsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// ListPrivateLinkResourcesResult - Values returned by the List operation.
type ListPrivateLinkResourcesResult struct {
	// The continuation token.
	NextLink *string `json:"nextLink,omitempty"`

	// The collection of returned private link resources.
	Value []*PrivateLinkResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListPrivateLinkResourcesResult.
func (l ListPrivateLinkResourcesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LocationCheckNameAvailabilityOptions contains the optional parameters for the Location.CheckNameAvailability method.
type LocationCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// LocationGetQuotasOptions contains the optional parameters for the Location.GetQuotas method.
type LocationGetQuotasOptions struct {
	// placeholder for future optional parameters
}

// LocationListSupportedCloudServiceSKUsOptions contains the optional parameters for the Location.ListSupportedCloudServiceSKUs method.
type LocationListSupportedCloudServiceSKUsOptions struct {
	// OData filter expression. Valid properties for filtering are "familyName".
	Filter *string
	// The maximum number of items to return in the response.
	Maxresults *int32
}

// LocationListSupportedVirtualMachineSKUsOptions contains the optional parameters for the Location.ListSupportedVirtualMachineSKUs method.
type LocationListSupportedVirtualMachineSKUsOptions struct {
	// OData filter expression. Valid properties for filtering are "familyName".
	Filter *string
	// The maximum number of items to return in the response.
	Maxresults *int32
}

// MetadataItem - The Batch service does not assign any meaning to this metadata; it is solely for the use of user code.
type MetadataItem struct {
	// REQUIRED; The name of the metadata item.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The value of the metadata item.
	Value *string `json:"value,omitempty"`
}

// MountConfiguration - The file system to mount on each node.
type MountConfiguration struct {
	// This property is mutually exclusive with all other properties.
	AzureBlobFileSystemConfiguration *AzureBlobFileSystemConfiguration `json:"azureBlobFileSystemConfiguration,omitempty"`

	// This property is mutually exclusive with all other properties.
	AzureFileShareConfiguration *AzureFileShareConfiguration `json:"azureFileShareConfiguration,omitempty"`

	// This property is mutually exclusive with all other properties.
	CifsMountConfiguration *CIFSMountConfiguration `json:"cifsMountConfiguration,omitempty"`

	// This property is mutually exclusive with all other properties.
	NfsMountConfiguration *NFSMountConfiguration `json:"nfsMountConfiguration,omitempty"`
}

// NFSMountConfiguration - Information used to connect to an NFS file system.
type NFSMountConfiguration struct {
	// REQUIRED; All file systems are mounted relative to the Batch mounts directory, accessible via the AZBATCHNODEMOUNTSDIR environment variable.
	RelativeMountPath *string `json:"relativeMountPath,omitempty"`

	// REQUIRED; The URI of the file system to mount.
	Source *string `json:"source,omitempty"`

	// These are 'net use' options in Windows and 'mount' options in Linux.
	MountOptions *string `json:"mountOptions,omitempty"`
}

// NetworkConfiguration - The network configuration for a pool.
type NetworkConfiguration struct {
	// Pool endpoint configuration is only supported on pools with the virtualMachineConfiguration property.
	EndpointConfiguration *PoolEndpointConfiguration `json:"endpointConfiguration,omitempty"`

	// This property is only supported on Pools with the virtualMachineConfiguration property.
	PublicIPAddressConfiguration *PublicIPAddressConfiguration `json:"publicIPAddressConfiguration,omitempty"`

	// The virtual network must be in the same region and subscription as the Azure Batch account. The specified subnet should have enough free IP addresses
	// to accommodate the number of nodes in the pool. If
	// the subnet doesn't have enough free IP addresses, the pool will partially allocate compute nodes and a resize error will occur. The 'MicrosoftAzureBatch'
	// service principal must have the 'Classic
	// Virtual Machine Contributor' Role-Based Access Control (RBAC) role for the specified VNet. The specified subnet must allow communication from the Azure
	// Batch service to be able to schedule tasks on
	// the compute nodes. This can be verified by checking if the specified VNet has any associated Network Security Groups (NSG). If communication to the compute
	// nodes in the specified subnet is denied by
	// an NSG, then the Batch service will set the state of the compute nodes to unusable. If the specified VNet has any associated Network Security Groups
	// (NSG), then a few reserved system ports must be
	// enabled for inbound communication. For pools created with a virtual machine configuration, enable ports 29876 and 29877, as well as port 22 for Linux
	// and port 3389 for Windows. For pools created with
	// a cloud service configuration, enable ports 10100, 20100, and 30100. Also enable outbound connections to Azure Storage on port 443. For cloudServiceConfiguration
	// pools, only 'classic' VNETs are
	// supported. For more details see: https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
	SubnetID *string `json:"subnetId,omitempty"`
}

// NetworkSecurityGroupRule - A network security group rule to apply to an inbound endpoint.
type NetworkSecurityGroupRule struct {
	// REQUIRED; The action that should be taken for a specified IP address, subnet range or tag.
	Access *NetworkSecurityGroupRuleAccess `json:"access,omitempty"`

	// REQUIRED; Priorities within a pool must be unique and are evaluated in order of priority. The lower the number the higher the priority. For example,
	// rules could be specified with order numbers of 150, 250, and
	// 350. The rule with the order number of 150 takes precedence over the rule that has an order of 250. Allowed priorities are 150 to 4096. If any reserved
	// or duplicate values are provided the request
	// fails with HTTP status code 400.
	Priority *int32 `json:"priority,omitempty"`

	// REQUIRED; Valid values are a single IP address (i.e. 10.10.10.10), IP subnet (i.e. 192.168.1.0/24), default tag, or * (for all addresses). If any other
	// values are provided the request fails with HTTP status
	// code 400.
	SourceAddressPrefix *string `json:"sourceAddressPrefix,omitempty"`

	// Valid values are '*' (for all ports 0 - 65535) or arrays of ports or port ranges (i.e. 100-200). The ports should in the range of 0 to 65535 and the
	// port ranges or ports can't overlap. If any other
	// values are provided the request fails with HTTP status code 400. Default value will be *.
	SourcePortRanges []*string `json:"sourcePortRanges,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkSecurityGroupRule.
func (n NetworkSecurityGroupRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "access", n.Access)
	populate(objectMap, "priority", n.Priority)
	populate(objectMap, "sourceAddressPrefix", n.SourceAddressPrefix)
	populate(objectMap, "sourcePortRanges", n.SourcePortRanges)
	return json.Marshal(objectMap)
}

// NodePlacementConfiguration - Allocation configuration used by Batch Service to provision the nodes.
type NodePlacementConfiguration struct {
	// Allocation policy used by Batch Service to provision the nodes. If not specified, Batch will use the regional policy.
	Policy *NodePlacementPolicyType `json:"policy,omitempty"`
}

// OSDisk - Settings for the operating system disk of the virtual machine.
type OSDisk struct {
	// Specifies the ephemeral Disk Settings for the operating system disk used by the virtual machine.
	EphemeralOSDiskSettings *DiffDiskSettings `json:"ephemeralOSDiskSettings,omitempty"`
}

// Operation - A REST API operation
type Operation struct {
	// The object that describes the operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty"`

	// This is of the format {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty"`

	// The intended executor of the operation.
	Origin *string `json:"origin,omitempty"`

	// Any object
	Properties map[string]interface{} `json:"properties,omitempty"`
}

// OperationDisplay - The object that describes the operation.
type OperationDisplay struct {
	// The friendly name of the operation
	Description *string `json:"description,omitempty"`

	// For example: read, write, delete, or listKeys/action
	Operation *string `json:"operation,omitempty"`

	// Friendly name of the resource provider.
	Provider *string `json:"provider,omitempty"`

	// The resource type on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
}

// OperationListResult - Result of the request to list REST API operations. It contains a list of operations and a URL nextLink to get the next set of results.
type OperationListResult struct {
	// The URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`

	// The list of operations supported by the resource provider.
	Value []*Operation `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// OutboundEnvironmentEndpoint - A collection of related endpoints from the same service for which the Batch service requires outbound access.
type OutboundEnvironmentEndpoint struct {
	// READ-ONLY; The type of service that the Batch service connects to.
	Category *string `json:"category,omitempty" azure:"ro"`

	// READ-ONLY; The endpoints for this service to which the Batch service makes outbound calls.
	Endpoints []*EndpointDependency `json:"endpoints,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OutboundEnvironmentEndpoint.
func (o OutboundEnvironmentEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", o.Category)
	populate(objectMap, "endpoints", o.Endpoints)
	return json.Marshal(objectMap)
}

// OutboundEnvironmentEndpointCollection - Values returned by the List operation.
type OutboundEnvironmentEndpointCollection struct {
	// The continuation token.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; The collection of outbound network dependency endpoints returned by the listing operation.
	Value []*OutboundEnvironmentEndpoint `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OutboundEnvironmentEndpointCollection.
func (o OutboundEnvironmentEndpointCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// Pool - Contains information about a pool.
type Pool struct {
	ProxyResource
	// The type of identity used for the Batch Pool.
	Identity *BatchPoolIdentity `json:"identity,omitempty"`

	// The properties associated with the pool.
	Properties *PoolProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Pool.
func (p Pool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// PoolBeginDeleteOptions contains the optional parameters for the Pool.BeginDelete method.
type PoolBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// PoolCreateOptions contains the optional parameters for the Pool.Create method.
type PoolCreateOptions struct {
	// The entity state (ETag) version of the pool to update. A value of "*" can be used to apply the operation only if the pool already exists. If omitted,
	// this operation will always be applied.
	IfMatch *string
	// Set to '*' to allow a new pool to be created, but to prevent updating an existing pool. Other values will be ignored.
	IfNoneMatch *string
}

// PoolDisableAutoScaleOptions contains the optional parameters for the Pool.DisableAutoScale method.
type PoolDisableAutoScaleOptions struct {
	// placeholder for future optional parameters
}

// PoolEndpointConfiguration - The endpoint configuration for a pool.
type PoolEndpointConfiguration struct {
	// REQUIRED; The maximum number of inbound NAT pools per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded the request fails with
	// HTTP status code 400. This cannot be specified if the
	// IPAddressProvisioningType is NoPublicIPAddresses.
	InboundNatPools []*InboundNatPool `json:"inboundNatPools,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PoolEndpointConfiguration.
func (p PoolEndpointConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "inboundNatPools", p.InboundNatPools)
	return json.Marshal(objectMap)
}

// PoolGetOptions contains the optional parameters for the Pool.Get method.
type PoolGetOptions struct {
	// placeholder for future optional parameters
}

// PoolListByBatchAccountOptions contains the optional parameters for the Pool.ListByBatchAccount method.
type PoolListByBatchAccountOptions struct {
	// OData filter expression. Valid properties for filtering are:
	// name
	// properties/allocationState
	// properties/allocationStateTransitionTime
	// properties/creationTime
	// properties/provisioningState
	// properties/provisioningStateTransitionTime
	// properties/lastModified
	// properties/vmSize
	// properties/interNodeCommunication
	// properties/scaleSettings/autoScale
	// properties/scaleSettings/fixedScale
	Filter *string
	// The maximum number of items to return in the response.
	Maxresults *int32
	// Comma separated list of properties that should be returned. e.g. "properties/provisioningState". Only top level properties under properties/ are valid
	// for selection.
	Select *string
}

// PoolProperties - Pool properties.
type PoolProperties struct {
	// The list of application licenses must be a subset of available Batch service application licenses. If a license is requested which is not supported,
	// pool creation will fail.
	ApplicationLicenses []*string `json:"applicationLicenses,omitempty"`

	// Changes to application package references affect all new compute nodes joining the pool, but do not affect compute nodes that are already in the pool
	// until they are rebooted or reimaged. There is a
	// maximum of 10 application package references on any given pool.
	ApplicationPackages []*ApplicationPackageReference `json:"applicationPackages,omitempty"`

	// For Windows compute nodes, the Batch service installs the certificates to the specified certificate store and location. For Linux compute nodes, the
	// certificates are stored in a directory inside the
	// task working directory and an environment variable AZBATCHCERTIFICATES_DIR is supplied to the task to query for this location. For certificates with
	// visibility of 'remoteUser', a 'certs' directory is
	// created in the user's home directory (e.g., /home/{user-name}/certs) and certificates are placed in that directory.
	Certificates []*CertificateReference `json:"certificates,omitempty"`

	// Using CloudServiceConfiguration specifies that the nodes should be creating using Azure Cloud Services (PaaS), while VirtualMachineConfiguration uses
	// Azure Virtual Machines (IaaS).
	DeploymentConfiguration *DeploymentConfiguration `json:"deploymentConfiguration,omitempty"`

	// The display name need not be unique and can contain any Unicode characters up to a maximum length of 1024.
	DisplayName *string `json:"displayName,omitempty"`

	// This imposes restrictions on which nodes can be assigned to the pool. Enabling this value can reduce the chance of the requested number of nodes to be
	// allocated in the pool. If not specified, this
	// value defaults to 'Disabled'.
	InterNodeCommunication *InterNodeCommunicationState `json:"interNodeCommunication,omitempty"`

	// The Batch service does not assign any meaning to metadata; it is solely for the use of user code.
	Metadata []*MetadataItem `json:"metadata,omitempty"`

	// This supports Azure Files, NFS, CIFS/SMB, and Blobfuse.
	MountConfiguration []*MountConfiguration `json:"mountConfiguration,omitempty"`

	// The network configuration for a pool.
	NetworkConfiguration *NetworkConfiguration `json:"networkConfiguration,omitempty"`

	// Defines the desired size of the pool. This can either be 'fixedScale' where the requested targetDedicatedNodes is specified, or 'autoScale' which defines
	// a formula which is periodically reevaluated.
	// If this property is not specified, the pool will have a fixed scale with 0 targetDedicatedNodes.
	ScaleSettings *ScaleSettings `json:"scaleSettings,omitempty"`

	// In an PATCH (update) operation, this property can be set to an empty object to remove the start task from the pool.
	StartTask *StartTask `json:"startTask,omitempty"`

	// If not specified, the default is spread.
	TaskSchedulingPolicy *TaskSchedulingPolicy `json:"taskSchedulingPolicy,omitempty"`

	// The default value is 1. The maximum value is the smaller of 4 times the number of cores of the vmSize of the pool or 256.
	TaskSlotsPerNode *int32 `json:"taskSlotsPerNode,omitempty"`

	// The list of user accounts to be created on each node in the pool.
	UserAccounts []*UserAccount `json:"userAccounts,omitempty"`

	// For information about available sizes of virtual machines for Cloud Services pools (pools created with cloudServiceConfiguration), see Sizes for Cloud
	// Services
	// (https://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/). Batch supports all Cloud Services VM sizes except ExtraSmall. For information
	// about available VM sizes for pools using
	// images from the Virtual Machines Marketplace (pools created with virtualMachineConfiguration) see Sizes for Virtual Machines (Linux)
	// (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/) or Sizes for Virtual Machines (Windows)
	// (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/). Batch supports all Azure VM sizes except STANDARDA0 and those with
	// premium storage (STANDARDGS, STANDARDDS, and
	// STANDARDDSV2 series).
	VMSize *string `json:"vmSize,omitempty"`

	// READ-ONLY; Whether the pool is resizing.
	AllocationState *AllocationState `json:"allocationState,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the pool entered its current allocation state.
	AllocationStateTransitionTime *time.Time `json:"allocationStateTransitionTime,omitempty" azure:"ro"`

	// READ-ONLY; This property is set only if the pool automatically scales, i.e. autoScaleSettings are used.
	AutoScaleRun *AutoScaleRun `json:"autoScaleRun,omitempty" azure:"ro"`

	// READ-ONLY; The creation time of the pool.
	CreationTime *time.Time `json:"creationTime,omitempty" azure:"ro"`

	// READ-ONLY; The number of compute nodes currently in the pool.
	CurrentDedicatedNodes *int32 `json:"currentDedicatedNodes,omitempty" azure:"ro"`

	// READ-ONLY; The number of low-priority compute nodes currently in the pool.
	CurrentLowPriorityNodes *int32 `json:"currentLowPriorityNodes,omitempty" azure:"ro"`

	// READ-ONLY; This is the last time at which the pool level data, such as the targetDedicatedNodes or autoScaleSettings, changed. It does not factor in
	// node-level changes such as a compute node changing state.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The current state of the pool.
	ProvisioningState *PoolProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the pool entered its current state.
	ProvisioningStateTransitionTime *time.Time `json:"provisioningStateTransitionTime,omitempty" azure:"ro"`

	// READ-ONLY; Describes either the current operation (if the pool AllocationState is Resizing) or the previously completed operation (if the AllocationState
	// is Steady).
	ResizeOperationStatus *ResizeOperationStatus `json:"resizeOperationStatus,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PoolProperties.
func (p PoolProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allocationState", p.AllocationState)
	populateTimeRFC3339(objectMap, "allocationStateTransitionTime", p.AllocationStateTransitionTime)
	populate(objectMap, "applicationLicenses", p.ApplicationLicenses)
	populate(objectMap, "applicationPackages", p.ApplicationPackages)
	populate(objectMap, "autoScaleRun", p.AutoScaleRun)
	populate(objectMap, "certificates", p.Certificates)
	populateTimeRFC3339(objectMap, "creationTime", p.CreationTime)
	populate(objectMap, "currentDedicatedNodes", p.CurrentDedicatedNodes)
	populate(objectMap, "currentLowPriorityNodes", p.CurrentLowPriorityNodes)
	populate(objectMap, "deploymentConfiguration", p.DeploymentConfiguration)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "interNodeCommunication", p.InterNodeCommunication)
	populateTimeRFC3339(objectMap, "lastModified", p.LastModified)
	populate(objectMap, "metadata", p.Metadata)
	populate(objectMap, "mountConfiguration", p.MountConfiguration)
	populate(objectMap, "networkConfiguration", p.NetworkConfiguration)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populateTimeRFC3339(objectMap, "provisioningStateTransitionTime", p.ProvisioningStateTransitionTime)
	populate(objectMap, "resizeOperationStatus", p.ResizeOperationStatus)
	populate(objectMap, "scaleSettings", p.ScaleSettings)
	populate(objectMap, "startTask", p.StartTask)
	populate(objectMap, "taskSchedulingPolicy", p.TaskSchedulingPolicy)
	populate(objectMap, "taskSlotsPerNode", p.TaskSlotsPerNode)
	populate(objectMap, "userAccounts", p.UserAccounts)
	populate(objectMap, "vmSize", p.VMSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PoolProperties.
func (p *PoolProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allocationState":
			err = unpopulate(val, &p.AllocationState)
			delete(rawMsg, key)
		case "allocationStateTransitionTime":
			err = unpopulateTimeRFC3339(val, &p.AllocationStateTransitionTime)
			delete(rawMsg, key)
		case "applicationLicenses":
			err = unpopulate(val, &p.ApplicationLicenses)
			delete(rawMsg, key)
		case "applicationPackages":
			err = unpopulate(val, &p.ApplicationPackages)
			delete(rawMsg, key)
		case "autoScaleRun":
			err = unpopulate(val, &p.AutoScaleRun)
			delete(rawMsg, key)
		case "certificates":
			err = unpopulate(val, &p.Certificates)
			delete(rawMsg, key)
		case "creationTime":
			err = unpopulateTimeRFC3339(val, &p.CreationTime)
			delete(rawMsg, key)
		case "currentDedicatedNodes":
			err = unpopulate(val, &p.CurrentDedicatedNodes)
			delete(rawMsg, key)
		case "currentLowPriorityNodes":
			err = unpopulate(val, &p.CurrentLowPriorityNodes)
			delete(rawMsg, key)
		case "deploymentConfiguration":
			err = unpopulate(val, &p.DeploymentConfiguration)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &p.DisplayName)
			delete(rawMsg, key)
		case "interNodeCommunication":
			err = unpopulate(val, &p.InterNodeCommunication)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &p.LastModified)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, &p.Metadata)
			delete(rawMsg, key)
		case "mountConfiguration":
			err = unpopulate(val, &p.MountConfiguration)
			delete(rawMsg, key)
		case "networkConfiguration":
			err = unpopulate(val, &p.NetworkConfiguration)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &p.ProvisioningState)
			delete(rawMsg, key)
		case "provisioningStateTransitionTime":
			err = unpopulateTimeRFC3339(val, &p.ProvisioningStateTransitionTime)
			delete(rawMsg, key)
		case "resizeOperationStatus":
			err = unpopulate(val, &p.ResizeOperationStatus)
			delete(rawMsg, key)
		case "scaleSettings":
			err = unpopulate(val, &p.ScaleSettings)
			delete(rawMsg, key)
		case "startTask":
			err = unpopulate(val, &p.StartTask)
			delete(rawMsg, key)
		case "taskSchedulingPolicy":
			err = unpopulate(val, &p.TaskSchedulingPolicy)
			delete(rawMsg, key)
		case "taskSlotsPerNode":
			err = unpopulate(val, &p.TaskSlotsPerNode)
			delete(rawMsg, key)
		case "userAccounts":
			err = unpopulate(val, &p.UserAccounts)
			delete(rawMsg, key)
		case "vmSize":
			err = unpopulate(val, &p.VMSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PoolStopResizeOptions contains the optional parameters for the Pool.StopResize method.
type PoolStopResizeOptions struct {
	// placeholder for future optional parameters
}

// PoolUpdateOptions contains the optional parameters for the Pool.Update method.
type PoolUpdateOptions struct {
	// The entity state (ETag) version of the pool to update. This value can be omitted or set to "*" to apply the operation unconditionally.
	IfMatch *string
}

// PrivateEndpoint - The private endpoint of the private endpoint connection.
type PrivateEndpoint struct {
	// READ-ONLY; The ARM resource identifier of the private endpoint. This is of the form /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/privateEndpoints/{privateEndpoint}.
	ID *string `json:"id,omitempty" azure:"ro"`
}

// PrivateEndpointConnection - Contains information about a private link resource.
type PrivateEndpointConnection struct {
	ProxyResource
	// The properties associated with the private endpoint connection.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnection.
func (p PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionBeginUpdateOptions contains the optional parameters for the PrivateEndpointConnection.BeginUpdate method.
type PrivateEndpointConnectionBeginUpdateOptions struct {
	// The state (ETag) version of the private endpoint connection to update. This value can be omitted or set to "*" to apply the operation unconditionally.
	IfMatch *string
}

// PrivateEndpointConnectionGetOptions contains the optional parameters for the PrivateEndpointConnection.Get method.
type PrivateEndpointConnectionGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionListByBatchAccountOptions contains the optional parameters for the PrivateEndpointConnection.ListByBatchAccount method.
type PrivateEndpointConnectionListByBatchAccountOptions struct {
	// The maximum number of items to return in the response.
	Maxresults *int32
}

// PrivateEndpointConnectionProperties - Private endpoint connection properties.
type PrivateEndpointConnectionProperties struct {
	// The private endpoint of the private endpoint connection.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// The private link service connection state of the private endpoint connection
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// READ-ONLY; The provisioning state of the private endpoint connection.
	ProvisioningState *PrivateEndpointConnectionProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// PrivateLinkResource - Contains information about a private link resource.
type PrivateLinkResource struct {
	ProxyResource
	// The properties associated with the private link resource.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResource.
func (p PrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// PrivateLinkResourceGetOptions contains the optional parameters for the PrivateLinkResource.Get method.
type PrivateLinkResourceGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResourceListByBatchAccountOptions contains the optional parameters for the PrivateLinkResource.ListByBatchAccount method.
type PrivateLinkResourceListByBatchAccountOptions struct {
	// The maximum number of items to return in the response.
	Maxresults *int32
}

// PrivateLinkResourceProperties - Private link resource properties.
type PrivateLinkResourceProperties struct {
	// READ-ONLY; The group id is used to establish the private link connection.
	GroupID *string `json:"groupId,omitempty" azure:"ro"`

	// READ-ONLY; The list of required members that are used to establish the private link connection.
	RequiredMembers []*string `json:"requiredMembers,omitempty" azure:"ro"`

	// READ-ONLY; The list of required zone names for the private DNS resource name
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkServiceConnectionState - The private link service connection state of the private endpoint connection
type PrivateLinkServiceConnectionState struct {
	// REQUIRED; The status of the Batch private endpoint connection
	Status *PrivateLinkServiceConnectionStatus `json:"status,omitempty"`

	// Description of the private Connection state
	Description *string `json:"description,omitempty"`

	// READ-ONLY; Action required on the private connection state
	ActionRequired *string `json:"actionRequired,omitempty" azure:"ro"`
}

// ProxyResource - A definition of an Azure resource.
type ProxyResource struct {
	// READ-ONLY; The ETag of the resource, used for concurrency statements.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; The ID of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProxyResource.
func (p ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (p ProxyResource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "type", p.Type)
}

// PublicIPAddressConfiguration - The public IP Address configuration of the networking configuration of a Pool.
type PublicIPAddressConfiguration struct {
	// The number of IPs specified here limits the maximum size of the Pool - 100 dedicated nodes or 100 low-priority nodes can be allocated for each public
	// IP. For example, a pool needing 250 dedicated VMs
	// would need at least 3 public IPs specified. Each element of this collection is of the form: /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
	IPAddressIDs []*string `json:"ipAddressIds,omitempty"`

	// The default value is BatchManaged
	Provision *IPAddressProvisioningType `json:"provision,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PublicIPAddressConfiguration.
func (p PublicIPAddressConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "ipAddressIds", p.IPAddressIDs)
	populate(objectMap, "provision", p.Provision)
	return json.Marshal(objectMap)
}

// ResizeError - An error that occurred when resizing a pool.
type ResizeError struct {
	// REQUIRED; An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// REQUIRED; A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`

	// Additional details about the error.
	Details []*ResizeError `json:"details,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResizeError.
func (r ResizeError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", r.Code)
	populate(objectMap, "details", r.Details)
	populate(objectMap, "message", r.Message)
	return json.Marshal(objectMap)
}

// ResizeOperationStatus - Describes either the current operation (if the pool AllocationState is Resizing) or the previously completed operation (if the
// AllocationState is Steady).
type ResizeOperationStatus struct {
	// This property is set only if an error occurred during the last pool resize, and only when the pool allocationState is Steady.
	Errors []*ResizeError `json:"errors,omitempty"`

	// The default value is requeue.
	NodeDeallocationOption *ComputeNodeDeallocationOption `json:"nodeDeallocationOption,omitempty"`

	// The default value is 15 minutes. The minimum value is 5 minutes. If you specify a value less than 5 minutes, the Batch service returns an error; if you
	// are calling the REST API directly, the HTTP
	// status code is 400 (Bad Request).
	ResizeTimeout *string `json:"resizeTimeout,omitempty"`

	// The time when this resize operation was started.
	StartTime *time.Time `json:"startTime,omitempty"`

	// The desired number of dedicated compute nodes in the pool.
	TargetDedicatedNodes *int32 `json:"targetDedicatedNodes,omitempty"`

	// The desired number of low-priority compute nodes in the pool.
	TargetLowPriorityNodes *int32 `json:"targetLowPriorityNodes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResizeOperationStatus.
func (r ResizeOperationStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errors", r.Errors)
	populate(objectMap, "nodeDeallocationOption", r.NodeDeallocationOption)
	populate(objectMap, "resizeTimeout", r.ResizeTimeout)
	populateTimeRFC3339(objectMap, "startTime", r.StartTime)
	populate(objectMap, "targetDedicatedNodes", r.TargetDedicatedNodes)
	populate(objectMap, "targetLowPriorityNodes", r.TargetLowPriorityNodes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResizeOperationStatus.
func (r *ResizeOperationStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
			err = unpopulate(val, &r.Errors)
			delete(rawMsg, key)
		case "nodeDeallocationOption":
			err = unpopulate(val, &r.NodeDeallocationOption)
			delete(rawMsg, key)
		case "resizeTimeout":
			err = unpopulate(val, &r.ResizeTimeout)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &r.StartTime)
			delete(rawMsg, key)
		case "targetDedicatedNodes":
			err = unpopulate(val, &r.TargetDedicatedNodes)
			delete(rawMsg, key)
		case "targetLowPriorityNodes":
			err = unpopulate(val, &r.TargetLowPriorityNodes)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Resource - A definition of an Azure resource.
type Resource struct {
	// READ-ONLY; The ID of the resource.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The location of the resource.
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The tags of the resource.
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
}

// ResourceFile - A single file or multiple files to be downloaded to a compute node.
type ResourceFile struct {
	// The autoStorageContainerName, storageContainerUrl and httpUrl properties are mutually exclusive and one of them must be specified.
	AutoStorageContainerName *string `json:"autoStorageContainerName,omitempty"`

	// The property is valid only when autoStorageContainerName or storageContainerUrl is used. This prefix can be a partial filename or a subdirectory. If
	// a prefix is not specified, all the files in the
	// container will be downloaded.
	BlobPrefix *string `json:"blobPrefix,omitempty"`

	// This property applies only to files being downloaded to Linux compute nodes. It will be ignored if it is specified for a resourceFile which will be downloaded
	// to a Windows node. If this property is
	// not specified for a Linux node, then a default value of 0770 is applied to the file.
	FileMode *string `json:"fileMode,omitempty"`

	// If the httpUrl property is specified, the filePath is required and describes the path which the file will be downloaded to, including the filename. Otherwise,
	// if the autoStorageContainerName or
	// storageContainerUrl property is specified, filePath is optional and is the directory to download the files to. In the case where filePath is used as
	// a directory, any directory structure already
	// associated with the input data will be retained in full and appended to the specified filePath directory. The specified relative path cannot break out
	// of the task's working directory (for example by
	// using '..').
	FilePath *string `json:"filePath,omitempty"`

	// The autoStorageContainerName, storageContainerUrl and httpUrl properties are mutually exclusive and one of them must be specified. If the URL points
	// to Azure Blob Storage, it must be readable from
	// compute nodes. There are three ways to get such a URL for a blob in Azure storage: include a Shared Access Signature (SAS) granting read permissions
	// on the blob, use a managed identity with read
	// permission, or set the ACL for the blob or its container to allow public access.
	HTTPURL *string `json:"httpUrl,omitempty"`

	// The reference to a user assigned identity associated with the Batch pool which a compute node will use.
	IdentityReference *ComputeNodeIdentityReference `json:"identityReference,omitempty"`

	// The autoStorageContainerName, storageContainerUrl and httpUrl properties are mutually exclusive and one of them must be specified. This URL must be readable
	// and listable from compute nodes. There are
	// three ways to get such a URL for a container in Azure storage: include a Shared Access Signature (SAS) granting read and list permissions on the container,
	// use a managed identity with read and list
	// permissions, or set the ACL for the container to allow public access.
	StorageContainerURL *string `json:"storageContainerUrl,omitempty"`
}

// SKUCapability - A SKU capability, such as the number of cores.
type SKUCapability struct {
	// READ-ONLY; The name of the feature.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The value of the feature.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// ScaleSettings - Defines the desired size of the pool. This can either be 'fixedScale' where the requested targetDedicatedNodes is specified, or 'autoScale'
// which defines a formula which is periodically reevaluated.
// If this property is not specified, the pool will have a fixed scale with 0 targetDedicatedNodes.
type ScaleSettings struct {
	// This property and fixedScale are mutually exclusive and one of the properties must be specified.
	AutoScale *AutoScaleSettings `json:"autoScale,omitempty"`

	// This property and autoScale are mutually exclusive and one of the properties must be specified.
	FixedScale *FixedScaleSettings `json:"fixedScale,omitempty"`
}

// StartTask - In some cases the start task may be re-run even though the node was not rebooted. Due to this, start tasks should be idempotent and exit
// gracefully if the setup they're performing has already been
// done. Special care should be taken to avoid start tasks which create breakaway process or install/launch services from the start task working directory,
// as this will block Batch from being able to
// re-run the start task.
type StartTask struct {
	// The command line does not run under a shell, and therefore cannot take advantage of shell features such as environment variable expansion. If you want
	// to take advantage of such features, you should
	// invoke the shell in the command line, for example using "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. Required if any other properties
	// of the startTask are specified.
	CommandLine *string `json:"commandLine,omitempty"`

	// When this is specified, all directories recursively below the AZBATCHNODEROOTDIR (the root of Azure Batch directories on the node) are mapped into the
	// container, all task environment variables are
	// mapped into the container, and the task command line is executed in the container.
	ContainerSettings *TaskContainerSettings `json:"containerSettings,omitempty"`

	// A list of environment variable settings for the start task.
	EnvironmentSettings []*EnvironmentSetting `json:"environmentSettings,omitempty"`

	// The Batch service retries a task if its exit code is nonzero. Note that this value specifically controls the number of retries. The Batch service will
	// try the task once, and may then retry up to this
	// limit. For example, if the maximum retry count is 3, Batch tries the task up to 4 times (one initial try and 3 retries). If the maximum retry count is
	// 0, the Batch service does not retry the task. If
	// the maximum retry count is -1, the Batch service retries the task without limit.
	MaxTaskRetryCount *int32 `json:"maxTaskRetryCount,omitempty"`

	// A list of files that the Batch service will download to the compute node before running the command line.
	ResourceFiles []*ResourceFile `json:"resourceFiles,omitempty"`

	// If omitted, the task runs as a non-administrative user unique to the task.
	UserIdentity *UserIdentity `json:"userIdentity,omitempty"`

	// If true and the start task fails on a compute node, the Batch service retries the start task up to its maximum retry count (maxTaskRetryCount). If the
	// task has still not completed successfully after
	// all retries, then the Batch service marks the compute node unusable, and will not schedule tasks to it. This condition can be detected via the node state
	// and scheduling error detail. If false, the
	// Batch service will not wait for the start task to complete. In this case, other tasks can start executing on the compute node while the start task is
	// still running; and even if the start task fails,
	// new tasks will continue to be scheduled on the node. The default is true.
	WaitForSuccess *bool `json:"waitForSuccess,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StartTask.
func (s StartTask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "commandLine", s.CommandLine)
	populate(objectMap, "containerSettings", s.ContainerSettings)
	populate(objectMap, "environmentSettings", s.EnvironmentSettings)
	populate(objectMap, "maxTaskRetryCount", s.MaxTaskRetryCount)
	populate(objectMap, "resourceFiles", s.ResourceFiles)
	populate(objectMap, "userIdentity", s.UserIdentity)
	populate(objectMap, "waitForSuccess", s.WaitForSuccess)
	return json.Marshal(objectMap)
}

// SupportedSKU - Describes a Batch supported SKU.
type SupportedSKU struct {
	// READ-ONLY; A collection of capabilities which this SKU supports.
	Capabilities []*SKUCapability `json:"capabilities,omitempty" azure:"ro"`

	// READ-ONLY; The family name of the SKU.
	FamilyName *string `json:"familyName,omitempty" azure:"ro"`

	// READ-ONLY; The name of the SKU.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SupportedSKU.
func (s SupportedSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "capabilities", s.Capabilities)
	populate(objectMap, "familyName", s.FamilyName)
	populate(objectMap, "name", s.Name)
	return json.Marshal(objectMap)
}

// SupportedSKUsResult - The Batch List supported SKUs operation response.
type SupportedSKUsResult struct {
	// REQUIRED; The list of SKUs available for the Batch service in the location.
	Value []*SupportedSKU `json:"value,omitempty"`

	// READ-ONLY; The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SupportedSKUsResult.
func (s SupportedSKUsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// TaskContainerSettings - The container settings for a task.
type TaskContainerSettings struct {
	// REQUIRED; This is the full image reference, as would be specified to "docker pull". If no tag is provided as part of the image name, the tag ":latest"
	// is used as a default.
	ImageName *string `json:"imageName,omitempty"`

	// These additional options are supplied as arguments to the "docker create" command, in addition to those controlled by the Batch Service.
	ContainerRunOptions *string `json:"containerRunOptions,omitempty"`

	// This setting can be omitted if was already provided at pool creation.
	Registry *ContainerRegistry `json:"registry,omitempty"`

	// A flag to indicate where the container task working directory is. The default is 'taskWorkingDirectory'.
	WorkingDirectory *ContainerWorkingDirectory `json:"workingDirectory,omitempty"`
}

// TaskSchedulingPolicy - Specifies how tasks should be distributed across compute nodes.
type TaskSchedulingPolicy struct {
	// REQUIRED; How tasks should be distributed across compute nodes.
	NodeFillType *ComputeNodeFillType `json:"nodeFillType,omitempty"`
}

// UserAccount - Properties used to create a user on an Azure Batch node.
type UserAccount struct {
	// REQUIRED; The name of the user account.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The password for the user account.
	Password *string `json:"password,omitempty"`

	// nonAdmin - The auto user is a standard user without elevated access. admin - The auto user is a user with elevated access and operates with full Administrator
	// permissions. The default value is
	// nonAdmin.
	ElevationLevel *ElevationLevel `json:"elevationLevel,omitempty"`

	// This property is ignored if specified on a Windows pool. If not specified, the user is created with the default options.
	LinuxUserConfiguration *LinuxUserConfiguration `json:"linuxUserConfiguration,omitempty"`

	// This property can only be specified if the user is on a Windows pool. If not specified and on a Windows pool, the user is created with the default options.
	WindowsUserConfiguration *WindowsUserConfiguration `json:"windowsUserConfiguration,omitempty"`
}

// UserAssignedIdentities - The list of associated user identities.
type UserAssignedIdentities struct {
	// READ-ONLY; The client id of user assigned identity.
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// READ-ONLY; The principal id of user assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`
}

// UserIdentity - Specify either the userName or autoUser property, but not both.
type UserIdentity struct {
	// The userName and autoUser properties are mutually exclusive; you must specify one but not both.
	AutoUser *AutoUserSpecification `json:"autoUser,omitempty"`

	// The userName and autoUser properties are mutually exclusive; you must specify one but not both.
	UserName *string `json:"userName,omitempty"`
}

// VMExtension - The configuration for virtual machine extensions.
type VMExtension struct {
	// REQUIRED; The name of the virtual machine extension.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The name of the extension handler publisher.
	Publisher *string `json:"publisher,omitempty"`

	// REQUIRED; The type of the extensions.
	Type *string `json:"type,omitempty"`

	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not
	// upgrade minor versions unless redeployed, even
	// with this property set to true.
	AutoUpgradeMinorVersion *bool `json:"autoUpgradeMinorVersion,omitempty"`

	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings map[string]interface{} `json:"protectedSettings,omitempty"`

	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []*string `json:"provisionAfterExtensions,omitempty"`

	// Any object
	Settings map[string]interface{} `json:"settings,omitempty"`

	// The version of script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VMExtension.
func (v VMExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoUpgradeMinorVersion", v.AutoUpgradeMinorVersion)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "protectedSettings", v.ProtectedSettings)
	populate(objectMap, "provisionAfterExtensions", v.ProvisionAfterExtensions)
	populate(objectMap, "publisher", v.Publisher)
	populate(objectMap, "settings", v.Settings)
	populate(objectMap, "type", v.Type)
	populate(objectMap, "typeHandlerVersion", v.TypeHandlerVersion)
	return json.Marshal(objectMap)
}

// VirtualMachineConfiguration - The configuration for compute nodes in a pool based on the Azure Virtual Machines infrastructure.
type VirtualMachineConfiguration struct {
	// REQUIRED; A reference to an Azure Virtual Machines Marketplace image or the Azure Image resource of a custom Virtual Machine. To get the list of all
	// imageReferences verified by Azure Batch, see the 'List
	// supported node agent SKUs' operation.
	ImageReference *ImageReference `json:"imageReference,omitempty"`

	// REQUIRED; The Batch node agent is a program that runs on each node in the pool, and provides the command-and-control interface between the node and the
	// Batch service. There are different implementations of the
	// node agent, known as SKUs, for different operating systems. You must specify a node agent SKU which matches the selected image reference. To get the
	// list of supported node agent SKUs along with their
	// list of verified image references, see the 'List supported node agent SKUs' operation.
	NodeAgentSKUID *string `json:"nodeAgentSkuId,omitempty"`

	// If specified, setup is performed on each node in the pool to allow tasks to run in containers. All regular tasks and job manager tasks run on this pool
	// must specify the containerSettings property, and
	// all other tasks may specify it.
	ContainerConfiguration *ContainerConfiguration `json:"containerConfiguration,omitempty"`

	// This property must be specified if the compute nodes in the pool need to have empty data disks attached to them.
	DataDisks []*DataDisk `json:"dataDisks,omitempty"`

	// If specified, encryption is performed on each node in the pool during node provisioning.
	DiskEncryptionConfiguration *DiskEncryptionConfiguration `json:"diskEncryptionConfiguration,omitempty"`

	// If specified, the extensions mentioned in this configuration will be installed on each node.
	Extensions []*VMExtension `json:"extensions,omitempty"`

	// This only applies to images that contain the Windows operating system, and should only be used when you hold valid on-premises licenses for the nodes
	// which will be deployed. If omitted, no on-premises
	// licensing discount is applied. Values are:
	// WindowsServer - The on-premises license is for Windows Server. WindowsClient - The on-premises license is for Windows Client.
	LicenseType *string `json:"licenseType,omitempty"`

	// This configuration will specify rules on how nodes in the pool will be physically allocated.
	NodePlacementConfiguration *NodePlacementConfiguration `json:"nodePlacementConfiguration,omitempty"`

	// Contains configuration for ephemeral OSDisk settings.
	OSDisk *OSDisk `json:"osDisk,omitempty"`

	// This property must not be specified if the imageReference specifies a Linux OS image.
	WindowsConfiguration *WindowsConfiguration `json:"windowsConfiguration,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineConfiguration.
func (v VirtualMachineConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containerConfiguration", v.ContainerConfiguration)
	populate(objectMap, "dataDisks", v.DataDisks)
	populate(objectMap, "diskEncryptionConfiguration", v.DiskEncryptionConfiguration)
	populate(objectMap, "extensions", v.Extensions)
	populate(objectMap, "imageReference", v.ImageReference)
	populate(objectMap, "licenseType", v.LicenseType)
	populate(objectMap, "nodeAgentSkuId", v.NodeAgentSKUID)
	populate(objectMap, "nodePlacementConfiguration", v.NodePlacementConfiguration)
	populate(objectMap, "osDisk", v.OSDisk)
	populate(objectMap, "windowsConfiguration", v.WindowsConfiguration)
	return json.Marshal(objectMap)
}

// VirtualMachineFamilyCoreQuota - A VM Family and its associated core quota for the Batch account.
type VirtualMachineFamilyCoreQuota struct {
	// READ-ONLY; The core quota for the VM family for the Batch account.
	CoreQuota *int32 `json:"coreQuota,omitempty" azure:"ro"`

	// READ-ONLY; The Virtual Machine family name.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// WindowsConfiguration - Windows operating system settings to apply to the virtual machine.
type WindowsConfiguration struct {
	// If omitted, the default value is true.
	EnableAutomaticUpdates *bool `json:"enableAutomaticUpdates,omitempty"`
}

// WindowsUserConfiguration - Properties used to create a user account on a Windows node.
type WindowsUserConfiguration struct {
	// Specifies login mode for the user. The default value for VirtualMachineConfiguration pools is interactive mode and for CloudServiceConfiguration pools
	// is batch mode.
	LoginMode *LoginMode `json:"loginMode,omitempty"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
