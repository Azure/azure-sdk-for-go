//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armbilling

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strings"
)

// BillingRoleAssignmentsClient contains the methods for the BillingRoleAssignments group.
// Don't use this type directly, use NewBillingRoleAssignmentsClient() instead.
type BillingRoleAssignmentsClient struct {
	ep string
	pl runtime.Pipeline
}

// NewBillingRoleAssignmentsClient creates a new instance of BillingRoleAssignmentsClient with the specified values.
func NewBillingRoleAssignmentsClient(credential azcore.TokenCredential, options *arm.ClientOptions) *BillingRoleAssignmentsClient {
	cp := arm.ClientOptions{}
	if options != nil {
		cp = *options
	}
	if len(cp.Host) == 0 {
		cp.Host = arm.AzurePublicCloud
	}
	return &BillingRoleAssignmentsClient{ep: string(cp.Host), pl: armruntime.NewPipeline(module, version, credential, &cp)}
}

// DeleteByBillingAccount - Deletes a role assignment for the caller on a billing account. The operation is supported for billing accounts with agreement
// type Microsoft Partner Agreement or Microsoft Customer Agreement.
// If the operation fails it returns the *ErrorResponse error type.
func (client *BillingRoleAssignmentsClient) DeleteByBillingAccount(ctx context.Context, billingAccountName string, billingRoleAssignmentName string, options *BillingRoleAssignmentsDeleteByBillingAccountOptions) (BillingRoleAssignmentsDeleteByBillingAccountResponse, error) {
	req, err := client.deleteByBillingAccountCreateRequest(ctx, billingAccountName, billingRoleAssignmentName, options)
	if err != nil {
		return BillingRoleAssignmentsDeleteByBillingAccountResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return BillingRoleAssignmentsDeleteByBillingAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return BillingRoleAssignmentsDeleteByBillingAccountResponse{}, client.deleteByBillingAccountHandleError(resp)
	}
	return client.deleteByBillingAccountHandleResponse(resp)
}

// deleteByBillingAccountCreateRequest creates the DeleteByBillingAccount request.
func (client *BillingRoleAssignmentsClient) deleteByBillingAccountCreateRequest(ctx context.Context, billingAccountName string, billingRoleAssignmentName string, options *BillingRoleAssignmentsDeleteByBillingAccountOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingRoleAssignments/{billingRoleAssignmentName}"
	if billingAccountName == "" {
		return nil, errors.New("parameter billingAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingAccountName}", url.PathEscape(billingAccountName))
	if billingRoleAssignmentName == "" {
		return nil, errors.New("parameter billingRoleAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingRoleAssignmentName}", url.PathEscape(billingRoleAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteByBillingAccountHandleResponse handles the DeleteByBillingAccount response.
func (client *BillingRoleAssignmentsClient) deleteByBillingAccountHandleResponse(resp *http.Response) (BillingRoleAssignmentsDeleteByBillingAccountResponse, error) {
	result := BillingRoleAssignmentsDeleteByBillingAccountResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingRoleAssignment); err != nil {
		return BillingRoleAssignmentsDeleteByBillingAccountResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// deleteByBillingAccountHandleError handles the DeleteByBillingAccount error response.
func (client *BillingRoleAssignmentsClient) deleteByBillingAccountHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteByBillingProfile - Deletes a role assignment for the caller on a billing profile. The operation is supported for billing accounts with agreement
// type Microsoft Partner Agreement or Microsoft Customer Agreement.
// If the operation fails it returns the *ErrorResponse error type.
func (client *BillingRoleAssignmentsClient) DeleteByBillingProfile(ctx context.Context, billingAccountName string, billingProfileName string, billingRoleAssignmentName string, options *BillingRoleAssignmentsDeleteByBillingProfileOptions) (BillingRoleAssignmentsDeleteByBillingProfileResponse, error) {
	req, err := client.deleteByBillingProfileCreateRequest(ctx, billingAccountName, billingProfileName, billingRoleAssignmentName, options)
	if err != nil {
		return BillingRoleAssignmentsDeleteByBillingProfileResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return BillingRoleAssignmentsDeleteByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return BillingRoleAssignmentsDeleteByBillingProfileResponse{}, client.deleteByBillingProfileHandleError(resp)
	}
	return client.deleteByBillingProfileHandleResponse(resp)
}

// deleteByBillingProfileCreateRequest creates the DeleteByBillingProfile request.
func (client *BillingRoleAssignmentsClient) deleteByBillingProfileCreateRequest(ctx context.Context, billingAccountName string, billingProfileName string, billingRoleAssignmentName string, options *BillingRoleAssignmentsDeleteByBillingProfileOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/billingRoleAssignments/{billingRoleAssignmentName}"
	if billingAccountName == "" {
		return nil, errors.New("parameter billingAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingAccountName}", url.PathEscape(billingAccountName))
	if billingProfileName == "" {
		return nil, errors.New("parameter billingProfileName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingProfileName}", url.PathEscape(billingProfileName))
	if billingRoleAssignmentName == "" {
		return nil, errors.New("parameter billingRoleAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingRoleAssignmentName}", url.PathEscape(billingRoleAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteByBillingProfileHandleResponse handles the DeleteByBillingProfile response.
func (client *BillingRoleAssignmentsClient) deleteByBillingProfileHandleResponse(resp *http.Response) (BillingRoleAssignmentsDeleteByBillingProfileResponse, error) {
	result := BillingRoleAssignmentsDeleteByBillingProfileResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingRoleAssignment); err != nil {
		return BillingRoleAssignmentsDeleteByBillingProfileResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// deleteByBillingProfileHandleError handles the DeleteByBillingProfile error response.
func (client *BillingRoleAssignmentsClient) deleteByBillingProfileHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteByInvoiceSection - Deletes a role assignment for the caller on an invoice section. The operation is supported for billing accounts with agreement
// type Microsoft Customer Agreement.
// If the operation fails it returns the *ErrorResponse error type.
func (client *BillingRoleAssignmentsClient) DeleteByInvoiceSection(ctx context.Context, billingAccountName string, billingProfileName string, invoiceSectionName string, billingRoleAssignmentName string, options *BillingRoleAssignmentsDeleteByInvoiceSectionOptions) (BillingRoleAssignmentsDeleteByInvoiceSectionResponse, error) {
	req, err := client.deleteByInvoiceSectionCreateRequest(ctx, billingAccountName, billingProfileName, invoiceSectionName, billingRoleAssignmentName, options)
	if err != nil {
		return BillingRoleAssignmentsDeleteByInvoiceSectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return BillingRoleAssignmentsDeleteByInvoiceSectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return BillingRoleAssignmentsDeleteByInvoiceSectionResponse{}, client.deleteByInvoiceSectionHandleError(resp)
	}
	return client.deleteByInvoiceSectionHandleResponse(resp)
}

// deleteByInvoiceSectionCreateRequest creates the DeleteByInvoiceSection request.
func (client *BillingRoleAssignmentsClient) deleteByInvoiceSectionCreateRequest(ctx context.Context, billingAccountName string, billingProfileName string, invoiceSectionName string, billingRoleAssignmentName string, options *BillingRoleAssignmentsDeleteByInvoiceSectionOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoiceSections/{invoiceSectionName}/billingRoleAssignments/{billingRoleAssignmentName}"
	if billingAccountName == "" {
		return nil, errors.New("parameter billingAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingAccountName}", url.PathEscape(billingAccountName))
	if billingProfileName == "" {
		return nil, errors.New("parameter billingProfileName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingProfileName}", url.PathEscape(billingProfileName))
	if invoiceSectionName == "" {
		return nil, errors.New("parameter invoiceSectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{invoiceSectionName}", url.PathEscape(invoiceSectionName))
	if billingRoleAssignmentName == "" {
		return nil, errors.New("parameter billingRoleAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingRoleAssignmentName}", url.PathEscape(billingRoleAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteByInvoiceSectionHandleResponse handles the DeleteByInvoiceSection response.
func (client *BillingRoleAssignmentsClient) deleteByInvoiceSectionHandleResponse(resp *http.Response) (BillingRoleAssignmentsDeleteByInvoiceSectionResponse, error) {
	result := BillingRoleAssignmentsDeleteByInvoiceSectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingRoleAssignment); err != nil {
		return BillingRoleAssignmentsDeleteByInvoiceSectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// deleteByInvoiceSectionHandleError handles the DeleteByInvoiceSection error response.
func (client *BillingRoleAssignmentsClient) deleteByInvoiceSectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetByBillingAccount - Gets a role assignment for the caller on a billing account. The operation is supported for billing accounts with agreement type
// Microsoft Partner Agreement or Microsoft Customer Agreement.
// If the operation fails it returns the *ErrorResponse error type.
func (client *BillingRoleAssignmentsClient) GetByBillingAccount(ctx context.Context, billingAccountName string, billingRoleAssignmentName string, options *BillingRoleAssignmentsGetByBillingAccountOptions) (BillingRoleAssignmentsGetByBillingAccountResponse, error) {
	req, err := client.getByBillingAccountCreateRequest(ctx, billingAccountName, billingRoleAssignmentName, options)
	if err != nil {
		return BillingRoleAssignmentsGetByBillingAccountResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return BillingRoleAssignmentsGetByBillingAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return BillingRoleAssignmentsGetByBillingAccountResponse{}, client.getByBillingAccountHandleError(resp)
	}
	return client.getByBillingAccountHandleResponse(resp)
}

// getByBillingAccountCreateRequest creates the GetByBillingAccount request.
func (client *BillingRoleAssignmentsClient) getByBillingAccountCreateRequest(ctx context.Context, billingAccountName string, billingRoleAssignmentName string, options *BillingRoleAssignmentsGetByBillingAccountOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingRoleAssignments/{billingRoleAssignmentName}"
	if billingAccountName == "" {
		return nil, errors.New("parameter billingAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingAccountName}", url.PathEscape(billingAccountName))
	if billingRoleAssignmentName == "" {
		return nil, errors.New("parameter billingRoleAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingRoleAssignmentName}", url.PathEscape(billingRoleAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getByBillingAccountHandleResponse handles the GetByBillingAccount response.
func (client *BillingRoleAssignmentsClient) getByBillingAccountHandleResponse(resp *http.Response) (BillingRoleAssignmentsGetByBillingAccountResponse, error) {
	result := BillingRoleAssignmentsGetByBillingAccountResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingRoleAssignment); err != nil {
		return BillingRoleAssignmentsGetByBillingAccountResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getByBillingAccountHandleError handles the GetByBillingAccount error response.
func (client *BillingRoleAssignmentsClient) getByBillingAccountHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetByBillingProfile - Gets a role assignment for the caller on a billing profile. The operation is supported for billing accounts with agreement type
// Microsoft Partner Agreement or Microsoft Customer Agreement.
// If the operation fails it returns the *ErrorResponse error type.
func (client *BillingRoleAssignmentsClient) GetByBillingProfile(ctx context.Context, billingAccountName string, billingProfileName string, billingRoleAssignmentName string, options *BillingRoleAssignmentsGetByBillingProfileOptions) (BillingRoleAssignmentsGetByBillingProfileResponse, error) {
	req, err := client.getByBillingProfileCreateRequest(ctx, billingAccountName, billingProfileName, billingRoleAssignmentName, options)
	if err != nil {
		return BillingRoleAssignmentsGetByBillingProfileResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return BillingRoleAssignmentsGetByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return BillingRoleAssignmentsGetByBillingProfileResponse{}, client.getByBillingProfileHandleError(resp)
	}
	return client.getByBillingProfileHandleResponse(resp)
}

// getByBillingProfileCreateRequest creates the GetByBillingProfile request.
func (client *BillingRoleAssignmentsClient) getByBillingProfileCreateRequest(ctx context.Context, billingAccountName string, billingProfileName string, billingRoleAssignmentName string, options *BillingRoleAssignmentsGetByBillingProfileOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/billingRoleAssignments/{billingRoleAssignmentName}"
	if billingAccountName == "" {
		return nil, errors.New("parameter billingAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingAccountName}", url.PathEscape(billingAccountName))
	if billingProfileName == "" {
		return nil, errors.New("parameter billingProfileName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingProfileName}", url.PathEscape(billingProfileName))
	if billingRoleAssignmentName == "" {
		return nil, errors.New("parameter billingRoleAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingRoleAssignmentName}", url.PathEscape(billingRoleAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getByBillingProfileHandleResponse handles the GetByBillingProfile response.
func (client *BillingRoleAssignmentsClient) getByBillingProfileHandleResponse(resp *http.Response) (BillingRoleAssignmentsGetByBillingProfileResponse, error) {
	result := BillingRoleAssignmentsGetByBillingProfileResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingRoleAssignment); err != nil {
		return BillingRoleAssignmentsGetByBillingProfileResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getByBillingProfileHandleError handles the GetByBillingProfile error response.
func (client *BillingRoleAssignmentsClient) getByBillingProfileHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetByInvoiceSection - Gets a role assignment for the caller on an invoice section. The operation is supported for billing accounts with agreement type
// Microsoft Customer Agreement.
// If the operation fails it returns the *ErrorResponse error type.
func (client *BillingRoleAssignmentsClient) GetByInvoiceSection(ctx context.Context, billingAccountName string, billingProfileName string, invoiceSectionName string, billingRoleAssignmentName string, options *BillingRoleAssignmentsGetByInvoiceSectionOptions) (BillingRoleAssignmentsGetByInvoiceSectionResponse, error) {
	req, err := client.getByInvoiceSectionCreateRequest(ctx, billingAccountName, billingProfileName, invoiceSectionName, billingRoleAssignmentName, options)
	if err != nil {
		return BillingRoleAssignmentsGetByInvoiceSectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return BillingRoleAssignmentsGetByInvoiceSectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return BillingRoleAssignmentsGetByInvoiceSectionResponse{}, client.getByInvoiceSectionHandleError(resp)
	}
	return client.getByInvoiceSectionHandleResponse(resp)
}

// getByInvoiceSectionCreateRequest creates the GetByInvoiceSection request.
func (client *BillingRoleAssignmentsClient) getByInvoiceSectionCreateRequest(ctx context.Context, billingAccountName string, billingProfileName string, invoiceSectionName string, billingRoleAssignmentName string, options *BillingRoleAssignmentsGetByInvoiceSectionOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoiceSections/{invoiceSectionName}/billingRoleAssignments/{billingRoleAssignmentName}"
	if billingAccountName == "" {
		return nil, errors.New("parameter billingAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingAccountName}", url.PathEscape(billingAccountName))
	if billingProfileName == "" {
		return nil, errors.New("parameter billingProfileName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingProfileName}", url.PathEscape(billingProfileName))
	if invoiceSectionName == "" {
		return nil, errors.New("parameter invoiceSectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{invoiceSectionName}", url.PathEscape(invoiceSectionName))
	if billingRoleAssignmentName == "" {
		return nil, errors.New("parameter billingRoleAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingRoleAssignmentName}", url.PathEscape(billingRoleAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getByInvoiceSectionHandleResponse handles the GetByInvoiceSection response.
func (client *BillingRoleAssignmentsClient) getByInvoiceSectionHandleResponse(resp *http.Response) (BillingRoleAssignmentsGetByInvoiceSectionResponse, error) {
	result := BillingRoleAssignmentsGetByInvoiceSectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingRoleAssignment); err != nil {
		return BillingRoleAssignmentsGetByInvoiceSectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getByInvoiceSectionHandleError handles the GetByInvoiceSection error response.
func (client *BillingRoleAssignmentsClient) getByInvoiceSectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListByBillingAccount - Lists the role assignments for the caller on a billing account. The operation is supported for billing accounts with agreement
// type Microsoft Partner Agreement or Microsoft Customer Agreement.
// If the operation fails it returns the *ErrorResponse error type.
func (client *BillingRoleAssignmentsClient) ListByBillingAccount(billingAccountName string, options *BillingRoleAssignmentsListByBillingAccountOptions) *BillingRoleAssignmentsListByBillingAccountPager {
	return &BillingRoleAssignmentsListByBillingAccountPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listByBillingAccountCreateRequest(ctx, billingAccountName, options)
		},
		advancer: func(ctx context.Context, resp BillingRoleAssignmentsListByBillingAccountResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.BillingRoleAssignmentListResult.NextLink)
		},
	}
}

// listByBillingAccountCreateRequest creates the ListByBillingAccount request.
func (client *BillingRoleAssignmentsClient) listByBillingAccountCreateRequest(ctx context.Context, billingAccountName string, options *BillingRoleAssignmentsListByBillingAccountOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingRoleAssignments"
	if billingAccountName == "" {
		return nil, errors.New("parameter billingAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingAccountName}", url.PathEscape(billingAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listByBillingAccountHandleResponse handles the ListByBillingAccount response.
func (client *BillingRoleAssignmentsClient) listByBillingAccountHandleResponse(resp *http.Response) (BillingRoleAssignmentsListByBillingAccountResponse, error) {
	result := BillingRoleAssignmentsListByBillingAccountResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingRoleAssignmentListResult); err != nil {
		return BillingRoleAssignmentsListByBillingAccountResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listByBillingAccountHandleError handles the ListByBillingAccount error response.
func (client *BillingRoleAssignmentsClient) listByBillingAccountHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListByBillingProfile - Lists the role assignments for the caller on a billing profile. The operation is supported for billing accounts with agreement
// type Microsoft Customer Agreement.
// If the operation fails it returns the *ErrorResponse error type.
func (client *BillingRoleAssignmentsClient) ListByBillingProfile(billingAccountName string, billingProfileName string, options *BillingRoleAssignmentsListByBillingProfileOptions) *BillingRoleAssignmentsListByBillingProfilePager {
	return &BillingRoleAssignmentsListByBillingProfilePager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listByBillingProfileCreateRequest(ctx, billingAccountName, billingProfileName, options)
		},
		advancer: func(ctx context.Context, resp BillingRoleAssignmentsListByBillingProfileResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.BillingRoleAssignmentListResult.NextLink)
		},
	}
}

// listByBillingProfileCreateRequest creates the ListByBillingProfile request.
func (client *BillingRoleAssignmentsClient) listByBillingProfileCreateRequest(ctx context.Context, billingAccountName string, billingProfileName string, options *BillingRoleAssignmentsListByBillingProfileOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/billingRoleAssignments"
	if billingAccountName == "" {
		return nil, errors.New("parameter billingAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingAccountName}", url.PathEscape(billingAccountName))
	if billingProfileName == "" {
		return nil, errors.New("parameter billingProfileName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingProfileName}", url.PathEscape(billingProfileName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listByBillingProfileHandleResponse handles the ListByBillingProfile response.
func (client *BillingRoleAssignmentsClient) listByBillingProfileHandleResponse(resp *http.Response) (BillingRoleAssignmentsListByBillingProfileResponse, error) {
	result := BillingRoleAssignmentsListByBillingProfileResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingRoleAssignmentListResult); err != nil {
		return BillingRoleAssignmentsListByBillingProfileResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listByBillingProfileHandleError handles the ListByBillingProfile error response.
func (client *BillingRoleAssignmentsClient) listByBillingProfileHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListByInvoiceSection - Lists the role assignments for the caller on an invoice section. The operation is supported for billing accounts with agreement
// type Microsoft Customer Agreement.
// If the operation fails it returns the *ErrorResponse error type.
func (client *BillingRoleAssignmentsClient) ListByInvoiceSection(billingAccountName string, billingProfileName string, invoiceSectionName string, options *BillingRoleAssignmentsListByInvoiceSectionOptions) *BillingRoleAssignmentsListByInvoiceSectionPager {
	return &BillingRoleAssignmentsListByInvoiceSectionPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listByInvoiceSectionCreateRequest(ctx, billingAccountName, billingProfileName, invoiceSectionName, options)
		},
		advancer: func(ctx context.Context, resp BillingRoleAssignmentsListByInvoiceSectionResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.BillingRoleAssignmentListResult.NextLink)
		},
	}
}

// listByInvoiceSectionCreateRequest creates the ListByInvoiceSection request.
func (client *BillingRoleAssignmentsClient) listByInvoiceSectionCreateRequest(ctx context.Context, billingAccountName string, billingProfileName string, invoiceSectionName string, options *BillingRoleAssignmentsListByInvoiceSectionOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoiceSections/{invoiceSectionName}/billingRoleAssignments"
	if billingAccountName == "" {
		return nil, errors.New("parameter billingAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingAccountName}", url.PathEscape(billingAccountName))
	if billingProfileName == "" {
		return nil, errors.New("parameter billingProfileName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{billingProfileName}", url.PathEscape(billingProfileName))
	if invoiceSectionName == "" {
		return nil, errors.New("parameter invoiceSectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{invoiceSectionName}", url.PathEscape(invoiceSectionName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listByInvoiceSectionHandleResponse handles the ListByInvoiceSection response.
func (client *BillingRoleAssignmentsClient) listByInvoiceSectionHandleResponse(resp *http.Response) (BillingRoleAssignmentsListByInvoiceSectionResponse, error) {
	result := BillingRoleAssignmentsListByInvoiceSectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingRoleAssignmentListResult); err != nil {
		return BillingRoleAssignmentsListByInvoiceSectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listByInvoiceSectionHandleError handles the ListByInvoiceSection error response.
func (client *BillingRoleAssignmentsClient) listByInvoiceSectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
