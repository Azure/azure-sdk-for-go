//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armbilling

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionPager provides operations for iterating over paged responses.
type AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionPager struct {
	client    *AccountsClient
	current   AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InvoiceSectionListWithCreateSubPermissionResult.NextLink == nil || len(*p.current.InvoiceSectionListWithCreateSubPermissionResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInvoiceSectionsByCreateSubscriptionPermissionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionResponse page.
func (p *AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionPager) PageResponse() AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionResponse {
	return p.current
}

// AccountsClientListPager provides operations for iterating over paged responses.
type AccountsClientListPager struct {
	client    *AccountsClient
	current   AccountsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccountsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccountsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccountListResult.NextLink == nil || len(*p.current.AccountListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccountsClientListResponse page.
func (p *AccountsClientListPager) PageResponse() AccountsClientListResponse {
	return p.current
}

// AgreementsClientListByBillingAccountPager provides operations for iterating over paged responses.
type AgreementsClientListByBillingAccountPager struct {
	client    *AgreementsClient
	current   AgreementsClientListByBillingAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AgreementsClientListByBillingAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AgreementsClientListByBillingAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AgreementsClientListByBillingAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AgreementListResult.NextLink == nil || len(*p.current.AgreementListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AgreementsClientListByBillingAccountResponse page.
func (p *AgreementsClientListByBillingAccountPager) PageResponse() AgreementsClientListByBillingAccountResponse {
	return p.current
}

// CustomersClientListByBillingAccountPager provides operations for iterating over paged responses.
type CustomersClientListByBillingAccountPager struct {
	client    *CustomersClient
	current   CustomersClientListByBillingAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomersClientListByBillingAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomersClientListByBillingAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomersClientListByBillingAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomerListResult.NextLink == nil || len(*p.current.CustomerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomersClientListByBillingAccountResponse page.
func (p *CustomersClientListByBillingAccountPager) PageResponse() CustomersClientListByBillingAccountResponse {
	return p.current
}

// CustomersClientListByBillingProfilePager provides operations for iterating over paged responses.
type CustomersClientListByBillingProfilePager struct {
	client    *CustomersClient
	current   CustomersClientListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomersClientListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomersClientListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomersClientListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomerListResult.NextLink == nil || len(*p.current.CustomerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomersClientListByBillingProfileResponse page.
func (p *CustomersClientListByBillingProfilePager) PageResponse() CustomersClientListByBillingProfileResponse {
	return p.current
}

// EnrollmentAccountsClientListPager provides operations for iterating over paged responses.
type EnrollmentAccountsClientListPager struct {
	client    *EnrollmentAccountsClient
	current   EnrollmentAccountsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnrollmentAccountsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EnrollmentAccountsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EnrollmentAccountsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EnrollmentAccountListResult.NextLink == nil || len(*p.current.EnrollmentAccountListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EnrollmentAccountsClientListResponse page.
func (p *EnrollmentAccountsClientListPager) PageResponse() EnrollmentAccountsClientListResponse {
	return p.current
}

// InstructionsClientListByBillingProfilePager provides operations for iterating over paged responses.
type InstructionsClientListByBillingProfilePager struct {
	client    *InstructionsClient
	current   InstructionsClientListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InstructionsClientListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InstructionsClientListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InstructionsClientListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InstructionListResult.NextLink == nil || len(*p.current.InstructionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InstructionsClientListByBillingProfileResponse page.
func (p *InstructionsClientListByBillingProfilePager) PageResponse() InstructionsClientListByBillingProfileResponse {
	return p.current
}

// InvoiceSectionsClientListByBillingProfilePager provides operations for iterating over paged responses.
type InvoiceSectionsClientListByBillingProfilePager struct {
	client    *InvoiceSectionsClient
	current   InvoiceSectionsClientListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InvoiceSectionsClientListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InvoiceSectionsClientListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InvoiceSectionsClientListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InvoiceSectionListResult.NextLink == nil || len(*p.current.InvoiceSectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InvoiceSectionsClientListByBillingProfileResponse page.
func (p *InvoiceSectionsClientListByBillingProfilePager) PageResponse() InvoiceSectionsClientListByBillingProfileResponse {
	return p.current
}

// InvoicesClientListByBillingAccountPager provides operations for iterating over paged responses.
type InvoicesClientListByBillingAccountPager struct {
	client    *InvoicesClient
	current   InvoicesClientListByBillingAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InvoicesClientListByBillingAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InvoicesClientListByBillingAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InvoicesClientListByBillingAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InvoiceListResult.NextLink == nil || len(*p.current.InvoiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InvoicesClientListByBillingAccountResponse page.
func (p *InvoicesClientListByBillingAccountPager) PageResponse() InvoicesClientListByBillingAccountResponse {
	return p.current
}

// InvoicesClientListByBillingProfilePager provides operations for iterating over paged responses.
type InvoicesClientListByBillingProfilePager struct {
	client    *InvoicesClient
	current   InvoicesClientListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InvoicesClientListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InvoicesClientListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InvoicesClientListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InvoiceListResult.NextLink == nil || len(*p.current.InvoiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InvoicesClientListByBillingProfileResponse page.
func (p *InvoicesClientListByBillingProfilePager) PageResponse() InvoicesClientListByBillingProfileResponse {
	return p.current
}

// InvoicesClientListByBillingSubscriptionPager provides operations for iterating over paged responses.
type InvoicesClientListByBillingSubscriptionPager struct {
	client    *InvoicesClient
	current   InvoicesClientListByBillingSubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InvoicesClientListByBillingSubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InvoicesClientListByBillingSubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InvoicesClientListByBillingSubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InvoiceListResult.NextLink == nil || len(*p.current.InvoiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingSubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InvoicesClientListByBillingSubscriptionResponse page.
func (p *InvoicesClientListByBillingSubscriptionPager) PageResponse() InvoicesClientListByBillingSubscriptionResponse {
	return p.current
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsClientListResponse page.
func (p *OperationsClientListPager) PageResponse() OperationsClientListResponse {
	return p.current
}

// PeriodsClientListPager provides operations for iterating over paged responses.
type PeriodsClientListPager struct {
	client    *PeriodsClient
	current   PeriodsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PeriodsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PeriodsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PeriodsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PeriodsListResult.NextLink == nil || len(*p.current.PeriodsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PeriodsClientListResponse page.
func (p *PeriodsClientListPager) PageResponse() PeriodsClientListResponse {
	return p.current
}

// PermissionsClientListByBillingAccountPager provides operations for iterating over paged responses.
type PermissionsClientListByBillingAccountPager struct {
	client    *PermissionsClient
	current   PermissionsClientListByBillingAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PermissionsClientListByBillingAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PermissionsClientListByBillingAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PermissionsClientListByBillingAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PermissionsListResult.NextLink == nil || len(*p.current.PermissionsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PermissionsClientListByBillingAccountResponse page.
func (p *PermissionsClientListByBillingAccountPager) PageResponse() PermissionsClientListByBillingAccountResponse {
	return p.current
}

// PermissionsClientListByBillingProfilePager provides operations for iterating over paged responses.
type PermissionsClientListByBillingProfilePager struct {
	client    *PermissionsClient
	current   PermissionsClientListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PermissionsClientListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PermissionsClientListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PermissionsClientListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PermissionsListResult.NextLink == nil || len(*p.current.PermissionsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PermissionsClientListByBillingProfileResponse page.
func (p *PermissionsClientListByBillingProfilePager) PageResponse() PermissionsClientListByBillingProfileResponse {
	return p.current
}

// PermissionsClientListByCustomerPager provides operations for iterating over paged responses.
type PermissionsClientListByCustomerPager struct {
	client    *PermissionsClient
	current   PermissionsClientListByCustomerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PermissionsClientListByCustomerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PermissionsClientListByCustomerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PermissionsClientListByCustomerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PermissionsListResult.NextLink == nil || len(*p.current.PermissionsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByCustomerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PermissionsClientListByCustomerResponse page.
func (p *PermissionsClientListByCustomerPager) PageResponse() PermissionsClientListByCustomerResponse {
	return p.current
}

// PermissionsClientListByInvoiceSectionsPager provides operations for iterating over paged responses.
type PermissionsClientListByInvoiceSectionsPager struct {
	client    *PermissionsClient
	current   PermissionsClientListByInvoiceSectionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PermissionsClientListByInvoiceSectionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PermissionsClientListByInvoiceSectionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PermissionsClientListByInvoiceSectionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PermissionsListResult.NextLink == nil || len(*p.current.PermissionsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInvoiceSectionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PermissionsClientListByInvoiceSectionsResponse page.
func (p *PermissionsClientListByInvoiceSectionsPager) PageResponse() PermissionsClientListByInvoiceSectionsResponse {
	return p.current
}

// ProductsClientListByBillingAccountPager provides operations for iterating over paged responses.
type ProductsClientListByBillingAccountPager struct {
	client    *ProductsClient
	current   ProductsClientListByBillingAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductsClientListByBillingAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductsClientListByBillingAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductsClientListByBillingAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductsListResult.NextLink == nil || len(*p.current.ProductsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductsClientListByBillingAccountResponse page.
func (p *ProductsClientListByBillingAccountPager) PageResponse() ProductsClientListByBillingAccountResponse {
	return p.current
}

// ProductsClientListByBillingProfilePager provides operations for iterating over paged responses.
type ProductsClientListByBillingProfilePager struct {
	client    *ProductsClient
	current   ProductsClientListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductsClientListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductsClientListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductsClientListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductsListResult.NextLink == nil || len(*p.current.ProductsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductsClientListByBillingProfileResponse page.
func (p *ProductsClientListByBillingProfilePager) PageResponse() ProductsClientListByBillingProfileResponse {
	return p.current
}

// ProductsClientListByCustomerPager provides operations for iterating over paged responses.
type ProductsClientListByCustomerPager struct {
	client    *ProductsClient
	current   ProductsClientListByCustomerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductsClientListByCustomerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductsClientListByCustomerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductsClientListByCustomerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductsListResult.NextLink == nil || len(*p.current.ProductsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByCustomerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductsClientListByCustomerResponse page.
func (p *ProductsClientListByCustomerPager) PageResponse() ProductsClientListByCustomerResponse {
	return p.current
}

// ProductsClientListByInvoiceSectionPager provides operations for iterating over paged responses.
type ProductsClientListByInvoiceSectionPager struct {
	client    *ProductsClient
	current   ProductsClientListByInvoiceSectionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductsClientListByInvoiceSectionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProductsClientListByInvoiceSectionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProductsClientListByInvoiceSectionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductsListResult.NextLink == nil || len(*p.current.ProductsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInvoiceSectionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProductsClientListByInvoiceSectionResponse page.
func (p *ProductsClientListByInvoiceSectionPager) PageResponse() ProductsClientListByInvoiceSectionResponse {
	return p.current
}

// ProfilesClientListByBillingAccountPager provides operations for iterating over paged responses.
type ProfilesClientListByBillingAccountPager struct {
	client    *ProfilesClient
	current   ProfilesClientListByBillingAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListByBillingAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProfilesClientListByBillingAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProfilesClientListByBillingAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProfileListResult.NextLink == nil || len(*p.current.ProfileListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProfilesClientListByBillingAccountResponse page.
func (p *ProfilesClientListByBillingAccountPager) PageResponse() ProfilesClientListByBillingAccountResponse {
	return p.current
}

// ReservationsClientListByBillingAccountPager provides operations for iterating over paged responses.
type ReservationsClientListByBillingAccountPager struct {
	client    *ReservationsClient
	current   ReservationsClientListByBillingAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsClientListByBillingAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReservationsClientListByBillingAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReservationsClientListByBillingAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationsListResult.NextLink == nil || len(*p.current.ReservationsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReservationsClientListByBillingAccountResponse page.
func (p *ReservationsClientListByBillingAccountPager) PageResponse() ReservationsClientListByBillingAccountResponse {
	return p.current
}

// ReservationsClientListByBillingProfilePager provides operations for iterating over paged responses.
type ReservationsClientListByBillingProfilePager struct {
	client    *ReservationsClient
	current   ReservationsClientListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsClientListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReservationsClientListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReservationsClientListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationsListResult.NextLink == nil || len(*p.current.ReservationsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReservationsClientListByBillingProfileResponse page.
func (p *ReservationsClientListByBillingProfilePager) PageResponse() ReservationsClientListByBillingProfileResponse {
	return p.current
}

// RoleAssignmentsClientListByBillingAccountPager provides operations for iterating over paged responses.
type RoleAssignmentsClientListByBillingAccountPager struct {
	client    *RoleAssignmentsClient
	current   RoleAssignmentsClientListByBillingAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentsClientListByBillingAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleAssignmentsClientListByBillingAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleAssignmentsClientListByBillingAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentListResult.NextLink == nil || len(*p.current.RoleAssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleAssignmentsClientListByBillingAccountResponse page.
func (p *RoleAssignmentsClientListByBillingAccountPager) PageResponse() RoleAssignmentsClientListByBillingAccountResponse {
	return p.current
}

// RoleAssignmentsClientListByBillingProfilePager provides operations for iterating over paged responses.
type RoleAssignmentsClientListByBillingProfilePager struct {
	client    *RoleAssignmentsClient
	current   RoleAssignmentsClientListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentsClientListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleAssignmentsClientListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleAssignmentsClientListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentListResult.NextLink == nil || len(*p.current.RoleAssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleAssignmentsClientListByBillingProfileResponse page.
func (p *RoleAssignmentsClientListByBillingProfilePager) PageResponse() RoleAssignmentsClientListByBillingProfileResponse {
	return p.current
}

// RoleAssignmentsClientListByInvoiceSectionPager provides operations for iterating over paged responses.
type RoleAssignmentsClientListByInvoiceSectionPager struct {
	client    *RoleAssignmentsClient
	current   RoleAssignmentsClientListByInvoiceSectionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentsClientListByInvoiceSectionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleAssignmentsClientListByInvoiceSectionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleAssignmentsClientListByInvoiceSectionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentListResult.NextLink == nil || len(*p.current.RoleAssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInvoiceSectionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleAssignmentsClientListByInvoiceSectionResponse page.
func (p *RoleAssignmentsClientListByInvoiceSectionPager) PageResponse() RoleAssignmentsClientListByInvoiceSectionResponse {
	return p.current
}

// RoleDefinitionsClientListByBillingAccountPager provides operations for iterating over paged responses.
type RoleDefinitionsClientListByBillingAccountPager struct {
	client    *RoleDefinitionsClient
	current   RoleDefinitionsClientListByBillingAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleDefinitionsClientListByBillingAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleDefinitionsClientListByBillingAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleDefinitionsClientListByBillingAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleDefinitionListResult.NextLink == nil || len(*p.current.RoleDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleDefinitionsClientListByBillingAccountResponse page.
func (p *RoleDefinitionsClientListByBillingAccountPager) PageResponse() RoleDefinitionsClientListByBillingAccountResponse {
	return p.current
}

// RoleDefinitionsClientListByBillingProfilePager provides operations for iterating over paged responses.
type RoleDefinitionsClientListByBillingProfilePager struct {
	client    *RoleDefinitionsClient
	current   RoleDefinitionsClientListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleDefinitionsClientListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleDefinitionsClientListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleDefinitionsClientListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleDefinitionListResult.NextLink == nil || len(*p.current.RoleDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleDefinitionsClientListByBillingProfileResponse page.
func (p *RoleDefinitionsClientListByBillingProfilePager) PageResponse() RoleDefinitionsClientListByBillingProfileResponse {
	return p.current
}

// RoleDefinitionsClientListByInvoiceSectionPager provides operations for iterating over paged responses.
type RoleDefinitionsClientListByInvoiceSectionPager struct {
	client    *RoleDefinitionsClient
	current   RoleDefinitionsClientListByInvoiceSectionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleDefinitionsClientListByInvoiceSectionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoleDefinitionsClientListByInvoiceSectionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoleDefinitionsClientListByInvoiceSectionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleDefinitionListResult.NextLink == nil || len(*p.current.RoleDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInvoiceSectionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoleDefinitionsClientListByInvoiceSectionResponse page.
func (p *RoleDefinitionsClientListByInvoiceSectionPager) PageResponse() RoleDefinitionsClientListByInvoiceSectionResponse {
	return p.current
}

// SubscriptionsClientListByBillingAccountPager provides operations for iterating over paged responses.
type SubscriptionsClientListByBillingAccountPager struct {
	client    *SubscriptionsClient
	current   SubscriptionsClientListByBillingAccountResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionsClientListByBillingAccountResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubscriptionsClientListByBillingAccountPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubscriptionsClientListByBillingAccountPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionsListResult.NextLink == nil || len(*p.current.SubscriptionsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubscriptionsClientListByBillingAccountResponse page.
func (p *SubscriptionsClientListByBillingAccountPager) PageResponse() SubscriptionsClientListByBillingAccountResponse {
	return p.current
}

// SubscriptionsClientListByBillingProfilePager provides operations for iterating over paged responses.
type SubscriptionsClientListByBillingProfilePager struct {
	client    *SubscriptionsClient
	current   SubscriptionsClientListByBillingProfileResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionsClientListByBillingProfileResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubscriptionsClientListByBillingProfilePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubscriptionsClientListByBillingProfilePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionsListResult.NextLink == nil || len(*p.current.SubscriptionsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubscriptionsClientListByBillingProfileResponse page.
func (p *SubscriptionsClientListByBillingProfilePager) PageResponse() SubscriptionsClientListByBillingProfileResponse {
	return p.current
}

// SubscriptionsClientListByCustomerPager provides operations for iterating over paged responses.
type SubscriptionsClientListByCustomerPager struct {
	client    *SubscriptionsClient
	current   SubscriptionsClientListByCustomerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionsClientListByCustomerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubscriptionsClientListByCustomerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubscriptionsClientListByCustomerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionsListResult.NextLink == nil || len(*p.current.SubscriptionsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByCustomerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubscriptionsClientListByCustomerResponse page.
func (p *SubscriptionsClientListByCustomerPager) PageResponse() SubscriptionsClientListByCustomerResponse {
	return p.current
}

// SubscriptionsClientListByInvoiceSectionPager provides operations for iterating over paged responses.
type SubscriptionsClientListByInvoiceSectionPager struct {
	client    *SubscriptionsClient
	current   SubscriptionsClientListByInvoiceSectionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionsClientListByInvoiceSectionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubscriptionsClientListByInvoiceSectionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubscriptionsClientListByInvoiceSectionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionsListResult.NextLink == nil || len(*p.current.SubscriptionsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInvoiceSectionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubscriptionsClientListByInvoiceSectionResponse page.
func (p *SubscriptionsClientListByInvoiceSectionPager) PageResponse() SubscriptionsClientListByInvoiceSectionResponse {
	return p.current
}

// TransactionsClientListByInvoicePager provides operations for iterating over paged responses.
type TransactionsClientListByInvoicePager struct {
	client    *TransactionsClient
	current   TransactionsClientListByInvoiceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TransactionsClientListByInvoiceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TransactionsClientListByInvoicePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TransactionsClientListByInvoicePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TransactionListResult.NextLink == nil || len(*p.current.TransactionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInvoiceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TransactionsClientListByInvoiceResponse page.
func (p *TransactionsClientListByInvoicePager) PageResponse() TransactionsClientListByInvoiceResponse {
	return p.current
}
