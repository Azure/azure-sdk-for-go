//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armbotservice

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// GetChannel implements the ChannelClassification interface for type AlexaChannel.
func (a *AlexaChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       a.ChannelName,
		Etag:              a.Etag,
		ProvisioningState: a.ProvisioningState,
		Location:          a.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AlexaChannel.
func (a AlexaChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "AlexaChannel"
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlexaChannel.
func (a *AlexaChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &a.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &a.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &a.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Bot.
func (b Bot) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", b.Etag)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "kind", b.Kind)
	populate(objectMap, "location", b.Location)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "sku", b.SKU)
	populate(objectMap, "tags", b.Tags)
	populate(objectMap, "type", b.Type)
	populate(objectMap, "zones", b.Zones)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BotChannel.
func (b BotChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", b.Etag)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "kind", b.Kind)
	populate(objectMap, "location", b.Location)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "sku", b.SKU)
	populate(objectMap, "tags", b.Tags)
	populate(objectMap, "type", b.Type)
	populate(objectMap, "zones", b.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BotChannel.
func (b *BotChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &b.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &b.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &b.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &b.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &b.Name)
			delete(rawMsg, key)
		case "properties":
			b.Properties, err = unmarshalChannelClassification(val)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &b.SKU)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &b.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, &b.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BotProperties.
func (b BotProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allSettings", b.AllSettings)
	populate(objectMap, "appPasswordHint", b.AppPasswordHint)
	populate(objectMap, "cmekEncryptionStatus", b.CmekEncryptionStatus)
	populate(objectMap, "cmekKeyVaultUrl", b.CmekKeyVaultURL)
	populate(objectMap, "configuredChannels", b.ConfiguredChannels)
	populate(objectMap, "description", b.Description)
	populate(objectMap, "developerAppInsightKey", b.DeveloperAppInsightKey)
	populate(objectMap, "developerAppInsightsApiKey", b.DeveloperAppInsightsAPIKey)
	populate(objectMap, "developerAppInsightsApplicationId", b.DeveloperAppInsightsApplicationID)
	populate(objectMap, "disableLocalAuth", b.DisableLocalAuth)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "enabledChannels", b.EnabledChannels)
	populate(objectMap, "endpoint", b.Endpoint)
	populate(objectMap, "endpointVersion", b.EndpointVersion)
	populate(objectMap, "iconUrl", b.IconURL)
	populate(objectMap, "isCmekEnabled", b.IsCmekEnabled)
	populate(objectMap, "isDeveloperAppInsightsApiKeySet", b.IsDeveloperAppInsightsAPIKeySet)
	populate(objectMap, "isStreamingSupported", b.IsStreamingSupported)
	populate(objectMap, "luisAppIds", b.LuisAppIDs)
	populate(objectMap, "luisKey", b.LuisKey)
	populate(objectMap, "manifestUrl", b.ManifestURL)
	populate(objectMap, "migrationToken", b.MigrationToken)
	populate(objectMap, "msaAppId", b.MsaAppID)
	populate(objectMap, "msaAppMSIResourceId", b.MsaAppMSIResourceID)
	populate(objectMap, "msaAppTenantId", b.MsaAppTenantID)
	populate(objectMap, "msaAppType", b.MsaAppType)
	populate(objectMap, "openWithHint", b.OpenWithHint)
	populate(objectMap, "parameters", b.Parameters)
	populate(objectMap, "privateEndpointConnections", b.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", b.PublicNetworkAccess)
	populate(objectMap, "publishingCredentials", b.PublishingCredentials)
	populate(objectMap, "schemaTransformationVersion", b.SchemaTransformationVersion)
	populate(objectMap, "storageResourceId", b.StorageResourceID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BotResponseList.
func (b BotResponseList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// GetChannel implements the ChannelClassification interface for type Channel.
func (c *Channel) GetChannel() *Channel { return c }

// MarshalJSON implements the json.Marshaller interface for type ChannelResponseList.
func (c ChannelResponseList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ChannelSettings.
func (c ChannelSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "botId", c.BotID)
	populate(objectMap, "botIconUrl", c.BotIconURL)
	populate(objectMap, "channelDisplayName", c.ChannelDisplayName)
	populate(objectMap, "channelId", c.ChannelID)
	populate(objectMap, "disableLocalAuth", c.DisableLocalAuth)
	populate(objectMap, "extensionKey1", c.ExtensionKey1)
	populate(objectMap, "extensionKey2", c.ExtensionKey2)
	populate(objectMap, "isEnabled", c.IsEnabled)
	populate(objectMap, "sites", c.Sites)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionSetting.
func (c ConnectionSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", c.Etag)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "kind", c.Kind)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "sku", c.SKU)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	populate(objectMap, "zones", c.Zones)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionSettingProperties.
func (c ConnectionSettingProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientId", c.ClientID)
	populate(objectMap, "clientSecret", c.ClientSecret)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "parameters", c.Parameters)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "scopes", c.Scopes)
	populate(objectMap, "serviceProviderDisplayName", c.ServiceProviderDisplayName)
	populate(objectMap, "serviceProviderId", c.ServiceProviderID)
	populate(objectMap, "settingId", c.SettingID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionSettingResponseList.
func (c ConnectionSettingResponseList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// GetChannel implements the ChannelClassification interface for type DirectLineChannel.
func (d *DirectLineChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       d.ChannelName,
		Etag:              d.Etag,
		ProvisioningState: d.ProvisioningState,
		Location:          d.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DirectLineChannel.
func (d DirectLineChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "DirectLineChannel"
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DirectLineChannel.
func (d *DirectLineChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &d.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &d.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &d.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DirectLineChannelProperties.
func (d DirectLineChannelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "DirectLineEmbedCode", d.DirectLineEmbedCode)
	populate(objectMap, "sites", d.Sites)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DirectLineSite.
func (d DirectLineSite) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "isBlockUserUploadEnabled", d.IsBlockUserUploadEnabled)
	populate(objectMap, "isEnabled", d.IsEnabled)
	populate(objectMap, "isSecureSiteEnabled", d.IsSecureSiteEnabled)
	populate(objectMap, "isV1Enabled", d.IsV1Enabled)
	populate(objectMap, "isV3Enabled", d.IsV3Enabled)
	populate(objectMap, "key", d.Key)
	populate(objectMap, "key2", d.Key2)
	populate(objectMap, "siteId", d.SiteID)
	populate(objectMap, "siteName", d.SiteName)
	populate(objectMap, "trustedOrigins", d.TrustedOrigins)
	return json.Marshal(objectMap)
}

// GetChannel implements the ChannelClassification interface for type DirectLineSpeechChannel.
func (d *DirectLineSpeechChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       d.ChannelName,
		Etag:              d.Etag,
		ProvisioningState: d.ProvisioningState,
		Location:          d.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DirectLineSpeechChannel.
func (d DirectLineSpeechChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "DirectLineSpeechChannel"
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DirectLineSpeechChannel.
func (d *DirectLineSpeechChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &d.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &d.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &d.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetChannel implements the ChannelClassification interface for type EmailChannel.
func (e *EmailChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       e.ChannelName,
		Etag:              e.Etag,
		ProvisioningState: e.ProvisioningState,
		Location:          e.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EmailChannel.
func (e EmailChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "EmailChannel"
	populate(objectMap, "etag", e.Etag)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EmailChannel.
func (e *EmailChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &e.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &e.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &e.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &e.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetChannel implements the ChannelClassification interface for type FacebookChannel.
func (f *FacebookChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       f.ChannelName,
		Etag:              f.Etag,
		ProvisioningState: f.ProvisioningState,
		Location:          f.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FacebookChannel.
func (f FacebookChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "FacebookChannel"
	populate(objectMap, "etag", f.Etag)
	populate(objectMap, "location", f.Location)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "provisioningState", f.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FacebookChannel.
func (f *FacebookChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &f.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &f.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &f.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &f.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &f.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FacebookChannelProperties.
func (f FacebookChannelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appId", f.AppID)
	populate(objectMap, "appSecret", f.AppSecret)
	populate(objectMap, "callbackUrl", f.CallbackURL)
	populate(objectMap, "isEnabled", f.IsEnabled)
	populate(objectMap, "pages", f.Pages)
	populate(objectMap, "verifyToken", f.VerifyToken)
	return json.Marshal(objectMap)
}

// GetChannel implements the ChannelClassification interface for type KikChannel.
func (k *KikChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       k.ChannelName,
		Etag:              k.Etag,
		ProvisioningState: k.ProvisioningState,
		Location:          k.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type KikChannel.
func (k KikChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "KikChannel"
	populate(objectMap, "etag", k.Etag)
	populate(objectMap, "location", k.Location)
	populate(objectMap, "properties", k.Properties)
	populate(objectMap, "provisioningState", k.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KikChannel.
func (k *KikChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &k.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &k.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &k.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &k.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &k.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetChannel implements the ChannelClassification interface for type LineChannel.
func (l *LineChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       l.ChannelName,
		Etag:              l.Etag,
		ProvisioningState: l.ProvisioningState,
		Location:          l.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type LineChannel.
func (l LineChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "LineChannel"
	populate(objectMap, "etag", l.Etag)
	populate(objectMap, "location", l.Location)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LineChannel.
func (l *LineChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &l.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &l.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &l.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &l.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LineChannelProperties.
func (l LineChannelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "callbackUrl", l.CallbackURL)
	populate(objectMap, "isValidated", l.IsValidated)
	populate(objectMap, "lineRegistrations", l.LineRegistrations)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ListChannelWithKeysResponse.
func (l ListChannelWithKeysResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "changedTime", l.ChangedTime)
	populate(objectMap, "entityTag", l.EntityTag)
	populate(objectMap, "etag", l.Etag)
	populate(objectMap, "id", l.ID)
	populate(objectMap, "kind", l.Kind)
	populate(objectMap, "location", l.Location)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "resource", l.Resource)
	populate(objectMap, "sku", l.SKU)
	populate(objectMap, "setting", l.Setting)
	populate(objectMap, "tags", l.Tags)
	populate(objectMap, "type", l.Type)
	populate(objectMap, "zones", l.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListChannelWithKeysResponse.
func (l *ListChannelWithKeysResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "changedTime":
			err = unpopulate(val, &l.ChangedTime)
			delete(rawMsg, key)
		case "entityTag":
			err = unpopulate(val, &l.EntityTag)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &l.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &l.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &l.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &l.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &l.Name)
			delete(rawMsg, key)
		case "properties":
			l.Properties, err = unmarshalChannelClassification(val)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		case "resource":
			l.Resource, err = unmarshalChannelClassification(val)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &l.SKU)
			delete(rawMsg, key)
		case "setting":
			err = unpopulate(val, &l.Setting)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &l.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &l.Type)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, &l.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetChannel implements the ChannelClassification interface for type MsTeamsChannel.
func (m *MsTeamsChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       m.ChannelName,
		Etag:              m.Etag,
		ProvisioningState: m.ProvisioningState,
		Location:          m.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MsTeamsChannel.
func (m MsTeamsChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "MsTeamsChannel"
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "provisioningState", m.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MsTeamsChannel.
func (m *MsTeamsChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &m.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &m.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &m.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &m.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationEntityListResult.
func (o OperationEntityListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OperationResultsDescription.
func (o OperationResultsDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populateTimeRFC3339(objectMap, "startTime", o.StartTime)
	populate(objectMap, "status", o.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationResultsDescription.
func (o *OperationResultsDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &o.Name)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &o.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &o.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "kind", r.Kind)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "sku", r.SKU)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	populate(objectMap, "zones", r.Zones)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ServiceProviderProperties.
func (s ServiceProviderProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "devPortalUrl", s.DevPortalURL)
	populate(objectMap, "displayName", s.DisplayName)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "iconUrl", s.IconURL)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "serviceProviderName", s.ServiceProviderName)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ServiceProviderResponseList.
func (s ServiceProviderResponseList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Site.
func (s Site) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eTag", s.ETag)
	populate(objectMap, "isBlockUserUploadEnabled", s.IsBlockUserUploadEnabled)
	populate(objectMap, "isEnabled", s.IsEnabled)
	populate(objectMap, "isSecureSiteEnabled", s.IsSecureSiteEnabled)
	populate(objectMap, "isTokenEnabled", s.IsTokenEnabled)
	populate(objectMap, "isV1Enabled", s.IsV1Enabled)
	populate(objectMap, "isV3Enabled", s.IsV3Enabled)
	populate(objectMap, "isWebchatPreviewEnabled", s.IsWebchatPreviewEnabled)
	populate(objectMap, "key", s.Key)
	populate(objectMap, "key2", s.Key2)
	populate(objectMap, "siteId", s.SiteID)
	populate(objectMap, "siteName", s.SiteName)
	populate(objectMap, "trustedOrigins", s.TrustedOrigins)
	return json.Marshal(objectMap)
}

// GetChannel implements the ChannelClassification interface for type SkypeChannel.
func (s *SkypeChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       s.ChannelName,
		Etag:              s.Etag,
		ProvisioningState: s.ProvisioningState,
		Location:          s.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SkypeChannel.
func (s SkypeChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "SkypeChannel"
	populate(objectMap, "etag", s.Etag)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SkypeChannel.
func (s *SkypeChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &s.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &s.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &s.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetChannel implements the ChannelClassification interface for type SlackChannel.
func (s *SlackChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       s.ChannelName,
		Etag:              s.Etag,
		ProvisioningState: s.ProvisioningState,
		Location:          s.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SlackChannel.
func (s SlackChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "SlackChannel"
	populate(objectMap, "etag", s.Etag)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SlackChannel.
func (s *SlackChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &s.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &s.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &s.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetChannel implements the ChannelClassification interface for type SmsChannel.
func (s *SmsChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       s.ChannelName,
		Etag:              s.Etag,
		ProvisioningState: s.ProvisioningState,
		Location:          s.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SmsChannel.
func (s SmsChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "SmsChannel"
	populate(objectMap, "etag", s.Etag)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SmsChannel.
func (s *SmsChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &s.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &s.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &s.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetChannel implements the ChannelClassification interface for type TelegramChannel.
func (t *TelegramChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       t.ChannelName,
		Etag:              t.Etag,
		ProvisioningState: t.ProvisioningState,
		Location:          t.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TelegramChannel.
func (t TelegramChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "TelegramChannel"
	populate(objectMap, "etag", t.Etag)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "provisioningState", t.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TelegramChannel.
func (t *TelegramChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &t.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &t.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &t.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &t.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &t.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetChannel implements the ChannelClassification interface for type WebChatChannel.
func (w *WebChatChannel) GetChannel() *Channel {
	return &Channel{
		ChannelName:       w.ChannelName,
		Etag:              w.Etag,
		ProvisioningState: w.ProvisioningState,
		Location:          w.Location,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WebChatChannel.
func (w WebChatChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["channelName"] = "WebChatChannel"
	populate(objectMap, "etag", w.Etag)
	populate(objectMap, "location", w.Location)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebChatChannel.
func (w *WebChatChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelName":
			err = unpopulate(val, &w.ChannelName)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &w.Etag)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &w.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &w.Properties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &w.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebChatChannelProperties.
func (w WebChatChannelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "sites", w.Sites)
	populate(objectMap, "webChatEmbedCode", w.WebChatEmbedCode)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
